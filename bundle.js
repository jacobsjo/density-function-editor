/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/deepslate/dist/deepslate.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/deepslate/dist/deepslate.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlendedNoise": () => (/* binding */ Y),
/* harmony export */   "BlockColors": () => (/* binding */ nt),
/* harmony export */   "BlockDefinition": () => (/* binding */ lt),
/* harmony export */   "BlockModel": () => (/* binding */ ft),
/* harmony export */   "BlockPos": () => (/* binding */ o),
/* harmony export */   "BlockState": () => (/* binding */ B),
/* harmony export */   "Chunk": () => (/* binding */ C),
/* harmony export */   "ChunkPos": () => (/* binding */ I),
/* harmony export */   "ChunkSection": () => (/* binding */ E),
/* harmony export */   "Climate": () => (/* binding */ yt),
/* harmony export */   "Direction": () => (/* binding */ n),
/* harmony export */   "FixedBiome": () => (/* binding */ Rt),
/* harmony export */   "ImprovedNoise": () => (/* binding */ V),
/* harmony export */   "Json": () => (/* binding */ k),
/* harmony export */   "MultiNoise": () => (/* binding */ _t),
/* harmony export */   "NbtReader": () => (/* binding */ h),
/* harmony export */   "NbtWriter": () => (/* binding */ u),
/* harmony export */   "NoiseChunkGenerator": () => (/* binding */ Nt),
/* harmony export */   "NoiseGeneratorSettings": () => (/* binding */ Ct),
/* harmony export */   "NoiseInterpolator": () => (/* binding */ Ft),
/* harmony export */   "NoiseOctaves": () => (/* binding */ kt),
/* harmony export */   "NoiseParameters": () => (/* binding */ R),
/* harmony export */   "NoiseSampler": () => (/* binding */ Mt),
/* harmony export */   "NoiseSamplingSettings": () => (/* binding */ Bt),
/* harmony export */   "NoiseSettings": () => (/* binding */ St),
/* harmony export */   "NoiseSlideSettings": () => (/* binding */ Et),
/* harmony export */   "NormalNoise": () => (/* binding */ X),
/* harmony export */   "PerlinNoise": () => (/* binding */ j),
/* harmony export */   "PerlinSimplexNoise": () => (/* binding */ H),
/* harmony export */   "Random": () => (/* binding */ W),
/* harmony export */   "SimplexNoise": () => (/* binding */ z),
/* harmony export */   "Spline": () => (/* binding */ Z),
/* harmony export */   "Structure": () => (/* binding */ _),
/* harmony export */   "StructureRenderer": () => (/* binding */ wt),
/* harmony export */   "StructureSettings": () => (/* binding */ It),
/* harmony export */   "TerrainShaper": () => (/* binding */ At),
/* harmony export */   "TextureAtlas": () => (/* binding */ xt),
/* harmony export */   "WorldgenRandom": () => (/* binding */ J),
/* harmony export */   "binarySearch": () => (/* binding */ L),
/* harmony export */   "clamp": () => (/* binding */ M),
/* harmony export */   "clampedLerp": () => (/* binding */ U),
/* harmony export */   "getListTag": () => (/* binding */ A),
/* harmony export */   "getOptional": () => (/* binding */ S),
/* harmony export */   "getTag": () => (/* binding */ y),
/* harmony export */   "lerp": () => (/* binding */ N),
/* harmony export */   "lerp2": () => (/* binding */ T),
/* harmony export */   "lerp3": () => (/* binding */ O),
/* harmony export */   "read": () => (/* binding */ f),
/* harmony export */   "readChunk": () => (/* binding */ p),
/* harmony export */   "readCompressed": () => (/* binding */ d),
/* harmony export */   "readRegion": () => (/* binding */ g),
/* harmony export */   "readUncompressed": () => (/* binding */ c),
/* harmony export */   "smoothstep": () => (/* binding */ D),
/* harmony export */   "square": () => (/* binding */ F),
/* harmony export */   "tagNames": () => (/* binding */ l),
/* harmony export */   "tagTypes": () => (/* binding */ a),
/* harmony export */   "write": () => (/* binding */ b),
/* harmony export */   "writeChunk": () => (/* binding */ P),
/* harmony export */   "writeCompressed": () => (/* binding */ v),
/* harmony export */   "writeRegion": () => (/* binding */ w),
/* harmony export */   "writeUncompressed": () => (/* binding */ m)
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/common.js");
var n;!function(t){t.UP="up",t.DOWN="down",t.NORTH="north",t.EAST="east",t.SOUTH="south",t.WEST="west"}(n||(n={}));const r={[n.UP]:[0,1,0],[n.DOWN]:[0,-1,0],[n.NORTH]:[0,0,-1],[n.EAST]:[1,0,0],[n.SOUTH]:[0,0,1],[n.WEST]:[-1,0,0]};var o;!function(t){t.ALL=[t.UP,t.DOWN,t.NORTH,t.EAST,t.SOUTH,t.WEST],t.normal=function(t){return r[t]}}(n||(n={})),function(t){t.create=function(t,e,s){return[t,e,s]},t.offset=function(t,e,s,i){return[t[0]+e,t[1]+s,t[2]+i]},t.towards=function(e,s){return t.offset(e,...n.normal(s))}}(o||(o={}));const a={end:0,byte:1,short:2,int:3,long:4,float:5,double:6,byteArray:7,string:8,list:9,compound:10,intArray:11,longArray:12},l=["end","byte","short","int","long","float","double","byteArray","string","list","compound","intArray","longArray"];class h{constructor(t,e=!1){this.byte=this.readNum.bind(this,"getInt8",1),this.short=this.readNum.bind(this,"getInt16",2),this.int=this.readNum.bind(this,"getInt32",4),this.float=this.readNum.bind(this,"getFloat32",4),this.double=this.readNum.bind(this,"getFloat64",8),this.offset=0,this.littleEndian=e,this.arrayView=t,this.dataView=new DataView(t.buffer,t.byteOffset)}end(){return null}readNum(t,e){const s=this.dataView[t](this.offset,this.littleEndian);return this.offset+=e,s}long(){return[this.int(),this.int()]}byteArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.byte());return e}intArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.int());return e}longArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.long());return e}string(){const t=this.short(),e=this.arrayView.slice(this.offset,this.offset+t);return this.offset+=t,function(t){var e,s=[];for(e=0;e<t.length;e++)0==(128&t[e])?s.push(127&t[e]):e+1<t.length&&192==(224&t[e])&&128==(192&t[e+1])?s.push((31&t[e])<<6|63&t[e+1]):e+2<t.length&&224==(240&t[e])&&128==(192&t[e+1])&&128==(192&t[e+2])?s.push((15&t[e])<<12|(63&t[e+1])<<6|63&t[e+2]):e+3<t.length&&240==(248&t[e])&&128==(192&t[e+1])&&128==(192&t[e+2])&&128==(192&t[e+3])&&s.push((7&t[e])<<18|(63&t[e+1])<<12|(63&t[e+2])<<6|63&t[e+3]);return String.fromCharCode.apply(null,s)}(e)}list(){const t=l[this.byte()],e=this.int(),s=[];for(let i=0;i<e;i++)s.push(this[t]());return{type:t,value:s}}compound(){const t={};for(;;){const e=l[this.byte()];if("end"===e)break;const s=this.string(),i=this[e]();t[s]={type:e,value:i}}return t}}class u{constructor(t=!1){this.byte=this.writeNum.bind(this,"setInt8",1),this.short=this.writeNum.bind(this,"setInt16",2),this.int=this.writeNum.bind(this,"setInt32",4),this.float=this.writeNum.bind(this,"setFloat32",4),this.double=this.writeNum.bind(this,"setFloat64",8),this.offset=0,this.littleEndian=t,this.buffer=new ArrayBuffer(1024),this.arrayView=new Uint8Array(this.buffer),this.dataView=new DataView(this.buffer)}accommodate(t){const e=this.offset+t;if(this.buffer.byteLength>=e)return;let s=this.buffer.byteLength;for(;s<e;)s*=2;const i=new ArrayBuffer(s),n=new Uint8Array(i);n.set(this.arrayView),this.offset>this.buffer.byteLength&&n.fill(0,this.buffer.byteLength,this.offset),this.buffer=i,this.dataView=new DataView(i),this.arrayView=n}getData(){return this.accommodate(0),this.arrayView.slice(0,this.offset)}end(t){}writeNum(t,e,s){this.accommodate(e),this.dataView[t](this.offset,s,this.littleEndian),this.offset+=e}long(t){this.int(t[0]),this.int(t[1])}byteArray(t){this.int(t.length),this.accommodate(t.length),this.arrayView.set(t,this.offset),this.offset+=t.length}intArray(t){this.int(t.length);for(let e=0;e<t.length;e++)this.int(t[e])}longArray(t){this.int(t.length);for(let e=0;e<t.length;e++)this.long(t[e])}string(t){const e=function(t){var e,s,i=[];for(e=0;e<t.length;e++)(s=t.charCodeAt(e))<128?i.push(s):s<2048?(i.push(192|s>>6),i.push(128|63&s)):s<65536?(i.push(224|s>>12),i.push(128|s>>6&63),i.push(128|63&s)):(i.push(240|s>>18&7),i.push(128|s>>12&63),i.push(128|s>>6&63),i.push(128|63&s));return i}(t);this.short(e.length),this.accommodate(e.length),this.arrayView.set(e,this.offset),this.offset+=e.length}list(t){this.byte(a[t.type]),this.int(t.value.length),t.value;for(let e=0;e<t.value.length;e++)this[t.type](t.value[e])}compound(t){for(const e in t)this.byte(a[t[e].type]),this.string(e),this[t[e].type](t[e].value);this.byte(a.end)}}function c(t,e){const s=new h(t,e);if(s.byte()!==a.compound)throw new Error("Top tag should be a compound");return{name:s.string(),value:s.compound()}}function d(e,s){return c(pako__WEBPACK_IMPORTED_MODULE_0__["default"].inflate(e),s)}function f(t,e){return 2===(s=new Uint8Array(t.slice(0,2))).length&&31===s[0]&&139===s[1]?{compressed:!0,result:d(t,e)}:{compressed:!1,result:c(t,e)};var s}function g(t){const e=[];for(let s=0;s<32;s+=1)for(let i=0;i<32;i+=1){const n=4*((31&s)+32*(31&i));if(0===t[n+3])continue;const r=(t[n]<<16)+(t[n+1]<<8)+t[n+2],o=(t[n+4096]<<24)+(t[n+4097]<<16)+(t[n+4098]<<8)+t[n+4099],a=4096*r,l=(t[a]<<24)+(t[a+1]<<16)+(t[a+2]<<8)+t[a+3],h=t[a+4],u=t.slice(a+5,a+4+l);e.push({x:s,z:i,timestamp:o,compression:h,data:u})}return e}function p(t,e,s){const i=x(t,e,s);switch(i.compression){case 1:case 2:i.nbt=d(i.data);break;case 3:i.nbt=c(i.data);break;default:throw new Error(`Invalid compression mode ${i.compression}`)}return i}function m(t,e){const s=new u(e);return s.byte(a.compound),s.string(t.name),s.compound(t.value),s.getData()}function v(e,s,i){const n=m(e,s);return pako__WEBPACK_IMPORTED_MODULE_0__["default"][i?"deflate":"gzip"](n)}function b(t,e,s){return e?v(t,s):m(t,s)}function w(t){let e=0;for(const s of t)e+=Math.ceil(s.data.length/4096);const s=new Uint8Array(8192+4096*e),i=new DataView(s.buffer);let n=2;for(const e of t){const t=4*((31&e.x)+32*(31&e.z)),r=Math.ceil(e.data.length/4096);i.setInt8(t,n>>16),i.setInt16(t+1,65535&n),i.setInt8(t+3,r),i.setInt32(t+4096,e.timestamp);const o=4096*n;i.setInt32(o,e.data.length+1),i.setInt8(o+4,e.compression),s.set(e.data,o+5),n+=r}return s}function P(t,e,s,i){const n=x(t,e,s);switch(n.compression){case 1:n.data=v(i);break;case 2:n.data=v(i,!1,!0);break;case 3:n.data=m(i);break;default:throw new Error(`Invalid compression mode ${n.compression}`)}return n}function x(t,e,s){const i=t.find((t=>t.x===e&&t.z===s));if(void 0===i)throw new Error(`Cannot find chunk [${e}, ${s}]`);return i}function y(t,e,s){if(!t[e])throw new Error(`Missing ${e} tag`);if(t[e].type!==s)throw new Error(`Expected ${e} to be of type ${s}, but found ${t[e].type}`);return t[e].value}function A(t,e,s,i){const n=y(t,e,"list");if(n.type!==s)throw new Error(`Expected ${e} to be a list of ${s}s, but found ${n.type}s`);if(i&&n.value.length!==i)throw new Error(`Expected ${e} to be a list of length ${i}, but found length ${n.value.length}`);return n.value}function S(t,e){try{return t()}catch(t){return e}}class B{constructor(t,e={}){this.name=t,this.properties=e}getName(){return this.name}getProperties(){return this.properties}getProperty(t){return this.properties[t]}isFluid(){return"minecraft:water"===this.name||"minecraft:lava"===this.name}equals(t){return this.name===t.name&&Object.keys(this.properties).every((e=>t.properties[e]===this.properties[e]))}toString(){return 0===Object.keys(this.properties).length?this.name:`${this.name}[${Object.entries(this.properties).map((([t,e])=>t+"="+e)).join(",")}]`}static fromNbt(t){const e=y(t.value,"Name","string"),s=S((()=>y(t.value,"Properties","compound")),{}),i=Object.keys(s).reduce(((t,e)=>Object.assign(Object.assign({},t),{[e]:y(s,e,"string")})),{});return new B(e,i)}static fromJson(t){var e,s;const i=null!==(e=k.readObject(t))&&void 0!==e?e:{},n=null!==(s=k.readString(i.Name))&&void 0!==s?s:"minecraft:stone",r=k.readMap(i.Properties,(t=>{var e;return null!==(e=k.readString(t))&&void 0!==e?e:""}));return new B(n,r)}}B.AIR=new B("minecraft:air");class E{constructor(t){this.minY=t,this.storage=Array(E.SIZE),this.palette=[B.AIR]}get minBlockY(){return this.minY<<4}index(t,e,s){return(t<<8)+(e<<4)+s}getBlockState(t,e,s){var i;const n=this.storage[this.index(t,e,s)];return null!==(i=this.palette[n])&&void 0!==i?i:B.AIR}setBlockState(t,e,s,i){let n=this.palette.findIndex((t=>t.equals(i)));-1===n&&(n=this.palette.length,this.palette.push(i)),this.storage[this.index(t,e,s)]=n}}E.WIDTH=16,E.SIZE=E.WIDTH*E.WIDTH*E.WIDTH;class C{constructor(t,e,s){this.minY=t,this.height=e,this.pos=s,this.sections=Array(this.sectionsCount).fill(null)}get maxY(){return this.minY+this.height}get minSection(){return this.minY>>4}get maxSection(){return 1+(this.maxY-1>>4)}get sectionsCount(){return this.maxSection-this.minSection}getSectionIndex(t){return(t>>4)-this.minSection}getBlockState(t){var e;const[s,i,n]=t,r=this.sections[this.getSectionIndex(i)];return null!==(e=null==r?void 0:r.getBlockState(15&s,15&i,15&n))&&void 0!==e?e:B.AIR}setBlockState(t,e){const[s,i,n]=t,r=this.getSectionIndex(i);let o=this.sections[r];if(null===o){if(e.equals(B.AIR))return;o=this.getOrCreateSection(r)}o.setBlockState(15&s,15&i,15&n,e)}getOrCreateSection(t){return null==this.sections[t]&&(this.sections[t]=new E(this.minSection+t)),this.sections[t]}}var I,k,R;!function(t){t.create=function(t,e){return[t,e]},t.fromBlockPos=function(t){return[t[0]>>4,t[2]>>4]},t.fromLong=function(t){return[4294967295&Number(t),Number(t>>BigInt(32))]},t.minBlockX=function(t){return t[0]<<4},t.minBlockZ=function(t){return t[1]<<4},t.maxBlockX=function(t){return t[0]<<19},t.maxBlockZ=function(t){return t[1]<<19}}(I||(I={})),function(t){function e(t){return"object"==typeof t&&null!==t?t:void 0}t.readNumber=function(t){return"number"==typeof t?t:void 0},t.readInt=function(t){return"number"==typeof t?Math.floor(t):void 0},t.readString=function(t){return"string"==typeof t?t:void 0},t.readBoolean=function(t){return"boolean"==typeof t?t:void 0},t.readObject=e,t.readArray=function(t,e){if(Array.isArray(t))return t.map((t=>e(t)))},t.readMap=function(t,s){var i;const n=null!==(i=e(t))&&void 0!==i?i:{};return Object.fromEntries(Object.entries(n).map((([t,e])=>[t,s(e)])))},t.compose=function(t,e,s){const i=e(t);return i?s(i):void 0}}(k||(k={}));class _{constructor(t,e=[],s=[]){this.size=t,this.palette=e,this.blocks=s,this.blocksMap=[],s.forEach((e=>{if(!this.isInside(e.pos))throw new Error(`Found block at ${e.pos} which is outside the structure bounds ${this.size}`);this.blocksMap[e.pos[0]*t[1]*t[2]+e.pos[1]*t[2]+e.pos[2]]=e}))}getSize(){return this.size}addBlock(t,e,s,i){if(!this.isInside(t))throw new Error(`Cannot add block at ${t} outside the structure bounds ${this.size}`);const n=new B(e,s);let r=this.palette.findIndex((t=>t.equals(n)));return-1===r&&(r=this.palette.length,this.palette.push(n)),this.blocks.push({pos:t,state:r,nbt:i}),this.blocksMap[t[0]*this.size[1]*this.size[2]+t[1]*this.size[2]+t[2]]={pos:t,state:r,nbt:i},this}getBlocks(){return this.blocks.map((t=>({pos:t.pos,state:this.palette[t.state],nbt:t.nbt})))}getBlock(t){if(!this.isInside(t))return null;const e=this.blocksMap[t[0]*this.size[1]*this.size[2]+t[1]*this.size[2]+t[2]];if(!e)return null;return{pos:e.pos,state:this.palette[e.state],nbt:e.nbt}}isInside(t){return t[0]>=0&&t[0]<this.size[0]&&t[1]>=0&&t[1]<this.size[1]&&t[2]>=0&&t[2]<this.size[2]}static fromNbt(t){const e=A(t.value,"size","int",3),s=A(t.value,"palette","compound").map((t=>B.fromNbt({name:"",value:t}))),i=A(t.value,"blocks","compound").map((t=>({pos:A(t,"pos","int",3),state:y(t,"state","int"),nbt:S((()=>y(t,"nbt","compound")),void 0)})));return new _(e,s,i)}}function F(t){return t*t}function M(t,e,s){return Math.max(e,Math.min(s,t))}function N(t,e,s){return e+t*(s-e)}function T(t,e,s,i,n,r){return N(e,N(t,s,i),N(t,n,r))}function O(t,e,s,i,n,r,o,a,l,h,u){return N(s,T(t,e,i,n,r,o),T(t,e,a,l,h,u))}function U(t,e,s){return s<0?t:s>1?e:N(s,t,e)}function D(t){return t*t*t*(t*(6*t-15)+10)}function L(t,e,s){let i=e-t;for(;i>0;){const e=Math.floor(i/2),n=t+e;s(n)?i=e:(t=n+1,i-=e+1)}return t}class z{constructor(t){this.xo=256*t.nextDouble(),this.yo=256*t.nextDouble(),this.zo=256*t.nextDouble(),this.p=Array(256);for(let t=0;t<256;t+=1)this.p[t]=t;for(let e=0;e<256;e+=1){const s=t.nextInt(256-e),i=this.p[e];this.p[e]=this.p[e+s],this.p[e+s]=i}}sample2D(t,e){let s,i,n;const r=(t+e)*z.F2,o=Math.floor(t+r),a=t-(o-(s=(o+(i=Math.floor(e+r)))*z.G2));let l,h;a>(n=e-(i-s))?(l=1,h=0):(l=0,h=1);const u=a-l+z.G2,c=n-h+z.G2,d=a-1+2*z.G2,f=n-1+2*z.G2,g=255&o,p=255&i,m=this.P(g+this.P(p))%12,v=this.P(g+l+this.P(p+h))%12,b=this.P(g+1+this.P(p+1))%12;return 70*(this.getCornerNoise3D(m,a,n,0,.5)+this.getCornerNoise3D(v,u,c,0,.5)+this.getCornerNoise3D(b,d,f,0,.5))}sample(t,e,s){const i=.3333333333333333*(t+e+s),n=Math.floor(t+i),r=Math.floor(e+i),o=Math.floor(s+i),a=.16666666666666666*(n+r+o),l=t-(n-a),h=e-(r-a),u=s-(o-a);let c,d,f,g,p,m;l>=h?h>=u?(c=1,d=0,f=0,g=1,p=1,m=0):l>=u?(c=1,d=0,f=0,g=1,p=0,m=1):(c=0,d=0,f=1,g=1,p=0,m=1):h<u?(c=0,d=0,f=1,g=0,p=1,m=1):l<u?(c=0,d=1,f=0,g=0,p=1,m=1):(c=0,d=1,f=0,g=1,p=1,m=0);const v=l-c+.16666666666666666,b=h-d+.16666666666666666,w=u-f+.16666666666666666,P=l-g+.3333333333333333,x=h-p+.3333333333333333,y=u-m+.3333333333333333,A=l-.5,S=h-.5,B=u-.5,E=255&n,C=255&r,I=255&o,k=this.P(E+this.P(C+this.P(I)))%12,R=this.P(E+c+this.P(C+d+this.P(I+f)))%12,_=this.P(E+g+this.P(C+p+this.P(I+m)))%12,F=this.P(E+1+this.P(C+1+this.P(I+1)))%12;return 32*(this.getCornerNoise3D(k,l,h,u,.6)+this.getCornerNoise3D(R,v,b,w,.6)+this.getCornerNoise3D(_,P,x,y,.6)+this.getCornerNoise3D(F,A,S,B,.6))}P(t){return this.p[255&t]}getCornerNoise3D(t,e,s,i,n){let r,o=n-e*e-s*s-i*i;return o<0?r=0:(o*=o,r=o*o*z.gradDot(t,e,s,i)),r}static gradDot(t,e,s,i){const n=z.GRADIENT[15&t];return n[0]*e+n[1]*s+n[2]*i}}z.GRADIENT=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1],[1,1,0],[0,-1,1],[-1,1,0],[0,-1,-1]],z.F2=.5*(Math.sqrt(3)-1),z.G2=(3-Math.sqrt(3))/6;class V{constructor(t){this.xo=256*t.nextDouble(),this.yo=256*t.nextDouble(),this.zo=256*t.nextDouble(),this.p=Array(256);for(let t=0;t<256;t+=1)this.p[t]=t>127?t-256:t;for(let e=0;e<256;e+=1){const s=t.nextInt(256-e),i=this.p[e];this.p[e]=this.p[e+s],this.p[e+s]=i}}sample(t,e,s,i=0,n=0){const r=t+this.xo,o=e+this.yo,a=s+this.zo,l=Math.floor(r),h=Math.floor(o),u=Math.floor(a),c=r-l,d=o-h,f=a-u;let g=0;if(0!==i){const t=n>=0&&n<d?n:d;g=Math.floor(t/i+1e-7)*i}return this.sampleAndLerp(l,h,u,c,d-g,f,d)}sampleAndLerp(t,e,s,i,n,r,o){const a=this.P(t),l=this.P(t+1),h=this.P(a+e),u=this.P(a+e+1),c=this.P(l+e),d=this.P(l+e+1),f=z.gradDot(this.P(h+s),i,n,r),g=z.gradDot(this.P(c+s),i-1,n,r),p=z.gradDot(this.P(u+s),i,n-1,r),m=z.gradDot(this.P(d+s),i-1,n-1,r),v=z.gradDot(this.P(h+s+1),i,n,r-1),b=z.gradDot(this.P(c+s+1),i-1,n,r-1),w=z.gradDot(this.P(u+s+1),i,n-1,r-1),P=z.gradDot(this.P(d+s+1),i-1,n-1,r-1);return O(D(i),D(o),D(r),f,g,p,m,v,b,w,P)}P(t){return 255&this.p[255&t]}}class j{constructor(t,e,s){if(1-e<s.length)throw new Error("Positive octaves are not allowed");this.noiseLevels=Array(s.length);for(let i=-e;i>=0;i-=1)i<s.length&&0!==s[i]?this.noiseLevels[i]=new V(t):t.consume(262);this.amplitudes=s,this.lowestFreqInputFactor=Math.pow(2,e),this.lowestFreqValueFactor=Math.pow(2,s.length-1)/(Math.pow(2,s.length)-1)}sample(t,e,s,i=0,n=0,r=!1){let o=0,a=this.lowestFreqInputFactor,l=this.lowestFreqValueFactor;for(let h=0;h<this.noiseLevels.length;h+=1){const u=this.noiseLevels[h];u&&(o+=this.amplitudes[h]*l*u.sample(j.wrap(t*a),r?-u.yo:j.wrap(e*a),j.wrap(s*a),i*a,n*a)),a*=2,l/=2}return o}getOctaveNoise(t){return this.noiseLevels[this.noiseLevels.length-1-t]}static wrap(t){return t-33554432*Math.floor(t/33554432+.5)}}class Y{constructor(t){this.minLimitNoise=new j(t,-15,[1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0]),this.maxLimitNoise=new j(t,-15,[1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0]),this.mainNoise=new j(t,-7,[1,1,1,1,1,0,0,0])}sample(t,e,s,i,n,r,o){let a,l=0,h=1;for(let i=0;i<8;i+=1){if(a=this.mainNoise.getOctaveNoise(i),a){const i=r*h,n=o*h,u=j.wrap(t*i),c=j.wrap(e*n),d=j.wrap(s*i);l+=a.sample(u,c,d,n,e*n)/h}h/=2}l=(l/10+1)/2,h=1;let u=0,c=0;for(let r=0;r<16;r+=1){const o=i*h,d=n*h,f=j.wrap(t*o),g=j.wrap(e*d),p=j.wrap(s*o);l<1&&(a=this.minLimitNoise.getOctaveNoise(r))&&(u+=a.sample(f,g,p,d,e*d)/h),l>0&&(a=this.maxLimitNoise.getOctaveNoise(r))&&(c+=a.sample(f,g,p,d,e*d)/h),h/=2}return U(u/512,c/512,l)}}class X{constructor(t,{firstOctave:e,amplitudes:s}){this.first=new j(t,e,s),this.second=new j(t,e,s);let i=1/0,n=-1/0;for(let t=0;t<s.length;t+=1)0!==s[t]&&(i=Math.min(i,t),n=Math.max(n,t));const r=.1*(1+1/(n-i+1));this.valueFactor=1/6/r}sample(t,e,s){const i=t*X.INPUT_FACTOR,n=e*X.INPUT_FACTOR,r=s*X.INPUT_FACTOR;return(this.first.sample(t,e,s)+this.second.sample(i,n,r))*this.valueFactor}}X.INPUT_FACTOR=1.0181268882175227,function(t){t.fromJson=function(t){var e,s,i;const n=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{firstOctave:null!==(s=k.readInt(n.firstOctave))&&void 0!==s?s:0,amplitudes:null!==(i=k.readArray(n.amplitudes,(t=>{var e;return null!==(e=k.readNumber(t))&&void 0!==e?e:0})))&&void 0!==i?i:[]}}}(R||(R={}));class H{constructor(t,e){const s=e[e.length-1],i=-e[0]+s+1,n=new Set(e),r=new z(t);this.noiseLevels=Array(i),s>=0&&s<i&&n.has(0)&&(this.noiseLevels[s]=r);for(let e=s+1;e<i;e+=1)e>=0&&n.has(s-e)?this.noiseLevels[e]=new z(t):t.consume(262);if(s>0)throw new Error("Positive octaves are not allowed");this.highestFreqInputFactor=Math.pow(2,s),this.highestFreqValueFactor=1/(Math.pow(2,i)-1)}sample(t,e,s){let i=0,n=this.highestFreqInputFactor,r=this.highestFreqValueFactor;for(let o=0;o<this.noiseLevels.length;o+=1){const a=this.noiseLevels[o];a&&(i+=r*a.sample2D(t*n+(s?a.xo:0),e*n+(s?a.yo:0))),n/=2,r*=2}return i}}class W{constructor(t){this.seed=BigInt(0),this.setSeed(t)}fork(){return new W(this.nextLong())}setSeed(t){this.seed=t^W.MULTIPLIER&W.MODULUS_MASK}advance(){this.seed=this.seed*W.MULTIPLIER+W.INCREMENT&W.MODULUS_MASK}consume(t){for(let e=0;e<t;e+=1)this.advance()}next(t){this.advance();const e=Number(this.seed>>BigInt(W.MODULUS_BITS-t));return e>2147483647?e-4294967296:e}nextInt(t){if(void 0===t)return this.next(32);if(0==(t&t-1))return Number(BigInt(t)*BigInt(this.next(31))>>BigInt(31));let e,s;for(;(e=this.next(31))-(s=e%t)+(t-1)<0;);return s}nextLong(){return(BigInt(this.next(32))<<BigInt(32))+BigInt(this.next(32))}nextFloat(){return this.next(24)*W.FLOAT_MULTIPLIER}nextDouble(){const t=this.next(30);return this.advance(),t*W.DOUBLE_MULTIPLIER}}W.MODULUS_BITS=48,W.MODULUS_MASK=BigInt("281474976710655"),W.MULTIPLIER=BigInt("25214903917"),W.INCREMENT=BigInt("11"),W.FLOAT_MULTIPLIER=1/Math.pow(2,24),W.DOUBLE_MULTIPLIER=1/Math.pow(2,30);class J extends W{constructor(){super(...arguments),this.count=0}getCount(){return this.count}next(t){return this.count+=1,super.next(t)}}class Z{constructor(t,e,s=[],i=[],n=[]){this.name=t,this.coordinate=e,this.locations=s,this.values=i,this.derivatives=n}apply(t){const e=this.coordinate(t),s=L(0,this.locations.length,(t=>e<this.locations[t]))-1,i=this.locations.length-1;if(s<0)return this.values[0](t)+this.derivatives[0]*(e-this.locations[0]);if(s===i)return this.values[i](t)+this.derivatives[i]*(e-this.locations[i]);const n=this.locations[s],r=this.locations[s+1],o=this.derivatives[s],a=this.derivatives[s+1],l=(e-n)/(r-n),h=this.values[s](t),u=this.values[s+1](t),c=o*(r-n)-(u-h),d=-a*(r-n)+(u-h);return N(l,h,u)+l*(1-l)*N(l,c,d)}addPoint(t,e,s=0){return this.locations.push(t),this.values.push("number"==typeof e?()=>e:e.apply.bind(e)),this.derivatives.push(s),this}}const $=t=>[(t>>16&255)/256,(t>>8&255)/256,(255&t)/256],G=[124/256,189/256,107/256],q=$(6396257),K=$(8431445),Q=$(4764952),tt=$(4159204),et=$(8431445),st=$(2129968),it=t=>[t/8,1-t/32,64*t],nt={large_fern:()=>G,tall_grass:()=>G,grass_block:()=>G,fern:()=>G,grass:()=>G,potted_fern:()=>G,spruce_leaves:()=>q,birch_leaves:()=>K,oak_leaves:()=>Q,jungle_leaves:()=>Q,acacia_leaves:()=>Q,dark_oak_leaves:()=>Q,vine:()=>Q,water:()=>tt,bubble_column:()=>tt,cauldron:()=>tt,redstone_wire:t=>{var e;return(t=>{const e=t/15;return[.6*e+(e>0?.4:.3),M(e*e*.7-.5,0,1),M(e*e*.6-.7,0,1)]})(parseInt(null!==(e=t.power)&&void 0!==e?e:"0"))},sugar_cane:()=>G,attached_melon_stem:()=>et,attached_pumpkin_stem:()=>et,melon_stem:t=>{var e;return it(parseInt(null!==(e=t.age)&&void 0!==e?e:"0"))},pumpkin_stem:t=>{var e;return it(parseInt(null!==(e=t.age)&&void 0!==e?e:"0"))},lily_pad:()=>st};var rt;function ot(...t){let e=0;for(const s of t)e+=s.length;const s=new Float32Array(e);let i=0;for(const e of t)s.set(e,i),i+=e.length;return s}function at(t,s){const i=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();for(let n=0;n<t.length;n+=3)i[0]=t[n],i[1]=t[n+1],i[2]=t[n+2],gl_matrix__WEBPACK_IMPORTED_MODULE_1__.transformMat4(i,i,s),t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2]}!function(t){t.rotate=function(t,e,s){let{up:i,down:n,north:r,east:o,south:a,west:l}=t;switch(s){case 90:[r,o,a,l]=[o,a,l,r];break;case 180:[r,o,a,l]=[a,l,r,o];break;case 270:[r,o,a,l]=[l,r,o,a]}switch(e){case 90:[i,r,n,a]=[r,n,a,i];break;case 180:[i,r,n,a]=[n,a,i,r];break;case 270:[i,r,n,a]=[a,i,r,n]}return{up:i,down:n,north:r,east:o,south:a,west:l}}}(rt||(rt={}));class lt{constructor(t,e,s){this.id=t,this.variants=e,this.multipart=s,this.variants=e}getModelVariants(t){if(this.variants){const e=Object.keys(this.variants).filter((e=>this.matchesVariant(e,t)));if(0===e.length)return[];const s=this.variants[e[0]];return[Array.isArray(s)?s[0]:s]}if(this.multipart){return this.multipart.filter((e=>!e.when||this.matchesCase(e.when,t))).map((t=>Array.isArray(t.apply)?t.apply[0]:t.apply))}return[]}getBuffers(t,e,n,r,o,a){var l,h,u,c;const d=this.getModelVariants(e),f=[],g=[],p=[],m=[];for(const v of d){const d=rt.rotate(a,null!==(l=v.x)&&void 0!==l?l:0,null!==(h=v.y)&&void 0!==h?h:0),b=r.getBlockModel(v.model).getBuffers(t,e,n,o,d);if(v.x||v.y){const t=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(t,t,[8,8,8]),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateY(t,t,-gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(null!==(u=v.y)&&void 0!==u?u:0)),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateX(t,t,-gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(null!==(c=v.x)&&void 0!==c?c:0)),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(t,t,[-8,-8,-8]),at(b.position,t)}f.push(b.position),g.push(...b.texCoord),p.push(...b.tintColor),m.push(...b.index),o+=b.texCoord.length/2}const v=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(v),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(v,v,[.0625,.0625,.0625]);const b=ot(...f);return at(b,v),{position:b,texCoord:g,tintColor:p,index:m}}matchesVariant(t,e){return t.split(",").every((t=>{const[s,i]=t.split("=");return e[s]===i}))}matchesCase(t,e){if(Array.isArray(t.OR))return t.OR.some((t=>this.matchesCase(t,e)));const s=t;return Object.keys(s).every((t=>s[t].split("|").includes(e[t])))}static fromJson(t,e){return new lt(t,e.variants,e.multipart)}}const ht={0:[0,3,2,3,2,1,0,1],90:[2,3,2,1,0,1,0,3],180:[2,1,0,1,0,3,2,3],270:[0,1,0,3,2,3,2,1]},ut={x:[1,0,0],y:[0,1,0],z:[0,0,1]},ct=1.41421356237,dt={x:[1,ct,ct],y:[ct,1,ct],z:[ct,ct,1]};class ft{constructor(t,e,s,i){this.id=t,this.parent=e,this.textures=s,this.elements=i,this.flattened=!1}getBuffers(t,e,s,i,n){var r;const o=[],a=[],l=[],h=[];for(const u of null!==(r=this.elements)&&void 0!==r?r:[]){const r=this.getElementBuffers(t,e,u,i,s,n);o.push(r.position),a.push(...r.texCoord),l.push(...r.tintColor),h.push(...r.index),i+=r.texCoord.length/2}return{position:ot(...o),texCoord:a,tintColor:l,index:h}}getElementBuffers(t,n,r,o,a,l){var h,u,c,d,f,g,p,m,v,b,w,P;const x=r.from[0],y=r.from[1],A=r.from[2],S=r.to[0],B=r.to[1],E=r.to[2],C=[],I=[],k=[],R=[],_=(e,s,i)=>{var r,l,h,u,c,d,f,g,p,m,v,b;const[w,P,x,y]=a.getTextureUV(this.getTexture(e.texture)),A=(x-w)/16,S=(y-P)/16,B=A/16,E=S/16;s[0]=(null!==(l=null===(r=e.uv)||void 0===r?void 0:r[0])&&void 0!==l?l:s[0])*A+B,s[1]=(null!==(u=null===(h=e.uv)||void 0===h?void 0:h[1])&&void 0!==u?u:s[1])*S+E,s[2]=(null!==(d=null===(c=e.uv)||void 0===c?void 0:c[2])&&void 0!==d?d:s[2])*A-B,s[3]=(null!==(g=null===(f=e.uv)||void 0===f?void 0:f[3])&&void 0!==g?g:s[3])*S-E;const _=ht[null!==(p=e.rotation)&&void 0!==p?p:0];I.push(w+s[_[0]],P+s[_[1]],w+s[_[2]],P+s[_[3]],w+s[_[4]],P+s[_[5]],w+s[_[6]],P+s[_[7]]);const F=(null!==(m=e.tintindex)&&void 0!==m?m:-1)>=0&&null!==(b=null===(v=nt[t.slice(10)])||void 0===v?void 0:v.call(nt,n))&&void 0!==b?b:[1,1,1];k.push(...F,...F,...F,...F),C.push(...i),R.push(o,o+1,o+2,o,o+2,o+3),o+=4};!(null===(u=null===(h=r.faces)||void 0===h?void 0:h.up)||void 0===u?void 0:u.texture)||r.faces.up.cullface&&l[r.faces.up.cullface]||_(r.faces.up,[x,16-E,S,16-A],[x,B,E,S,B,E,S,B,A,x,B,A]),!(null===(d=null===(c=r.faces)||void 0===c?void 0:c.down)||void 0===d?void 0:d.texture)||r.faces.down.cullface&&l[r.faces.down.cullface]||_(r.faces.down,[16-E,16-S,16-A,16-x],[x,y,A,S,y,A,S,y,E,x,y,E]),!(null===(g=null===(f=r.faces)||void 0===f?void 0:f.south)||void 0===g?void 0:g.texture)||r.faces.south.cullface&&l[r.faces.south.cullface]||_(r.faces.south,[x,16-B,S,16-y],[x,y,E,S,y,E,S,B,E,x,B,E]),!(null===(m=null===(p=r.faces)||void 0===p?void 0:p.north)||void 0===m?void 0:m.texture)||r.faces.north.cullface&&l[r.faces.north.cullface]||_(r.faces.north,[16-S,16-B,16-x,16-y],[S,y,A,x,y,A,x,B,A,S,B,A]),!(null===(b=null===(v=r.faces)||void 0===v?void 0:v.east)||void 0===b?void 0:b.texture)||r.faces.east.cullface&&l[r.faces.east.cullface]||_(r.faces.east,[16-E,16-B,16-A,16-y],[S,y,E,S,y,A,S,B,A,S,B,E]),!(null===(P=null===(w=r.faces)||void 0===w?void 0:w.west)||void 0===P?void 0:P.texture)||r.faces.west.cullface&&l[r.faces.west.cullface]||_(r.faces.west,[A,16-B,E,16-y],[x,y,A,x,y,E,x,B,E,x,B,A]);const F=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();if(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(F),r.rotation){const t=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(...r.rotation.origin);gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(F,F,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate(F,F,gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(r.rotation.angle),ut[r.rotation.axis]),r.rotation.rescale&&gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(F,F,dt[r.rotation.axis]),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.negate(t,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(F,F,t)}const M=new Float32Array(C);return at(M,F),{position:M,texCoord:I,tintColor:k,index:R}}getTexture(t){for(var e,s;t.startsWith("#");)t=null!==(s=null===(e=this.textures)||void 0===e?void 0:e[t.slice(1)])&&void 0!==s?s:"";return t.startsWith("minecraft:")||(t="minecraft:"+t),t}flatten(t){var e;if(!this.flattened&&this.parent){const s=t.getBlockModel(this.parent);if(!s)return console.warn(`parent ${this.parent} does not exist!`),void(this.flattened=!0);s.flatten(t),this.elements||(this.elements=s.elements),this.textures||(this.textures={}),Object.keys(null!==(e=s.textures)&&void 0!==e?e:{}).forEach((t=>{this.textures[t]||(this.textures[t]=s.textures[t])})),this.flattened=!0}}static fromJson(t,e){let s=e.parent;return s&&!s.startsWith("minecraft:")&&(s="minecraft:"+s),new ft(t,s,e.textures,e.elements)}}class gt{constructor(t,e,s){this.gl=t,this.program=this.initShaderProgram(e,s)}getProgram(){return this.program}initShaderProgram(t,e){const s=this.loadShader(this.gl.VERTEX_SHADER,t),i=this.loadShader(this.gl.FRAGMENT_SHADER,e),n=this.gl.createProgram();if(this.gl.attachShader(n,s),this.gl.attachShader(n,i),this.gl.linkProgram(n),!this.gl.getProgramParameter(n,this.gl.LINK_STATUS))throw new Error(`Unable to link shader program: ${this.gl.getProgramInfoLog(n)}`);return n}loadShader(t,e){const s=this.gl.createShader(t);if(this.gl.shaderSource(s,e),this.gl.compileShader(s),!this.gl.getShaderParameter(s,this.gl.COMPILE_STATUS)){const e=new Error(`Compiling ${t===this.gl.VERTEX_SHADER?"vertex":"fragment"} shader: ${this.gl.getShaderInfoLog(s)}`);throw this.gl.deleteShader(s),e}return s}}function pt(t,e,s,i,n){const r=new lt("",{"":{model:""}},void 0),o={getBlockModel:()=>n};return n.flatten(o),r.getBuffers(t,{},e,o,s,i)}function mt(t,e,s,i,r,o){const a=r.up?16:[14.2,12.5,10.5,9,7,5.3,3.7,1.9,16,16,16,16,16,16,16,16][s];return pt(`minecraft:${t}`,i,e,r,new ft("","",{still:`minecraft:block/${t}_still`,flow:`minecraft:block/${t}_flow`},[{from:[0,0,0],to:[16,a,16],faces:{up:{texture:"#still",tintindex:o,cullface:n.UP},down:{texture:"#still",tintindex:o,cullface:n.DOWN},north:{texture:"#flow",tintindex:o,cullface:n.NORTH},east:{texture:"#flow",tintindex:o,cullface:n.EAST},south:{texture:"#flow",tintindex:o,cullface:n.SOUTH},west:{texture:"#flow",tintindex:o,cullface:n.WEST}}}]))}const vt={"minecraft:water":(t,e,s,i)=>mt("water",t,parseInt(e.level),s,i,0),"minecraft:lava":(t,e,s,i)=>mt("lava",t,parseInt(e.level),s,i),"minecraft:chest":(t,e,s)=>function(t,e,s,i){return pt("minecraft:chest",i,t,{},new ft("","",{0:"minecraft:block/chest"},[{from:[1,0,1],to:[15,14,15],faces:{up:{texture:"#0"},down:{texture:"#0"},north:{texture:"#0"},east:{texture:"#0"},south:{texture:"#0"},west:{texture:"#0"}}}]))}(t,e.facing,e.type,s)},bt=new Set(Object.keys(vt));class wt{constructor(t,e,s,i){var n,r;this.gl=t,this.structure=e,this.resources=s,this.chunks=[],(null==i?void 0:i.facesPerBuffer)&&console.warn("webgl render warning: facesPerBuffer option has been removed in favor of chunkSize"),this.chunkSize=null!==(n=null==i?void 0:i.chunkSize)&&void 0!==n?n:16,this.useInvisibleBlockBuffer=null===(r=null==i?void 0:i.useInvisibleBlockBuffer)||void 0===r||r,this.shaderProgram=new gt(t,"\n  attribute vec4 vertPos;\n  attribute vec2 texCoord;\n  attribute vec3 tintColor;\n  attribute vec3 normal;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec2 vTexCoord;\n  varying highp vec3 vTintColor;\n  varying highp float vLighting;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vTexCoord = texCoord;\n    vTintColor = tintColor;\n    vLighting = normal.y * 0.2 + abs(normal.z) * 0.1 + 0.8;\n  }\n","\n  precision highp float;\n  varying highp vec2 vTexCoord;\n  varying highp vec3 vTintColor;\n  varying highp float vLighting;\n\n  uniform sampler2D sampler;\n\n  void main(void) {\n    vec4 texColor = texture2D(sampler, vTexCoord);\n    if(texColor.a < 0.01) discard;\n    gl_FragColor = vec4(texColor.xyz * vTintColor * vLighting, texColor.a);\n  }\n").getProgram(),this.gridShaderProgram=new gt(t,"\n  attribute vec4 vertPos;\n  attribute vec3 vertColor;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vColor = vertColor;\n  }\n","\n  precision highp float;\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n").getProgram(),this.colorShaderProgram=new gt(t,"\n  attribute vec4 vertPos;\n  attribute vec3 blockPos;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vColor = blockPos / 256.0;\n  }\n","\n  precision highp float;\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n").getProgram(),this.updateStructureBuffers(),this.gridBuffers=this.getGridBuffers(),this.outlineBuffers=this.getOutlineBuffers(),this.invisibleBlockBuffers=this.getInvisibleBlockBuffers(),this.atlasTexture=this.getBlockTexture(),this.projMatrix=this.getPerspective(),this.activeShader=this.shaderProgram,this.initialize()}setStructure(t){this.structure=t,this.updateStructureBuffers(),this.gridBuffers=this.getGridBuffers(),this.invisibleBlockBuffers=this.getInvisibleBlockBuffers()}initialize(){this.gl.enable(this.gl.DEPTH_TEST),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK)}getBlockTexture(){const t=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,this.resources.getTextureAtlas()),this.gl.generateMipmap(this.gl.TEXTURE_2D),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),t}getPerspective(){const t=70*Math.PI/180,e=this.gl.canvas.clientWidth/this.gl.canvas.clientHeight,i=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();return gl_matrix__WEBPACK_IMPORTED_MODULE_2__.perspective(i,t,e,.1,500),i}getChunk(t){const e=2*Math.abs(t[0])+(t[0]<0?1:0),s=2*Math.abs(t[1])+(t[1]<0?1:0),i=2*Math.abs(t[2])+(t[2]<0?1:0);return this.chunks[e]||(this.chunks[e]=[]),this.chunks[e][s]||(this.chunks[e][s]=[]),this.chunks[e][s][i]||(this.chunks[e][s][i]={positions:[],textureCoordinates:[],tintColors:[],blockPositions:[],normals:[],indices:[],indexOffset:0}),this.chunks[e][s][i]}updateStructureBuffers(t){var i;const r=(t,i,n)=>{const r=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(r,r,i),at(t.position,r),n.positions.push(t.position),n.textureCoordinates.push(...t.texCoord),n.tintColors.push(...t.tintColor);for(let s=0;s<t.position.length;s+=12){const i=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s],t.position[s+1],t.position[s+2]),r=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s+3],t.position[s+4],t.position[s+5]),o=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s+6],t.position[s+7],t.position[s+8]);gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(r,r,i),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(o,o,i),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.cross(r,r,o),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(r,r),n.normals.push(...r,...r,...r,...r)}for(let e=0;e<t.texCoord.length/2;e+=1)n.blockPositions.push(...i);n.indices.push(...t.index),n.indexOffset+=t.texCoord.length/2},o=t=>{t.positions=[],t.textureCoordinates=[],t.tintColors=[],t.blockPositions=[],t.normals=[],t.indices=[],t.indexOffset=0},a=t=>{t.buffer?(this.updateBuffer(t.buffer.position,this.gl.ARRAY_BUFFER,ot(...t.positions)),this.updateBuffer(t.buffer.texCoord,this.gl.ARRAY_BUFFER,new Float32Array(t.textureCoordinates)),this.updateBuffer(t.buffer.tintColor,this.gl.ARRAY_BUFFER,new Float32Array(t.tintColors)),this.updateBuffer(t.buffer.normal,this.gl.ARRAY_BUFFER,new Float32Array(t.normals)),this.updateBuffer(t.buffer.blockPos,this.gl.ARRAY_BUFFER,new Float32Array(t.blockPositions)),this.updateBuffer(t.buffer.index,this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t.indices)),t.buffer.length=t.indices.length):t.buffer={position:this.createBuffer(this.gl.ARRAY_BUFFER,ot(...t.positions)),texCoord:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.textureCoordinates)),tintColor:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.tintColors)),blockPos:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.blockPositions)),normal:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.normals)),index:this.createBuffer(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t.indices)),length:t.indices.length}};let l;t?t.forEach((t=>{const e=this.getChunk(t);o(e)})):this.chunks.forEach((t=>t.forEach((t=>t.forEach((t=>{o(t)}))))));for(const s of this.structure.getBlocks()){const o=s.state.getName(),a=s.state.getProperties(),h=null!==(i=this.resources.getDefaultBlockProperties(o))&&void 0!==i?i:{};Object.entries(h).forEach((([t,e])=>{a[t]||(a[t]=e)}));const u=[Math.floor(s.pos[0]/this.chunkSize),Math.floor(s.pos[1]/this.chunkSize),Math.floor(s.pos[2]/this.chunkSize)];if(t&&!t.some((t=>gl_matrix__WEBPACK_IMPORTED_MODULE_1__.equals(t,u))))continue;const c=this.getChunk(u);try{const t=this.resources.getBlockDefinition(o),e={up:this.needsCull(s,n.UP),down:this.needsCull(s,n.DOWN),west:this.needsCull(s,n.WEST),east:this.needsCull(s,n.EAST),north:this.needsCull(s,n.NORTH),south:this.needsCull(s,n.SOUTH)};t&&(l=t.getBuffers(o,a,this.resources,this.resources,c.indexOffset,e),r(l,s.pos,c)),bt.has(o)&&(l=vt[o](c.indexOffset,a,this.resources,e),r(l,s.pos,c))}catch(t){console.error(`Error rendering block ${o}`,t)}}t?t.forEach((t=>{const e=this.getChunk(t);a(e)})):this.chunks.forEach((t=>t.forEach((t=>t.forEach((t=>{a(t)}))))))}needsCull(t,e){var s,i;const r=null===(s=this.structure.getBlock(o.towards(t.pos,e)))||void 0===s?void 0:s.state;return!!r&&((null===(i=this.resources.getBlockFlags(r.getName()))||void 0===i?void 0:i.opaque)?!(e===n.UP&&t.state.isFluid()):t.state.isFluid()&&r.isFluid())}getGridBuffers(){const[t,e,s]=this.structure.getSize(),i=[],n=[];i.push(0,0,0,t,0,0),n.push(1,0,0,1,0,0),i.push(0,0,0,0,0,s),n.push(0,0,1,0,0,1),i.push(0,0,0,0,e,0),i.push(t,0,0,t,e,0),i.push(0,0,s,0,e,s),i.push(t,0,s,t,e,s),i.push(0,e,0,0,e,s),i.push(t,e,0,t,e,s),i.push(0,e,0,t,e,0),i.push(0,e,s,t,e,s);for(let e=1;e<=t;e+=1)i.push(e,0,0,e,0,s);for(let e=1;e<=s;e+=1)i.push(0,0,e,t,0,e);for(let e=0;e<8+t+s;e+=1)n.push(.8,.8,.8,.8,.8,.8);return{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(i)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(n)),length:i.length/3}}getOutlineBuffers(){const t=[],e=[];return this.addCube(t,e,[1,1,1],[0,0,0],[1,1,1]),{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(e)),length:t.length/3}}getInvisibleBlockBuffers(){if(!this.useInvisibleBlockBuffer)return;const t=this.structure.getSize(),e=[],s=[];for(let i=0;i<t[0];i+=1)for(let n=0;n<t[1];n+=1)for(let r=0;r<t[2];r+=1){const t=this.structure.getBlock([i,n,r]);void 0!==t&&(null===t?this.addCube(e,s,[1,.25,.25],[i+.4375,n+.4375,r+.4375],[i+.5625,n+.5625,r+.5625]):"minecraft:air"===t.state.getName()?this.addCube(e,s,[.5,.5,1],[i+.375,n+.375,r+.375],[i+.625,n+.625,r+.625]):"minecraft:cave_air"===t.state.getName()&&this.addCube(e,s,[.5,1,.5],[i+.375,n+.375,r+.375],[i+.625,n+.625,r+.625]))}return{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(e)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(s)),length:e.length/3}}addCube(t,e,s,i,n){t.push(i[0],i[1],i[2],i[0],i[1],n[2]),t.push(n[0],i[1],i[2],n[0],i[1],n[2]),t.push(i[0],i[1],i[2],n[0],i[1],i[2]),t.push(i[0],i[1],n[2],n[0],i[1],n[2]),t.push(i[0],i[1],i[2],i[0],n[1],i[2]),t.push(n[0],i[1],i[2],n[0],n[1],i[2]),t.push(i[0],i[1],n[2],i[0],n[1],n[2]),t.push(n[0],i[1],n[2],n[0],n[1],n[2]),t.push(i[0],n[1],i[2],i[0],n[1],n[2]),t.push(n[0],n[1],i[2],n[0],n[1],n[2]),t.push(i[0],n[1],i[2],n[0],n[1],i[2]),t.push(i[0],n[1],n[2],n[0],n[1],n[2]);for(let t=0;t<24;t+=1)e.push(...s)}createBuffer(t,e){const s=this.gl.createBuffer();return this.gl.bindBuffer(t,s),this.gl.bufferData(t,e,this.gl.DYNAMIC_DRAW),s}updateBuffer(t,e,s){this.gl.bindBuffer(e,t),this.gl.bufferData(e,s,this.gl.STATIC_DRAW)}drawGrid(t){this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.gridBuffers.position),this.setVertexAttr("vertColor",3,this.gridBuffers.color),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.gridBuffers.length)}drawInvisibleBlocks(t){this.useInvisibleBlockBuffer&&(this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.invisibleBlockBuffers.position),this.setVertexAttr("vertColor",3,this.invisibleBlockBuffers.color),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.invisibleBlockBuffers.length))}drawStructure(t){this.setShader(this.shaderProgram),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.atlasTexture),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.chunks.forEach((t=>{t.forEach((t=>{t.forEach((t=>{t.buffer&&(this.setVertexAttr("vertPos",3,t.buffer.position),this.setVertexAttr("texCoord",2,t.buffer.texCoord),this.setVertexAttr("tintColor",3,t.buffer.tintColor),this.setVertexAttr("normal",3,t.buffer.normal),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer.index),this.gl.drawElements(this.gl.TRIANGLES,t.buffer.length,this.gl.UNSIGNED_SHORT,0))}))}))}))}drawColoredStructure(t){this.setShader(this.colorShaderProgram),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.chunks.forEach((t=>{t.forEach((t=>{t.forEach((t=>{t.buffer&&(this.setVertexAttr("vertPos",3,t.buffer.position),this.setVertexAttr("blockPos",3,t.buffer.blockPos),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer.index),this.gl.drawElements(this.gl.TRIANGLES,t.buffer.length,this.gl.UNSIGNED_SHORT,0))}))}))}))}drawOutline(t,e){this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.outlineBuffers.position),this.setVertexAttr("vertColor",3,this.outlineBuffers.color);const i=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.copy(i,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(i,i,e),this.setUniform("mView",i),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.outlineBuffers.length)}setViewport(t,e,s,i){this.gl.viewport(t,e,s,i),this.projMatrix=this.getPerspective()}setShader(t){this.gl.useProgram(t),this.activeShader=t}setVertexAttr(t,e,s){const i=this.gl.getAttribLocation(this.activeShader,t);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s),this.gl.vertexAttribPointer(i,e,this.gl.FLOAT,!1,0,0),this.gl.enableVertexAttribArray(i)}setUniform(t,e){const s=this.gl.getUniformLocation(this.activeShader,t);this.gl.uniformMatrix4fv(s,!1,e)}}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function Pt(t,e,s,i){return new(s||(s=Promise))((function(n,r){function o(t){try{l(i.next(t))}catch(t){r(t)}}function a(t){try{l(i.throw(t))}catch(t){r(t)}}function l(t){var e;t.done?n(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(o,a)}l((i=i.apply(t,e||[])).next())}))}class xt{constructor(t,e){this.img=t,this.idMap=e,this.part=16/t.width}getTextureAtlas(){return this.img}getTextureUV(t){var e;return null!==(e=this.idMap[t])&&void 0!==e?e:[0,0,this.part,this.part]}static fromBlobs(t){return Pt(this,void 0,void 0,(function*(){const e=Math.sqrt(Object.keys(t).length+1),s=Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))),i=16*s,n=1/s,r=document.createElement("canvas");r.width=i,r.height=i;const o=r.getContext("2d");this.drawInvalidTexture(o);const a={};let l=1;return yield Promise.all(Object.keys(t).map((e=>Pt(this,void 0,void 0,(function*(){const i=l%s,r=Math.floor(l/s);l+=1,a[e]=[n*i,n*r,n*i+n,n*r+n];const h=yield createImageBitmap(t[e]);o.drawImage(h,0,0,16,16,16*i,16*r,16,16)}))))),new xt(o.getImageData(0,0,i,i),a)}))}static empty(){const t=document.createElement("canvas");t.width=16,t.height=16;const e=t.getContext("2d");return xt.drawInvalidTexture(e),new xt(e.getImageData(0,0,16,16),{})}static drawInvalidTexture(t){t.fillStyle="black",t.fillRect(0,0,16,16),t.fillStyle="magenta",t.fillRect(0,0,8,8),t.fillRect(8,8,8,8)}}var yt,At,St,Bt,Et,Ct,It,kt;!function(t){function e(t,e){return"number"==typeof t?new s(t,null!=e?e:t):t}t.target=function(t,e,s,i,r,o){return new n(t,e,s,i,r,o)},t.parameters=function(t,s,n,r,o,a,l){return new i(e(t),e(s),e(n),e(r),e(o),e(a),l)},t.param=e;class s{constructor(t,e){this.min=t,this.max=e}distance(t){const e=("number"==typeof t?t:t.min)-this.max,s=this.min-("number"==typeof t?t:t.max);return e>0?e:Math.max(s,0)}union(t){return new s(Math.min(this.min,t.min),Math.max(this.max,t.max))}static fromJson(t){var e;if("number"==typeof t)return new s(t,t);const[i,n]=null!==(e=k.readArray(t,(t=>k.readNumber(t))))&&void 0!==e?e:[];return new s(null!=i?i:0,null!=n?n:0)}}t.Param=s;class i{constructor(t,e,s,i,n,r,o){this.temperature=t,this.humidity=e,this.continentalness=s,this.erosion=i,this.depth=n,this.weirdness=r,this.offset=o}fittness(t){return F(this.temperature.distance(t.temperature))+F(this.humidity.distance(t.humidity))+F(this.continentalness.distance(t.continentalness))+F(this.erosion.distance(t.erosion))+F(this.depth.distance(t.depth))+F(this.weirdness.distance(t.weirdness))+F(this.offset-t.offset)}space(){return[this.temperature,this.humidity,this.continentalness,this.erosion,this.depth,this.weirdness,new s(this.offset,this.offset)]}static fromJson(t){var e,n;const r=null!==(e=k.readObject(t))&&void 0!==e?e:{};return new i(s.fromJson(r.temperature),s.fromJson(r.humidity),s.fromJson(r.continentalness),s.fromJson(r.erosion),s.fromJson(r.depth),s.fromJson(r.weirdness),null!==(n=k.readInt(r.offset))&&void 0!==n?n:0)}}t.ParamPoint=i;class n{constructor(t,e,s,i,n,r){this.temperature=t,this.humidity=e,this.continentalness=s,this.erosion=i,this.depth=n,this.weirdness=r}get offset(){return 0}toArray(){return[this.temperature,this.humidity,this.continentalness,this.erosion,this.depth,this.weirdness,this.offset]}}t.TargetPoint=n;t.Parameters=class{constructor(t){this.things=t,this.index=new r(t)}find(t){return this.index.search(t,((t,e)=>t.distance(e)))}};class r{constructor(t){this.root=r.build(t.map((([t,e])=>new l(t,e))))}static build(t){if(1===t.length)return t[0];if(t.length<=r.CHILDREN_PER_NODE){const e=t.map((t=>{let e=0;for(let s=0;s<7;s+=1){const i=t.space[s];e+=Math.abs((i.min+i.max)/2)}return{key:e,node:t}})).sort(((t,e)=>t.key-e.key)).map((({node:t})=>t));return new a(e)}let e=1/0,s=-1,i=[];for(let n=0;n<7;++n){r.sort(t,n,!1),i=r.bucketize(t);let o=0;for(const t of i)o+=r.area(t.space);e>o&&(e=o,s=n)}return t=r.sort(t,s,!1),i=r.bucketize(t),i=r.sort(i,s,!0),new a(i.map((t=>r.build(t.children))))}static sort(t,e,s){return t.map((t=>{const i=t.space[e],n=(i.min+i.max)/2;return{key:s?Math.abs(n):n,node:t}})).sort(((t,e)=>t.key-e.key)).map((({node:t})=>t))}static bucketize(t){const e=[];let s=[];const i=Math.pow(10,Math.floor(Math.log(t.length-.01)/Math.log(10)));for(const n of t)s.push(n),s.length<i||(e.push(new a(s)),s=[]);return 0!==s.length&&e.push(new a(s)),e}static area(t){let e=0;for(const s of t)e+=Math.abs(s.max-s.min);return e}search(t,e){return this.root.search(t.toArray(),e).thing()}}r.CHILDREN_PER_NODE=10,t.RTree=r;class o{constructor(t){this.space=t}distance(t){let e=0;for(let s=0;s<7;s+=1)e+=F(this.space[s].distance(t[s]));return e}}t.RNode=o;class a extends o{constructor(t){super(a.buildSpace(t)),this.children=t}static buildSpace(t){let e=[...Array(7)].map((()=>new s(1/0,-1/0)));for(const s of t)e=[...Array(7)].map(((t,i)=>e[i].union(s.space[i])));return e}search(t,e){let s=1/0,i=null;for(const n of this.children){const r=e(n,t);if(s<=r)continue;const o=n.search(t,e),a=n==o?r:e(o,t);s<=a||(s=a,i=o)}return i}}t.RSubTree=a;class l extends o{constructor(t,e){super(t.space()),this.thing=e}search(){return this}}t.RLeaf=l}(yt||(yt={}));class Rt{constructor(t){this.biome=t}getBiome(){return this.biome}static fromJson(t){var e,s;const i=null!==(e=k.readObject(t))&&void 0!==e?e:{},n=null!==(s=k.readString(i.biome))&&void 0!==s?s:"minecraft:the_void";return new Rt(n)}}class _t{constructor(t){this.parameters=t}getBiome(t,e,s,i){const n=i(t,e,s);return this.parameters.find(n)}static fromJson(t){var e,s;const i=null!==(e=k.readObject(t))&&void 0!==e?e:{},n=(null!==(s=k.readArray(i.biomes,(t=>{var e;return(t=>{var e;return{biome:null!==(e=k.readString(t.biome))&&void 0!==e?e:"minecraft:the_void",parameters:yt.ParamPoint.fromJson(t.parameters)}})(null!==(e=k.readObject(t))&&void 0!==e?e:{})})))&&void 0!==s?s:[]).map((t=>[t.parameters,()=>t.biome]));return new _t(new yt.Parameters(n))}}!function(t){function e(t){return h.apply(t)+.015}function s(t){return u.apply(t)}function i(t){return c.apply(t)}function n(t){return 3*-(Math.abs(Math.abs(t)-.6666667)-.33333334)}t.offset=e,t.factor=s,t.peaks=i,t.peaksAndValleys=n,t.point=function(t,e,s){return{continents:t,erosion:e,weirdness:s,ridges:n(s)}},t.nearWater=function(t,e){return!(t<-.2)&&(t<-.05||Math.abs(e)<.15)},t.shape=function(t,n){return{offset:e(t),factor:s(t),peaks:i(t),nearWater:n}};const r=f("beachSpline",-.15,-.05,0,0,.1,0,-.03,!1,!1),o=f("lowSpline",-.1,-.1,.03,.1,.1,.01,-.03,!1,!1),a=f("midSpline",-.1,-.1,.03,.1,.7,.01,-.03,!0,!0),l=f("highSpline",-.05,.3,.03,.1,1,.01,.01,!0,!0),h=new Z("offsetSampler",(t=>t.continents)).addPoint(-1.1,.044).addPoint(-1.02,-.2222).addPoint(-.51,-.2222).addPoint(-.44,-.12).addPoint(-.18,-.12).addPoint(-.16,r).addPoint(-.15,r).addPoint(-.1,o).addPoint(.25,a).addPoint(1,l),u=new Z("Factor-Continents",(t=>t.continents)).addPoint(-.19,505).addPoint(-.15,d("erosionCoast",800,!0,"ridgeCoast-OldMountains")).addPoint(-.1,d("erosionInland",700,!0,"ridgeInland-OldMountains")).addPoint(.03,d("erosionMidInland",650,!0,"ridgeMidInland-OldMountains")).addPoint(.06,d("erosionFarInland",600,!1,"ridgeFarInland-OldMountains")),c=new Z("Peaks",(t=>t.continents)).addPoint(.1,0).addPoint(.2,new Z("Peaks-erosion",(t=>t.erosion)).addPoint(-.8,new Z("Peaks-erosion-ridges",(t=>t.ridges)).addPoint(-1,0).addPoint(.2,0).addPoint(1,new Z("Peaks-erosion-ridges-weirdness",(t=>t.weirdness)).addPoint(-.01,80).addPoint(.01,20))).addPoint(-.4,0));function d(t,e,s,i){const n=new Z(t,(t=>t.erosion)).addPoint(-.6,e).addPoint(-.5,342).addPoint(-.35,e).addPoint(-.25,e).addPoint(-.1,342).addPoint(.03,e);if(s){const t=new Z("weirdnessShattered",(t=>t.weirdness)).addPoint(0,e).addPoint(.1,80),s=new Z("ridgesShattered",(t=>t.ridges)).addPoint(-.9,e).addPoint(-.69,t);n.addPoint(.35,e).addPoint(.45,s).addPoint(.55,s).addPoint(.62,e)}else{const t=new Z(i,(t=>t.ridges)).addPoint(-.7,e).addPoint(-.15,175),s=new Z(i,(t=>t.ridges)).addPoint(.45,e).addPoint(.7,200);n.addPoint(.05,s).addPoint(.4,s).addPoint(.45,t).addPoint(.55,t).addPoint(.58,e)}return n}function f(t,e,s,i,n,r,o,a,l,h){const u=g(N(r,.6,1.5),h),c=g(N(r,.6,1),h),d=g(r,h),f=v(t+"-widePlateau",e-.15,.5*r,N(.5,.5,.5)*r,.5*r,.6*r,.5),p=v(t+"-narrowPlateau",e,o*r,i*r,.5*r,.6*r,.5),m=v(t+"-plains",e,o,o,i,n,.5),b=v(t+"-plainsFarInland",e,o,o,i,n,.5),w=new Z(t,(t=>t.ridges)).addPoint(-1,e).addPoint(-.4,m).addPoint(0,n+.07),P=v(t+"-swamps",-.02,a,a,i,n,0),x=new Z(t,(t=>t.erosion)).addPoint(-.85,u).addPoint(-.7,c).addPoint(-.4,d).addPoint(-.35,f).addPoint(-.1,p).addPoint(.2,m);return l&&x.addPoint(.4,b).addPoint(.45,w).addPoint(.55,w).addPoint(.58,b),x.addPoint(.7,P),x}function g(t,e){const s=new Z(`M-spline for continentalness: ${t} ${e}`,(t=>t.ridges)),i=p(-1,t,-.7),n=p(1,t,-.7),r=function(t){return.5*(1-t)/(.46082947*(1-.5*(1-t)))-1.17}(t);if(-.65<r&&r<1){const e=p(-.65,t,-.7),o=p(-.75,t,-.7),a=m(i,o,-1,-.75);s.addPoint(-1,i,a),s.addPoint(-.75,o),s.addPoint(-.65,e);const l=p(r,t,-.7),h=m(l,n,r,1);s.addPoint(r-.01,l),s.addPoint(r,l,h),s.addPoint(1,n,h)}else{const t=m(i,n,-1,1);e?(s.addPoint(-1,Math.max(.2,i)),s.addPoint(0,N(.5,i,n),t)):s.addPoint(-1,i,t),s.addPoint(1,n,t)}return s}function p(t,e,s){const i=.46082947*(t+1.17)*(1-.5*(1-e))-.5*(1-e);return t<s?Math.max(i,-.2222):Math.max(i,0)}function m(t,e,s,i){return(e-t)/(i-s)}function v(t,e,s,i,n,r,o){const a=Math.max(.5*(s-e),o),l=5*(i-s);return new Z(t,(t=>t.ridges)).addPoint(-1,e,a).addPoint(-.4,s,Math.min(a,l)).addPoint(0,i,l).addPoint(.4,n,2*(n-i)).addPoint(1,r,.7*(r-n))}}(At||(At={}));class Ft{constructor(t,e,s,i,n,r){this.cellCountY=e,this.cellCountZ=s,this.cellMinY=n,this.filler=r,this.noise000=0,this.noise001=0,this.noise100=0,this.noise101=0,this.noise010=0,this.noise011=0,this.noise110=0,this.noise111=0,this.valueXZ00=0,this.valueXZ10=0,this.valueXZ01=0,this.valueXZ11=0,this.valueZ0=0,this.valueZ1=0,this.minCellX=i[0]*t,this.minCellZ=i[1]*s,this.slice0=Ft.allocateSlice(e,s),this.slice1=Ft.allocateSlice(e,s)}static allocateSlice(t,e){const s=Array(e+1);for(let i=0;i<e+1;i+=1)s[i]=Array(t+1);return s}initializeForFirstCellX(){this.fillSlice(this.slice0,this.minCellX)}advanceCellX(t){this.fillSlice(this.slice1,this.minCellX+t+1)}fillSlice(t,e){for(let s=0;s<this.cellCountZ+1;s+=1)this.filler(t[s],e,this.minCellZ+s,this.cellMinY,this.cellCountY)}selectCellYZ(t,e){this.noise000=this.slice0[e][t],this.noise001=this.slice0[e+1][t],this.noise100=this.slice1[e][t],this.noise101=this.slice1[e+1][t],this.noise010=this.slice0[e][t+1],this.noise011=this.slice0[e+1][t+1],this.noise110=this.slice1[e][t+1],this.noise111=this.slice1[e+1][t+1]}updateForY(t){this.valueXZ00=N(t,this.noise000,this.noise010),this.valueXZ10=N(t,this.noise100,this.noise110),this.valueXZ01=N(t,this.noise001,this.noise011),this.valueXZ11=N(t,this.noise101,this.noise111)}updateForX(t){this.valueZ0=N(t,this.valueXZ00,this.valueXZ10),this.valueZ1=N(t,this.valueXZ01,this.valueXZ11)}calculateValue(t){return N(t,this.valueZ0,this.valueZ1)}swapSlices(){[this.slice0,this.slice1]=[this.slice1,this.slice0]}}class Mt{constructor(t,e,s,i,n,r,o,a){this.cellWidth=t,this.cellHeight=e,this.cellCountY=s,this.biomeSource=i,this.settings=n,this.shapeOverride=a;const l=new W(o),h=n.useLegacyRandom?new W(o):l.fork();this.blendedNoise=new Y(h),l.consume(8),this.temperatureNoise=new X(new J(o),r.temperature),this.humidityNoise=new X(new J(o+BigInt(1)),r.humidity),this.continentalnessNoise=new X(new J(o+BigInt(2)),r.continentalness),this.erosionNoise=new X(new J(o+BigInt(3)),r.erosion),this.weirdnessNoise=new X(new J(o+BigInt(4)),r.weirdness),this.offsetNoise=new X(new J(o+BigInt(5)),r.shift),this.mountainPeakNoise=new X(l.fork(),{firstOctave:-16,amplitudes:[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]})}getClimate(t,e,s){const i=t+this.getOffset(t,0,s),n=e+this.getOffset(e,s,t),r=s+this.getOffset(s,t,0),o=this.temperatureNoise.sample(i,n,r),a=this.humidityNoise.sample(i,n,r),l=this.continentalnessNoise.sample(i,0,r),h=this.erosionNoise.sample(i,0,r),u=this.weirdnessNoise.sample(i,0,r),c=At.offset(At.point(l,h,u)),d=Mt.computeDimensionDensity(1,-.51875,4*e)+c;return new yt.TargetPoint(o,a,l,h,d,u)}getTerrainShape(t,e){if(this.shapeOverride)return this.shapeOverride;const s=t+this.getOffset(t,0,e),i=e+this.getOffset(e,t,0),n=this.continentalnessNoise.sample(s,0,i),r=this.erosionNoise.sample(s,0,i),o=this.weirdnessNoise.sample(s,0,i),a=At.point(n,r,o),l=At.nearWater(n,o);return At.shape(a,l)}getOffset(t,e,s){return 4*this.offsetNoise.sample(t,e,s)}fillNoiseColumn(t,e,s,i,n){const r=e*this.cellWidth>>2,o=s*this.cellWidth>>2,{offset:a,factor:l,peaks:h}=this.getTerrainShape(r,o),u=684.412*this.settings.sampling.xzScale,c=684.412*this.settings.sampling.yScale,d=u/this.settings.sampling.xzFactor,f=c/this.settings.sampling.yFactor;for(let r=0;r<=n;r+=1){const n=r+i,o=this.blendedNoise.sample(e,n,s,u,c,d,f),g=this.samplePeakNoise(h,e*this.cellHeight,s*this.cellHeight)/128,p=this.computeInitialDensity(n*this.cellHeight,a,l,0,g)+o;t[r]=this.applySlide(p,n)}}samplePeakNoise(t,e,s){if(0===t)return 0;const i=3e3/this.cellWidth,n=this.mountainPeakNoise.sample(e*i,0,s*i);return n>0?t*n:t/2*n}computeInitialDensity(t,e,s,i,n){const r=(Mt.computeDimensionDensity(this.settings.densityFactor,this.settings.densityOffset,t,i)+e+n)*s;return r*(r>0?4:1)}applySlide(t,e){const s=e-Math.floor(this.settings.minY/this.cellHeight);if(this.settings.topSlide.size>0){const e=(this.cellCountY-s-this.settings.topSlide.offset)/this.settings.topSlide.size;t=U(this.settings.topSlide.target,t,e)}if(this.settings.bottomSlide.size>0){const e=(s-this.settings.bottomSlide.offset)/this.settings.bottomSlide.size;t=U(this.settings.bottomSlide.target,t,e)}return t}static computeDimensionDensity(t,e,s,i=0){return t*(1-s/128+i)+e}}class Nt{constructor(t,e,s,i){this.seed=t,this.biomeSource=e,this.settings=s,this.cellHeight=s.noise.ySize<<2,this.cellWidth=s.noise.xzSize<<2,this.cellCountXZ=Math.floor(16/this.cellWidth),this.cellCountY=Math.floor(s.noise.height/this.cellHeight),this.sampler=new Mt(this.cellWidth,this.cellHeight,this.cellCountY,e,s.noise,s.octaves,t,i)}fill(t){const e=Math.max(t.minY,this.settings.noise.minY),s=Math.min(t.maxY,this.settings.noise.minY+this.settings.noise.height),i=Math.floor(e/this.cellHeight),n=Math.floor((s-e)/this.cellHeight),r=I.minBlockX(t.pos),o=I.minBlockZ(t.pos),a=new Ft(this.cellCountXZ,n,this.cellCountXZ,t.pos,i,this.sampler.fillNoiseColumn.bind(this.sampler)),l=Array(a);l.forEach((t=>t.initializeForFirstCellX()));for(let e=0;e<this.cellCountXZ;e+=1){l.forEach((t=>t.advanceCellX(e)));for(let s=0;s<this.cellCountXZ;s+=1){let h=t.getOrCreateSection(t.sectionsCount-1);for(let u=n-1;u>=0;u-=1){l.forEach((t=>t.selectCellYZ(u,s)));for(let n=this.cellHeight-1;n>=0;n-=1){const c=(i+u)*this.cellHeight+n,d=15&c,f=t.getSectionIndex(c);t.getSectionIndex(h.minBlockY)!==f&&(h=t.getOrCreateSection(f));const g=n/this.cellHeight;l.forEach((t=>t.updateForY(g)));for(let t=0;t<this.cellWidth;t+=1){const i=r+e*this.cellWidth+t,n=15&i,u=t/this.cellWidth;l.forEach((t=>t.updateForX(u)));for(let t=0;t<this.cellWidth;t+=1){const e=o+s*this.cellWidth+t,r=15&e,l=t/this.cellWidth,u=a.calculateValue(l),f=this.baseState(i,c,e,u);f.equals(B.AIR)||h.setBlockState(n,d,r,f)}}}}}l.forEach((t=>t.swapSlices()))}}baseState(t,e,s,i){return(i=(i=M(i/200,-1,1))/2-i*i*i/24)>0?this.settings.defaultBlock:e<this.settings.seaLevel?this.settings.defaultFluid:B.AIR}}!function(t){t.fromJson=function(t){var e,s,i,n,r,o,a,l,h,u,c,d;const f=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{minY:null!==(s=k.readInt(f.min_y))&&void 0!==s?s:0,height:null!==(i=k.readInt(f.height))&&void 0!==i?i:256,xzSize:null!==(n=k.readInt(f.size_horizontal))&&void 0!==n?n:1,ySize:null!==(r=k.readInt(f.size_vertical))&&void 0!==r?r:1,densityFactor:null!==(o=k.readNumber(f.density_factor))&&void 0!==o?o:0,densityOffset:null!==(a=k.readNumber(f.density_offset))&&void 0!==a?a:0,sampling:Bt.fromJson(f.sampling),topSlide:Et.fromJson(f.top_slide),bottomSlide:Et.fromJson(f.bottom_slide),useSimplexSurfaceNoise:null!==(l=k.readBoolean(f.simplex_surface_noise))&&void 0!==l&&l,randomDensityOffset:null!==(h=k.readBoolean(f.random_density_offset))&&void 0!==h&&h,islandNoiseOverride:null!==(u=k.readBoolean(f.island_noise_override))&&void 0!==u&&u,isAmplified:null!==(c=k.readBoolean(f.amplified))&&void 0!==c&&c,useLegacyRandom:null!==(d=k.readBoolean(f.use_legacy_random))&&void 0!==d&&d}}}(St||(St={})),function(t){t.fromJson=function(t){var e,s,i,n,r;const o=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{xzScale:null!==(s=k.readNumber(o.xz_scale))&&void 0!==s?s:1,yScale:null!==(i=k.readNumber(o.y_scale))&&void 0!==i?i:1,xzFactor:null!==(n=k.readNumber(o.xz_factor))&&void 0!==n?n:80,yFactor:null!==(r=k.readNumber(o.y_factor))&&void 0!==r?r:80}}}(Bt||(Bt={})),function(t){t.fromJson=function(t){var e,s,i,n;const r=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{target:null!==(s=k.readNumber(r.target))&&void 0!==s?s:0,size:null!==(i=k.readInt(r.size))&&void 0!==i?i:0,offset:null!==(n=k.readInt(r.offset))&&void 0!==n?n:0}}}(Et||(Et={})),function(t){t.fromJson=function(t){var e,s,i,n,r,o,a,l,h,u;const c=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{structures:It.fromJson(c.structures),noise:St.fromJson(c.noise),octaves:kt.fromJson(c.octaves),defaultBlock:B.fromJson(c.default_block),defaultFluid:B.fromJson(c.default_fluid),bedrockRoofPosition:null!==(s=k.readInt(c.bedrock_roof_position))&&void 0!==s?s:0,bedrockFloorPosition:null!==(i=k.readInt(c.bedrock_floor_position))&&void 0!==i?i:0,seaLevel:null!==(n=k.readInt(c.sea_level))&&void 0!==n?n:0,disableMobGeneration:null!==(r=k.readBoolean(c.disable_mob_generation))&&void 0!==r&&r,aquifersEnabled:null!==(o=k.readBoolean(c.aquifers_enabled))&&void 0!==o&&o,noiseCavesEnabled:null!==(a=k.readBoolean(c.noise_caves_enabled))&&void 0!==a&&a,deepslateEnabled:null!==(l=k.readBoolean(c.deepslate_enabled))&&void 0!==l&&l,oreVeinsEnabled:null!==(h=k.readBoolean(c.ore_veins_enabled))&&void 0!==h&&h,noodleCavesEnabled:null!==(u=k.readBoolean(c.noodle_caves_enabled))&&void 0!==u&&u}}}(Ct||(Ct={})),function(t){t.fromJson=function(t){var e;const s=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{stronghold:k.compose(s.stronghold,k.readObject,(t=>{var e,s,i;return{distance:null!==(e=k.readInt(t.distance))&&void 0!==e?e:0,spread:null!==(s=k.readInt(t.spread))&&void 0!==s?s:0,count:null!==(i=k.readInt(t.count))&&void 0!==i?i:0}})),structures:k.readMap(s.structures,(t=>{var e;return(t=>{var e,s,i;return{spacing:null!==(e=k.readInt(t.spacing))&&void 0!==e?e:0,separation:null!==(s=k.readInt(t.separation))&&void 0!==s?s:0,salt:null!==(i=k.readInt(t.salt))&&void 0!==i?i:0}})(null!==(e=k.readObject(t))&&void 0!==e?e:{})}))}}}(It||(It={})),function(t){t.fromJson=function(t){var e;const s=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{temperature:R.fromJson(s.temperature),humidity:R.fromJson(s.humidity),continentalness:R.fromJson(s.continentalness),erosion:R.fromJson(s.erosion),weirdness:R.fromJson(s.weirdness),shift:R.fromJson(s.shift)}}}(kt||(kt={}));
//# sourceMappingURL=deepslate.esm.js.map


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "ARRAY_TYPE": () => (/* binding */ ARRAY_TYPE),
/* harmony export */   "RANDOM": () => (/* binding */ RANDOM),
/* harmony export */   "setMatrixArrayType": () => (/* binding */ setMatrixArrayType),
/* harmony export */   "toRadian": () => (/* binding */ toRadian),
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromXRotation": () => (/* binding */ fromXRotation),
/* harmony export */   "fromYRotation": () => (/* binding */ fromYRotation),
/* harmony export */   "fromZRotation": () => (/* binding */ fromZRotation),
/* harmony export */   "fromRotationTranslation": () => (/* binding */ fromRotationTranslation),
/* harmony export */   "fromQuat2": () => (/* binding */ fromQuat2),
/* harmony export */   "getTranslation": () => (/* binding */ getTranslation),
/* harmony export */   "getScaling": () => (/* binding */ getScaling),
/* harmony export */   "getRotation": () => (/* binding */ getRotation),
/* harmony export */   "fromRotationTranslationScale": () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   "fromRotationTranslationScaleOrigin": () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   "fromQuat": () => (/* binding */ fromQuat),
/* harmony export */   "frustum": () => (/* binding */ frustum),
/* harmony export */   "perspectiveNO": () => (/* binding */ perspectiveNO),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "perspectiveZO": () => (/* binding */ perspectiveZO),
/* harmony export */   "perspectiveFromFieldOfView": () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   "orthoNO": () => (/* binding */ orthoNO),
/* harmony export */   "ortho": () => (/* binding */ ortho),
/* harmony export */   "orthoZO": () => (/* binding */ orthoZO),
/* harmony export */   "lookAt": () => (/* binding */ lookAt),
/* harmony export */   "targetTo": () => (/* binding */ targetTo),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "hermite": () => (/* binding */ hermite),
/* harmony export */   "bezier": () => (/* binding */ bezier),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "transformMat3": () => (/* binding */ transformMat3),
/* harmony export */   "transformQuat": () => (/* binding */ transformQuat),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "angle": () => (/* binding */ angle),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/litegraph.js/build/litegraph.js":
/*!******************************************************!*\
  !*** ./node_modules/litegraph.js/build/litegraph.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

//packer version

(function(global) {
    // *************************************************************
    //   LiteGraph CLASS                                     *******
    // *************************************************************

    /**
     * The Global Scope. It contains all the registered node classes.
     *
     * @class LiteGraph
     * @constructor
     */

    var LiteGraph = (global.LiteGraph = {
        VERSION: 0.4,

        CANVAS_GRID_SIZE: 10,

        NODE_TITLE_HEIGHT: 30,
        NODE_TITLE_TEXT_Y: 20,
        NODE_SLOT_HEIGHT: 20,
        NODE_WIDGET_HEIGHT: 20,
        NODE_WIDTH: 140,
        NODE_MIN_WIDTH: 50,
        NODE_COLLAPSED_RADIUS: 10,
        NODE_COLLAPSED_WIDTH: 80,
        NODE_TITLE_COLOR: "#999",
        NODE_SELECTED_TITLE_COLOR: "#FFF",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#AAA",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#333",
        NODE_DEFAULT_BGCOLOR: "#353535",
        NODE_DEFAULT_BOXCOLOR: "#666",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#FFF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 24,

        WIDGET_BGCOLOR: "#222",
        WIDGET_OUTLINE_COLOR: "#666",
        WIDGET_TEXT_COLOR: "#DDD",
        WIDGET_SECONDARY_TEXT_COLOR: "#999",

        LINK_COLOR: "#9A9",
        EVENT_LINK_COLOR: "#A86",
        CONNECTING_LINK_COLOR: "#AFA",

        MAX_NUMBER_OF_NODES: 1000, //avoid infinite loops
        DEFAULT_POSITION: [100, 100], //default node position
        VALID_SHAPES: ["default", "box", "round", "card"], //,"circle"

        //shapes are used for nodes but also for slots
        BOX_SHAPE: 1,
        ROUND_SHAPE: 2,
        CIRCLE_SHAPE: 3,
        CARD_SHAPE: 4,
        ARROW_SHAPE: 5,

        //enums
        INPUT: 1,
        OUTPUT: 2,

        EVENT: -1, //for outputs
        ACTION: -1, //for inputs

        ALWAYS: 0,
        ON_EVENT: 1,
        NEVER: 2,
        ON_TRIGGER: 3,

        UP: 1,
        DOWN: 2,
        LEFT: 3,
        RIGHT: 4,
        CENTER: 5,

        STRAIGHT_LINK: 0,
        LINEAR_LINK: 1,
        SPLINE_LINK: 2,

        NORMAL_TITLE: 0,
        NO_TITLE: 1,
        TRANSPARENT_TITLE: 2,
        AUTOHIDE_TITLE: 3,

        proxy: null, //used to redirect calls
        node_images_path: "",

        debug: false,
        catch_exceptions: true,
        throw_errors: true,
        allow_scripts: false, //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits
        registered_node_types: {}, //nodetypes by string
        node_types_by_file_extension: {}, //used for dropping files in the canvas
        Nodes: {}, //node types by classname
		Globals: {}, //used to store vars between graphs

        searchbox_extras: {}, //used to add extra features to the search box
        auto_sort_node_types: false, // If set to true, will automatically sort node types / categories in the context menus

        /**
         * Register a node class so it can be listed when the user wants to create a new one
         * @method registerNodeType
         * @param {String} type name of the node and path
         * @param {Class} base_class class containing the structure of a node
         */

        registerNodeType: function(type, base_class) {
            if (!base_class.prototype) {
                throw "Cannot register a simple object, it must be a class with a prototype";
            }
            base_class.type = type;

            if (LiteGraph.debug) {
                console.log("Node registered: " + type);
            }

            var categories = type.split("/");
            var classname = base_class.name;

            var pos = type.lastIndexOf("/");
            base_class.category = type.substr(0, pos);

            if (!base_class.title) {
                base_class.title = classname;
            }
            //info.name = name.substr(pos+1,name.length - pos);

            //extend class
            if (base_class.prototype) {
                //is a class
                for (var i in LGraphNode.prototype) {
                    if (!base_class.prototype[i]) {
                        base_class.prototype[i] = LGraphNode.prototype[i];
                    }
                }
            }

            var prev = this.registered_node_types[type];
			if(prev)
				console.log("replacing node type: " + type);
			else
			{
				if( !Object.hasOwnProperty( base_class.prototype, "shape") )
				Object.defineProperty(base_class.prototype, "shape", {
					set: function(v) {
						switch (v) {
							case "default":
								delete this._shape;
								break;
							case "box":
								this._shape = LiteGraph.BOX_SHAPE;
								break;
							case "round":
								this._shape = LiteGraph.ROUND_SHAPE;
								break;
							case "circle":
								this._shape = LiteGraph.CIRCLE_SHAPE;
								break;
							case "card":
								this._shape = LiteGraph.CARD_SHAPE;
								break;
							default:
								this._shape = v;
						}
					},
					get: function(v) {
						return this._shape;
					},
					enumerable: true,
					configurable: true
				});

				//warnings
				if (base_class.prototype.onPropertyChange) {
					console.warn(
						"LiteGraph node class " +
							type +
							" has onPropertyChange method, it must be called onPropertyChanged with d at the end"
					);
				}

				//used to know which nodes create when dragging files to the canvas
				if (base_class.supported_extensions) {
					for (var i in base_class.supported_extensions) {
						var ext = base_class.supported_extensions[i];
						if(ext && ext.constructor === String)
							this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;
					}
				}
			}

            this.registered_node_types[type] = base_class;
            if (base_class.constructor.name) {
                this.Nodes[classname] = base_class;
            }
            if (LiteGraph.onNodeTypeRegistered) {
                LiteGraph.onNodeTypeRegistered(type, base_class);
            }
            if (prev && LiteGraph.onNodeTypeReplaced) {
                LiteGraph.onNodeTypeReplaced(type, base_class, prev);
            }

            //warnings
            if (base_class.prototype.onPropertyChange) {
                console.warn(
                    "LiteGraph node class " +
                        type +
                        " has onPropertyChange method, it must be called onPropertyChanged with d at the end"
                );
            }

			//used to know which nodes create when dragging files to the canvas
            if (base_class.supported_extensions) {
                for (var i=0; i < base_class.supported_extensions.length; i++) {
					var ext = base_class.supported_extensions[i];
					if(ext && ext.constructor === String)
	                    this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;
                }
            }
        },

        /**
         * removes a node type from the system
         * @method unregisterNodeType
         * @param {String|Object} type name of the node or the node constructor itself
         */
        unregisterNodeType: function(type) {
			var base_class = type.constructor === String ? this.registered_node_types[type] : type;
			if(!base_class)
				throw("node type not found: " + type );
			delete this.registered_node_types[base_class.type];
			if(base_class.constructor.name)
				delete this.Nodes[base_class.constructor.name];
		},

        /**
         * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
         * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
         * @method wrapFunctionAsNode
         * @param {String} name node name with namespace (p.e.: 'math/sum')
         * @param {Function} func
         * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
         * @param {String} return_type [optional] string with the return type, otherwise it will be generic
         * @param {Object} properties [optional] properties to be configurable
         */
        wrapFunctionAsNode: function(
            name,
            func,
            param_types,
            return_type,
            properties
        ) {
            var params = Array(func.length);
            var code = "";
            var names = LiteGraph.getParameterNames(func);
            for (var i = 0; i < names.length; ++i) {
                code +=
                    "this.addInput('" +
                    names[i] +
                    "'," +
                    (param_types && param_types[i]
                        ? "'" + param_types[i] + "'"
                        : "0") +
                    ");\n";
            }
            code +=
                "this.addOutput('out'," +
                (return_type ? "'" + return_type + "'" : 0) +
                ");\n";
            if (properties) {
                code +=
                    "this.properties = " + JSON.stringify(properties) + ";\n";
            }
            var classobj = Function(code);
            classobj.title = name.split("/").pop();
            classobj.desc = "Generated from " + func.name;
            classobj.prototype.onExecute = function onExecute() {
                for (var i = 0; i < params.length; ++i) {
                    params[i] = this.getInputData(i);
                }
                var r = func.apply(this, params);
                this.setOutputData(0, r);
            };
            this.registerNodeType(name, classobj);
        },

        /**
         * Removes all previously registered node's types
         */
        clearRegisteredTypes: function() {
            this.registered_node_types = {};
            this.node_types_by_file_extension = {};
            this.Nodes = {};
            this.searchbox_extras = {};
        },

        /**
         * Adds this method to all nodetypes, existing and to be created
         * (You can add it to LGraphNode.prototype but then existing node types wont have it)
         * @method addNodeMethod
         * @param {Function} func
         */
        addNodeMethod: function(name, func) {
            LGraphNode.prototype[name] = func;
            for (var i in this.registered_node_types) {
                var type = this.registered_node_types[i];
                if (type.prototype[name]) {
                    type.prototype["_" + name] = type.prototype[name];
                } //keep old in case of replacing
                type.prototype[name] = func;
            }
        },

        /**
         * Create a node of a given type with a name. The node is not attached to any graph yet.
         * @method createNode
         * @param {String} type full name of the node class. p.e. "math/sin"
         * @param {String} name a name to distinguish from other nodes
         * @param {Object} options to set options
         */

        createNode: function(type, title, options) {
            var base_class = this.registered_node_types[type];
            if (!base_class) {
                if (LiteGraph.debug) {
                    console.log(
                        'GraphNode type "' + type + '" not registered.'
                    );
                }
                return null;
            }

            var prototype = base_class.prototype || base_class;

            title = title || base_class.title || type;

            var node = null;

            if (LiteGraph.catch_exceptions) {
                try {
                    node = new base_class(title);
                } catch (err) {
                    console.error(err);
                    return null;
                }
            } else {
                node = new base_class(title);
            }

            node.type = type;

            if (!node.title && title) {
                node.title = title;
            }
            if (!node.properties) {
                node.properties = {};
            }
            if (!node.properties_info) {
                node.properties_info = [];
            }
            if (!node.flags) {
                node.flags = {};
            }
            if (!node.size) {
                node.size = node.computeSize();
				//call onresize?
            }
            if (!node.pos) {
                node.pos = LiteGraph.DEFAULT_POSITION.concat();
            }
            if (!node.mode) {
                node.mode = LiteGraph.ALWAYS;
            }

            //extra options
            if (options) {
                for (var i in options) {
                    node[i] = options[i];
                }
            }

            return node;
        },

        /**
         * Returns a registered node type with a given name
         * @method getNodeType
         * @param {String} type full name of the node class. p.e. "math/sin"
         * @return {Class} the node class
         */
        getNodeType: function(type) {
            return this.registered_node_types[type];
        },

        /**
         * Returns a list of node types matching one category
         * @method getNodeType
         * @param {String} category category name
         * @return {Array} array with all the node classes
         */

        getNodeTypesInCategory: function(category, filter) {
            var r = [];
            for (var i in this.registered_node_types) {
                var type = this.registered_node_types[i];
                if (type.filter != filter) {
                    continue;
                }

                if (category == "") {
                    if (type.category == null) {
                        r.push(type);
                    }
                } else if (type.category == category) {
                    r.push(type);
                }
            }

            if (this.auto_sort_node_types) {
                r.sort((a, b) => a.title.localeCompare(b.title));
            }

            return r;
        },

        /**
         * Returns a list with all the node type categories
         * @method getNodeTypesCategories
         * @param {String} filter only nodes with ctor.filter equal can be shown
         * @return {Array} array with all the names of the categories
         */
        getNodeTypesCategories: function( filter ) {
            var categories = { "": 1 };
            for (var i in this.registered_node_types) {
				var type = this.registered_node_types[i];
                if ( type.category && !type.skip_list )
                {
					if(type.filter != filter)
						continue;
                    categories[type.category] = 1;
                }
            }
            var result = [];
            for (var i in categories) {
                result.push(i);
            }
            return this.auto_sort_node_types ? result.sort() : result;
        },

        //debug purposes: reloads all the js scripts that matches a wildcard
        reloadNodes: function(folder_wildcard) {
            var tmp = document.getElementsByTagName("script");
            //weird, this array changes by its own, so we use a copy
            var script_files = [];
            for (var i=0; i < tmp.length; i++) {
                script_files.push(tmp[i]);
            }

            var docHeadObj = document.getElementsByTagName("head")[0];
            folder_wildcard = document.location.href + folder_wildcard;

            for (var i=0; i < script_files.length; i++) {
                var src = script_files[i].src;
                if (
                    !src ||
                    src.substr(0, folder_wildcard.length) != folder_wildcard
                ) {
                    continue;
                }

                try {
                    if (LiteGraph.debug) {
                        console.log("Reloading: " + src);
                    }
                    var dynamicScript = document.createElement("script");
                    dynamicScript.type = "text/javascript";
                    dynamicScript.src = src;
                    docHeadObj.appendChild(dynamicScript);
                    docHeadObj.removeChild(script_files[i]);
                } catch (err) {
                    if (LiteGraph.throw_errors) {
                        throw err;
                    }
                    if (LiteGraph.debug) {
                        console.log("Error while reloading " + src);
                    }
                }
            }

            if (LiteGraph.debug) {
                console.log("Nodes reloaded");
            }
        },

        //separated just to improve if it doesn't work
        cloneObject: function(obj, target) {
            if (obj == null) {
                return null;
            }
            var r = JSON.parse(JSON.stringify(obj));
            if (!target) {
                return r;
            }

            for (var i in r) {
                target[i] = r[i];
            }
            return target;
        },

        /**
         * Returns if the types of two slots are compatible (taking into account wildcards, etc)
         * @method isValidConnection
         * @param {String} type_a
         * @param {String} type_b
         * @return {Boolean} true if they can be connected
         */
        isValidConnection: function(type_a, type_b) {
            if (
                !type_a || //generic output
                !type_b || //generic input
                type_a == type_b || //same type (is valid for triggers)
                (type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION)
            ) {
                return true;
            }

            // Enforce string type to handle toLowerCase call (-1 number not ok)
            type_a = String(type_a);
            type_b = String(type_b);
            type_a = type_a.toLowerCase();
            type_b = type_b.toLowerCase();

            // For nodes supporting multiple connection types
            if (type_a.indexOf(",") == -1 && type_b.indexOf(",") == -1) {
                return type_a == type_b;
            }

            // Check all permutations to see if one is valid
            var supported_types_a = type_a.split(",");
            var supported_types_b = type_b.split(",");
            for (var i = 0; i < supported_types_a.length; ++i) {
                for (var j = 0; j < supported_types_b.length; ++j) {
                    if (supported_types_a[i] == supported_types_b[j]) {
                        return true;
                    }
                }
            }

            return false;
        },

        /**
         * Register a string in the search box so when the user types it it will recommend this node
         * @method registerSearchboxExtra
         * @param {String} node_type the node recommended
         * @param {String} description text to show next to it
         * @param {Object} data it could contain info of how the node should be configured
         * @return {Boolean} true if they can be connected
         */
        registerSearchboxExtra: function(node_type, description, data) {
            this.searchbox_extras[description.toLowerCase()] = {
                type: node_type,
                desc: description,
                data: data
            };
        },

        /**
         * Wrapper to load files (from url using fetch or from file using FileReader)
         * @method fetchFile
         * @param {String|File|Blob} url the url of the file (or the file itself)
         * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
         * @param {Function} on_complete callback(data)
         * @param {Function} on_error in case of an error
         * @return {FileReader|Promise} returns the object used to 
         */
		fetchFile: function( url, type, on_complete, on_error ) {
			var that = this;
			if(!url)
				return null;

			type = type || "text";
			if( url.constructor === String )
			{
				if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
					url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
				}
				return fetch(url)
				.then(function(response) {
					if(!response.ok)
						 throw new Error("File not found"); //it will be catch below
					if(type == "arraybuffer")
						return response.arrayBuffer();
					else if(type == "text" || type == "string")
						return response.text();
					else if(type == "json")
						return response.json();
					else if(type == "blob")
						return response.blob();
				})
				.then(function(data) {
					if(on_complete)
						on_complete(data);
				})
				.catch(function(error) {
					console.error("error fetching file:",url);
					if(on_error)
						on_error(error);
				});
			}
			else if( url.constructor === File || url.constructor === Blob)
			{
				var reader = new FileReader();
				reader.onload = function(e)
				{
					var v = e.target.result;
					if( type == "json" )
						v = JSON.parse(v);
					if(on_complete)
						on_complete(v);
				}
				if(type == "arraybuffer")
					return reader.readAsArrayBuffer(url);
				else if(type == "text" || type == "json")
					return reader.readAsText(url);
				else if(type == "blob")
					return reader.readAsBinaryString(url);
			}
			return null;
		}
    });

    //timer that works everywhere
    if (typeof performance != "undefined") {
        LiteGraph.getTime = performance.now.bind(performance);
    } else if (typeof Date != "undefined" && Date.now) {
        LiteGraph.getTime = Date.now.bind(Date);
    } else if (typeof process != "undefined") {
        LiteGraph.getTime = function() {
            var t = process.hrtime();
            return t[0] * 0.001 + t[1] * 1e-6;
        };
    } else {
        LiteGraph.getTime = function getTime() {
            return new Date().getTime();
        };
    }

    //*********************************************************************************
    // LGraph CLASS
    //*********************************************************************************

    /**
     * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.
	 * supported callbacks:
		+ onNodeAdded: when a new node is added to the graph
		+ onNodeRemoved: when a node inside this graph is removed
		+ onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)
     *
     * @class LGraph
     * @constructor
     * @param {Object} o data from previous serialization [optional]
     */

    function LGraph(o) {
        if (LiteGraph.debug) {
            console.log("Graph created");
        }
        this.list_of_graphcanvas = null;
        this.clear();

        if (o) {
            this.configure(o);
        }
    }

    global.LGraph = LiteGraph.LGraph = LGraph;

    //default supported types
    LGraph.supported_types = ["number", "string", "boolean"];

    //used to know which types of connections support this graph (some graphs do not allow certain types)
    LGraph.prototype.getSupportedTypes = function() {
        return this.supported_types || LGraph.supported_types;
    };

    LGraph.STATUS_STOPPED = 1;
    LGraph.STATUS_RUNNING = 2;

    /**
     * Removes all nodes from this graph
     * @method clear
     */

    LGraph.prototype.clear = function() {
        this.stop();
        this.status = LGraph.STATUS_STOPPED;

        this.last_node_id = 0;
        this.last_link_id = 0;

        this._version = -1; //used to detect changes

        //safe clear
        if (this._nodes) {
            for (var i = 0; i < this._nodes.length; ++i) {
                var node = this._nodes[i];
                if (node.onRemoved) {
                    node.onRemoved();
                }
            }
        }

        //nodes
        this._nodes = [];
        this._nodes_by_id = {};
        this._nodes_in_order = []; //nodes sorted in execution order
        this._nodes_executable = null; //nodes that contain onExecute sorted in execution order

        //other scene stuff
        this._groups = [];

        //links
        this.links = {}; //container with all the links

        //iterations
        this.iteration = 0;

        //custom data
        this.config = {};
		this.vars = {};
		this.extra = {}; //to store custom data

        //timing
        this.globaltime = 0;
        this.runningtime = 0;
        this.fixedtime = 0;
        this.fixedtime_lapse = 0.01;
        this.elapsed_time = 0.01;
        this.last_update_time = 0;
        this.starttime = 0;

        this.catch_errors = true;

        //subgraph_data
        this.inputs = {};
        this.outputs = {};

        //notify canvas to redraw
        this.change();

        this.sendActionToCanvas("clear");
    };

    /**
     * Attach Canvas to this graph
     * @method attachCanvas
     * @param {GraphCanvas} graph_canvas
     */

    LGraph.prototype.attachCanvas = function(graphcanvas) {
        if (graphcanvas.constructor != LGraphCanvas) {
            throw "attachCanvas expects a LGraphCanvas instance";
        }
        if (graphcanvas.graph && graphcanvas.graph != this) {
            graphcanvas.graph.detachCanvas(graphcanvas);
        }

        graphcanvas.graph = this;

        if (!this.list_of_graphcanvas) {
            this.list_of_graphcanvas = [];
        }
        this.list_of_graphcanvas.push(graphcanvas);
    };

    /**
     * Detach Canvas from this graph
     * @method detachCanvas
     * @param {GraphCanvas} graph_canvas
     */
    LGraph.prototype.detachCanvas = function(graphcanvas) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        var pos = this.list_of_graphcanvas.indexOf(graphcanvas);
        if (pos == -1) {
            return;
        }
        graphcanvas.graph = null;
        this.list_of_graphcanvas.splice(pos, 1);
    };

    /**
     * Starts running this graph every interval milliseconds.
     * @method start
     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
     */

    LGraph.prototype.start = function(interval) {
        if (this.status == LGraph.STATUS_RUNNING) {
            return;
        }
        this.status = LGraph.STATUS_RUNNING;

        if (this.onPlayEvent) {
            this.onPlayEvent();
        }

        this.sendEventToAllNodes("onStart");

        //launch
        this.starttime = LiteGraph.getTime();
        this.last_update_time = this.starttime;
        interval = interval || 0;
        var that = this;

		//execute once per frame
        if ( interval == 0 && typeof window != "undefined" && window.requestAnimationFrame ) {
            function on_frame() {
                if (that.execution_timer_id != -1) {
                    return;
                }
                window.requestAnimationFrame(on_frame);
				if(that.onBeforeStep)
					that.onBeforeStep();
                that.runStep(1, !that.catch_errors);
				if(that.onAfterStep)
					that.onAfterStep();
            }
            this.execution_timer_id = -1;
            on_frame();
        } else { //execute every 'interval' ms
            this.execution_timer_id = setInterval(function() {
                //execute
				if(that.onBeforeStep)
					that.onBeforeStep();
                that.runStep(1, !that.catch_errors);
				if(that.onAfterStep)
					that.onAfterStep();
            }, interval);
        }
    };

    /**
     * Stops the execution loop of the graph
     * @method stop execution
     */

    LGraph.prototype.stop = function() {
        if (this.status == LGraph.STATUS_STOPPED) {
            return;
        }

        this.status = LGraph.STATUS_STOPPED;

        if (this.onStopEvent) {
            this.onStopEvent();
        }

        if (this.execution_timer_id != null) {
            if (this.execution_timer_id != -1) {
                clearInterval(this.execution_timer_id);
            }
            this.execution_timer_id = null;
        }

        this.sendEventToAllNodes("onStop");
    };

    /**
     * Run N steps (cycles) of the graph
     * @method runStep
     * @param {number} num number of steps to run, default is 1
     * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors 
     * @param {number} limit max number of nodes to execute (used to execute from start to a node)
     */

    LGraph.prototype.runStep = function(num, do_not_catch_errors, limit ) {
        num = num || 1;

        var start = LiteGraph.getTime();
        this.globaltime = 0.001 * (start - this.starttime);

        var nodes = this._nodes_executable
            ? this._nodes_executable
            : this._nodes;
        if (!nodes) {
            return;
        }

		limit = limit || nodes.length;

        if (do_not_catch_errors) {
            //iterations
            for (var i = 0; i < num; i++) {
                for (var j = 0; j < limit; ++j) {
                    var node = nodes[j];
                    if (node.mode == LiteGraph.ALWAYS && node.onExecute) {
                        node.onExecute(); //hard to send elapsed time
                    }
                }

                this.fixedtime += this.fixedtime_lapse;
                if (this.onExecuteStep) {
                    this.onExecuteStep();
                }
            }

            if (this.onAfterExecute) {
                this.onAfterExecute();
            }
        } else {
            try {
                //iterations
                for (var i = 0; i < num; i++) {
                    for (var j = 0; j < limit; ++j) {
                        var node = nodes[j];
                        if (node.mode == LiteGraph.ALWAYS && node.onExecute) {
                            node.onExecute();
                        }
                    }

                    this.fixedtime += this.fixedtime_lapse;
                    if (this.onExecuteStep) {
                        this.onExecuteStep();
                    }
                }

                if (this.onAfterExecute) {
                    this.onAfterExecute();
                }
                this.errors_in_execution = false;
            } catch (err) {
                this.errors_in_execution = true;
                if (LiteGraph.throw_errors) {
                    throw err;
                }
                if (LiteGraph.debug) {
                    console.log("Error during execution: " + err);
                }
                this.stop();
            }
        }

        var now = LiteGraph.getTime();
        var elapsed = now - start;
        if (elapsed == 0) {
            elapsed = 1;
        }
        this.execution_time = 0.001 * elapsed;
        this.globaltime += 0.001 * elapsed;
        this.iteration += 1;
        this.elapsed_time = (now - this.last_update_time) * 0.001;
        this.last_update_time = now;
    };

    /**
     * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
     * nodes with only inputs.
     * @method updateExecutionOrder
     */
    LGraph.prototype.updateExecutionOrder = function() {
        this._nodes_in_order = this.computeExecutionOrder(false);
        this._nodes_executable = [];
        for (var i = 0; i < this._nodes_in_order.length; ++i) {
            if (this._nodes_in_order[i].onExecute) {
                this._nodes_executable.push(this._nodes_in_order[i]);
            }
        }
    };

    //This is more internal, it computes the executable nodes in order and returns it
    LGraph.prototype.computeExecutionOrder = function(
        only_onExecute,
        set_level
    ) {
        var L = [];
        var S = [];
        var M = {};
        var visited_links = {}; //to avoid repeating links
        var remaining_links = {}; //to a

        //search for the nodes without inputs (starting nodes)
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            var node = this._nodes[i];
            if (only_onExecute && !node.onExecute) {
                continue;
            }

            M[node.id] = node; //add to pending nodes

            var num = 0; //num of input connections
            if (node.inputs) {
                for (var j = 0, l2 = node.inputs.length; j < l2; j++) {
                    if (node.inputs[j] && node.inputs[j].link != null) {
                        num += 1;
                    }
                }
            }

            if (num == 0) {
                //is a starting node
                S.push(node);
                if (set_level) {
                    node._level = 1;
                }
            } //num of input links
            else {
                if (set_level) {
                    node._level = 0;
                }
                remaining_links[node.id] = num;
            }
        }

        while (true) {
            if (S.length == 0) {
                break;
            }

            //get an starting node
            var node = S.shift();
            L.push(node); //add to ordered list
            delete M[node.id]; //remove from the pending nodes

            if (!node.outputs) {
                continue;
            }

            //for every output
            for (var i = 0; i < node.outputs.length; i++) {
                var output = node.outputs[i];
                //not connected
                if (
                    output == null ||
                    output.links == null ||
                    output.links.length == 0
                ) {
                    continue;
                }

                //for every connection
                for (var j = 0; j < output.links.length; j++) {
                    var link_id = output.links[j];
                    var link = this.links[link_id];
                    if (!link) {
                        continue;
                    }

                    //already visited link (ignore it)
                    if (visited_links[link.id]) {
                        continue;
                    }

                    var target_node = this.getNodeById(link.target_id);
                    if (target_node == null) {
                        visited_links[link.id] = true;
                        continue;
                    }

                    if (
                        set_level &&
                        (!target_node._level ||
                            target_node._level <= node._level)
                    ) {
                        target_node._level = node._level + 1;
                    }

                    visited_links[link.id] = true; //mark as visited
                    remaining_links[target_node.id] -= 1; //reduce the number of links remaining
                    if (remaining_links[target_node.id] == 0) {
                        S.push(target_node);
                    } //if no more links, then add to starters array
                }
            }
        }

        //the remaining ones (loops)
        for (var i in M) {
            L.push(M[i]);
        }

        if (L.length != this._nodes.length && LiteGraph.debug) {
            console.warn("something went wrong, nodes missing");
        }

        var l = L.length;

        //save order number in the node
        for (var i = 0; i < l; ++i) {
            L[i].order = i;
        }

        //sort now by priority
        L = L.sort(function(A, B) {
            var Ap = A.constructor.priority || A.priority || 0;
            var Bp = B.constructor.priority || B.priority || 0;
            if (Ap == Bp) {
                //if same priority, sort by order
                return A.order - B.order;
            }
            return Ap - Bp; //sort by priority
        });

        //save order number in the node, again...
        for (var i = 0; i < l; ++i) {
            L[i].order = i;
        }

        return L;
    };

    /**
     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
     * It doesn't include the node itself
     * @method getAncestors
     * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution
     */
    LGraph.prototype.getAncestors = function(node) {
        var ancestors = [];
        var pending = [node];
        var visited = {};

        while (pending.length) {
            var current = pending.shift();
            if (!current.inputs) {
                continue;
            }
            if (!visited[current.id] && current != node) {
                visited[current.id] = true;
                ancestors.push(current);
            }

            for (var i = 0; i < current.inputs.length; ++i) {
                var input = current.getInputNode(i);
                if (input && ancestors.indexOf(input) == -1) {
                    pending.push(input);
                }
            }
        }

        ancestors.sort(function(a, b) {
            return a.order - b.order;
        });
        return ancestors;
    };

    /**
     * Positions every node in a more readable manner
     * @method arrange
     */
    LGraph.prototype.arrange = function(margin) {
        margin = margin || 100;

        var nodes = this.computeExecutionOrder(false, true);
        var columns = [];
        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            var col = node._level || 1;
            if (!columns[col]) {
                columns[col] = [];
            }
            columns[col].push(node);
        }

        var x = margin;

        for (var i = 0; i < columns.length; ++i) {
            var column = columns[i];
            if (!column) {
                continue;
            }
            var max_size = 100;
            var y = margin + LiteGraph.NODE_TITLE_HEIGHT;
            for (var j = 0; j < column.length; ++j) {
                var node = column[j];
                node.pos[0] = x;
                node.pos[1] = y;
                if (node.size[0] > max_size) {
                    max_size = node.size[0];
                }
                y += node.size[1] + margin + LiteGraph.NODE_TITLE_HEIGHT;
            }
            x += max_size + margin;
        }

        this.setDirtyCanvas(true, true);
    };

    /**
     * Returns the amount of time the graph has been running in milliseconds
     * @method getTime
     * @return {number} number of milliseconds the graph has been running
     */
    LGraph.prototype.getTime = function() {
        return this.globaltime;
    };

    /**
     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
     * @method getFixedTime
     * @return {number} number of milliseconds the graph has been running
     */

    LGraph.prototype.getFixedTime = function() {
        return this.fixedtime;
    };

    /**
     * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
     * if the nodes are using graphical actions
     * @method getElapsedTime
     * @return {number} number of milliseconds it took the last cycle
     */

    LGraph.prototype.getElapsedTime = function() {
        return this.elapsed_time;
    };

    /**
     * Sends an event to all the nodes, useful to trigger stuff
     * @method sendEventToAllNodes
     * @param {String} eventname the name of the event (function to be called)
     * @param {Array} params parameters in array format
     */
    LGraph.prototype.sendEventToAllNodes = function(eventname, params, mode) {
        mode = mode || LiteGraph.ALWAYS;

        var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
        if (!nodes) {
            return;
        }

        for (var j = 0, l = nodes.length; j < l; ++j) {
            var node = nodes[j];

            if (
                node.constructor === LiteGraph.Subgraph &&
                eventname != "onExecute"
            ) {
                if (node.mode == mode) {
                    node.sendEventToAllNodes(eventname, params, mode);
                }
                continue;
            }

            if (!node[eventname] || node.mode != mode) {
                continue;
            }
            if (params === undefined) {
                node[eventname]();
            } else if (params && params.constructor === Array) {
                node[eventname].apply(node, params);
            } else {
                node[eventname](params);
            }
        }
    };

    LGraph.prototype.sendActionToCanvas = function(action, params) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
            var c = this.list_of_graphcanvas[i];
            if (c[action]) {
                c[action].apply(c, params);
            }
        }
    };

    /**
     * Adds a new node instance to this graph
     * @method add
     * @param {LGraphNode} node the instance of the node
     */

    LGraph.prototype.add = function(node, skip_compute_order) {
        if (!node) {
            return;
        }

        //groups
        if (node.constructor === LGraphGroup) {
            this._groups.push(node);
            this.setDirtyCanvas(true);
            this.change();
            node.graph = this;
            this._version++;
            return;
        }

        //nodes
        if (node.id != -1 && this._nodes_by_id[node.id] != null) {
            console.warn(
                "LiteGraph: there is already a node with this ID, changing it"
            );
            node.id = ++this.last_node_id;
        }

        if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {
            throw "LiteGraph: max number of nodes in a graph reached";
        }

        //give him an id
        if (node.id == null || node.id == -1) {
            node.id = ++this.last_node_id;
        } else if (this.last_node_id < node.id) {
            this.last_node_id = node.id;
        }

        node.graph = this;
        this._version++;

        this._nodes.push(node);
        this._nodes_by_id[node.id] = node;

        if (node.onAdded) {
            node.onAdded(this);
        }

        if (this.config.align_to_grid) {
            node.alignToGrid();
        }

        if (!skip_compute_order) {
            this.updateExecutionOrder();
        }

        if (this.onNodeAdded) {
            this.onNodeAdded(node);
        }

        this.setDirtyCanvas(true);
        this.change();

        return node; //to chain actions
    };

    /**
     * Removes a node from the graph
     * @method remove
     * @param {LGraphNode} node the instance of the node
     */

    LGraph.prototype.remove = function(node) {
        if (node.constructor === LiteGraph.LGraphGroup) {
            var index = this._groups.indexOf(node);
            if (index != -1) {
                this._groups.splice(index, 1);
            }
            node.graph = null;
            this._version++;
            this.setDirtyCanvas(true, true);
            this.change();
            return;
        }

        if (this._nodes_by_id[node.id] == null) {
            return;
        } //not found

        if (node.ignore_remove) {
            return;
        } //cannot be removed

		this.beforeChange(); //sure?

        //disconnect inputs
        if (node.inputs) {
            for (var i = 0; i < node.inputs.length; i++) {
                var slot = node.inputs[i];
                if (slot.link != null) {
                    node.disconnectInput(i);
                }
            }
        }

        //disconnect outputs
        if (node.outputs) {
            for (var i = 0; i < node.outputs.length; i++) {
                var slot = node.outputs[i];
                if (slot.links != null && slot.links.length) {
                    node.disconnectOutput(i);
                }
            }
        }

        //node.id = -1; //why?

        //callback
        if (node.onRemoved) {
            node.onRemoved();
        }

        node.graph = null;
        this._version++;

        //remove from canvas render
        if (this.list_of_graphcanvas) {
            for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
                var canvas = this.list_of_graphcanvas[i];
                if (canvas.selected_nodes[node.id]) {
                    delete canvas.selected_nodes[node.id];
                }
                if (canvas.node_dragged == node) {
                    canvas.node_dragged = null;
                }
            }
        }

        //remove from containers
        var pos = this._nodes.indexOf(node);
        if (pos != -1) {
            this._nodes.splice(pos, 1);
        }
        delete this._nodes_by_id[node.id];

        if (this.onNodeRemoved) {
            this.onNodeRemoved(node);
        }

		//close panels
		this.sendActionToCanvas("checkPanels");

        this.setDirtyCanvas(true, true);
		this.afterChange(); //sure?
        this.change();

        this.updateExecutionOrder();
    };

    /**
     * Returns a node by its id.
     * @method getNodeById
     * @param {Number} id
     */

    LGraph.prototype.getNodeById = function(id) {
        if (id == null) {
            return null;
        }
        return this._nodes_by_id[id];
    };

    /**
     * Returns a list of nodes that matches a class
     * @method findNodesByClass
     * @param {Class} classObject the class itself (not an string)
     * @return {Array} a list with all the nodes of this type
     */
    LGraph.prototype.findNodesByClass = function(classObject, result) {
        result = result || [];
        result.length = 0;
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].constructor === classObject) {
                result.push(this._nodes[i]);
            }
        }
        return result;
    };

    /**
     * Returns a list of nodes that matches a type
     * @method findNodesByType
     * @param {String} type the name of the node type
     * @return {Array} a list with all the nodes of this type
     */
    LGraph.prototype.findNodesByType = function(type, result) {
        var type = type.toLowerCase();
        result = result || [];
        result.length = 0;
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].type.toLowerCase() == type) {
                result.push(this._nodes[i]);
            }
        }
        return result;
    };

    /**
     * Returns the first node that matches a name in its title
     * @method findNodeByTitle
     * @param {String} name the name of the node to search
     * @return {Node} the node or null
     */
    LGraph.prototype.findNodeByTitle = function(title) {
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].title == title) {
                return this._nodes[i];
            }
        }
        return null;
    };

    /**
     * Returns a list of nodes that matches a name
     * @method findNodesByTitle
     * @param {String} name the name of the node to search
     * @return {Array} a list with all the nodes with this name
     */
    LGraph.prototype.findNodesByTitle = function(title) {
        var result = [];
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].title == title) {
                result.push(this._nodes[i]);
            }
        }
        return result;
    };

    /**
     * Returns the top-most node in this position of the canvas
     * @method getNodeOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph
     * @return {LGraphNode} the node at this position or null
     */
    LGraph.prototype.getNodeOnPos = function(x, y, nodes_list, margin) {
        nodes_list = nodes_list || this._nodes;
        for (var i = nodes_list.length - 1; i >= 0; i--) {
            var n = nodes_list[i];
            if (n.isPointInside(x, y, margin)) {
                return n;
            }
        }
        return null;
    };

    /**
     * Returns the top-most group in that position
     * @method getGroupOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @return {LGraphGroup} the group or null
     */
    LGraph.prototype.getGroupOnPos = function(x, y) {
        for (var i = this._groups.length - 1; i >= 0; i--) {
            var g = this._groups[i];
            if (g.isPointInside(x, y, 2, true)) {
                return g;
            }
        }
        return null;
    };

    /**
     * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
     * this replaces the ones using the old version with the new version
     * @method checkNodeTypes
     */
    LGraph.prototype.checkNodeTypes = function() {
        var changes = false;
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var ctor = LiteGraph.registered_node_types[node.type];
            if (node.constructor == ctor) {
                continue;
            }
            console.log("node being replaced by newer version: " + node.type);
            var newnode = LiteGraph.createNode(node.type);
            changes = true;
            this._nodes[i] = newnode;
            newnode.configure(node.serialize());
            newnode.graph = this;
            this._nodes_by_id[newnode.id] = newnode;
            if (node.inputs) {
                newnode.inputs = node.inputs.concat();
            }
            if (node.outputs) {
                newnode.outputs = node.outputs.concat();
            }
        }
        this.updateExecutionOrder();
    };

    // ********** GLOBALS *****************

    LGraph.prototype.onAction = function(action, param) {
        this._input_nodes = this.findNodesByClass(
            LiteGraph.GraphInput,
            this._input_nodes
        );
        for (var i = 0; i < this._input_nodes.length; ++i) {
            var node = this._input_nodes[i];
            if (node.properties.name != action) {
                continue;
            }
            node.onAction(action, param);
            break;
        }
    };

    LGraph.prototype.trigger = function(action, param) {
        if (this.onTrigger) {
            this.onTrigger(action, param);
        }
    };

    /**
     * Tell this graph it has a global graph input of this type
     * @method addGlobalInput
     * @param {String} name
     * @param {String} type
     * @param {*} value [optional]
     */
    LGraph.prototype.addInput = function(name, type, value) {
        var input = this.inputs[name];
        if (input) {
            //already exist
            return;
        }

		this.beforeChange();
        this.inputs[name] = { name: name, type: type, value: value };
        this._version++;
		this.afterChange();

        if (this.onInputAdded) {
            this.onInputAdded(name, type);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Assign a data to the global graph input
     * @method setGlobalInputData
     * @param {String} name
     * @param {*} data
     */
    LGraph.prototype.setInputData = function(name, data) {
        var input = this.inputs[name];
        if (!input) {
            return;
        }
        input.value = data;
    };

    /**
     * Returns the current value of a global graph input
     * @method getInputData
     * @param {String} name
     * @return {*} the data
     */
    LGraph.prototype.getInputData = function(name) {
        var input = this.inputs[name];
        if (!input) {
            return null;
        }
        return input.value;
    };

    /**
     * Changes the name of a global graph input
     * @method renameInput
     * @param {String} old_name
     * @param {String} new_name
     */
    LGraph.prototype.renameInput = function(old_name, name) {
        if (name == old_name) {
            return;
        }

        if (!this.inputs[old_name]) {
            return false;
        }

        if (this.inputs[name]) {
            console.error("there is already one input with that name");
            return false;
        }

        this.inputs[name] = this.inputs[old_name];
        delete this.inputs[old_name];
        this._version++;

        if (this.onInputRenamed) {
            this.onInputRenamed(old_name, name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Changes the type of a global graph input
     * @method changeInputType
     * @param {String} name
     * @param {String} type
     */
    LGraph.prototype.changeInputType = function(name, type) {
        if (!this.inputs[name]) {
            return false;
        }

        if (
            this.inputs[name].type &&
            String(this.inputs[name].type).toLowerCase() ==
                String(type).toLowerCase()
        ) {
            return;
        }

        this.inputs[name].type = type;
        this._version++;
        if (this.onInputTypeChanged) {
            this.onInputTypeChanged(name, type);
        }
    };

    /**
     * Removes a global graph input
     * @method removeInput
     * @param {String} name
     * @param {String} type
     */
    LGraph.prototype.removeInput = function(name) {
        if (!this.inputs[name]) {
            return false;
        }

        delete this.inputs[name];
        this._version++;

        if (this.onInputRemoved) {
            this.onInputRemoved(name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
        return true;
    };

    /**
     * Creates a global graph output
     * @method addOutput
     * @param {String} name
     * @param {String} type
     * @param {*} value
     */
    LGraph.prototype.addOutput = function(name, type, value) {
        this.outputs[name] = { name: name, type: type, value: value };
        this._version++;

        if (this.onOutputAdded) {
            this.onOutputAdded(name, type);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Assign a data to the global output
     * @method setOutputData
     * @param {String} name
     * @param {String} value
     */
    LGraph.prototype.setOutputData = function(name, value) {
        var output = this.outputs[name];
        if (!output) {
            return;
        }
        output.value = value;
    };

    /**
     * Returns the current value of a global graph output
     * @method getOutputData
     * @param {String} name
     * @return {*} the data
     */
    LGraph.prototype.getOutputData = function(name) {
        var output = this.outputs[name];
        if (!output) {
            return null;
        }
        return output.value;
    };

    /**
     * Renames a global graph output
     * @method renameOutput
     * @param {String} old_name
     * @param {String} new_name
     */
    LGraph.prototype.renameOutput = function(old_name, name) {
        if (!this.outputs[old_name]) {
            return false;
        }

        if (this.outputs[name]) {
            console.error("there is already one output with that name");
            return false;
        }

        this.outputs[name] = this.outputs[old_name];
        delete this.outputs[old_name];
        this._version++;

        if (this.onOutputRenamed) {
            this.onOutputRenamed(old_name, name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Changes the type of a global graph output
     * @method changeOutputType
     * @param {String} name
     * @param {String} type
     */
    LGraph.prototype.changeOutputType = function(name, type) {
        if (!this.outputs[name]) {
            return false;
        }

        if (
            this.outputs[name].type &&
            String(this.outputs[name].type).toLowerCase() ==
                String(type).toLowerCase()
        ) {
            return;
        }

        this.outputs[name].type = type;
        this._version++;
        if (this.onOutputTypeChanged) {
            this.onOutputTypeChanged(name, type);
        }
    };

    /**
     * Removes a global graph output
     * @method removeOutput
     * @param {String} name
     */
    LGraph.prototype.removeOutput = function(name) {
        if (!this.outputs[name]) {
            return false;
        }
        delete this.outputs[name];
        this._version++;

        if (this.onOutputRemoved) {
            this.onOutputRemoved(name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
        return true;
    };

    LGraph.prototype.triggerInput = function(name, value) {
        var nodes = this.findNodesByTitle(name);
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].onTrigger(value);
        }
    };

    LGraph.prototype.setCallback = function(name, func) {
        var nodes = this.findNodesByTitle(name);
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].setTrigger(func);
        }
    };

	//used for undo, called before any change is made to the graph
    LGraph.prototype.beforeChange = function(info) {
        if (this.onBeforeChange) {
            this.onBeforeChange(this,info);
        }
        this.sendActionToCanvas("onBeforeChange", this);
    };

	//used to resend actions, called after any change is made to the graph
    LGraph.prototype.afterChange = function(info) {
        if (this.onAfterChange) {
            this.onAfterChange(this,info);
        }
        this.sendActionToCanvas("onAfterChange", this);
    };

    LGraph.prototype.connectionChange = function(node, link_info) {
        this.updateExecutionOrder();
        if (this.onConnectionChange) {
            this.onConnectionChange(node);
        }
        this._version++;
        this.sendActionToCanvas("onConnectionChange");
    };

    /**
     * returns if the graph is in live mode
     * @method isLive
     */

    LGraph.prototype.isLive = function() {
        if (!this.list_of_graphcanvas) {
            return false;
        }

        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
            var c = this.list_of_graphcanvas[i];
            if (c.live_mode) {
                return true;
            }
        }
        return false;
    };

    /**
     * clears the triggered slot animation in all links (stop visual animation)
     * @method clearTriggeredSlots
     */
    LGraph.prototype.clearTriggeredSlots = function() {
        for (var i in this.links) {
            var link_info = this.links[i];
            if (!link_info) {
                continue;
            }
            if (link_info._last_time) {
                link_info._last_time = 0;
            }
        }
    };

    /* Called when something visually changed (not the graph!) */
    LGraph.prototype.change = function() {
        if (LiteGraph.debug) {
            console.log("Graph changed");
        }
        this.sendActionToCanvas("setDirty", [true, true]);
        if (this.on_change) {
            this.on_change(this);
        }
    };

    LGraph.prototype.setDirtyCanvas = function(fg, bg) {
        this.sendActionToCanvas("setDirty", [fg, bg]);
    };

    /**
     * Destroys a link
     * @method removeLink
     * @param {Number} link_id
     */
    LGraph.prototype.removeLink = function(link_id) {
        var link = this.links[link_id];
        if (!link) {
            return;
        }
        var node = this.getNodeById(link.target_id);
        if (node) {
            node.disconnectInput(link.target_slot);
        }
    };

    //save and recover app state ***************************************
    /**
     * Creates a Object containing all the info about this graph, it can be serialized
     * @method serialize
     * @return {Object} value of the node
     */
    LGraph.prototype.serialize = function() {
        var nodes_info = [];
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            nodes_info.push(this._nodes[i].serialize());
        }

        //pack link info into a non-verbose format
        var links = [];
        for (var i in this.links) {
            //links is an OBJECT
            var link = this.links[i];
            if (!link.serialize) {
                //weird bug I havent solved yet
                console.warn(
                    "weird LLink bug, link info is not a LLink but a regular object"
                );
                var link2 = new LLink();
                for (var j in link) { 
                    link2[j] = link[j];
                }
                this.links[i] = link2;
                link = link2;
            }

            links.push(link.serialize());
        }

        var groups_info = [];
        for (var i = 0; i < this._groups.length; ++i) {
            groups_info.push(this._groups[i].serialize());
        }

        var data = {
            last_node_id: this.last_node_id,
            last_link_id: this.last_link_id,
            nodes: nodes_info,
            links: links,
            groups: groups_info,
            config: this.config,
			extra: this.extra,
            version: LiteGraph.VERSION
        };

		if(this.onSerialize)
			this.onSerialize(data);

        return data;
    };

    /**
     * Configure a graph from a JSON string
     * @method configure
     * @param {String} str configure a graph from a JSON string
     * @param {Boolean} returns if there was any error parsing
     */
    LGraph.prototype.configure = function(data, keep_old) {
        if (!data) {
            return;
        }

        if (!keep_old) {
            this.clear();
        }

        var nodes = data.nodes;

        //decode links info (they are very verbose)
        if (data.links && data.links.constructor === Array) {
            var links = [];
            for (var i = 0; i < data.links.length; ++i) {
                var link_data = data.links[i];
				if(!link_data) //weird bug
				{
					console.warn("serialized graph link data contains errors, skipping.");
					continue;
				}
                var link = new LLink();
                link.configure(link_data);
                links[link.id] = link;
            }
            data.links = links;
        }

        //copy all stored fields
        for (var i in data) {
			if(i == "nodes" || i == "groups" ) //links must be accepted
				continue;
            this[i] = data[i];
        }

        var error = false;

        //create nodes
        this._nodes = [];
        if (nodes) {
            for (var i = 0, l = nodes.length; i < l; ++i) {
                var n_info = nodes[i]; //stored info
                var node = LiteGraph.createNode(n_info.type, n_info.title);
                if (!node) {
                    if (LiteGraph.debug) {
                        console.log(
                            "Node not found or has errors: " + n_info.type
                        );
                    }

                    //in case of error we create a replacement node to avoid losing info
                    node = new LGraphNode();
                    node.last_serialization = n_info;
                    node.has_errors = true;
                    error = true;
                    //continue;
                }

                node.id = n_info.id; //id it or it will create a new id
                this.add(node, true); //add before configure, otherwise configure cannot create links
            }

            //configure nodes afterwards so they can reach each other
            for (var i = 0, l = nodes.length; i < l; ++i) {
                var n_info = nodes[i];
                var node = this.getNodeById(n_info.id);
                if (node) {
                    node.configure(n_info);
                }
            }
        }

        //groups
        this._groups.length = 0;
        if (data.groups) {
            for (var i = 0; i < data.groups.length; ++i) {
                var group = new LiteGraph.LGraphGroup();
                group.configure(data.groups[i]);
                this.add(group);
            }
        }

        this.updateExecutionOrder();

		this.extra = data.extra || {};

		if(this.onConfigure)
			this.onConfigure(data);

        this._version++;
        this.setDirtyCanvas(true, true);
        return error;
    };

    LGraph.prototype.load = function(url, callback) {
        var that = this;

		//from file
		if(url.constructor === File || url.constructor === Blob)
		{
			var reader = new FileReader();
			reader.addEventListener('load', function(event) {
				var data = JSON.parse(event.target.result);
				that.configure(data);
				if(callback)
					callback();
			});
			
			reader.readAsText(url);
			return;
		}

		//is a string, then an URL
        var req = new XMLHttpRequest();
        req.open("GET", url, true);
        req.send(null);
        req.onload = function(oEvent) {
            if (req.status !== 200) {
                console.error("Error loading graph:", req.status, req.response);
                return;
            }
            var data = JSON.parse( req.response );
            that.configure(data);
			if(callback)
				callback();
        };
        req.onerror = function(err) {
            console.error("Error loading graph:", err);
        };
    };

    LGraph.prototype.onNodeTrace = function(node, msg, color) {
        //TODO
    };

    //this is the class in charge of storing link information
    function LLink(id, type, origin_id, origin_slot, target_id, target_slot) {
        this.id = id;
        this.type = type;
        this.origin_id = origin_id;
        this.origin_slot = origin_slot;
        this.target_id = target_id;
        this.target_slot = target_slot;

        this._data = null;
        this._pos = new Float32Array(2); //center
    }

    LLink.prototype.configure = function(o) {
        if (o.constructor === Array) {
            this.id = o[0];
            this.origin_id = o[1];
            this.origin_slot = o[2];
            this.target_id = o[3];
            this.target_slot = o[4];
            this.type = o[5];
        } else {
            this.id = o.id;
            this.type = o.type;
            this.origin_id = o.origin_id;
            this.origin_slot = o.origin_slot;
            this.target_id = o.target_id;
            this.target_slot = o.target_slot;
        }
    };

    LLink.prototype.serialize = function() {
        return [
            this.id,
            this.origin_id,
            this.origin_slot,
            this.target_id,
            this.target_slot,
            this.type
        ];
    };

    LiteGraph.LLink = LLink;

    // *************************************************************
    //   Node CLASS                                          *******
    // *************************************************************

    /*
	title: string
	pos: [x,y]
	size: [x,y]

	input|output: every connection
		+  { name:string, type:string, pos: [x,y]=Optional, direction: "input"|"output", links: Array });

	general properties:
		+ clip_area: if you render outside the node, it will be clipped
		+ unsafe_execution: not allowed for safe execution
		+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected
		+ resizable: if set to false it wont be resizable with the mouse
		+ horizontal: slots are distributed horizontally
		+ widgets_start_y: widgets start at y distance from the top of the node
	
	flags object:
		+ collapsed: if it is collapsed

	supported callbacks:
		+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)
		+ onRemoved: when removed from graph
		+ onStart:	when the graph starts playing
		+ onStop:	when the graph stops playing
		+ onDrawForeground: render the inside widgets inside the node
		+ onDrawBackground: render the background area inside the node (only in edit mode)
		+ onMouseDown
		+ onMouseMove
		+ onMouseUp
		+ onMouseEnter
		+ onMouseLeave
		+ onExecute: execute the node
		+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)
		+ onGetInputs: returns an array of possible inputs
		+ onGetOutputs: returns an array of possible outputs
		+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])
		+ onDblClick: double clicked in the node
		+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)
		+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)
		+ onConfigure: called after the node has been configured
		+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)
		+ onSelected
		+ onDeselected
		+ onDropItem : DOM item dropped over the node
		+ onDropFile : file dropped over the node
		+ onConnectInput : if returns false the incoming connection will be canceled
		+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )
		+ onAction: action slot triggered
		+ getExtraMenuOptions: to add option to context menu
*/

    /**
     * Base Class for all the node type classes
     * @class LGraphNode
     * @param {String} name a name for the node
     */

    function LGraphNode(title) {
        this._ctor(title);
    }

    global.LGraphNode = LiteGraph.LGraphNode = LGraphNode;

    LGraphNode.prototype._ctor = function(title) {
        this.title = title || "Unnamed";
        this.size = [LiteGraph.NODE_WIDTH, 60];
        this.graph = null;

        this._pos = new Float32Array(10, 10);

        Object.defineProperty(this, "pos", {
            set: function(v) {
                if (!v || v.length < 2) {
                    return;
                }
                this._pos[0] = v[0];
                this._pos[1] = v[1];
            },
            get: function() {
                return this._pos;
            },
            enumerable: true
        });

        this.id = -1; //not know till not added
        this.type = null;

        //inputs available: array of inputs
        this.inputs = [];
        this.outputs = [];
        this.connections = [];

        //local data
        this.properties = {}; //for the values
        this.properties_info = []; //for the info

        this.flags = {};
    };

    /**
     * configure a node from an object containing the serialized info
     * @method configure
     */
    LGraphNode.prototype.configure = function(info) {
        if (this.graph) {
            this.graph._version++;
        }
        for (var j in info) {
            if (j == "properties") {
                //i don't want to clone properties, I want to reuse the old container
                for (var k in info.properties) {
                    this.properties[k] = info.properties[k];
                    if (this.onPropertyChanged) {
                        this.onPropertyChanged( k, info.properties[k] );
                    }
                }
                continue;
            }

            if (info[j] == null) {
                continue;
            } else if (typeof info[j] == "object") {
                //object
                if (this[j] && this[j].configure) {
                    this[j].configure(info[j]);
                } else {
                    this[j] = LiteGraph.cloneObject(info[j], this[j]);
                }
            } //value
            else {
                this[j] = info[j];
            }
        }

        if (!info.title) {
            this.title = this.constructor.title;
        }

        if (this.onConnectionsChange) {
            if (this.inputs) {
                for (var i = 0; i < this.inputs.length; ++i) {
                    var input = this.inputs[i];
                    var link_info = this.graph
                        ? this.graph.links[input.link]
                        : null;
                    this.onConnectionsChange(
                        LiteGraph.INPUT,
                        i,
                        true,
                        link_info,
                        input
                    ); //link_info has been created now, so its updated
                }
            }

            if (this.outputs) {
                for (var i = 0; i < this.outputs.length; ++i) {
                    var output = this.outputs[i];
                    if (!output.links) {
                        continue;
                    }
                    for (var j = 0; j < output.links.length; ++j) {
                        var link_info = this.graph
                            ? this.graph.links[output.links[j]]
                            : null;
                        this.onConnectionsChange(
                            LiteGraph.OUTPUT,
                            i,
                            true,
                            link_info,
                            output
                        ); //link_info has been created now, so its updated
                    }
                }
            }
        }

		if( this.widgets )
		{
			for (var i = 0; i < this.widgets.length; ++i)
			{
				var w = this.widgets[i];
				if(!w)
					continue;
				if(w.options && w.options.property && this.properties[ w.options.property ])
					w.value = JSON.parse( JSON.stringify( this.properties[ w.options.property ] ) );
			}
			if (info.widgets_values) {
				for (var i = 0; i < info.widgets_values.length; ++i) {
					if (this.widgets[i]) {
						this.widgets[i].value = info.widgets_values[i];
					}
				}
			}
		}

        if (this.onConfigure) {
            this.onConfigure(info);
        }
    };

    /**
     * serialize the content
     * @method serialize
     */

    LGraphNode.prototype.serialize = function() {
        //create serialization object
        var o = {
            id: this.id,
            type: this.type,
            pos: this.pos,
            size: this.size,
            flags: LiteGraph.cloneObject(this.flags),
			order: this.order,
            mode: this.mode
        };

        //special case for when there were errors
        if (this.constructor === LGraphNode && this.last_serialization) {
            return this.last_serialization;
        }

        if (this.inputs) {
            o.inputs = this.inputs;
        }

        if (this.outputs) {
            //clear outputs last data (because data in connections is never serialized but stored inside the outputs info)
            for (var i = 0; i < this.outputs.length; i++) {
                delete this.outputs[i]._data;
            }
            o.outputs = this.outputs;
        }

        if (this.title && this.title != this.constructor.title) {
            o.title = this.title;
        }

        if (this.properties) {
            o.properties = LiteGraph.cloneObject(this.properties);
        }

        if (this.widgets && this.serialize_widgets) {
            o.widgets_values = [];
            for (var i = 0; i < this.widgets.length; ++i) {
				if(this.widgets[i])
	                o.widgets_values[i] = this.widgets[i].value;
				else
					o.widgets_values[i] = null;
            }
        }

        if (!o.type) {
            o.type = this.constructor.type;
        }

        if (this.color) {
            o.color = this.color;
        }
        if (this.bgcolor) {
            o.bgcolor = this.bgcolor;
        }
        if (this.boxcolor) {
            o.boxcolor = this.boxcolor;
        }
        if (this.shape) {
            o.shape = this.shape;
        }

        if (this.onSerialize) {
            if (this.onSerialize(o)) {
                console.warn(
                    "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter"
                );
            }
        }

        return o;
    };

    /* Creates a clone of this node */
    LGraphNode.prototype.clone = function() {
        var node = LiteGraph.createNode(this.type);
        if (!node) {
            return null;
        }

        //we clone it because serialize returns shared containers
        var data = LiteGraph.cloneObject(this.serialize());

        //remove links
        if (data.inputs) {
            for (var i = 0; i < data.inputs.length; ++i) {
                data.inputs[i].link = null;
            }
        }

        if (data.outputs) {
            for (var i = 0; i < data.outputs.length; ++i) {
                if (data.outputs[i].links) {
                    data.outputs[i].links.length = 0;
                }
            }
        }

        delete data["id"];
        //remove links
        node.configure(data);

        return node;
    };

    /**
     * serialize and stringify
     * @method toString
     */

    LGraphNode.prototype.toString = function() {
        return JSON.stringify(this.serialize());
    };
    //LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph

    /**
     * get the title string
     * @method getTitle
     */

    LGraphNode.prototype.getTitle = function() {
        return this.title || this.constructor.title;
    };

    /**
     * sets the value of a property
     * @method setProperty
     * @param {String} name
     * @param {*} value
     */
    LGraphNode.prototype.setProperty = function(name, value) {
        if (!this.properties) {
            this.properties = {};
        }
		if( value === this.properties[name] )
			return;
		var prev_value = this.properties[name];
        this.properties[name] = value;
        if (this.onPropertyChanged) {
            if( this.onPropertyChanged(name, value, prev_value) === false ) //abort change
				this.properties[name] = prev_value;
        }
		if(this.widgets) //widgets could be linked to properties
			for(var i = 0; i < this.widgets.length; ++i)
			{
				var w = this.widgets[i];
				if(!w)
					continue;
				if(w.options.property == name)
				{
					w.value = value;
					break;
				}
			}
    };

    // Execution *************************
    /**
     * sets the output data
     * @method setOutputData
     * @param {number} slot
     * @param {*} data
     */
    LGraphNode.prototype.setOutputData = function(slot, data) {
        if (!this.outputs) {
            return;
        }

        //this maybe slow and a niche case
        //if(slot && slot.constructor === String)
        //	slot = this.findOutputSlot(slot);

        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }

        var output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }

        //store data in the output itself in case we want to debug
        output_info._data = data;

        //if there are connections, pass the data to the connections
        if (this.outputs[slot].links) {
            for (var i = 0; i < this.outputs[slot].links.length; i++) {
                var link_id = this.outputs[slot].links[i];
				var link = this.graph.links[link_id];
				if(link)
					link.data = data;
            }
        }
    };

    /**
     * sets the output data type, useful when you want to be able to overwrite the data type
     * @method setOutputDataType
     * @param {number} slot
     * @param {String} datatype
     */
    LGraphNode.prototype.setOutputDataType = function(slot, type) {
        if (!this.outputs) {
            return;
        }
        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }
        var output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }
        //store data in the output itself in case we want to debug
        output_info.type = type;

        //if there are connections, pass the data to the connections
        if (this.outputs[slot].links) {
            for (var i = 0; i < this.outputs[slot].links.length; i++) {
                var link_id = this.outputs[slot].links[i];
                this.graph.links[link_id].type = type;
            }
        }
    };

    /**
     * Retrieves the input data (data traveling through the connection) from one slot
     * @method getInputData
     * @param {number} slot
     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
     * @return {*} data or if it is not connected returns undefined
     */
    LGraphNode.prototype.getInputData = function(slot, force_update) {
        if (!this.inputs) {
            return;
        } //undefined;

        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return;
        }

        var link_id = this.inputs[slot].link;
        var link = this.graph.links[link_id];
        if (!link) {
            //bug: weird case but it happens sometimes
            return null;
        }

        if (!force_update) {
            return link.data;
        }

        //special case: used to extract data from the incoming connection before the graph has been executed
        var node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.data;
        }

        if (node.updateOutputData) {
            node.updateOutputData(link.origin_slot);
        } else if (node.onExecute) {
            node.onExecute();
        }

        return link.data;
    };

    /**
     * Retrieves the input data type (in case this supports multiple input types)
     * @method getInputDataType
     * @param {number} slot
     * @return {String} datatype in string format
     */
    LGraphNode.prototype.getInputDataType = function(slot) {
        if (!this.inputs) {
            return null;
        } //undefined;

        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return null;
        }
        var link_id = this.inputs[slot].link;
        var link = this.graph.links[link_id];
        if (!link) {
            //bug: weird case but it happens sometimes
            return null;
        }
        var node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.type;
        }
        var output_info = node.outputs[link.origin_slot];
        if (output_info) {
            return output_info.type;
        }
        return null;
    };

    /**
     * Retrieves the input data from one slot using its name instead of slot number
     * @method getInputDataByName
     * @param {String} slot_name
     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
     * @return {*} data or if it is not connected returns null
     */
    LGraphNode.prototype.getInputDataByName = function(
        slot_name,
        force_update
    ) {
        var slot = this.findInputSlot(slot_name);
        if (slot == -1) {
            return null;
        }
        return this.getInputData(slot, force_update);
    };

    /**
     * tells you if there is a connection in one input slot
     * @method isInputConnected
     * @param {number} slot
     * @return {boolean}
     */
    LGraphNode.prototype.isInputConnected = function(slot) {
        if (!this.inputs) {
            return false;
        }
        return slot < this.inputs.length && this.inputs[slot].link != null;
    };

    /**
     * tells you info about an input connection (which node, type, etc)
     * @method getInputInfo
     * @param {number} slot
     * @return {Object} object or null { link: id, name: string, type: string or 0 }
     */
    LGraphNode.prototype.getInputInfo = function(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot < this.inputs.length) {
            return this.inputs[slot];
        }
        return null;
    };

    /**
     * Returns the link info in the connection of an input slot
     * @method getInputLink
     * @param {number} slot
     * @return {LLink} object or null
     */
    LGraphNode.prototype.getInputLink = function(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot < this.inputs.length) {
            var slot_info = this.inputs[slot];
			return this.graph.links[ slot_info.link ];
        }
        return null;
    };

    /**
     * returns the node connected in the input slot
     * @method getInputNode
     * @param {number} slot
     * @return {LGraphNode} node or null
     */
    LGraphNode.prototype.getInputNode = function(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot >= this.inputs.length) {
            return null;
        }
        var input = this.inputs[slot];
        if (!input || input.link === null) {
            return null;
        }
        var link_info = this.graph.links[input.link];
        if (!link_info) {
            return null;
        }
        return this.graph.getNodeById(link_info.origin_id);
    };

    /**
     * returns the value of an input with this name, otherwise checks if there is a property with that name
     * @method getInputOrProperty
     * @param {string} name
     * @return {*} value
     */
    LGraphNode.prototype.getInputOrProperty = function(name) {
        if (!this.inputs || !this.inputs.length) {
            return this.properties ? this.properties[name] : null;
        }

        for (var i = 0, l = this.inputs.length; i < l; ++i) {
            var input_info = this.inputs[i];
            if (name == input_info.name && input_info.link != null) {
                var link = this.graph.links[input_info.link];
                if (link) {
                    return link.data;
                }
            }
        }
        return this.properties[name];
    };

    /**
     * tells you the last output data that went in that slot
     * @method getOutputData
     * @param {number} slot
     * @return {Object}  object or null
     */
    LGraphNode.prototype.getOutputData = function(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot >= this.outputs.length) {
            return null;
        }

        var info = this.outputs[slot];
        return info._data;
    };

    /**
     * tells you info about an output connection (which node, type, etc)
     * @method getOutputInfo
     * @param {number} slot
     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }
     */
    LGraphNode.prototype.getOutputInfo = function(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot < this.outputs.length) {
            return this.outputs[slot];
        }
        return null;
    };

    /**
     * tells you if there is a connection in one output slot
     * @method isOutputConnected
     * @param {number} slot
     * @return {boolean}
     */
    LGraphNode.prototype.isOutputConnected = function(slot) {
        if (!this.outputs) {
            return false;
        }
        return (
            slot < this.outputs.length &&
            this.outputs[slot].links &&
            this.outputs[slot].links.length
        );
    };

    /**
     * tells you if there is any connection in the output slots
     * @method isAnyOutputConnected
     * @return {boolean}
     */
    LGraphNode.prototype.isAnyOutputConnected = function() {
        if (!this.outputs) {
            return false;
        }
        for (var i = 0; i < this.outputs.length; ++i) {
            if (this.outputs[i].links && this.outputs[i].links.length) {
                return true;
            }
        }
        return false;
    };

    /**
     * retrieves all the nodes connected to this output slot
     * @method getOutputNodes
     * @param {number} slot
     * @return {array}
     */
    LGraphNode.prototype.getOutputNodes = function(slot) {
        if (!this.outputs || this.outputs.length == 0) {
            return null;
        }

        if (slot >= this.outputs.length) {
            return null;
        }

        var output = this.outputs[slot];
        if (!output.links || output.links.length == 0) {
            return null;
        }

        var r = [];
        for (var i = 0; i < output.links.length; i++) {
            var link_id = output.links[i];
            var link = this.graph.links[link_id];
            if (link) {
                var target_node = this.graph.getNodeById(link.target_id);
                if (target_node) {
                    r.push(target_node);
                }
            }
        }
        return r;
    };

    /**
     * Triggers an event in this node, this will trigger any output with the same name
     * @method trigger
     * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all
     * @param {*} param
     */
    LGraphNode.prototype.trigger = function(action, param) {
        if (!this.outputs || !this.outputs.length) {
            return;
        }

        if (this.graph)
            this.graph._last_trigger_time = LiteGraph.getTime();

        for (var i = 0; i < this.outputs.length; ++i) {
            var output = this.outputs[i];
            if ( !output || output.type !== LiteGraph.EVENT || (action && output.name != action) )
                continue;
            this.triggerSlot(i, param);
        }
    };

    /**
     * Triggers an slot event in this node
     * @method triggerSlot
     * @param {Number} slot the index of the output slot
     * @param {*} param
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
     */
    LGraphNode.prototype.triggerSlot = function(slot, param, link_id) {
        if (!this.outputs) {
            return;
        }

        var output = this.outputs[slot];
        if (!output) {
            return;
        }

        var links = output.links;
        if (!links || !links.length) {
            return;
        }

        if (this.graph) {
            this.graph._last_trigger_time = LiteGraph.getTime();
        }

        //for every link attached here
        for (var k = 0; k < links.length; ++k) {
            var id = links[k];
            if (link_id != null && link_id != id) {
                //to skip links
                continue;
            }
            var link_info = this.graph.links[links[k]];
            if (!link_info) {
                //not connected
                continue;
            }
            link_info._last_time = LiteGraph.getTime();
            var node = this.graph.getNodeById(link_info.target_id);
            if (!node) {
                //node not found?
                continue;
            }

            //used to mark events in graph
            var target_connection = node.inputs[link_info.target_slot];

			if (node.mode === LiteGraph.ON_TRIGGER)
			{
                if (node.onExecute) {
                    node.onExecute(param);
                }
			}
			else if (node.onAction) {
                node.onAction(target_connection.name, param);
            }
        }
    };

    /**
     * clears the trigger slot animation
     * @method clearTriggeredSlot
     * @param {Number} slot the index of the output slot
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
     */
    LGraphNode.prototype.clearTriggeredSlot = function(slot, link_id) {
        if (!this.outputs) {
            return;
        }

        var output = this.outputs[slot];
        if (!output) {
            return;
        }

        var links = output.links;
        if (!links || !links.length) {
            return;
        }

        //for every link attached here
        for (var k = 0; k < links.length; ++k) {
            var id = links[k];
            if (link_id != null && link_id != id) {
                //to skip links
                continue;
            }
            var link_info = this.graph.links[links[k]];
            if (!link_info) {
                //not connected
                continue;
            }
            link_info._last_time = 0;
        }
    };

    /**
     * changes node size and triggers callback
     * @method setSize
     * @param {vec2} size
     */
    LGraphNode.prototype.setSize = function(size)
	{
		this.size = size;
		if(this.onResize)
			this.onResize(this.size);
	}

    /**
     * add a new property to this node
     * @method addProperty
     * @param {string} name
     * @param {*} default_value
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)
     */
    LGraphNode.prototype.addProperty = function(
        name,
        default_value,
        type,
        extra_info
    ) {
        var o = { name: name, type: type, default_value: default_value };
        if (extra_info) {
            for (var i in extra_info) {
                o[i] = extra_info[i];
            }
        }
        if (!this.properties_info) {
            this.properties_info = [];
        }
        this.properties_info.push(o);
        if (!this.properties) {
            this.properties = {};
        }
        this.properties[name] = default_value;
        return o;
    };

    //connections

    /**
     * add a new output slot to use in this node
     * @method addOutput
     * @param {string} name
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of an output (label, special color, position, etc)
     */
    LGraphNode.prototype.addOutput = function(name, type, extra_info) {
        var o = { name: name, type: type, links: null };
        if (extra_info) {
            for (var i in extra_info) {
                o[i] = extra_info[i];
            }
        }

        if (!this.outputs) {
            this.outputs = [];
        }
        this.outputs.push(o);
        if (this.onOutputAdded) {
            this.onOutputAdded(o);
        }
        this.setSize( this.computeSize() );
        this.setDirtyCanvas(true, true);
        return o;
    };

    /**
     * add a new output slot to use in this node
     * @method addOutputs
     * @param {Array} array of triplets like [[name,type,extra_info],[...]]
     */
    LGraphNode.prototype.addOutputs = function(array) {
        for (var i = 0; i < array.length; ++i) {
            var info = array[i];
            var o = { name: info[0], type: info[1], link: null };
            if (array[2]) {
                for (var j in info[2]) {
                    o[j] = info[2][j];
                }
            }

            if (!this.outputs) {
                this.outputs = [];
            }
            this.outputs.push(o);
            if (this.onOutputAdded) {
                this.onOutputAdded(o);
            }
        }

        this.setSize( this.computeSize() );
        this.setDirtyCanvas(true, true);
    };

    /**
     * remove an existing output slot
     * @method removeOutput
     * @param {number} slot
     */
    LGraphNode.prototype.removeOutput = function(slot) {
        this.disconnectOutput(slot);
        this.outputs.splice(slot, 1);
        for (var i = slot; i < this.outputs.length; ++i) {
            if (!this.outputs[i] || !this.outputs[i].links) {
                continue;
            }
            var links = this.outputs[i].links;
            for (var j = 0; j < links.length; ++j) {
                var link = this.graph.links[links[j]];
                if (!link) {
                    continue;
                }
                link.origin_slot -= 1;
            }
        }

        this.setSize( this.computeSize() );
        if (this.onOutputRemoved) {
            this.onOutputRemoved(slot);
        }
        this.setDirtyCanvas(true, true);
    };

    /**
     * add a new input slot to use in this node
     * @method addInput
     * @param {string} name
     * @param {string} type string defining the input type ("vec3","number",...), it its a generic one use 0
     * @param {Object} extra_info this can be used to have special properties of an input (label, color, position, etc)
     */
    LGraphNode.prototype.addInput = function(name, type, extra_info) {
        type = type || 0;
        var o = { name: name, type: type, link: null };
        if (extra_info) {
            for (var i in extra_info) {
                o[i] = extra_info[i];
            }
        }

        if (!this.inputs) {
            this.inputs = [];
        }

        this.inputs.push(o);
        this.setSize( this.computeSize() );

        if (this.onInputAdded) {
            this.onInputAdded(o);
        }

        this.setDirtyCanvas(true, true);
        return o;
    };

    /**
     * add several new input slots in this node
     * @method addInputs
     * @param {Array} array of triplets like [[name,type,extra_info],[...]]
     */
    LGraphNode.prototype.addInputs = function(array) {
        for (var i = 0; i < array.length; ++i) {
            var info = array[i];
            var o = { name: info[0], type: info[1], link: null };
            if (array[2]) {
                for (var j in info[2]) {
                    o[j] = info[2][j];
                }
            }

            if (!this.inputs) {
                this.inputs = [];
            }
            this.inputs.push(o);
            if (this.onInputAdded) {
                this.onInputAdded(o);
            }
        }

        this.setSize( this.computeSize() );
        this.setDirtyCanvas(true, true);
    };

    /**
     * remove an existing input slot
     * @method removeInput
     * @param {number} slot
     */
    LGraphNode.prototype.removeInput = function(slot) {
        this.disconnectInput(slot);
        var slot_info = this.inputs.splice(slot, 1);
        for (var i = slot; i < this.inputs.length; ++i) {
            if (!this.inputs[i]) {
                continue;
            }
            var link = this.graph.links[this.inputs[i].link];
            if (!link) {
                continue;
            }
            link.target_slot -= 1;
        }
        this.setSize( this.computeSize() );
        if (this.onInputRemoved) {
            this.onInputRemoved(slot, slot_info[0] );
        }
        this.setDirtyCanvas(true, true);
    };

    /**
     * add an special connection to this node (used for special kinds of graphs)
     * @method addConnection
     * @param {string} name
     * @param {string} type string defining the input type ("vec3","number",...)
     * @param {[x,y]} pos position of the connection inside the node
     * @param {string} direction if is input or output
     */
    LGraphNode.prototype.addConnection = function(name, type, pos, direction) {
        var o = {
            name: name,
            type: type,
            pos: pos,
            direction: direction,
            links: null
        };
        this.connections.push(o);
        return o;
    };

    /**
     * computes the minimum size of a node according to its inputs and output slots
     * @method computeSize
     * @param {number} minHeight
     * @return {number} the total size
     */
    LGraphNode.prototype.computeSize = function(out) {
        if (this.constructor.size) {
            return this.constructor.size.concat();
        }

        var rows = Math.max(
            this.inputs ? this.inputs.length : 1,
            this.outputs ? this.outputs.length : 1
        );
        var size = out || new Float32Array([0, 0]);
        rows = Math.max(rows, 1);
        var font_size = LiteGraph.NODE_TEXT_SIZE; //although it should be graphcanvas.inner_text_font size

        var font_size = font_size;
        var title_width = compute_text_size(this.title);
        var input_width = 0;
        var output_width = 0;

        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i < l; ++i) {
                var input = this.inputs[i];
                var text = input.label || input.name || "";
                var text_width = compute_text_size(text);
                if (input_width < text_width) {
                    input_width = text_width;
                }
            }
        }

        if (this.outputs) {
            for (var i = 0, l = this.outputs.length; i < l; ++i) {
                var output = this.outputs[i];
                var text = output.label || output.name || "";
                var text_width = compute_text_size(text);
                if (output_width < text_width) {
                    output_width = text_width;
                }
            }
        }

        size[0] = Math.max(input_width + output_width + 10, title_width);
        size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH);
        if (this.widgets && this.widgets.length) {
            size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH * 1.5);
        }

        size[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;

        var widgets_height = 0;
        if (this.widgets && this.widgets.length) {
            for (var i = 0, l = this.widgets.length; i < l; ++i) {
                if (this.widgets[i].computeSize)
                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;
                else
                    widgets_height += LiteGraph.NODE_WIDGET_HEIGHT + 4;
            }
            widgets_height += 8;
        }

        //compute height using widgets height
        if( this.widgets_up )
            size[1] = Math.max( size[1], widgets_height );
        else if( this.widgets_start_y != null )
            size[1] = Math.max( size[1], widgets_height + this.widgets_start_y );
        else
            size[1] += widgets_height;

        function compute_text_size(text) {
            if (!text) {
                return 0;
            }
            return font_size * text.length * 0.6;
        }

        if (
            this.constructor.min_height &&
            size[1] < this.constructor.min_height
        ) {
            size[1] = this.constructor.min_height;
        }

        size[1] += 6; //margin

        return size;
    };

    /**
     * returns all the info available about a property of this node.
     *
     * @method getPropertyInfo
     * @param {String} property name of the property
     * @return {Object} the object with all the available info
    */
    LGraphNode.prototype.getPropertyInfo = function( property )
	{
        var info = null;

		//there are several ways to define info about a property
		//legacy mode
		if (this.properties_info) {
            for (var i = 0; i < this.properties_info.length; ++i) {
                if (this.properties_info[i].name == property) {
                    info = this.properties_info[i];
                    break;
                }
            }
        }
		//litescene mode using the constructor
		if(this.constructor["@" + property])
			info = this.constructor["@" + property];

		if(this.constructor.widgets_info && this.constructor.widgets_info[property])
			info = this.constructor.widgets_info[property];

		//litescene mode using the constructor
		if (!info && this.onGetPropertyInfo) {
            info = this.onGetPropertyInfo(property);
        }

        if (!info)
            info = {};
		if(!info.type)
			info.type = typeof this.properties[property];
		if(info.widget == "combo")
			info.type = "enum";

		return info;
	}

    /**
     * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
     *
     * @method addWidget
     * @param {String} type the widget type (could be "number","string","combo"
     * @param {String} name the text to show on the widget
     * @param {String} value the default value
     * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)
     * @param {Object} options the object that contains special properties of this widget 
     * @return {Object} the created widget object
     */
    LGraphNode.prototype.addWidget = function( type, name, value, callback, options )
	{
        if (!this.widgets) {
            this.widgets = [];
        }

		if(!options && callback && callback.constructor === Object)
		{
			options = callback;
			callback = null;
		}

		if(options && options.constructor === String) //options can be the property name
			options = { property: options };

		if(callback && callback.constructor === String) //callback can be the property name
		{
			if(!options)
				options = {};
			options.property = callback;
			callback = null;
		}

		if(callback && callback.constructor !== Function)
		{
			console.warn("addWidget: callback must be a function");
			callback = null;
		}

        var w = {
            type: type.toLowerCase(),
            name: name,
            value: value,
            callback: callback,
            options: options || {}
        };

        if (w.options.y !== undefined) {
            w.y = w.options.y;
        }

        if (!callback && !w.options.callback && !w.options.property) {
            console.warn("LiteGraph addWidget(...) without a callback or property assigned");
        }
        if (type == "combo" && !w.options.values) {
            throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
        }
        this.widgets.push(w);
		this.setSize( this.computeSize() );
        return w;
    };

    LGraphNode.prototype.addCustomWidget = function(custom_widget) {
        if (!this.widgets) {
            this.widgets = [];
        }
        this.widgets.push(custom_widget);
        return custom_widget;
    };

    /**
     * returns the bounding of the object, used for rendering purposes
     * bounding is: [topleft_cornerx, topleft_cornery, width, height]
     * @method getBounding
     * @return {Float32Array[4]} the total size
     */
    LGraphNode.prototype.getBounding = function(out) {
        out = out || new Float32Array(4);
        out[0] = this.pos[0] - 4;
        out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
        out[2] = this.size[0] + 4;
        out[3] = this.flags.collapsed ? LiteGraph.NODE_TITLE_HEIGHT : this.size[1] + LiteGraph.NODE_TITLE_HEIGHT;

        if (this.onBounding) {
            this.onBounding(out);
        }
        return out;
    };

    /**
     * checks if a point is inside the shape of a node
     * @method isPointInside
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    LGraphNode.prototype.isPointInside = function(x, y, margin, skip_title) {
        margin = margin || 0;

        var margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;
        if (skip_title) {
            margin_top = 0;
        }
        if (this.flags && this.flags.collapsed) {
            //if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] + this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)
            if (
                isInsideRectangle(
                    x,
                    y,
                    this.pos[0] - margin,
                    this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,
                    (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) +
                        2 * margin,
                    LiteGraph.NODE_TITLE_HEIGHT + 2 * margin
                )
            ) {
                return true;
            }
        } else if (
            this.pos[0] - 4 - margin < x &&
            this.pos[0] + this.size[0] + 4 + margin > x &&
            this.pos[1] - margin_top - margin < y &&
            this.pos[1] + this.size[1] + margin > y
        ) {
            return true;
        }
        return false;
    };

    /**
     * checks if a point is inside a node slot, and returns info about which slot
     * @method getSlotInPosition
     * @param {number} x
     * @param {number} y
     * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
     */
    LGraphNode.prototype.getSlotInPosition = function(x, y) {
        //search for inputs
        var link_pos = new Float32Array(2);
        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i < l; ++i) {
                var input = this.inputs[i];
                this.getConnectionPos(true, i, link_pos);
                if (
                    isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10
                    )
                ) {
                    return { input: input, slot: i, link_pos: link_pos };
                }
            }
        }

        if (this.outputs) {
            for (var i = 0, l = this.outputs.length; i < l; ++i) {
                var output = this.outputs[i];
                this.getConnectionPos(false, i, link_pos);
                if (
                    isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10
                    )
                ) {
                    return { output: output, slot: i, link_pos: link_pos };
                }
            }
        }

        return null;
    };

    /**
     * returns the input slot with a given name (used for dynamic slots), -1 if not found
     * @method findInputSlot
     * @param {string} name the name of the slot
     * @return {number} the slot (-1 if not found)
     */
    LGraphNode.prototype.findInputSlot = function(name) {
        if (!this.inputs) {
            return -1;
        }
        for (var i = 0, l = this.inputs.length; i < l; ++i) {
            if (name == this.inputs[i].name) {
                return i;
            }
        }
        return -1;
    };

    /**
     * returns the output slot with a given name (used for dynamic slots), -1 if not found
     * @method findOutputSlot
     * @param {string} name the name of the slot
     * @return {number} the slot (-1 if not found)
     */
    LGraphNode.prototype.findOutputSlot = function(name) {
        if (!this.outputs) {
            return -1;
        }
        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            if (name == this.outputs[i].name) {
                return i;
            }
        }
        return -1;
    };

    /**
     * connect this node output to the input of another node
     * @method connect
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} node the target node
     * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
     * @return {Object} the link_info is created, otherwise null
     */
    LGraphNode.prototype.connect = function(slot, target_node, target_slot) {
        target_slot = target_slot || 0;

        if (!this.graph) {
            //could be connected before adding it to a graph
            console.log(
                "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."
            ); //due to link ids being associated with graphs
            return null;
        }

        //seek for the output slot
        if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                if (LiteGraph.debug) {
                    console.log("Connect: Error, no slot of name " + slot);
                }
                return null;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return null;
        }

        if (target_node && target_node.constructor === Number) {
            target_node = this.graph.getNodeById(target_node);
        }
        if (!target_node) {
            throw "target node is null";
        }

        //avoid loopback
        if (target_node == this) {
            return null;
        }

        //you can specify the slot by name
        if (target_slot.constructor === String) {
            target_slot = target_node.findInputSlot(target_slot);
            if (target_slot == -1) {
                if (LiteGraph.debug) {
                    console.log(
                        "Connect: Error, no slot of name " + target_slot
                    );
                }
                return null;
            }
        } else if (target_slot === LiteGraph.EVENT) {
            //search for first slot with event?
            /*
		//create input for trigger
		var input = target_node.addInput("onTrigger", LiteGraph.EVENT );
		target_slot = target_node.inputs.length - 1; //last one is the one created
		target_node.mode = LiteGraph.ON_TRIGGER;
		*/
            return null;
        } else if (
            !target_node.inputs ||
            target_slot >= target_node.inputs.length
        ) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return null;
        }

		var changed = false;

        //if there is something already plugged there, disconnect
        if (target_node.inputs[target_slot].link != null) {
			this.graph.beforeChange();
            target_node.disconnectInput(target_slot);
			changed = true;
        }

        //why here??
        //this.setDirtyCanvas(false,true);
        //this.graph.connectionChange( this );

        var output = this.outputs[slot];

        //allows nodes to block connection
        if (target_node.onConnectInput) {
            if ( target_node.onConnectInput(target_slot, output.type, output, this, slot) === false ) {
                return null;
            }
        }

        var input = target_node.inputs[target_slot];
        var link_info = null;

		//this slots cannot be connected (different types)
        if (!LiteGraph.isValidConnection(output.type, input.type))
		{
	        this.setDirtyCanvas(false, true);
			if(changed)
		        this.graph.connectionChange(this, link_info);
			return null;
		}

		if(!changed)
			this.graph.beforeChange();

		//create link class
		link_info = new LLink(
			++this.graph.last_link_id,
			input.type,
			this.id,
			slot,
			target_node.id,
			target_slot
		);

		//add to graph links list
		this.graph.links[link_info.id] = link_info;

		//connect in output
		if (output.links == null) {
			output.links = [];
		}
		output.links.push(link_info.id);
		//connect in input
		target_node.inputs[target_slot].link = link_info.id;
		if (this.graph) {
			this.graph._version++;
		}
		if (this.onConnectionsChange) {
			this.onConnectionsChange(
				LiteGraph.OUTPUT,
				slot,
				true,
				link_info,
				output
			);
		} //link_info has been created now, so its updated
		if (target_node.onConnectionsChange) {
			target_node.onConnectionsChange(
				LiteGraph.INPUT,
				target_slot,
				true,
				link_info,
				input
			);
		}
		if (this.graph && this.graph.onNodeConnectionChange) {
			this.graph.onNodeConnectionChange(
				LiteGraph.INPUT,
				target_node,
				target_slot,
				this,
				slot
			);
			this.graph.onNodeConnectionChange(
				LiteGraph.OUTPUT,
				this,
				slot,
				target_node,
				target_slot
			);
		}

        this.setDirtyCanvas(false, true);
		this.graph.afterChange();
		this.graph.connectionChange(this, link_info);

        return link_info;
    };

    /**
     * disconnect one output to an specific node
     * @method disconnectOutput
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]
     * @return {boolean} if it was disconnected successfully
     */
    LGraphNode.prototype.disconnectOutput = function(slot, target_node) {
        if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                if (LiteGraph.debug) {
                    console.log("Connect: Error, no slot of name " + slot);
                }
                return false;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return false;
        }

        //get output slot
        var output = this.outputs[slot];
        if (!output || !output.links || output.links.length == 0) {
            return false;
        }

        //one of the output links in this slot
        if (target_node) {
            if (target_node.constructor === Number) {
                target_node = this.graph.getNodeById(target_node);
            }
            if (!target_node) {
                throw "Target Node not found";
            }

            for (var i = 0, l = output.links.length; i < l; i++) {
                var link_id = output.links[i];
                var link_info = this.graph.links[link_id];

                //is the link we are searching for...
                if (link_info.target_id == target_node.id) {
                    output.links.splice(i, 1); //remove here
                    var input = target_node.inputs[link_info.target_slot];
                    input.link = null; //remove there
                    delete this.graph.links[link_id]; //remove the link from the links pool
                    if (this.graph) {
                        this.graph._version++;
                    }
                    if (target_node.onConnectionsChange) {
                        target_node.onConnectionsChange(
                            LiteGraph.INPUT,
                            link_info.target_slot,
                            false,
                            link_info,
                            input
                        );
                    } //link_info hasn't been modified so its ok
                    if (this.onConnectionsChange) {
                        this.onConnectionsChange(
                            LiteGraph.OUTPUT,
                            slot,
                            false,
                            link_info,
                            output
                        );
                    }
                    if (this.graph && this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            LiteGraph.OUTPUT,
                            this,
                            slot
                        );
                    }
                    if (this.graph && this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            LiteGraph.OUTPUT,
                            this,
                            slot
                        );
                        this.graph.onNodeConnectionChange(
                            LiteGraph.INPUT,
                            target_node,
                            link_info.target_slot
                        );
                    }
                    break;
                }
            }
        } //all the links in this output slot
        else {
            for (var i = 0, l = output.links.length; i < l; i++) {
                var link_id = output.links[i];
                var link_info = this.graph.links[link_id];
                if (!link_info) {
                    //bug: it happens sometimes
                    continue;
                }

                var target_node = this.graph.getNodeById(link_info.target_id);
                var input = null;
                if (this.graph) {
                    this.graph._version++;
                }
                if (target_node) {
                    input = target_node.inputs[link_info.target_slot];
                    input.link = null; //remove other side link
                    if (target_node.onConnectionsChange) {
                        target_node.onConnectionsChange(
                            LiteGraph.INPUT,
                            link_info.target_slot,
                            false,
                            link_info,
                            input
                        );
                    } //link_info hasn't been modified so its ok
                    if (this.graph && this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            LiteGraph.INPUT,
                            target_node,
                            link_info.target_slot
                        );
                    }
                }
                delete this.graph.links[link_id]; //remove the link from the links pool
                if (this.onConnectionsChange) {
                    this.onConnectionsChange(
                        LiteGraph.OUTPUT,
                        slot,
                        false,
                        link_info,
                        output
                    );
                }
                if (this.graph && this.graph.onNodeConnectionChange) {
                    this.graph.onNodeConnectionChange(
                        LiteGraph.OUTPUT,
                        this,
                        slot
                    );
                    this.graph.onNodeConnectionChange(
                        LiteGraph.INPUT,
                        target_node,
                        link_info.target_slot
                    );
                }
            }
            output.links = null;
        }

        this.setDirtyCanvas(false, true);
        this.graph.connectionChange(this);
        return true;
    };

    /**
     * disconnect one input
     * @method disconnectInput
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @return {boolean} if it was disconnected successfully
     */
    LGraphNode.prototype.disconnectInput = function(slot) {
        //seek for the output slot
        if (slot.constructor === String) {
            slot = this.findInputSlot(slot);
            if (slot == -1) {
                if (LiteGraph.debug) {
                    console.log("Connect: Error, no slot of name " + slot);
                }
                return false;
            }
        } else if (!this.inputs || slot >= this.inputs.length) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return false;
        }

        var input = this.inputs[slot];
        if (!input) {
            return false;
        }

        var link_id = this.inputs[slot].link;
		if(link_id != null)
		{
			this.inputs[slot].link = null;

			//remove other side
			var link_info = this.graph.links[link_id];
			if (link_info) {
				var target_node = this.graph.getNodeById(link_info.origin_id);
				if (!target_node) {
					return false;
				}

				var output = target_node.outputs[link_info.origin_slot];
				if (!output || !output.links || output.links.length == 0) {
					return false;
				}

				//search in the inputs list for this link
				for (var i = 0, l = output.links.length; i < l; i++) {
					if (output.links[i] == link_id) {
						output.links.splice(i, 1);
						break;
					}
				}

				delete this.graph.links[link_id]; //remove from the pool
				if (this.graph) {
					this.graph._version++;
				}
				if (this.onConnectionsChange) {
					this.onConnectionsChange(
						LiteGraph.INPUT,
						slot,
						false,
						link_info,
						input
					);
				}
				if (target_node.onConnectionsChange) {
					target_node.onConnectionsChange(
						LiteGraph.OUTPUT,
						i,
						false,
						link_info,
						output
					);
				}
				if (this.graph && this.graph.onNodeConnectionChange) {
					this.graph.onNodeConnectionChange(
						LiteGraph.OUTPUT,
						target_node,
						i
					);
					this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, slot);
				}
			}
		} //link != null

        this.setDirtyCanvas(false, true);
		if(this.graph)
	        this.graph.connectionChange(this);
        return true;
    };

    /**
     * returns the center of a connection point in canvas coords
     * @method getConnectionPos
     * @param {boolean} is_input true if if a input slot, false if it is an output
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {vec2} out [optional] a place to store the output, to free garbage
     * @return {[x,y]} the position
     **/
    LGraphNode.prototype.getConnectionPos = function(
        is_input,
        slot_number,
        out
    ) {
        out = out || new Float32Array(2);
        var num_slots = 0;
        if (is_input && this.inputs) {
            num_slots = this.inputs.length;
        }
        if (!is_input && this.outputs) {
            num_slots = this.outputs.length;
        }

        var offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;

        if (this.flags.collapsed) {
            var w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
            if (this.horizontal) {
                out[0] = this.pos[0] + w * 0.5;
                if (is_input) {
                    out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
                } else {
                    out[1] = this.pos[1];
                }
            } else {
                if (is_input) {
                    out[0] = this.pos[0];
                } else {
                    out[0] = this.pos[0] + w;
                }
                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            }
            return out;
        }

        //weird feature that never got finished
        if (is_input && slot_number == -1) {
            out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            return out;
        }

        //hard-coded pos
        if (
            is_input &&
            num_slots > slot_number &&
            this.inputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
            return out;
        } else if (
            !is_input &&
            num_slots > slot_number &&
            this.outputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
            return out;
        }

        //horizontal distributed slots
        if (this.horizontal) {
            out[0] =
                this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
            if (is_input) {
                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
            } else {
                out[1] = this.pos[1] + this.size[1];
            }
            return out;
        }

        //default vertical slots
        if (is_input) {
            out[0] = this.pos[0] + offset;
        } else {
            out[0] = this.pos[0] + this.size[0] + 1 - offset;
        }
        out[1] =
            this.pos[1] +
            (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +
            (this.constructor.slot_start_y || 0);
        return out;
    };

    /* Force align to grid */
    LGraphNode.prototype.alignToGrid = function() {
        this.pos[0] =
            LiteGraph.CANVAS_GRID_SIZE *
            Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);
        this.pos[1] =
            LiteGraph.CANVAS_GRID_SIZE *
            Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
    };

    /* Console output */
    LGraphNode.prototype.trace = function(msg) {
        if (!this.console) {
            this.console = [];
        }

        this.console.push(msg);
        if (this.console.length > LGraphNode.MAX_CONSOLE) {
            this.console.shift();
        }

		if(this.graph.onNodeTrace)
	        this.graph.onNodeTrace(this, msg);
    };

    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
    LGraphNode.prototype.setDirtyCanvas = function(
        dirty_foreground,
        dirty_background
    ) {
        if (!this.graph) {
            return;
        }
        this.graph.sendActionToCanvas("setDirty", [
            dirty_foreground,
            dirty_background
        ]);
    };

    LGraphNode.prototype.loadImage = function(url) {
        var img = new Image();
        img.src = LiteGraph.node_images_path + url;
        img.ready = false;

        var that = this;
        img.onload = function() {
            this.ready = true;
            that.setDirtyCanvas(true);
        };
        return img;
    };

    //safe LGraphNode action execution (not sure if safe)
    /*
LGraphNode.prototype.executeAction = function(action)
{
	if(action == "") return false;

	if( action.indexOf(";") != -1 || action.indexOf("}") != -1)
	{
		this.trace("Error: Action contains unsafe characters");
		return false;
	}

	var tokens = action.split("(");
	var func_name = tokens[0];
	if( typeof(this[func_name]) != "function")
	{
		this.trace("Error: Action not found on node: " + func_name);
		return false;
	}

	var code = action;

	try
	{
		var _foo = eval;
		eval = null;
		(new Function("with(this) { " + code + "}")).call(this);
		eval = _foo;
	}
	catch (err)
	{
		this.trace("Error executing action {" + action + "} :" + err);
		return false;
	}

	return true;
}
*/

    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
    LGraphNode.prototype.captureInput = function(v) {
        if (!this.graph || !this.graph.list_of_graphcanvas) {
            return;
        }

        var list = this.graph.list_of_graphcanvas;

        for (var i = 0; i < list.length; ++i) {
            var c = list[i];
            //releasing somebody elses capture?!
            if (!v && c.node_capturing_input != this) {
                continue;
            }

            //change
            c.node_capturing_input = v ? this : null;
        }
    };

    /**
     * Collapse the node to make it smaller on the canvas
     * @method collapse
     **/
    LGraphNode.prototype.collapse = function(force) {
        this.graph._version++;
        if (this.constructor.collapsable === false && !force) {
            return;
        }
        if (!this.flags.collapsed) {
            this.flags.collapsed = true;
        } else {
            this.flags.collapsed = false;
        }
        this.setDirtyCanvas(true, true);
    };

    /**
     * Forces the node to do not move or realign on Z
     * @method pin
     **/

    LGraphNode.prototype.pin = function(v) {
        this.graph._version++;
        if (v === undefined) {
            this.flags.pinned = !this.flags.pinned;
        } else {
            this.flags.pinned = v;
        }
    };

    LGraphNode.prototype.localToScreen = function(x, y, graphcanvas) {
        return [
            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],
            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]
        ];
    };

    function LGraphGroup(title) {
        this._ctor(title);
    }

    global.LGraphGroup = LiteGraph.LGraphGroup = LGraphGroup;

    LGraphGroup.prototype._ctor = function(title) {
        this.title = title || "Group";
        this.font_size = 24;
        this.color = LGraphCanvas.node_colors.pale_blue
            ? LGraphCanvas.node_colors.pale_blue.groupcolor
            : "#AAA";
        this._bounding = new Float32Array([10, 10, 140, 80]);
        this._pos = this._bounding.subarray(0, 2);
        this._size = this._bounding.subarray(2, 4);
        this._nodes = [];
        this.graph = null;

        Object.defineProperty(this, "pos", {
            set: function(v) {
                if (!v || v.length < 2) {
                    return;
                }
                this._pos[0] = v[0];
                this._pos[1] = v[1];
            },
            get: function() {
                return this._pos;
            },
            enumerable: true
        });

        Object.defineProperty(this, "size", {
            set: function(v) {
                if (!v || v.length < 2) {
                    return;
                }
                this._size[0] = Math.max(140, v[0]);
                this._size[1] = Math.max(80, v[1]);
            },
            get: function() {
                return this._size;
            },
            enumerable: true
        });
    };

    LGraphGroup.prototype.configure = function(o) {
        this.title = o.title;
        this._bounding.set(o.bounding);
        this.color = o.color;
        this.font = o.font;
    };

    LGraphGroup.prototype.serialize = function() {
        var b = this._bounding;
        return {
            title: this.title,
            bounding: [
                Math.round(b[0]),
                Math.round(b[1]),
                Math.round(b[2]),
                Math.round(b[3])
            ],
            color: this.color,
            font: this.font
        };
    };

    LGraphGroup.prototype.move = function(deltax, deltay, ignore_nodes) {
        this._pos[0] += deltax;
        this._pos[1] += deltay;
        if (ignore_nodes) {
            return;
        }
        for (var i = 0; i < this._nodes.length; ++i) {
            var node = this._nodes[i];
            node.pos[0] += deltax;
            node.pos[1] += deltay;
        }
    };

    LGraphGroup.prototype.recomputeInsideNodes = function() {
        this._nodes.length = 0;
        var nodes = this.graph._nodes;
        var node_bounding = new Float32Array(4);

        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            node.getBounding(node_bounding);
            if (!overlapBounding(this._bounding, node_bounding)) {
                continue;
            } //out of the visible area
            this._nodes.push(node);
        }
    };

    LGraphGroup.prototype.isPointInside = LGraphNode.prototype.isPointInside;
    LGraphGroup.prototype.setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas;

    //****************************************

    //Scale and Offset
    function DragAndScale(element, skip_events) {
        this.offset = new Float32Array([0, 0]);
        this.scale = 1;
        this.max_scale = 10;
        this.min_scale = 0.1;
        this.onredraw = null;
        this.enabled = true;
        this.last_mouse = [0, 0];
        this.element = null;
        this.visible_area = new Float32Array(4);

        if (element) {
            this.element = element;
            if (!skip_events) {
                this.bindEvents(element);
            }
        }
    }

    LiteGraph.DragAndScale = DragAndScale;

    DragAndScale.prototype.bindEvents = function(element) {
        this.last_mouse = new Float32Array(2);

        this._binded_mouse_callback = this.onMouse.bind(this);

        element.addEventListener("mousedown", this._binded_mouse_callback);
        element.addEventListener("mousemove", this._binded_mouse_callback);

        element.addEventListener(
            "mousewheel",
            this._binded_mouse_callback,
            false
        );
        element.addEventListener("wheel", this._binded_mouse_callback, false);
    };

    DragAndScale.prototype.computeVisibleArea = function( viewport ) {
        if (!this.element) {
            this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
            return;
        }
        var width = this.element.width;
        var height = this.element.height;
        var startx = -this.offset[0];
        var starty = -this.offset[1];
		if( viewport )
		{
			startx += viewport[0] / this.scale;
			starty += viewport[1] / this.scale;
			width = viewport[2];
			height = viewport[3];
		}
        var endx = startx + width / this.scale;
        var endy = starty + height / this.scale;
        this.visible_area[0] = startx;
        this.visible_area[1] = starty;
        this.visible_area[2] = endx - startx;
        this.visible_area[3] = endy - starty;
    };

    DragAndScale.prototype.onMouse = function(e) {
        if (!this.enabled) {
            return;
        }

        var canvas = this.element;
        var rect = canvas.getBoundingClientRect();
        var x = e.clientX - rect.left;
        var y = e.clientY - rect.top;
        e.canvasx = x;
        e.canvasy = y;
        e.dragging = this.dragging;

		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );

        var ignore = false;
        if (this.onmouse) {
            ignore = this.onmouse(e);
        }

        if (e.type == "mousedown" && is_inside) {
            this.dragging = true;
            canvas.removeEventListener( "mousemove", this._binded_mouse_callback );
            document.body.addEventListener( "mousemove", this._binded_mouse_callback );
            document.body.addEventListener( "mouseup", this._binded_mouse_callback );
        } else if (e.type == "mousemove") {
            if (!ignore) {
                var deltax = x - this.last_mouse[0];
                var deltay = y - this.last_mouse[1];
                if (this.dragging) {
                    this.mouseDrag(deltax, deltay);
                }
            }
        } else if (e.type == "mouseup") {
            this.dragging = false;
            document.body.removeEventListener( "mousemove", this._binded_mouse_callback );
            document.body.removeEventListener( "mouseup", this._binded_mouse_callback );
            canvas.addEventListener("mousemove", this._binded_mouse_callback );
        } else if ( is_inside &&
            (e.type == "mousewheel" ||
            e.type == "wheel" ||
            e.type == "DOMMouseScroll")
        ) {
            e.eventType = "mousewheel";
            if (e.type == "wheel") {
                e.wheel = -e.deltaY;
            } else {
                e.wheel =
                    e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
            }

            //from stack overflow
            e.delta = e.wheelDelta
                ? e.wheelDelta / 40
                : e.deltaY
                ? -e.deltaY / 3
                : 0;
            this.changeDeltaScale(1.0 + e.delta * 0.05);
        }

        this.last_mouse[0] = x;
        this.last_mouse[1] = y;

		if(is_inside)
		{
	        e.preventDefault();
		    e.stopPropagation();
		    return false;
		}
    };

    DragAndScale.prototype.toCanvasContext = function(ctx) {
        ctx.scale(this.scale, this.scale);
        ctx.translate(this.offset[0], this.offset[1]);
    };

    DragAndScale.prototype.convertOffsetToCanvas = function(pos) {
        //return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];
        return [
            (pos[0] + this.offset[0]) * this.scale,
            (pos[1] + this.offset[1]) * this.scale
        ];
    };

    DragAndScale.prototype.convertCanvasToOffset = function(pos, out) {
        out = out || [0, 0];
        out[0] = pos[0] / this.scale - this.offset[0];
        out[1] = pos[1] / this.scale - this.offset[1];
        return out;
    };

    DragAndScale.prototype.mouseDrag = function(x, y) {
        this.offset[0] += x / this.scale;
        this.offset[1] += y / this.scale;

        if (this.onredraw) {
            this.onredraw(this);
        }
    };

    DragAndScale.prototype.changeScale = function(value, zooming_center) {
        if (value < this.min_scale) {
            value = this.min_scale;
        } else if (value > this.max_scale) {
            value = this.max_scale;
        }

        if (value == this.scale) {
            return;
        }

        if (!this.element) {
            return;
        }

        var rect = this.element.getBoundingClientRect();
        if (!rect) {
            return;
        }

        zooming_center = zooming_center || [
            rect.width * 0.5,
            rect.height * 0.5
        ];
        var center = this.convertCanvasToOffset(zooming_center);
        this.scale = value;
        if (Math.abs(this.scale - 1) < 0.01) {
            this.scale = 1;
        }

        var new_center = this.convertCanvasToOffset(zooming_center);
        var delta_offset = [
            new_center[0] - center[0],
            new_center[1] - center[1]
        ];

        this.offset[0] += delta_offset[0];
        this.offset[1] += delta_offset[1];

        if (this.onredraw) {
            this.onredraw(this);
        }
    };

    DragAndScale.prototype.changeDeltaScale = function(value, zooming_center) {
        this.changeScale(this.scale * value, zooming_center);
    };

    DragAndScale.prototype.reset = function() {
        this.scale = 1;
        this.offset[0] = 0;
        this.offset[1] = 0;
    };

    //*********************************************************************************
    // LGraphCanvas: LGraph renderer CLASS
    //*********************************************************************************

    /**
     * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.
     * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked
     *
     * @class LGraphCanvas
     * @constructor
     * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in string format or the canvas element itself)
     * @param {LGraph} graph [optional]
     * @param {Object} options [optional] { skip_rendering, autoresize, viewport }
     */
    function LGraphCanvas(canvas, graph, options) {
        this.options = options = options || {};

        //if(graph === undefined)
        //	throw ("No graph assigned");
        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;

        if (canvas && canvas.constructor === String) {
            canvas = document.querySelector(canvas);
        }

        this.ds = new DragAndScale();
        this.zoom_modify_alpha = true; //otherwise it generates ugly patterns when scaling down too much

        this.title_text_font = "" + LiteGraph.NODE_TEXT_SIZE + "px Arial";
        this.inner_text_font =
            "normal " + LiteGraph.NODE_SUBTEXT_SIZE + "px Arial";
        this.node_title_color = LiteGraph.NODE_TITLE_COLOR;
        this.default_link_color = LiteGraph.LINK_COLOR;
        this.default_connection_color = {
            input_off: "#778",
            input_on: "#7F7",
            output_off: "#778",
            output_on: "#7F7"
        };

        this.highquality_render = true;
        this.use_gradients = false; //set to true to render titlebar with gradients
        this.editor_alpha = 1; //used for transition
        this.pause_rendering = false;
        this.clear_background = true;

		this.read_only = false; //if set to true users cannot modify the graph
        this.render_only_selected = true;
        this.live_mode = false;
        this.show_info = true;
        this.allow_dragcanvas = true;
        this.allow_dragnodes = true;
        this.allow_interaction = true; //allow to control widgets, buttons, collapse, etc
        this.allow_searchbox = true;
        this.allow_reconnect_links = false; //allows to change a connection with having to redo it again
		this.align_to_grid = false; //snap to grid

        this.drag_mode = false;
        this.dragging_rectangle = null;

        this.filter = null; //allows to filter to only accept some type of nodes in a graph

		this.set_canvas_dirty_on_mouse_event = true; //forces to redraw the canvas if the mouse does anything
        this.always_render_background = false;
        this.render_shadows = true;
        this.render_canvas_border = true;
        this.render_connections_shadows = false; //too much cpu
        this.render_connections_border = true;
        this.render_curved_connections = false;
        this.render_connection_arrows = false;
        this.render_collapsed_slots = true;
        this.render_execution_order = false;
        this.render_title_colored = true;
		this.render_link_tooltip = true;

        this.links_render_mode = LiteGraph.SPLINE_LINK;

        this.mouse = [0, 0]; //mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle
        this.graph_mouse = [0, 0]; //mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle
		this.canvas_mouse = this.graph_mouse; //LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD

        //to personalize the search box
        this.onSearchBox = null;
        this.onSearchBoxSelection = null;

        //callbacks
        this.onMouse = null;
        this.onDrawBackground = null; //to render background objects (behind nodes and connections) in the canvas affected by transform
        this.onDrawForeground = null; //to render foreground objects (above nodes and connections) in the canvas affected by transform
        this.onDrawOverlay = null; //to render foreground objects not affected by transform (for GUIs)
		this.onDrawLinkTooltip = null; //called when rendering a tooltip
		this.onNodeMoved = null; //called after moving a node
		this.onSelectionChange = null; //called if the selection changes
		this.onConnectingChange = null; //called before any link changes
		this.onBeforeChange = null; //called before modifying the graph
		this.onAfterChange = null; //called after modifying the graph

        this.connections_width = 3;
        this.round_radius = 8;

        this.current_node = null;
        this.node_widget = null; //used for widgets
		this.over_link_center = null;
        this.last_mouse_position = [0, 0];
        this.visible_area = this.ds.visible_area;
        this.visible_links = [];

		this.viewport = options.viewport || null; //to constraint render area to a portion of the canvas

        //link canvas and graph
        if (graph) {
            graph.attachCanvas(this);
        }

        this.setCanvas(canvas,options.skip_events);
        this.clear();

        if (!options.skip_render) {
            this.startRendering();
        }

        this.autoresize = options.autoresize;
    }

    global.LGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas;

	LGraphCanvas.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";

    LGraphCanvas.link_type_colors = {
        "-1": LiteGraph.EVENT_LINK_COLOR,
        number: "#AAA",
        node: "#DCA"
    };
    LGraphCanvas.gradients = {}; //cache of gradients

    /**
     * clears all the data inside
     *
     * @method clear
     */
    LGraphCanvas.prototype.clear = function() {
        this.frame = 0;
        this.last_draw_time = 0;
        this.render_time = 0;
        this.fps = 0;

        //this.scale = 1;
        //this.offset = [0,0];

        this.dragging_rectangle = null;

        this.selected_nodes = {};
        this.selected_group = null;

        this.visible_nodes = [];
        this.node_dragged = null;
        this.node_over = null;
        this.node_capturing_input = null;
        this.connecting_node = null;
        this.highlighted_links = {};

		this.dragging_canvas = false;

        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
        this.dirty_area = null;

        this.node_in_panel = null;
        this.node_widget = null;

        this.last_mouse = [0, 0];
        this.last_mouseclick = 0;
        this.visible_area.set([0, 0, 0, 0]);

        if (this.onClear) {
            this.onClear();
        }
    };

    /**
     * assigns a graph, you can reassign graphs to the same canvas
     *
     * @method setGraph
     * @param {LGraph} graph
     */
    LGraphCanvas.prototype.setGraph = function(graph, skip_clear) {
        if (this.graph == graph) {
            return;
        }

        if (!skip_clear) {
            this.clear();
        }

        if (!graph && this.graph) {
            this.graph.detachCanvas(this);
            return;
        }

        graph.attachCanvas(this);

		//remove the graph stack in case a subgraph was open
		if (this._graph_stack)
			this._graph_stack = null;

        this.setDirty(true, true);
    };

    /**
     * returns the top level graph (in case there are subgraphs open on the canvas)
     *
     * @method getTopGraph
     * @return {LGraph} graph
     */
	LGraphCanvas.prototype.getTopGraph = function()
	{
		if(this._graph_stack.length)
			return this._graph_stack[0];
		return this.graph;
	}

    /**
     * opens a graph contained inside a node in the current graph
     *
     * @method openSubgraph
     * @param {LGraph} graph
     */
    LGraphCanvas.prototype.openSubgraph = function(graph) {
        if (!graph) {
            throw "graph cannot be null";
        }

        if (this.graph == graph) {
            throw "graph cannot be the same";
        }

        this.clear();

        if (this.graph) {
            if (!this._graph_stack) {
                this._graph_stack = [];
            }
            this._graph_stack.push(this.graph);
        }

        graph.attachCanvas(this);
		this.checkPanels();
        this.setDirty(true, true);
    };

    /**
     * closes a subgraph contained inside a node
     *
     * @method closeSubgraph
     * @param {LGraph} assigns a graph
     */
    LGraphCanvas.prototype.closeSubgraph = function() {
        if (!this._graph_stack || this._graph_stack.length == 0) {
            return;
        }
        var subgraph_node = this.graph._subgraph_node;
        var graph = this._graph_stack.pop();
        this.selected_nodes = {};
        this.highlighted_links = {};
        graph.attachCanvas(this);
        this.setDirty(true, true);
        if (subgraph_node) {
            this.centerOnNode(subgraph_node);
            this.selectNodes([subgraph_node]);
        }
    };

    /**
     * returns the visualy active graph (in case there are more in the stack)
     * @method getCurrentGraph
     * @return {LGraph} the active graph
     */
    LGraphCanvas.prototype.getCurrentGraph = function() {
        return this.graph;
    };

    /**
     * assigns a canvas
     *
     * @method setCanvas
     * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)
     */
    LGraphCanvas.prototype.setCanvas = function(canvas, skip_events) {
        var that = this;

        if (canvas) {
            if (canvas.constructor === String) {
                canvas = document.getElementById(canvas);
                if (!canvas) {
                    throw "Error creating LiteGraph canvas: Canvas not found";
                }
            }
        }

        if (canvas === this.canvas) {
            return;
        }

        if (!canvas && this.canvas) {
            //maybe detach events from old_canvas
            if (!skip_events) {
                this.unbindEvents();
            }
        }

        this.canvas = canvas;
        this.ds.element = canvas;

        if (!canvas) {
            return;
        }

        //this.canvas.tabindex = "1000";
        canvas.className += " lgraphcanvas";
        canvas.data = this;
        canvas.tabindex = "1"; //to allow key events

        //bg canvas: used for non changing stuff
        this.bgcanvas = null;
        if (!this.bgcanvas) {
            this.bgcanvas = document.createElement("canvas");
            this.bgcanvas.width = this.canvas.width;
            this.bgcanvas.height = this.canvas.height;
        }

        if (canvas.getContext == null) {
            if (canvas.localName != "canvas") {
                throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " +
                    canvas.localName;
            }
            throw "This browser doesn't support Canvas";
        }

        var ctx = (this.ctx = canvas.getContext("2d"));
        if (ctx == null) {
            if (!canvas.webgl_enabled) {
                console.warn(
                    "This canvas seems to be WebGL, enabling WebGL renderer"
                );
            }
            this.enableWebGL();
        }

        //input:  (move and up could be unbinded)
        this._mousemove_callback = this.processMouseMove.bind(this);
        this._mouseup_callback = this.processMouseUp.bind(this);

        if (!skip_events) {
            this.bindEvents();
        }
    };

    //used in some events to capture them
    LGraphCanvas.prototype._doNothing = function doNothing(e) {
        e.preventDefault();
        return false;
    };
    LGraphCanvas.prototype._doReturnTrue = function doNothing(e) {
        e.preventDefault();
        return true;
    };

    /**
     * binds mouse, keyboard, touch and drag events to the canvas
     * @method bindEvents
     **/
    LGraphCanvas.prototype.bindEvents = function() {
        if (this._events_binded) {
            console.warn("LGraphCanvas: events already binded");
            return;
        }

        var canvas = this.canvas;

        var ref_window = this.getCanvasWindow();
        var document = ref_window.document; //hack used when moving canvas between windows

        this._mousedown_callback = this.processMouseDown.bind(this);
        this._mousewheel_callback = this.processMouseWheel.bind(this);
        this._touch_callback = this.touchHandler.bind(this);

        canvas.addEventListener("mousedown", this._mousedown_callback, true); //down do not need to store the binded
        canvas.addEventListener("mousemove", this._mousemove_callback);
        canvas.addEventListener("mousewheel", this._mousewheel_callback, false);

        canvas.addEventListener("contextmenu", this._doNothing);
        canvas.addEventListener(
            "DOMMouseScroll",
            this._mousewheel_callback,
            false
        );

        //touch events
        //if( 'touchstart' in document.documentElement )
        {
            canvas.addEventListener("touchstart", this._touch_callback, true);
            canvas.addEventListener("touchmove", this._touch_callback, true);
            canvas.addEventListener("touchend", this._touch_callback, true);
            canvas.addEventListener("touchcancel", this._touch_callback, true);
        }

        //Keyboard ******************
        this._key_callback = this.processKey.bind(this);

        canvas.addEventListener("keydown", this._key_callback, true);
        document.addEventListener("keyup", this._key_callback, true); //in document, otherwise it doesn't fire keyup

        //Dropping Stuff over nodes ************************************
        this._ondrop_callback = this.processDrop.bind(this);

        canvas.addEventListener("dragover", this._doNothing, false);
        canvas.addEventListener("dragend", this._doNothing, false);
        canvas.addEventListener("drop", this._ondrop_callback, false);
        canvas.addEventListener("dragenter", this._doReturnTrue, false);

        this._events_binded = true;
    };

    /**
     * unbinds mouse events from the canvas
     * @method unbindEvents
     **/
    LGraphCanvas.prototype.unbindEvents = function() {
        if (!this._events_binded) {
            console.warn("LGraphCanvas: no events binded");
            return;
        }

        var ref_window = this.getCanvasWindow();
        var document = ref_window.document;

        this.canvas.removeEventListener("mousedown", this._mousedown_callback);
        this.canvas.removeEventListener(
            "mousewheel",
            this._mousewheel_callback
        );
        this.canvas.removeEventListener(
            "DOMMouseScroll",
            this._mousewheel_callback
        );
        this.canvas.removeEventListener("keydown", this._key_callback);
        document.removeEventListener("keyup", this._key_callback);
        this.canvas.removeEventListener("contextmenu", this._doNothing);
        this.canvas.removeEventListener("drop", this._ondrop_callback);
        this.canvas.removeEventListener("dragenter", this._doReturnTrue);

        this.canvas.removeEventListener("touchstart", this._touch_callback );
        this.canvas.removeEventListener("touchmove", this._touch_callback );
        this.canvas.removeEventListener("touchend", this._touch_callback );
        this.canvas.removeEventListener("touchcancel", this._touch_callback );

        this._mousedown_callback = null;
        this._mousewheel_callback = null;
        this._key_callback = null;
        this._ondrop_callback = null;

        this._events_binded = false;
    };

    LGraphCanvas.getFileExtension = function(url) {
        var question = url.indexOf("?");
        if (question != -1) {
            url = url.substr(0, question);
        }
        var point = url.lastIndexOf(".");
        if (point == -1) {
            return "";
        }
        return url.substr(point + 1).toLowerCase();
    };

    /**
     * this function allows to render the canvas using WebGL instead of Canvas2D
     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL
     * @method enableWebGL
     **/
    LGraphCanvas.prototype.enableWebGL = function() {
        if (typeof GL === undefined) {
            throw "litegl.js must be included to use a WebGL canvas";
        }
        if (typeof enableWebGLCanvas === undefined) {
            throw "webglCanvas.js must be included to use this feature";
        }

        this.gl = this.ctx = enableWebGLCanvas(this.canvas);
        this.ctx.webgl = true;
        this.bgcanvas = this.canvas;
        this.bgctx = this.gl;
        this.canvas.webgl_enabled = true;

        /*
	GL.create({ canvas: this.bgcanvas });
	this.bgctx = enableWebGLCanvas( this.bgcanvas );
	window.gl = this.gl;
	*/
    };

    /**
     * marks as dirty the canvas, this way it will be rendered again
     *
     * @class LGraphCanvas
     * @method setDirty
     * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)
     * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)
     */
    LGraphCanvas.prototype.setDirty = function(fgcanvas, bgcanvas) {
        if (fgcanvas) {
            this.dirty_canvas = true;
        }
        if (bgcanvas) {
            this.dirty_bgcanvas = true;
        }
    };

    /**
     * Used to attach the canvas in a popup
     *
     * @method getCanvasWindow
     * @return {window} returns the window where the canvas is attached (the DOM root node)
     */
    LGraphCanvas.prototype.getCanvasWindow = function() {
        if (!this.canvas) {
            return window;
        }
        var doc = this.canvas.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    };

    /**
     * starts rendering the content of the canvas when needed
     *
     * @method startRendering
     */
    LGraphCanvas.prototype.startRendering = function() {
        if (this.is_rendering) {
            return;
        } //already rendering

        this.is_rendering = true;
        renderFrame.call(this);

        function renderFrame() {
            if (!this.pause_rendering) {
                this.draw();
            }

            var window = this.getCanvasWindow();
            if (this.is_rendering) {
                window.requestAnimationFrame(renderFrame.bind(this));
            }
        }
    };

    /**
     * stops rendering the content of the canvas (to save resources)
     *
     * @method stopRendering
     */
    LGraphCanvas.prototype.stopRendering = function() {
        this.is_rendering = false;
        /*
	if(this.rendering_timer_id)
	{
		clearInterval(this.rendering_timer_id);
		this.rendering_timer_id = null;
	}
	*/
    };

    /* LiteGraphCanvas input */

	//used to block future mouse events (because of im gui)
	LGraphCanvas.prototype.blockClick = function()
	{
		this.block_click = true;
		this.last_mouseclick = 0;
	}

    LGraphCanvas.prototype.processMouseDown = function(e) {

		if( this.set_canvas_dirty_on_mouse_event )
			this.dirty_canvas = true;
		
		if (!this.graph) {
            return;
        }

        this.adjustMouseEvent(e);

        var ref_window = this.getCanvasWindow();
        var document = ref_window.document;
        LGraphCanvas.active_canvas = this;
        var that = this;

		var x = e.localX;
		var y = e.localY;
		//console.log(y,this.viewport);

		this.ds.viewport = this.viewport;
		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );

        //move mouse move event to the window in case it drags outside of the canvas
		if(!this.options.skip_events)
		{
			this.canvas.removeEventListener("mousemove", this._mousemove_callback);
			ref_window.document.addEventListener( "mousemove", this._mousemove_callback, true ); //catch for the entire window
			ref_window.document.addEventListener( "mouseup", this._mouseup_callback, true );
		}

		if(!is_inside)
			return;

        var node = this.graph.getNodeOnPos( e.canvasX, e.canvasY, this.visible_nodes, 5 );
        var skip_dragging = false;
        var skip_action = false;
        var now = LiteGraph.getTime();
        var is_double_click = now - this.last_mouseclick < 300;
		this.mouse[0] = e.localX;
		this.mouse[1] = e.localY;
        this.graph_mouse[0] = e.canvasX;
        this.graph_mouse[1] = e.canvasY;
		this.last_click_position = [this.mouse[0],this.mouse[1]];

        this.canvas.focus();

        LiteGraph.closeAllContextMenus(ref_window);

        if (this.onMouse)
		{
            if (this.onMouse(e) == true)
                return;
        }

		//left button mouse
        if (e.which == 1)
		{
            if (e.ctrlKey)
			{
                this.dragging_rectangle = new Float32Array(4);
                this.dragging_rectangle[0] = e.canvasX;
                this.dragging_rectangle[1] = e.canvasY;
                this.dragging_rectangle[2] = 1;
                this.dragging_rectangle[3] = 1;
                skip_action = true;
            }

            var clicking_canvas_bg = false;

            //when clicked on top of a node
            //and it is not interactive
            if (node && this.allow_interaction && !skip_action && !this.read_only) {
                if (!this.live_mode && !node.flags.pinned) {
                    this.bringToFront(node);
                } //if it wasn't selected?

                //not dragging mouse to connect two slots
                if ( !this.connecting_node && !node.flags.collapsed && !this.live_mode ) {
                    //Search for corner for resize
                    if (
                        !skip_action &&
                        node.resizable !== false &&
                        isInsideRectangle(
                            e.canvasX,
                            e.canvasY,
                            node.pos[0] + node.size[0] - 5,
                            node.pos[1] + node.size[1] - 5,
                            10,
                            10
                        )
                    ) {
						this.graph.beforeChange();						
                        this.resizing_node = node;
                        this.canvas.style.cursor = "se-resize";
                        skip_action = true;
                    } else {
                        //search for outputs
                        if (node.outputs) {
                            for ( var i = 0, l = node.outputs.length; i < l; ++i ) {
                                var output = node.outputs[i];
                                var link_pos = node.getConnectionPos(false, i);
                                if (
                                    isInsideRectangle(
                                        e.canvasX,
                                        e.canvasY,
                                        link_pos[0] - 15,
                                        link_pos[1] - 10,
                                        30,
                                        20
                                    )
                                ) {
                                    this.connecting_node = node;
                                    this.connecting_output = output;
                                    this.connecting_pos = node.getConnectionPos( false, i );
                                    this.connecting_slot = i;

                                    if (e.shiftKey) {
                                        node.disconnectOutput(i);
                                    }

                                    if (is_double_click) {
                                        if (node.onOutputDblClick) {
                                            node.onOutputDblClick(i, e);
                                        }
                                    } else {
                                        if (node.onOutputClick) {
                                            node.onOutputClick(i, e);
                                        }
                                    }

                                    skip_action = true;
                                    break;
                                }
                            }
                        }

                        //search for inputs
                        if (node.inputs) {
                            for ( var i = 0, l = node.inputs.length; i < l; ++i ) {
                                var input = node.inputs[i];
                                var link_pos = node.getConnectionPos(true, i);
                                if (
                                    isInsideRectangle(
                                        e.canvasX,
                                        e.canvasY,
                                        link_pos[0] - 15,
                                        link_pos[1] - 10,
                                        30,
                                        20
                                    )
                                ) {
                                    if (is_double_click) {
                                        if (node.onInputDblClick) {
                                            node.onInputDblClick(i, e);
                                        }
                                    } else {
                                        if (node.onInputClick) {
                                            node.onInputClick(i, e);
                                        }
                                    }

                                    if (input.link !== null) {
                                        var link_info = this.graph.links[
                                            input.link
                                        ]; //before disconnecting
                                        node.disconnectInput(i);

                                        if (
                                            this.allow_reconnect_links ||
                                            e.shiftKey
                                        ) {
                                            this.connecting_node = this.graph._nodes_by_id[
                                                link_info.origin_id
                                            ];
                                            this.connecting_slot =
                                                link_info.origin_slot;
                                            this.connecting_output = this.connecting_node.outputs[
                                                this.connecting_slot
                                            ];
                                            this.connecting_pos = this.connecting_node.getConnectionPos( false, this.connecting_slot );
                                        }

                                        this.dirty_bgcanvas = true;
                                        skip_action = true;
                                    }
                                }
                            }
                        }
                    } //not resizing
                }

                //it wasn't clicked on the links boxes
                if (!skip_action) {
                    var block_drag_node = false;
					var pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];

                    //widgets
                    var widget = this.processNodeWidgets( node, this.graph_mouse, e );
                    if (widget) {
                        block_drag_node = true;
                        this.node_widget = [node, widget];
                    }

                    //double clicking
                    if (is_double_click && this.selected_nodes[node.id]) {
                        //double click node
                        if (node.onDblClick) {
                            node.onDblClick( e, pos, this );
                        }
                        this.processNodeDblClicked(node);
                        block_drag_node = true;
                    }

                    //if do not capture mouse
                    if ( node.onMouseDown && node.onMouseDown( e, pos, this ) ) {
                        block_drag_node = true;
                    } else {
						//open subgraph button
						if(node.subgraph && !node.skip_subgraph_button)
						{
							if ( !node.flags.collapsed && pos[0] > node.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos[1] < 0 ) {
								var that = this;
								setTimeout(function() {
									that.openSubgraph(node.subgraph);
								}, 10);
							}
						}

						if (this.live_mode) {
							clicking_canvas_bg = true;
	                        block_drag_node = true;
						}
                    }

                    if (!block_drag_node) {
                        if (this.allow_dragnodes) {
							this.graph.beforeChange();
                            this.node_dragged = node;
                        }
                        if (!this.selected_nodes[node.id]) {
                            this.processNodeSelected(node, e);
                        }
                    }

                    this.dirty_canvas = true;
                }
            } //clicked outside of nodes
            else {
                //search for link connector
				if(!this.read_only) 
					for (var i = 0; i < this.visible_links.length; ++i) {
						var link = this.visible_links[i];
						var center = link._pos;
						if (
							!center ||
							e.canvasX < center[0] - 4 ||
							e.canvasX > center[0] + 4 ||
							e.canvasY < center[1] - 4 ||
							e.canvasY > center[1] + 4
						) {
							continue;
						}
						//link clicked
						this.showLinkMenu(link, e);
						this.over_link_center = null; //clear tooltip
						break;
					}

                this.selected_group = this.graph.getGroupOnPos( e.canvasX, e.canvasY );
                this.selected_group_resizing = false;
                if (this.selected_group && !this.read_only ) {
                    if (e.ctrlKey) {
                        this.dragging_rectangle = null;
                    }

                    var dist = distance( [e.canvasX, e.canvasY], [ this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1] ] );
                    if (dist * this.ds.scale < 10) {
                        this.selected_group_resizing = true;
                    } else {
                        this.selected_group.recomputeInsideNodes();
                    }
                }

                if (is_double_click && !this.read_only && this.allow_searchbox) {
                    this.showSearchBox(e);
                }

                clicking_canvas_bg = true;
            }

            if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {
                this.dragging_canvas = true;
            }
        } else if (e.which == 2) {
            //middle button
        } else if (e.which == 3) {
            //right button
			if(!this.read_only)
	            this.processContextMenu(node, e);
        }

        //TODO
        //if(this.node_selected != prev_selected)
        //	this.onNodeSelectionChange(this.node_selected);

        this.last_mouse[0] = e.localX;
        this.last_mouse[1] = e.localY;
        this.last_mouseclick = LiteGraph.getTime();
        this.last_mouse_dragging = true;

        /*
	if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)
		this.draw();
	*/

        this.graph.change();

        //this is to ensure to defocus(blur) if a text input element is on focus
        if (
            !ref_window.document.activeElement ||
            (ref_window.document.activeElement.nodeName.toLowerCase() !=
                "input" &&
                ref_window.document.activeElement.nodeName.toLowerCase() !=
                    "textarea")
        ) {
            e.preventDefault();
        }
        e.stopPropagation();

        if (this.onMouseDown) {
            this.onMouseDown(e);
        }

        return false;
    };

    /**
     * Called when a mouse move event has to be processed
     * @method processMouseMove
     **/
    LGraphCanvas.prototype.processMouseMove = function(e) {
        if (this.autoresize) {
            this.resize();
        }

		if( this.set_canvas_dirty_on_mouse_event )
			this.dirty_canvas = true;

        if (!this.graph) {
            return;
        }

        LGraphCanvas.active_canvas = this;
        this.adjustMouseEvent(e);
        var mouse = [e.localX, e.localY];
		this.mouse[0] = mouse[0];
		this.mouse[1] = mouse[1];
        var delta = [
            mouse[0] - this.last_mouse[0],
            mouse[1] - this.last_mouse[1]
        ];
        this.last_mouse = mouse;
        this.graph_mouse[0] = e.canvasX;
        this.graph_mouse[1] = e.canvasY;

		if(this.block_click)
		{
			e.preventDefault();
			return false;
		}

        e.dragging = this.last_mouse_dragging;

        if (this.node_widget) {
            this.processNodeWidgets(
                this.node_widget[0],
                this.graph_mouse,
                e,
                this.node_widget[1]
            );
            this.dirty_canvas = true;
        }

        if (this.dragging_rectangle)
		{
            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];
            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];
            this.dirty_canvas = true;
        } 
		else if (this.selected_group && !this.read_only)
		{
            //moving/resizing a group
            if (this.selected_group_resizing) {
                this.selected_group.size = [
                    e.canvasX - this.selected_group.pos[0],
                    e.canvasY - this.selected_group.pos[1]
                ];
            } else {
                var deltax = delta[0] / this.ds.scale;
                var deltay = delta[1] / this.ds.scale;
                this.selected_group.move(deltax, deltay, e.ctrlKey);
                if (this.selected_group._nodes.length) {
                    this.dirty_canvas = true;
                }
            }
            this.dirty_bgcanvas = true;
        } else if (this.dragging_canvas) {
            this.ds.offset[0] += delta[0] / this.ds.scale;
            this.ds.offset[1] += delta[1] / this.ds.scale;
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
        } else if (this.allow_interaction && !this.read_only) {
            if (this.connecting_node) {
                this.dirty_canvas = true;
            }

            //get node over
            var node = this.graph.getNodeOnPos(e.canvasX,e.canvasY,this.visible_nodes);

            //remove mouseover flag
            for (var i = 0, l = this.graph._nodes.length; i < l; ++i) {
                if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i] ) {
                    //mouse leave
                    this.graph._nodes[i].mouseOver = false;
                    if (this.node_over && this.node_over.onMouseLeave) {
                        this.node_over.onMouseLeave(e);
                    }
                    this.node_over = null;
                    this.dirty_canvas = true;
                }
            }

            //mouse over a node
            if (node) {

				if(node.redraw_on_mouse)
                    this.dirty_canvas = true;

                //this.canvas.style.cursor = "move";
                if (!node.mouseOver) {
                    //mouse enter
                    node.mouseOver = true;
                    this.node_over = node;
                    this.dirty_canvas = true;

                    if (node.onMouseEnter) {
                        node.onMouseEnter(e);
                    }
                }

                //in case the node wants to do something
                if (node.onMouseMove) {
                    node.onMouseMove( e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this );
                }

                //if dragging a link
                if (this.connecting_node) {
                    var pos = this._highlight_input || [0, 0]; //to store the output of isOverNodeInput

                    //on top of input
                    if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {
                        //mouse on top of the corner box, don't know what to do
                    } else {
                        //check if I have a slot below de mouse
                        var slot = this.isOverNodeInput( node, e.canvasX, e.canvasY, pos );
                        if (slot != -1 && node.inputs[slot]) {
                            var slot_type = node.inputs[slot].type;
                            if ( LiteGraph.isValidConnection( this.connecting_output.type, slot_type ) ) {
                                this._highlight_input = pos;
                                this._highlight_input_slot = node.inputs[slot];
                            }
                        } else {
                            this._highlight_input = null;
                            this._highlight_input_slot = null;
                        }
                    }
                }

                //Search for corner
                if (this.canvas) {
                    if (
                        isInsideRectangle(
                            e.canvasX,
                            e.canvasY,
                            node.pos[0] + node.size[0] - 5,
                            node.pos[1] + node.size[1] - 5,
                            5,
                            5
                        )
                    ) {
                        this.canvas.style.cursor = "se-resize";
                    } else {
                        this.canvas.style.cursor = "crosshair";
                    }
                }
            } else { //not over a node

                //search for link connector
				var over_link = null;
				for (var i = 0; i < this.visible_links.length; ++i) {
					var link = this.visible_links[i];
					var center = link._pos;
					if (
						!center ||
						e.canvasX < center[0] - 4 ||
						e.canvasX > center[0] + 4 ||
						e.canvasY < center[1] - 4 ||
						e.canvasY > center[1] + 4
					) {
						continue;
					}
					over_link = link;
					break;
				}
				if( over_link != this.over_link_center )
				{
					this.over_link_center = over_link;
	                this.dirty_canvas = true;
				}

				if (this.canvas) {
	                this.canvas.style.cursor = "";
				}
			} //end

			//send event to node if capturing input (used with widgets that allow drag outside of the area of the node)
            if ( this.node_capturing_input && this.node_capturing_input != node && this.node_capturing_input.onMouseMove ) {
                this.node_capturing_input.onMouseMove(e,[e.canvasX - this.node_capturing_input.pos[0],e.canvasY - this.node_capturing_input.pos[1]], this);
            }

			//node being dragged
            if (this.node_dragged && !this.live_mode) {
				//console.log("draggin!",this.selected_nodes);
                for (var i in this.selected_nodes) {
                    var n = this.selected_nodes[i];
                    n.pos[0] += delta[0] / this.ds.scale;
                    n.pos[1] += delta[1] / this.ds.scale;
                }

                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
            }

            if (this.resizing_node && !this.live_mode) {
                //convert mouse to node space
				var desired_size = [ e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1] ];
				var min_size = this.resizing_node.computeSize();
				desired_size[0] = Math.max( min_size[0], desired_size[0] );
				desired_size[1] = Math.max( min_size[1], desired_size[1] );
				this.resizing_node.setSize( desired_size );

                this.canvas.style.cursor = "se-resize";
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
            }
        }

        e.preventDefault();
        return false;
    };

    /**
     * Called when a mouse up event has to be processed
     * @method processMouseUp
     **/
    LGraphCanvas.prototype.processMouseUp = function(e) {

		if( this.set_canvas_dirty_on_mouse_event )
			this.dirty_canvas = true;

        if (!this.graph)
            return;

        var window = this.getCanvasWindow();
        var document = window.document;
        LGraphCanvas.active_canvas = this;

        //restore the mousemove event back to the canvas
		if(!this.options.skip_events)
		{
			document.removeEventListener("mousemove",this._mousemove_callback,true);
			this.canvas.addEventListener("mousemove",this._mousemove_callback,true);
			document.removeEventListener("mouseup", this._mouseup_callback, true);
		}

        this.adjustMouseEvent(e);
        var now = LiteGraph.getTime();
        e.click_time = now - this.last_mouseclick;
        this.last_mouse_dragging = false;
		this.last_click_position = null;

		if(this.block_click)
		{
			console.log("foo");
			this.block_click = false; //used to avoid sending twice a click in a immediate button
		}

        if (e.which == 1) {

			if( this.node_widget )
			{
				this.processNodeWidgets( this.node_widget[0], this.graph_mouse, e );
			}

            //left button
            this.node_widget = null;

            if (this.selected_group) {
                var diffx =
                    this.selected_group.pos[0] -
                    Math.round(this.selected_group.pos[0]);
                var diffy =
                    this.selected_group.pos[1] -
                    Math.round(this.selected_group.pos[1]);
                this.selected_group.move(diffx, diffy, e.ctrlKey);
                this.selected_group.pos[0] = Math.round(
                    this.selected_group.pos[0]
                );
                this.selected_group.pos[1] = Math.round(
                    this.selected_group.pos[1]
                );
                if (this.selected_group._nodes.length) {
                    this.dirty_canvas = true;
                }
                this.selected_group = null;
            }
            this.selected_group_resizing = false;

            if (this.dragging_rectangle) {
                if (this.graph) {
                    var nodes = this.graph._nodes;
                    var node_bounding = new Float32Array(4);
                    this.deselectAllNodes();
                    //compute bounding and flip if left to right
                    var w = Math.abs(this.dragging_rectangle[2]);
                    var h = Math.abs(this.dragging_rectangle[3]);
                    var startx =
                        this.dragging_rectangle[2] < 0
                            ? this.dragging_rectangle[0] - w
                            : this.dragging_rectangle[0];
                    var starty =
                        this.dragging_rectangle[3] < 0
                            ? this.dragging_rectangle[1] - h
                            : this.dragging_rectangle[1];
                    this.dragging_rectangle[0] = startx;
                    this.dragging_rectangle[1] = starty;
                    this.dragging_rectangle[2] = w;
                    this.dragging_rectangle[3] = h;

                    //test against all nodes (not visible because the rectangle maybe start outside
                    var to_select = [];
                    for (var i = 0; i < nodes.length; ++i) {
                        var node = nodes[i];
                        node.getBounding(node_bounding);
                        if (
                            !overlapBounding(
                                this.dragging_rectangle,
                                node_bounding
                            )
                        ) {
                            continue;
                        } //out of the visible area
                        to_select.push(node);
                    }
                    if (to_select.length) {
                        this.selectNodes(to_select);
                    }
                }
                this.dragging_rectangle = null;
            } else if (this.connecting_node) {
                //dragging a connection
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;

                var node = this.graph.getNodeOnPos(
                    e.canvasX,
                    e.canvasY,
                    this.visible_nodes
                );

                //node below mouse
                if (node) {
                    if (
                        this.connecting_output.type == LiteGraph.EVENT &&
                        this.isOverNodeBox(node, e.canvasX, e.canvasY)
                    ) {
                        this.connecting_node.connect(
                            this.connecting_slot,
                            node,
                            LiteGraph.EVENT
                        );
                    } else {
                        //slot below mouse? connect
                        var slot = this.isOverNodeInput(
                            node,
                            e.canvasX,
                            e.canvasY
                        );
                        if (slot != -1) {
                            this.connecting_node.connect(
                                this.connecting_slot,
                                node,
                                slot
                            );
                        } else {
                            //not on top of an input
                            var input = node.getInputInfo(0);
                            //auto connect
                            if (
                                this.connecting_output.type == LiteGraph.EVENT
                            ) {
                                this.connecting_node.connect(
                                    this.connecting_slot,
                                    node,
                                    LiteGraph.EVENT
                                );
                            } else if (
                                input &&
                                !input.link &&
                                LiteGraph.isValidConnection(
                                    input.type && this.connecting_output.type
                                )
                            ) {
                                this.connecting_node.connect(
                                    this.connecting_slot,
                                    node,
                                    0
                                );
                            }
                        }
                    }
                }

                this.connecting_output = null;
                this.connecting_pos = null;
                this.connecting_node = null;
                this.connecting_slot = -1;
            } //not dragging connection
            else if (this.resizing_node) {
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
				this.graph.afterChange(this.resizing_node);
                this.resizing_node = null;
            } else if (this.node_dragged) {
                //node being dragged?
                var node = this.node_dragged;
                if (
                    node &&
                    e.click_time < 300 &&
                    isInsideRectangle( e.canvasX, e.canvasY, node.pos[0], node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT )
                ) {
                    node.collapse();
                }

                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
                if (this.graph.config.align_to_grid || this.align_to_grid ) {
                    this.node_dragged.alignToGrid();
                }
				if( this.onNodeMoved )
					this.onNodeMoved( this.node_dragged );
				this.graph.afterChange(this.node_dragged);
                this.node_dragged = null;
            } //no node being dragged
            else {
                //get node over
                var node = this.graph.getNodeOnPos(
                    e.canvasX,
                    e.canvasY,
                    this.visible_nodes
                );

                if (!node && e.click_time < 300) {
                    this.deselectAllNodes();
                }

                this.dirty_canvas = true;
                this.dragging_canvas = false;

                if (this.node_over && this.node_over.onMouseUp) {
                    this.node_over.onMouseUp( e, [ e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1] ], this );
                }
                if (
                    this.node_capturing_input &&
                    this.node_capturing_input.onMouseUp
                ) {
                    this.node_capturing_input.onMouseUp(e, [
                        e.canvasX - this.node_capturing_input.pos[0],
                        e.canvasY - this.node_capturing_input.pos[1]
                    ]);
                }
            }
        } else if (e.which == 2) {
            //middle button
            //trace("middle");
            this.dirty_canvas = true;
            this.dragging_canvas = false;
        } else if (e.which == 3) {
            //right button
            //trace("right");
            this.dirty_canvas = true;
            this.dragging_canvas = false;
        }

        /*
	if((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)
		this.draw();
	*/

        this.graph.change();

        e.stopPropagation();
        e.preventDefault();
        return false;
    };

    /**
     * Called when a mouse wheel event has to be processed
     * @method processMouseWheel
     **/
    LGraphCanvas.prototype.processMouseWheel = function(e) {
        if (!this.graph || !this.allow_dragcanvas) {
            return;
        }

        var delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;

        this.adjustMouseEvent(e);

		var x = e.localX;
		var y = e.localY;
		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
		if(!is_inside)
			return;

        var scale = this.ds.scale;

        if (delta > 0) {
            scale *= 1.1;
        } else if (delta < 0) {
            scale *= 1 / 1.1;
        }

        //this.setZoom( scale, [ e.localX, e.localY ] );
        this.ds.changeScale(scale, [e.localX, e.localY]);

        this.graph.change();

        e.preventDefault();
        return false; // prevent default
    };

    /**
     * returns true if a position (in graph space) is on top of a node little corner box
     * @method isOverNodeBox
     **/
    LGraphCanvas.prototype.isOverNodeBox = function(node, canvasx, canvasy) {
        var title_height = LiteGraph.NODE_TITLE_HEIGHT;
        if (
            isInsideRectangle(
                canvasx,
                canvasy,
                node.pos[0] + 2,
                node.pos[1] + 2 - title_height,
                title_height - 4,
                title_height - 4
            )
        ) {
            return true;
        }
        return false;
    };

    /**
     * returns true if a position (in graph space) is on top of a node input slot
     * @method isOverNodeInput
     **/
    LGraphCanvas.prototype.isOverNodeInput = function(
        node,
        canvasx,
        canvasy,
        slot_pos
    ) {
        if (node.inputs) {
            for (var i = 0, l = node.inputs.length; i < l; ++i) {
                var input = node.inputs[i];
                var link_pos = node.getConnectionPos(true, i);
                var is_inside = false;
                if (node.horizontal) {
                    is_inside = isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 5,
                        link_pos[1] - 10,
                        10,
                        20
                    );
                } else {
                    is_inside = isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        40,
                        10
                    );
                }
                if (is_inside) {
                    if (slot_pos) {
                        slot_pos[0] = link_pos[0];
                        slot_pos[1] = link_pos[1];
                    }
                    return i;
                }
            }
        }
        return -1;
    };

    /**
     * process a key event
     * @method processKey
     **/
    LGraphCanvas.prototype.processKey = function(e) {
        if (!this.graph) {
            return;
        }

        var block_default = false;
        //console.log(e); //debug

        if (e.target.localName == "input") {
            return;
        }

        if (e.type == "keydown") {
            if (e.keyCode == 32) {
                //esc
                this.dragging_canvas = true;
                block_default = true;
            }

            //select all Control A
            if (e.keyCode == 65 && e.ctrlKey) {
                this.selectNodes();
                block_default = true;
            }

            if (e.code == "KeyC" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
                //copy
                if (this.selected_nodes) {
                    this.copyToClipboard();
                    block_default = true;
                }
            }

            if (e.code == "KeyV" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
                //paste
                this.pasteFromClipboard();
            }

            //delete or backspace
            if (e.keyCode == 46 || e.keyCode == 8) {
                if (
                    e.target.localName != "input" &&
                    e.target.localName != "textarea"
                ) {
                    this.deleteSelectedNodes();
                    block_default = true;
                }
            }

            //collapse
            //...

            //TODO
            if (this.selected_nodes) {
                for (var i in this.selected_nodes) {
                    if (this.selected_nodes[i].onKeyDown) {
                        this.selected_nodes[i].onKeyDown(e);
                    }
                }
            }
        } else if (e.type == "keyup") {
            if (e.keyCode == 32) {
                this.dragging_canvas = false;
            }

            if (this.selected_nodes) {
                for (var i in this.selected_nodes) {
                    if (this.selected_nodes[i].onKeyUp) {
                        this.selected_nodes[i].onKeyUp(e);
                    }
                }
            }
        }

        this.graph.change();

        if (block_default) {
            e.preventDefault();
            e.stopImmediatePropagation();
            return false;
        }
    };

    LGraphCanvas.prototype.copyToClipboard = function() {
        var clipboard_info = {
            nodes: [],
            links: []
        };
        var index = 0;
        var selected_nodes_array = [];
        for (var i in this.selected_nodes) {
            var node = this.selected_nodes[i];
            node._relative_id = index;
            selected_nodes_array.push(node);
            index += 1;
        }

        for (var i = 0; i < selected_nodes_array.length; ++i) {
            var node = selected_nodes_array[i];
			var cloned = node.clone();
			if(!cloned)
			{
				console.warn("node type not found: " + node.type );
				continue;
			}
            clipboard_info.nodes.push(cloned.serialize());
            if (node.inputs && node.inputs.length) {
                for (var j = 0; j < node.inputs.length; ++j) {
                    var input = node.inputs[j];
                    if (!input || input.link == null) {
                        continue;
                    }
                    var link_info = this.graph.links[input.link];
                    if (!link_info) {
                        continue;
                    }
                    var target_node = this.graph.getNodeById(
                        link_info.origin_id
                    );
                    if (!target_node || !this.selected_nodes[target_node.id]) {
                        //improve this by allowing connections to non-selected nodes
                        continue;
                    } //not selected
                    clipboard_info.links.push([
                        target_node._relative_id,
                        link_info.origin_slot, //j,
                        node._relative_id,
                        link_info.target_slot
                    ]);
                }
            }
        }
        localStorage.setItem(
            "litegrapheditor_clipboard",
            JSON.stringify(clipboard_info)
        );
    };

    LGraphCanvas.prototype.pasteFromClipboard = function() {
        var data = localStorage.getItem("litegrapheditor_clipboard");
        if (!data) {
            return;
        }

		this.graph.beforeChange();

        //create nodes
        var clipboard_info = JSON.parse(data);
        var nodes = [];
        for (var i = 0; i < clipboard_info.nodes.length; ++i) {
            var node_data = clipboard_info.nodes[i];
            var node = LiteGraph.createNode(node_data.type);
            if (node) {
                node.configure(node_data);
                node.pos[0] += 5;
                node.pos[1] += 5;
                this.graph.add(node);
                nodes.push(node);
            }
        }

        //create links
        for (var i = 0; i < clipboard_info.links.length; ++i) {
            var link_info = clipboard_info.links[i];
            var origin_node = nodes[link_info[0]];
            var target_node = nodes[link_info[2]];
			if( origin_node && target_node )
	            origin_node.connect(link_info[1], target_node, link_info[3]);
			else
				console.warn("Warning, nodes missing on pasting");
        }

        this.selectNodes(nodes);

		this.graph.afterChange();
    };

    /**
     * process a item drop event on top the canvas
     * @method processDrop
     **/
    LGraphCanvas.prototype.processDrop = function(e) {
        e.preventDefault();
        this.adjustMouseEvent(e);
		var x = e.localX;
		var y = e.localY;
		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
		if(!is_inside)
			return;

        var pos = [e.canvasX, e.canvasY];


        var node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;

        if (!node) {
            var r = null;
            if (this.onDropItem) {
                r = this.onDropItem(event);
            }
            if (!r) {
                this.checkDropItem(e);
            }
            return;
        }

        if (node.onDropFile || node.onDropData) {
            var files = e.dataTransfer.files;
            if (files && files.length) {
                for (var i = 0; i < files.length; i++) {
                    var file = e.dataTransfer.files[0];
                    var filename = file.name;
                    var ext = LGraphCanvas.getFileExtension(filename);
                    //console.log(file);

                    if (node.onDropFile) {
                        node.onDropFile(file);
                    }

                    if (node.onDropData) {
                        //prepare reader
                        var reader = new FileReader();
                        reader.onload = function(event) {
                            //console.log(event.target);
                            var data = event.target.result;
                            node.onDropData(data, filename, file);
                        };

                        //read data
                        var type = file.type.split("/")[0];
                        if (type == "text" || type == "") {
                            reader.readAsText(file);
                        } else if (type == "image") {
                            reader.readAsDataURL(file);
                        } else {
                            reader.readAsArrayBuffer(file);
                        }
                    }
                }
            }
        }

        if (node.onDropItem) {
            if (node.onDropItem(event)) {
                return true;
            }
        }

        if (this.onDropItem) {
            return this.onDropItem(event);
        }

        return false;
    };

    //called if the graph doesn't have a default drop item behaviour
    LGraphCanvas.prototype.checkDropItem = function(e) {
        if (e.dataTransfer.files.length) {
            var file = e.dataTransfer.files[0];
            var ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();
            var nodetype = LiteGraph.node_types_by_file_extension[ext];
            if (nodetype) {
				this.graph.beforeChange();
                var node = LiteGraph.createNode(nodetype.type);
                node.pos = [e.canvasX, e.canvasY];
                this.graph.add(node);
                if (node.onDropFile) {
                    node.onDropFile(file);
                }
				this.graph.afterChange();
            }
        }
    };

    LGraphCanvas.prototype.processNodeDblClicked = function(n) {
        if (this.onShowNodePanel) {
            this.onShowNodePanel(n);
        }
		else
		{
			this.showShowNodePanel(n);
		}

        if (this.onNodeDblClicked) {
            this.onNodeDblClicked(n);
        }

        this.setDirty(true);
    };

    LGraphCanvas.prototype.processNodeSelected = function(node, e) {
        this.selectNode(node, e && e.shiftKey);
        if (this.onNodeSelected) {
            this.onNodeSelected(node);
        }
    };

    /**
     * selects a given node (or adds it to the current selection)
     * @method selectNode
     **/
    LGraphCanvas.prototype.selectNode = function(
        node,
        add_to_current_selection
    ) {
        if (node == null) {
            this.deselectAllNodes();
        } else {
            this.selectNodes([node], add_to_current_selection);
        }
    };

    /**
     * selects several nodes (or adds them to the current selection)
     * @method selectNodes
     **/
    LGraphCanvas.prototype.selectNodes = function( nodes, add_to_current_selection )
	{
        if (!add_to_current_selection) {
            this.deselectAllNodes();
        }

        nodes = nodes || this.graph._nodes;
        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            if (node.is_selected) {
                continue;
            }

            if (!node.is_selected && node.onSelected) {
                node.onSelected();
            }
            node.is_selected = true;
            this.selected_nodes[node.id] = node;

            if (node.inputs) {
                for (var j = 0; j < node.inputs.length; ++j) {
                    this.highlighted_links[node.inputs[j].link] = true;
                }
            }
            if (node.outputs) {
                for (var j = 0; j < node.outputs.length; ++j) {
                    var out = node.outputs[j];
                    if (out.links) {
                        for (var k = 0; k < out.links.length; ++k) {
                            this.highlighted_links[out.links[k]] = true;
                        }
                    }
                }
            }
        }

		if(	this.onSelectionChange )
			this.onSelectionChange( this.selected_nodes );

        this.setDirty(true);
    };

    /**
     * removes a node from the current selection
     * @method deselectNode
     **/
    LGraphCanvas.prototype.deselectNode = function(node) {
        if (!node.is_selected) {
            return;
        }
        if (node.onDeselected) {
            node.onDeselected();
        }
        node.is_selected = false;

        if (this.onNodeDeselected) {
            this.onNodeDeselected(node);
        }

        //remove highlighted
        if (node.inputs) {
            for (var i = 0; i < node.inputs.length; ++i) {
                delete this.highlighted_links[node.inputs[i].link];
            }
        }
        if (node.outputs) {
            for (var i = 0; i < node.outputs.length; ++i) {
                var out = node.outputs[i];
                if (out.links) {
                    for (var j = 0; j < out.links.length; ++j) {
                        delete this.highlighted_links[out.links[j]];
                    }
                }
            }
        }
    };

    /**
     * removes all nodes from the current selection
     * @method deselectAllNodes
     **/
    LGraphCanvas.prototype.deselectAllNodes = function() {
        if (!this.graph) {
            return;
        }
        var nodes = this.graph._nodes;
        for (var i = 0, l = nodes.length; i < l; ++i) {
            var node = nodes[i];
            if (!node.is_selected) {
                continue;
            }
            if (node.onDeselected) {
                node.onDeselected();
            }
            node.is_selected = false;
			if (this.onNodeDeselected) {
				this.onNodeDeselected(node);
			}
        }
        this.selected_nodes = {};
        this.current_node = null;
        this.highlighted_links = {};
		if(	this.onSelectionChange )
			this.onSelectionChange( this.selected_nodes );
        this.setDirty(true);
    };

    /**
     * deletes all nodes in the current selection from the graph
     * @method deleteSelectedNodes
     **/
    LGraphCanvas.prototype.deleteSelectedNodes = function() {

		this.graph.beforeChange();

        for (var i in this.selected_nodes) {
            var node = this.selected_nodes[i];

			if(node.block_delete)
				continue;

			//autoconnect when possible (very basic, only takes into account first input-output)
			if(node.inputs && node.inputs.length && node.outputs && node.outputs.length && LiteGraph.isValidConnection( node.inputs[0].type, node.outputs[0].type ) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length ) 
			{
				var input_link = node.graph.links[ node.inputs[0].link ];
				var output_link = node.graph.links[ node.outputs[0].links[0] ];
				var input_node = node.getInputNode(0);
				var output_node = node.getOutputNodes(0)[0];
				if(input_node && output_node)
					input_node.connect( input_link.origin_slot, output_node, output_link.target_slot );
			}
            this.graph.remove(node);
			if (this.onNodeDeselected) {
				this.onNodeDeselected(node);
			}
        }
        this.selected_nodes = {};
        this.current_node = null;
        this.highlighted_links = {};
        this.setDirty(true);
		this.graph.afterChange();
    };

    /**
     * centers the camera on a given node
     * @method centerOnNode
     **/
    LGraphCanvas.prototype.centerOnNode = function(node) {
        this.ds.offset[0] =
            -node.pos[0] -
            node.size[0] * 0.5 +
            (this.canvas.width * 0.5) / this.ds.scale;
        this.ds.offset[1] =
            -node.pos[1] -
            node.size[1] * 0.5 +
            (this.canvas.height * 0.5) / this.ds.scale;
        this.setDirty(true, true);
    };

    /**
     * adds some useful properties to a mouse event, like the position in graph coordinates
     * @method adjustMouseEvent
     **/
    LGraphCanvas.prototype.adjustMouseEvent = function(e) {
        if (this.canvas) {
            var b = this.canvas.getBoundingClientRect();
            e.localX = e.clientX - b.left;
            e.localY = e.clientY - b.top;
        } else {
            e.localX = e.clientX;
            e.localY = e.clientY;
        }

        e.deltaX = e.localX - this.last_mouse_position[0];
        e.deltaY = e.localY - this.last_mouse_position[1];

        this.last_mouse_position[0] = e.localX;
        this.last_mouse_position[1] = e.localY;

        e.canvasX = e.localX / this.ds.scale - this.ds.offset[0];
        e.canvasY = e.localY / this.ds.scale - this.ds.offset[1];
    };

    /**
     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom
     * @method setZoom
     **/
    LGraphCanvas.prototype.setZoom = function(value, zooming_center) {
        this.ds.changeScale(value, zooming_center);
        /*
	if(!zooming_center && this.canvas)
		zooming_center = [this.canvas.width * 0.5,this.canvas.height * 0.5];

	var center = this.convertOffsetToCanvas( zooming_center );

	this.ds.scale = value;

	if(this.scale > this.max_zoom)
		this.scale = this.max_zoom;
	else if(this.scale < this.min_zoom)
		this.scale = this.min_zoom;

	var new_center = this.convertOffsetToCanvas( zooming_center );
	var delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];

	this.offset[0] += delta_offset[0];
	this.offset[1] += delta_offset[1];
	*/

        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
    };

    /**
     * converts a coordinate from graph coordinates to canvas2D coordinates
     * @method convertOffsetToCanvas
     **/
    LGraphCanvas.prototype.convertOffsetToCanvas = function(pos, out) {
        return this.ds.convertOffsetToCanvas(pos, out);
    };

    /**
     * converts a coordinate from Canvas2D coordinates to graph space
     * @method convertCanvasToOffset
     **/
    LGraphCanvas.prototype.convertCanvasToOffset = function(pos, out) {
        return this.ds.convertCanvasToOffset(pos, out);
    };

    //converts event coordinates from canvas2D to graph coordinates
    LGraphCanvas.prototype.convertEventToCanvasOffset = function(e) {
        var rect = this.canvas.getBoundingClientRect();
        return this.convertCanvasToOffset([
            e.clientX - rect.left,
            e.clientY - rect.top
        ]);
    };

    /**
     * brings a node to front (above all other nodes)
     * @method bringToFront
     **/
    LGraphCanvas.prototype.bringToFront = function(node) {
        var i = this.graph._nodes.indexOf(node);
        if (i == -1) {
            return;
        }

        this.graph._nodes.splice(i, 1);
        this.graph._nodes.push(node);
    };

    /**
     * sends a node to the back (below all other nodes)
     * @method sendToBack
     **/
    LGraphCanvas.prototype.sendToBack = function(node) {
        var i = this.graph._nodes.indexOf(node);
        if (i == -1) {
            return;
        }

        this.graph._nodes.splice(i, 1);
        this.graph._nodes.unshift(node);
    };

    /* Interaction */

    /* LGraphCanvas render */
    var temp = new Float32Array(4);

    /**
     * checks which nodes are visible (inside the camera area)
     * @method computeVisibleNodes
     **/
    LGraphCanvas.prototype.computeVisibleNodes = function(nodes, out) {
        var visible_nodes = out || [];
        visible_nodes.length = 0;
        nodes = nodes || this.graph._nodes;
        for (var i = 0, l = nodes.length; i < l; ++i) {
            var n = nodes[i];

            //skip rendering nodes in live mode
            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {
                continue;
            }

            if (!overlapBounding(this.visible_area, n.getBounding(temp))) {
                continue;
            } //out of the visible area

            visible_nodes.push(n);
        }
        return visible_nodes;
    };

    /**
     * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)
     * @method draw
     **/
    LGraphCanvas.prototype.draw = function(force_canvas, force_bgcanvas) {
        if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {
            return;
        }

        //fps counting
        var now = LiteGraph.getTime();
        this.render_time = (now - this.last_draw_time) * 0.001;
        this.last_draw_time = now;

        if (this.graph) {
            this.ds.computeVisibleArea(this.viewport);
        }

        if (
            this.dirty_bgcanvas ||
            force_bgcanvas ||
            this.always_render_background ||
            (this.graph &&
                this.graph._last_trigger_time &&
                now - this.graph._last_trigger_time < 1000)
        ) {
            this.drawBackCanvas();
        }

        if (this.dirty_canvas || force_canvas) {
            this.drawFrontCanvas();
        }

        this.fps = this.render_time ? 1.0 / this.render_time : 0;
        this.frame += 1;
    };

    /**
     * draws the front canvas (the one containing all the nodes)
     * @method drawFrontCanvas
     **/
    LGraphCanvas.prototype.drawFrontCanvas = function() {
        this.dirty_canvas = false;

        if (!this.ctx) {
            this.ctx = this.bgcanvas.getContext("2d");
        }
        var ctx = this.ctx;
        if (!ctx) {
            //maybe is using webgl...
            return;
        }

        var canvas = this.canvas;
        if ( ctx.start2D && !this.viewport ) {
            ctx.start2D();
			ctx.restore();
			ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        //clip dirty area if there is one, otherwise work in full canvas
		var area = this.viewport || this.dirty_area;
        if (area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect( area[0],area[1],area[2],area[3] );
            ctx.clip();
        }

        //clear
        //canvas.width = canvas.width;
        if (this.clear_background) {
			if(area)
	            ctx.clearRect( area[0],area[1],area[2],area[3] );
			else
	            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        //draw bg canvas
        if (this.bgcanvas == this.canvas) {
            this.drawBackCanvas();
        } else {
            ctx.drawImage( this.bgcanvas, 0, 0 );
        }

        //rendering
        if (this.onRender) {
            this.onRender(canvas, ctx);
        }

        //info widget
        if (this.show_info) {
            this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0 );
        }

        if (this.graph) {
            //apply transformations
            ctx.save();
            this.ds.toCanvasContext(ctx);

            //draw nodes
            var drawn_nodes = 0;
            var visible_nodes = this.computeVisibleNodes(
                null,
                this.visible_nodes
            );

            for (var i = 0; i < visible_nodes.length; ++i) {
                var node = visible_nodes[i];

                //transform coords system
                ctx.save();
                ctx.translate(node.pos[0], node.pos[1]);

                //Draw
                this.drawNode(node, ctx);
                drawn_nodes += 1;

                //Restore
                ctx.restore();
            }

            //on top (debug)
            if (this.render_execution_order) {
                this.drawExecutionOrder(ctx);
            }

            //connections ontop?
            if (this.graph.config.links_ontop) {
                if (!this.live_mode) {
                    this.drawConnections(ctx);
                }
            }

            //current connection (the one being dragged by the mouse)
            if (this.connecting_pos != null) {
                ctx.lineWidth = this.connections_width;
                var link_color = null;

                switch (this.connecting_output.type) {
                    case LiteGraph.EVENT:
                        link_color = LiteGraph.EVENT_LINK_COLOR;
                        break;
                    default:
                        link_color = LiteGraph.CONNECTING_LINK_COLOR;
                }

                //the connection being dragged by the mouse
                this.renderLink(
                    ctx,
                    this.connecting_pos,
                    [this.graph_mouse[0], this.graph_mouse[1]],
                    null,
                    false,
                    null,
                    link_color,
                    this.connecting_output.dir ||
                        (this.connecting_node.horizontal
                            ? LiteGraph.DOWN
                            : LiteGraph.RIGHT),
                    LiteGraph.CENTER
                );

                ctx.beginPath();
                if (
                    this.connecting_output.type === LiteGraph.EVENT ||
                    this.connecting_output.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(
                        this.connecting_pos[0] - 6 + 0.5,
                        this.connecting_pos[1] - 5 + 0.5,
                        14,
                        10
                    );
                } else if (this.connecting_output.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5);
                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5);
                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5);
                    ctx.closePath();
                } 
                else {
                    ctx.arc(
                        this.connecting_pos[0],
                        this.connecting_pos[1],
                        4,
                        0,
                        Math.PI * 2
                    );
                }
                ctx.fill();

                ctx.fillStyle = "#ffcc00";
                if (this._highlight_input) {
                    ctx.beginPath();
                    var shape = this._highlight_input_slot.shape;
                    if (shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);
                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);
                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
                        ctx.arc(
                            this._highlight_input[0],
                            this._highlight_input[1],
                            6,
                            0,
                            Math.PI * 2
                        );
                    }
                    ctx.fill();
                }
            }

			//the selection rectangle
            if (this.dragging_rectangle) {
                ctx.strokeStyle = "#FFF";
                ctx.strokeRect(
                    this.dragging_rectangle[0],
                    this.dragging_rectangle[1],
                    this.dragging_rectangle[2],
                    this.dragging_rectangle[3]
                );
            }

			//on top of link center
			if(this.over_link_center && this.render_link_tooltip)
				this.drawLinkTooltip( ctx, this.over_link_center );
			else
				if(this.onDrawLinkTooltip) //to remove
					this.onDrawLinkTooltip(ctx,null);

			//custom info
            if (this.onDrawForeground) {
                this.onDrawForeground(ctx, this.visible_rect);
            }

            ctx.restore();
        }

		//draws panel in the corner 
		if (this._graph_stack && this._graph_stack.length) {
			this.drawSubgraphPanel( ctx );
		}


        if (this.onDrawOverlay) {
            this.onDrawOverlay(ctx);
        }

        if (area) {
            ctx.restore();
        }

        if (ctx.finish2D) {
            //this is a function I use in webgl renderer
            ctx.finish2D();
        }
    };

    /**
     * draws the panel in the corner that shows subgraph properties
     * @method drawSubgraphPanel
     **/
	LGraphCanvas.prototype.drawSubgraphPanel = function(ctx) {
		var subgraph = this.graph;
		var subnode = subgraph._subgraph_node;
		if(!subnode)
		{
			console.warn("subgraph without subnode");
			return;
		}

		var num = subnode.inputs ? subnode.inputs.length : 0;
		var w = 300;
		var h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);

		ctx.fillStyle = "#111";
		ctx.globalAlpha = 0.8;
		ctx.beginPath();
		ctx.roundRect(10,10,w, (num + 1) * h + 50,8 );
		ctx.fill();
		ctx.globalAlpha = 1;

		ctx.fillStyle = "#888";
		ctx.font = "14px Arial";
		ctx.textAlign = "left";
		ctx.fillText( "Graph Inputs", 20, 34 );
		var pos = this.mouse;

		if( this.drawButton( w - 20, 20,20,20, "X", "#151515" ) )
		{
			this.closeSubgraph();
			return;
		}

		var y = 50;
		ctx.font = "20px Arial";
		if(subnode.inputs)
		for(var i = 0; i < subnode.inputs.length; ++i)
		{
			var input = subnode.inputs[i];
			if(input.not_subgraph_input)
				continue;

			//input button clicked
			if( this.drawButton( 20,y+2,w - 20, h - 2 ) )
			{
				var type = subnode.constructor.input_node_type || "graph/input";
				this.graph.beforeChange();
				var newnode = LiteGraph.createNode( type );
				if(newnode)
				{
					subgraph.add( newnode );
					this.block_click = false;
					this.last_click_position = null;
					this.selectNodes([newnode]);
					this.node_dragged = newnode;
					this.dragging_canvas = false;
					newnode.setProperty("name",input.name);
					newnode.setProperty("type",input.type);
					this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
					this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
					this.graph.afterChange();
				}
				else
					console.error("graph input node not found:",type);
			}

			ctx.fillStyle = "#9C9";
			ctx.beginPath();
			ctx.arc(w - 16,y + h * 0.5,5,0,2*Math.PI);
			ctx.fill();

			ctx.fillStyle = "#AAA";
			ctx.fillText( input.name, 50, y + h*0.75 );
			var tw = ctx.measureText( input.name );
			ctx.fillStyle = "#777";
			ctx.fillText( input.type, 50 + tw.width + 10, y + h*0.75 );

			y += h;
		}

		//add + button
		if( this.drawButton( 20,y+2,w - 20, h - 2, "+", "#151515", "#222" ) )
		{
			this.showSubgraphPropertiesDialog( subnode );
		}
	}

	//Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm
	LGraphCanvas.prototype.drawButton = function( x,y,w,h, text, bgcolor, hovercolor, textcolor )
	{
		var ctx = this.ctx;
		bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;
		hovercolor = hovercolor || "#555";
		textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;

		var pos = this.mouse;
		var hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
		pos = this.last_click_position;
		var clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );

		ctx.fillStyle = hover ? hovercolor : bgcolor;
		if(clicked)
			ctx.fillStyle = "#AAA";
		ctx.beginPath();
		ctx.roundRect(x,y,w,h,4 );
		ctx.fill();

		if(text != null)
		{
			if(text.constructor == String)
			{
				ctx.fillStyle = textcolor;
				ctx.textAlign = "center";
				ctx.font = ((h * 0.65)|0) + "px Arial";
				ctx.fillText( text, x + w * 0.5,y + h * 0.75 );
				ctx.textAlign = "left";
			}
		}

		var was_clicked = clicked && !this.block_click;
		if(clicked)
			this.blockClick();
		return was_clicked;
	}

	LGraphCanvas.prototype.isAreaClicked = function( x,y,w,h, hold_click )
	{
		var pos = this.mouse;
		var hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
		pos = this.last_click_position;
		var clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
		var was_clicked = clicked && !this.block_click;
		if(clicked && hold_click)
			this.blockClick();
		return was_clicked;
	}

    /**
     * draws some useful stats in the corner of the canvas
     * @method renderInfo
     **/
    LGraphCanvas.prototype.renderInfo = function(ctx, x, y) {
        x = x || 10;
        y = y || this.canvas.height - 80;

        ctx.save();
        ctx.translate(x, y);

        ctx.font = "10px Arial";
        ctx.fillStyle = "#888";
		ctx.textAlign = "left";
        if (this.graph) {
            ctx.fillText( "T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1 );
            ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2 );
            ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3 );
            ctx.fillText("V: " + this.graph._version, 5, 13 * 4);
            ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);
        } else {
            ctx.fillText("No graph selected", 5, 13 * 1);
        }
        ctx.restore();
    };

    /**
     * draws the back canvas (the one containing the background and the connections)
     * @method drawBackCanvas
     **/
    LGraphCanvas.prototype.drawBackCanvas = function() {
        var canvas = this.bgcanvas;
        if (
            canvas.width != this.canvas.width ||
            canvas.height != this.canvas.height
        ) {
            canvas.width = this.canvas.width;
            canvas.height = this.canvas.height;
        }

        if (!this.bgctx) {
            this.bgctx = this.bgcanvas.getContext("2d");
        }
        var ctx = this.bgctx;
        if (ctx.start) {
            ctx.start();
        }

		var viewport = this.viewport || [0,0,ctx.canvas.width,ctx.canvas.height];

        //clear
        if (this.clear_background) {
            ctx.clearRect( viewport[0], viewport[1], viewport[2], viewport[3] );
        }

		//show subgraph stack header
        if (this._graph_stack && this._graph_stack.length) {
            ctx.save();
            var parent_graph = this._graph_stack[this._graph_stack.length - 1];
            var subgraph_node = this.graph._subgraph_node;
            ctx.strokeStyle = subgraph_node.bgcolor;
            ctx.lineWidth = 10;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            ctx.lineWidth = 1;
            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            ctx.fillStyle = subgraph_node.bgcolor || "#AAA";
            var title = "";
            for (var i = 1; i < this._graph_stack.length; ++i) {
                title +=
                    this._graph_stack[i]._subgraph_node.getTitle() + " >> ";
            }
            ctx.fillText(
                title + subgraph_node.getTitle(),
                canvas.width * 0.5,
                40
            );
            ctx.restore();
        }

        var bg_already_painted = false;
        if (this.onRenderBackground) {
            bg_already_painted = this.onRenderBackground(canvas, ctx);
        }

        //reset in case of error
        if ( !this.viewport )
		{
	        ctx.restore();
		    ctx.setTransform(1, 0, 0, 1, 0, 0);
		}
        this.visible_links.length = 0;

        if (this.graph) {
            //apply transformations
            ctx.save();
            this.ds.toCanvasContext(ctx);

            //render BG
            if (
                this.background_image &&
                this.ds.scale > 0.5 &&
                !bg_already_painted
            ) {
                if (this.zoom_modify_alpha) {
                    ctx.globalAlpha =
                        (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;
                } else {
                    ctx.globalAlpha = this.editor_alpha;
                }
                ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.imageSmoothingEnabled = false;
                if (
                    !this._bg_img ||
                    this._bg_img.name != this.background_image
                ) {
                    this._bg_img = new Image();
                    this._bg_img.name = this.background_image;
                    this._bg_img.src = this.background_image;
                    var that = this;
                    this._bg_img.onload = function() {
                        that.draw(true, true);
                    };
                }

                var pattern = null;
                if (this._pattern == null && this._bg_img.width > 0) {
                    pattern = ctx.createPattern(this._bg_img, "repeat");
                    this._pattern_img = this._bg_img;
                    this._pattern = pattern;
                } else {
                    pattern = this._pattern;
                }
                if (pattern) {
                    ctx.fillStyle = pattern;
                    ctx.fillRect(
                        this.visible_area[0],
                        this.visible_area[1],
                        this.visible_area[2],
                        this.visible_area[3]
                    );
                    ctx.fillStyle = "transparent";
                }

                ctx.globalAlpha = 1.0;
                ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.imageSmoothingEnabled = true;
            }

            //groups
            if (this.graph._groups.length && !this.live_mode) {
                this.drawGroups(canvas, ctx);
            }

            if (this.onDrawBackground) {
                this.onDrawBackground(ctx, this.visible_area);
            }
            if (this.onBackgroundRender) {
                //LEGACY
                console.error(
                    "WARNING! onBackgroundRender deprecated, now is named onDrawBackground "
                );
                this.onBackgroundRender = null;
            }

            //DEBUG: show clipping area
            //ctx.fillStyle = "red";
            //ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);

            //bg
            if (this.render_canvas_border) {
                ctx.strokeStyle = "#235";
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }

            if (this.render_connections_shadows) {
                ctx.shadowColor = "#000";
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.shadowBlur = 6;
            } else {
                ctx.shadowColor = "rgba(0,0,0,0)";
            }

            //draw connections
            if (!this.live_mode) {
                this.drawConnections(ctx);
            }

            ctx.shadowColor = "rgba(0,0,0,0)";

            //restore state
            ctx.restore();
        }

        if (ctx.finish) {
            ctx.finish();
        }

        this.dirty_bgcanvas = false;
        this.dirty_canvas = true; //to force to repaint the front canvas with the bgcanvas
    };

    var temp_vec2 = new Float32Array(2);

    /**
     * draws the given node inside the canvas
     * @method drawNode
     **/
    LGraphCanvas.prototype.drawNode = function(node, ctx) {
        var glow = false;
        this.current_node = node;

        var color = node.color || node.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;
        var bgcolor = node.bgcolor || node.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;

        //shadow and glow
        if (node.mouseOver) {
            glow = true;
        }

        var low_quality = this.ds.scale < 0.6; //zoomed out

        //only render if it forces it to do it
        if (this.live_mode) {
            if (!node.flags.collapsed) {
                ctx.shadowColor = "transparent";
                if (node.onDrawForeground) {
                    node.onDrawForeground(ctx, this, this.canvas);
                }
            }
            return;
        }

        var editor_alpha = this.editor_alpha;
        ctx.globalAlpha = editor_alpha;

        if (this.render_shadows && !low_quality) {
            ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
            ctx.shadowOffsetX = 2 * this.ds.scale;
            ctx.shadowOffsetY = 2 * this.ds.scale;
            ctx.shadowBlur = 3 * this.ds.scale;
        } else {
            ctx.shadowColor = "transparent";
        }

        //custom draw collapsed method (draw after shadows because they are affected)
        if (
            node.flags.collapsed &&
            node.onDrawCollapsed &&
            node.onDrawCollapsed(ctx, this) == true
        ) {
            return;
        }

        //clip if required (mask)
        var shape = node._shape || LiteGraph.BOX_SHAPE;
        var size = temp_vec2;
        temp_vec2.set(node.size);
        var horizontal = node.horizontal; // || node.flags.horizontal;

        if (node.flags.collapsed) {
            ctx.font = this.inner_text_font;
            var title = node.getTitle ? node.getTitle() : node.title;
            if (title != null) {
                node._collapsed_width = Math.min(
                    node.size[0],
                    ctx.measureText(title).width +
                        LiteGraph.NODE_TITLE_HEIGHT * 2
                ); //LiteGraph.NODE_COLLAPSED_WIDTH;
                size[0] = node._collapsed_width;
                size[1] = 0;
            }
        }

        if (node.clip_area) {
            //Start clipping
            ctx.save();
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE) {
                ctx.rect(0, 0, size[0], size[1]);
            } else if (shape == LiteGraph.ROUND_SHAPE) {
                ctx.roundRect(0, 0, size[0], size[1], 10);
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5,
                    0,
                    Math.PI * 2
                );
            }
            ctx.clip();
        }

        //draw shape
        if (node.has_errors) {
            bgcolor = "red";
        }
        this.drawNodeShape(
            node,
            ctx,
            size,
            color,
            bgcolor,
            node.is_selected,
            node.mouseOver
        );
        ctx.shadowColor = "transparent";

        //draw foreground
        if (node.onDrawForeground) {
            node.onDrawForeground(ctx, this, this.canvas);
        }

        //connection slots
        ctx.textAlign = horizontal ? "center" : "left";
        ctx.font = this.inner_text_font;

        var render_text = !low_quality;

        var out_slot = this.connecting_output;
        ctx.lineWidth = 1;

        var max_y = 0;
        var slot_pos = new Float32Array(2); //to reuse

        //render inputs and outputs
        if (!node.flags.collapsed) {
            //input connection slots
            if (node.inputs) {
                for (var i = 0; i < node.inputs.length; i++) {
                    var slot = node.inputs[i];

                    ctx.globalAlpha = editor_alpha;
                    //change opacity of incompatible slots when dragging a connection
                    if ( this.connecting_node && !LiteGraph.isValidConnection( slot.type , out_slot.type) ) {
                        ctx.globalAlpha = 0.4 * editor_alpha;
                    }

                    ctx.fillStyle =
                        slot.link != null
                            ? slot.color_on ||
                              this.default_connection_color.input_on
                            : slot.color_off ||
                              this.default_connection_color.input_off;

                    var pos = node.getConnectionPos(true, i, slot_pos);
                    pos[0] -= node.pos[0];
                    pos[1] -= node.pos[1];
                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
                    }

                    ctx.beginPath();

                    if (
                        slot.type === LiteGraph.EVENT ||
                        slot.shape === LiteGraph.BOX_SHAPE
                    ) {
                        if (horizontal) {
                            ctx.rect(
                                pos[0] - 5 + 0.5,
                                pos[1] - 8 + 0.5,
                                10,
                                14
                            );
                        } else {
                            ctx.rect(
                                pos[0] - 6 + 0.5,
                                pos[1] - 5 + 0.5,
                                14,
                                10
                            );
                        }
                    } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
						if(low_quality)
	                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 ); //faster
						else
	                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
                    }
                    ctx.fill();

                    //render name
                    if (render_text) {
                        var text = slot.label != null ? slot.label : slot.name;
                        if (text) {
                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                            if (horizontal || slot.dir == LiteGraph.UP) {
                                ctx.fillText(text, pos[0], pos[1] - 10);
                            } else {
                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);
                            }
                        }
                    }
                }
            }

            //output connection slots
            if (this.connecting_node) {
                ctx.globalAlpha = 0.4 * editor_alpha;
            }

            ctx.textAlign = horizontal ? "center" : "right";
            ctx.strokeStyle = "black";
            if (node.outputs) {
                for (var i = 0; i < node.outputs.length; i++) {
                    var slot = node.outputs[i];

                    var pos = node.getConnectionPos(false, i, slot_pos);
                    pos[0] -= node.pos[0];
                    pos[1] -= node.pos[1];
                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
                    }

                    ctx.fillStyle =
                        slot.links && slot.links.length
                            ? slot.color_on ||
                              this.default_connection_color.output_on
                            : slot.color_off ||
                              this.default_connection_color.output_off;
                    ctx.beginPath();
                    //ctx.rect( node.size[0] - 14,i*14,10,10);

                    if (
                        slot.type === LiteGraph.EVENT ||
                        slot.shape === LiteGraph.BOX_SHAPE
                    ) {
                        if (horizontal) {
                            ctx.rect(
                                pos[0] - 5 + 0.5,
                                pos[1] - 8 + 0.5,
                                10,
                                14
                            );
                        } else {
                            ctx.rect(
                                pos[0] - 6 + 0.5,
                                pos[1] - 5 + 0.5,
                                14,
                                10
                            );
                        }
                    } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
						if(low_quality)
	                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 );
						else
	                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
                    }

                    //trigger
                    //if(slot.node_id != null && slot.slot == -1)
                    //	ctx.fillStyle = "#F85";

                    //if(slot.links != null && slot.links.length)
                    ctx.fill();
					if(!low_quality)
	                    ctx.stroke();

                    //render output name
                    if (render_text) {
                        var text = slot.label != null ? slot.label : slot.name;
                        if (text) {
                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                            if (horizontal || slot.dir == LiteGraph.DOWN) {
                                ctx.fillText(text, pos[0], pos[1] - 8);
                            } else {
                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);
                            }
                        }
                    }
                }
            }

            ctx.textAlign = "left";
            ctx.globalAlpha = 1;

            if (node.widgets) {
				var widgets_y = max_y;
                if (horizontal || node.widgets_up) {
                    widgets_y = 2;
                }
				if( node.widgets_start_y != null )
                    widgets_y = node.widgets_start_y;
                this.drawNodeWidgets(
                    node,
                    widgets_y,
                    ctx,
                    this.node_widget && this.node_widget[0] == node
                        ? this.node_widget[1]
                        : null
                );
            }
        } else if (this.render_collapsed_slots) {
            //if collapsed
            var input_slot = null;
            var output_slot = null;

            //get first connected slot to render
            if (node.inputs) {
                for (var i = 0; i < node.inputs.length; i++) {
                    var slot = node.inputs[i];
                    if (slot.link == null) {
                        continue;
                    }
                    input_slot = slot;
                    break;
                }
            }
            if (node.outputs) {
                for (var i = 0; i < node.outputs.length; i++) {
                    var slot = node.outputs[i];
                    if (!slot.links || !slot.links.length) {
                        continue;
                    }
                    output_slot = slot;
                }
            }

            if (input_slot) {
                var x = 0;
                var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; //center
                if (horizontal) {
                    x = node._collapsed_width * 0.5;
                    y = -LiteGraph.NODE_TITLE_HEIGHT;
                }
                ctx.fillStyle = "#686";
                ctx.beginPath();
                if (
                    slot.type === LiteGraph.EVENT ||
                    slot.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);
                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(x + 8, y);
                    ctx.lineTo(x + -4, y - 4);
                    ctx.lineTo(x + -4, y + 4);
                    ctx.closePath();
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
            }

            if (output_slot) {
                var x = node._collapsed_width;
                var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; //center
                if (horizontal) {
                    x = node._collapsed_width * 0.5;
                    y = 0;
                }
                ctx.fillStyle = "#686";
                ctx.strokeStyle = "black";
                ctx.beginPath();
                if (
                    slot.type === LiteGraph.EVENT ||
                    slot.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);
                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(x + 6, y);
                    ctx.lineTo(x - 6, y - 4);
                    ctx.lineTo(x - 6, y + 4);
                    ctx.closePath();
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
                //ctx.stroke();
            }
        }

        if (node.clip_area) {
            ctx.restore();
        }

        ctx.globalAlpha = 1.0;
    };

	//used by this.over_link_center
	LGraphCanvas.prototype.drawLinkTooltip = function( ctx, link )
	{
		var pos = link._pos;
		ctx.fillStyle = "black";
		ctx.beginPath();
		ctx.arc( pos[0], pos[1], 3, 0, Math.PI * 2 );
		ctx.fill();

		if(link.data == null)
			return;

		if(this.onDrawLinkTooltip)
			if( this.onDrawLinkTooltip(ctx,link,this) == true )
				return;

		var data = link.data;
		var text = null;

		if( data.constructor === Number )
			text = data.toFixed(2);
		else if( data.constructor === String )
			text = "\"" + data + "\"";
		else if( data.constructor === Boolean )
			text = String(data);
		else if (data.toToolTip)
			text = data.toToolTip();
		else
			text = "[" + data.constructor.name + "]";

		if(text == null)
			return;
		text = text.substr(0,30); //avoid weird

		ctx.font = "14px Courier New";
		var info = ctx.measureText(text);
		var w = info.width + 20;
		var h = 24;
		ctx.shadowColor = "black";
		ctx.shadowOffsetX = 2;
		ctx.shadowOffsetY = 2;
		ctx.shadowBlur = 3;
		ctx.fillStyle = "#454";
		ctx.beginPath();
		ctx.roundRect( pos[0] - w*0.5, pos[1] - 15 - h, w, h,3, 3);
		ctx.moveTo( pos[0] - 10, pos[1] - 15 );
		ctx.lineTo( pos[0] + 10, pos[1] - 15 );
		ctx.lineTo( pos[0], pos[1] - 5 );
		ctx.fill();
        ctx.shadowColor = "transparent";
		ctx.textAlign = "center";
		ctx.fillStyle = "#CEC";
		ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);
	}

    /**
     * draws the shape of the given node in the canvas
     * @method drawNodeShape
     **/
    var tmp_area = new Float32Array(4);

    LGraphCanvas.prototype.drawNodeShape = function(
        node,
        ctx,
        size,
        fgcolor,
        bgcolor,
        selected,
        mouse_over
    ) {
        //bg rect
        ctx.strokeStyle = fgcolor;
        ctx.fillStyle = bgcolor;

        var title_height = LiteGraph.NODE_TITLE_HEIGHT;
        var low_quality = this.ds.scale < 0.5;

        //render node area depending on shape
        var shape =
            node._shape || node.constructor.shape || LiteGraph.ROUND_SHAPE;

        var title_mode = node.constructor.title_mode;

        var render_title = true;
        if (title_mode == LiteGraph.TRANSPARENT_TITLE) {
            render_title = false;
        } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {
            render_title = true;
        }

        var area = tmp_area;
        area[0] = 0; //x
        area[1] = render_title ? -title_height : 0; //y
        area[2] = size[0] + 1; //w
        area[3] = render_title ? size[1] + title_height : size[1]; //h

        var old_alpha = ctx.globalAlpha;

        //full node shape
        //if(node.flags.collapsed)
        {
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE || low_quality) {
                ctx.fillRect(area[0], area[1], area[2], area[3]);
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                shape == LiteGraph.CARD_SHAPE
            ) {
                ctx.roundRect(
                    area[0],
                    area[1],
                    area[2],
                    area[3],
                    this.round_radius,
                    shape == LiteGraph.CARD_SHAPE ? 0 : this.round_radius
                );
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5,
                    0,
                    Math.PI * 2
                );
            }
            ctx.fill();

			//separator
			if(!node.flags.collapsed)
			{
				ctx.shadowColor = "transparent";
				ctx.fillStyle = "rgba(0,0,0,0.2)";
				ctx.fillRect(0, -1, area[2], 2);
			}
        }
        ctx.shadowColor = "transparent";

        if (node.onDrawBackground) {
            node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse );
        }

        //title bg (remember, it is rendered ABOVE the node)
        if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {
            //title bar
            if (node.onDrawTitleBar) {
                node.onDrawTitleBar( ctx, title_height, size, this.ds.scale, fgcolor );
            } else if (
                title_mode != LiteGraph.TRANSPARENT_TITLE &&
                (node.constructor.title_color || this.render_title_colored)
            ) {
                var title_color = node.constructor.title_color || fgcolor;

                if (node.flags.collapsed) {
                    ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
                }

                //* gradient test
                if (this.use_gradients) {
                    var grad = LGraphCanvas.gradients[title_color];
                    if (!grad) {
                        grad = LGraphCanvas.gradients[ title_color ] = ctx.createLinearGradient(0, 0, 400, 0);
                        grad.addColorStop(0, title_color);
                        grad.addColorStop(1, "#000");
                    }
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = title_color;
                }

                //ctx.globalAlpha = 0.5 * old_alpha;
                ctx.beginPath();
                if (shape == LiteGraph.BOX_SHAPE || low_quality) {
                    ctx.rect(0, -title_height, size[0] + 1, title_height);
                } else if (  shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE ) {
                    ctx.roundRect(
                        0,
                        -title_height,
                        size[0] + 1,
                        title_height,
                        this.round_radius,
                        node.flags.collapsed ? this.round_radius : 0
                    );
                }
                ctx.fill();
                ctx.shadowColor = "transparent";
            }

            //title box
            var box_size = 10;
            if (node.onDrawTitleBox) {
                node.onDrawTitleBox(ctx, title_height, size, this.ds.scale);
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                shape == LiteGraph.CIRCLE_SHAPE ||
                shape == LiteGraph.CARD_SHAPE
            ) {
                if (low_quality) {
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(
                        title_height * 0.5,
                        title_height * -0.5,
                        box_size * 0.5 + 1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;
				if(low_quality)
					ctx.fillRect( title_height * 0.5 - box_size *0.5, title_height * -0.5 - box_size *0.5, box_size , box_size  );
				else
				{
					ctx.beginPath();
					ctx.arc(
						title_height * 0.5,
						title_height * -0.5,
						box_size * 0.5,
						0,
						Math.PI * 2
					);
					ctx.fill();
				}
            } else {
                if (low_quality) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(
                        (title_height - box_size) * 0.5 - 1,
                        (title_height + box_size) * -0.5 - 1,
                        box_size + 2,
                        box_size + 2
                    );
                }
                ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;
                ctx.fillRect(
                    (title_height - box_size) * 0.5,
                    (title_height + box_size) * -0.5,
                    box_size,
                    box_size
                );
            }
            ctx.globalAlpha = old_alpha;

            //title text
            if (node.onDrawTitleText) {
                node.onDrawTitleText(
                    ctx,
                    title_height,
                    size,
                    this.ds.scale,
                    this.title_text_font,
                    selected
                );
            }
            if (!low_quality) {
                ctx.font = this.title_text_font;
                var title = String(node.getTitle());
                if (title) {
                    if (selected) {
                        ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;
                    } else {
                        ctx.fillStyle =
                            node.constructor.title_text_color ||
                            this.node_title_color;
                    }
                    if (node.flags.collapsed) {
                        ctx.textAlign = "left";
                        var measure = ctx.measureText(title);
                        ctx.fillText(
                            title.substr(0,20), //avoid urls too long
                            title_height,// + measure.width * 0.5,
                            LiteGraph.NODE_TITLE_TEXT_Y - title_height
                        );
                        ctx.textAlign = "left";
                    } else {
                        ctx.textAlign = "left";
                        ctx.fillText(
                            title,
                            title_height,
                            LiteGraph.NODE_TITLE_TEXT_Y - title_height
                        );
                    }
                }
            }

			//subgraph box
			if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {
				var w = LiteGraph.NODE_TITLE_HEIGHT;
				var x = node.size[0] - w;
				var over = LiteGraph.isInsideRectangle( this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x+2, -w+2, w-4, w-4 );
				ctx.fillStyle = over ? "#888" : "#555";
				if( shape == LiteGraph.BOX_SHAPE || low_quality)
					ctx.fillRect(x+2, -w+2, w-4, w-4);
				else
				{
					ctx.beginPath();
					ctx.roundRect(x+2, -w+2, w-4, w-4,4);
					ctx.fill();
				}
				ctx.fillStyle = "#333";
				ctx.beginPath();
				ctx.moveTo(x + w * 0.2, -w * 0.6);
				ctx.lineTo(x + w * 0.8, -w * 0.6);
				ctx.lineTo(x + w * 0.5, -w * 0.3);
				ctx.fill();
			}

			//custom title render
            if (node.onDrawTitle) {
                node.onDrawTitle(ctx);
            }
        }

        //render selection marker
        if (selected) {
            if (node.onBounding) {
                node.onBounding(area);
            }

            if (title_mode == LiteGraph.TRANSPARENT_TITLE) {
                area[1] -= title_height;
                area[3] += title_height;
            }
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE) {
                ctx.rect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3]
                );
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                (shape == LiteGraph.CARD_SHAPE && node.flags.collapsed)
            ) {
                ctx.roundRect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                    this.round_radius * 2
                );
            } else if (shape == LiteGraph.CARD_SHAPE) {
                ctx.roundRect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                    this.round_radius * 2,
                    2
                );
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5 + 6,
                    0,
                    Math.PI * 2
                );
            }
            ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;
            ctx.stroke();
            ctx.strokeStyle = fgcolor;
            ctx.globalAlpha = 1;
        }
    };

    var margin_area = new Float32Array(4);
    var link_bounding = new Float32Array(4);
    var tempA = new Float32Array(2);
    var tempB = new Float32Array(2);

    /**
     * draws every connection visible in the canvas
     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time
     * @method drawConnections
     **/
    LGraphCanvas.prototype.drawConnections = function(ctx) {
        var now = LiteGraph.getTime();
        var visible_area = this.visible_area;
        margin_area[0] = visible_area[0] - 20;
        margin_area[1] = visible_area[1] - 20;
        margin_area[2] = visible_area[2] + 40;
        margin_area[3] = visible_area[3] + 40;

        //draw connections
        ctx.lineWidth = this.connections_width;

        ctx.fillStyle = "#AAA";
        ctx.strokeStyle = "#AAA";
        ctx.globalAlpha = this.editor_alpha;
        //for every node
        var nodes = this.graph._nodes;
        for (var n = 0, l = nodes.length; n < l; ++n) {
            var node = nodes[n];
            //for every input (we render just inputs because it is easier as every slot can only have one input)
            if (!node.inputs || !node.inputs.length) {
                continue;
            }

            for (var i = 0; i < node.inputs.length; ++i) {
                var input = node.inputs[i];
                if (!input || input.link == null) {
                    continue;
                }
                var link_id = input.link;
                var link = this.graph.links[link_id];
                if (!link) {
                    continue;
                }

                //find link info
                var start_node = this.graph.getNodeById(link.origin_id);
                if (start_node == null) {
                    continue;
                }
                var start_node_slot = link.origin_slot;
                var start_node_slotpos = null;
                if (start_node_slot == -1) {
                    start_node_slotpos = [
                        start_node.pos[0] + 10,
                        start_node.pos[1] + 10
                    ];
                } else {
                    start_node_slotpos = start_node.getConnectionPos(
                        false,
                        start_node_slot,
                        tempA
                    );
                }
                var end_node_slotpos = node.getConnectionPos(true, i, tempB);

                //compute link bounding
                link_bounding[0] = start_node_slotpos[0];
                link_bounding[1] = start_node_slotpos[1];
                link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];
                link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];
                if (link_bounding[2] < 0) {
                    link_bounding[0] += link_bounding[2];
                    link_bounding[2] = Math.abs(link_bounding[2]);
                }
                if (link_bounding[3] < 0) {
                    link_bounding[1] += link_bounding[3];
                    link_bounding[3] = Math.abs(link_bounding[3]);
                }

                //skip links outside of the visible area of the canvas
                if (!overlapBounding(link_bounding, margin_area)) {
                    continue;
                }

                var start_slot = start_node.outputs[start_node_slot];
                var end_slot = node.inputs[i];
                if (!start_slot || !end_slot) {
                    continue;
                }
                var start_dir =
                    start_slot.dir ||
                    (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);
                var end_dir =
                    end_slot.dir ||
                    (node.horizontal ? LiteGraph.UP : LiteGraph.LEFT);

                this.renderLink(
                    ctx,
                    start_node_slotpos,
                    end_node_slotpos,
                    link,
                    false,
                    0,
                    null,
                    start_dir,
                    end_dir
                );

                //event triggered rendered on top
                if (link && link._last_time && now - link._last_time < 1000) {
                    var f = 2.0 - (now - link._last_time) * 0.002;
                    var tmp = ctx.globalAlpha;
                    ctx.globalAlpha = tmp * f;
                    this.renderLink(
                        ctx,
                        start_node_slotpos,
                        end_node_slotpos,
                        link,
                        true,
                        f,
                        "white",
                        start_dir,
                        end_dir
                    );
                    ctx.globalAlpha = tmp;
                }
            }
        }
        ctx.globalAlpha = 1;
    };

    /**
     * draws a link between two points
     * @method renderLink
     * @param {vec2} a start pos
     * @param {vec2} b end pos
     * @param {Object} link the link object with all the link info
     * @param {boolean} skip_border ignore the shadow of the link
     * @param {boolean} flow show flow animation (for events)
     * @param {string} color the color for the link
     * @param {number} start_dir the direction enum
     * @param {number} end_dir the direction enum
     * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)
     **/
    LGraphCanvas.prototype.renderLink = function(
        ctx,
        a,
        b,
        link,
        skip_border,
        flow,
        color,
        start_dir,
        end_dir,
        num_sublines
    ) {
        if (link) {
            this.visible_links.push(link);
        }

        //choose color
        if (!color && link) {
            color = link.color || LGraphCanvas.link_type_colors[link.type];
        }
        if (!color) {
            color = this.default_link_color;
        }
        if (link != null && this.highlighted_links[link.id]) {
            color = "#FFF";
        }

        start_dir = start_dir || LiteGraph.RIGHT;
        end_dir = end_dir || LiteGraph.LEFT;

        var dist = distance(a, b);

        if (this.render_connections_border && this.ds.scale > 0.6) {
            ctx.lineWidth = this.connections_width + 4;
        }
        ctx.lineJoin = "round";
        num_sublines = num_sublines || 1;
        if (num_sublines > 1) {
            ctx.lineWidth = 0.5;
        }

        //begin line shape
        ctx.beginPath();
        for (var i = 0; i < num_sublines; i += 1) {
            var offsety = (i - (num_sublines - 1) * 0.5) * 5;

            if (this.links_render_mode == LiteGraph.SPLINE_LINK) {
                ctx.moveTo(a[0], a[1] + offsety);
                var start_offset_x = 0;
                var start_offset_y = 0;
                var end_offset_x = 0;
                var end_offset_y = 0;
                switch (start_dir) {
                    case LiteGraph.LEFT:
                        start_offset_x = dist * -0.25;
                        break;
                    case LiteGraph.RIGHT:
                        start_offset_x = dist * 0.25;
                        break;
                    case LiteGraph.UP:
                        start_offset_y = dist * -0.25;
                        break;
                    case LiteGraph.DOWN:
                        start_offset_y = dist * 0.25;
                        break;
                }
                switch (end_dir) {
                    case LiteGraph.LEFT:
                        end_offset_x = dist * -0.25;
                        break;
                    case LiteGraph.RIGHT:
                        end_offset_x = dist * 0.25;
                        break;
                    case LiteGraph.UP:
                        end_offset_y = dist * -0.25;
                        break;
                    case LiteGraph.DOWN:
                        end_offset_y = dist * 0.25;
                        break;
                }
                ctx.bezierCurveTo(
                    a[0] + start_offset_x,
                    a[1] + start_offset_y + offsety,
                    b[0] + end_offset_x,
                    b[1] + end_offset_y + offsety,
                    b[0],
                    b[1] + offsety
                );
            } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {
                ctx.moveTo(a[0], a[1] + offsety);
                var start_offset_x = 0;
                var start_offset_y = 0;
                var end_offset_x = 0;
                var end_offset_y = 0;
                switch (start_dir) {
                    case LiteGraph.LEFT:
                        start_offset_x = -1;
                        break;
                    case LiteGraph.RIGHT:
                        start_offset_x = 1;
                        break;
                    case LiteGraph.UP:
                        start_offset_y = -1;
                        break;
                    case LiteGraph.DOWN:
                        start_offset_y = 1;
                        break;
                }
                switch (end_dir) {
                    case LiteGraph.LEFT:
                        end_offset_x = -1;
                        break;
                    case LiteGraph.RIGHT:
                        end_offset_x = 1;
                        break;
                    case LiteGraph.UP:
                        end_offset_y = -1;
                        break;
                    case LiteGraph.DOWN:
                        end_offset_y = 1;
                        break;
                }
                var l = 15;
                ctx.lineTo(
                    a[0] + start_offset_x * l,
                    a[1] + start_offset_y * l + offsety
                );
                ctx.lineTo(
                    b[0] + end_offset_x * l,
                    b[1] + end_offset_y * l + offsety
                );
                ctx.lineTo(b[0], b[1] + offsety);
            } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {
                ctx.moveTo(a[0], a[1]);
                var start_x = a[0];
                var start_y = a[1];
                var end_x = b[0];
                var end_y = b[1];
                if (start_dir == LiteGraph.RIGHT) {
                    start_x += 10;
                } else {
                    start_y += 10;
                }
                if (end_dir == LiteGraph.LEFT) {
                    end_x -= 10;
                } else {
                    end_y -= 10;
                }
                ctx.lineTo(start_x, start_y);
                ctx.lineTo((start_x + end_x) * 0.5, start_y);
                ctx.lineTo((start_x + end_x) * 0.5, end_y);
                ctx.lineTo(end_x, end_y);
                ctx.lineTo(b[0], b[1]);
            } else {
                return;
            } //unknown
        }

        //rendering the outline of the connection can be a little bit slow
        if (
            this.render_connections_border &&
            this.ds.scale > 0.6 &&
            !skip_border
        ) {
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.stroke();
        }

        ctx.lineWidth = this.connections_width;
        ctx.fillStyle = ctx.strokeStyle = color;
        ctx.stroke();
        //end line shape

        var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);
        if (link && link._pos) {
            link._pos[0] = pos[0];
            link._pos[1] = pos[1];
        }

        //render arrow in the middle
        if (
            this.ds.scale >= 0.6 &&
            this.highquality_render &&
            end_dir != LiteGraph.CENTER
        ) {
            //render arrow
            if (this.render_connection_arrows) {
                //compute two points in the connection
                var posA = this.computeConnectionPoint(
                    a,
                    b,
                    0.25,
                    start_dir,
                    end_dir
                );
                var posB = this.computeConnectionPoint(
                    a,
                    b,
                    0.26,
                    start_dir,
                    end_dir
                );
                var posC = this.computeConnectionPoint(
                    a,
                    b,
                    0.75,
                    start_dir,
                    end_dir
                );
                var posD = this.computeConnectionPoint(
                    a,
                    b,
                    0.76,
                    start_dir,
                    end_dir
                );

                //compute the angle between them so the arrow points in the right direction
                var angleA = 0;
                var angleB = 0;
                if (this.render_curved_connections) {
                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);
                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);
                } else {
                    angleB = angleA = b[1] > a[1] ? 0 : Math.PI;
                }

                //render arrow
                ctx.save();
                ctx.translate(posA[0], posA[1]);
                ctx.rotate(angleA);
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(0, +7);
                ctx.lineTo(+5, -3);
                ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(posC[0], posC[1]);
                ctx.rotate(angleB);
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(0, +7);
                ctx.lineTo(+5, -3);
                ctx.fill();
                ctx.restore();
            }

            //circle
            ctx.beginPath();
            ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);
            ctx.fill();
        }

        //render flowing points
        if (flow) {
            ctx.fillStyle = color;
            for (var i = 0; i < 5; ++i) {
                var f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1;
                var pos = this.computeConnectionPoint(
                    a,
                    b,
                    f,
                    start_dir,
                    end_dir
                );
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    };

    //returns the link center point based on curvature
    LGraphCanvas.prototype.computeConnectionPoint = function(
        a,
        b,
        t,
        start_dir,
        end_dir
    ) {
        start_dir = start_dir || LiteGraph.RIGHT;
        end_dir = end_dir || LiteGraph.LEFT;

        var dist = distance(a, b);
        var p0 = a;
        var p1 = [a[0], a[1]];
        var p2 = [b[0], b[1]];
        var p3 = b;

        switch (start_dir) {
            case LiteGraph.LEFT:
                p1[0] += dist * -0.25;
                break;
            case LiteGraph.RIGHT:
                p1[0] += dist * 0.25;
                break;
            case LiteGraph.UP:
                p1[1] += dist * -0.25;
                break;
            case LiteGraph.DOWN:
                p1[1] += dist * 0.25;
                break;
        }
        switch (end_dir) {
            case LiteGraph.LEFT:
                p2[0] += dist * -0.25;
                break;
            case LiteGraph.RIGHT:
                p2[0] += dist * 0.25;
                break;
            case LiteGraph.UP:
                p2[1] += dist * -0.25;
                break;
            case LiteGraph.DOWN:
                p2[1] += dist * 0.25;
                break;
        }

        var c1 = (1 - t) * (1 - t) * (1 - t);
        var c2 = 3 * ((1 - t) * (1 - t)) * t;
        var c3 = 3 * (1 - t) * (t * t);
        var c4 = t * t * t;

        var x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];
        var y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];
        return [x, y];
    };

    LGraphCanvas.prototype.drawExecutionOrder = function(ctx) {
        ctx.shadowColor = "transparent";
        ctx.globalAlpha = 0.25;

        ctx.textAlign = "center";
        ctx.strokeStyle = "white";
        ctx.globalAlpha = 0.75;

        var visible_nodes = this.visible_nodes;
        for (var i = 0; i < visible_nodes.length; ++i) {
            var node = visible_nodes[i];
            ctx.fillStyle = "black";
            ctx.fillRect(
                node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
                node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
                LiteGraph.NODE_TITLE_HEIGHT,
                LiteGraph.NODE_TITLE_HEIGHT
            );
            if (node.order == 0) {
                ctx.strokeRect(
                    node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
                    node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
                    LiteGraph.NODE_TITLE_HEIGHT,
                    LiteGraph.NODE_TITLE_HEIGHT
                );
            }
            ctx.fillStyle = "#FFF";
            ctx.fillText(
                node.order,
                node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
                node.pos[1] - 6
            );
        }
        ctx.globalAlpha = 1;
    };

    /**
     * draws the widgets stored inside a node
     * @method drawNodeWidgets
     **/
    LGraphCanvas.prototype.drawNodeWidgets = function(
        node,
        posY,
        ctx,
        active_widget
    ) {
        if (!node.widgets || !node.widgets.length) {
            return 0;
        }
        var width = node.size[0];
        var widgets = node.widgets;
        posY += 2;
        var H = LiteGraph.NODE_WIDGET_HEIGHT;
        var show_text = this.ds.scale > 0.5;
        ctx.save();
        ctx.globalAlpha = this.editor_alpha;
        var outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
        var background_color = LiteGraph.WIDGET_BGCOLOR;
        var text_color = LiteGraph.WIDGET_TEXT_COLOR;
		var secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
        var margin = 15;

        for (var i = 0; i < widgets.length; ++i) {
            var w = widgets[i];
            var y = posY;
            if (w.y) {
                y = w.y;
            }
            w.last_y = y;
            ctx.strokeStyle = outline_color;
            ctx.fillStyle = "#222";
            ctx.textAlign = "left";
			//ctx.lineWidth = 2;
			if(w.disabled)
				ctx.globalAlpha *= 0.5;
			var widget_width = w.width || width;

            switch (w.type) {
                case "button":
                    if (w.clicked) {
                        ctx.fillStyle = "#AAA";
                        w.clicked = false;
                        this.dirty_canvas = true;
                    }
                    ctx.fillRect(margin, y, widget_width - margin * 2, H);
					if(show_text && !w.disabled)
	                    ctx.strokeRect( margin, y, widget_width - margin * 2, H );
                    if (show_text) {
                        ctx.textAlign = "center";
                        ctx.fillStyle = text_color;
                        ctx.fillText(w.name, widget_width * 0.5, y + H * 0.7);
                    }
                    break;
                case "toggle":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if (show_text)
	                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);
					else
	                    ctx.rect(margin, posY, widget_width - margin * 2, H );
                    ctx.fill();
					if(show_text && !w.disabled)
	                    ctx.stroke();
                    ctx.fillStyle = w.value ? "#89A" : "#333";
                    ctx.beginPath();
                    ctx.arc( widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2 );
                    ctx.fill();
                    if (show_text) {
                        ctx.fillStyle = secondary_text_color;
                        if (w.name != null) {
                            ctx.fillText(w.name, margin * 2, y + H * 0.7);
                        }
                        ctx.fillStyle = w.value ? text_color : secondary_text_color;
                        ctx.textAlign = "right";
                        ctx.fillText(
                            w.value
                                ? w.options.on || "true"
                                : w.options.off || "false",
                            widget_width - 40,
                            y + H * 0.7
                        );
                    }
                    break;
                case "slider":
                    ctx.fillStyle = background_color;
                    ctx.fillRect(margin, y, widget_width - margin * 2, H);
                    var range = w.options.max - w.options.min;
                    var nvalue = (w.value - w.options.min) / range;
                    ctx.fillStyle = active_widget == w ? "#89A" : "#678";
                    ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);
					if(show_text && !w.disabled)
	                    ctx.strokeRect(margin, y, widget_width - margin * 2, H);
                    if (w.marker) {
                        var marker_nvalue = (w.marker - w.options.min) / range;
                        ctx.fillStyle = "#AA9";
                        ctx.fillRect( margin + marker_nvalue * (widget_width - margin * 2), y, 2, H );
                    }
                    if (show_text) {
                        ctx.textAlign = "center";
                        ctx.fillStyle = text_color;
                        ctx.fillText(
                            w.name + "  " + Number(w.value).toFixed(3),
                            widget_width * 0.5,
                            y + H * 0.7
                        );
                    }
                    break;
                case "number":
                case "combo":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
					if(show_text)
	                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);
					else
	                    ctx.rect(margin, posY, widget_width - margin * 2, H );
                    ctx.fill();
                    if (show_text) {
						if(!w.disabled)
		                    ctx.stroke();
                        ctx.fillStyle = text_color;
						if(!w.disabled)
						{
							ctx.beginPath();
							ctx.moveTo(margin + 16, posY + 5);
							ctx.lineTo(margin + 6, posY + H * 0.5);
							ctx.lineTo(margin + 16, posY + H - 5);
							ctx.fill();
							ctx.beginPath();
							ctx.moveTo(widget_width - margin - 16, posY + 5);
							ctx.lineTo(widget_width - margin - 6, posY + H * 0.5);
							ctx.lineTo(widget_width - margin - 16, posY + H - 5);
							ctx.fill();
						}
                        ctx.fillStyle = secondary_text_color;
                        ctx.fillText(w.name, margin * 2 + 5, y + H * 0.7);
                        ctx.fillStyle = text_color;
                        ctx.textAlign = "right";
                        if (w.type == "number") {
                            ctx.fillText(
                                Number(w.value).toFixed(
                                    w.options.precision !== undefined
                                        ? w.options.precision
                                        : 3
                                ),
                                widget_width - margin * 2 - 20,
                                y + H * 0.7
                            );
                        } else {
							var v = w.value;
							if( w.options.values )
							{
								var values = w.options.values;
								if( values.constructor === Function )
									values = values();
								if(values && values.constructor !== Array)
									v = values[ w.value ];
							}
                            ctx.fillText(
                                v,
                                widget_width - margin * 2 - 20,
                                y + H * 0.7
                            );
                        }
                    }
                    break;
                case "string":
                case "text":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if (show_text)
	                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);
					else
	                    ctx.rect( margin, posY, widget_width - margin * 2, H );
                    ctx.fill();
	                if (show_text) {
						if(!w.disabled)
							ctx.stroke();
    					ctx.save();
						ctx.beginPath();
						ctx.rect(margin, posY, widget_width - margin * 2, H);
						ctx.clip();

	                    //ctx.stroke();
                        ctx.fillStyle = secondary_text_color;
                        if (w.name != null) {
                            ctx.fillText(w.name, margin * 2, y + H * 0.7);
                        }
                        ctx.fillStyle = text_color;
                        ctx.textAlign = "right";
                        ctx.fillText(String(w.value).substr(0,30), widget_width - margin * 2, y + H * 0.7); //30 chars max
						ctx.restore();
                    }
                    break;
                default:
                    if (w.draw) {
                        w.draw(ctx, node, widget_width, y, H);
                    }
                    break;
            }
            posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;
			ctx.globalAlpha = this.editor_alpha;

        }
        ctx.restore();
		ctx.textAlign = "left";
    };

    /**
     * process an event on widgets
     * @method processNodeWidgets
     **/
    LGraphCanvas.prototype.processNodeWidgets = function(
        node,
        pos,
        event,
        active_widget
    ) {
        if (!node.widgets || !node.widgets.length) {
            return null;
        }

        var x = pos[0] - node.pos[0];
        var y = pos[1] - node.pos[1];
        var width = node.size[0];
        var that = this;
        var ref_window = this.getCanvasWindow();

        for (var i = 0; i < node.widgets.length; ++i) {
            var w = node.widgets[i];
			if(!w || w.disabled)
				continue;
			var widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;
			var widget_width = w.width || width;
			//outside
			if ( w != active_widget && 
				(x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === undefined) ) 
				continue;

			var old_value = w.value;

            //if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y < w.last_y + widget_height) ) {
			//inside widget
			switch (w.type) {
				case "button":
					if (event.type === "mousedown") {
                        if (w.callback) {
                            setTimeout(function() {
                                w.callback(w, that, node, pos, event);
                            }, 20);
                        }
                        w.clicked = true;
                        this.dirty_canvas = true;
                    }
					break;
				case "slider":
					var range = w.options.max - w.options.min;
					var nvalue = Math.clamp((x - 15) / (widget_width - 30), 0, 1);
					w.value = w.options.min + (w.options.max - w.options.min) * nvalue;
					if (w.callback) {
						setTimeout(function() {
							inner_value_change(w, w.value);
						}, 20);
					}
					this.dirty_canvas = true;
					break;
				case "number":
				case "combo":
					var old_value = w.value;
					if (event.type == "mousemove" && w.type == "number") {
						w.value += event.deltaX * 0.1 * (w.options.step || 1);
						if ( w.options.min != null && w.value < w.options.min ) {
							w.value = w.options.min;
						}
						if ( w.options.max != null && w.value > w.options.max ) {
							w.value = w.options.max;
						}
					} else if (event.type == "mousedown") {
						var values = w.options.values;
						if (values && values.constructor === Function) {
							values = w.options.values(w, node);
						}
						var values_list = null;
						
						if( w.type != "number")
							values_list = values.constructor === Array ? values : Object.keys(values);

						var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
						if (w.type == "number") {
							w.value += delta * 0.1 * (w.options.step || 1);
							if ( w.options.min != null && w.value < w.options.min ) {
								w.value = w.options.min;
							}
							if ( w.options.max != null && w.value > w.options.max ) {
								w.value = w.options.max;
							}
						} else if (delta) { //clicked in arrow, used for combos 
							var index = -1;
							this.last_mouseclick = 0; //avoids dobl click event
							if(values.constructor === Object)
								index = values_list.indexOf( String( w.value ) ) + delta;
							else
								index = values_list.indexOf( w.value ) + delta;
							if (index >= values_list.length) {
								index = values_list.length - 1;
							}
							if (index < 0) {
								index = 0;
							}
							if( values.constructor === Array )
								w.value = values[index];
							else
								w.value = index;
						} else { //combo clicked 
							var text_values = values != values_list ? Object.values(values) : values;
							var menu = new LiteGraph.ContextMenu(text_values, {
									scale: Math.max(1, this.ds.scale),
									event: event,
									className: "dark",
									callback: inner_clicked.bind(w)
								},
								ref_window);
							function inner_clicked(v, option, event) {
								if(values != values_list)
									v = text_values.indexOf(v);
								this.value = v;
								inner_value_change(this, v);
								that.dirty_canvas = true;
								return false;
							}
						}
					} //end mousedown
					else if(event.type == "mouseup" && w.type == "number")
					{
						var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
						if (event.click_time < 200 && delta == 0) {
							this.prompt("Value",w.value,function(v) {
									this.value = Number(v);
									inner_value_change(this, this.value);
								}.bind(w),
								event);
						}
					}

					if( old_value != w.value )
						setTimeout(
							function() {
								inner_value_change(this, this.value);
							}.bind(w),
							20
						);
					this.dirty_canvas = true;
					break;
				case "toggle":
					if (event.type == "mousedown") {
						w.value = !w.value;
						setTimeout(function() {
							inner_value_change(w, w.value);
						}, 20);
					}
					break;
				case "string":
				case "text":
					if (event.type == "mousedown") {
						this.prompt("Value",w.value,function(v) {
								this.value = v;
								inner_value_change(this, v);
							}.bind(w),
							event,w.options ? w.options.multiline : false );
					}
					break;
				default:
					if (w.mouse) {
						this.dirty_canvas = w.mouse(event, [x, y], node);
					}
					break;
			} //end switch

			//value changed
			if( old_value != w.value )
			{
				if(node.onWidgetChanged)
					node.onWidgetChanged( w.name,w.value,old_value,w );
                node.graph._version++;
			}

			return w;
        }//end for

        function inner_value_change(widget, value) {
            widget.value = value;
            if ( widget.options && widget.options.property && node.properties[widget.options.property] !== undefined ) {
                node.setProperty( widget.options.property, value );
            }
            if (widget.callback) {
                widget.callback(widget.value, that, node, pos, event);
            }
        }

        return null;
    };

    /**
     * draws every group area in the background
     * @method drawGroups
     **/
    LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {
        if (!this.graph) {
            return;
        }

        var groups = this.graph._groups;

        ctx.save();
        ctx.globalAlpha = 0.5 * this.editor_alpha;

        for (var i = 0; i < groups.length; ++i) {
            var group = groups[i];

            if (!overlapBounding(this.visible_area, group._bounding)) {
                continue;
            } //out of the visible area

            ctx.fillStyle = group.color || "#335";
            ctx.strokeStyle = group.color || "#335";
            var pos = group._pos;
            var size = group._size;
            ctx.globalAlpha = 0.25 * this.editor_alpha;
            ctx.beginPath();
            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);
            ctx.fill();
            ctx.globalAlpha = this.editor_alpha;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);
            ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);
            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);
            ctx.fill();

            var font_size =
                group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
            ctx.font = font_size + "px Arial";
            ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);
        }

        ctx.restore();
    };

    LGraphCanvas.prototype.adjustNodesSize = function() {
        var nodes = this.graph._nodes;
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].size = nodes[i].computeSize();
        }
        this.setDirty(true, true);
    };

    /**
     * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode
     * @method resize
     **/
    LGraphCanvas.prototype.resize = function(width, height) {
        if (!width && !height) {
            var parent = this.canvas.parentNode;
            width = parent.offsetWidth;
            height = parent.offsetHeight;
        }

        if (this.canvas.width == width && this.canvas.height == height) {
            return;
        }

        this.canvas.width = width;
        this.canvas.height = height;
        this.bgcanvas.width = this.canvas.width;
        this.bgcanvas.height = this.canvas.height;
        this.setDirty(true, true);
    };

    /**
     * switches to live mode (node shapes are not rendered, only the content)
     * this feature was designed when graphs where meant to create user interfaces
     * @method switchLiveMode
     **/
    LGraphCanvas.prototype.switchLiveMode = function(transition) {
        if (!transition) {
            this.live_mode = !this.live_mode;
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
            return;
        }

        var self = this;
        var delta = this.live_mode ? 1.1 : 0.9;
        if (this.live_mode) {
            this.live_mode = false;
            this.editor_alpha = 0.1;
        }

        var t = setInterval(function() {
            self.editor_alpha *= delta;
            self.dirty_canvas = true;
            self.dirty_bgcanvas = true;

            if (delta < 1 && self.editor_alpha < 0.01) {
                clearInterval(t);
                if (delta < 1) {
                    self.live_mode = true;
                }
            }
            if (delta > 1 && self.editor_alpha > 0.99) {
                clearInterval(t);
                self.editor_alpha = 1;
            }
        }, 1);
    };

    LGraphCanvas.prototype.onNodeSelectionChange = function(node) {
        return; //disabled
    };

    LGraphCanvas.prototype.touchHandler = function(event) {
        //alert("foo");
        var touches = event.changedTouches,
            first = touches[0],
            type = "";

        switch (event.type) {
            case "touchstart":
                type = "mousedown";
                break;
            case "touchmove":
                type = "mousemove";
                break;
            case "touchend":
                type = "mouseup";
                break;
            default:
                return;
        }

        //initMouseEvent(type, canBubble, cancelable, view, clickCount,
        //           screenX, screenY, clientX, clientY, ctrlKey,
        //           altKey, shiftKey, metaKey, button, relatedTarget);

        var window = this.getCanvasWindow();
        var document = window.document;

        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(
            type,
            true,
            true,
            window,
            1,
            first.screenX,
            first.screenY,
            first.clientX,
            first.clientY,
            false,
            false,
            false,
            false,
            0 /*left*/,
            null
        );
        first.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
    };

    /* CONTEXT MENU ********************/

    LGraphCanvas.onGroupAdd = function(info, entry, mouse_event) {
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var group = new LiteGraph.LGraphGroup();
        group.pos = canvas.convertEventToCanvasOffset(mouse_event);
        canvas.graph.add(group);
    };

    LGraphCanvas.onMenuAdd = function (node, options, e, prev_menu, callback) {

        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();
        var graph = canvas.graph;
        if (!graph)
            return;

        function inner_onMenuAdded(base_category ,prev_menu){
    
            var categories  = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category){return category.startsWith(base_category)});
            var entries = [];
    
            categories.map(function(category){
    
                if (!category) 
                    return;
    
                var base_category_regex = new RegExp('^(' + base_category + ')');
                var category_name = category.replace(base_category_regex,"").split('/')[0];
                var category_path = base_category  === '' ? category_name + '/' : base_category + category_name + '/';
    
                var name = category_name;
                if(name.indexOf("::") != -1) //in case it has a namespace like "shader::math/rand" it hides the namespace
                    name = name.split("::")[1];
                        
                var index = entries.findIndex(function(entry){return entry.value === category_path});
                if (index === -1) {
                    entries.push({ value: category_path, content: name, has_submenu: true, callback : function(value, event, mouseEvent, contextMenu){
                        inner_onMenuAdded(value.value, contextMenu)
                    }});
                }
                
            });
    
            var nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter );
            nodes.map(function(node){
    
                if (node.skip_list)
                    return;
    
                var entry = { value: node.type, content: node.title, has_submenu: false , callback : function(value, event, mouseEvent, contextMenu){
                    
                        var first_event = contextMenu.getFirstEvent();
                        canvas.graph.beforeChange();
                        var node = LiteGraph.createNode(value.value);
                        if (node) {
                            node.pos = canvas.convertEventToCanvasOffset(first_event);
                            canvas.graph.add(node);
                        }
                        if(callback)
                            callback(node);
                        canvas.graph.afterChange();
                    
                    }
                }
    
                entries.push(entry);
    
            });
    
            new LiteGraph.ContextMenu( entries, { event: e, parentMenu: prev_menu }, ref_window );
    
        }
    
        inner_onMenuAdded('',prev_menu);
        return false;
    
    };

    LGraphCanvas.onMenuCollapseAll = function() {};

    LGraphCanvas.onMenuNodeEdit = function() {};

    LGraphCanvas.showMenuNodeOptionalInputs = function(
        v,
        options,
        e,
        prev_menu,
        node
    ) {
        if (!node) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var options = node.optional_inputs;
        if (node.onGetInputs) {
            options = node.onGetInputs();
        }

        var entries = [];
        if (options) {
            for (var i=0; i < options.length; i++) {
                var entry = options[i];
                if (!entry) {
                    entries.push(null);
                    continue;
                }
                var label = entry[0];
                if (entry[2] && entry[2].label) {
                    label = entry[2].label;
                }
                var data = { content: label, value: entry };
                if (entry[1] == LiteGraph.ACTION) {
                    data.className = "event";
                }
                entries.push(data);
            }
        }

        if (this.onMenuNodeInputs) {
            entries = this.onMenuNodeInputs(entries);
        }

        if (!entries.length) {
			console.log("no input entries");
            return;
        }

        var menu = new LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                node: node
            },
            ref_window
        );

        function inner_clicked(v, e, prev) {
            if (!node) {
                return;
            }

            if (v.callback) {
                v.callback.call(that, node, v, e, prev);
            }

            if (v.value) {
				node.graph.beforeChange();
                node.addInput(v.value[0], v.value[1], v.value[2]);
                node.setDirtyCanvas(true, true);
				node.graph.afterChange();
            }
        }

        return false;
    };

    LGraphCanvas.showMenuNodeOptionalOutputs = function(
        v,
        options,
        e,
        prev_menu,
        node
    ) {
        if (!node) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var options = node.optional_outputs;
        if (node.onGetOutputs) {
            options = node.onGetOutputs();
        }

        var entries = [];
        if (options) {
            for (var i=0; i < options.length; i++) {
                var entry = options[i];
                if (!entry) {
                    //separator?
                    entries.push(null);
                    continue;
                }

                if (
                    node.flags &&
                    node.flags.skip_repeated_outputs &&
                    node.findOutputSlot(entry[0]) != -1
                ) {
                    continue;
                } //skip the ones already on
                var label = entry[0];
                if (entry[2] && entry[2].label) {
                    label = entry[2].label;
                }
                var data = { content: label, value: entry };
                if (entry[1] == LiteGraph.EVENT) {
                    data.className = "event";
                }
                entries.push(data);
            }
        }

        if (this.onMenuNodeOutputs) {
            entries = this.onMenuNodeOutputs(entries);
        }

        if (!entries.length) {
            return;
        }

        var menu = new LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                node: node
            },
            ref_window
        );

        function inner_clicked(v, e, prev) {
            if (!node) {
                return;
            }

            if (v.callback) {
                v.callback.call(that, node, v, e, prev);
            }

            if (!v.value) {
                return;
            }

            var value = v.value[1];

            if (
                value &&
                (value.constructor === Object || value.constructor === Array)
            ) {
                //submenu why?
                var entries = [];
                for (var i in value) {
                    entries.push({ content: i, value: value[i] });
                }
                new LiteGraph.ContextMenu(entries, {
                    event: e,
                    callback: inner_clicked,
                    parentMenu: prev_menu,
                    node: node
                });
                return false;
            } else {
				node.graph.beforeChange();
                node.addOutput(v.value[0], v.value[1], v.value[2]);
                node.setDirtyCanvas(true, true);
				node.graph.afterChange();
            }
        }

        return false;
    };

    LGraphCanvas.onShowMenuNodeProperties = function(
        value,
        options,
        e,
        prev_menu,
        node
    ) {
        if (!node || !node.properties) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var entries = [];
        for (var i in node.properties) {
            var value = node.properties[i] !== undefined ? node.properties[i] : " ";
			if( typeof value == "object" )
				value = JSON.stringify(value);
			var info = node.getPropertyInfo(i);
			if(info.type == "enum" || info.type == "combo")
				value = LGraphCanvas.getPropertyPrintableValue( value, info.values );

            //value could contain invalid html characters, clean that
            value = LGraphCanvas.decodeHTML(value);
            entries.push({
                content:
                    "<span class='property_name'>" +
                    (info.label ? info.label : i) +
                    "</span>" +
                    "<span class='property_value'>" +
                    value +
                    "</span>",
                value: i
            });
        }
        if (!entries.length) {
            return;
        }

        var menu = new LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                allow_html: true,
                node: node
            },
            ref_window
        );

        function inner_clicked(v, options, e, prev) {
            if (!node) {
                return;
            }
            var rect = this.getBoundingClientRect();
            canvas.showEditPropertyValue(node, v.value, {
                position: [rect.left, rect.top]
            });
        }

        return false;
    };

    LGraphCanvas.decodeHTML = function(str) {
        var e = document.createElement("div");
        e.innerText = str;
        return e.innerHTML;
    };

    LGraphCanvas.onResizeNode = function(value, options, e, menu, node) {
        if (!node) {
            return;
        }
        node.size = node.computeSize();
        if (node.onResize)
            node.onResize(node.size);
        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.prototype.showLinkMenu = function(link, e) {
        var that = this;
		console.log(link);
		var options = ["Add Node",null,"Delete"];
        var menu = new LiteGraph.ContextMenu(options, {
            event: e,
			title: link.data != null ? link.data.constructor.name : null,
            callback: inner_clicked
        });

        function inner_clicked(v,options,e) {
            switch (v) {
                case "Add Node":
					LGraphCanvas.onMenuAdd(null, null, e, menu, function(node){
						console.log("node autoconnect");
						var node_left = that.graph.getNodeById( link.origin_id );
						var node_right = that.graph.getNodeById( link.target_id );
						if(!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length)
							return;
						if( node_left.outputs[ link.origin_slot ].type == node.inputs[0].type && node.outputs[0].type == node_right.inputs[0].type )
						{
							node_left.connect( link.origin_slot, node, 0 );
							node.connect( 0, node_right, link.target_slot );
							node.pos[0] -= node.size[0] * 0.5;
						}
					});
					break;
                case "Delete":
                    that.graph.removeLink(link.id);
                    break;
                default:
            }
        }

        return false;
    };

    LGraphCanvas.onShowPropertyEditor = function(item, options, e, menu, node) {
        var input_html = "";
        var property = item.property || "title";
        var value = node[property];

        var dialog = document.createElement("div");
        dialog.className = "graphdialog";
        dialog.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
		//dialog.innerHTML = "<span class='name'></span><textarea autofocus class='value'></textarea><button>OK</button>";
        var title = dialog.querySelector(".name");
        title.innerText = property;
        var input = dialog.querySelector(".value");
        if (input) {
            input.value = value;
            input.addEventListener("blur", function(e) {
                this.focus();
            });
            input.addEventListener("keydown", function(e) {
                if (e.keyCode != 13 && e.target.localName != "textarea") {
                    return;
                }
                inner();
                e.preventDefault();
                e.stopPropagation();
            });
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;

        var rect = canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }

        var button = dialog.querySelector("button");
        button.addEventListener("click", inner);
        canvas.parentNode.appendChild(dialog);

        function inner() {
            setValue(input.value);
        }

        function setValue(value) {
            if (item.type == "Number") {
                value = Number(value);
            } else if (item.type == "Boolean") {
                value = Boolean(value);
            }
            node[property] = value;
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
            node.setDirtyCanvas(true, true);
        }
    };

    LGraphCanvas.prototype.prompt = function(title, value, callback, event, multiline) {
        var that = this;
        var input_html = "";
        title = title || "";

        var modified = false;

        var dialog = document.createElement("div");
        dialog.className = "graphdialog rounded";
		if(multiline)
	        dialog.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>";
		else
	        dialog.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
        dialog.close = function() {
            that.prompt_box = null;
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        if (this.ds.scale > 1) {
            dialog.style.transform = "scale(" + this.ds.scale + ")";
        }

        dialog.addEventListener("mouseleave", function(e) {
            if (!modified) {
                dialog.close();
            }
        });

        if (that.prompt_box) {
            that.prompt_box.close();
        }
        that.prompt_box = dialog;

        var first = null;
        var timeout = null;
        var selected = null;

        var name_element = dialog.querySelector(".name");
        name_element.innerText = title;
        var value_element = dialog.querySelector(".value");
        value_element.value = value;

        var input = value_element;
        input.addEventListener("keydown", function(e) {
            modified = true;
            if (e.keyCode == 27) {
                //ESC
                dialog.close();
            } else if (e.keyCode == 13 && e.target.localName != "textarea") {
                if (callback) {
                    callback(this.value);
                }
                dialog.close();
            } else {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
        });

        var button = dialog.querySelector("button");
        button.addEventListener("click", function(e) {
            if (callback) {
                callback(input.value);
            }
            that.setDirty(true);
            dialog.close();
        });

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;

        var rect = canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }

        canvas.parentNode.appendChild(dialog);
        setTimeout(function() {
            input.focus();
        }, 10);

        return dialog;
    };

    LGraphCanvas.search_limit = -1;
    LGraphCanvas.prototype.showSearchBox = function(event) {
        var that = this;
        var input_html = "";
        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;
        var root_document = canvas.ownerDocument || document;

        var dialog = document.createElement("div");
        dialog.className = "litegraph litesearchbox graphdialog rounded";
        dialog.innerHTML =
            "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>";
        dialog.close = function() {
            that.search_box = null;
            root_document.body.focus();
			root_document.body.style.overflow = "";

            setTimeout(function() {
                that.canvas.focus();
            }, 20); //important, if canvas loses focus keys wont be captured
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        var timeout_close = null;

        if (this.ds.scale > 1) {
            dialog.style.transform = "scale(" + this.ds.scale + ")";
        }

        dialog.addEventListener("mouseenter", function(e) {
            if (timeout_close) {
                clearTimeout(timeout_close);
                timeout_close = null;
            }
        });

        dialog.addEventListener("mouseleave", function(e) {
            //dialog.close();
            timeout_close = setTimeout(function() {
                dialog.close();
            }, 500);
        });

        if (that.search_box) {
            that.search_box.close();
        }
        that.search_box = dialog;

        var helper = dialog.querySelector(".helper");

        var first = null;
        var timeout = null;
        var selected = null;

        var input = dialog.querySelector("input");
        if (input) {
            input.addEventListener("blur", function(e) {
                this.focus();
            });
            input.addEventListener("keydown", function(e) {
                if (e.keyCode == 38) {
                    //UP
                    changeSelection(false);
                } else if (e.keyCode == 40) {
                    //DOWN
                    changeSelection(true);
                } else if (e.keyCode == 27) {
                    //ESC
                    dialog.close();
                } else if (e.keyCode == 13) {
                    if (selected) {
                        select(selected.innerHTML);
                    } else if (first) {
                        select(first);
                    } else {
                        dialog.close();
                    }
                } else {
                    if (timeout) {
                        clearInterval(timeout);
                    }
                    timeout = setTimeout(refreshHelper, 10);
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
				e.stopImmediatePropagation();
				return true;
            });
        }

		if( root_document.fullscreenElement )
	        root_document.fullscreenElement.appendChild(dialog);
		else
		{
		    root_document.body.appendChild(dialog);
			root_document.body.style.overflow = "hidden";
		}

        //compute best position
        var rect = canvas.getBoundingClientRect();

        var left = ( event ? event.clientX : (rect.left + rect.width * 0.5) ) - 80;
        var top = ( event ? event.clientY : (rect.top + rect.height * 0.5) ) - 20;
        dialog.style.left = left + "px";
        dialog.style.top = top + "px";

		//To avoid out of screen problems
		if(event.layerY > (rect.height - 200)) 
            helper.style.maxHeight = (rect.height - event.layerY - 20) + "px";

		/*
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }
        canvas.parentNode.appendChild(dialog);
		*/

        input.focus();

        function select(name) {
            if (name) {
                if (that.onSearchBoxSelection) {
                    that.onSearchBoxSelection(name, event, graphcanvas);
                } else {
                    var extra = LiteGraph.searchbox_extras[name.toLowerCase()];
                    if (extra) {
                        name = extra.type;
                    }

					graphcanvas.graph.beforeChange();
                    var node = LiteGraph.createNode(name);
                    if (node) {
                        node.pos = graphcanvas.convertEventToCanvasOffset(
                            event
                        );
                        graphcanvas.graph.add(node);
                    }

                    if (extra && extra.data) {
                        if (extra.data.properties) {
                            for (var i in extra.data.properties) {
                                node.addProperty( i, extra.data.properties[i] );
                            }
                        }
                        if (extra.data.inputs) {
                            node.inputs = [];
                            for (var i in extra.data.inputs) {
                                node.addOutput(
                                    extra.data.inputs[i][0],
                                    extra.data.inputs[i][1]
                                );
                            }
                        }
                        if (extra.data.outputs) {
                            node.outputs = [];
                            for (var i in extra.data.outputs) {
                                node.addOutput(
                                    extra.data.outputs[i][0],
                                    extra.data.outputs[i][1]
                                );
                            }
                        }
                        if (extra.data.title) {
                            node.title = extra.data.title;
                        }
                        if (extra.data.json) {
                            node.configure(extra.data.json);
                        }

						graphcanvas.graph.afterChange();
                    }
                }
            }

            dialog.close();
        }

        function changeSelection(forward) {
            var prev = selected;
            if (selected) {
                selected.classList.remove("selected");
            }
            if (!selected) {
                selected = forward
                    ? helper.childNodes[0]
                    : helper.childNodes[helper.childNodes.length];
            } else {
                selected = forward
                    ? selected.nextSibling
                    : selected.previousSibling;
                if (!selected) {
                    selected = prev;
                }
            }
            if (!selected) {
                return;
            }
            selected.classList.add("selected");
            selected.scrollIntoView({block: "end", behavior: "smooth"});
        }

        function refreshHelper() {
            timeout = null;
            var str = input.value;
            first = null;
            helper.innerHTML = "";
            if (!str) {
                return;
            }

            if (that.onSearchBox) {
                var list = that.onSearchBox(helper, str, graphcanvas);
                if (list) {
                    for (var i = 0; i < list.length; ++i) {
                        addResult(list[i]);
                    }
                }
            } else {
                var c = 0;
                str = str.toLowerCase();
				var filter = graphcanvas.filter || graphcanvas.graph.filter;

                //extras
                for (var i in LiteGraph.searchbox_extras) {
                    var extra = LiteGraph.searchbox_extras[i];
                    if (extra.desc.toLowerCase().indexOf(str) === -1) {
                        continue;
                    }
					var ctor = LiteGraph.registered_node_types[ extra.type ];
					if( ctor && ctor.filter != filter )
						continue;
                    addResult( extra.desc, "searchbox_extra" );
                    if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
                        break;
                    }
                }

				var filtered = null;
                if (Array.prototype.filter) { //filter supported
                    var keys = Object.keys( LiteGraph.registered_node_types ); //types
                    var filtered = keys.filter( inner_test_filter );
                } else {
					filtered = [];
                    for (var i in LiteGraph.registered_node_types) {
						if( inner_test_filter(i) )
							filtered.push(i);
                    }
                }

				for (var i = 0; i < filtered.length; i++) {
					addResult(filtered[i]);
					if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
						break;
					}
				}

				function inner_test_filter( type )
				{
					var ctor = LiteGraph.registered_node_types[ type ];
					if(filter && ctor.filter != filter )
						return false;
					return type.toLowerCase().indexOf(str) !== -1;
				}
            }

            function addResult(type, className) {
                var help = document.createElement("div");
                if (!first) {
                    first = type;
                }
                help.innerText = type;
                help.dataset["type"] = escape(type);
                help.className = "litegraph lite-search-item";
                if (className) {
                    help.className += " " + className;
                }
                help.addEventListener("click", function(e) {
                    select(unescape(this.dataset["type"]));
                });
                helper.appendChild(help);
            }
        }

        return dialog;
    };

    LGraphCanvas.prototype.showEditPropertyValue = function( node, property, options ) {
        if (!node || node.properties[property] === undefined) {
            return;
        }

        options = options || {};
        var that = this;

        var info = node.getPropertyInfo(property);
		var type = info.type;

        var input_html = "";

        if (type == "string" || type == "number" || type == "array" || type == "object") {
            input_html = "<input autofocus type='text' class='value'/>";
        } else if ( (type == "enum" || type == "combo") && info.values) {
            input_html = "<select autofocus type='text' class='value'>";
            for (var i in info.values) {
                var v = i;
				if( info.values.constructor === Array )
					v = info.values[i];

                input_html +=
                    "<option value='" +
                    v +
                    "' " +
                    (v == node.properties[property] ? "selected" : "") +
                    ">" +
                    info.values[i] +
                    "</option>";
            }
            input_html += "</select>";
        } else if (type == "boolean") {
            input_html =
                "<input autofocus type='checkbox' class='value' " +
                (node.properties[property] ? "checked" : "") +
                "/>";
        } else {
            console.warn("unknown type: " + type);
            return;
        }

        var dialog = this.createDialog(
            "<span class='name'>" +
                (info.label ? info.label : property) +
                "</span>" +
                input_html +
                "<button>OK</button>",
            options
        );

        if ((type == "enum" || type == "combo") && info.values) {
            var input = dialog.querySelector("select");
            input.addEventListener("change", function(e) {
                setValue(e.target.value);
                //var index = e.target.value;
                //setValue( e.options[e.selectedIndex].value );
            });
        } else if (type == "boolean") {
            var input = dialog.querySelector("input");
            if (input) {
                input.addEventListener("click", function(e) {
                    setValue(!!input.checked);
                });
            }
        } else {
            var input = dialog.querySelector("input");
            if (input) {
                input.addEventListener("blur", function(e) {
                    this.focus();
                });

				var v = node.properties[property] !== undefined ? node.properties[property] : "";
				if (type !== 'string') {
                    v = JSON.stringify(v);
                }

                input.value = v;
                input.addEventListener("keydown", function(e) {
                    if (e.keyCode != 13) {
                        return;
                    }
                    inner();
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
        }

        var button = dialog.querySelector("button");
        button.addEventListener("click", inner);

        function inner() {
            setValue(input.value);
        }

        function setValue(value) {

			if(info && info.values && info.values.constructor === Object && info.values[value] != undefined )
				value = info.values[value];

            if (typeof node.properties[property] == "number") {
                value = Number(value);
            }
            if (type == "array" || type == "object") {
                value = JSON.parse(value);
            }
            node.properties[property] = value;
            if (node.graph) {
                node.graph._version++;
            }
            if (node.onPropertyChanged) {
                node.onPropertyChanged(property, value);
            }
			if(options.onclose)
				options.onclose();
            dialog.close();
            node.setDirtyCanvas(true, true);
        }

		return dialog;
    };

    LGraphCanvas.prototype.createDialog = function(html, options) {
        options = options || {};

        var dialog = document.createElement("div");
        dialog.className = "graphdialog";
        dialog.innerHTML = html;

        var rect = this.canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (options.position) {
            offsetx += options.position[0];
            offsety += options.position[1];
        } else if (options.event) {
            offsetx += options.event.clientX;
            offsety += options.event.clientY;
        } //centered
        else {
            offsetx += this.canvas.width * 0.5;
            offsety += this.canvas.height * 0.5;
        }

        dialog.style.left = offsetx + "px";
        dialog.style.top = offsety + "px";

        this.canvas.parentNode.appendChild(dialog);

        dialog.close = function() {
            if (this.parentNode) {
                this.parentNode.removeChild(this);
            }
        };

        return dialog;
    };

	LGraphCanvas.prototype.createPanel = function(title, options) {
		options = options || {};

		var ref_window = options.window || window;
		var root = document.createElement("div");
		root.className = "litegraph dialog";
		root.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>";
		root.header = root.querySelector(".dialog-header");

		if(options.width)
			root.style.width = options.width + (options.width.constructor === Number ? "px" : "");
		if(options.height)
			root.style.height = options.height + (options.height.constructor === Number ? "px" : "");
		if(options.closable)
		{
			var close = document.createElement("span");
			close.innerHTML = "&#10005;";
			close.classList.add("close");
			close.addEventListener("click",function(){
				root.close();
			});
			root.header.appendChild(close);
		}
		root.title_element = root.querySelector(".dialog-title");
		root.title_element.innerText = title;
		root.content = root.querySelector(".dialog-content");
		root.footer = root.querySelector(".dialog-footer");

		root.close = function()
		{
			if(this.parentNode)
				this.parentNode.removeChild(this);
		}

		root.clear = function()
		{
			this.content.innerHTML = "";
		}

		root.addHTML = function(code, classname, on_footer)
		{
			var elem = document.createElement("div");
			if(classname)
				elem.className = classname;
			elem.innerHTML = code;
			if(on_footer)
				root.footer.appendChild(elem);
			else
				root.content.appendChild(elem);
			return elem;
		}

		root.addButton = function( name, callback, options )
		{
			var elem = document.createElement("button");
			elem.innerText = name;
			elem.options = options;
			elem.classList.add("btn");
			elem.addEventListener("click",callback);
			root.footer.appendChild(elem);
			return elem;
		}

		root.addSeparator = function()
		{
			var elem = document.createElement("div");
			elem.className = "separator";
			root.content.appendChild(elem);
		}

		root.addWidget = function( type, name, value, options, callback )
		{
			options = options || {};
			var str_value = String(value);
			type = type.toLowerCase();
			if(type == "number")
				str_value = value.toFixed(3);

			var elem = document.createElement("div");
			elem.className = "property";
			elem.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
			elem.querySelector(".property_name").innerText = options.label || name;
			var value_element = elem.querySelector(".property_value");
			value_element.innerText = str_value;
			elem.dataset["property"] = name;
			elem.dataset["type"] = options.type || type;
			elem.options = options;
			elem.value = value;

			//if( type == "code" )
			//	elem.addEventListener("click", function(){ inner_showCodePad( node, this.dataset["property"] ); });
			if (type == "boolean")
			{
				elem.classList.add("boolean");
				if(value)
					elem.classList.add("bool-on");
				elem.addEventListener("click", function(){ 
					//var v = node.properties[this.dataset["property"]]; 
					//node.setProperty(this.dataset["property"],!v); this.innerText = v ? "true" : "false"; 
					var propname = this.dataset["property"];
					this.value = !this.value;
					this.classList.toggle("bool-on");
					this.querySelector(".property_value").innerText = this.value ? "true" : "false";
					innerChange(propname, this.value );
				});
			}
			else if (type == "string" || type == "number")
			{
				value_element.setAttribute("contenteditable",true);
				value_element.addEventListener("keydown", function(e){ 
					if(e.code == "Enter")
					{
						e.preventDefault();
						this.blur();
					}
				});
				value_element.addEventListener("blur", function(){ 
					var v = this.innerText;
					var propname = this.parentNode.dataset["property"];
					var proptype = this.parentNode.dataset["type"];
					if( proptype == "number")
						v = Number(v);
					innerChange(propname, v);
				});
			}
			else if (type == "enum" || type == "combo") {
				var str_value = LGraphCanvas.getPropertyPrintableValue( value, options.values );
				value_element.innerText = str_value;

				value_element.addEventListener("click", function(event){ 
					var values = options.values || [];
					var propname = this.parentNode.dataset["property"];
					var elem_that = this;
					var menu = new LiteGraph.ContextMenu(values,{
							event: event,
							className: "dark",
							callback: inner_clicked
						},
						ref_window);
					function inner_clicked(v, option, event) {
						//node.setProperty(propname,v); 
						//graphcanvas.dirty_canvas = true;
						elem_that.innerText = v;
						innerChange(propname,v);
						return false;
					}
				});
            }

			root.content.appendChild(elem);

			function innerChange(name, value)
			{
				console.log("change",name,value);
				//that.dirty_canvas = true;
				if(options.callback)
					options.callback(name,value);
				if(callback)
					callback(name,value);
			}

			return elem;
		}

		return root;
	};

	LGraphCanvas.getPropertyPrintableValue = function(value, values)
	{
		if(!values)
			return String(value);

		if(values.constructor === Array)
		{
			return String(value);			
		}

		if(values.constructor === Object)
		{
			var desc_value = "";
			for(var k in values)
			{
				if(values[k] != value)
					continue;
				desc_value = k;
				break;
			}
			return String(value) + " ("+desc_value+")";
		}
	}

	LGraphCanvas.prototype.showShowNodePanel = function( node )
	{
		window.SELECTED_NODE = node;
		var panel = document.querySelector("#node-panel");
		if(panel)
			panel.close();
		var ref_window = this.getCanvasWindow();
		panel = this.createPanel(node.title || "",{closable: true, window: ref_window });
		panel.id = "node-panel";
		panel.node = node;
		panel.classList.add("settings");
		var that = this;
		var graphcanvas = this;

		function inner_refresh()
		{
			panel.content.innerHTML = ""; //clear
			panel.addHTML("<span class='node_type'>"+node.type+"</span><span class='node_desc'>"+(node.constructor.desc || "")+"</span><span class='separator'></span>");

			panel.addHTML("<h3>Properties</h3>");

			for(var i in node.properties)
			{
				var value = node.properties[i];
				var info = node.getPropertyInfo(i);
				var type = info.type || "string";

				//in case the user wants control over the side panel widget
				if( node.onAddPropertyToPanel && node.onAddPropertyToPanel(i,panel) )
					continue;

				panel.addWidget( info.widget || info.type, i, value, info, function(name,value){
					graphcanvas.graph.beforeChange(node);
					node.setProperty(name,value);
					graphcanvas.graph.afterChange();
					graphcanvas.dirty_canvas = true;
				});
			}

			panel.addSeparator();

			if(node.onShowCustomPanelInfo)
				node.onShowCustomPanelInfo(panel);

			/*
			panel.addHTML("<h3>Connections</h3>");
			var connection_containers = panel.addHTML("<div class='inputs connections_side'></div><div class='outputs connections_side'></div>","connections");
			var inputs = connection_containers.querySelector(".inputs");
			var outputs = connection_containers.querySelector(".outputs");
			*/

			panel.addButton("Delete",function(){
				if(node.block_delete)
					return;
				node.graph.remove(node);
				panel.close();
			}).classList.add("delete");
		}

		function inner_showCodePad( node, propname )
		{
			panel.style.top = "calc( 50% - 250px)";
			panel.style.left = "calc( 50% - 400px)";
			panel.style.width = "800px";
			panel.style.height = "500px";

			if(window.CodeFlask) //disabled for now
			{
				panel.content.innerHTML = "<div class='code'></div>";
				var flask = new CodeFlask( "div.code", { language: 'js' });
				flask.updateCode(node.properties[propname]);
				flask.onUpdate( function(code) {
					node.setProperty(propname, code);
				});
			}
			else
			{
				panel.content.innerHTML = "<textarea class='code'></textarea>";
				var textarea = panel.content.querySelector("textarea");
				textarea.value = node.properties[propname];
				textarea.addEventListener("keydown", function(e){
					//console.log(e);
					if(e.code == "Enter" && e.ctrlKey )
					{
						console.log("Assigned");
						node.setProperty(propname, textarea.value);
					}
				});
				textarea.style.height = "calc(100% - 40px)";
			}
			var assign = that.createButton( "Assign", null, function(){
				node.setProperty(propname, textarea.value);
			});
			panel.content.appendChild(assign);
			var button = that.createButton( "Close", null, function(){
				panel.style.height = "";
				inner_refresh();
			});
			button.style.float = "right";
			panel.content.appendChild(button);
		}

		inner_refresh();

		this.canvas.parentNode.appendChild( panel );
	}
	
	LGraphCanvas.prototype.showSubgraphPropertiesDialog = function(node)
	{
		console.log("showing subgraph properties dialog");

		var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
		if(old_panel)
			old_panel.close();

		var panel = this.createPanel("Subgraph Inputs",{closable:true, width: 500});
		panel.node = node;
		panel.classList.add("subgraph_dialog");

		function inner_refresh()
		{
			panel.clear();

			//show currents
			if(node.inputs)
				for(var i = 0; i < node.inputs.length; ++i)
				{
					var input = node.inputs[i];
					if(input.not_subgraph_input)
						continue;
					var html = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
					var elem = panel.addHTML(html,"subgraph_property");
					elem.dataset["name"] = input.name;
					elem.dataset["slot"] = i;
					elem.querySelector(".name").innerText = input.name;
					elem.querySelector(".type").innerText = input.type;
					elem.querySelector("button").addEventListener("click",function(e){
						node.removeInput( Number( this.parentNode.dataset["slot"] ) );
						inner_refresh();
					});
				}
		}

		//add extra
		var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
		var elem = panel.addHTML(html,"subgraph_property extra", true);
		elem.querySelector("button").addEventListener("click", function(e){
			var elem = this.parentNode;
			var name = elem.querySelector(".name").value;
			var type = elem.querySelector(".type").value;
			if(!name || node.findInputSlot(name) != -1)
				return;
			node.addInput(name,type);
			elem.querySelector(".name").value = "";
			elem.querySelector(".type").value = "";
			inner_refresh();
		});

		inner_refresh();
	    this.canvas.parentNode.appendChild(panel);
		return panel;
	}

	LGraphCanvas.prototype.checkPanels = function()
	{
		if(!this.canvas)
			return;
		var panels = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
		for(var i = 0; i < panels.length; ++i)
		{
			var panel = panels[i];
			if( !panel.node )
				continue;
			if( !panel.node.graph || panel.graph != this.graph )
				panel.close();
		}
	}

    LGraphCanvas.onMenuNodeCollapse = function(value, options, e, menu, node) {
		node.graph.beforeChange(node);
        node.collapse();
		node.graph.afterChange(node);
    };

    LGraphCanvas.onMenuNodePin = function(value, options, e, menu, node) {
        node.pin();
    };

    LGraphCanvas.onMenuNodeMode = function(value, options, e, menu, node) {
        new LiteGraph.ContextMenu(
            ["Always", "On Event", "On Trigger", "Never"],
            { event: e, callback: inner_clicked, parentMenu: menu, node: node }
        );

        function inner_clicked(v) {
            if (!node) {
                return;
            }
            switch (v) {
                case "On Event":
                    node.mode = LiteGraph.ON_EVENT;
                    break;
                case "On Trigger":
                    node.mode = LiteGraph.ON_TRIGGER;
                    break;
                case "Never":
                    node.mode = LiteGraph.NEVER;
                    break;
                case "Always":
                default:
                    node.mode = LiteGraph.ALWAYS;
                    break;
            }
        }

        return false;
    };

    LGraphCanvas.onMenuNodeColors = function(value, options, e, menu, node) {
        if (!node) {
            throw "no node for color";
        }

        var values = [];
        values.push({
            value: null,
            content:
                "<span style='display: block; padding-left: 4px;'>No color</span>"
        });

        for (var i in LGraphCanvas.node_colors) {
            var color = LGraphCanvas.node_colors[i];
            var value = {
                value: i,
                content:
                    "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " +
                    color.color +
                    "; background-color:" +
                    color.bgcolor +
                    "'>" +
                    i +
                    "</span>"
            };
            values.push(value);
        }
        new LiteGraph.ContextMenu(values, {
            event: e,
            callback: inner_clicked,
            parentMenu: menu,
            node: node
        });

        function inner_clicked(v) {
            if (!node) {
                return;
            }

            var color = v.value ? LGraphCanvas.node_colors[v.value] : null;
            if (color) {
                if (node.constructor === LiteGraph.LGraphGroup) {
                    node.color = color.groupcolor;
                } else {
                    node.color = color.color;
                    node.bgcolor = color.bgcolor;
                }
            } else {
                delete node.color;
                delete node.bgcolor;
            }
            node.setDirtyCanvas(true, true);
        }

        return false;
    };

    LGraphCanvas.onMenuNodeShapes = function(value, options, e, menu, node) {
        if (!node) {
            throw "no node passed";
        }

        new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
            event: e,
            callback: inner_clicked,
            parentMenu: menu,
            node: node
        });

        function inner_clicked(v) {
            if (!node) {
                return;
            }
			node.graph.beforeChange(node);
            node.shape = v;
			node.graph.afterChange(node);
            node.setDirtyCanvas(true);
        }

        return false;
    };

    LGraphCanvas.onMenuNodeRemove = function(value, options, e, menu, node) {
        if (!node) {
            throw "no node passed";
        }

        if (node.removable === false) {
            return;
        }

		var graph = node.graph;
		graph.beforeChange();
        graph.remove(node);
		graph.afterChange();
        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.onMenuNodeToSubgraph = function(value, options, e, menu, node) {
		var graph = node.graph;
		var graphcanvas = LGraphCanvas.active_canvas;
		if(!graphcanvas) //??
			return;

		var nodes_list = Object.values( graphcanvas.selected_nodes || {} );
		if( !nodes_list.length )
			nodes_list = [ node ];

		var subgraph_node = LiteGraph.createNode("graph/subgraph");
		subgraph_node.pos = node.pos.concat();
		graph.add(subgraph_node);

		subgraph_node.buildFromNodes( nodes_list );

		graphcanvas.deselectAllNodes();
        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.onMenuNodeClone = function(value, options, e, menu, node) {
        if (node.clonable == false) {
            return;
        }
        var newnode = node.clone();
        if (!newnode) {
            return;
        }
        newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];

		node.graph.beforeChange();
        node.graph.add(newnode);
		node.graph.afterChange();

        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.node_colors = {
        red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
        brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
        green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
        blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
        pale_blue: {
            color: "#2a363b",
            bgcolor: "#3f5159",
            groupcolor: "#3f789e"
        },
        cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
        purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
        yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
        black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }
    };

    LGraphCanvas.prototype.getCanvasMenuOptions = function() {
        var options = null;
        if (this.getMenuOptions) {
            options = this.getMenuOptions();
        } else {
            options = [
                {
                    content: "Add Node",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuAdd
                },
                { content: "Add Group", callback: LGraphCanvas.onGroupAdd }
                //{content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
            ];

            if (this._graph_stack && this._graph_stack.length > 0) {
                options.push(null, {
                    content: "Close subgraph",
                    callback: this.closeSubgraph.bind(this)
                });
            }
        }

        if (this.getExtraMenuOptions) {
            var extra = this.getExtraMenuOptions(this, options);
            if (extra) {
                options = options.concat(extra);
            }
        }

        return options;
    };

    //called by processContextMenu to extract the menu list
    LGraphCanvas.prototype.getNodeMenuOptions = function(node) {
        var options = null;

        if (node.getMenuOptions) {
            options = node.getMenuOptions(this);
        } else {
            options = [
                {
                    content: "Inputs",
                    has_submenu: true,
                    disabled: true,
                    callback: LGraphCanvas.showMenuNodeOptionalInputs
                },
                {
                    content: "Outputs",
                    has_submenu: true,
                    disabled: true,
                    callback: LGraphCanvas.showMenuNodeOptionalOutputs
                },
                null,
                {
                    content: "Properties",
                    has_submenu: true,
                    callback: LGraphCanvas.onShowMenuNodeProperties
                },
                null,
                {
                    content: "Title",
                    callback: LGraphCanvas.onShowPropertyEditor
                },
                {
                    content: "Mode",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeMode
                },
                {
                    content: "Resize", callback: function() {
                        if(node.resizable) 
                            return LGraphCanvas.onResizeNode;
                    }
                },
                {
                    content: "Collapse",
                    callback: LGraphCanvas.onMenuNodeCollapse
                },
                { content: "Pin", callback: LGraphCanvas.onMenuNodePin },
                {
                    content: "Colors",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeColors
                },
                {
                    content: "Shapes",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeShapes
                },
                null
            ];
        }

        if (node.onGetInputs) {
            var inputs = node.onGetInputs();
            if (inputs && inputs.length) {
                options[0].disabled = false;
            }
        }

        if (node.onGetOutputs) {
            var outputs = node.onGetOutputs();
            if (outputs && outputs.length) {
                options[1].disabled = false;
            }
        }

        if (node.getExtraMenuOptions) {
            var extra = node.getExtraMenuOptions(this, options);
            if (extra) {
                extra.push(null);
                options = extra.concat(options);
            }
        }

        if (node.clonable !== false) {
            options.push({
                content: "Clone",
                callback: LGraphCanvas.onMenuNodeClone
            });
        }

		if(false) //TODO
		{}

		options.push(null, {
			content: "Remove",
			disabled: !(node.removable !== false && !node.block_delete ),
			callback: LGraphCanvas.onMenuNodeRemove
		});

        if (node.graph && node.graph.onGetNodeMenuOptions) {
            node.graph.onGetNodeMenuOptions(options, node);
        }

        return options;
    };

    LGraphCanvas.prototype.getGroupMenuOptions = function(node) {
        var o = [
            { content: "Title", callback: LGraphCanvas.onShowPropertyEditor },
            {
                content: "Color",
                has_submenu: true,
                callback: LGraphCanvas.onMenuNodeColors
            },
            {
                content: "Font size",
                property: "font_size",
                type: "Number",
                callback: LGraphCanvas.onShowPropertyEditor
            },
            null,
            { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }
        ];

        return o;
    };

    LGraphCanvas.prototype.processContextMenu = function(node, event) {
        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var menu_info = null;
        var options = {
            event: event,
            callback: inner_option_clicked,
            extra: node
        };

		if(node)
			options.title = node.type;

        //check if mouse is in input
        var slot = null;
        if (node) {
            slot = node.getSlotInPosition(event.canvasX, event.canvasY);
            LGraphCanvas.active_node = node;
        }

        if (slot) {
            //on slot
            menu_info = [];
            if (node.getSlotMenuOptions) {
                menu_info = node.getSlotMenuOptions(slot);
            } else {
                if (
                    slot &&
                    slot.output &&
                    slot.output.links &&
                    slot.output.links.length
                ) {
                    menu_info.push({ content: "Disconnect Links", slot: slot });
                }
                var _slot = slot.input || slot.output;
                menu_info.push(
                    _slot.locked
                        ? "Cannot remove"
                        : { content: "Remove Slot", slot: slot }
                );
                menu_info.push(
                    _slot.nameLocked
                        ? "Cannot rename"
                        : { content: "Rename Slot", slot: slot }
                );
    
            }
            options.title =
                (slot.input ? slot.input.type : slot.output.type) || "*";
            if (slot.input && slot.input.type == LiteGraph.ACTION) {
                options.title = "Action";
            }
            if (slot.output && slot.output.type == LiteGraph.EVENT) {
                options.title = "Event";
            }
        } else {
            if (node) {
                //on node
                menu_info = this.getNodeMenuOptions(node);
            } else {
                menu_info = this.getCanvasMenuOptions();
                var group = this.graph.getGroupOnPos(
                    event.canvasX,
                    event.canvasY
                );
                if (group) {
                    //on group
                    menu_info.push(null, {
                        content: "Edit Group",
                        has_submenu: true,
                        submenu: {
                            title: "Group",
                            extra: group,
                            options: this.getGroupMenuOptions(group)
                        }
                    });
                }
            }
        }

        //show menu
        if (!menu_info) {
            return;
        }

        var menu = new LiteGraph.ContextMenu(menu_info, options, ref_window);

        function inner_option_clicked(v, options, e) {
            if (!v) {
                return;
            }

            if (v.content == "Remove Slot") {
                var info = v.slot;
                if (info.input) {
                    node.removeInput(info.slot);
                } else if (info.output) {
                    node.removeOutput(info.slot);
                }
                return;
            } else if (v.content == "Disconnect Links") {
                var info = v.slot;
                if (info.output) {
                    node.disconnectOutput(info.slot);
                } else if (info.input) {
                    node.disconnectInput(info.slot);
                }
                return;
            } else if (v.content == "Rename Slot") {
                var info = v.slot;
                var slot_info = info.input
                    ? node.getInputInfo(info.slot)
                    : node.getOutputInfo(info.slot);
                var dialog = that.createDialog(
                    "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
                    options
                );
                var input = dialog.querySelector("input");
                if (input && slot_info) {
                    input.value = slot_info.label || "";
                }
                dialog
                    .querySelector("button")
                    .addEventListener("click", function(e) {
                        if (input.value) {
                            if (slot_info) {
                                slot_info.label = input.value;
                            }
                            that.setDirty(true);
                        }
                        dialog.close();
                    });
            }

            //if(v.callback)
            //	return v.callback.call(that, node, options, e, menu, that, event );
        }
    };

    //API *************************************************
    //like rect but rounded corners
    if (typeof(window) != "undefined" && window.CanvasRenderingContext2D && !window.CanvasRenderingContext2D.prototype.roundRect) {
        window.CanvasRenderingContext2D.prototype.roundRect = function(
		x,
		y,
		w,
		h,
		radius,
		radius_low
	) {
		var top_left_radius = 0;
		var top_right_radius = 0;
		var bottom_left_radius = 0;
		var bottom_right_radius = 0;

		if ( radius === 0 )
		{
			this.rect(x,y,w,h);
			return;
		}

		if(radius_low === undefined)
			radius_low = radius;

		//make it compatible with official one
		if(radius != null && radius.constructor === Array)
		{
			if(radius.length == 1)
				top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0];
			else if(radius.length == 2)
			{
				top_left_radius = bottom_right_radius = radius[0];
				top_right_radius = bottom_left_radius = radius[1];
			}
			else if(radius.length == 4)
			{
				top_left_radius = radius[0];
				top_right_radius = radius[1];
				bottom_left_radius = radius[2];
				bottom_right_radius = radius[3];
			}
			else
				return;
		}
		else //old using numbers
		{
			top_left_radius = radius || 0;
			top_right_radius = radius || 0;
			bottom_left_radius = radius_low || 0;
			bottom_right_radius = radius_low || 0;
		}

		//top right
		this.moveTo(x + top_left_radius, y);
		this.lineTo(x + w - top_right_radius, y);
		this.quadraticCurveTo(x + w, y, x + w, y + top_right_radius);

		//bottom right
		this.lineTo(x + w, y + h - bottom_right_radius);
		this.quadraticCurveTo(
			x + w,
			y + h,
			x + w - bottom_right_radius,
			y + h
		);

		//bottom left
		this.lineTo(x + bottom_right_radius, y + h);
		this.quadraticCurveTo(x, y + h, x, y + h - bottom_left_radius);

		//top left
		this.lineTo(x, y + bottom_left_radius);
		this.quadraticCurveTo(x, y, x + top_left_radius, y);
	};
	}//if

    function compareObjects(a, b) {
        for (var i in a) {
            if (a[i] != b[i]) {
                return false;
            }
        }
        return true;
    }
    LiteGraph.compareObjects = compareObjects;

    function distance(a, b) {
        return Math.sqrt(
            (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
        );
    }
    LiteGraph.distance = distance;

    function colorToString(c) {
        return (
            "rgba(" +
            Math.round(c[0] * 255).toFixed() +
            "," +
            Math.round(c[1] * 255).toFixed() +
            "," +
            Math.round(c[2] * 255).toFixed() +
            "," +
            (c.length == 4 ? c[3].toFixed(2) : "1.0") +
            ")"
        );
    }
    LiteGraph.colorToString = colorToString;

    function isInsideRectangle(x, y, left, top, width, height) {
        if (left < x && left + width > x && top < y && top + height > y) {
            return true;
        }
        return false;
    }
    LiteGraph.isInsideRectangle = isInsideRectangle;

    //[minx,miny,maxx,maxy]
    function growBounding(bounding, x, y) {
        if (x < bounding[0]) {
            bounding[0] = x;
        } else if (x > bounding[2]) {
            bounding[2] = x;
        }

        if (y < bounding[1]) {
            bounding[1] = y;
        } else if (y > bounding[3]) {
            bounding[3] = y;
        }
    }
    LiteGraph.growBounding = growBounding;

    //point inside bounding box
    function isInsideBounding(p, bb) {
        if (
            p[0] < bb[0][0] ||
            p[1] < bb[0][1] ||
            p[0] > bb[1][0] ||
            p[1] > bb[1][1]
        ) {
            return false;
        }
        return true;
    }
    LiteGraph.isInsideBounding = isInsideBounding;

    //bounding overlap, format: [ startx, starty, width, height ]
    function overlapBounding(a, b) {
        var A_end_x = a[0] + a[2];
        var A_end_y = a[1] + a[3];
        var B_end_x = b[0] + b[2];
        var B_end_y = b[1] + b[3];

        if (
            a[0] > B_end_x ||
            a[1] > B_end_y ||
            A_end_x < b[0] ||
            A_end_y < b[1]
        ) {
            return false;
        }
        return true;
    }
    LiteGraph.overlapBounding = overlapBounding;

    //Convert a hex value to its decimal value - the inputted hex must be in the
    //	format of a hex triplet - the kind we use for HTML colours. The function
    //	will return an array with three values.
    function hex2num(hex) {
        if (hex.charAt(0) == "#") {
            hex = hex.slice(1);
        } //Remove the '#' char - if there is one.
        hex = hex.toUpperCase();
        var hex_alphabets = "0123456789ABCDEF";
        var value = new Array(3);
        var k = 0;
        var int1, int2;
        for (var i = 0; i < 6; i += 2) {
            int1 = hex_alphabets.indexOf(hex.charAt(i));
            int2 = hex_alphabets.indexOf(hex.charAt(i + 1));
            value[k] = int1 * 16 + int2;
            k++;
        }
        return value;
    }

    LiteGraph.hex2num = hex2num;

    //Give a array with three values as the argument and the function will return
    //	the corresponding hex triplet.
    function num2hex(triplet) {
        var hex_alphabets = "0123456789ABCDEF";
        var hex = "#";
        var int1, int2;
        for (var i = 0; i < 3; i++) {
            int1 = triplet[i] / 16;
            int2 = triplet[i] % 16;

            hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);
        }
        return hex;
    }

    LiteGraph.num2hex = num2hex;

    /* LiteGraph GUI elements used for canvas editing *************************************/

    /**
     * ContextMenu from LiteGUI
     *
     * @class ContextMenu
     * @constructor
     * @param {Array} values (allows object { title: "Nice text", callback: function ... })
     * @param {Object} options [optional] Some options:\
     * - title: title to show on top of the menu
     * - callback: function to call when an option is clicked, it receives the item information
     * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback
     * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position
     */
    function ContextMenu(values, options) {
        options = options || {};
        this.options = options;
        var that = this;

        //to link a menu with its parent
        if (options.parentMenu) {
            if (options.parentMenu.constructor !== this.constructor) {
                console.error(
                    "parentMenu must be of class ContextMenu, ignoring it"
                );
                options.parentMenu = null;
            } else {
                this.parentMenu = options.parentMenu;
                this.parentMenu.lock = true;
                this.parentMenu.current_submenu = this;
            }
        }

		var eventClass = null;
		if(options.event) //use strings because comparing classes between windows doesnt work
			eventClass = options.event.constructor.name;
        if ( eventClass !== "MouseEvent" &&
            eventClass !== "CustomEvent" &&
			eventClass !== "PointerEvent"
        ) {
            console.error(
                "Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it."
            );
            options.event = null;
        }

        var root = document.createElement("div");
        root.className = "litegraph litecontextmenu litemenubar-panel";
        if (options.className) {
            root.className += " " + options.className;
        }
        root.style.minWidth = 100;
        root.style.minHeight = 100;
        root.style.pointerEvents = "none";
        setTimeout(function() {
            root.style.pointerEvents = "auto";
        }, 100); //delay so the mouse up event is not caught by this element

        //this prevents the default context browser menu to open in case this menu was created when pressing right button
        root.addEventListener(
            "mouseup",
            function(e) {
                e.preventDefault();
                return true;
            },
            true
        );
        root.addEventListener(
            "contextmenu",
            function(e) {
                if (e.button != 2) {
                    //right button
                    return false;
                }
                e.preventDefault();
                return false;
            },
            true
        );

        root.addEventListener(
            "mousedown",
            function(e) {
                if (e.button == 2) {
                    that.close();
                    e.preventDefault();
                    return true;
                }
            },
            true
        );

        function on_mouse_wheel(e) {
            var pos = parseInt(root.style.top);
            root.style.top =
                (pos + e.deltaY * options.scroll_speed).toFixed() + "px";
            e.preventDefault();
            return true;
        }

        if (!options.scroll_speed) {
            options.scroll_speed = 0.1;
        }

        root.addEventListener("wheel", on_mouse_wheel, true);
        root.addEventListener("mousewheel", on_mouse_wheel, true);

        this.root = root;

        //title
        if (options.title) {
            var element = document.createElement("div");
            element.className = "litemenu-title";
            element.innerHTML = options.title;
            root.appendChild(element);
        }

        //entries
        var num = 0;
        for (var i=0; i < values.length; i++) {
            var name = values.constructor == Array ? values[i] : i;
            if (name != null && name.constructor !== String) {
                name = name.content === undefined ? String(name) : name.content;
            }
            var value = values[i];
            this.addItem(name, value, options);
            num++;
        }

        //close on leave
        root.addEventListener("mouseleave", function(e) {
            if (that.lock) {
                return;
            }
            if (root.closing_timer) {
                clearTimeout(root.closing_timer);
            }
            root.closing_timer = setTimeout(that.close.bind(that, e), 500);
            //that.close(e);
        });

        root.addEventListener("mouseenter", function(e) {
            if (root.closing_timer) {
                clearTimeout(root.closing_timer);
            }
        });

        //insert before checking position
        var root_document = document;
        if (options.event) {
            root_document = options.event.target.ownerDocument;
        }

        if (!root_document) {
            root_document = document;
        }

		if( root_document.fullscreenElement )
	        root_document.fullscreenElement.appendChild(root);
		else
		    root_document.body.appendChild(root);

        //compute best position
        var left = options.left || 0;
        var top = options.top || 0;
        if (options.event) {
            left = options.event.clientX - 10;
            top = options.event.clientY - 10;
            if (options.title) {
                top -= 20;
            }

            if (options.parentMenu) {
                var rect = options.parentMenu.root.getBoundingClientRect();
                left = rect.left + rect.width;
            }

            var body_rect = document.body.getBoundingClientRect();
            var root_rect = root.getBoundingClientRect();
			if(body_rect.height == 0)
				console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");

            if (body_rect.width && left > body_rect.width - root_rect.width - 10) {
                left = body_rect.width - root_rect.width - 10;
            }
            if (body_rect.height && top > body_rect.height - root_rect.height - 10) {
                top = body_rect.height - root_rect.height - 10;
            }
        }

        root.style.left = left + "px";
        root.style.top = top + "px";

        if (options.scale) {
            root.style.transform = "scale(" + options.scale + ")";
        }
    }

    ContextMenu.prototype.addItem = function(name, value, options) {
        var that = this;
        options = options || {};

        var element = document.createElement("div");
        element.className = "litemenu-entry submenu";

        var disabled = false;

        if (value === null) {
            element.classList.add("separator");
            //element.innerHTML = "<hr/>"
            //continue;
        } else {
            element.innerHTML = value && value.title ? value.title : name;
            element.value = value;

            if (value) {
                if (value.disabled) {
                    disabled = true;
                    element.classList.add("disabled");
                }
                if (value.submenu || value.has_submenu) {
                    element.classList.add("has_submenu");
                }
            }

            if (typeof value == "function") {
                element.dataset["value"] = name;
                element.onclick_callback = value;
            } else {
                element.dataset["value"] = value;
            }

            if (value.className) {
                element.className += " " + value.className;
            }
        }

        this.root.appendChild(element);
        if (!disabled) {
            element.addEventListener("click", inner_onclick);
        }
        if (options.autoopen) {
            element.addEventListener("mouseenter", inner_over);
        }

        function inner_over(e) {
            var value = this.value;
            if (!value || !value.has_submenu) {
                return;
            }
            //if it is a submenu, autoopen like the item was clicked
            inner_onclick.call(this, e);
        }

        //menu option clicked
        function inner_onclick(e) {
            var value = this.value;
            var close_parent = true;

            if (that.current_submenu) {
                that.current_submenu.close(e);
            }

            //global callback
            if (options.callback) {
                var r = options.callback.call(
                    this,
                    value,
                    options,
                    e,
                    that,
                    options.node
                );
                if (r === true) {
                    close_parent = false;
                }
            }

            //special cases
            if (value) {
                if (
                    value.callback &&
                    !options.ignore_item_callbacks &&
                    value.disabled !== true
                ) {
                    //item callback
                    var r = value.callback.call(
                        this,
                        value,
                        options,
                        e,
                        that,
                        options.extra
                    );
                    if (r === true) {
                        close_parent = false;
                    }
                }
                if (value.submenu) {
                    if (!value.submenu.options) {
                        throw "ContextMenu submenu needs options";
                    }
                    var submenu = new that.constructor(value.submenu.options, {
                        callback: value.submenu.callback,
                        event: e,
                        parentMenu: that,
                        ignore_item_callbacks:
                            value.submenu.ignore_item_callbacks,
                        title: value.submenu.title,
                        extra: value.submenu.extra,
                        autoopen: options.autoopen
                    });
                    close_parent = false;
                }
            }

            if (close_parent && !that.lock) {
                that.close();
            }
        }

        return element;
    };

    ContextMenu.prototype.close = function(e, ignore_parent_menu) {
        if (this.root.parentNode) {
            this.root.parentNode.removeChild(this.root);
        }
        if (this.parentMenu && !ignore_parent_menu) {
            this.parentMenu.lock = false;
            this.parentMenu.current_submenu = null;
            if (e === undefined) {
                this.parentMenu.close();
            } else if (
                e &&
                !ContextMenu.isCursorOverElement(e, this.parentMenu.root)
            ) {
                ContextMenu.trigger(this.parentMenu.root, "mouseleave", e);
            }
        }
        if (this.current_submenu) {
            this.current_submenu.close(e, true);
        }

        if (this.root.closing_timer) {
            clearTimeout(this.root.closing_timer);
        }
    };

    //this code is used to trigger events easily (used in the context menu mouseleave
    ContextMenu.trigger = function(element, event_name, params, origin) {
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event_name, true, true, params); //canBubble, cancelable, detail
        evt.srcElement = origin;
        if (element.dispatchEvent) {
            element.dispatchEvent(evt);
        } else if (element.__events) {
            element.__events.dispatchEvent(evt);
        }
        //else nothing seems binded here so nothing to do
        return evt;
    };

    //returns the top most menu
    ContextMenu.prototype.getTopMenu = function() {
        if (this.options.parentMenu) {
            return this.options.parentMenu.getTopMenu();
        }
        return this;
    };

    ContextMenu.prototype.getFirstEvent = function() {
        if (this.options.parentMenu) {
            return this.options.parentMenu.getFirstEvent();
        }
        return this.options.event;
    };

    ContextMenu.isCursorOverElement = function(event, element) {
        var left = event.clientX;
        var top = event.clientY;
        var rect = element.getBoundingClientRect();
        if (!rect) {
            return false;
        }
        if (
            top > rect.top &&
            top < rect.top + rect.height &&
            left > rect.left &&
            left < rect.left + rect.width
        ) {
            return true;
        }
        return false;
    };

    LiteGraph.ContextMenu = ContextMenu;

    LiteGraph.closeAllContextMenus = function(ref_window) {
        ref_window = ref_window || window;

        var elements = ref_window.document.querySelectorAll(".litecontextmenu");
        if (!elements.length) {
            return;
        }

        var result = [];
        for (var i = 0; i < elements.length; i++) {
            result.push(elements[i]);
        }

        for (var i=0; i < result.length; i++) {
            if (result[i].close) {
                result[i].close();
            } else if (result[i].parentNode) {
                result[i].parentNode.removeChild(result[i]);
            }
        }
    };

    LiteGraph.extendClass = function(target, origin) {
        for (var i in origin) {
            //copy class properties
            if (target.hasOwnProperty(i)) {
                continue;
            }
            target[i] = origin[i];
        }

        if (origin.prototype) {
            //copy prototype properties
            for (var i in origin.prototype) {
                //only enumerable
                if (!origin.prototype.hasOwnProperty(i)) {
                    continue;
                }

                if (target.prototype.hasOwnProperty(i)) {
                    //avoid overwriting existing ones
                    continue;
                }

                //copy getters
                if (origin.prototype.__lookupGetter__(i)) {
                    target.prototype.__defineGetter__(
                        i,
                        origin.prototype.__lookupGetter__(i)
                    );
                } else {
                    target.prototype[i] = origin.prototype[i];
                }

                //and setters
                if (origin.prototype.__lookupSetter__(i)) {
                    target.prototype.__defineSetter__(
                        i,
                        origin.prototype.__lookupSetter__(i)
                    );
                }
            }
        }
    };

	//used by some widgets to render a curve editor
	function CurveEditor( points )
	{
		this.points = points;
		this.selected = -1;
		this.nearest = -1;
		this.size = null; //stores last size used
		this.must_update = true;
		this.margin = 5;
	}

	CurveEditor.sampleCurve = function(f,points)
	{
		if(!points)
			return;
		for(var i = 0; i < points.length - 1; ++i)
		{
			var p = points[i];
			var pn = points[i+1];
			if(pn[0] < f)
				continue;
			var r = (pn[0] - p[0]);
			if( Math.abs(r) < 0.00001 )
				return p[1];
			var local_f = (f - p[0]) / r;
			return p[1] * (1.0 - local_f) + pn[1] * local_f;
		}
		return 0;
	}

	CurveEditor.prototype.draw = function( ctx, size, graphcanvas, background_color, line_color, inactive )
	{
		var points = this.points;
		if(!points)
			return;
		this.size = size;
		var w = size[0] - this.margin * 2;
		var h = size[1] - this.margin * 2;

		line_color = line_color || "#666";

		ctx.save();
		ctx.translate(this.margin,this.margin);

		if(background_color)
		{
			ctx.fillStyle = "#111";
			ctx.fillRect(0,0,w,h);
			ctx.fillStyle = "#222";
			ctx.fillRect(w*0.5,0,1,h);
			ctx.strokeStyle = "#333";
			ctx.strokeRect(0,0,w,h);
		}
		ctx.strokeStyle = line_color;
		if(inactive)
			ctx.globalAlpha = 0.5;
		ctx.beginPath();
		for(var i = 0; i < points.length; ++i)
		{
			var p = points[i];
			ctx.lineTo( p[0] * w, (1.0 - p[1]) * h );
		}
		ctx.stroke();
		ctx.globalAlpha = 1;
		if(!inactive)
			for(var i = 0; i < points.length; ++i)
			{
				var p = points[i];
				ctx.fillStyle = this.selected == i ? "#FFF" : (this.nearest == i ? "#DDD" : "#AAA");
				ctx.beginPath();
				ctx.arc( p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2 );
				ctx.fill();
			}
		ctx.restore();
	}

	//localpos is mouse in curve editor space
	CurveEditor.prototype.onMouseDown = function( localpos, graphcanvas )
	{
		var points = this.points;
		if(!points)
			return;
		if( localpos[1] < 0 )
			return;

		//this.captureInput(true);
		var w = this.size[0] - this.margin * 2;
		var h = this.size[1] - this.margin * 2;
		var x = localpos[0] - this.margin;
		var y = localpos[1] - this.margin;
		var pos = [x,y];
		var max_dist = 30 / graphcanvas.ds.scale;
		//search closer one
		this.selected = this.getCloserPoint(pos, max_dist);
		//create one
		if(this.selected == -1)
		{
			var point = [x / w, 1 - y / h];
			points.push(point);
			points.sort(function(a,b){ return a[0] - b[0]; });
			this.selected = points.indexOf(point);
			this.must_update = true;
		}
		if(this.selected != -1)
			return true;
	}

	CurveEditor.prototype.onMouseMove = function( localpos, graphcanvas )
	{
		var points = this.points;
		if(!points)
			return;
		var s = this.selected;
		if(s < 0)
			return;
		var x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2 );
		var y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2 );
		var curvepos = [(localpos[0] - this.margin),(localpos[1] - this.margin)];
		var max_dist = 30 / graphcanvas.ds.scale;
		this._nearest = this.getCloserPoint(curvepos, max_dist);
		var point = points[s];
		if(point)
		{
			var is_edge_point = s == 0 || s == points.length - 1;
			if( !is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10) )
			{
				points.splice(s,1);
				this.selected = -1;
				return;
			}
			if( !is_edge_point ) //not edges
				point[0] = Math.clamp(x,0,1);
			else
				point[0] = s == 0 ? 0 : 1;
			point[1] = 1.0 - Math.clamp(y,0,1);
			points.sort(function(a,b){ return a[0] - b[0]; });
			this.selected = points.indexOf(point);
			this.must_update = true;
		}
	}

	CurveEditor.prototype.onMouseUp = function( localpos, graphcanvas )
	{
		this.selected = -1;
		return false;
	}

	CurveEditor.prototype.getCloserPoint = function(pos, max_dist)
	{
		var points = this.points;
		if(!points)
			return -1;
		max_dist = max_dist || 30;
		var w = (this.size[0] - this.margin * 2);
		var h = (this.size[1] - this.margin * 2);
		var num = points.length;
		var p2 = [0,0];
		var min_dist = 1000000;
		var closest = -1;
		var last_valid = -1;
		for(var i = 0; i < num; ++i)
		{
			var p = points[i];
			p2[0] = p[0] * w;
			p2[1] = (1.0 - p[1]) * h;
			if(p2[0] < pos[0])
				last_valid = i;
			var dist = vec2.distance(pos,p2);
			if(dist > min_dist || dist > max_dist)
				continue;
			closest = i;
			min_dist = dist;
		}
		return closest;
	}

	LiteGraph.CurveEditor = CurveEditor;

    //used to create nodes from wrapping functions
    LiteGraph.getParameterNames = function(func) {
        return (func + "")
            .replace(/[/][/].*$/gm, "") // strip single-line comments
            .replace(/\s+/g, "") // strip white space
            .replace(/[/][*][^/*]*[*][/]/g, "") // strip multi-line comments  /**/
            .split("){", 1)[0]
            .replace(/^[^(]*[(]/, "") // extract the parameters
            .replace(/=[^,]+/g, "") // strip any ES6 defaults
            .split(",")
            .filter(Boolean); // split & filter [""]
    };

    Math.clamp = function(v, a, b) {
        return a > v ? a : b < v ? b : v;
    };

    if (typeof window != "undefined" && !window["requestAnimationFrame"]) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    }
})(this);

if (true) {
    exports.LiteGraph = this.LiteGraph;
}

//basic nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    //Constant
    function Time() {
        this.addOutput("in ms", "number");
        this.addOutput("in sec", "number");
    }

    Time.title = "Time";
    Time.desc = "Time";

    Time.prototype.onExecute = function() {
        this.setOutputData(0, this.graph.globaltime * 1000);
        this.setOutputData(1, this.graph.globaltime);
    };

    LiteGraph.registerNodeType("basic/time", Time);

    //Subgraph: a node that contains a graph
    function Subgraph() {
        var that = this;
        this.size = [140, 80];
        this.properties = { enabled: true };
        this.enabled = true;

        //create inner graph
        this.subgraph = new LiteGraph.LGraph();
        this.subgraph._subgraph_node = this;
        this.subgraph._is_subgraph = true;

        this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);

		//nodes input node added inside
        this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);
        this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);
        this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);
        this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);

        this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);
        this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);
        this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);
        this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
    }

    Subgraph.title = "Subgraph";
    Subgraph.desc = "Graph inside a node";
    Subgraph.title_color = "#334";

    Subgraph.prototype.onGetInputs = function() {
        return [["enabled", "boolean"]];
    };

	/*
    Subgraph.prototype.onDrawTitle = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.fillStyle = "#555";
        var w = LiteGraph.NODE_TITLE_HEIGHT;
        var x = this.size[0] - w;
        ctx.fillRect(x, -w, w, w);
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(x + w * 0.2, -w * 0.6);
        ctx.lineTo(x + w * 0.8, -w * 0.6);
        ctx.lineTo(x + w * 0.5, -w * 0.3);
        ctx.fill();
    };
	*/

    Subgraph.prototype.onDblClick = function(e, pos, graphcanvas) {
        var that = this;
        setTimeout(function() {
            graphcanvas.openSubgraph(that.subgraph);
        }, 10);
    };

	/*
    Subgraph.prototype.onMouseDown = function(e, pos, graphcanvas) {
        if (
            !this.flags.collapsed &&
            pos[0] > this.size[0] - LiteGraph.NODE_TITLE_HEIGHT &&
            pos[1] < 0
        ) {
            var that = this;
            setTimeout(function() {
                graphcanvas.openSubgraph(that.subgraph);
            }, 10);
        }
    };
	*/

    Subgraph.prototype.onAction = function(action, param) {
        this.subgraph.onAction(action, param);
    };

    Subgraph.prototype.onExecute = function() {
        this.enabled = this.getInputOrProperty("enabled");
        if (!this.enabled) {
            return;
        }

        //send inputs to subgraph global inputs
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var value = this.getInputData(i);
                this.subgraph.setInputData(input.name, value);
            }
        }

        //execute
        this.subgraph.runStep();

        //send subgraph global outputs to outputs
        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                var value = this.subgraph.getOutputData(output.name);
                this.setOutputData(i, value);
            }
        }
    };

    Subgraph.prototype.sendEventToAllNodes = function(eventname, param, mode) {
        if (this.enabled) {
            this.subgraph.sendEventToAllNodes(eventname, param, mode);
        }
    };

	Subgraph.prototype.onDrawBackground = function(ctx, graphcanvas, canvas, pos)
	{
		if(this.flags.collapsed)
			return;

		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;

		//button
		var over = LiteGraph.isInsideRectangle(pos[0],pos[1],this.pos[0],this.pos[1] + y,this.size[0],LiteGraph.NODE_TITLE_HEIGHT);
		ctx.fillStyle = over ? "#555" : "#222";
		ctx.beginPath();
		if (this._shape == LiteGraph.BOX_SHAPE)
			ctx.rect(0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT);
		else
			ctx.roundRect( 0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT, 0, 8);
		ctx.fill();

		//button
		ctx.textAlign = "center";
		ctx.font = "24px Arial";
		ctx.fillStyle = over ? "#DDD" : "#999";
		ctx.fillText( "+", this.size[0] * 0.5, y + 24 );
	}

	Subgraph.prototype.onMouseDown = function(e, localpos, graphcanvas)
	{
		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
		if(localpos[1] > y)
		{
			graphcanvas.showSubgraphPropertiesDialog(this);
		}
	}

	Subgraph.prototype.computeSize = function()
	{
		var num_inputs = this.inputs ? this.inputs.length : 0;
		var num_outputs = this.outputs ? this.outputs.length : 0;
		return [ 200, Math.max(num_inputs,num_outputs) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT ];
	}

    //**** INPUTS ***********************************
    Subgraph.prototype.onSubgraphTrigger = function(event, param) {
        var slot = this.findOutputSlot(event);
        if (slot != -1) {
            this.triggerSlot(slot);
        }
    };

    Subgraph.prototype.onSubgraphNewInput = function(name, type) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            //add input to the node
            this.addInput(name, type);
        }
    };

    Subgraph.prototype.onSubgraphRenamedInput = function(oldname, name) {
        var slot = this.findInputSlot(oldname);
        if (slot == -1) {
            return;
        }
        var info = this.getInputInfo(slot);
        info.name = name;
    };

    Subgraph.prototype.onSubgraphTypeChangeInput = function(name, type) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        var info = this.getInputInfo(slot);
        info.type = type;
    };

    Subgraph.prototype.onSubgraphRemovedInput = function(name) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        this.removeInput(slot);
    };

    //**** OUTPUTS ***********************************
    Subgraph.prototype.onSubgraphNewOutput = function(name, type) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            this.addOutput(name, type);
        }
    };

    Subgraph.prototype.onSubgraphRenamedOutput = function(oldname, name) {
        var slot = this.findOutputSlot(oldname);
        if (slot == -1) {
            return;
        }
        var info = this.getOutputInfo(slot);
        info.name = name;
    };

    Subgraph.prototype.onSubgraphTypeChangeOutput = function(name, type) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            return;
        }
        var info = this.getOutputInfo(slot);
        info.type = type;
    };

    Subgraph.prototype.onSubgraphRemovedOutput = function(name) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        this.removeOutput(slot);
    };
    // *****************************************************

    Subgraph.prototype.getExtraMenuOptions = function(graphcanvas) {
        var that = this;
        return [
            {
                content: "Open",
                callback: function() {
                    graphcanvas.openSubgraph(that.subgraph);
                }
            }
        ];
    };

    Subgraph.prototype.onResize = function(size) {
        size[1] += 20;
    };

    Subgraph.prototype.serialize = function() {
        var data = LiteGraph.LGraphNode.prototype.serialize.call(this);
        data.subgraph = this.subgraph.serialize();
        return data;
    };
    //no need to define node.configure, the default method detects node.subgraph and passes the object to node.subgraph.configure()

    Subgraph.prototype.clone = function() {
        var node = LiteGraph.createNode(this.type);
        var data = this.serialize();
        delete data["id"];
        delete data["inputs"];
        delete data["outputs"];
        node.configure(data);
        return node;
    };

	Subgraph.prototype.buildFromNodes = function(nodes)
	{
		//clear all?
		//TODO

		//nodes that connect data between parent graph and subgraph
		var subgraph_inputs = [];
		var subgraph_outputs = [];

		//mark inner nodes
		var ids = {};
		var min_x = 0;
		var max_x = 0;
		for(var i = 0; i < nodes.length; ++i)
		{
			var node = nodes[i];
			ids[ node.id ] = node;
			min_x = Math.min( node.pos[0], min_x );
			max_x = Math.max( node.pos[0], min_x );
		}
		
		var last_input_y = 0;
		var last_output_y = 0;

		for(var i = 0; i < nodes.length; ++i)
		{
			var node = nodes[i];
			//check inputs
			if( node.inputs )
				for(var j = 0; j < node.inputs.length; ++j)
				{
					var input = node.inputs[j];
					if( !input || !input.link )
						continue;
					var link = node.graph.links[ input.link ];
					if(!link)
						continue;
					if( ids[ link.origin_id ] )
						continue;
					//this.addInput(input.name,link.type);
					this.subgraph.addInput(input.name,link.type);
					/*
					var input_node = LiteGraph.createNode("graph/input");
					this.subgraph.add( input_node );
					input_node.pos = [min_x - 200, last_input_y ];
					last_input_y += 100;
					*/
				}

			//check outputs
			if( node.outputs )
				for(var j = 0; j < node.outputs.length; ++j)
				{
					var output = node.outputs[j];
					if( !output || !output.links || !output.links.length )
						continue;
					var is_external = false;
					for(var k = 0; k < output.links.length; ++k)
					{
						var link = node.graph.links[ output.links[k] ];
						if(!link)
							continue;
						if( ids[ link.target_id ] )
							continue;
						is_external = true;
						break;
					}
					if(!is_external)
						continue;
					//this.addOutput(output.name,output.type);
					/*
					var output_node = LiteGraph.createNode("graph/output");
					this.subgraph.add( output_node );
					output_node.pos = [max_x + 50, last_output_y ];
					last_output_y += 100;
					*/
				}
		}

		//detect inputs and outputs
			//split every connection in two data_connection nodes
			//keep track of internal connections
			//connect external connections

		//clone nodes inside subgraph and try to reconnect them

		//connect edge subgraph nodes to extarnal connections nodes
	}

    LiteGraph.Subgraph = Subgraph;
    LiteGraph.registerNodeType("graph/subgraph", Subgraph);

    //Input for a subgraph
    function GraphInput() {
        this.addOutput("", "number");

        this.name_in_graph = "";
        this.properties = {
			name: "",
			type: "number",
			value: 0
		}; 

        var that = this;

        this.name_widget = this.addWidget(
            "text",
            "Name",
            this.properties.name,
            function(v) {
                if (!v) {
                    return;
                }
                that.setProperty("name",v);
            }
        );
        this.type_widget = this.addWidget(
            "text",
            "Type",
            this.properties.type,
            function(v) {
				that.setProperty("type",v);
            }
        );

        this.value_widget = this.addWidget(
            "number",
            "Value",
            this.properties.value,
            function(v) {
                that.setProperty("value",v);
            }
        );

        this.widgets_up = true;
        this.size = [180, 90];
    }

    GraphInput.title = "Input";
    GraphInput.desc = "Input of the graph";

	GraphInput.prototype.onConfigure = function()
	{
		this.updateType();
	}

	//ensures the type in the node output and the type in the associated graph input are the same
	GraphInput.prototype.updateType = function()
	{
		var type = this.properties.type;
		this.type_widget.value = type;

		//update output
		if(this.outputs[0].type != type)
		{
	        if (!LiteGraph.isValidConnection(this.outputs[0].type,type))
				this.disconnectOutput(0);
			this.outputs[0].type = type;
		}

		//update widget
		if(type == "number")
		{
			this.value_widget.type = "number";
			this.value_widget.value = 0;
		}
		else if(type == "boolean")
		{
			this.value_widget.type = "toggle";
			this.value_widget.value = true;
		}
		else if(type == "string")
		{
			this.value_widget.type = "text";
			this.value_widget.value = "";
		}
		else
		{
			this.value_widget.type = null;
			this.value_widget.value = null;
		}
		this.properties.value = this.value_widget.value;

		//update graph
		if (this.graph && this.name_in_graph) {
			this.graph.changeInputType(this.name_in_graph, type);
		}
	}

	//this is executed AFTER the property has changed
	GraphInput.prototype.onPropertyChanged = function(name,v)
	{
		if( name == "name" )
		{
			if (v == "" || v == this.name_in_graph || v == "enabled") {
				return false;
			}
			if(this.graph)
			{
				if (this.name_in_graph) {
					//already added
					this.graph.renameInput( this.name_in_graph, v );
				} else {
					this.graph.addInput( v, this.properties.type );
				}
			} //what if not?!
			this.name_widget.value = v;
			this.name_in_graph = v;
		}
		else if( name == "type" )
		{
			this.updateType();
		}
		else if( name == "value" )
		{
		}
	}

    GraphInput.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.name;
        }
        return this.title;
    };

    GraphInput.prototype.onAction = function(action, param) {
        if (this.properties.type == LiteGraph.EVENT) {
            this.triggerSlot(0, param);
        }
    };

    GraphInput.prototype.onExecute = function() {
        var name = this.properties.name;
        //read from global input
        var data = this.graph.inputs[name];
        if (!data) {
            this.setOutputData(0, this.properties.value );
			return;
        }

        this.setOutputData(0, data.value !== undefined ? data.value : this.properties.value );
    };

    GraphInput.prototype.onRemoved = function() {
        if (this.name_in_graph) {
            this.graph.removeInput(this.name_in_graph);
        }
    };

    LiteGraph.GraphInput = GraphInput;
    LiteGraph.registerNodeType("graph/input", GraphInput);

    //Output for a subgraph
    function GraphOutput() {
        this.addInput("", "");

        this.name_in_graph = "";
        this.properties = {};
        var that = this;

        Object.defineProperty(this.properties, "name", {
            get: function() {
                return that.name_in_graph;
            },
            set: function(v) {
                if (v == "" || v == that.name_in_graph) {
                    return;
                }
                if (that.name_in_graph) {
                    //already added
                    that.graph.renameOutput(that.name_in_graph, v);
                } else {
                    that.graph.addOutput(v, that.properties.type);
                }
                that.name_widget.value = v;
                that.name_in_graph = v;
            },
            enumerable: true
        });

        Object.defineProperty(this.properties, "type", {
            get: function() {
                return that.inputs[0].type;
            },
            set: function(v) {
                if (v == "action" || v == "event") {
                    v = LiteGraph.ACTION;
                }
		        if (!LiteGraph.isValidConnection(that.inputs[0].type,v))
					that.disconnectInput(0);
                that.inputs[0].type = v;
                if (that.name_in_graph) {
                    //already added
                    that.graph.changeOutputType(
                        that.name_in_graph,
                        that.inputs[0].type
                    );
                }
                that.type_widget.value = v || "";
            },
            enumerable: true
        });

        this.name_widget = this.addWidget("text","Name",this.properties.name,"name");
        this.type_widget = this.addWidget("text","Type",this.properties.type,"type");
        this.widgets_up = true;
        this.size = [180, 60];
    }

    GraphOutput.title = "Output";
    GraphOutput.desc = "Output of the graph";

    GraphOutput.prototype.onExecute = function() {
        this._value = this.getInputData(0);
        this.graph.setOutputData(this.properties.name, this._value);
    };

    GraphOutput.prototype.onAction = function(action, param) {
        if (this.properties.type == LiteGraph.ACTION) {
            this.graph.trigger(this.properties.name, param);
        }
    };

    GraphOutput.prototype.onRemoved = function() {
        if (this.name_in_graph) {
            this.graph.removeOutput(this.name_in_graph);
        }
    };

    GraphOutput.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.name;
        }
        return this.title;
    };

    LiteGraph.GraphOutput = GraphOutput;
    LiteGraph.registerNodeType("graph/output", GraphOutput);

    //Constant
    function ConstantNumber() {
        this.addOutput("value", "number");
        this.addProperty("value", 1.0);
        this.widget = this.addWidget("number","value",1,"value");
        this.widgets_up = true;
        this.size = [180, 30];
    }

    ConstantNumber.title = "Const Number";
    ConstantNumber.desc = "Constant number";

    ConstantNumber.prototype.onExecute = function() {
        this.setOutputData(0, parseFloat(this.properties["value"]));
    };

    ConstantNumber.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.value;
        }
        return this.title;
    };

	ConstantNumber.prototype.setValue = function(v)
	{
		this.setProperty("value",v);
	}

    ConstantNumber.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.outputs[0].label = this.properties["value"].toFixed(3);
    };

    LiteGraph.registerNodeType("basic/const", ConstantNumber);

    function ConstantBoolean() {
        this.addOutput("", "boolean");
        this.addProperty("value", true);
        this.widget = this.addWidget("toggle","value",true,"value");
        this.widgets_up = true;
        this.size = [140, 30];
    }

    ConstantBoolean.title = "Const Boolean";
    ConstantBoolean.desc = "Constant boolean";
    ConstantBoolean.prototype.getTitle = ConstantNumber.prototype.getTitle;

    ConstantBoolean.prototype.onExecute = function() {
        this.setOutputData(0, this.properties["value"]);
    };

	ConstantBoolean.prototype.setValue = ConstantNumber.prototype.setValue;

	ConstantBoolean.prototype.onGetInputs = function() {
		return [["toggle", LiteGraph.ACTION]];
	};

	ConstantBoolean.prototype.onAction = function(action)
	{
		this.setValue( !this.properties.value );
	}

    LiteGraph.registerNodeType("basic/boolean", ConstantBoolean);

    function ConstantString() {
        this.addOutput("", "string");
        this.addProperty("value", "");
        this.widget = this.addWidget("text","value","","value");  //link to property value
        this.widgets_up = true;
        this.size = [180, 30];
    }

    ConstantString.title = "Const String";
    ConstantString.desc = "Constant string";

    ConstantString.prototype.getTitle = ConstantNumber.prototype.getTitle;

    ConstantString.prototype.onExecute = function() {
        this.setOutputData(0, this.properties["value"]);
    };

	ConstantString.prototype.setValue = ConstantNumber.prototype.setValue;

	ConstantString.prototype.onDropFile = function(file)
	{
		var that = this;
		var reader = new FileReader();
		reader.onload = function(e)
		{
			that.setProperty("value",e.target.result);
		}
		reader.readAsText(file);
	}

    LiteGraph.registerNodeType("basic/string", ConstantString);

    function ConstantObject() {
        this.addOutput("obj", "object");
        this.size = [120, 30];
		this._object = {};
    }

    ConstantObject.title = "Const Object";
    ConstantObject.desc = "Constant Object";

    ConstantObject.prototype.onExecute = function() {
        this.setOutputData(0, this._object);
    };

    LiteGraph.registerNodeType( "basic/object", ConstantObject );

    function ConstantFile() {
        this.addInput("url", "");
        this.addOutput("", "");
        this.addProperty("url", "");
        this.addProperty("type", "text");
        this.widget = this.addWidget("text","url","","url");
        this._data = null;
    }

    ConstantFile.title = "Const File";
    ConstantFile.desc = "Fetches a file from an url";
    ConstantFile["@type"] = { type: "enum", values: ["text","arraybuffer","blob","json"] };

    ConstantFile.prototype.onPropertyChanged = function(name, value) {
        if (name == "url")
		{
			if( value == null || value == "")
				this._data = null;
			else
			{
				this.fetchFile(value);
			}
		}
	}

    ConstantFile.prototype.onExecute = function() {
		var url = this.getInputData(0) || this.properties.url;
		if(url && (url != this._url || this._type != this.properties.type))
			this.fetchFile(url);
        this.setOutputData(0, this._data );
    };

	ConstantFile.prototype.setValue = ConstantNumber.prototype.setValue;

    ConstantFile.prototype.fetchFile = function(url) {
		var that = this;
		if(!url || url.constructor !== String)
		{
			that._data = null;
            that.boxcolor = null;
			return;
		}

		this._url = url;
		this._type = this.properties.type;
        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }
		fetch(url)
		.then(function(response) {
			if(!response.ok)
				 throw new Error("File not found");

			if(that.properties.type == "arraybuffer")
				return response.arrayBuffer();
			else if(that.properties.type == "text")
				return response.text();
			else if(that.properties.type == "json")
				return response.json();
			else if(that.properties.type == "blob")
				return response.blob();
		})
		.then(function(data) {
			that._data = data;
            that.boxcolor = "#AEA";
		})
		.catch(function(error) {
			that._data = null;
            that.boxcolor = "red";
			console.error("error fetching file:",url);
		});
    };

	ConstantFile.prototype.onDropFile = function(file)
	{
		var that = this;
		this._url = file.name;
		this._type = this.properties.type;
		this.properties.url = file.name;
		var reader = new FileReader();
		reader.onload = function(e)
		{
            that.boxcolor = "#AEA";
			var v = e.target.result;
			if( that.properties.type == "json" )
				v = JSON.parse(v);
			that._data = v;
		}
		if(that.properties.type == "arraybuffer")
			reader.readAsArrayBuffer(file);
		else if(that.properties.type == "text" || that.properties.type == "json")
			reader.readAsText(file);
		else if(that.properties.type == "blob")
			return reader.readAsBinaryString(file);
	}

    LiteGraph.registerNodeType("basic/file", ConstantFile);

	//to store json objects
    function ConstantData() {
        this.addOutput("", "");
        this.addProperty("value", "");
        this.widget = this.addWidget("text","json","","value");
        this.widgets_up = true;
        this.size = [140, 30];
        this._value = null;
    }

    ConstantData.title = "Const Data";
    ConstantData.desc = "Constant Data";

    ConstantData.prototype.onPropertyChanged = function(name, value) {
        this.widget.value = value;
        if (value == null || value == "") {
            return;
        }

        try {
            this._value = JSON.parse(value);
            this.boxcolor = "#AEA";
        } catch (err) {
            this.boxcolor = "red";
        }
    };

    ConstantData.prototype.onExecute = function() {
        this.setOutputData(0, this._value);
    };

	ConstantData.prototype.setValue = ConstantNumber.prototype.setValue;

    LiteGraph.registerNodeType("basic/data", ConstantData);

	//to store json objects
    function ConstantArray() {
        this._value = [];
        this.addInput("", "");
        this.addOutput("", "array");
        this.addOutput("length", "number");
        this.addProperty("value", "[]");
        this.widget = this.addWidget("text","array",this.properties.value,"value");
        this.widgets_up = true;
        this.size = [140, 50];
    }

    ConstantArray.title = "Const Array";
    ConstantArray.desc = "Constant Array";

    ConstantArray.prototype.onPropertyChanged = function(name, value) {
        this.widget.value = value;
        if (value == null || value == "") {
            return;
        }

        try {
			if(value[0] != "[")
	            this._value = JSON.parse("[" + value + "]");
			else
	            this._value = JSON.parse(value);
            this.boxcolor = "#AEA";
        } catch (err) {
            this.boxcolor = "red";
        }
    };

    ConstantArray.prototype.onExecute = function() {
        var v = this.getInputData(0);
		if(v && v.length) //clone
		{
			if(!this._value)
				this._value = new Array();
			this._value.length = v.length;
			for(var i = 0; i < v.length; ++i)
				this._value[i] = v[i];
		}
		this.setOutputData(0, this._value );
		this.setOutputData(1, this._value ? ( this._value.length || 0) : 0 );
    };

	ConstantArray.prototype.setValue = ConstantNumber.prototype.setValue;

    LiteGraph.registerNodeType("basic/array", ConstantArray);

	function SetArray()
	{
        this.addInput("arr", "array");
        this.addInput("value", "");
        this.addOutput("arr", "array");
		this.properties = { index: 0 };
        this.widget = this.addWidget("number","i",this.properties.index,"index");
	}

    SetArray.title = "Set Array";
    SetArray.desc = "Sets index of array";

    SetArray.prototype.onExecute = function() {
        var arr = this.getInputData(0);
		if(!arr)
			return;
        var v = this.getInputData(1);
		if(v === undefined )
			return;
		if(this.properties.index)
			arr[ Math.floor(this.properties.index) ] = v;
		this.setOutputData(0,arr);
    };

    LiteGraph.registerNodeType("basic/set_array", SetArray );

    function ArrayElement() {
        this.addInput("array", "array,table,string");
        this.addInput("index", "number");
        this.addOutput("value", "");
		this.addProperty("index",0);
    }

    ArrayElement.title = "Array[i]";
    ArrayElement.desc = "Returns an element from an array";

    ArrayElement.prototype.onExecute = function() {
        var array = this.getInputData(0);
        var index = this.getInputData(1);
		if(index == null)
			index = this.properties.index;
		if(array == null || index == null )
			return;
        this.setOutputData(0, array[Math.floor(Number(index))] );
    };

    LiteGraph.registerNodeType("basic/array[]", ArrayElement);

    function TableElement() {
        this.addInput("table", "table");
        this.addInput("row", "number");
        this.addInput("col", "number");
        this.addOutput("value", "");
		this.addProperty("row",0);
		this.addProperty("column",0);
    }

    TableElement.title = "Table[row][col]";
    TableElement.desc = "Returns an element from a table";

    TableElement.prototype.onExecute = function() {
        var table = this.getInputData(0);
        var row = this.getInputData(1);
        var col = this.getInputData(2);
		if(row == null)
			row = this.properties.row;
		if(col == null)
			col = this.properties.column;
		if(table == null || row == null || col == null)
			return;
		var row = table[Math.floor(Number(row))];
		if(row)
	        this.setOutputData(0, row[Math.floor(Number(col))] );
		else
	        this.setOutputData(0, null );
    };

    LiteGraph.registerNodeType("basic/table[][]", TableElement);

    function ObjectProperty() {
        this.addInput("obj", "");
        this.addOutput("", "");
        this.addProperty("value", "");
        this.widget = this.addWidget("text","prop.","",this.setValue.bind(this) );
        this.widgets_up = true;
        this.size = [140, 30];
        this._value = null;
    }

    ObjectProperty.title = "Object property";
    ObjectProperty.desc = "Outputs the property of an object";

    ObjectProperty.prototype.setValue = function(v) {
        this.properties.value = v;
        this.widget.value = v;
    };

    ObjectProperty.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return "in." + this.properties.value;
        }
        return this.title;
    };

    ObjectProperty.prototype.onPropertyChanged = function(name, value) {
        this.widget.value = value;
    };

    ObjectProperty.prototype.onExecute = function() {
        var data = this.getInputData(0);
        if (data != null) {
            this.setOutputData(0, data[this.properties.value]);
        }
    };

    LiteGraph.registerNodeType("basic/object_property", ObjectProperty);

    function ObjectKeys() {
        this.addInput("obj", "");
        this.addOutput("keys", "array");
        this.size = [140, 30];
    }

    ObjectKeys.title = "Object keys";
    ObjectKeys.desc = "Outputs an array with the keys of an object";

    ObjectKeys.prototype.onExecute = function() {
        var data = this.getInputData(0);
        if (data != null) {
            this.setOutputData(0, Object.keys(data) );
        }
    };

    LiteGraph.registerNodeType("basic/object_keys", ObjectKeys);


	function SetObject()
	{
        this.addInput("obj", "");
        this.addInput("value", "");
        this.addOutput("obj", "");
		this.properties = { property: "" };
        this.name_widget = this.addWidget("text","prop.",this.properties.property,"property");
	}

    SetObject.title = "Set Object";
    SetObject.desc = "Adds propertiesrty to object";

    SetObject.prototype.onExecute = function() {
        var obj = this.getInputData(0);
		if(!obj)
			return;
        var v = this.getInputData(1);
		if(v === undefined )
			return;
		if(this.properties.property)
			obj[ this.properties.property ] = v;
		this.setOutputData(0,obj);
    };

    LiteGraph.registerNodeType("basic/set_object", SetObject );


    function MergeObjects() {
        this.addInput("A", "");
        this.addInput("B", "");
        this.addOutput("", "");
		this._result = {};
		var that = this;
		this.addWidget("button","clear","",function(){
			that._result = {};
		});
		this.size = this.computeSize();
    }

    MergeObjects.title = "Merge Objects";
    MergeObjects.desc = "Creates an object copying properties from others";

    MergeObjects.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
		var C = this._result;
		if(A)
			for(var i in A)
				C[i] = A[i];
		if(B)
			for(var i in B)
				C[i] = B[i];
		this.setOutputData(0,C);
    };

    LiteGraph.registerNodeType("basic/merge_objects", MergeObjects );

    //Store as variable
    function Variable() {
        this.size = [60, 30];
        this.addInput("in");
        this.addOutput("out");
		this.properties = { varname: "myname", container: Variable.LITEGRAPH };
        this.value = null;
    }

    Variable.title = "Variable";
    Variable.desc = "store/read variable value";

	Variable.LITEGRAPH = 0; //between all graphs
	Variable.GRAPH = 1;	//only inside this graph
	Variable.GLOBALSCOPE = 2;	//attached to Window

    Variable["@container"] = { type: "enum", values: {"litegraph":Variable.LITEGRAPH, "graph":Variable.GRAPH,"global": Variable.GLOBALSCOPE} };

    Variable.prototype.onExecute = function() {
		var container = this.getContainer();

		if(this.isInputConnected(0))
		{
			this.value = this.getInputData(0);
			container[ this.properties.varname ] = this.value;
			this.setOutputData(0, this.value );
			return;
		}

		this.setOutputData( 0, container[ this.properties.varname ] );
    };

	Variable.prototype.getContainer = function()
	{
		switch(this.properties.container)
		{
			case Variable.GRAPH:
				if(this.graph)
					return this.graph.vars;
				return {};
				break;
			case Variable.GLOBALSCOPE:
				return global;
				break;
			case Variable.LITEGRAPH:
			default:
				return LiteGraph.Globals;
				break;
		}
	}

    Variable.prototype.getTitle = function() {
        return this.properties.varname;
    };

    LiteGraph.registerNodeType("basic/variable", Variable);

    function length(v) {
        if(v && v.length != null)
			return Number(v.length);
		return 0;
    }

    LiteGraph.wrapFunctionAsNode(
        "basic/length",
        length,
        [""],
        "number"
    );

	function DownloadData() {
        this.size = [60, 30];
        this.addInput("data", 0 );
        this.addInput("download", LiteGraph.ACTION );
		this.properties = { filename: "data.json" };
        this.value = null;
		var that = this;
		this.addWidget("button","Download","", function(v){
			if(!that.value)
				return;
			that.downloadAsFile();
		});
    }

    DownloadData.title = "Download";
    DownloadData.desc = "Download some data";

	DownloadData.prototype.downloadAsFile = function()
	{
		if(this.value == null)
			return;

		var str = null;
		if(this.value.constructor === String)
			str = this.value;
		else
			str = JSON.stringify(this.value);

		var file = new Blob([str]);
		var url = URL.createObjectURL( file );
		var element = document.createElement("a");
		element.setAttribute('href', url);
		element.setAttribute('download', this.properties.filename );
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
		setTimeout( function(){ URL.revokeObjectURL( url ); }, 1000*60 ); //wait one minute to revoke url
	}

    DownloadData.prototype.onAction = function(action, param) {
		var that = this;
		setTimeout( function(){ that.downloadAsFile(); }, 100); //deferred to avoid blocking the renderer with the popup
	}

    DownloadData.prototype.onExecute = function() {
        if (this.inputs[0]) {
            this.value = this.getInputData(0);
        }
    };

    DownloadData.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.filename;
        }
        return this.title;
    };

    LiteGraph.registerNodeType("basic/download", DownloadData);



    //Watch a value in the editor
    function Watch() {
        this.size = [60, 30];
        this.addInput("value", 0, { label: "" });
        this.value = 0;
    }

    Watch.title = "Watch";
    Watch.desc = "Show value of input";

    Watch.prototype.onExecute = function() {
        if (this.inputs[0]) {
            this.value = this.getInputData(0);
        }
    };

    Watch.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.inputs[0].label;
        }
        return this.title;
    };

    Watch.toString = function(o) {
        if (o == null) {
            return "null";
        } else if (o.constructor === Number) {
            return o.toFixed(3);
        } else if (o.constructor === Array) {
            var str = "[";
            for (var i = 0; i < o.length; ++i) {
                str += Watch.toString(o[i]) + (i + 1 != o.length ? "," : "");
            }
            str += "]";
            return str;
        } else {
            return String(o);
        }
    };

    Watch.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.inputs[0].label = Watch.toString(this.value);
    };

    LiteGraph.registerNodeType("basic/watch", Watch);

    //in case one type doesnt match other type but you want to connect them anyway
    function Cast() {
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.size = [40, 30];
    }

    Cast.title = "Cast";
    Cast.desc = "Allows to connect different types";

    Cast.prototype.onExecute = function() {
        this.setOutputData(0, this.getInputData(0));
    };

    LiteGraph.registerNodeType("basic/cast", Cast);

    //Show value inside the debug console
    function Console() {
        this.mode = LiteGraph.ON_EVENT;
        this.size = [80, 30];
        this.addProperty("msg", "");
        this.addInput("log", LiteGraph.EVENT);
        this.addInput("msg", 0);
    }

    Console.title = "Console";
    Console.desc = "Show value inside the console";

    Console.prototype.onAction = function(action, param) {
        if (action == "log") {
            console.log(param);
        } else if (action == "warn") {
            console.warn(param);
        } else if (action == "error") {
            console.error(param);
        }
    };

    Console.prototype.onExecute = function() {
        var msg = this.getInputData(1);
        if (msg !== null) {
            this.properties.msg = msg;
        }
        console.log(msg);
    };

    Console.prototype.onGetInputs = function() {
        return [
            ["log", LiteGraph.ACTION],
            ["warn", LiteGraph.ACTION],
            ["error", LiteGraph.ACTION]
        ];
    };

    LiteGraph.registerNodeType("basic/console", Console);

    //Show value inside the debug console
    function Alert() {
        this.mode = LiteGraph.ON_EVENT;
        this.addProperty("msg", "");
        this.addInput("", LiteGraph.EVENT);
        var that = this;
        this.widget = this.addWidget("text", "Text", "", "msg");
        this.widgets_up = true;
        this.size = [200, 30];
    }

    Alert.title = "Alert";
    Alert.desc = "Show an alert window";
    Alert.color = "#510";

    Alert.prototype.onConfigure = function(o) {
        this.widget.value = o.properties.msg;
    };

    Alert.prototype.onAction = function(action, param) {
        var msg = this.properties.msg;
        setTimeout(function() {
            alert(msg);
        }, 10);
    };

    LiteGraph.registerNodeType("basic/alert", Alert);

    //Execites simple code
    function NodeScript() {
        this.size = [60, 30];
        this.addProperty("onExecute", "return A;");
        this.addInput("A", "");
        this.addInput("B", "");
        this.addOutput("out", "");

        this._func = null;
        this.data = {};
    }

    NodeScript.prototype.onConfigure = function(o) {
        if (o.properties.onExecute && LiteGraph.allow_scripts)
            this.compileCode(o.properties.onExecute);
		else
			console.warn("Script not compiled, LiteGraph.allow_scripts is false");
    };

    NodeScript.title = "Script";
    NodeScript.desc = "executes a code (max 100 characters)";

    NodeScript.widgets_info = {
        onExecute: { type: "code" }
    };

    NodeScript.prototype.onPropertyChanged = function(name, value) {
        if (name == "onExecute" && LiteGraph.allow_scripts)
            this.compileCode(value);
		else
			console.warn("Script not compiled, LiteGraph.allow_scripts is false");
    };

    NodeScript.prototype.compileCode = function(code) {
        this._func = null;
        if (code.length > 256) {
            console.warn("Script too long, max 256 chars");
        } else {
            var code_low = code.toLowerCase();
            var forbidden_words = [
                "script",
                "body",
                "document",
                "eval",
                "nodescript",
                "function"
            ]; //bad security solution
            for (var i = 0; i < forbidden_words.length; ++i) {
                if (code_low.indexOf(forbidden_words[i]) != -1) {
                    console.warn("invalid script");
                    return;
                }
            }
            try {
                this._func = new Function("A", "B", "C", "DATA", "node", code);
            } catch (err) {
                console.error("Error parsing script");
                console.error(err);
            }
        }
    };

    NodeScript.prototype.onExecute = function() {
        if (!this._func) {
            return;
        }

        try {
            var A = this.getInputData(0);
            var B = this.getInputData(1);
            var C = this.getInputData(2);
            this.setOutputData(0, this._func(A, B, C, this.data, this));
        } catch (err) {
            console.error("Error in script");
            console.error(err);
        }
    };

    NodeScript.prototype.onGetOutputs = function() {
        return [["C", ""]];
    };

    LiteGraph.registerNodeType("basic/script", NodeScript);
})(this);

//event related nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    //Show value inside the debug console
    function LogEvent() {
        this.size = [60, 30];
        this.addInput("event", LiteGraph.ACTION);
    }

    LogEvent.title = "Log Event";
    LogEvent.desc = "Log event in console";

    LogEvent.prototype.onAction = function(action, param) {
        console.log(action, param);
    };

    LiteGraph.registerNodeType("events/log", LogEvent);

    //convert to Event if the value is true
    function TriggerEvent() {
        this.size = [60, 30];
        this.addInput("if", "");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("change", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
		this.properties = { only_on_change: true };
		this.prev = 0;
    }

    TriggerEvent.title = "TriggerEvent";
    TriggerEvent.desc = "Triggers event if input evaluates to true";

    TriggerEvent.prototype.onExecute = function(action, param) {
		var v = this.getInputData(0);
		var changed = (v != this.prev);
		if(this.prev === 0)
			changed = false;
		var must_resend = (changed && this.properties.only_on_change) || (!changed && !this.properties.only_on_change);
		if(v && must_resend )
	        this.triggerSlot(0, param);
		if(!v && must_resend)
	        this.triggerSlot(2, param);
		if(changed)
	        this.triggerSlot(1, param);
		this.prev = v;
    };

    LiteGraph.registerNodeType("events/trigger", TriggerEvent);

    //Sequencer for events
    function Sequencer() {
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.size = [120, 30];
        this.flags = { horizontal: true, render_box: false };
    }

    Sequencer.title = "Sequencer";
    Sequencer.desc = "Trigger events when an event arrives";

    Sequencer.prototype.getTitle = function() {
        return "";
    };

    Sequencer.prototype.onAction = function(action, param) {
        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; ++i) {
                this.triggerSlot(i, param);
            }
        }
    };

    LiteGraph.registerNodeType("events/sequencer", Sequencer);

    //Filter events
    function FilterEvent() {
        this.size = [60, 30];
        this.addInput("event", LiteGraph.ACTION);
        this.addOutput("event", LiteGraph.EVENT);
        this.properties = {
            equal_to: "",
            has_property: "",
            property_equal_to: ""
        };
    }

    FilterEvent.title = "Filter Event";
    FilterEvent.desc = "Blocks events that do not match the filter";

    FilterEvent.prototype.onAction = function(action, param) {
        if (param == null) {
            return;
        }

        if (this.properties.equal_to && this.properties.equal_to != param) {
            return;
        }

        if (this.properties.has_property) {
            var prop = param[this.properties.has_property];
            if (prop == null) {
                return;
            }

            if (
                this.properties.property_equal_to &&
                this.properties.property_equal_to != prop
            ) {
                return;
            }
        }

        this.triggerSlot(0, param);
    };

    LiteGraph.registerNodeType("events/filter", FilterEvent);


    function EventBranch() {
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("cond", "boolean");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
        this.size = [120, 60];
		this._value = false;
    }

    EventBranch.title = "Branch";
    EventBranch.desc = "If condition is true, outputs triggers true, otherwise false";

    EventBranch.prototype.onExecute = function() {
		this._value = this.getInputData(1);
	}

    EventBranch.prototype.onAction = function(action, param) {
		this.triggerSlot(this._value ? 0 : 1);
	}

    LiteGraph.registerNodeType("events/branch", EventBranch);

    //Show value inside the debug console
    function EventCounter() {
        this.addInput("inc", LiteGraph.ACTION);
        this.addInput("dec", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("change", LiteGraph.EVENT);
        this.addOutput("num", "number");
        this.num = 0;
    }

    EventCounter.title = "Counter";
    EventCounter.desc = "Counts events";

    EventCounter.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return String(this.num);
        }
        return this.title;
    };

    EventCounter.prototype.onAction = function(action, param) {
        var v = this.num;
        if (action == "inc") {
            this.num += 1;
        } else if (action == "dec") {
            this.num -= 1;
        } else if (action == "reset") {
            this.num = 0;
        }
        if (this.num != v) {
            this.trigger("change", this.num);
        }
    };

    EventCounter.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        ctx.fillStyle = "#AAA";
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.num, this.size[0] * 0.5, this.size[1] * 0.5);
    };

    EventCounter.prototype.onExecute = function() {
        this.setOutputData(1, this.num);
    };

    LiteGraph.registerNodeType("events/counter", EventCounter);

    //Show value inside the debug console
    function DelayEvent() {
        this.size = [60, 30];
        this.addProperty("time_in_ms", 1000);
        this.addInput("event", LiteGraph.ACTION);
        this.addOutput("on_time", LiteGraph.EVENT);

        this._pending = [];
    }

    DelayEvent.title = "Delay";
    DelayEvent.desc = "Delays one event";

    DelayEvent.prototype.onAction = function(action, param) {
        var time = this.properties.time_in_ms;
        if (time <= 0) {
            this.trigger(null, param);
        } else {
            this._pending.push([time, param]);
        }
    };

    DelayEvent.prototype.onExecute = function() {
        var dt = this.graph.elapsed_time * 1000; //in ms

        if (this.isInputConnected(1)) {
            this.properties.time_in_ms = this.getInputData(1);
        }

        for (var i = 0; i < this._pending.length; ++i) {
            var action = this._pending[i];
            action[0] -= dt;
            if (action[0] > 0) {
                continue;
            }

            //remove
            this._pending.splice(i, 1);
            --i;

            //trigger
            this.trigger(null, action[1]);
        }
    };

    DelayEvent.prototype.onGetInputs = function() {
        return [["event", LiteGraph.ACTION], ["time_in_ms", "number"]];
    };

    LiteGraph.registerNodeType("events/delay", DelayEvent);

    //Show value inside the debug console
    function TimerEvent() {
        this.addProperty("interval", 1000);
        this.addProperty("event", "tick");
        this.addOutput("on_tick", LiteGraph.EVENT);
        this.time = 0;
        this.last_interval = 1000;
        this.triggered = false;
    }

    TimerEvent.title = "Timer";
    TimerEvent.desc = "Sends an event every N milliseconds";

    TimerEvent.prototype.onStart = function() {
        this.time = 0;
    };

    TimerEvent.prototype.getTitle = function() {
        return "Timer: " + this.last_interval.toString() + "ms";
    };

    TimerEvent.on_color = "#AAA";
    TimerEvent.off_color = "#222";

    TimerEvent.prototype.onDrawBackground = function() {
        this.boxcolor = this.triggered
            ? TimerEvent.on_color
            : TimerEvent.off_color;
        this.triggered = false;
    };

    TimerEvent.prototype.onExecute = function() {
        var dt = this.graph.elapsed_time * 1000; //in ms

        var trigger = this.time == 0;

        this.time += dt;
        this.last_interval = Math.max(
            1,
            this.getInputOrProperty("interval") | 0
        );

        if (
            !trigger &&
            (this.time < this.last_interval || isNaN(this.last_interval))
        ) {
            if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {
                this.setOutputData(1, false);
            }
            return;
        }

        this.triggered = true;
        this.time = this.time % this.last_interval;
        this.trigger("on_tick", this.properties.event);
        if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {
            this.setOutputData(1, true);
        }
    };

    TimerEvent.prototype.onGetInputs = function() {
        return [["interval", "number"]];
    };

    TimerEvent.prototype.onGetOutputs = function() {
        return [["tick", "boolean"]];
    };

    LiteGraph.registerNodeType("events/timer", TimerEvent);

    function DataStore() {
        this.addInput("data", "");
        this.addInput("assign", LiteGraph.ACTION);
        this.addOutput("data", "");
		this._last_value = null;
		this.properties = { data: null, serialize: true };
		var that = this;
		this.addWidget("button","store","",function(){
			that.properties.data = that._last_value;
		});
    }

    DataStore.title = "Data Store";
    DataStore.desc = "Stores data and only changes when event is received";

	DataStore.prototype.onExecute = function()
	{
		this._last_value = this.getInputData(0);
		this.setOutputData(0, this.properties.data );
	}

    DataStore.prototype.onAction = function(action, param) {
		this.properties.data = this._last_value;
    };

	DataStore.prototype.onSerialize = function(o)
	{
		if(o.data == null)
			return;
		if(this.properties.serialize == false || (o.data.constructor !== String && o.data.constructor !== Number && o.data.constructor !== Boolean && o.data.constructor !== Array && o.data.constructor !== Object ))
			o.data = null;
	}

    LiteGraph.registerNodeType("basic/data_store", DataStore);
})(this);

//widgets
(function(global) {
    var LiteGraph = global.LiteGraph;

    /* Button ****************/

    function WidgetButton() {
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", "boolean");
        this.addProperty("text", "click me");
        this.addProperty("font_size", 30);
        this.addProperty("message", "");
        this.size = [164, 84];
        this.clicked = false;
    }

    WidgetButton.title = "Button";
    WidgetButton.desc = "Triggers an event";

    WidgetButton.font = "Arial";
    WidgetButton.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        var margin = 10;
        ctx.fillStyle = "black";
        ctx.fillRect(
            margin + 1,
            margin + 1,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2
        );
        ctx.fillStyle = "#AAF";
        ctx.fillRect(
            margin - 1,
            margin - 1,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2
        );
        ctx.fillStyle = this.clicked
            ? "white"
            : this.mouseOver
            ? "#668"
            : "#334";
        ctx.fillRect(
            margin,
            margin,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2
        );

        if (this.properties.text || this.properties.text === 0) {
            var font_size = this.properties.font_size || 30;
            ctx.textAlign = "center";
            ctx.fillStyle = this.clicked ? "black" : "white";
            ctx.font = font_size + "px " + WidgetButton.font;
            ctx.fillText(
                this.properties.text,
                this.size[0] * 0.5,
                this.size[1] * 0.5 + font_size * 0.3
            );
            ctx.textAlign = "left";
        }
    };

    WidgetButton.prototype.onMouseDown = function(e, local_pos) {
        if (
            local_pos[0] > 1 &&
            local_pos[1] > 1 &&
            local_pos[0] < this.size[0] - 2 &&
            local_pos[1] < this.size[1] - 2
        ) {
            this.clicked = true;
            this.triggerSlot(0, this.properties.message);
            return true;
        }
    };

    WidgetButton.prototype.onExecute = function() {
        this.setOutputData(1, this.clicked);
    };

    WidgetButton.prototype.onMouseUp = function(e) {
        this.clicked = false;
    };

    LiteGraph.registerNodeType("widget/button", WidgetButton);

    function WidgetToggle() {
        this.addInput("", "boolean");
        this.addInput("e", LiteGraph.ACTION);
        this.addOutput("v", "boolean");
        this.addOutput("e", LiteGraph.EVENT);
        this.properties = { font: "", value: false };
        this.size = [160, 44];
    }

    WidgetToggle.title = "Toggle";
    WidgetToggle.desc = "Toggles between true or false";

    WidgetToggle.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size[1] * 0.5;
        var margin = 0.25;
        var h = this.size[1] * 0.8;
        ctx.font = this.properties.font || (size * 0.8).toFixed(0) + "px Arial";
        var w = ctx.measureText(this.title).width;
        var x = (this.size[0] - (w + size)) * 0.5;

        ctx.fillStyle = "#AAA";
        ctx.fillRect(x, h - size, size, size);

        ctx.fillStyle = this.properties.value ? "#AEF" : "#000";
        ctx.fillRect(
            x + size * margin,
            h - size + size * margin,
            size * (1 - margin * 2),
            size * (1 - margin * 2)
        );

        ctx.textAlign = "left";
        ctx.fillStyle = "#AAA";
        ctx.fillText(this.title, size * 1.2 + x, h * 0.85);
        ctx.textAlign = "left";
    };

    WidgetToggle.prototype.onAction = function(action) {
        this.properties.value = !this.properties.value;
        this.trigger("e", this.properties.value);
    };

    WidgetToggle.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v != null) {
            this.properties.value = v;
        }
        this.setOutputData(0, this.properties.value);
    };

    WidgetToggle.prototype.onMouseDown = function(e, local_pos) {
        if (
            local_pos[0] > 1 &&
            local_pos[1] > 1 &&
            local_pos[0] < this.size[0] - 2 &&
            local_pos[1] < this.size[1] - 2
        ) {
            this.properties.value = !this.properties.value;
            this.graph._version++;
            this.trigger("e", this.properties.value);
            return true;
        }
    };

    LiteGraph.registerNodeType("widget/toggle", WidgetToggle);

    /* Number ****************/

    function WidgetNumber() {
        this.addOutput("", "number");
        this.size = [80, 60];
        this.properties = { min: -1000, max: 1000, value: 1, step: 1 };
        this.old_y = -1;
        this._remainder = 0;
        this._precision = 0;
        this.mouse_captured = false;
    }

    WidgetNumber.title = "Number";
    WidgetNumber.desc = "Widget to select number value";

    WidgetNumber.pixels_threshold = 10;
    WidgetNumber.markers_color = "#666";

    WidgetNumber.prototype.onDrawForeground = function(ctx) {
        var x = this.size[0] * 0.5;
        var h = this.size[1];
        if (h > 30) {
            ctx.fillStyle = WidgetNumber.markers_color;
            ctx.beginPath();
            ctx.moveTo(x, h * 0.1);
            ctx.lineTo(x + h * 0.1, h * 0.2);
            ctx.lineTo(x + h * -0.1, h * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x, h * 0.9);
            ctx.lineTo(x + h * 0.1, h * 0.8);
            ctx.lineTo(x + h * -0.1, h * 0.8);
            ctx.fill();
            ctx.font = (h * 0.7).toFixed(1) + "px Arial";
        } else {
            ctx.font = (h * 0.8).toFixed(1) + "px Arial";
        }

        ctx.textAlign = "center";
        ctx.font = (h * 0.7).toFixed(1) + "px Arial";
        ctx.fillStyle = "#EEE";
        ctx.fillText(
            this.properties.value.toFixed(this._precision),
            x,
            h * 0.75
        );
    };

    WidgetNumber.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
    };

    WidgetNumber.prototype.onPropertyChanged = function(name, value) {
        var t = (this.properties.step + "").split(".");
        this._precision = t.length > 1 ? t[1].length : 0;
    };

    WidgetNumber.prototype.onMouseDown = function(e, pos) {
        if (pos[1] < 0) {
            return;
        }

        this.old_y = e.canvasY;
        this.captureInput(true);
        this.mouse_captured = true;

        return true;
    };

    WidgetNumber.prototype.onMouseMove = function(e) {
        if (!this.mouse_captured) {
            return;
        }

        var delta = this.old_y - e.canvasY;
        if (e.shiftKey) {
            delta *= 10;
        }
        if (e.metaKey || e.altKey) {
            delta *= 0.1;
        }
        this.old_y = e.canvasY;

        var steps = this._remainder + delta / WidgetNumber.pixels_threshold;
        this._remainder = steps % 1;
        steps = steps | 0;

        var v = Math.clamp(
            this.properties.value + steps * this.properties.step,
            this.properties.min,
            this.properties.max
        );
        this.properties.value = v;
        this.graph._version++;
        this.setDirtyCanvas(true);
    };

    WidgetNumber.prototype.onMouseUp = function(e, pos) {
        if (e.click_time < 200) {
            var steps = pos[1] > this.size[1] * 0.5 ? -1 : 1;
            this.properties.value = Math.clamp(
                this.properties.value + steps * this.properties.step,
                this.properties.min,
                this.properties.max
            );
            this.graph._version++;
            this.setDirtyCanvas(true);
        }

        if (this.mouse_captured) {
            this.mouse_captured = false;
            this.captureInput(false);
        }
    };

    LiteGraph.registerNodeType("widget/number", WidgetNumber);


    /* Combo ****************/

    function WidgetCombo() {
        this.addOutput("", "string");
        this.addOutput("change", LiteGraph.EVENT);
        this.size = [80, 60];
        this.properties = { value: "A", values:"A;B;C" };
        this.old_y = -1;
        this.mouse_captured = false;
		this._values = this.properties.values.split(";");
		var that = this;
        this.widgets_up = true;
		this.widget = this.addWidget("combo","", this.properties.value, function(v){
			that.properties.value = v;
            that.triggerSlot(1, v);
		}, { property: "value", values: this._values } );
    }

    WidgetCombo.title = "Combo";
    WidgetCombo.desc = "Widget to select from a list";

    WidgetCombo.prototype.onExecute = function() {
        this.setOutputData( 0, this.properties.value );
    };

    WidgetCombo.prototype.onPropertyChanged = function(name, value) {
		if(name == "values")
		{
			this._values = value.split(";");
			this.widget.options.values = this._values;
		}
		else if(name == "value")
		{
			this.widget.value = value;
		}
	};

    LiteGraph.registerNodeType("widget/combo", WidgetCombo);


    /* Knob ****************/

    function WidgetKnob() {
        this.addOutput("", "number");
        this.size = [64, 84];
        this.properties = {
            min: 0,
            max: 1,
            value: 0.5,
            color: "#7AF",
            precision: 2
        };
        this.value = -1;
    }

    WidgetKnob.title = "Knob";
    WidgetKnob.desc = "Circular controller";
    WidgetKnob.size = [80, 100];

    WidgetKnob.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (this.value == -1) {
            this.value =
                (this.properties.value - this.properties.min) /
                (this.properties.max - this.properties.min);
        }

        var center_x = this.size[0] * 0.5;
        var center_y = this.size[1] * 0.5;
        var radius = Math.min(this.size[0], this.size[1]) * 0.5 - 5;
        var w = Math.floor(radius * 0.05);

        ctx.globalAlpha = 1;
        ctx.save();
        ctx.translate(center_x, center_y);
        ctx.rotate(Math.PI * 0.75);

        //bg
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius, 0, Math.PI * 1.5);
        ctx.fill();

        //value
        ctx.strokeStyle = "black";
        ctx.fillStyle = this.properties.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(
            0,
            0,
            radius - 4,
            0,
            Math.PI * 1.5 * Math.max(0.01, this.value)
        );
        ctx.closePath();
        ctx.fill();
        //ctx.stroke();
        ctx.lineWidth = 1;
        ctx.globalAlpha = 1;
        ctx.restore();

        //inner
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(center_x, center_y, radius * 0.75, 0, Math.PI * 2, true);
        ctx.fill();

        //miniball
        ctx.fillStyle = this.mouseOver ? "white" : this.properties.color;
        ctx.beginPath();
        var angle = this.value * Math.PI * 1.5 + Math.PI * 0.75;
        ctx.arc(
            center_x + Math.cos(angle) * radius * 0.65,
            center_y + Math.sin(angle) * radius * 0.65,
            radius * 0.05,
            0,
            Math.PI * 2,
            true
        );
        ctx.fill();

        //text
        ctx.fillStyle = this.mouseOver ? "white" : "#AAA";
        ctx.font = Math.floor(radius * 0.5) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.value.toFixed(this.properties.precision),
            center_x,
            center_y + radius * 0.15
        );
    };

    WidgetKnob.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
        this.boxcolor = LiteGraph.colorToString([
            this.value,
            this.value,
            this.value
        ]);
    };

    WidgetKnob.prototype.onMouseDown = function(e) {
        this.center = [this.size[0] * 0.5, this.size[1] * 0.5 + 20];
        this.radius = this.size[0] * 0.5;
        if (
            e.canvasY - this.pos[1] < 20 ||
            LiteGraph.distance(
                [e.canvasX, e.canvasY],
                [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]
            ) > this.radius
        ) {
            return false;
        }
        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];
        this.captureInput(true);
        return true;
    };

    WidgetKnob.prototype.onMouseMove = function(e) {
        if (!this.oldmouse) {
            return;
        }

        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];

        var v = this.value;
        v -= (m[1] - this.oldmouse[1]) * 0.01;
        if (v > 1.0) {
            v = 1.0;
        } else if (v < 0.0) {
            v = 0.0;
        }
        this.value = v;
        this.properties.value =
            this.properties.min +
            (this.properties.max - this.properties.min) * this.value;
        this.oldmouse = m;
        this.setDirtyCanvas(true);
    };

    WidgetKnob.prototype.onMouseUp = function(e) {
        if (this.oldmouse) {
            this.oldmouse = null;
            this.captureInput(false);
        }
    };

    WidgetKnob.prototype.onPropertyChanged = function(name, value) {
        if (name == "min" || name == "max" || name == "value") {
            this.properties[name] = parseFloat(value);
            return true; //block
        }
    };

    LiteGraph.registerNodeType("widget/knob", WidgetKnob);

    //Show value inside the debug console
    function WidgetSliderGUI() {
        this.addOutput("", "number");
        this.properties = {
            value: 0.5,
            min: 0,
            max: 1,
            text: "V"
        };
        var that = this;
        this.size = [140, 40];
        this.slider = this.addWidget(
            "slider",
            "V",
            this.properties.value,
            function(v) {
                that.properties.value = v;
            },
            this.properties
        );
        this.widgets_up = true;
    }

    WidgetSliderGUI.title = "Inner Slider";

    WidgetSliderGUI.prototype.onPropertyChanged = function(name, value) {
        if (name == "value") {
            this.slider.value = value;
        }
    };

    WidgetSliderGUI.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
    };

    LiteGraph.registerNodeType("widget/internal_slider", WidgetSliderGUI);

    //Widget H SLIDER
    function WidgetHSlider() {
        this.size = [160, 26];
        this.addOutput("", "number");
        this.properties = { color: "#7AF", min: 0, max: 1, value: 0.5 };
        this.value = -1;
    }

    WidgetHSlider.title = "H.Slider";
    WidgetHSlider.desc = "Linear slider controller";

    WidgetHSlider.prototype.onDrawForeground = function(ctx) {
        if (this.value == -1) {
            this.value =
                (this.properties.value - this.properties.min) /
                (this.properties.max - this.properties.min);
        }

        //border
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.fillStyle = "#000";
        ctx.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4);

        ctx.fillStyle = this.properties.color;
        ctx.beginPath();
        ctx.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8);
        ctx.fill();
    };

    WidgetHSlider.prototype.onExecute = function() {
        this.properties.value =
            this.properties.min +
            (this.properties.max - this.properties.min) * this.value;
        this.setOutputData(0, this.properties.value);
        this.boxcolor = LiteGraph.colorToString([
            this.value,
            this.value,
            this.value
        ]);
    };

    WidgetHSlider.prototype.onMouseDown = function(e) {
        if (e.canvasY - this.pos[1] < 0) {
            return false;
        }

        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];
        this.captureInput(true);
        return true;
    };

    WidgetHSlider.prototype.onMouseMove = function(e) {
        if (!this.oldmouse) {
            return;
        }

        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];

        var v = this.value;
        var delta = m[0] - this.oldmouse[0];
        v += delta / this.size[0];
        if (v > 1.0) {
            v = 1.0;
        } else if (v < 0.0) {
            v = 0.0;
        }

        this.value = v;

        this.oldmouse = m;
        this.setDirtyCanvas(true);
    };

    WidgetHSlider.prototype.onMouseUp = function(e) {
        this.oldmouse = null;
        this.captureInput(false);
    };

    WidgetHSlider.prototype.onMouseLeave = function(e) {
        //this.oldmouse = null;
    };

    LiteGraph.registerNodeType("widget/hslider", WidgetHSlider);

    function WidgetProgress() {
        this.size = [160, 26];
        this.addInput("", "number");
        this.properties = { min: 0, max: 1, value: 0, color: "#AAF" };
    }

    WidgetProgress.title = "Progress";
    WidgetProgress.desc = "Shows data in linear progress";

    WidgetProgress.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v != undefined) {
            this.properties["value"] = v;
        }
    };

    WidgetProgress.prototype.onDrawForeground = function(ctx) {
        //border
        ctx.lineWidth = 1;
        ctx.fillStyle = this.properties.color;
        var v =
            (this.properties.value - this.properties.min) /
            (this.properties.max - this.properties.min);
        v = Math.min(1, v);
        v = Math.max(0, v);
        ctx.fillRect(2, 2, (this.size[0] - 4) * v, this.size[1] - 4);
    };

    LiteGraph.registerNodeType("widget/progress", WidgetProgress);

    function WidgetText() {
        this.addInputs("", 0);
        this.properties = {
            value: "...",
            font: "Arial",
            fontsize: 18,
            color: "#AAA",
            align: "left",
            glowSize: 0,
            decimals: 1
        };
    }

    WidgetText.title = "Text";
    WidgetText.desc = "Shows the input value";
    WidgetText.widgets = [
        { name: "resize", text: "Resize box", type: "button" },
        { name: "led_text", text: "LED", type: "minibutton" },
        { name: "normal_text", text: "Normal", type: "minibutton" }
    ];

    WidgetText.prototype.onDrawForeground = function(ctx) {
        //ctx.fillStyle="#000";
        //ctx.fillRect(0,0,100,60);
        ctx.fillStyle = this.properties["color"];
        var v = this.properties["value"];

        if (this.properties["glowSize"]) {
            ctx.shadowColor = this.properties.color;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = this.properties["glowSize"];
        } else {
            ctx.shadowColor = "transparent";
        }

        var fontsize = this.properties["fontsize"];

        ctx.textAlign = this.properties["align"];
        ctx.font = fontsize.toString() + "px " + this.properties["font"];
        this.str =
            typeof v == "number" ? v.toFixed(this.properties["decimals"]) : v;

        if (typeof this.str == "string") {
            var lines = this.str.split("\\n");
            for (var i=0; i < lines.length; i++) {
                ctx.fillText(
                    lines[i],
                    this.properties["align"] == "left" ? 15 : this.size[0] - 15,
                    fontsize * -0.15 + fontsize * (parseInt(i) + 1)
                );
            }
        }

        ctx.shadowColor = "transparent";
        this.last_ctx = ctx;
        ctx.textAlign = "left";
    };

    WidgetText.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v != null) {
            this.properties["value"] = v;
        }
        //this.setDirtyCanvas(true);
    };

    WidgetText.prototype.resize = function() {
        if (!this.last_ctx) {
            return;
        }

        var lines = this.str.split("\\n");
        this.last_ctx.font =
            this.properties["fontsize"] + "px " + this.properties["font"];
        var max = 0;
        for (var i=0; i < lines.length; i++) {
            var w = this.last_ctx.measureText(lines[i]).width;
            if (max < w) {
                max = w;
            }
        }
        this.size[0] = max + 20;
        this.size[1] = 4 + lines.length * this.properties["fontsize"];

        this.setDirtyCanvas(true);
    };

    WidgetText.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;
        this.str = typeof value == "number" ? value.toFixed(3) : value;
        //this.resize();
        return true;
    };

    LiteGraph.registerNodeType("widget/text", WidgetText);

    function WidgetPanel() {
        this.size = [200, 100];
        this.properties = {
            borderColor: "#ffffff",
            bgcolorTop: "#f0f0f0",
            bgcolorBottom: "#e0e0e0",
            shadowSize: 2,
            borderRadius: 3
        };
    }

    WidgetPanel.title = "Panel";
    WidgetPanel.desc = "Non interactive panel";
    WidgetPanel.widgets = [{ name: "update", text: "Update", type: "button" }];

    WidgetPanel.prototype.createGradient = function(ctx) {
        if (
            this.properties["bgcolorTop"] == "" ||
            this.properties["bgcolorBottom"] == ""
        ) {
            this.lineargradient = 0;
            return;
        }

        this.lineargradient = ctx.createLinearGradient(0, 0, 0, this.size[1]);
        this.lineargradient.addColorStop(0, this.properties["bgcolorTop"]);
        this.lineargradient.addColorStop(1, this.properties["bgcolorBottom"]);
    };

    WidgetPanel.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (this.lineargradient == null) {
            this.createGradient(ctx);
        }

        if (!this.lineargradient) {
            return;
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = this.properties["borderColor"];
        //ctx.fillStyle = "#ebebeb";
        ctx.fillStyle = this.lineargradient;

        if (this.properties["shadowSize"]) {
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = this.properties["shadowSize"];
        } else {
            ctx.shadowColor = "transparent";
        }

        ctx.roundRect(
            0,
            0,
            this.size[0] - 1,
            this.size[1] - 1,
            this.properties["shadowSize"]
        );
        ctx.fill();
        ctx.shadowColor = "transparent";
        ctx.stroke();
    };

    LiteGraph.registerNodeType("widget/panel", WidgetPanel);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    function GamepadInput() {
        this.addOutput("left_x_axis", "number");
        this.addOutput("left_y_axis", "number");
        this.addOutput("button_pressed", LiteGraph.EVENT);
        this.properties = { gamepad_index: 0, threshold: 0.1 };

        this._left_axis = new Float32Array(2);
        this._right_axis = new Float32Array(2);
        this._triggers = new Float32Array(2);
        this._previous_buttons = new Uint8Array(17);
        this._current_buttons = new Uint8Array(17);
    }

    GamepadInput.title = "Gamepad";
    GamepadInput.desc = "gets the input of the gamepad";

    GamepadInput.CENTER = 0;
    GamepadInput.LEFT = 1;
    GamepadInput.RIGHT = 2;
    GamepadInput.UP = 4;
    GamepadInput.DOWN = 8;

    GamepadInput.zero = new Float32Array(2);
    GamepadInput.buttons = [
        "a",
        "b",
        "x",
        "y",
        "lb",
        "rb",
        "lt",
        "rt",
        "back",
        "start",
        "ls",
        "rs",
        "home"
    ];

    GamepadInput.prototype.onExecute = function() {
        //get gamepad
        var gamepad = this.getGamepad();
        var threshold = this.properties.threshold || 0.0;

        if (gamepad) {
            this._left_axis[0] =
                Math.abs(gamepad.xbox.axes["lx"]) > threshold
                    ? gamepad.xbox.axes["lx"]
                    : 0;
            this._left_axis[1] =
                Math.abs(gamepad.xbox.axes["ly"]) > threshold
                    ? gamepad.xbox.axes["ly"]
                    : 0;
            this._right_axis[0] =
                Math.abs(gamepad.xbox.axes["rx"]) > threshold
                    ? gamepad.xbox.axes["rx"]
                    : 0;
            this._right_axis[1] =
                Math.abs(gamepad.xbox.axes["ry"]) > threshold
                    ? gamepad.xbox.axes["ry"]
                    : 0;
            this._triggers[0] =
                Math.abs(gamepad.xbox.axes["ltrigger"]) > threshold
                    ? gamepad.xbox.axes["ltrigger"]
                    : 0;
            this._triggers[1] =
                Math.abs(gamepad.xbox.axes["rtrigger"]) > threshold
                    ? gamepad.xbox.axes["rtrigger"]
                    : 0;
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                if (!output.links || !output.links.length) {
                    continue;
                }
                var v = null;

                if (gamepad) {
                    switch (output.name) {
                        case "left_axis":
                            v = this._left_axis;
                            break;
                        case "right_axis":
                            v = this._right_axis;
                            break;
                        case "left_x_axis":
                            v = this._left_axis[0];
                            break;
                        case "left_y_axis":
                            v = this._left_axis[1];
                            break;
                        case "right_x_axis":
                            v = this._right_axis[0];
                            break;
                        case "right_y_axis":
                            v = this._right_axis[1];
                            break;
                        case "trigger_left":
                            v = this._triggers[0];
                            break;
                        case "trigger_right":
                            v = this._triggers[1];
                            break;
                        case "a_button":
                            v = gamepad.xbox.buttons["a"] ? 1 : 0;
                            break;
                        case "b_button":
                            v = gamepad.xbox.buttons["b"] ? 1 : 0;
                            break;
                        case "x_button":
                            v = gamepad.xbox.buttons["x"] ? 1 : 0;
                            break;
                        case "y_button":
                            v = gamepad.xbox.buttons["y"] ? 1 : 0;
                            break;
                        case "lb_button":
                            v = gamepad.xbox.buttons["lb"] ? 1 : 0;
                            break;
                        case "rb_button":
                            v = gamepad.xbox.buttons["rb"] ? 1 : 0;
                            break;
                        case "ls_button":
                            v = gamepad.xbox.buttons["ls"] ? 1 : 0;
                            break;
                        case "rs_button":
                            v = gamepad.xbox.buttons["rs"] ? 1 : 0;
                            break;
                        case "hat_left":
                            v = gamepad.xbox.hatmap & GamepadInput.LEFT;
                            break;
                        case "hat_right":
                            v = gamepad.xbox.hatmap & GamepadInput.RIGHT;
                            break;
                        case "hat_up":
                            v = gamepad.xbox.hatmap & GamepadInput.UP;
                            break;
                        case "hat_down":
                            v = gamepad.xbox.hatmap & GamepadInput.DOWN;
                            break;
                        case "hat":
                            v = gamepad.xbox.hatmap;
                            break;
                        case "start_button":
                            v = gamepad.xbox.buttons["start"] ? 1 : 0;
                            break;
                        case "back_button":
                            v = gamepad.xbox.buttons["back"] ? 1 : 0;
                            break;
                        case "button_pressed":
                            for (
                                var j = 0;
                                j < this._current_buttons.length;
                                ++j
                            ) {
                                if (
                                    this._current_buttons[j] &&
                                    !this._previous_buttons[j]
                                ) {
                                    this.triggerSlot(
                                        i,
                                        GamepadInput.buttons[j]
                                    );
                                }
                            }
                            break;
                        default:
                            break;
                    }
                } else {
                    //if no gamepad is connected, output 0
                    switch (output.name) {
                        case "button_pressed":
                            break;
                        case "left_axis":
                        case "right_axis":
                            v = GamepadInput.zero;
                            break;
                        default:
                            v = 0;
                    }
                }
                this.setOutputData(i, v);
            }
        }
    };

	GamepadInput.mapping = {a:0,b:1,x:2,y:3,lb:4,rb:5,lt:6,rt:7,back:8,start:9,ls:10,rs:11 };
	GamepadInput.mapping_array = ["a","b","x","y","lb","rb","lt","rt","back","start","ls","rs"];

    GamepadInput.prototype.getGamepad = function() {
        var getGamepads =
            navigator.getGamepads ||
            navigator.webkitGetGamepads ||
            navigator.mozGetGamepads;
        if (!getGamepads) {
            return null;
        }
        var gamepads = getGamepads.call(navigator);
        var gamepad = null;

        this._previous_buttons.set(this._current_buttons);

        //pick the first connected
        for (var i = this.properties.gamepad_index; i < 4; i++) {
            if (!gamepads[i]) {
                continue;
            }
            gamepad = gamepads[i];

            //xbox controller mapping
            var xbox = this.xbox_mapping;
            if (!xbox) {
                xbox = this.xbox_mapping = {
                    axes: [],
                    buttons: {},
                    hat: "",
                    hatmap: GamepadInput.CENTER
                };
            }

            xbox.axes["lx"] = gamepad.axes[0];
            xbox.axes["ly"] = gamepad.axes[1];
            xbox.axes["rx"] = gamepad.axes[2];
            xbox.axes["ry"] = gamepad.axes[3];
            xbox.axes["ltrigger"] = gamepad.buttons[6].value;
            xbox.axes["rtrigger"] = gamepad.buttons[7].value;
            xbox.hat = "";
            xbox.hatmap = GamepadInput.CENTER;

            for (var j = 0; j < gamepad.buttons.length; j++) {
                this._current_buttons[j] = gamepad.buttons[j].pressed;

				if(j < 12)
				{
					xbox.buttons[ GamepadInput.mapping_array[j] ] = gamepad.buttons[j].pressed;
					if(gamepad.buttons[j].was_pressed)
						this.trigger( GamepadInput.mapping_array[j] + "_button_event" );
				}
				else //mapping of XBOX
					switch ( j ) //I use a switch to ensure that a player with another gamepad could play
					{
						case 12:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "up";
								xbox.hatmap |= GamepadInput.UP;
							}
							break;
						case 13:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "down";
								xbox.hatmap |= GamepadInput.DOWN;
							}
							break;
						case 14:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "left";
								xbox.hatmap |= GamepadInput.LEFT;
							}
							break;
						case 15:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "right";
								xbox.hatmap |= GamepadInput.RIGHT;
							}
							break;
						case 16:
							xbox.buttons["home"] = gamepad.buttons[j].pressed;
							break;
						default:
					}
            }
            gamepad.xbox = xbox;
            return gamepad;
        }
    };

    GamepadInput.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        //render gamepad state?
        var la = this._left_axis;
        var ra = this._right_axis;
        ctx.strokeStyle = "#88A";
        ctx.strokeRect(
            (la[0] + 1) * 0.5 * this.size[0] - 4,
            (la[1] + 1) * 0.5 * this.size[1] - 4,
            8,
            8
        );
        ctx.strokeStyle = "#8A8";
        ctx.strokeRect(
            (ra[0] + 1) * 0.5 * this.size[0] - 4,
            (ra[1] + 1) * 0.5 * this.size[1] - 4,
            8,
            8
        );
        var h = this.size[1] / this._current_buttons.length;
        ctx.fillStyle = "#AEB";
        for (var i = 0; i < this._current_buttons.length; ++i) {
            if (this._current_buttons[i]) {
                ctx.fillRect(0, h * i, 6, h);
            }
        }
    };

    GamepadInput.prototype.onGetOutputs = function() {
        return [
            ["left_axis", "vec2"],
            ["right_axis", "vec2"],
            ["left_x_axis", "number"],
            ["left_y_axis", "number"],
            ["right_x_axis", "number"],
            ["right_y_axis", "number"],
            ["trigger_left", "number"],
            ["trigger_right", "number"],
            ["a_button", "number"],
            ["b_button", "number"],
            ["x_button", "number"],
            ["y_button", "number"],
            ["lb_button", "number"],
            ["rb_button", "number"],
            ["ls_button", "number"],
            ["rs_button", "number"],
            ["start_button", "number"],
            ["back_button", "number"],
            ["a_button_event", LiteGraph.EVENT ],
            ["b_button_event", LiteGraph.EVENT ],
            ["x_button_event", LiteGraph.EVENT ],
            ["y_button_event", LiteGraph.EVENT ],
            ["lb_button_event", LiteGraph.EVENT ],
            ["rb_button_event", LiteGraph.EVENT ],
            ["ls_button_event", LiteGraph.EVENT ],
            ["rs_button_event", LiteGraph.EVENT ],
            ["start_button_event", LiteGraph.EVENT ],
            ["back_button_event", LiteGraph.EVENT ],
            ["hat_left", "number"],
            ["hat_right", "number"],
            ["hat_up", "number"],
            ["hat_down", "number"],
            ["hat", "number"],
            ["button_pressed", LiteGraph.EVENT]
        ];
    };

    LiteGraph.registerNodeType("input/gamepad", GamepadInput);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    //Converter
    function Converter() {
        this.addInput("in", "");
	this.addOutput("out");
        this.size = [80, 30];
    }

    Converter.title = "Converter";
    Converter.desc = "type A to type B";

    Converter.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                if (!output.links || !output.links.length) {
                    continue;
                }

                var result = null;
                switch (output.name) {
                    case "number":
                        result = v.length ? v[0] : parseFloat(v);
                        break;
                    case "vec2":
                    case "vec3":
                    case "vec4":
                        var result = null;
                        var count = 1;
                        switch (output.name) {
                            case "vec2":
                                count = 2;
                                break;
                            case "vec3":
                                count = 3;
                                break;
                            case "vec4":
                                count = 4;
                                break;
                        }

                        var result = new Float32Array(count);
                        if (v.length) {
                            for (
                                var j = 0;
                                j < v.length && j < result.length;
                                j++
                            ) {
                                result[j] = v[j];
                            }
                        } else {
                            result[0] = parseFloat(v);
                        }
                        break;
                }
                this.setOutputData(i, result);
            }
        }
    };

    Converter.prototype.onGetOutputs = function() {
        return [
            ["number", "number"],
            ["vec2", "vec2"],
            ["vec3", "vec3"],
            ["vec4", "vec4"]
        ];
    };

    LiteGraph.registerNodeType("math/converter", Converter);

    //Bypass
    function Bypass() {
        this.addInput("in");
        this.addOutput("out");
        this.size = [80, 30];
    }

    Bypass.title = "Bypass";
    Bypass.desc = "removes the type";

    Bypass.prototype.onExecute = function() {
        var v = this.getInputData(0);
        this.setOutputData(0, v);
    };

    LiteGraph.registerNodeType("math/bypass", Bypass);

    function ToNumber() {
        this.addInput("in");
        this.addOutput("out");
    }

    ToNumber.title = "to Number";
    ToNumber.desc = "Cast to number";

    ToNumber.prototype.onExecute = function() {
        var v = this.getInputData(0);
        this.setOutputData(0, Number(v));
    };

    LiteGraph.registerNodeType("math/to_number", ToNumber);

    function MathRange() {
        this.addInput("in", "number", { locked: true });
        this.addOutput("out", "number", { locked: true });
        this.addOutput("clamped", "number", { locked: true });

        this.addProperty("in", 0);
        this.addProperty("in_min", 0);
        this.addProperty("in_max", 1);
        this.addProperty("out_min", 0);
        this.addProperty("out_max", 1);

        this.size = [120, 50];
    }

    MathRange.title = "Range";
    MathRange.desc = "Convert a number from one range to another";

    MathRange.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return (this._last_v || 0).toFixed(2);
        }
        return this.title;
    };

    MathRange.prototype.onExecute = function() {
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                this.properties[input.name] = v;
            }
        }

        var v = this.properties["in"];
        if (v === undefined || v === null || v.constructor !== Number) {
            v = 0;
        }

        var in_min = this.properties.in_min;
        var in_max = this.properties.in_max;
        var out_min = this.properties.out_min;
        var out_max = this.properties.out_max;
		/*
		if( in_min > in_max )
		{
			in_min = in_max;
			in_max = this.properties.in_min;
		}
		if( out_min > out_max )
		{
			out_min = out_max;
			out_max = this.properties.out_min;
		}
		*/

        this._last_v = ((v - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;
        this.setOutputData(0, this._last_v);
        this.setOutputData(1, Math.clamp( this._last_v, out_min, out_max ));
    };

    MathRange.prototype.onDrawBackground = function(ctx) {
        //show the current value
        if (this._last_v) {
            this.outputs[0].label = this._last_v.toFixed(3);
        } else {
            this.outputs[0].label = "?";
        }
    };

    MathRange.prototype.onGetInputs = function() {
        return [
            ["in_min", "number"],
            ["in_max", "number"],
            ["out_min", "number"],
            ["out_max", "number"]
        ];
    };

    LiteGraph.registerNodeType("math/range", MathRange);

    function MathRand() {
        this.addOutput("value", "number");
        this.addProperty("min", 0);
        this.addProperty("max", 1);
        this.size = [80, 30];
    }

    MathRand.title = "Rand";
    MathRand.desc = "Random number";

    MathRand.prototype.onExecute = function() {
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                this.properties[input.name] = v;
            }
        }

        var min = this.properties.min;
        var max = this.properties.max;
        this._last_v = Math.random() * (max - min) + min;
        this.setOutputData(0, this._last_v);
    };

    MathRand.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.outputs[0].label = (this._last_v || 0).toFixed(3);
    };

    MathRand.prototype.onGetInputs = function() {
        return [["min", "number"], ["max", "number"]];
    };

    LiteGraph.registerNodeType("math/rand", MathRand);

    //basic continuous noise
    function MathNoise() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.addProperty("min", 0);
        this.addProperty("max", 1);
        this.addProperty("smooth", true);
        this.addProperty("seed", 0);
        this.addProperty("octaves", 1);
        this.addProperty("persistence", 0.8);
        this.addProperty("speed", 1);
        this.size = [90, 30];
    }

    MathNoise.title = "Noise";
    MathNoise.desc = "Random number with temporal continuity";
    MathNoise.data = null;

    MathNoise.getValue = function(f, smooth) {
        if (!MathNoise.data) {
            MathNoise.data = new Float32Array(1024);
            for (var i = 0; i < MathNoise.data.length; ++i) {
                MathNoise.data[i] = Math.random();
            }
        }
        f = f % 1024;
        if (f < 0) {
            f += 1024;
        }
        var f_min = Math.floor(f);
        var f = f - f_min;
        var r1 = MathNoise.data[f_min];
        var r2 = MathNoise.data[f_min == 1023 ? 0 : f_min + 1];
        if (smooth) {
            f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        }
        return r1 * (1 - f) + r2 * f;
    };

    MathNoise.prototype.onExecute = function() {
        var f = this.getInputData(0) || 0;
		var iterations = this.properties.octaves || 1;
		var r = 0;
		var amp = 1;
		var seed = this.properties.seed || 0;
		f += seed;
		var speed = this.properties.speed || 1;
		var total_amp = 0;
		for(var i = 0; i < iterations; ++i)
		{
			r += MathNoise.getValue(f * (1+i) * speed, this.properties.smooth) * amp;
			total_amp += amp;
			amp *= this.properties.persistence;
			if(amp < 0.001)
				break;
		}
		r /= total_amp;
        var min = this.properties.min;
        var max = this.properties.max;
        this._last_v = r * (max - min) + min;
        this.setOutputData(0, this._last_v);
    };

    MathNoise.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.outputs[0].label = (this._last_v || 0).toFixed(3);
    };

    LiteGraph.registerNodeType("math/noise", MathNoise);

    //generates spikes every random time
    function MathSpikes() {
        this.addOutput("out", "number");
        this.addProperty("min_time", 1);
        this.addProperty("max_time", 2);
        this.addProperty("duration", 0.2);
        this.size = [90, 30];
        this._remaining_time = 0;
        this._blink_time = 0;
    }

    MathSpikes.title = "Spikes";
    MathSpikes.desc = "spike every random time";

    MathSpikes.prototype.onExecute = function() {
        var dt = this.graph.elapsed_time; //in secs

        this._remaining_time -= dt;
        this._blink_time -= dt;

        var v = 0;
        if (this._blink_time > 0) {
            var f = this._blink_time / this.properties.duration;
            v = 1 / (Math.pow(f * 8 - 4, 4) + 1);
        }

        if (this._remaining_time < 0) {
            this._remaining_time =
                Math.random() *
                    (this.properties.max_time - this.properties.min_time) +
                this.properties.min_time;
            this._blink_time = this.properties.duration;
            this.boxcolor = "#FFF";
        } else {
            this.boxcolor = "#000";
        }
        this.setOutputData(0, v);
    };

    LiteGraph.registerNodeType("math/spikes", MathSpikes);

    //Math clamp
    function MathClamp() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.addProperty("min", 0);
        this.addProperty("max", 1);
    }

    MathClamp.title = "Clamp";
    MathClamp.desc = "Clamp number between min and max";
    //MathClamp.filter = "shader";

    MathClamp.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        v = Math.max(this.properties.min, v);
        v = Math.min(this.properties.max, v);
        this.setOutputData(0, v);
    };

    MathClamp.prototype.getCode = function(lang) {
        var code = "";
        if (this.isInputConnected(0)) {
            code +=
                "clamp({{0}}," +
                this.properties.min +
                "," +
                this.properties.max +
                ")";
        }
        return code;
    };

    LiteGraph.registerNodeType("math/clamp", MathClamp);

    //Math ABS
    function MathLerp() {
        this.properties = { f: 0.5 };
        this.addInput("A", "number");
        this.addInput("B", "number");

        this.addOutput("out", "number");
    }

    MathLerp.title = "Lerp";
    MathLerp.desc = "Linear Interpolation";

    MathLerp.prototype.onExecute = function() {
        var v1 = this.getInputData(0);
        if (v1 == null) {
            v1 = 0;
        }
        var v2 = this.getInputData(1);
        if (v2 == null) {
            v2 = 0;
        }

        var f = this.properties.f;

        var _f = this.getInputData(2);
        if (_f !== undefined) {
            f = _f;
        }

        this.setOutputData(0, v1 * (1 - f) + v2 * f);
    };

    MathLerp.prototype.onGetInputs = function() {
        return [["f", "number"]];
    };

    LiteGraph.registerNodeType("math/lerp", MathLerp);

    //Math ABS
    function MathAbs() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    MathAbs.title = "Abs";
    MathAbs.desc = "Absolute";

    MathAbs.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, Math.abs(v));
    };

    LiteGraph.registerNodeType("math/abs", MathAbs);

    //Math Floor
    function MathFloor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    MathFloor.title = "Floor";
    MathFloor.desc = "Floor number to remove fractional part";

    MathFloor.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, Math.floor(v));
    };

    LiteGraph.registerNodeType("math/floor", MathFloor);

    //Math frac
    function MathFrac() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    MathFrac.title = "Frac";
    MathFrac.desc = "Returns fractional part";

    MathFrac.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, v % 1);
    };

    LiteGraph.registerNodeType("math/frac", MathFrac);

    //Math Floor
    function MathSmoothStep() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.properties = { A: 0, B: 1 };
    }

    MathSmoothStep.title = "Smoothstep";
    MathSmoothStep.desc = "Smoothstep";

    MathSmoothStep.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v === undefined) {
            return;
        }

        var edge0 = this.properties.A;
        var edge1 = this.properties.B;

        // Scale, bias and saturate x to 0..1 range
        v = Math.clamp((v - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        v = v * v * (3 - 2 * v);

        this.setOutputData(0, v);
    };

    LiteGraph.registerNodeType("math/smoothstep", MathSmoothStep);

    //Math scale
    function MathScale() {
        this.addInput("in", "number", { label: "" });
        this.addOutput("out", "number", { label: "" });
        this.size = [80, 30];
        this.addProperty("factor", 1);
    }

    MathScale.title = "Scale";
    MathScale.desc = "v * factor";

    MathScale.prototype.onExecute = function() {
        var value = this.getInputData(0);
        if (value != null) {
            this.setOutputData(0, value * this.properties.factor);
        }
    };

    LiteGraph.registerNodeType("math/scale", MathScale);

	//Gate
	function Gate() {
		this.addInput("v","boolean");
		this.addInput("A");
		this.addInput("B");
		this.addOutput("out");
	}

	Gate.title = "Gate";
	Gate.desc = "if v is true, then outputs A, otherwise B";

	Gate.prototype.onExecute = function() {
		var v = this.getInputData(0);
		this.setOutputData(0, this.getInputData( v ? 1 : 2 ));
	};

	LiteGraph.registerNodeType("math/gate", Gate);


    //Math Average
    function MathAverageFilter() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.addProperty("samples", 10);
        this._values = new Float32Array(10);
        this._current = 0;
    }

    MathAverageFilter.title = "Average";
    MathAverageFilter.desc = "Average Filter";

    MathAverageFilter.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }

        var num_samples = this._values.length;

        this._values[this._current % num_samples] = v;
        this._current += 1;
        if (this._current > num_samples) {
            this._current = 0;
        }

        var avr = 0;
        for (var i = 0; i < num_samples; ++i) {
            avr += this._values[i];
        }

        this.setOutputData(0, avr / num_samples);
    };

    MathAverageFilter.prototype.onPropertyChanged = function(name, value) {
        if (value < 1) {
            value = 1;
        }
        this.properties.samples = Math.round(value);
        var old = this._values;

        this._values = new Float32Array(this.properties.samples);
        if (old.length <= this._values.length) {
            this._values.set(old);
        } else {
            this._values.set(old.subarray(0, this._values.length));
        }
    };

    LiteGraph.registerNodeType("math/average", MathAverageFilter);

    //Math
    function MathTendTo() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.addProperty("factor", 0.1);
        this.size = [80, 30];
        this._value = null;
    }

    MathTendTo.title = "TendTo";
    MathTendTo.desc = "moves the output value always closer to the input";

    MathTendTo.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }
        var f = this.properties.factor;
        if (this._value == null) {
            this._value = v;
        } else {
            this._value = this._value * (1 - f) + v * f;
        }
        this.setOutputData(0, this._value);
    };

    LiteGraph.registerNodeType("math/tendTo", MathTendTo);

    //Math operation
    function MathOperation() {
        this.addInput("A", "number,array,object");
        this.addInput("B", "number");
        this.addOutput("=", "number");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", "+", "enum", { values: MathOperation.values });
		this._func = function(A,B) { return A + B; };
		this._result = []; //only used for arrays
    }

    MathOperation.values = ["+", "-", "*", "/", "%", "^", "max", "min"];

	MathOperation.title = "Operation";
    MathOperation.desc = "Easy math operators";
    MathOperation["@OP"] = {
        type: "enum",
        title: "operation",
        values: MathOperation.values
    };
    MathOperation.size = [100, 60];

    MathOperation.prototype.getTitle = function() {
		if(this.properties.OP == "max" || this.properties.OP == "min")
			return this.properties.OP + "(A,B)";
        return "A " + this.properties.OP + " B";
    };

    MathOperation.prototype.setValue = function(v) {
        if (typeof v == "string") {
            v = parseFloat(v);
        }
        this.properties["value"] = v;
    };

    MathOperation.prototype.onPropertyChanged = function(name, value)
	{
		if (name != "OP")
			return;
        switch (this.properties.OP) {
            case "+": this._func = function(A,B) { return A + B; }; break;
            case "-": this._func = function(A,B) { return A - B; }; break;
            case "x":
            case "X":
            case "*": this._func = function(A,B) { return A * B; }; break;
            case "/": this._func = function(A,B) { return A / B; }; break;
            case "%": this._func = function(A,B) { return A % B; }; break;
            case "^": this._func = function(A,B) { return Math.pow(A, B); }; break;
            case "max": this._func = function(A,B) { return Math.max(A, B); }; break;
            case "min": this._func = function(A,B) { return Math.min(A, B); }; break;
			default: 
				console.warn("Unknown operation: " + this.properties.OP);
				this._func = function(A) { return A; };
				break;
        }
	}

    MathOperation.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        if ( A != null ) {
			if( A.constructor === Number )
	            this.properties["A"] = A;
        } else {
            A = this.properties["A"];
        }

        if (B != null) {
            this.properties["B"] = B;
        } else {
            B = this.properties["B"];
        }

		var result;
		if(A.constructor === Number)
		{
	        result = 0;
			result = this._func(A,B);
		}
		else if(A.constructor === Array)
		{
			result = this._result;
			result.length = A.length;
			for(var i = 0; i < A.length; ++i)
				result[i] = this._func(A[i],B);
		}
		else
		{
			result = {};
			for(var i in A)
				result[i] = this._func(A[i],B);
		}
	    this.setOutputData(0, result);
    };

    MathOperation.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.font = "40px Arial";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.OP,
            this.size[0] * 0.5,
            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5
        );
        ctx.textAlign = "left";
    };

    LiteGraph.registerNodeType("math/operation", MathOperation);

    LiteGraph.registerSearchboxExtra("math/operation", "MAX", {
        properties: {OP:"max"},
        title: "MAX()"
    });

    LiteGraph.registerSearchboxExtra("math/operation", "MIN", {
        properties: {OP:"min"},
        title: "MIN()"
    });


    //Math compare
    function MathCompare() {
        this.addInput("A", "number");
        this.addInput("B", "number");
        this.addOutput("A==B", "boolean");
        this.addOutput("A!=B", "boolean");
        this.addProperty("A", 0);
        this.addProperty("B", 0);
    }

    MathCompare.title = "Compare";
    MathCompare.desc = "compares between two values";

    MathCompare.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        if (A !== undefined) {
            this.properties["A"] = A;
        } else {
            A = this.properties["A"];
        }

        if (B !== undefined) {
            this.properties["B"] = B;
        } else {
            B = this.properties["B"];
        }

        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            var output = this.outputs[i];
            if (!output.links || !output.links.length) {
                continue;
            }
            var value;
            switch (output.name) {
                case "A==B":
                    value = A == B;
                    break;
                case "A!=B":
                    value = A != B;
                    break;
                case "A>B":
                    value = A > B;
                    break;
                case "A<B":
                    value = A < B;
                    break;
                case "A<=B":
                    value = A <= B;
                    break;
                case "A>=B":
                    value = A >= B;
                    break;
            }
            this.setOutputData(i, value);
        }
    };

    MathCompare.prototype.onGetOutputs = function() {
        return [
            ["A==B", "boolean"],
            ["A!=B", "boolean"],
            ["A>B", "boolean"],
            ["A<B", "boolean"],
            ["A>=B", "boolean"],
            ["A<=B", "boolean"]
        ];
    };

    LiteGraph.registerNodeType("math/compare", MathCompare);

    LiteGraph.registerSearchboxExtra("math/compare", "==", {
        outputs: [["A==B", "boolean"]],
        title: "A==B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", "!=", {
        outputs: [["A!=B", "boolean"]],
        title: "A!=B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", ">", {
        outputs: [["A>B", "boolean"]],
        title: "A>B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", "<", {
        outputs: [["A<B", "boolean"]],
        title: "A<B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", ">=", {
        outputs: [["A>=B", "boolean"]],
        title: "A>=B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", "<=", {
        outputs: [["A<=B", "boolean"]],
        title: "A<=B"
    });

    function MathCondition() {
        this.addInput("A", "number");
        this.addInput("B", "number");
        this.addOutput("true", "boolean");
        this.addOutput("false", "boolean");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", ">", "enum", { values: MathCondition.values });
		this.addWidget("combo","Cond.",this.properties.OP,{ property: "OP", values: MathCondition.values } );

        this.size = [80, 60];
    }

    MathCondition.values = [">", "<", "==", "!=", "<=", ">=", "||", "&&" ];
    MathCondition["@OP"] = {
        type: "enum",
        title: "operation",
        values: MathCondition.values
    };

    MathCondition.title = "Condition";
    MathCondition.desc = "evaluates condition between A and B";

    MathCondition.prototype.getTitle = function() {
        return "A " + this.properties.OP + " B";
    };

    MathCondition.prototype.onExecute = function() {
        var A = this.getInputData(0);
        if (A === undefined) {
            A = this.properties.A;
        } else {
            this.properties.A = A;
        }

        var B = this.getInputData(1);
        if (B === undefined) {
            B = this.properties.B;
        } else {
            this.properties.B = B;
        }

        var result = true;
        switch (this.properties.OP) {
            case ">":
                result = A > B;
                break;
            case "<":
                result = A < B;
                break;
            case "==":
                result = A == B;
                break;
            case "!=":
                result = A != B;
                break;
            case "<=":
                result = A <= B;
                break;
            case ">=":
                result = A >= B;
                break;
            case "||":
                result = A || B;
                break;
            case "&&":
                result = A && B;
                break;
        }

        this.setOutputData(0, result);
        this.setOutputData(1, !result);
    };

    LiteGraph.registerNodeType("math/condition", MathCondition);


    function MathBranch() {
        this.addInput("in", "");
        this.addInput("cond", "boolean");
        this.addOutput("true", "");
        this.addOutput("false", "");
        this.size = [80, 60];
    }

    MathBranch.title = "Branch";
    MathBranch.desc = "If condition is true, outputs IN in true, otherwise in false";

    MathBranch.prototype.onExecute = function() {
        var V = this.getInputData(0);
        var cond = this.getInputData(1);

		if(cond)
		{
			this.setOutputData(0, V);
			this.setOutputData(1, null);
		}
		else
		{
			this.setOutputData(0, null);
			this.setOutputData(1, V);
		}
	}

    LiteGraph.registerNodeType("math/branch", MathBranch);


    function MathAccumulate() {
        this.addInput("inc", "number");
        this.addOutput("total", "number");
        this.addProperty("increment", 1);
        this.addProperty("value", 0);
    }

    MathAccumulate.title = "Accumulate";
    MathAccumulate.desc = "Increments a value every time";

    MathAccumulate.prototype.onExecute = function() {
        if (this.properties.value === null) {
            this.properties.value = 0;
        }

        var inc = this.getInputData(0);
        if (inc !== null) {
            this.properties.value += inc;
        } else {
            this.properties.value += this.properties.increment;
        }
        this.setOutputData(0, this.properties.value);
    };

    LiteGraph.registerNodeType("math/accumulate", MathAccumulate);

    //Math Trigonometry
    function MathTrigonometry() {
        this.addInput("v", "number");
        this.addOutput("sin", "number");

        this.addProperty("amplitude", 1);
        this.addProperty("offset", 0);
        this.bgImageUrl = "nodes/imgs/icon-sin.png";
    }

    MathTrigonometry.title = "Trigonometry";
    MathTrigonometry.desc = "Sin Cos Tan";
    //MathTrigonometry.filter = "shader";

    MathTrigonometry.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }
        var amplitude = this.properties["amplitude"];
        var slot = this.findInputSlot("amplitude");
        if (slot != -1) {
            amplitude = this.getInputData(slot);
        }
        var offset = this.properties["offset"];
        slot = this.findInputSlot("offset");
        if (slot != -1) {
            offset = this.getInputData(slot);
        }

        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            var output = this.outputs[i];
            var value;
            switch (output.name) {
                case "sin":
                    value = Math.sin(v);
                    break;
                case "cos":
                    value = Math.cos(v);
                    break;
                case "tan":
                    value = Math.tan(v);
                    break;
                case "asin":
                    value = Math.asin(v);
                    break;
                case "acos":
                    value = Math.acos(v);
                    break;
                case "atan":
                    value = Math.atan(v);
                    break;
            }
            this.setOutputData(i, amplitude * value + offset);
        }
    };

    MathTrigonometry.prototype.onGetInputs = function() {
        return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];
    };

    MathTrigonometry.prototype.onGetOutputs = function() {
        return [
            ["sin", "number"],
            ["cos", "number"],
            ["tan", "number"],
            ["asin", "number"],
            ["acos", "number"],
            ["atan", "number"]
        ];
    };

    LiteGraph.registerNodeType("math/trigonometry", MathTrigonometry);

    LiteGraph.registerSearchboxExtra("math/trigonometry", "SIN()", {
        outputs: [["sin", "number"]],
        title: "SIN()"
    });
    LiteGraph.registerSearchboxExtra("math/trigonometry", "COS()", {
        outputs: [["cos", "number"]],
        title: "COS()"
    });
    LiteGraph.registerSearchboxExtra("math/trigonometry", "TAN()", {
        outputs: [["tan", "number"]],
        title: "TAN()"
    });

    //math library for safe math operations without eval
    function MathFormula() {
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.addOutput("", "number");
        this.properties = { x: 1.0, y: 1.0, formula: "x+y" };
        this.code_widget = this.addWidget(
            "text",
            "F(x,y)",
            this.properties.formula,
            function(v, canvas, node) {
                node.properties.formula = v;
            }
        );
        this.addWidget("toggle", "allow", LiteGraph.allow_scripts, function(v) {
            LiteGraph.allow_scripts = v;
        });
        this._func = null;
    }

    MathFormula.title = "Formula";
    MathFormula.desc = "Compute formula";
    MathFormula.size = [160, 100];

    MathAverageFilter.prototype.onPropertyChanged = function(name, value) {
        if (name == "formula") {
            this.code_widget.value = value;
        }
    };

    MathFormula.prototype.onExecute = function() {
        if (!LiteGraph.allow_scripts) {
            return;
        }

        var x = this.getInputData(0);
        var y = this.getInputData(1);
        if (x != null) {
            this.properties["x"] = x;
        } else {
            x = this.properties["x"];
        }

        if (y != null) {
            this.properties["y"] = y;
        } else {
            y = this.properties["y"];
        }

        var f = this.properties["formula"];

        var value;
        try {
            if (!this._func || this._func_code != this.properties.formula) {
                this._func = new Function(
                    "x",
                    "y",
                    "TIME",
                    "return " + this.properties.formula
                );
                this._func_code = this.properties.formula;
            }
            value = this._func(x, y, this.graph.globaltime);
            this.boxcolor = null;
        } catch (err) {
            this.boxcolor = "red";
        }
        this.setOutputData(0, value);
    };

    MathFormula.prototype.getTitle = function() {
        return this._func_code || "Formula";
    };

    MathFormula.prototype.onDrawBackground = function() {
        var f = this.properties["formula"];
        if (this.outputs && this.outputs.length) {
            this.outputs[0].label = f;
        }
    };

    LiteGraph.registerNodeType("math/formula", MathFormula);

    function Math3DVec2ToXY() {
        this.addInput("vec2", "vec2");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
    }

    Math3DVec2ToXY.title = "Vec2->XY";
    Math3DVec2ToXY.desc = "vector 2 to components";

    Math3DVec2ToXY.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
    };

    LiteGraph.registerNodeType("math3d/vec2-to-xy", Math3DVec2ToXY);

    function Math3DXYToVec2() {
        this.addInputs([["x", "number"], ["y", "number"]]);
        this.addOutput("vec2", "vec2");
        this.properties = { x: 0, y: 0 };
        this._data = new Float32Array(2);
    }

    Math3DXYToVec2.title = "XY->Vec2";
    Math3DXYToVec2.desc = "components to vector2";

    Math3DXYToVec2.prototype.onExecute = function() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/xy-to-vec2", Math3DXYToVec2);

    function Math3DVec3ToXYZ() {
        this.addInput("vec3", "vec3");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
        this.addOutput("z", "number");
    }

    Math3DVec3ToXYZ.title = "Vec3->XYZ";
    Math3DVec3ToXYZ.desc = "vector 3 to components";

    Math3DVec3ToXYZ.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
        this.setOutputData(2, v[2]);
    };

    LiteGraph.registerNodeType("math3d/vec3-to-xyz", Math3DVec3ToXYZ);

    function Math3DXYZToVec3() {
        this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);
        this.addOutput("vec3", "vec3");
        this.properties = { x: 0, y: 0, z: 0 };
        this._data = new Float32Array(3);
    }

    Math3DXYZToVec3.title = "XYZ->Vec3";
    Math3DXYZToVec3.desc = "components to vector3";

    Math3DXYZToVec3.prototype.onExecute = function() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }
        var z = this.getInputData(2);
        if (z == null) {
            z = this.properties.z;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;
        data[2] = z;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/xyz-to-vec3", Math3DXYZToVec3);

    function Math3DVec4ToXYZW() {
        this.addInput("vec4", "vec4");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
        this.addOutput("z", "number");
        this.addOutput("w", "number");
    }

    Math3DVec4ToXYZW.title = "Vec4->XYZW";
    Math3DVec4ToXYZW.desc = "vector 4 to components";

    Math3DVec4ToXYZW.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
        this.setOutputData(2, v[2]);
        this.setOutputData(3, v[3]);
    };

    LiteGraph.registerNodeType("math3d/vec4-to-xyzw", Math3DVec4ToXYZW);

    function Math3DXYZWToVec4() {
        this.addInputs([
            ["x", "number"],
            ["y", "number"],
            ["z", "number"],
            ["w", "number"]
        ]);
        this.addOutput("vec4", "vec4");
        this.properties = { x: 0, y: 0, z: 0, w: 0 };
        this._data = new Float32Array(4);
    }

    Math3DXYZWToVec4.title = "XYZW->Vec4";
    Math3DXYZWToVec4.desc = "components to vector4";

    Math3DXYZWToVec4.prototype.onExecute = function() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }
        var z = this.getInputData(2);
        if (z == null) {
            z = this.properties.z;
        }
        var w = this.getInputData(3);
        if (w == null) {
            w = this.properties.w;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;
        data[2] = z;
        data[3] = w;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/xyzw-to-vec4", Math3DXYZWToVec4);

})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;


	function Math3DMat4()
	{
        this.addInput("T", "vec3");
        this.addInput("R", "vec3");
        this.addInput("S", "vec3");
        this.addOutput("mat4", "mat4");
		this.properties = {
			"T":[0,0,0],
			"R":[0,0,0],
			"S":[1,1,1],
			R_in_degrees: true
		};
		this._result = mat4.create();
		this._must_update = true;
	}

	Math3DMat4.title = "mat4";
	Math3DMat4.temp_quat = new Float32Array([0,0,0,1]);
	Math3DMat4.temp_mat4 = new Float32Array(16);
	Math3DMat4.temp_vec3 = new Float32Array(3);

	Math3DMat4.prototype.onPropertyChanged = function(name, value)
	{
		this._must_update = true;
	}

	Math3DMat4.prototype.onExecute = function()
	{
		var M = this._result;
		var Q = Math3DMat4.temp_quat;
		var temp_mat4 = Math3DMat4.temp_mat4;
		var temp_vec3 = Math3DMat4.temp_vec3;

		var T = this.getInputData(0);
		var R = this.getInputData(1);
		var S = this.getInputData(2);

		if( this._must_update || T || R || S )
		{
			T = T || this.properties.T;
			R = R || this.properties.R;
			S = S || this.properties.S;
			mat4.identity( M );
			mat4.translate( M, M, T );
			if(this.properties.R_in_degrees)
			{
				temp_vec3.set( R );
				vec3.scale(temp_vec3,temp_vec3,DEG2RAD);
				quat.fromEuler( Q, temp_vec3 );
			}
			else
				quat.fromEuler( Q, R );
			mat4.fromQuat( temp_mat4, Q );
			mat4.multiply( M, M, temp_mat4 );
			mat4.scale( M, M, S );
		}

		this.setOutputData(0, M);		
	}

    LiteGraph.registerNodeType("math3d/mat4", Math3DMat4);

    //Math 3D operation
    function Math3DOperation() {
        this.addInput("A", "number,vec3");
        this.addInput("B", "number,vec3");
        this.addOutput("=", "number,vec3");
        this.addProperty("OP", "+", "enum", { values: Math3DOperation.values });
		this._result = vec3.create();
    }

    Math3DOperation.values = ["+", "-", "*", "/", "%", "^", "max", "min","dot","cross"];

    LiteGraph.registerSearchboxExtra("math3d/operation", "CROSS()", {
        properties: {"OP":"cross"},
        title: "CROSS()"
    });

    LiteGraph.registerSearchboxExtra("math3d/operation", "DOT()", {
        properties: {"OP":"dot"},
        title: "DOT()"
    });

	Math3DOperation.title = "Operation";
    Math3DOperation.desc = "Easy math 3D operators";
    Math3DOperation["@OP"] = {
        type: "enum",
        title: "operation",
        values: Math3DOperation.values
    };
    Math3DOperation.size = [100, 60];

    Math3DOperation.prototype.getTitle = function() {
		if(this.properties.OP == "max" || this.properties.OP == "min" )
			return this.properties.OP + "(A,B)";
        return "A " + this.properties.OP + " B";
    };

    Math3DOperation.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
		if(A == null || B == null)
			return;
		if(A.constructor === Number)
			A = [A,A,A];
		if(B.constructor === Number)
			B = [B,B,B];

        var result = this._result;
        switch (this.properties.OP) {
            case "+":
                result = vec3.add(result,A,B);
                break;
            case "-":
                result = vec3.sub(result,A,B);
                break;
            case "x":
            case "X":
            case "*":
                result = vec3.mul(result,A,B);
                break;
            case "/":
                result = vec3.div(result,A,B);
                break;
            case "%":
                result[0] = A[0]%B[0];
                result[1] = A[1]%B[1];
                result[2] = A[2]%B[2];
                break;
            case "^":
                result[0] = Math.pow(A[0],B[0]);
                result[1] = Math.pow(A[1],B[1]);
                result[2] = Math.pow(A[2],B[2]);
                break;
            case "max":
                result[0] = Math.max(A[0],B[0]);
                result[1] = Math.max(A[1],B[1]);
                result[2] = Math.max(A[2],B[2]);
                break;
            case "min":
                result[0] = Math.min(A[0],B[0]);
                result[1] = Math.min(A[1],B[1]);
                result[2] = Math.min(A[2],B[2]);
            case "dot":
                result = vec3.dot(A,B);
                break;
            case "cross":
                vec3.cross(result,A,B);
                break;
            default:
                console.warn("Unknown operation: " + this.properties.OP);
        }
        this.setOutputData(0, result);
    };

    Math3DOperation.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.font = "40px Arial";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.OP,
            this.size[0] * 0.5,
            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5
        );
        ctx.textAlign = "left";
    };

    LiteGraph.registerNodeType("math3d/operation", Math3DOperation);

    function Math3DVec3Scale() {
        this.addInput("in", "vec3");
        this.addInput("f", "number");
        this.addOutput("out", "vec3");
        this.properties = { f: 1 };
        this._data = new Float32Array(3);
    }

    Math3DVec3Scale.title = "vec3_scale";
    Math3DVec3Scale.desc = "scales the components of a vec3";

    Math3DVec3Scale.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var f = this.getInputData(1);
        if (f == null) {
            f = this.properties.f;
        }

        var data = this._data;
        data[0] = v[0] * f;
        data[1] = v[1] * f;
        data[2] = v[2] * f;
        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/vec3-scale", Math3DVec3Scale);

    function Math3DVec3Length() {
        this.addInput("in", "vec3");
        this.addOutput("out", "number");
    }

    Math3DVec3Length.title = "vec3_length";
    Math3DVec3Length.desc = "returns the module of a vector";

    Math3DVec3Length.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        this.setOutputData(0, dist);
    };

    LiteGraph.registerNodeType("math3d/vec3-length", Math3DVec3Length);

    function Math3DVec3Normalize() {
        this.addInput("in", "vec3");
        this.addOutput("out", "vec3");
        this._data = new Float32Array(3);
    }

    Math3DVec3Normalize.title = "vec3_normalize";
    Math3DVec3Normalize.desc = "returns the vector normalized";

    Math3DVec3Normalize.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        var data = this._data;
        data[0] = v[0] / dist;
        data[1] = v[1] / dist;
        data[2] = v[2] / dist;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/vec3-normalize", Math3DVec3Normalize);

    function Math3DVec3Lerp() {
        this.addInput("A", "vec3");
        this.addInput("B", "vec3");
        this.addInput("f", "vec3");
        this.addOutput("out", "vec3");
        this.properties = { f: 0.5 };
        this._data = new Float32Array(3);
    }

    Math3DVec3Lerp.title = "vec3_lerp";
    Math3DVec3Lerp.desc = "returns the interpolated vector";

    Math3DVec3Lerp.prototype.onExecute = function() {
        var A = this.getInputData(0);
        if (A == null) {
            return;
        }
        var B = this.getInputData(1);
        if (B == null) {
            return;
        }
        var f = this.getInputOrProperty("f");

        var data = this._data;
        data[0] = A[0] * (1 - f) + B[0] * f;
        data[1] = A[1] * (1 - f) + B[1] * f;
        data[2] = A[2] * (1 - f) + B[2] * f;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/vec3-lerp", Math3DVec3Lerp);

    function Math3DVec3Dot() {
        this.addInput("A", "vec3");
        this.addInput("B", "vec3");
        this.addOutput("out", "number");
    }

    Math3DVec3Dot.title = "vec3_dot";
    Math3DVec3Dot.desc = "returns the dot product";

    Math3DVec3Dot.prototype.onExecute = function() {
        var A = this.getInputData(0);
        if (A == null) {
            return;
        }
        var B = this.getInputData(1);
        if (B == null) {
            return;
        }

        var dot = A[0] * B[0] + A[1] * B[1] + A[2] * B[2];
        this.setOutputData(0, dot);
    };

    LiteGraph.registerNodeType("math3d/vec3-dot", Math3DVec3Dot);

    //if glMatrix is installed...
    if (global.glMatrix) {
        function Math3DQuaternion() {
            this.addOutput("quat", "quat");
            this.properties = { x: 0, y: 0, z: 0, w: 1, normalize: false };
            this._value = quat.create();
        }

        Math3DQuaternion.title = "Quaternion";
        Math3DQuaternion.desc = "quaternion";

        Math3DQuaternion.prototype.onExecute = function() {
            this._value[0] = this.getInputOrProperty("x");
            this._value[1] = this.getInputOrProperty("y");
            this._value[2] = this.getInputOrProperty("z");
            this._value[3] = this.getInputOrProperty("w");
            if (this.properties.normalize) {
                quat.normalize(this._value, this._value);
            }
            this.setOutputData(0, this._value);
        };

        Math3DQuaternion.prototype.onGetInputs = function() {
            return [
                ["x", "number"],
                ["y", "number"],
                ["z", "number"],
                ["w", "number"]
            ];
        };

        LiteGraph.registerNodeType("math3d/quaternion", Math3DQuaternion);

        function Math3DRotation() {
            this.addInputs([["degrees", "number"], ["axis", "vec3"]]);
            this.addOutput("quat", "quat");
            this.properties = { angle: 90.0, axis: vec3.fromValues(0, 1, 0) };

            this._value = quat.create();
        }

        Math3DRotation.title = "Rotation";
        Math3DRotation.desc = "quaternion rotation";

        Math3DRotation.prototype.onExecute = function() {
            var angle = this.getInputData(0);
            if (angle == null) {
                angle = this.properties.angle;
            }
            var axis = this.getInputData(1);
            if (axis == null) {
                axis = this.properties.axis;
            }

            var R = quat.setAxisAngle(this._value, axis, angle * 0.0174532925);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/rotation", Math3DRotation);


        function MathEulerToQuat() {
            this.addInput("euler", "vec3");
            this.addOutput("quat", "quat");
            this.properties = { euler:[0,0,0], use_yaw_pitch_roll: false };
			this._degs = vec3.create();
            this._value = quat.create();
        }

        MathEulerToQuat.title = "Euler->Quat";
        MathEulerToQuat.desc = "Converts euler angles (in degrees) to quaternion";

        MathEulerToQuat.prototype.onExecute = function() {
            var euler = this.getInputData(0);
            if (euler == null) {
                euler = this.properties.euler;
            }
			vec3.scale( this._degs, euler, DEG2RAD );
			if(this.properties.use_yaw_pitch_roll)
				this._degs = [this._degs[2],this._degs[0],this._degs[1]];
            var R = quat.fromEuler(this._value, this._degs);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/euler_to_quat", MathEulerToQuat);

        function MathQuatToEuler() {
            this.addInput(["quat", "quat"]);
            this.addOutput("euler", "vec3");
			this._value = vec3.create();
        }

        MathQuatToEuler.title = "Euler->Quat";
        MathQuatToEuler.desc = "Converts rotX,rotY,rotZ in degrees to quat";

        MathQuatToEuler.prototype.onExecute = function() {
            var q = this.getInputData(0);
			if(!q)
				return;
            var R = quat.toEuler(this._value, q);
			vec3.scale( this._value, this._value, DEG2RAD );
            this.setOutputData(0, this._value);
        };

        LiteGraph.registerNodeType("math3d/quat_to_euler", MathQuatToEuler);


        //Math3D rotate vec3
        function Math3DRotateVec3() {
            this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);
            this.addOutput("result", "vec3");
            this.properties = { vec: [0, 0, 1] };
        }

        Math3DRotateVec3.title = "Rot. Vec3";
        Math3DRotateVec3.desc = "rotate a point";

        Math3DRotateVec3.prototype.onExecute = function() {
            var vec = this.getInputData(0);
            if (vec == null) {
                vec = this.properties.vec;
            }
            var quat = this.getInputData(1);
            if (quat == null) {
                this.setOutputData(vec);
            } else {
                this.setOutputData(
                    0,
                    vec3.transformQuat(vec3.create(), vec, quat)
                );
            }
        };

        LiteGraph.registerNodeType("math3d/rotate_vec3", Math3DRotateVec3);

        function Math3DMultQuat() {
            this.addInputs([["A", "quat"], ["B", "quat"]]);
            this.addOutput("A*B", "quat");

            this._value = quat.create();
        }

        Math3DMultQuat.title = "Mult. Quat";
        Math3DMultQuat.desc = "rotate quaternion";

        Math3DMultQuat.prototype.onExecute = function() {
            var A = this.getInputData(0);
            if (A == null) {
                return;
            }
            var B = this.getInputData(1);
            if (B == null) {
                return;
            }

            var R = quat.multiply(this._value, A, B);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/mult-quat", Math3DMultQuat);

        function Math3DQuatSlerp() {
            this.addInputs([
                ["A", "quat"],
                ["B", "quat"],
                ["factor", "number"]
            ]);
            this.addOutput("slerp", "quat");
            this.addProperty("factor", 0.5);

            this._value = quat.create();
        }

        Math3DQuatSlerp.title = "Quat Slerp";
        Math3DQuatSlerp.desc = "quaternion spherical interpolation";

        Math3DQuatSlerp.prototype.onExecute = function() {
            var A = this.getInputData(0);
            if (A == null) {
                return;
            }
            var B = this.getInputData(1);
            if (B == null) {
                return;
            }
            var factor = this.properties.factor;
            if (this.getInputData(2) != null) {
                factor = this.getInputData(2);
            }

            var R = quat.slerp(this._value, A, B, factor);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/quat-slerp", Math3DQuatSlerp);


        //Math3D rotate vec3
        function Math3DRemapRange() {
            this.addInput("vec3", "vec3");
            this.addOutput("remap", "vec3");
			this.addOutput("clamped", "vec3");
            this.properties = { clamp: true, range_min: [-1, -1, 0], range_max: [1, 1, 0], target_min: [-1,-1,0], target_max:[1,1,0] };
			this._value = vec3.create();
			this._clamped = vec3.create();
        }

        Math3DRemapRange.title = "Remap Range";
        Math3DRemapRange.desc = "remap a 3D range";

        Math3DRemapRange.prototype.onExecute = function() {
            var vec = this.getInputData(0);
			if(vec)
				this._value.set(vec);
			var range_min = this.properties.range_min;
			var range_max = this.properties.range_max;
			var target_min = this.properties.target_min;
			var target_max = this.properties.target_max;

			//swap to avoid errors
			/*
			if(range_min > range_max)
			{
				range_min = range_max;
				range_max = this.properties.range_min;
			}

			if(target_min > target_max)
			{
				target_min = target_max;
				target_max = this.properties.target_min;
			}
			*/

			for(var i = 0; i < 3; ++i)
			{
				var r = range_max[i] - range_min[i];
				this._clamped[i] = Math.clamp( this._value[i], range_min[i], range_max[i] );
				if(r == 0)
				{
					this._value[i] = (target_min[i] + target_max[i]) * 0.5;
					continue;
				}

				var n = (this._value[i] - range_min[i]) / r;
				if(this.properties.clamp)
					n = Math.clamp(n,0,1);
				var t = target_max[i] - target_min[i];
				this._value[i] = target_min[i] + n * t;
			}

			this.setOutputData(0,this._value);
			this.setOutputData(1,this._clamped);
        };

        LiteGraph.registerNodeType("math3d/remap_range", Math3DRemapRange);



    } //glMatrix
	else
		console.warn("No glmatrix found, some Math3D nodes may not work");

})(this);

//basic nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    function toString(a) {
		if(a && a.constructor === Object)
		{
			try
			{
				return JSON.stringify(a);
			}
			catch (err)
			{
				return String(a);
			}
		}
        return String(a);
    }

    LiteGraph.wrapFunctionAsNode("string/toString", toString, [""], "String");

    function compare(a, b) {
        return a == b;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/compare",
        compare,
        ["string", "string"],
        "boolean"
    );

    function concatenate(a, b) {
        if (a === undefined) {
            return b;
        }
        if (b === undefined) {
            return a;
        }
        return a + b;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/concatenate",
        concatenate,
        ["string", "string"],
        "string"
    );

    function contains(a, b) {
        if (a === undefined || b === undefined) {
            return false;
        }
        return a.indexOf(b) != -1;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/contains",
        contains,
        ["string", "string"],
        "boolean"
    );

    function toUpperCase(a) {
        if (a != null && a.constructor === String) {
            return a.toUpperCase();
        }
        return a;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/toUpperCase",
        toUpperCase,
        ["string"],
        "string"
    );

    function split(str, separator) {
		if(separator == null)
			separator = this.properties.separator;
        if (str == null )
	        return [];
		if( str.constructor === String )
			return str.split(separator || " ");
		else if( str.constructor === Array )
		{
			var r = [];
			for(var i = 0; i < str.length; ++i)
				r[i] = str[i].split(separator || " ");
			return r;
		}
        return null;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/split",
        split,
        ["string,array", "string"],
        "array",
		{ separator: "," }
    );

    function toFixed(a) {
        if (a != null && a.constructor === Number) {
            return a.toFixed(this.properties.precision);
        }
        return a;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/toFixed",
        toFixed,
        ["number"],
        "string",
        { precision: 0 }
    );


    function StringToTable() {
        this.addInput("", "string");
        this.addOutput("table", "table");
        this.addOutput("rows", "number");
        this.addProperty("value", "");
        this.addProperty("separator", ",");
		this._table = null;
    }

    StringToTable.title = "toTable";
    StringToTable.desc = "Splits a string to table";

    StringToTable.prototype.onExecute = function() {
        var input = this.getInputData(0);
		if(!input)
			return;
		var separator = this.properties.separator || ",";
		if(input != this._str || separator != this._last_separator )
		{
			this._last_separator = separator;
			this._str = input;
			this._table = input.split("\n").map(function(a){ return a.trim().split(separator)});
		}
        this.setOutputData(0, this._table );
        this.setOutputData(1, this._table ? this._table.length : 0 );
    };

    LiteGraph.registerNodeType("string/toTable", StringToTable);

})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    function Selector() {
        this.addInput("sel", "number");
        this.addInput("A");
        this.addInput("B");
        this.addInput("C");
        this.addInput("D");
        this.addOutput("out");

        this.selected = 0;
    }

    Selector.title = "Selector";
    Selector.desc = "selects an output";

    Selector.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        ctx.fillStyle = "#AFB";
        var y = (this.selected + 1) * LiteGraph.NODE_SLOT_HEIGHT + 6;
        ctx.beginPath();
        ctx.moveTo(50, y);
        ctx.lineTo(50, y + LiteGraph.NODE_SLOT_HEIGHT);
        ctx.lineTo(34, y + LiteGraph.NODE_SLOT_HEIGHT * 0.5);
        ctx.fill();
    };

    Selector.prototype.onExecute = function() {
        var sel = this.getInputData(0);
        if (sel == null || sel.constructor !== Number)
            sel = 0;
        this.selected = sel = Math.round(sel) % (this.inputs.length - 1);
        var v = this.getInputData(sel + 1);
        if (v !== undefined) {
            this.setOutputData(0, v);
        }
    };

    Selector.prototype.onGetInputs = function() {
        return [["E", 0], ["F", 0], ["G", 0], ["H", 0]];
    };

    LiteGraph.registerNodeType("logic/selector", Selector);

    function Sequence() {
        this.properties = {
            sequence: "A,B,C"
        };
        this.addInput("index", "number");
        this.addInput("seq");
        this.addOutput("out");

        this.index = 0;
        this.values = this.properties.sequence.split(",");
    }

    Sequence.title = "Sequence";
    Sequence.desc = "select one element from a sequence from a string";

    Sequence.prototype.onPropertyChanged = function(name, value) {
        if (name == "sequence") {
            this.values = value.split(",");
        }
    };

    Sequence.prototype.onExecute = function() {
        var seq = this.getInputData(1);
        if (seq && seq != this.current_sequence) {
            this.values = seq.split(",");
            this.current_sequence = seq;
        }
        var index = this.getInputData(0);
        if (index == null) {
            index = 0;
        }
        this.index = index = Math.round(index) % this.values.length;

        this.setOutputData(0, this.values[index]);
    };

    LiteGraph.registerNodeType("logic/sequence", Sequence);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    function GraphicsPlot() {
        this.addInput("A", "Number");
        this.addInput("B", "Number");
        this.addInput("C", "Number");
        this.addInput("D", "Number");

        this.values = [[], [], [], []];
        this.properties = { scale: 2 };
    }

    GraphicsPlot.title = "Plot";
    GraphicsPlot.desc = "Plots data over time";
    GraphicsPlot.colors = ["#FFF", "#F99", "#9F9", "#99F"];

    GraphicsPlot.prototype.onExecute = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size;

        for (var i = 0; i < 4; ++i) {
            var v = this.getInputData(i);
            if (v == null) {
                continue;
            }
            var values = this.values[i];
            values.push(v);
            if (values.length > size[0]) {
                values.shift();
            }
        }
    };

    GraphicsPlot.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size;

        var scale = (0.5 * size[1]) / this.properties.scale;
        var colors = GraphicsPlot.colors;
        var offset = size[1] * 0.5;

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, size[0], size[1]);
        ctx.strokeStyle = "#555";
        ctx.beginPath();
        ctx.moveTo(0, offset);
        ctx.lineTo(size[0], offset);
        ctx.stroke();

        if (this.inputs) {
            for (var i = 0; i < 4; ++i) {
                var values = this.values[i];
                if (!this.inputs[i] || !this.inputs[i].link) {
                    continue;
                }
                ctx.strokeStyle = colors[i];
                ctx.beginPath();
                var v = values[0] * scale * -1 + offset;
                ctx.moveTo(0, Math.clamp(v, 0, size[1]));
                for (var j = 1; j < values.length && j < size[0]; ++j) {
                    var v = values[j] * scale * -1 + offset;
                    ctx.lineTo(j, Math.clamp(v, 0, size[1]));
                }
                ctx.stroke();
            }
        }
    };

    LiteGraph.registerNodeType("graphics/plot", GraphicsPlot);

    function GraphicsImage() {
        this.addOutput("frame", "image");
        this.properties = { url: "" };
    }

    GraphicsImage.title = "Image";
    GraphicsImage.desc = "Image loader";
    GraphicsImage.widgets = [{ name: "load", text: "Load", type: "button" }];

    GraphicsImage.supported_extensions = ["jpg", "jpeg", "png", "gif"];

    GraphicsImage.prototype.onAdded = function() {
        if (this.properties["url"] != "" && this.img == null) {
            this.loadImage(this.properties["url"]);
        }
    };

    GraphicsImage.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        if (this.img && this.size[0] > 5 && this.size[1] > 5 && this.img.width) {
            ctx.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
        }
    };

    GraphicsImage.prototype.onExecute = function() {
        if (!this.img) {
            this.boxcolor = "#000";
        }
        if (this.img && this.img.width) {
            this.setOutputData(0, this.img);
        } else {
            this.setOutputData(0, null);
        }
        if (this.img && this.img.dirty) {
            this.img.dirty = false;
        }
    };

    GraphicsImage.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;
        if (name == "url" && value != "") {
            this.loadImage(value);
        }

        return true;
    };

    GraphicsImage.prototype.loadImage = function(url, callback) {
        if (url == "") {
            this.img = null;
            return;
        }

        this.img = document.createElement("img");

        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }

        this.img.src = url;
        this.boxcolor = "#F95";
        var that = this;
        this.img.onload = function() {
            if (callback) {
                callback(this);
            }
            console.log( "Image loaded, size: " + that.img.width + "x" + that.img.height );
            this.dirty = true;
            that.boxcolor = "#9F9";
            that.setDirtyCanvas(true);
        };
        this.img.onerror = function() {
			console.log("error loading the image:" + url);
		}
    };

    GraphicsImage.prototype.onWidget = function(e, widget) {
        if (widget.name == "load") {
            this.loadImage(this.properties["url"]);
        }
    };

    GraphicsImage.prototype.onDropFile = function(file) {
        var that = this;
        if (this._url) {
            URL.revokeObjectURL(this._url);
        }
        this._url = URL.createObjectURL(file);
        this.properties.url = this._url;
        this.loadImage(this._url, function(img) {
            that.size[1] = (img.height / img.width) * that.size[0];
        });
    };

    LiteGraph.registerNodeType("graphics/image", GraphicsImage);

    function ColorPalette() {
        this.addInput("f", "number");
        this.addOutput("Color", "color");
        this.properties = {
            colorA: "#444444",
            colorB: "#44AAFF",
            colorC: "#44FFAA",
            colorD: "#FFFFFF"
        };
    }

    ColorPalette.title = "Palette";
    ColorPalette.desc = "Generates a color";

    ColorPalette.prototype.onExecute = function() {
        var c = [];

        if (this.properties.colorA != null) {
            c.push(hex2num(this.properties.colorA));
        }
        if (this.properties.colorB != null) {
            c.push(hex2num(this.properties.colorB));
        }
        if (this.properties.colorC != null) {
            c.push(hex2num(this.properties.colorC));
        }
        if (this.properties.colorD != null) {
            c.push(hex2num(this.properties.colorD));
        }

        var f = this.getInputData(0);
        if (f == null) {
            f = 0.5;
        }
        if (f > 1.0) {
            f = 1.0;
        } else if (f < 0.0) {
            f = 0.0;
        }

        if (c.length == 0) {
            return;
        }

        var result = [0, 0, 0];
        if (f == 0) {
            result = c[0];
        } else if (f == 1) {
            result = c[c.length - 1];
        } else {
            var pos = (c.length - 1) * f;
            var c1 = c[Math.floor(pos)];
            var c2 = c[Math.floor(pos) + 1];
            var t = pos - Math.floor(pos);
            result[0] = c1[0] * (1 - t) + c2[0] * t;
            result[1] = c1[1] * (1 - t) + c2[1] * t;
            result[2] = c1[2] * (1 - t) + c2[2] * t;
        }

        /*
	c[0] = 1.0 - Math.abs( Math.sin( 0.1 * reModular.getTime() * Math.PI) );
	c[1] = Math.abs( Math.sin( 0.07 * reModular.getTime() * Math.PI) );
	c[2] = Math.abs( Math.sin( 0.01 * reModular.getTime() * Math.PI) );
	*/

        for (var i=0; i < result.length; i++) {
            result[i] /= 255;
        }

        this.boxcolor = colorToString(result);
        this.setOutputData(0, result);
    };

    LiteGraph.registerNodeType("color/palette", ColorPalette);

    function ImageFrame() {
        this.addInput("", "image,canvas");
        this.size = [200, 200];
    }

    ImageFrame.title = "Frame";
    ImageFrame.desc = "Frame viewerew";
    ImageFrame.widgets = [
        { name: "resize", text: "Resize box", type: "button" },
        { name: "view", text: "View Image", type: "button" }
    ];

    ImageFrame.prototype.onDrawBackground = function(ctx) {
        if (this.frame && !this.flags.collapsed) {
            ctx.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
        }
    };

    ImageFrame.prototype.onExecute = function() {
        this.frame = this.getInputData(0);
        this.setDirtyCanvas(true);
    };

    ImageFrame.prototype.onWidget = function(e, widget) {
        if (widget.name == "resize" && this.frame) {
            var width = this.frame.width;
            var height = this.frame.height;

            if (!width && this.frame.videoWidth != null) {
                width = this.frame.videoWidth;
                height = this.frame.videoHeight;
            }

            if (width && height) {
                this.size = [width, height];
            }
            this.setDirtyCanvas(true, true);
        } else if (widget.name == "view") {
            this.show();
        }
    };

    ImageFrame.prototype.show = function() {
        //var str = this.canvas.toDataURL("image/png");
        if (showElement && this.frame) {
            showElement(this.frame);
        }
    };

    LiteGraph.registerNodeType("graphics/frame", ImageFrame);

    function ImageFade() {
        this.addInputs([
            ["img1", "image"],
            ["img2", "image"],
            ["fade", "number"]
        ]);
        this.addOutput("", "image");
        this.properties = { fade: 0.5, width: 512, height: 512 };
    }

    ImageFade.title = "Image fade";
    ImageFade.desc = "Fades between images";
    ImageFade.widgets = [
        { name: "resizeA", text: "Resize to A", type: "button" },
        { name: "resizeB", text: "Resize to B", type: "button" }
    ];

    ImageFade.prototype.onAdded = function() {
        this.createCanvas();
        var ctx = this.canvas.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, this.properties["width"], this.properties["height"]);
    };

    ImageFade.prototype.createCanvas = function() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.properties["width"];
        this.canvas.height = this.properties["height"];
    };

    ImageFade.prototype.onExecute = function() {
        var ctx = this.canvas.getContext("2d");
        this.canvas.width = this.canvas.width;

        var A = this.getInputData(0);
        if (A != null) {
            ctx.drawImage(A, 0, 0, this.canvas.width, this.canvas.height);
        }

        var fade = this.getInputData(2);
        if (fade == null) {
            fade = this.properties["fade"];
        } else {
            this.properties["fade"] = fade;
        }

        ctx.globalAlpha = fade;
        var B = this.getInputData(1);
        if (B != null) {
            ctx.drawImage(B, 0, 0, this.canvas.width, this.canvas.height);
        }
        ctx.globalAlpha = 1.0;

        this.setOutputData(0, this.canvas);
        this.setDirtyCanvas(true);
    };

    LiteGraph.registerNodeType("graphics/imagefade", ImageFade);

    function ImageCrop() {
        this.addInput("", "image");
        this.addOutput("", "image");
        this.properties = { width: 256, height: 256, x: 0, y: 0, scale: 1.0 };
        this.size = [50, 20];
    }

    ImageCrop.title = "Crop";
    ImageCrop.desc = "Crop Image";

    ImageCrop.prototype.onAdded = function() {
        this.createCanvas();
    };

    ImageCrop.prototype.createCanvas = function() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.properties["width"];
        this.canvas.height = this.properties["height"];
    };

    ImageCrop.prototype.onExecute = function() {
        var input = this.getInputData(0);
        if (!input) {
            return;
        }

        if (input.width) {
            var ctx = this.canvas.getContext("2d");

            ctx.drawImage(
                input,
                -this.properties["x"],
                -this.properties["y"],
                input.width * this.properties["scale"],
                input.height * this.properties["scale"]
            );
            this.setOutputData(0, this.canvas);
        } else {
            this.setOutputData(0, null);
        }
    };

    ImageCrop.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        if (this.canvas) {
            ctx.drawImage(
                this.canvas,
                0,
                0,
                this.canvas.width,
                this.canvas.height,
                0,
                0,
                this.size[0],
                this.size[1]
            );
        }
    };

    ImageCrop.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;

        if (name == "scale") {
            this.properties[name] = parseFloat(value);
            if (this.properties[name] == 0) {
                console.error("Error in scale");
                this.properties[name] = 1.0;
            }
        } else {
            this.properties[name] = parseInt(value);
        }

        this.createCanvas();

        return true;
    };

    LiteGraph.registerNodeType("graphics/cropImage", ImageCrop);

    //CANVAS stuff

    function CanvasNode() {
        this.addInput("clear", LiteGraph.ACTION);
        this.addOutput("", "canvas");
        this.properties = { width: 512, height: 512, autoclear: true };

        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
    }

    CanvasNode.title = "Canvas";
    CanvasNode.desc = "Canvas to render stuff";

    CanvasNode.prototype.onExecute = function() {
        var canvas = this.canvas;
        var w = this.properties.width | 0;
        var h = this.properties.height | 0;
        if (canvas.width != w) {
            canvas.width = w;
        }
        if (canvas.height != h) {
            canvas.height = h;
        }

        if (this.properties.autoclear) {
            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        this.setOutputData(0, canvas);
    };

    CanvasNode.prototype.onAction = function(action, param) {
        if (action == "clear") {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
    };

    LiteGraph.registerNodeType("graphics/canvas", CanvasNode);

    function DrawImageNode() {
        this.addInput("canvas", "canvas");
        this.addInput("img", "image,canvas");
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.properties = { x: 0, y: 0, opacity: 1 };
    }

    DrawImageNode.title = "DrawImage";
    DrawImageNode.desc = "Draws image into a canvas";

    DrawImageNode.prototype.onExecute = function() {
        var canvas = this.getInputData(0);
        if (!canvas) {
            return;
        }

        var img = this.getInputOrProperty("img");
        if (!img) {
            return;
        }

        var x = this.getInputOrProperty("x");
        var y = this.getInputOrProperty("y");
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, x, y);
    };

    LiteGraph.registerNodeType("graphics/drawImage", DrawImageNode);

    function DrawRectangleNode() {
        this.addInput("canvas", "canvas");
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.addInput("w", "number");
        this.addInput("h", "number");
        this.properties = {
            x: 0,
            y: 0,
            w: 10,
            h: 10,
            color: "white",
            opacity: 1
        };
    }

    DrawRectangleNode.title = "DrawRectangle";
    DrawRectangleNode.desc = "Draws rectangle in canvas";

    DrawRectangleNode.prototype.onExecute = function() {
        var canvas = this.getInputData(0);
        if (!canvas) {
            return;
        }

        var x = this.getInputOrProperty("x");
        var y = this.getInputOrProperty("y");
        var w = this.getInputOrProperty("w");
        var h = this.getInputOrProperty("h");
        var ctx = canvas.getContext("2d");
        ctx.fillRect(x, y, w, h);
    };

    LiteGraph.registerNodeType("graphics/drawRectangle", DrawRectangleNode);

    function ImageVideo() {
        this.addInput("t", "number");
        this.addOutputs([["frame", "image"], ["t", "number"], ["d", "number"]]);
        this.properties = { url: "", use_proxy: true };
    }

    ImageVideo.title = "Video";
    ImageVideo.desc = "Video playback";
    ImageVideo.widgets = [
        { name: "play", text: "PLAY", type: "minibutton" },
        { name: "stop", text: "STOP", type: "minibutton" },
        { name: "demo", text: "Demo video", type: "button" },
        { name: "mute", text: "Mute video", type: "button" }
    ];

    ImageVideo.prototype.onExecute = function() {
        if (!this.properties.url) {
            return;
        }

        if (this.properties.url != this._video_url) {
            this.loadVideo(this.properties.url);
        }

        if (!this._video || this._video.width == 0) {
            return;
        }

        var t = this.getInputData(0);
        if (t && t >= 0 && t <= 1.0) {
            this._video.currentTime = t * this._video.duration;
            this._video.pause();
        }

        this._video.dirty = true;
        this.setOutputData(0, this._video);
        this.setOutputData(1, this._video.currentTime);
        this.setOutputData(2, this._video.duration);
        this.setDirtyCanvas(true);
    };

    ImageVideo.prototype.onStart = function() {
        this.play();
    };

    ImageVideo.prototype.onStop = function() {
        this.stop();
    };

    ImageVideo.prototype.loadVideo = function(url) {
        this._video_url = url;

		var pos = url.substr(0,10).indexOf(":");
		var protocol = "";
		if(pos != -1)
			protocol = url.substr(0,pos);

		var host = "";
		if(protocol)
		{
			host = url.substr(0,url.indexOf("/",protocol.length + 3));
			host = host.substr(protocol.length+3);
		}

        if (
            this.properties.use_proxy &&
            protocol &&
            LiteGraph.proxy &&
			host != location.host
        ) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }

        this._video = document.createElement("video");
        this._video.src = url;
        this._video.type = "type=video/mp4";

        this._video.muted = true;
        this._video.autoplay = true;

        var that = this;
        this._video.addEventListener("loadedmetadata", function(e) {
            //onload
            console.log("Duration: " + this.duration + " seconds");
            console.log("Size: " + this.videoWidth + "," + this.videoHeight);
            that.setDirtyCanvas(true);
            this.width = this.videoWidth;
            this.height = this.videoHeight;
        });
        this._video.addEventListener("progress", function(e) {
            //onload
            console.log("video loading...");
        });
        this._video.addEventListener("error", function(e) {
            console.error("Error loading video: " + this.src);
            if (this.error) {
                switch (this.error.code) {
                    case this.error.MEDIA_ERR_ABORTED:
                        console.error("You stopped the video.");
                        break;
                    case this.error.MEDIA_ERR_NETWORK:
                        console.error("Network error - please try again later.");
                        break;
                    case this.error.MEDIA_ERR_DECODE:
                        console.error("Video is broken..");
                        break;
                    case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        console.error("Sorry, your browser can't play this video.");
                        break;
                }
            }
        });

        this._video.addEventListener("ended", function(e) {
            console.log("Video Ended.");
            this.play(); //loop
        });

        //document.body.appendChild(this.video);
    };

    ImageVideo.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;
        if (name == "url" && value != "") {
            this.loadVideo(value);
        }

        return true;
    };

    ImageVideo.prototype.play = function() {
        if (this._video && this._video.videoWidth ) { //is loaded
            this._video.play();
        }
    };

    ImageVideo.prototype.playPause = function() {
        if (!this._video) {
            return;
        }
        if (this._video.paused) {
            this.play();
        } else {
            this.pause();
        }
    };

    ImageVideo.prototype.stop = function() {
        if (!this._video) {
            return;
        }
        this._video.pause();
        this._video.currentTime = 0;
    };

    ImageVideo.prototype.pause = function() {
        if (!this._video) {
            return;
        }
        console.log("Video paused");
        this._video.pause();
    };

    ImageVideo.prototype.onWidget = function(e, widget) {
        /*
	if(widget.name == "demo")
	{
		this.loadVideo();
	}
	else if(widget.name == "play")
	{
		if(this._video)
			this.playPause();
	}
	if(widget.name == "stop")
	{
		this.stop();
	}
	else if(widget.name == "mute")
	{
		if(this._video)
			this._video.muted = !this._video.muted;
	}
	*/
    };

    LiteGraph.registerNodeType("graphics/video", ImageVideo);

    // Texture Webcam *****************************************
    function ImageWebcam() {
        this.addOutput("Webcam", "image");
        this.properties = { filterFacingMode: false, facingMode: "user" };
        this.boxcolor = "black";
        this.frame = 0;
    }

    ImageWebcam.title = "Webcam";
    ImageWebcam.desc = "Webcam image";
    ImageWebcam.is_webcam_open = false;

    ImageWebcam.prototype.openStream = function() {
        if (!navigator.mediaDevices.getUserMedia) {
            console.log('getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags');
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        var constraints = {
            audio: false,
            video: !this.properties.filterFacingMode ? true : { facingMode: this.properties.facingMode }
        };
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(e) {
            console.log("Webcam rejected", e);
            that._webcam_stream = false;
            ImageWebcam.is_webcam_open = false;
            that.boxcolor = "red";
            that.trigger("stream_error");
        }
    };

    ImageWebcam.prototype.closeStream = function() {
        if (this._webcam_stream) {
            var tracks = this._webcam_stream.getTracks();
            if (tracks.length) {
                for (var i = 0; i < tracks.length; ++i) {
                    tracks[i].stop();
                }
            }
            ImageWebcam.is_webcam_open = false;
            this._webcam_stream = null;
            this._video = null;
            this.boxcolor = "black";
            this.trigger("stream_closed");
        }
    };

    ImageWebcam.prototype.onPropertyChanged = function(name, value) {
        if (name == "facingMode") {
            this.properties.facingMode = value;
            this.closeStream();
            this.openStream();
        }
    };

    ImageWebcam.prototype.onRemoved = function() {
        this.closeStream();
    };

    ImageWebcam.prototype.streamReady = function(localMediaStream) {
        this._webcam_stream = localMediaStream;
        //this._waiting_confirmation = false;
        this.boxcolor = "green";

        var video = this._video;
        if (!video) {
            video = document.createElement("video");
            video.autoplay = true;
            video.srcObject = localMediaStream;
            this._video = video;
            //document.body.appendChild( video ); //debug
            //when video info is loaded (size and so)
            video.onloadedmetadata = function(e) {
                // Ready to go. Do some stuff.
                console.log(e);
                ImageWebcam.is_webcam_open = true;
            };
        }

        this.trigger("stream_ready", video);
    };

    ImageWebcam.prototype.onExecute = function() {
        if (this._webcam_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (!this._video || !this._video.videoWidth) {
            return;
        }

        this._video.frame = ++this.frame;
        this._video.width = this._video.videoWidth;
        this._video.height = this._video.videoHeight;
        this.setOutputData(0, this._video);
        for (var i = 1; i < this.outputs.length; ++i) {
            if (!this.outputs[i]) {
                continue;
            }
            switch (this.outputs[i].name) {
                case "width":
                    this.setOutputData(i, this._video.videoWidth);
                    break;
                case "height":
                    this.setOutputData(i, this._video.videoHeight);
                    break;
            }
        }
    };

    ImageWebcam.prototype.getExtraMenuOptions = function(graphcanvas) {
        var that = this;
        var txt = !that.properties.show ? "Show Frame" : "Hide Frame";
        return [
            {
                content: txt,
                callback: function() {
                    that.properties.show = !that.properties.show;
                }
            }
        ];
    };

    ImageWebcam.prototype.onDrawBackground = function(ctx) {
        if (
            this.flags.collapsed ||
            this.size[1] <= 20 ||
            !this.properties.show
        ) {
            return;
        }

        if (!this._video) {
            return;
        }

        //render to graph canvas
        ctx.save();
        ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);
        ctx.restore();
    };

    ImageWebcam.prototype.onGetOutputs = function() {
        return [
            ["width", "number"],
            ["height", "number"],
            ["stream_ready", LiteGraph.EVENT],
            ["stream_closed", LiteGraph.EVENT],
            ["stream_error", LiteGraph.EVENT]
        ];
    };

    LiteGraph.registerNodeType("graphics/webcam", ImageWebcam);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;
	var LGraphCanvas = global.LGraphCanvas;

    //Works with Litegl.js to create WebGL nodes
    global.LGraphTexture = null;

    if (typeof GL == "undefined")
		return;

	LGraphCanvas.link_type_colors["Texture"] = "#987";

	function LGraphTexture() {
		this.addOutput("tex", "Texture");
		this.addOutput("name", "string");
		this.properties = { name: "", filter: true };
		this.size = [
			LGraphTexture.image_preview_size,
			LGraphTexture.image_preview_size
		];
	}

	global.LGraphTexture = LGraphTexture;

	LGraphTexture.title = "Texture";
	LGraphTexture.desc = "Texture";
	LGraphTexture.widgets_info = {
		name: { widget: "texture" },
		filter: { widget: "checkbox" }
	};

	//REPLACE THIS TO INTEGRATE WITH YOUR FRAMEWORK
	LGraphTexture.loadTextureCallback = null; //function in charge of loading textures when not present in the container
	LGraphTexture.image_preview_size = 256;

	//flags to choose output texture type
	LGraphTexture.UNDEFINED = 0; //not specified
	LGraphTexture.PASS_THROUGH = 1; //do not apply FX (like disable but passing the in to the out)
	LGraphTexture.COPY = 2; //create new texture with the same properties as the origin texture
	LGraphTexture.LOW = 3; //create new texture with low precision (byte)
	LGraphTexture.HIGH = 4; //create new texture with high precision (half-float)
	LGraphTexture.REUSE = 5; //reuse input texture
	LGraphTexture.DEFAULT = 2; //use the default

	LGraphTexture.MODE_VALUES = {
		"undefined": LGraphTexture.UNDEFINED,
		"pass through": LGraphTexture.PASS_THROUGH,
		copy: LGraphTexture.COPY,
		low: LGraphTexture.LOW,
		high: LGraphTexture.HIGH,
		reuse: LGraphTexture.REUSE,
		default: LGraphTexture.DEFAULT
	};

	//returns the container where all the loaded textures are stored (overwrite if you have a Resources Manager)
	LGraphTexture.getTexturesContainer = function() {
		return gl.textures;
	};

	//process the loading of a texture (overwrite it if you have a Resources Manager)
	LGraphTexture.loadTexture = function(name, options) {
		options = options || {};
		var url = name;
		if (url.substr(0, 7) == "http://") {
			if (LiteGraph.proxy) {
				//proxy external files
				url = LiteGraph.proxy + url.substr(7);
			}
		}

		var container = LGraphTexture.getTexturesContainer();
		var tex = (container[name] = GL.Texture.fromURL(url, options));
		return tex;
	};

	LGraphTexture.getTexture = function(name) {
		var container = this.getTexturesContainer();

		if (!container) {
			throw "Cannot load texture, container of textures not found";
		}

		var tex = container[name];
		if (!tex && name && name[0] != ":") {
			return this.loadTexture(name);
		}

		return tex;
	};

	//used to compute the appropiate output texture
	LGraphTexture.getTargetTexture = function(origin, target, mode) {
		if (!origin) {
			throw "LGraphTexture.getTargetTexture expects a reference texture";
		}

		var tex_type = null;

		switch (mode) {
			case LGraphTexture.LOW:
				tex_type = gl.UNSIGNED_BYTE;
				break;
			case LGraphTexture.HIGH:
				tex_type = gl.HIGH_PRECISION_FORMAT;
				break;
			case LGraphTexture.REUSE:
				return origin;
				break;
			case LGraphTexture.COPY:
			default:
				tex_type = origin ? origin.type : gl.UNSIGNED_BYTE;
				break;
		}

		if (
			!target ||
			target.width != origin.width ||
			target.height != origin.height ||
			target.type != tex_type ||
			target.format != origin.format 
		) {
			target = new GL.Texture(origin.width, origin.height, {
				type: tex_type,
				format: origin.format,
				filter: gl.LINEAR
			});
		}

		return target;
	};

	LGraphTexture.getTextureType = function(precision, ref_texture) {
		var type = ref_texture ? ref_texture.type : gl.UNSIGNED_BYTE;
		switch (precision) {
			case LGraphTexture.HIGH:
				type = gl.HIGH_PRECISION_FORMAT;
				break;
			case LGraphTexture.LOW:
				type = gl.UNSIGNED_BYTE;
				break;
			//no default
		}
		return type;
	};

	LGraphTexture.getWhiteTexture = function() {
		if (this._white_texture) {
			return this._white_texture;
		}
		var texture = (this._white_texture = GL.Texture.fromMemory(
			1,
			1,
			[255, 255, 255, 255],
			{ format: gl.RGBA, wrap: gl.REPEAT, filter: gl.NEAREST }
		));
		return texture;
	};

	LGraphTexture.getNoiseTexture = function() {
		if (this._noise_texture) {
			return this._noise_texture;
		}

		var noise = new Uint8Array(512 * 512 * 4);
		for (var i = 0; i < 512 * 512 * 4; ++i) {
			noise[i] = Math.random() * 255;
		}

		var texture = GL.Texture.fromMemory(512, 512, noise, {
			format: gl.RGBA,
			wrap: gl.REPEAT,
			filter: gl.NEAREST
		});
		this._noise_texture = texture;
		return texture;
	};

	LGraphTexture.prototype.onDropFile = function(data, filename, file) {
		if (!data) {
			this._drop_texture = null;
			this.properties.name = "";
		} else {
			var texture = null;
			if (typeof data == "string") {
				texture = GL.Texture.fromURL(data);
			} else if (filename.toLowerCase().indexOf(".dds") != -1) {
				texture = GL.Texture.fromDDSInMemory(data);
			} else {
				var blob = new Blob([file]);
				var url = URL.createObjectURL(blob);
				texture = GL.Texture.fromURL(url);
			}

			this._drop_texture = texture;
			this.properties.name = filename;
		}
	};

	LGraphTexture.prototype.getExtraMenuOptions = function(graphcanvas) {
		var that = this;
		if (!this._drop_texture) {
			return;
		}
		return [
			{
				content: "Clear",
				callback: function() {
					that._drop_texture = null;
					that.properties.name = "";
				}
			}
		];
	};

	LGraphTexture.prototype.onExecute = function() {
		var tex = null;
		if (this.isOutputConnected(1)) {
			tex = this.getInputData(0);
		}

		if (!tex && this._drop_texture) {
			tex = this._drop_texture;
		}

		if (!tex && this.properties.name) {
			tex = LGraphTexture.getTexture(this.properties.name);
		}

		if (!tex) {
			this.setOutputData( 0, null );
			this.setOutputData( 1, "" );
			return;
		}

		this._last_tex = tex;

		if (this.properties.filter === false) {
			tex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		} else {
			tex.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		}

		this.setOutputData( 0, tex );
		this.setOutputData( 1, tex.fullpath || tex.filename );

		for (var i = 2; i < this.outputs.length; i++) {
			var output = this.outputs[i];
			if (!output) {
				continue;
			}
			var v = null;
			if (output.name == "width") {
				v = tex.width;
			} else if (output.name == "height") {
				v = tex.height;
			} else if (output.name == "aspect") {
				v = tex.width / tex.height;
			}
			this.setOutputData(i, v);
		}
	};

	LGraphTexture.prototype.onResourceRenamed = function(
		old_name,
		new_name
	) {
		if (this.properties.name == old_name) {
			this.properties.name = new_name;
		}
	};

	LGraphTexture.prototype.onDrawBackground = function(ctx) {
		if (this.flags.collapsed || this.size[1] <= 20) {
			return;
		}

		if (this._drop_texture && ctx.webgl) {
			ctx.drawImage(
				this._drop_texture,
				0,
				0,
				this.size[0],
				this.size[1]
			);
			//this._drop_texture.renderQuad(this.pos[0],this.pos[1],this.size[0],this.size[1]);
			return;
		}

		//Different texture? then get it from the GPU
		if (this._last_preview_tex != this._last_tex) {
			if (ctx.webgl) {
				this._canvas = this._last_tex;
			} else {
				var tex_canvas = LGraphTexture.generateLowResTexturePreview(
					this._last_tex
				);
				if (!tex_canvas) {
					return;
				}

				this._last_preview_tex = this._last_tex;
				this._canvas = cloneCanvas(tex_canvas);
			}
		}

		if (!this._canvas) {
			return;
		}

		//render to graph canvas
		ctx.save();
		if (!ctx.webgl) {
			//reverse image
			ctx.translate(0, this.size[1]);
			ctx.scale(1, -1);
		}
		ctx.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]);
		ctx.restore();
	};

	//very slow, used at your own risk
	LGraphTexture.generateLowResTexturePreview = function(tex) {
		if (!tex) {
			return null;
		}

		var size = LGraphTexture.image_preview_size;
		var temp_tex = tex;

		if (tex.format == gl.DEPTH_COMPONENT) {
			return null;
		} //cannot generate from depth

		//Generate low-level version in the GPU to speed up
		if (tex.width > size || tex.height > size) {
			temp_tex = this._preview_temp_tex;
			if (!this._preview_temp_tex) {
				temp_tex = new GL.Texture(size, size, {
					minFilter: gl.NEAREST
				});
				this._preview_temp_tex = temp_tex;
			}

			//copy
			tex.copyTo(temp_tex);
			tex = temp_tex;
		}

		//create intermediate canvas with lowquality version
		var tex_canvas = this._preview_canvas;
		if (!tex_canvas) {
			tex_canvas = createCanvas(size, size);
			this._preview_canvas = tex_canvas;
		}

		if (temp_tex) {
			temp_tex.toCanvas(tex_canvas);
		}
		return tex_canvas;
	};

	LGraphTexture.prototype.getResources = function(res) {
		if(this.properties.name)
			res[this.properties.name] = GL.Texture;
		return res;
	};

	LGraphTexture.prototype.onGetInputs = function() {
		return [["in", "Texture"]];
	};

	LGraphTexture.prototype.onGetOutputs = function() {
		return [
			["width", "number"],
			["height", "number"],
			["aspect", "number"]
		];
	};

	//used to replace shader code
	LGraphTexture.replaceCode = function( code, context )
	{
		return code.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function(v){
			v = v.replace( /[\{\}]/g, "" );
			return context[v] || "";
		});
	}

	LiteGraph.registerNodeType("texture/texture", LGraphTexture);

	//**************************
	function LGraphTexturePreview() {
		this.addInput("Texture", "Texture");
		this.properties = { flipY: false };
		this.size = [
			LGraphTexture.image_preview_size,
			LGraphTexture.image_preview_size
		];
	}

	LGraphTexturePreview.title = "Preview";
	LGraphTexturePreview.desc = "Show a texture in the graph canvas";
	LGraphTexturePreview.allow_preview = false;

	LGraphTexturePreview.prototype.onDrawBackground = function(ctx) {
		if (this.flags.collapsed) {
			return;
		}

		if (!ctx.webgl && !LGraphTexturePreview.allow_preview) {
			return;
		} //not working well

		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		var tex_canvas = null;

		if (!tex.handle && ctx.webgl) {
			tex_canvas = tex;
		} else {
			tex_canvas = LGraphTexture.generateLowResTexturePreview(tex);
		}

		//render to graph canvas
		ctx.save();
		if (this.properties.flipY) {
			ctx.translate(0, this.size[1]);
			ctx.scale(1, -1);
		}
		ctx.drawImage(tex_canvas, 0, 0, this.size[0], this.size[1]);
		ctx.restore();
	};

	LiteGraph.registerNodeType("texture/preview", LGraphTexturePreview);

	//**************************************

	function LGraphTextureSave() {
		this.addInput("Texture", "Texture");
		this.addOutput("tex", "Texture");
		this.addOutput("name", "string");
		this.properties = { name: "", generate_mipmaps: false };
	}

	LGraphTextureSave.title = "Save";
	LGraphTextureSave.desc = "Save a texture in the repository";

	LGraphTextureSave.prototype.getPreviewTexture = function()
	{
		return this._texture;
	}

	LGraphTextureSave.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (this.properties.generate_mipmaps) {
			tex.bind(0);
			tex.setParameter( gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );
			gl.generateMipmap(tex.texture_type);
			tex.unbind(0);
		}

		if (this.properties.name) {
			//for cases where we want to perform something when storing it
			if (LGraphTexture.storeTexture) {
				LGraphTexture.storeTexture(this.properties.name, tex);
			} else {
				var container = LGraphTexture.getTexturesContainer();
				container[this.properties.name] = tex;
			}
		}

		this._texture = tex;
		this.setOutputData(0, tex);
		this.setOutputData(1, this.properties.name);
	};

	LiteGraph.registerNodeType("texture/save", LGraphTextureSave);

	//****************************************************

	function LGraphTextureOperation() {
		this.addInput("Texture", "Texture");
		this.addInput("TextureB", "Texture");
		this.addInput("value", "number");
		this.addOutput("Texture", "Texture");
		this.help = "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>\
		<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>";

		this.properties = {
			value: 1,
			pixelcode: "color + colorB * value",
			uvcode: "",
			precision: LGraphTexture.DEFAULT
		};

		this.has_error = false;
	}

	LGraphTextureOperation.widgets_info = {
		uvcode: { widget: "code" },
		pixelcode: { widget: "code" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureOperation.title = "Operation";
	LGraphTextureOperation.desc = "Texture shader operation";

	LGraphTextureOperation.presets = {};

	LGraphTextureOperation.prototype.getExtraMenuOptions = function(
		graphcanvas
	) {
		var that = this;
		var txt = !that.properties.show ? "Show Texture" : "Hide Texture";
		return [
			{
				content: txt,
				callback: function() {
					that.properties.show = !that.properties.show;
				}
			}
		];
	};

	LGraphTextureOperation.prototype.onPropertyChanged = function()
	{
		this.has_error = false;
	}

	LGraphTextureOperation.prototype.onDrawBackground = function(ctx) {
		if (
			this.flags.collapsed ||
			this.size[1] <= 20 ||
			!this.properties.show
		) {
			return;
		}

		if (!this._tex) {
			return;
		}

		//only works if using a webgl renderer
		if (this._tex.gl != ctx) {
			return;
		}

		//render to graph canvas
		ctx.save();
		ctx.drawImage(this._tex, 0, 0, this.size[0], this.size[1]);
		ctx.restore();
	};

	LGraphTextureOperation.prototype.onExecute = function() {
		var tex = this.getInputData(0);

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		var texB = this.getInputData(1);

		if (!this.properties.uvcode && !this.properties.pixelcode) {
			return;
		}

		var width = 512;
		var height = 512;
		if (tex) {
			width = tex.width;
			height = tex.height;
		} else if (texB) {
			width = texB.width;
			height = texB.height;
		}

		if(!texB)
			texB = GL.Texture.getWhiteTexture();

		var type = LGraphTexture.getTextureType( this.properties.precision, tex );

		if (!tex && !this._tex) {
			this._tex = new GL.Texture(width, height, { type: type, format: gl.RGBA, filter: gl.LINEAR });
		} else {
			this._tex = LGraphTexture.getTargetTexture( tex || this._tex, this._tex, this.properties.precision );
		}

		var uvcode = "";
		if (this.properties.uvcode) {
			uvcode = "uv = " + this.properties.uvcode;
			if (this.properties.uvcode.indexOf(";") != -1) {
				//there are line breaks, means multiline code
				uvcode = this.properties.uvcode;
			}
		}

		var pixelcode = "";
		if (this.properties.pixelcode) {
			pixelcode = "result = " + this.properties.pixelcode;
			if (this.properties.pixelcode.indexOf(";") != -1) {
				//there are line breaks, means multiline code
				pixelcode = this.properties.pixelcode;
			}
		}

		var shader = this._shader;

		if ( !this.has_error && (!shader || this._shader_code != uvcode + "|" + pixelcode) ) {

			var final_pixel_code = LGraphTexture.replaceCode( LGraphTextureOperation.pixel_shader, { UV_CODE:uvcode, PIXEL_CODE:pixelcode });

			try {
				shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, final_pixel_code );
				this.boxcolor = "#00FF00";
			} catch (err) {
				//console.log("Error compiling shader: ", err, final_pixel_code );
				GL.Shader.dumpErrorToConsole(err,Shader.SCREEN_VERTEX_SHADER, final_pixel_code);
				this.boxcolor = "#FF0000";
				this.has_error = true;
				return;
			}
			this._shader = shader;
			this._shader_code = uvcode + "|" + pixelcode;
		}

		if(!this._shader)
			return;

		var value = this.getInputData(2);
		if (value != null) {
			this.properties.value = value;
		} else {
			value = parseFloat(this.properties.value);
		}

		var time = this.graph.getTime();

		this._tex.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.BLEND);
			if (tex) {
				tex.bind(0);
			}
			if (texB) {
				texB.bind(1);
			}
			var mesh = Mesh.getScreenQuad();
			shader
				.uniforms({
					u_texture: 0,
					u_textureB: 1,
					value: value,
					texSize: [width, height,1/width,1/height],
					time: time
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureOperation.pixel_shader =
		"precision highp float;\n\
		\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		varying vec2 v_coord;\n\
		uniform vec4 texSize;\n\
		uniform float time;\n\
		uniform float value;\n\
		\n\
		void main() {\n\
			vec2 uv = v_coord;\n\
			{{UV_CODE}};\n\
			vec4 color4 = texture2D(u_texture, uv);\n\
			vec3 color = color4.rgb;\n\
			vec4 color4B = texture2D(u_textureB, uv);\n\
			vec3 colorB = color4B.rgb;\n\
			vec3 result = color;\n\
			float alpha = 1.0;\n\
			{{PIXEL_CODE}};\n\
			gl_FragColor = vec4(result, alpha);\n\
		}\n\
		";

	LGraphTextureOperation.registerPreset = function ( name, code )
	{
		LGraphTextureOperation.presets[name] = code;
	}

	LGraphTextureOperation.registerPreset("","");
	LGraphTextureOperation.registerPreset("bypass","color");
	LGraphTextureOperation.registerPreset("add","color + colorB * value");
	LGraphTextureOperation.registerPreset("substract","(color - colorB) * value");
	LGraphTextureOperation.registerPreset("mate","mix( color, colorB, color4B.a * value)");
	LGraphTextureOperation.registerPreset("invert","vec3(1.0) - color");
	LGraphTextureOperation.registerPreset("multiply","color * colorB * value");
	LGraphTextureOperation.registerPreset("divide","(color / colorB) / value");
	LGraphTextureOperation.registerPreset("difference","abs(color - colorB) * value");
	LGraphTextureOperation.registerPreset("max","max(color, colorB) * value");
	LGraphTextureOperation.registerPreset("min","min(color, colorB) * value");
	LGraphTextureOperation.registerPreset("displace","texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz");
	LGraphTextureOperation.registerPreset("grayscale","vec3(color.x + color.y + color.z) * value / 3.0");
	LGraphTextureOperation.registerPreset("saturation","mix( vec3(color.x + color.y + color.z) / 3.0, color, value )");
	LGraphTextureOperation.registerPreset("normalmap","\n\
		float z0 = texture2D(u_texture, uv + vec2(-texSize.z, -texSize.w) ).x;\n\
		float z1 = texture2D(u_texture, uv + vec2(0.0, -texSize.w) ).x;\n\
		float z2 = texture2D(u_texture, uv + vec2(texSize.z, -texSize.w) ).x;\n\
		float z3 = texture2D(u_texture, uv + vec2(-texSize.z, 0.0) ).x;\n\
		float z4 = color.x;\n\
		float z5 = texture2D(u_texture, uv + vec2(texSize.z, 0.0) ).x;\n\
		float z6 = texture2D(u_texture, uv + vec2(-texSize.z, texSize.w) ).x;\n\
		float z7 = texture2D(u_texture, uv + vec2(0.0, texSize.w) ).x;\n\
		float z8 = texture2D(u_texture, uv + vec2(texSize.z, texSize.w) ).x;\n\
		vec3 normal = vec3( z2 + 2.0*z4 + z7 - z0 - 2.0*z3 - z5, z5 + 2.0*z6 + z7 -z0 - 2.0*z1 - z2, 1.0 );\n\
		normal.xy *= value;\n\
		result.xyz = normalize(normal) * 0.5 + vec3(0.5);\n\
	");
	LGraphTextureOperation.registerPreset("threshold","vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)");

	//webglstudio stuff...
	LGraphTextureOperation.prototype.onInspect = function(widgets)
	{
		var that = this;
		widgets.addCombo("Presets","",{ values: Object.keys(LGraphTextureOperation.presets), callback: function(v){
			var code = LGraphTextureOperation.presets[v];
			if(!code)
				return;
			that.setProperty("pixelcode",code);
			that.title = v;
			widgets.refresh();
		}});
	}

	LiteGraph.registerNodeType("texture/operation", LGraphTextureOperation);

	//****************************************************

	function LGraphTextureShader() {
		this.addOutput("out", "Texture");
		this.properties = {
			code: "",
			u_value: 1,
			u_color: [1,1,1,1],
			width: 512,
			height: 512,
			precision: LGraphTexture.DEFAULT
		};

		this.properties.code = LGraphTextureShader.pixel_shader;
		this._uniforms = { u_value: 1, u_color: vec4.create(), in_texture: 0, texSize: vec4.create(), time: 0 };
	}

	LGraphTextureShader.title = "Shader";
	LGraphTextureShader.desc = "Texture shader";
	LGraphTextureShader.widgets_info = {
		code: { type: "code", lang: "glsl" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureShader.prototype.onPropertyChanged = function(
		name,
		value
	) {
		if (name != "code") {
			return;
		}

		var shader = this.getShader();
		if (!shader) {
			return;
		}

		//update connections
		var uniforms = shader.uniformInfo;

		//remove deprecated slots
		if (this.inputs) {
			var already = {};
			for (var i = 0; i < this.inputs.length; ++i) {
				var info = this.getInputInfo(i);
				if (!info) {
					continue;
				}

				if (uniforms[info.name] && !already[info.name]) {
					already[info.name] = true;
					continue;
				}
				this.removeInput(i);
				i--;
			}
		}

		//update existing ones
		for (var i in uniforms) {
			var info = shader.uniformInfo[i];
			if (info.loc === null) {
				continue;
			} //is an attribute, not a uniform
			if (i == "time") {
				//default one
				continue;
			}

			var type = "number";
			if (this._shader.samplers[i]) {
				type = "texture";
			} else {
				switch (info.size) {
					case 1:
						type = "number";
						break;
					case 2:
						type = "vec2";
						break;
					case 3:
						type = "vec3";
						break;
					case 4:
						type = "vec4";
						break;
					case 9:
						type = "mat3";
						break;
					case 16:
						type = "mat4";
						break;
					default:
						continue;
				}
			}

			var slot = this.findInputSlot(i);
			if (slot == -1) {
				this.addInput(i, type);
				continue;
			}

			var input_info = this.getInputInfo(slot);
			if (!input_info) {
				this.addInput(i, type);
			} else {
				if (input_info.type == type) {
					continue;
				}
				this.removeInput(slot, type);
				this.addInput(i, type);
			}
		}
	};

	LGraphTextureShader.prototype.getShader = function() {
		//replug
		if (this._shader && this._shader_code == this.properties.code) {
			return this._shader;
		}

		this._shader_code = this.properties.code;
		this._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, this.properties.code );
		if (!this._shader) {
			this.boxcolor = "red";
			return null;
		} else {
			this.boxcolor = "green";
		}
		return this._shader;
	};

	LGraphTextureShader.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var shader = this.getShader();
		if (!shader) {
			return;
		}

		var tex_slot = 0;
		var in_tex = null;

		//set uniforms
		if(this.inputs)
		for (var i = 0; i < this.inputs.length; ++i) {
			var info = this.getInputInfo(i);
			var data = this.getInputData(i);
			if (data == null) {
				continue;
			}

			if (data.constructor === GL.Texture) {
				data.bind(tex_slot);
				if (!in_tex) {
					in_tex = data;
				}
				data = tex_slot;
				tex_slot++;
			}
			shader.setUniform(info.name, data); //data is tex_slot
		}

		var uniforms = this._uniforms;
		var type = LGraphTexture.getTextureType( this.properties.precision, in_tex );

		//render to texture
		var w = this.properties.width | 0;
		var h = this.properties.height | 0;
		if (w == 0) {
			w = in_tex ? in_tex.width : gl.canvas.width;
		}
		if (h == 0) {
			h = in_tex ? in_tex.height : gl.canvas.height;
		}
		uniforms.texSize[0] = w;
		uniforms.texSize[1] = h;
		uniforms.texSize[2] = 1/w;
		uniforms.texSize[3] = 1/h;
		uniforms.time = this.graph.getTime();
		uniforms.u_value = this.properties.u_value;
		uniforms.u_color.set( this.properties.u_color );

		if ( !this._tex || this._tex.type != type ||  this._tex.width != w || this._tex.height != h ) {
			this._tex = new GL.Texture(w, h, {  type: type, format: gl.RGBA, filter: gl.LINEAR });
		}
		var tex = this._tex;
		tex.drawTo(function() {
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureShader.pixel_shader =
"precision highp float;\n\
\n\
varying vec2 v_coord;\n\
uniform float time; //time in seconds\n\
uniform vec4 texSize; //tex resolution\n\
uniform float u_value;\n\
uniform vec4 u_color;\n\n\
void main() {\n\
	vec2 uv = v_coord;\n\
	vec3 color = vec3(0.0);\n\
	//your code here\n\
	color.xy=uv;\n\n\
	gl_FragColor = vec4(color, 1.0);\n\
}\n\
";

	LiteGraph.registerNodeType("texture/shader", LGraphTextureShader);

	// Texture Scale Offset

	function LGraphTextureScaleOffset() {
		this.addInput("in", "Texture");
		this.addInput("scale", "vec2");
		this.addInput("offset", "vec2");
		this.addOutput("out", "Texture");
		this.properties = {
			offset: vec2.fromValues(0, 0),
			scale: vec2.fromValues(1, 1),
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureScaleOffset.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureScaleOffset.title = "Scale/Offset";
	LGraphTextureScaleOffset.desc = "Applies an scaling and offseting";

	LGraphTextureScaleOffset.prototype.onExecute = function() {
		var tex = this.getInputData(0);

		if (!this.isOutputConnected(0) || !tex) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		var width = tex.width;
		var height = tex.height;
		var type =  this.precision === LGraphTexture.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;
		if (this.precision === LGraphTexture.DEFAULT) {
			type = tex.type;
		}

		if (
			!this._tex ||
			this._tex.width != width ||
			this._tex.height != height ||
			this._tex.type != type
		) {
			this._tex = new GL.Texture(width, height, {
				type: type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		var shader = this._shader;

		if (!shader) {
			shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureScaleOffset.pixel_shader
			);
		}

		var scale = this.getInputData(1);
		if (scale) {
			this.properties.scale[0] = scale[0];
			this.properties.scale[1] = scale[1];
		} else {
			scale = this.properties.scale;
		}

		var offset = this.getInputData(2);
		if (offset) {
			this.properties.offset[0] = offset[0];
			this.properties.offset[1] = offset[1];
		} else {
			offset = this.properties.offset;
		}

		this._tex.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.BLEND);
			tex.bind(0);
			var mesh = Mesh.getScreenQuad();
			shader
				.uniforms({
					u_texture: 0,
					u_scale: scale,
					u_offset: offset
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureScaleOffset.pixel_shader =
		"precision highp float;\n\
		\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		varying vec2 v_coord;\n\
		uniform vec2 u_scale;\n\
		uniform vec2 u_offset;\n\
		\n\
		void main() {\n\
			vec2 uv = v_coord;\n\
			uv = uv / u_scale - u_offset;\n\
			gl_FragColor = texture2D(u_texture, uv);\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/scaleOffset",
		LGraphTextureScaleOffset
	);

	// Warp (distort a texture) *************************

	function LGraphTextureWarp() {
		this.addInput("in", "Texture");
		this.addInput("warp", "Texture");
		this.addInput("factor", "number");
		this.addOutput("out", "Texture");
		this.properties = {
			factor: 0.01,
			scale: [1,1],
			offset: [0,0],
			precision: LGraphTexture.DEFAULT
		};

		this._uniforms = { 
			u_texture: 0, 
			u_textureB: 1, 
			u_factor: 1, 
			u_scale: vec2.create(),
			u_offset: vec2.create()
		};
	}

	LGraphTextureWarp.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureWarp.title = "Warp";
	LGraphTextureWarp.desc = "Texture warp operation";

	LGraphTextureWarp.prototype.onExecute = function() {
		var tex = this.getInputData(0);

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		var texB = this.getInputData(1);

		var width = 512;
		var height = 512;
		var type = gl.UNSIGNED_BYTE;
		if (tex) {
			width = tex.width;
			height = tex.height;
			type = tex.type;
		} else if (texB) {
			width = texB.width;
			height = texB.height;
			type = texB.type;
		}

		if (!tex && !this._tex) {
			this._tex = new GL.Texture(width, height, {
				type:
					this.precision === LGraphTexture.LOW
						? gl.UNSIGNED_BYTE
						: gl.HIGH_PRECISION_FORMAT,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		} else {
			this._tex = LGraphTexture.getTargetTexture(
				tex || this._tex,
				this._tex,
				this.properties.precision
			);
		}

		var shader = this._shader;

		if (!shader) {
			shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureWarp.pixel_shader
			);
		}

		var factor = this.getInputData(2);
		if (factor != null) {
			this.properties.factor = factor;
		} else {
			factor = parseFloat(this.properties.factor);
		}
		var uniforms = this._uniforms;
		uniforms.u_factor = factor;
		uniforms.u_scale.set( this.properties.scale );
		uniforms.u_offset.set( this.properties.offset );

		this._tex.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.BLEND);
			if (tex) {
				tex.bind(0);
			}
			if (texB) {
				texB.bind(1);
			}
			var mesh = Mesh.getScreenQuad();
			shader
				.uniforms( uniforms )
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureWarp.pixel_shader =
		"precision highp float;\n\
		\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		varying vec2 v_coord;\n\
		uniform float u_factor;\n\
		uniform vec2 u_scale;\n\
		uniform vec2 u_offset;\n\
		\n\
		void main() {\n\
			vec2 uv = v_coord;\n\
			uv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;\n\
			gl_FragColor = texture2D(u_texture, uv);\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/warp", LGraphTextureWarp);

	//****************************************************

	// Texture to Viewport *****************************************
	function LGraphTextureToViewport() {
		this.addInput("Texture", "Texture");
		this.properties = {
			additive: false,
			antialiasing: false,
			filter: true,
			disable_alpha: false,
			gamma: 1.0,
			viewport: [0,0,1,1]
		};
		this.size[0] = 130;
	}

	LGraphTextureToViewport.title = "to Viewport";
	LGraphTextureToViewport.desc = "Texture to viewport";

	LGraphTextureToViewport._prev_viewport = new Float32Array(4);

	LGraphTextureToViewport.prototype.onDrawBackground = function( ctx )
	{
		if ( this.flags.collapsed || this.size[1] <= 40 )
			return;

		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		ctx.drawImage( ctx == gl ? tex : gl.canvas, 10,30, this.size[0] -20, this.size[1] -40);
	}

	LGraphTextureToViewport.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (this.properties.disable_alpha) {
			gl.disable(gl.BLEND);
		} else {
			gl.enable(gl.BLEND);
			if (this.properties.additive) {
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			} else {
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			}
		}

		gl.disable(gl.DEPTH_TEST);
		var gamma = this.properties.gamma || 1.0;
		if (this.isInputConnected(1)) {
			gamma = this.getInputData(1);
		}

		tex.setParameter(
			gl.TEXTURE_MAG_FILTER,
			this.properties.filter ? gl.LINEAR : gl.NEAREST
		);

		var old_viewport = LGraphTextureToViewport._prev_viewport;
		old_viewport.set( gl.viewport_data );
		var new_view = this.properties.viewport;
		gl.viewport( old_viewport[0] + old_viewport[2] * new_view[0], old_viewport[1] + old_viewport[3] * new_view[1], old_viewport[2] * new_view[2], old_viewport[3] * new_view[3] );
		var viewport = gl.getViewport(); //gl.getParameter(gl.VIEWPORT);

		if (this.properties.antialiasing) {
			if (!LGraphTextureToViewport._shader) {
				LGraphTextureToViewport._shader = new GL.Shader(
					GL.Shader.SCREEN_VERTEX_SHADER,
					LGraphTextureToViewport.aa_pixel_shader
				);
			}

			var mesh = Mesh.getScreenQuad();
			tex.bind(0);
			LGraphTextureToViewport._shader
				.uniforms({
					u_texture: 0,
					uViewportSize: [tex.width, tex.height],
					u_igamma: 1 / gamma,
					inverseVP: [1 / tex.width, 1 / tex.height]
				})
				.draw(mesh);
		} else {
			if (gamma != 1.0) {
				if (!LGraphTextureToViewport._gamma_shader) {
					LGraphTextureToViewport._gamma_shader = new GL.Shader(
						Shader.SCREEN_VERTEX_SHADER,
						LGraphTextureToViewport.gamma_pixel_shader
					);
				}
				tex.toViewport(LGraphTextureToViewport._gamma_shader, {
					u_texture: 0,
					u_igamma: 1 / gamma
				});
			} else {
				tex.toViewport();
			}
		}

		gl.viewport( old_viewport[0], old_viewport[1], old_viewport[2], old_viewport[3] );
	};

	LGraphTextureToViewport.prototype.onGetInputs = function() {
		return [["gamma", "number"]];
	};

	LGraphTextureToViewport.aa_pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 uViewportSize;\n\
		uniform vec2 inverseVP;\n\
		uniform float u_igamma;\n\
		#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\
		#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\
		#define FXAA_SPAN_MAX     8.0\n\
		\n\
		/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\n\
		vec4 applyFXAA(sampler2D tex, vec2 fragCoord)\n\
		{\n\
			vec4 color = vec4(0.0);\n\
			/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\n\
			vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\n\
			vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\n\
			vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\n\
			vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\n\
			vec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\n\
			vec3 luma = vec3(0.299, 0.587, 0.114);\n\
			float lumaNW = dot(rgbNW, luma);\n\
			float lumaNE = dot(rgbNE, luma);\n\
			float lumaSW = dot(rgbSW, luma);\n\
			float lumaSE = dot(rgbSE, luma);\n\
			float lumaM  = dot(rgbM,  luma);\n\
			float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\
			float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\
			\n\
			vec2 dir;\n\
			dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\
			dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\
			\n\
			float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\
			\n\
			float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\
			dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n\
			\n\
			vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \n\
				texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n\
			vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \n\
				texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\
			\n\
			//return vec4(rgbA,1.0);\n\
			float lumaB = dot(rgbB, luma);\n\
			if ((lumaB < lumaMin) || (lumaB > lumaMax))\n\
				color = vec4(rgbA, 1.0);\n\
			else\n\
				color = vec4(rgbB, 1.0);\n\
			if(u_igamma != 1.0)\n\
				color.xyz = pow( color.xyz, vec3(u_igamma) );\n\
			return color;\n\
		}\n\
		\n\
		void main() {\n\
		   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\n\
		}\n\
		";

	LGraphTextureToViewport.gamma_pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_igamma;\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord);\n\
			color.xyz = pow(color.xyz, vec3(u_igamma) );\n\
		   gl_FragColor = color;\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/toviewport",
		LGraphTextureToViewport
	);

	// Texture Copy *****************************************
	function LGraphTextureCopy() {
		this.addInput("Texture", "Texture");
		this.addOutput("", "Texture");
		this.properties = {
			size: 0,
			generate_mipmaps: false,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureCopy.title = "Copy";
	LGraphTextureCopy.desc = "Copy Texture";
	LGraphTextureCopy.widgets_info = {
		size: {
			widget: "combo",
			values: [0, 32, 64, 128, 256, 512, 1024, 2048]
		},
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureCopy.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex && !this._temp_texture) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		//copy the texture
		if (tex) {
			var width = tex.width;
			var height = tex.height;

			if (this.properties.size != 0) {
				width = this.properties.size;
				height = this.properties.size;
			}

			var temp = this._temp_texture;

			var type = tex.type;
			if (this.properties.precision === LGraphTexture.LOW) {
				type = gl.UNSIGNED_BYTE;
			} else if (this.properties.precision === LGraphTexture.HIGH) {
				type = gl.HIGH_PRECISION_FORMAT;
			}

			if (
				!temp ||
				temp.width != width ||
				temp.height != height ||
				temp.type != type
			) {
				var minFilter = gl.LINEAR;
				if (
					this.properties.generate_mipmaps &&
					isPowerOfTwo(width) &&
					isPowerOfTwo(height)
				) {
					minFilter = gl.LINEAR_MIPMAP_LINEAR;
				}
				this._temp_texture = new GL.Texture(width, height, {
					type: type,
					format: gl.RGBA,
					minFilter: minFilter,
					magFilter: gl.LINEAR
				});
			}
			tex.copyTo(this._temp_texture);

			if (this.properties.generate_mipmaps) {
				this._temp_texture.bind(0);
				gl.generateMipmap(this._temp_texture.texture_type);
				this._temp_texture.unbind(0);
			}
		}

		this.setOutputData(0, this._temp_texture);
	};

	LiteGraph.registerNodeType("texture/copy", LGraphTextureCopy);

	// Texture Downsample *****************************************
	function LGraphTextureDownsample() {
		this.addInput("Texture", "Texture");
		this.addOutput("", "Texture");
		this.properties = {
			iterations: 1,
			generate_mipmaps: false,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureDownsample.title = "Downsample";
	LGraphTextureDownsample.desc = "Downsample Texture";
	LGraphTextureDownsample.widgets_info = {
		iterations: { type: "number", step: 1, precision: 0, min: 0 },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureDownsample.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex && !this._temp_texture) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		//we do not allow any texture different than texture 2D
		if (!tex || tex.texture_type !== GL.TEXTURE_2D) {
			return;
		}

		if (this.properties.iterations < 1) {
			this.setOutputData(0, tex);
			return;
		}

		var shader = LGraphTextureDownsample._shader;
		if (!shader) {
			LGraphTextureDownsample._shader = shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureDownsample.pixel_shader
			);
		}

		var width = tex.width | 0;
		var height = tex.height | 0;
		var type = tex.type;
		if (this.properties.precision === LGraphTexture.LOW) {
			type = gl.UNSIGNED_BYTE;
		} else if (this.properties.precision === LGraphTexture.HIGH) {
			type = gl.HIGH_PRECISION_FORMAT;
		}
		var iterations = this.properties.iterations || 1;

		var origin = tex;
		var target = null;

		var temp = [];
		var options = {
			type: type,
			format: tex.format
		};

		var offset = vec2.create();
		var uniforms = {
			u_offset: offset
		};

		if (this._texture) {
			GL.Texture.releaseTemporary(this._texture);
		}

		for (var i = 0; i < iterations; ++i) {
			offset[0] = 1 / width;
			offset[1] = 1 / height;
			width = width >> 1 || 0;
			height = height >> 1 || 0;
			target = GL.Texture.getTemporary(width, height, options);
			temp.push(target);
			origin.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
			origin.copyTo(target, shader, uniforms);
			if (width == 1 && height == 1) {
				break;
			} //nothing else to do
			origin = target;
		}

		//keep the last texture used
		this._texture = temp.pop();

		//free the rest
		for (var i = 0; i < temp.length; ++i) {
			GL.Texture.releaseTemporary(temp[i]);
		}

		if (this.properties.generate_mipmaps) {
			this._texture.bind(0);
			gl.generateMipmap(this._texture.texture_type);
			this._texture.unbind(0);
		}

		this.setOutputData(0, this._texture);
	};

	LGraphTextureDownsample.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_offset;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = texture2D(u_texture, v_coord );\n\
			color += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\n\
			color += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\n\
			color += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\n\
		   gl_FragColor = color * 0.25;\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/downsample",
		LGraphTextureDownsample
	);



	function LGraphTextureResize() {
		this.addInput("Texture", "Texture");
		this.addOutput("", "Texture");
		this.properties = {
			size: [512,512],
			generate_mipmaps: false,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureResize.title = "Resize";
	LGraphTextureResize.desc = "Resize Texture";
	LGraphTextureResize.widgets_info = {
		iterations: { type: "number", step: 1, precision: 0, min: 0 },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureResize.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex && !this._temp_texture) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		//we do not allow any texture different than texture 2D
		if (!tex || tex.texture_type !== GL.TEXTURE_2D) {
			return;
		}

		var width = this.properties.size[0] | 0;
		var height = this.properties.size[1] | 0;
		if(width == 0)
			width = tex.width;
		if(height == 0)
			height = tex.height;
		var type = tex.type;
		if (this.properties.precision === LGraphTexture.LOW) {
			type = gl.UNSIGNED_BYTE;
		} else if (this.properties.precision === LGraphTexture.HIGH) {
			type = gl.HIGH_PRECISION_FORMAT;
		}

		if( !this._texture || this._texture.width != width || this._texture.height != height || this._texture.type != type )
			this._texture = new GL.Texture( width, height, { type: type } );

		tex.copyTo( this._texture );

		if (this.properties.generate_mipmaps) {
			this._texture.bind(0);
			gl.generateMipmap(this._texture.texture_type);
			this._texture.unbind(0);
		}

		this.setOutputData(0, this._texture);
	};

	LiteGraph.registerNodeType( "texture/resize", LGraphTextureResize );

	// Texture Average  *****************************************
	function LGraphTextureAverage() {
		this.addInput("Texture", "Texture");
		this.addOutput("tex", "Texture");
		this.addOutput("avg", "vec4");
		this.addOutput("lum", "number");
		this.properties = {
			use_previous_frame: true, //to avoid stalls 
			high_quality: false //to use as much pixels as possible
		};

		this._uniforms = {
			u_texture: 0,
			u_mipmap_offset: 0
		};
		this._luminance = new Float32Array(4);
	}

	LGraphTextureAverage.title = "Average";
	LGraphTextureAverage.desc =
		"Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.\n If high_quality is true, then it generates the mipmaps first and reads from the lower one.";

	LGraphTextureAverage.prototype.onExecute = function() {
		if (!this.properties.use_previous_frame) {
			this.updateAverage();
		}

		var v = this._luminance;
		this.setOutputData(0, this._temp_texture);
		this.setOutputData(1, v);
		this.setOutputData(2, (v[0] + v[1] + v[2]) / 3);
	};

	//executed before rendering the frame
	LGraphTextureAverage.prototype.onPreRenderExecute = function() {
		this.updateAverage();
	};

	LGraphTextureAverage.prototype.updateAverage = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (
			!this.isOutputConnected(0) &&
			!this.isOutputConnected(1) &&
			!this.isOutputConnected(2)
		) {
			return;
		} //saves work

		if (!LGraphTextureAverage._shader) {
			LGraphTextureAverage._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureAverage.pixel_shader
			);
			//creates 256 random numbers and stores them in two mat4
			var samples = new Float32Array(16);
			for (var i = 0; i < samples.length; ++i) {
				samples[i] = Math.random(); //poorly distributed samples
			}
			//upload only once
			LGraphTextureAverage._shader.uniforms({
				u_samples_a: samples.subarray(0, 16),
				u_samples_b: samples.subarray(16, 32)
			});
		}

		var temp = this._temp_texture;
		var type = gl.UNSIGNED_BYTE;
		if (tex.type != type) {
			//force floats, half floats cannot be read with gl.readPixels
			type = gl.FLOAT;
		}

		if (!temp || temp.type != type) {
			this._temp_texture = new GL.Texture(1, 1, {
				type: type,
				format: gl.RGBA,
				filter: gl.NEAREST
			});
		}

		this._uniforms.u_mipmap_offset = 0;

		if(this.properties.high_quality)
		{
			if( !this._temp_pot2_texture || this._temp_pot2_texture.type != type )
				this._temp_pot2_texture = new GL.Texture(512, 512, {
					type: type,
					format: gl.RGBA,
					minFilter: gl.LINEAR_MIPMAP_LINEAR,
					magFilter: gl.LINEAR
				});

			tex.copyTo( this._temp_pot2_texture );
			tex = this._temp_pot2_texture;
			tex.bind(0);
			gl.generateMipmap(GL.TEXTURE_2D);
			this._uniforms.u_mipmap_offset = 9;
		}

		var shader = LGraphTextureAverage._shader;
		var uniforms = this._uniforms;
		uniforms.u_mipmap_offset = this.properties.mipmap_offset;
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);
		this._temp_texture.drawTo(function() {
			tex.toViewport(shader, uniforms);
		});

		if (this.isOutputConnected(1) || this.isOutputConnected(2)) {
			var pixel = this._temp_texture.getPixels();
			if (pixel) {
				var v = this._luminance;
				var type = this._temp_texture.type;
				v.set(pixel);
				if (type == gl.UNSIGNED_BYTE) {
					vec4.scale(v, v, 1 / 255);
				} else if (
					type == GL.HALF_FLOAT ||
					type == GL.HALF_FLOAT_OES
				) {
					//no half floats possible, hard to read back unless copyed to a FLOAT texture, so temp_texture is always forced to FLOAT
				}
			}
		}
	};

	LGraphTextureAverage.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform mat4 u_samples_a;\n\
		uniform mat4 u_samples_b;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_mipmap_offset;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = vec4(0.0);\n\
			//random average\n\
			for(int i = 0; i < 4; ++i)\n\
				for(int j = 0; j < 4; ++j)\n\
				{\n\
					color += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\
					color += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\
				}\n\
		   gl_FragColor = color * 0.03125;\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/average", LGraphTextureAverage);



	// Computes operation between pixels (max, min)  *****************************************
	function LGraphTextureMinMax() {
		this.addInput("Texture", "Texture");
		this.addOutput("min_t", "Texture");
		this.addOutput("max_t", "Texture");
		this.addOutput("min", "vec4");
		this.addOutput("max", "vec4");
		this.properties = {
			mode: "max",
			use_previous_frame: true //to avoid stalls 
		};

		this._uniforms = {
			u_texture: 0
		};

		this._max = new Float32Array(4);
		this._min = new Float32Array(4);

		this._textures_chain = [];
	}

	LGraphTextureMinMax.widgets_info = {
		mode: { widget: "combo", values: ["min","max","avg"] }
	};

	LGraphTextureMinMax.title = "MinMax";
	LGraphTextureMinMax.desc = "Compute the scene min max";

	LGraphTextureMinMax.prototype.onExecute = function() {
		if (!this.properties.use_previous_frame) {
			this.update();
		}

		this.setOutputData(0, this._temp_texture);
		this.setOutputData(1, this._luminance);
	};

	//executed before rendering the frame
	LGraphTextureMinMax.prototype.onPreRenderExecute = function() {
		this.update();
	};

	LGraphTextureMinMax.prototype.update = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if ( !this.isOutputConnected(0) && !this.isOutputConnected(1) ) {
			return;
		} //saves work

		if (!LGraphTextureMinMax._shader) {
			LGraphTextureMinMax._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureMinMax.pixel_shader );
		}

		var temp = this._temp_texture;
		var type = gl.UNSIGNED_BYTE;
		if (tex.type != type) {
			//force floats, half floats cannot be read with gl.readPixels
			type = gl.FLOAT;
		}

		var size = 512;

		if( !this._textures_chain.length || this._textures_chain[0].type != type )
		{
			var index = 0;
			while(i)
			{
				this._textures_chain[i] = new GL.Texture( size, size, {
					type: type,
					format: gl.RGBA,
					filter: gl.NEAREST
				});
				size = size >> 2;
				i++;
				if(size == 1)
					break;
			}
		}

		tex.copyTo( this._textures_chain[0] );
		var prev = this._textures_chain[0];
		for(var i = 1; i <= this._textures_chain.length; ++i)
		{
			var tex = this._textures_chain[i];

			prev = tex;				
		}

		var shader = LGraphTextureMinMax._shader;
		var uniforms = this._uniforms;
		uniforms.u_mipmap_offset = this.properties.mipmap_offset;
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);
		this._temp_texture.drawTo(function() {
			tex.toViewport(shader, uniforms);
		});
	};

	LGraphTextureMinMax.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform mat4 u_samples_a;\n\
		uniform mat4 u_samples_b;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_mipmap_offset;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = vec4(0.0);\n\
			//random average\n\
			for(int i = 0; i < 4; ++i)\n\
				for(int j = 0; j < 4; ++j)\n\
				{\n\
					color += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\
					color += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\
				}\n\
		   gl_FragColor = color * 0.03125;\n\
		}\n\
		";

	//LiteGraph.registerNodeType("texture/clustered_operation", LGraphTextureClusteredOperation);


	function LGraphTextureTemporalSmooth() {
		this.addInput("in", "Texture");
		this.addInput("factor", "Number");
		this.addOutput("out", "Texture");
		this.properties = { factor: 0.5 };
		this._uniforms = {
			u_texture: 0,
			u_textureB: 1,
			u_factor: this.properties.factor
		};
	}

	LGraphTextureTemporalSmooth.title = "Smooth";
	LGraphTextureTemporalSmooth.desc = "Smooth texture over time";

	LGraphTextureTemporalSmooth.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex || !this.isOutputConnected(0)) {
			return;
		}

		if (!LGraphTextureTemporalSmooth._shader) {
			LGraphTextureTemporalSmooth._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureTemporalSmooth.pixel_shader
			);
		}

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.type != tex.type ||
			temp.width != tex.width ||
			temp.height != tex.height
		) {
			var options = {
				type: tex.type,
				format: gl.RGBA,
				filter: gl.NEAREST
			};
			this._temp_texture = new GL.Texture(tex.width, tex.height, options );
			this._temp_texture2 = new GL.Texture(tex.width, tex.height, options );
			tex.copyTo(this._temp_texture2);
		}

		var tempA = this._temp_texture;
		var tempB = this._temp_texture2;

		var shader = LGraphTextureTemporalSmooth._shader;
		var uniforms = this._uniforms;
		uniforms.u_factor = 1.0 - this.getInputOrProperty("factor");

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		tempA.drawTo(function() {
			tempB.bind(1);
			tex.toViewport(shader, uniforms);
		});

		this.setOutputData(0, tempA);

		//swap
		this._temp_texture = tempB;
		this._temp_texture2 = tempA;
	};

	LGraphTextureTemporalSmooth.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_factor;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			gl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );\n\
		}\n\
		";

	LiteGraph.registerNodeType( "texture/temporal_smooth", LGraphTextureTemporalSmooth );


	function LGraphTextureLinearAvgSmooth() {
		this.addInput("in", "Texture");
		this.addOutput("avg", "Texture");
		this.addOutput("array", "Texture");
		this.properties = { samples: 64, frames_interval: 1 };
		this._uniforms = {
			u_texture: 0,
			u_textureB: 1,
			u_samples: this.properties.samples,
			u_isamples: 1/this.properties.samples
		};
		this.frame = 0;
	}

	LGraphTextureLinearAvgSmooth.title = "Lineal Avg Smooth";
	LGraphTextureLinearAvgSmooth.desc = "Smooth texture linearly over time";

	LGraphTextureLinearAvgSmooth["@samples"] = { type: "number", min: 1, max: 64, step: 1, precision: 1 };

	LGraphTextureLinearAvgSmooth.prototype.getPreviewTexture = function()
	{
		return this._temp_texture2;
	}

	LGraphTextureLinearAvgSmooth.prototype.onExecute = function() {

		var tex = this.getInputData(0);
		if (!tex || !this.isOutputConnected(0)) {
			return;
		}

		if (!LGraphTextureLinearAvgSmooth._shader) {
			LGraphTextureLinearAvgSmooth._shader_copy = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearAvgSmooth.pixel_shader_copy );
			LGraphTextureLinearAvgSmooth._shader_avg = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearAvgSmooth.pixel_shader_avg );
		}

		var samples = Math.clamp(this.properties.samples,0,64);
		var frame = this.frame;
		var interval = this.properties.frames_interval;

		if( interval == 0 || frame % interval == 0 )
		{
			var temp = this._temp_texture;
			if ( !temp || temp.type != tex.type || temp.width != samples ) {
				var options = {
					type: tex.type,
					format: gl.RGBA,
					filter: gl.NEAREST
				};
				this._temp_texture = new GL.Texture( samples, 1, options );
				this._temp_texture2 = new GL.Texture( samples, 1, options );
				this._temp_texture_out = new GL.Texture( 1, 1, options );
			}

			var tempA = this._temp_texture;
			var tempB = this._temp_texture2;

			var shader_copy = LGraphTextureLinearAvgSmooth._shader_copy;
			var shader_avg = LGraphTextureLinearAvgSmooth._shader_avg;
			var uniforms = this._uniforms;
			uniforms.u_samples = samples;
			uniforms.u_isamples = 1.0 / samples;

			gl.disable(gl.BLEND);
			gl.disable(gl.DEPTH_TEST);
			tempA.drawTo(function() {
				tempB.bind(1);
				tex.toViewport( shader_copy, uniforms );
			});

			this._temp_texture_out.drawTo(function() {
				tempA.toViewport( shader_avg, uniforms );
			});

			this.setOutputData( 0, this._temp_texture_out );

			//swap
			this._temp_texture = tempB;
			this._temp_texture2 = tempA;
		}
		else
			this.setOutputData(0, this._temp_texture_out);
		this.setOutputData(1, this._temp_texture2);
		this.frame++;
	};

	LGraphTextureLinearAvgSmooth.pixel_shader_copy =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_isamples;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			if( v_coord.x <= u_isamples )\n\
				gl_FragColor = texture2D( u_texture, vec2(0.5) );\n\
			else\n\
				gl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );\n\
		}\n\
		";

	LGraphTextureLinearAvgSmooth.pixel_shader_avg =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform int u_samples;\n\
		uniform float u_isamples;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = vec4(0.0);\n\
			for(int i = 0; i < 64; ++i)\n\
			{\n\
				color += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );\n\
				if(i == (u_samples - 1))\n\
					break;\n\
			}\n\
			gl_FragColor = color * u_isamples;\n\
		}\n\
		";


	LiteGraph.registerNodeType( "texture/linear_avg_smooth", LGraphTextureLinearAvgSmooth );

	// Image To Texture *****************************************
	function LGraphImageToTexture() {
		this.addInput("Image", "image");
		this.addOutput("", "Texture");
		this.properties = {};
	}

	LGraphImageToTexture.title = "Image to Texture";
	LGraphImageToTexture.desc = "Uploads an image to the GPU";
	//LGraphImageToTexture.widgets_info = { size: { widget:"combo", values:[0,32,64,128,256,512,1024,2048]} };

	LGraphImageToTexture.prototype.onExecute = function() {
		var img = this.getInputData(0);
		if (!img) {
			return;
		}

		var width = img.videoWidth || img.width;
		var height = img.videoHeight || img.height;

		//this is in case we are using a webgl canvas already, no need to reupload it
		if (img.gltexture) {
			this.setOutputData(0, img.gltexture);
			return;
		}

		var temp = this._temp_texture;
		if (!temp || temp.width != width || temp.height != height) {
			this._temp_texture = new GL.Texture(width, height, {
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		try {
			this._temp_texture.uploadImage(img);
		} catch (err) {
			console.error(
				"image comes from an unsafe location, cannot be uploaded to webgl: " +
					err
			);
			return;
		}

		this.setOutputData(0, this._temp_texture);
	};

	LiteGraph.registerNodeType(
		"texture/imageToTexture",
		LGraphImageToTexture
	);

	// Texture LUT *****************************************
	function LGraphTextureLUT() {
		this.addInput("Texture", "Texture");
		this.addInput("LUT", "Texture");
		this.addInput("Intensity", "number");
		this.addOutput("", "Texture");
		this.properties = { enabled: true, intensity: 1, precision: LGraphTexture.DEFAULT, texture: null };

		if (!LGraphTextureLUT._shader) {
			LGraphTextureLUT._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, LGraphTextureLUT.pixel_shader );
		}
	}

	LGraphTextureLUT.widgets_info = {
		texture: { widget: "texture" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureLUT.title = "LUT";
	LGraphTextureLUT.desc = "Apply LUT to Texture";

	LGraphTextureLUT.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === false) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		var lut_tex = this.getInputData(1);

		if (!lut_tex) {
			lut_tex = LGraphTexture.getTexture(this.properties.texture);
		}

		if (!lut_tex) {
			this.setOutputData(0, tex);
			return;
		}

		lut_tex.bind(0);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(
			gl.TEXTURE_2D,
			gl.TEXTURE_WRAP_S,
			gl.CLAMP_TO_EDGE
		);
		gl.texParameteri(
			gl.TEXTURE_2D,
			gl.TEXTURE_WRAP_T,
			gl.CLAMP_TO_EDGE
		);
		gl.bindTexture(gl.TEXTURE_2D, null);

		var intensity = this.properties.intensity;
		if (this.isInputConnected(2)) {
			this.properties.intensity = intensity = this.getInputData(2);
		}

		this._tex = LGraphTexture.getTargetTexture(
			tex,
			this._tex,
			this.properties.precision
		);

		//var mesh = Mesh.getScreenQuad();

		this._tex.drawTo(function() {
			lut_tex.bind(1);
			tex.toViewport(LGraphTextureLUT._shader, {
				u_texture: 0,
				u_textureB: 1,
				u_amount: intensity
			});
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureLUT.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_amount;\n\
		\n\
		void main() {\n\
			 lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\
			 mediump float blueColor = textureColor.b * 63.0;\n\
			 mediump vec2 quad1;\n\
			 quad1.y = floor(floor(blueColor) / 8.0);\n\
			 quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\
			 mediump vec2 quad2;\n\
			 quad2.y = floor(ceil(blueColor) / 8.0);\n\
			 quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\
			 highp vec2 texPos1;\n\
			 texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\
			 texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\
			 highp vec2 texPos2;\n\
			 texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\
			 texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\
			 lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\
			 lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\
			 lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\
			 gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/LUT", LGraphTextureLUT);


	// Texture LUT *****************************************
	function LGraphTextureEncode() {
		this.addInput("Texture", "Texture");
		this.addInput("Atlas", "Texture");
		this.addOutput("", "Texture");
		this.properties = { enabled: true, num_row_symbols: 4, symbol_size: 16, brightness: 1, colorize: false, filter: false, invert: false, precision: LGraphTexture.DEFAULT, generate_mipmaps: false, texture: null };

		if (!LGraphTextureEncode._shader) {
			LGraphTextureEncode._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, LGraphTextureEncode.pixel_shader );
		}

		this._uniforms = {
				u_texture: 0,
				u_textureB: 1,
				u_row_simbols: 4,
				u_simbol_size: 16,
				u_res: vec2.create()
		};
	}

	LGraphTextureEncode.widgets_info = {
		texture: { widget: "texture" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureEncode.title = "Encode";
	LGraphTextureEncode.desc = "Apply a texture atlas to encode a texture";

	LGraphTextureEncode.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === false) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		var symbols_tex = this.getInputData(1);

		if (!symbols_tex) {
			symbols_tex = LGraphTexture.getTexture(this.properties.texture);
		}

		if (!symbols_tex) {
			this.setOutputData(0, tex);
			return;
		}

		symbols_tex.bind(0);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.bindTexture(gl.TEXTURE_2D, null);

		var uniforms = this._uniforms;
		uniforms.u_row_simbols = Math.floor(this.properties.num_row_symbols);
		uniforms.u_symbol_size = this.properties.symbol_size;
		uniforms.u_brightness = this.properties.brightness;
		uniforms.u_invert = this.properties.invert ? 1 : 0;
		uniforms.u_colorize = this.properties.colorize ? 1 : 0;

		this._tex = LGraphTexture.getTargetTexture( tex, this._tex, this.properties.precision );
		uniforms.u_res[0] = this._tex.width;
		uniforms.u_res[1] = this._tex.height;
		this._tex.bind(0);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		this._tex.drawTo(function() {
			symbols_tex.bind(1);
			tex.toViewport(LGraphTextureEncode._shader, uniforms);
		});

		if (this.properties.generate_mipmaps) {
			this._tex.bind(0);
			gl.generateMipmap(this._tex.texture_type);
			this._tex.unbind(0);
		}

		this.setOutputData(0, this._tex);
	};

	LGraphTextureEncode.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_row_simbols;\n\
		uniform float u_symbol_size;\n\
		uniform float u_brightness;\n\
		uniform float u_invert;\n\
		uniform float u_colorize;\n\
		uniform vec2 u_res;\n\
		\n\
		void main() {\n\
			vec2 total_symbols = u_res / u_symbol_size;\n\
			vec2 uv = floor(v_coord * total_symbols) / total_symbols; //pixelate \n\
			vec2 local_uv = mod(v_coord * u_res, u_symbol_size) / u_symbol_size;\n\
			lowp vec4 textureColor = texture2D(u_texture, uv );\n\
			float lum = clamp(u_brightness * (textureColor.x + textureColor.y + textureColor.z)/3.0,0.0,1.0);\n\
			if( u_invert == 1.0 ) lum = 1.0 - lum;\n\
			float index = floor( lum * (u_row_simbols * u_row_simbols - 1.0));\n\
			float col = mod( index, u_row_simbols );\n\
			float row = u_row_simbols - floor( index / u_row_simbols ) - 1.0;\n\
			vec2 simbol_uv = ( vec2( col, row ) + local_uv ) / u_row_simbols;\n\
			vec4 color = texture2D( u_textureB, simbol_uv );\n\
			if(u_colorize == 1.0)\n\
				color *= textureColor;\n\
			gl_FragColor = color;\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/encode", LGraphTextureEncode);

	// Texture Channels *****************************************
	function LGraphTextureChannels() {
		this.addInput("Texture", "Texture");

		this.addOutput("R", "Texture");
		this.addOutput("G", "Texture");
		this.addOutput("B", "Texture");
		this.addOutput("A", "Texture");

		//this.properties = { use_single_channel: true };
		if (!LGraphTextureChannels._shader) {
			LGraphTextureChannels._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureChannels.pixel_shader
			);
		}
	}

	LGraphTextureChannels.title = "Texture to Channels";
	LGraphTextureChannels.desc = "Split texture channels";

	LGraphTextureChannels.prototype.onExecute = function() {
		var texA = this.getInputData(0);
		if (!texA) {
			return;
		}

		if (!this._channels) {
			this._channels = Array(4);
		}

		//var format = this.properties.use_single_channel ? gl.LUMINANCE : gl.RGBA; //not supported by WebGL1
		var format = gl.RGB;
		var connections = 0;
		for (var i = 0; i < 4; i++) {
			if (this.isOutputConnected(i)) {
				if (
					!this._channels[i] ||
					this._channels[i].width != texA.width ||
					this._channels[i].height != texA.height ||
					this._channels[i].type != texA.type ||
					this._channels[i].format != format
				) {
					this._channels[i] = new GL.Texture(
						texA.width,
						texA.height,
						{
							type: texA.type,
							format: format,
							filter: gl.LINEAR
						}
					);
				}
				connections++;
			} else {
				this._channels[i] = null;
			}
		}

		if (!connections) {
			return;
		}

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		var shader = LGraphTextureChannels._shader;
		var masks = [
			[1, 0, 0, 0],
			[0, 1, 0, 0],
			[0, 0, 1, 0],
			[0, 0, 0, 1]
		];

		for (var i = 0; i < 4; i++) {
			if (!this._channels[i]) {
				continue;
			}

			this._channels[i].drawTo(function() {
				texA.bind(0);
				shader
					.uniforms({ u_texture: 0, u_mask: masks[i] })
					.draw(mesh);
			});
			this.setOutputData(i, this._channels[i]);
		}
	};

	LGraphTextureChannels.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec4 u_mask;\n\
		\n\
		void main() {\n\
		   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/textureChannels",
		LGraphTextureChannels
	);

	// Texture Channels to Texture *****************************************
	function LGraphChannelsTexture() {
		this.addInput("R", "Texture");
		this.addInput("G", "Texture");
		this.addInput("B", "Texture");
		this.addInput("A", "Texture");

		this.addOutput("Texture", "Texture");

		this.properties = {
			precision: LGraphTexture.DEFAULT,
			R: 1,
			G: 1,
			B: 1,
			A: 1
		};
		this._color = vec4.create();
		this._uniforms = {
			u_textureR: 0,
			u_textureG: 1,
			u_textureB: 2,
			u_textureA: 3,
			u_color: this._color
		};
	}

	LGraphChannelsTexture.title = "Channels to Texture";
	LGraphChannelsTexture.desc = "Split texture channels";
	LGraphChannelsTexture.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphChannelsTexture.prototype.onExecute = function() {
		var white = LGraphTexture.getWhiteTexture();
		var texR = this.getInputData(0) || white;
		var texG = this.getInputData(1) || white;
		var texB = this.getInputData(2) || white;
		var texA = this.getInputData(3) || white;

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		if (!LGraphChannelsTexture._shader) {
			LGraphChannelsTexture._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphChannelsTexture.pixel_shader
			);
		}
		var shader = LGraphChannelsTexture._shader;

		var w = Math.max(texR.width, texG.width, texB.width, texA.width);
		var h = Math.max(
			texR.height,
			texG.height,
			texB.height,
			texA.height
		);
		var type =
			this.properties.precision == LGraphTexture.HIGH
				? LGraphTexture.HIGH_PRECISION_FORMAT
				: gl.UNSIGNED_BYTE;

		if (
			!this._texture ||
			this._texture.width != w ||
			this._texture.height != h ||
			this._texture.type != type
		) {
			this._texture = new GL.Texture(w, h, {
				type: type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		var color = this._color;
		color[0] = this.properties.R;
		color[1] = this.properties.G;
		color[2] = this.properties.B;
		color[3] = this.properties.A;
		var uniforms = this._uniforms;

		this._texture.drawTo(function() {
			texR.bind(0);
			texG.bind(1);
			texB.bind(2);
			texA.bind(3);
			shader.uniforms(uniforms).draw(mesh);
		});
		this.setOutputData(0, this._texture);
	};

	LGraphChannelsTexture.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_textureR;\n\
		uniform sampler2D u_textureG;\n\
		uniform sampler2D u_textureB;\n\
		uniform sampler2D u_textureA;\n\
		uniform vec4 u_color;\n\
		\n\
		void main() {\n\
		   gl_FragColor = u_color * vec4( \
					texture2D(u_textureR, v_coord).r,\
					texture2D(u_textureG, v_coord).r,\
					texture2D(u_textureB, v_coord).r,\
					texture2D(u_textureA, v_coord).r);\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/channelsTexture",
		LGraphChannelsTexture
	);

	// Texture Color *****************************************
	function LGraphTextureColor() {
		this.addOutput("Texture", "Texture");

		this._tex_color = vec4.create();
		this.properties = {
			color: vec4.create(),
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureColor.title = "Color";
	LGraphTextureColor.desc =
		"Generates a 1x1 texture with a constant color";

	LGraphTextureColor.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureColor.prototype.onDrawBackground = function(ctx) {
		var c = this.properties.color;
		ctx.fillStyle =
			"rgb(" +
			Math.floor(Math.clamp(c[0], 0, 1) * 255) +
			"," +
			Math.floor(Math.clamp(c[1], 0, 1) * 255) +
			"," +
			Math.floor(Math.clamp(c[2], 0, 1) * 255) +
			")";
		if (this.flags.collapsed) {
			this.boxcolor = ctx.fillStyle;
		} else {
			ctx.fillRect(0, 0, this.size[0], this.size[1]);
		}
	};

	LGraphTextureColor.prototype.onExecute = function() {
		var type =
			this.properties.precision == LGraphTexture.HIGH
				? LGraphTexture.HIGH_PRECISION_FORMAT
				: gl.UNSIGNED_BYTE;

		if (!this._tex || this._tex.type != type) {
			this._tex = new GL.Texture(1, 1, {
				format: gl.RGBA,
				type: type,
				minFilter: gl.NEAREST
			});
		}
		var color = this.properties.color;

		if (this.inputs) {
			for (var i = 0; i < this.inputs.length; i++) {
				var input = this.inputs[i];
				var v = this.getInputData(i);
				if (v === undefined) {
					continue;
				}
				switch (input.name) {
					case "RGB":
					case "RGBA":
						color.set(v);
						break;
					case "R":
						color[0] = v;
						break;
					case "G":
						color[1] = v;
						break;
					case "B":
						color[2] = v;
						break;
					case "A":
						color[3] = v;
						break;
				}
			}
		}

		if (vec4.sqrDist(this._tex_color, color) > 0.001) {
			this._tex_color.set(color);
			this._tex.fill(color);
		}
		this.setOutputData(0, this._tex);
	};

	LGraphTextureColor.prototype.onGetInputs = function() {
		return [
			["RGB", "vec3"],
			["RGBA", "vec4"],
			["R", "number"],
			["G", "number"],
			["B", "number"],
			["A", "number"]
		];
	};

	LiteGraph.registerNodeType("texture/color", LGraphTextureColor);

	// Texture Channels to Texture *****************************************
	function LGraphTextureGradient() {
		this.addInput("A", "color");
		this.addInput("B", "color");
		this.addOutput("Texture", "Texture");

		this.properties = {
			angle: 0,
			scale: 1,
			A: [0, 0, 0],
			B: [1, 1, 1],
			texture_size: 32
		};
		if (!LGraphTextureGradient._shader) {
			LGraphTextureGradient._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureGradient.pixel_shader
			);
		}

		this._uniforms = {
			u_angle: 0,
			u_colorA: vec3.create(),
			u_colorB: vec3.create()
		};
	}

	LGraphTextureGradient.title = "Gradient";
	LGraphTextureGradient.desc = "Generates a gradient";
	LGraphTextureGradient["@A"] = { type: "color" };
	LGraphTextureGradient["@B"] = { type: "color" };
	LGraphTextureGradient["@texture_size"] = {
		type: "enum",
		values: [32, 64, 128, 256, 512]
	};

	LGraphTextureGradient.prototype.onExecute = function() {
		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = GL.Mesh.getScreenQuad();
		var shader = LGraphTextureGradient._shader;

		var A = this.getInputData(0);
		if (!A) {
			A = this.properties.A;
		}
		var B = this.getInputData(1);
		if (!B) {
			B = this.properties.B;
		}

		//angle and scale
		for (var i = 2; i < this.inputs.length; i++) {
			var input = this.inputs[i];
			var v = this.getInputData(i);
			if (v === undefined) {
				continue;
			}
			this.properties[input.name] = v;
		}

		var uniforms = this._uniforms;
		this._uniforms.u_angle = this.properties.angle * DEG2RAD;
		this._uniforms.u_scale = this.properties.scale;
		vec3.copy(uniforms.u_colorA, A);
		vec3.copy(uniforms.u_colorB, B);

		var size = parseInt(this.properties.texture_size);
		if (!this._tex || this._tex.width != size) {
			this._tex = new GL.Texture(size, size, {
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		this._tex.drawTo(function() {
			shader.uniforms(uniforms).draw(mesh);
		});
		this.setOutputData(0, this._tex);
	};

	LGraphTextureGradient.prototype.onGetInputs = function() {
		return [["angle", "number"], ["scale", "number"]];
	};

	LGraphTextureGradient.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform float u_angle;\n\
		uniform float u_scale;\n\
		uniform vec3 u_colorA;\n\
		uniform vec3 u_colorB;\n\
		\n\
		vec2 rotate(vec2 v, float angle)\n\
		{\n\
			vec2 result;\n\
			float _cos = cos(angle);\n\
			float _sin = sin(angle);\n\
			result.x = v.x * _cos - v.y * _sin;\n\
			result.y = v.x * _sin + v.y * _cos;\n\
			return result;\n\
		}\n\
		void main() {\n\
			float f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\
			vec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\
		   gl_FragColor = vec4(color,1.0);\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/gradient", LGraphTextureGradient);

	// Texture Mix *****************************************
	function LGraphTextureMix() {
		this.addInput("A", "Texture");
		this.addInput("B", "Texture");
		this.addInput("Mixer", "Texture");

		this.addOutput("Texture", "Texture");
		this.properties = { factor: 0.5, size_from_biggest: true, invert: false, precision: LGraphTexture.DEFAULT };
		this._uniforms = {
			u_textureA: 0,
			u_textureB: 1,
			u_textureMix: 2,
			u_mix: vec4.create()
		};
	}

	LGraphTextureMix.title = "Mix";
	LGraphTextureMix.desc = "Generates a texture mixing two textures";

	LGraphTextureMix.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureMix.prototype.onExecute = function() {
		var texA = this.getInputData(0);

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, texA);
			return;
		}

		var texB = this.getInputData(1);
		if (!texA || !texB) {
			return;
		}

		var texMix = this.getInputData(2);

		var factor = this.getInputData(3);

		this._tex = LGraphTexture.getTargetTexture(
			this.properties.size_from_biggest && texB.width > texA.width ? texB : texA,
			this._tex,
			this.properties.precision
		);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		var shader = null;
		var uniforms = this._uniforms;
		if (texMix) {
			shader = LGraphTextureMix._shader_tex;
			if (!shader) {
				shader = LGraphTextureMix._shader_tex = new GL.Shader(
					Shader.SCREEN_VERTEX_SHADER,
					LGraphTextureMix.pixel_shader,
					{ MIX_TEX: "" }
				);
			}
		} else {
			shader = LGraphTextureMix._shader_factor;
			if (!shader) {
				shader = LGraphTextureMix._shader_factor = new GL.Shader(
					Shader.SCREEN_VERTEX_SHADER,
					LGraphTextureMix.pixel_shader
				);
			}
			var f = factor == null ? this.properties.factor : factor;
			uniforms.u_mix.set([f, f, f, f]);
		}

		var invert = this.properties.invert;

		this._tex.drawTo(function() {
			texA.bind( invert ? 1 : 0 );
			texB.bind( invert ? 0 : 1 );
			if (texMix) {
				texMix.bind(2);
			}
			shader.uniforms(uniforms).draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureMix.prototype.onGetInputs = function() {
		return [["factor", "number"]];
	};

	LGraphTextureMix.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_textureA;\n\
		uniform sampler2D u_textureB;\n\
		#ifdef MIX_TEX\n\
			uniform sampler2D u_textureMix;\n\
		#else\n\
			uniform vec4 u_mix;\n\
		#endif\n\
		\n\
		void main() {\n\
			#ifdef MIX_TEX\n\
			   vec4 f = texture2D(u_textureMix, v_coord);\n\
			#else\n\
			   vec4 f = u_mix;\n\
			#endif\n\
		   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/mix", LGraphTextureMix);

	// Texture Edges detection *****************************************
	function LGraphTextureEdges() {
		this.addInput("Tex.", "Texture");

		this.addOutput("Edges", "Texture");
		this.properties = {
			invert: true,
			threshold: false,
			factor: 1,
			precision: LGraphTexture.DEFAULT
		};

		if (!LGraphTextureEdges._shader) {
			LGraphTextureEdges._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureEdges.pixel_shader
			);
		}
	}

	LGraphTextureEdges.title = "Edges";
	LGraphTextureEdges.desc = "Detects edges";

	LGraphTextureEdges.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureEdges.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		this._tex = LGraphTexture.getTargetTexture(
			tex,
			this._tex,
			this.properties.precision
		);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		var shader = LGraphTextureEdges._shader;
		var invert = this.properties.invert;
		var factor = this.properties.factor;
		var threshold = this.properties.threshold ? 1 : 0;

		this._tex.drawTo(function() {
			tex.bind(0);
			shader
				.uniforms({
					u_texture: 0,
					u_isize: [1 / tex.width, 1 / tex.height],
					u_factor: factor,
					u_threshold: threshold,
					u_invert: invert ? 1 : 0
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureEdges.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_isize;\n\
		uniform int u_invert;\n\
		uniform float u_factor;\n\
		uniform float u_threshold;\n\
		\n\
		void main() {\n\
			vec4 center = texture2D(u_texture, v_coord);\n\
			vec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\
			vec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\
			vec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\
			vec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\
			vec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\
			diff *= u_factor;\n\
			if(u_invert == 1)\n\
				diff.xyz = vec3(1.0) - diff.xyz;\n\
			if( u_threshold == 0.0 )\n\
				gl_FragColor = vec4( diff.xyz, center.a );\n\
			else\n\
				gl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/edges", LGraphTextureEdges);

	// Texture Depth *****************************************
	function LGraphTextureDepthRange() {
		this.addInput("Texture", "Texture");
		this.addInput("Distance", "number");
		this.addInput("Range", "number");
		this.addOutput("Texture", "Texture");
		this.properties = {
			distance: 100,
			range: 50,
			only_depth: false,
			high_precision: false
		};
		this._uniforms = {
			u_texture: 0,
			u_distance: 100,
			u_range: 50,
			u_camera_planes: null
		};
	}

	LGraphTextureDepthRange.title = "Depth Range";
	LGraphTextureDepthRange.desc = "Generates a texture with a depth range";

	LGraphTextureDepthRange.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		var precision = gl.UNSIGNED_BYTE;
		if (this.properties.high_precision) {
			precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
		}

		if (
			!this._temp_texture ||
			this._temp_texture.type != precision ||
			this._temp_texture.width != tex.width ||
			this._temp_texture.height != tex.height
		) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: precision,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		var uniforms = this._uniforms;

		//iterations
		var distance = this.properties.distance;
		if (this.isInputConnected(1)) {
			distance = this.getInputData(1);
			this.properties.distance = distance;
		}

		var range = this.properties.range;
		if (this.isInputConnected(2)) {
			range = this.getInputData(2);
			this.properties.range = range;
		}

		uniforms.u_distance = distance;
		uniforms.u_range = range;

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		var mesh = Mesh.getScreenQuad();
		if (!LGraphTextureDepthRange._shader) {
			LGraphTextureDepthRange._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureDepthRange.pixel_shader
			);
			LGraphTextureDepthRange._shader_onlydepth = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureDepthRange.pixel_shader,
				{ ONLY_DEPTH: "" }
			);
		}
		var shader = this.properties.only_depth
			? LGraphTextureDepthRange._shader_onlydepth
			: LGraphTextureDepthRange._shader;

		//NEAR AND FAR PLANES
		var planes = null;
		if (tex.near_far_planes) {
			planes = tex.near_far_planes;
		} else if (window.LS && LS.Renderer._main_camera) {
			planes = LS.Renderer._main_camera._uniforms.u_camera_planes;
		} else {
			planes = [0.1, 1000];
		} //hardcoded
		uniforms.u_camera_planes = planes;

		this._temp_texture.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(mesh);
		});

		this._temp_texture.near_far_planes = planes;
		this.setOutputData(0, this._temp_texture);
	};

	LGraphTextureDepthRange.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_camera_planes;\n\
		uniform float u_distance;\n\
		uniform float u_range;\n\
		\n\
		float LinearDepth()\n\
		{\n\
			float zNear = u_camera_planes.x;\n\
			float zFar = u_camera_planes.y;\n\
			float depth = texture2D(u_texture, v_coord).x;\n\
			depth = depth * 2.0 - 1.0;\n\
			return zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\
		}\n\
		\n\
		void main() {\n\
			float depth = LinearDepth();\n\
			#ifdef ONLY_DEPTH\n\
			   gl_FragColor = vec4(depth);\n\
			#else\n\
				float diff = abs(depth * u_camera_planes.y - u_distance);\n\
				float dof = 1.0;\n\
				if(diff <= u_range)\n\
					dof = diff / u_range;\n\
			   gl_FragColor = vec4(dof);\n\
			#endif\n\
		}\n\
		";

	LiteGraph.registerNodeType( "texture/depth_range", LGraphTextureDepthRange );


	// Texture Depth *****************************************
	function LGraphTextureLinearDepth() {
		this.addInput("Texture", "Texture");
		this.addOutput("Texture", "Texture");
		this.properties = {
			precision: LGraphTexture.DEFAULT,
			invert: false
		};
		this._uniforms = {
			u_texture: 0,
			u_camera_planes: null, //filled later
			u_ires: vec2.create()
		};
	}

	LGraphTextureLinearDepth.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureLinearDepth.title = "Linear Depth";
	LGraphTextureLinearDepth.desc = "Creates a color texture with linear depth";

	LGraphTextureLinearDepth.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);
		if (!tex || (tex.format != gl.DEPTH_COMPONENT && tex.format != gl.DEPTH_STENCIL) ) {
			return;
		}

		var precision = this.properties.precision == LGraphTexture.HIGH ? gl.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;

		if ( !this._temp_texture || this._temp_texture.type != precision || this._temp_texture.width != tex.width || this._temp_texture.height != tex.height ) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: precision,
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		var uniforms = this._uniforms;
		uniforms.u_invert = this.properties.invert ? 1 : 0;

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		var mesh = Mesh.getScreenQuad();
		if(!LGraphTextureLinearDepth._shader)
			LGraphTextureLinearDepth._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearDepth.pixel_shader);
		var shader = LGraphTextureLinearDepth._shader;

		//NEAR AND FAR PLANES
		var planes = null;
		if (tex.near_far_planes) {
			planes = tex.near_far_planes;
		} else if (window.LS && LS.Renderer._main_camera) {
			planes = LS.Renderer._main_camera._uniforms.u_camera_planes;
		} else {
			planes = [0.1, 1000];
		} //hardcoded
		uniforms.u_camera_planes = planes;
		//uniforms.u_ires.set([1/tex.width, 1/tex.height]);
		uniforms.u_ires.set([0,0]);

		this._temp_texture.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(mesh);
		});

		this._temp_texture.near_far_planes = planes;
		this.setOutputData(0, this._temp_texture);
	};

	LGraphTextureLinearDepth.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_camera_planes;\n\
		uniform int u_invert;\n\
		uniform vec2 u_ires;\n\
		\n\
		void main() {\n\
			float zNear = u_camera_planes.x;\n\
			float zFar = u_camera_planes.y;\n\
			float depth = texture2D(u_texture, v_coord + u_ires*0.5).x * 2.0 - 1.0;\n\
			float f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\
			if( u_invert == 1 )\n\
				f = 1.0 - f;\n\
			gl_FragColor = vec4(vec3(f),1.0);\n\
		}\n\
		";

	LiteGraph.registerNodeType( "texture/linear_depth", LGraphTextureLinearDepth );

	// Texture Blur *****************************************
	function LGraphTextureBlur() {
		this.addInput("Texture", "Texture");
		this.addInput("Iterations", "number");
		this.addInput("Intensity", "number");
		this.addOutput("Blurred", "Texture");
		this.properties = {
			intensity: 1,
			iterations: 1,
			preserve_aspect: false,
			scale: [1, 1],
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureBlur.title = "Blur";
	LGraphTextureBlur.desc = "Blur a texture";

	LGraphTextureBlur.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureBlur.max_iterations = 20;

	LGraphTextureBlur.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._final_texture;

		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			//we need two textures to do the blurring
			//this._temp_texture = new GL.Texture( tex.width, tex.height, { type: tex.type, format: gl.RGBA, filter: gl.LINEAR });
			temp = this._final_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		//iterations
		var iterations = this.properties.iterations;
		if (this.isInputConnected(1)) {
			iterations = this.getInputData(1);
			this.properties.iterations = iterations;
		}
		iterations = Math.min(
			Math.floor(iterations),
			LGraphTextureBlur.max_iterations
		);
		if (iterations == 0) {
			//skip blurring
			this.setOutputData(0, tex);
			return;
		}

		var intensity = this.properties.intensity;
		if (this.isInputConnected(2)) {
			intensity = this.getInputData(2);
			this.properties.intensity = intensity;
		}

		//blur sometimes needs an aspect correction
		var aspect = LiteGraph.camera_aspect;
		if (!aspect && window.gl !== undefined) {
			aspect = gl.canvas.height / gl.canvas.width;
		}
		if (!aspect) {
			aspect = 1;
		}
		aspect = this.properties.preserve_aspect ? aspect : 1;

		var scale = this.properties.scale || [1, 1];
		tex.applyBlur(aspect * scale[0], scale[1], intensity, temp);
		for (var i = 1; i < iterations; ++i) {
			temp.applyBlur(
				aspect * scale[0] * (i + 1),
				scale[1] * (i + 1),
				intensity
			);
		}

		this.setOutputData(0, temp);
	};

	/*
LGraphTextureBlur.pixel_shader = "precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_offset;\n\
		uniform float u_intensity;\n\
		void main() {\n\
		   vec4 sum = vec4(0.0);\n\
		   vec4 center = texture2D(u_texture, v_coord);\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\n\
		   sum += center * 0.16/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\n\
		   gl_FragColor = u_intensity * sum;\n\
		}\n\
		";
*/

	LiteGraph.registerNodeType("texture/blur", LGraphTextureBlur);

	//Independent glow FX
	//based on https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/
	function FXGlow()
	{
		this.intensity = 0.5;
		this.persistence = 0.6;
		this.iterations = 8;
		this.threshold = 0.8;
		this.scale = 1;

		this.dirt_texture = null;
		this.dirt_factor = 0.5;

		this._textures = [];
		this._uniforms = {
			u_intensity: 1,
			u_texture: 0,
			u_glow_texture: 1,
			u_threshold: 0,
			u_texel_size: vec2.create()
		};
	}

	FXGlow.prototype.applyFX = function( tex, output_texture, glow_texture, average_texture ) {

		var width = tex.width;
		var height = tex.height;

		var texture_info = {
			format: tex.format,
			type: tex.type,
			minFilter: GL.LINEAR,
			magFilter: GL.LINEAR,
			wrap: gl.CLAMP_TO_EDGE
		};

		var uniforms = this._uniforms;
		var textures = this._textures;

		//cut
		var shader = FXGlow._cut_shader;
		if (!shader) {
			shader = FXGlow._cut_shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				FXGlow.cut_pixel_shader
			);
		}

		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);

		uniforms.u_threshold = this.threshold;
		var currentDestination = (textures[0] = GL.Texture.getTemporary(
			width,
			height,
			texture_info
		));
		tex.blit( currentDestination, shader.uniforms(uniforms) );
		var currentSource = currentDestination;

		var iterations = this.iterations;
		iterations = Math.clamp(iterations, 1, 16) | 0;
		var texel_size = uniforms.u_texel_size;
		var intensity = this.intensity;

		uniforms.u_intensity = 1;
		uniforms.u_delta = this.scale; //1

		//downscale/upscale shader
		var shader = FXGlow._shader;
		if (!shader) {
			shader = FXGlow._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				FXGlow.scale_pixel_shader
			);
		}

		var i = 1;
		//downscale
		for (; i < iterations; i++) {
			width = width >> 1;
			if ((height | 0) > 1) {
				height = height >> 1;
			}
			if (width < 2) {
				break;
			}
			currentDestination = textures[i] = GL.Texture.getTemporary(
				width,
				height,
				texture_info
			);
			texel_size[0] = 1 / currentSource.width;
			texel_size[1] = 1 / currentSource.height;
			currentSource.blit(
				currentDestination,
				shader.uniforms(uniforms)
			);
			currentSource = currentDestination;
		}

		//average
		if (average_texture) {
			texel_size[0] = 1 / currentSource.width;
			texel_size[1] = 1 / currentSource.height;
			uniforms.u_intensity = intensity;
			uniforms.u_delta = 1;
			currentSource.blit(average_texture, shader.uniforms(uniforms));
		}

		//upscale and blend
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.ONE, gl.ONE);
		uniforms.u_intensity = this.persistence;
		uniforms.u_delta = 0.5;

		// i-=2 => -1 to point to last element in array, -1 to go to texture above
		for ( i -= 2; i >= 0; i-- ) 
		{
			currentDestination = textures[i];
			textures[i] = null;
			texel_size[0] = 1 / currentSource.width;
			texel_size[1] = 1 / currentSource.height;
			currentSource.blit(
				currentDestination,
				shader.uniforms(uniforms)
			);
			GL.Texture.releaseTemporary(currentSource);
			currentSource = currentDestination;
		}
		gl.disable(gl.BLEND);

		//glow
		if (glow_texture) {
			currentSource.blit(glow_texture);
		}

		//final composition
		if ( output_texture ) {
			var final_texture = output_texture;
			var dirt_texture = this.dirt_texture;
			var dirt_factor = this.dirt_factor;
			uniforms.u_intensity = intensity;

			shader = dirt_texture
				? FXGlow._dirt_final_shader
				: FXGlow._final_shader;
			if (!shader) {
				if (dirt_texture) {
					shader = FXGlow._dirt_final_shader = new GL.Shader(
						GL.Shader.SCREEN_VERTEX_SHADER,
						FXGlow.final_pixel_shader,
						{ USE_DIRT: "" }
					);
				} else {
					shader = FXGlow._final_shader = new GL.Shader(
						GL.Shader.SCREEN_VERTEX_SHADER,
						FXGlow.final_pixel_shader
					);
				}
			}

			final_texture.drawTo(function() {
				tex.bind(0);
				currentSource.bind(1);
				if (dirt_texture) {
					shader.setUniform("u_dirt_factor", dirt_factor);
					shader.setUniform(
						"u_dirt_texture",
						dirt_texture.bind(2)
					);
				}
				shader.toViewport(uniforms);
			});
		}

		GL.Texture.releaseTemporary(currentSource);
	};

	FXGlow.cut_pixel_shader =
		"precision highp float;\n\
	varying vec2 v_coord;\n\
	uniform sampler2D u_texture;\n\
	uniform float u_threshold;\n\
	void main() {\n\
		gl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\n\
	}";

	FXGlow.scale_pixel_shader =
		"precision highp float;\n\
	varying vec2 v_coord;\n\
	uniform sampler2D u_texture;\n\
	uniform vec2 u_texel_size;\n\
	uniform float u_delta;\n\
	uniform float u_intensity;\n\
	\n\
	vec4 sampleBox(vec2 uv) {\n\
		vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\
		vec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\n\
		return s * 0.25;\n\
	}\n\
	void main() {\n\
		gl_FragColor = u_intensity * sampleBox( v_coord );\n\
	}";

	FXGlow.final_pixel_shader =
		"precision highp float;\n\
	varying vec2 v_coord;\n\
	uniform sampler2D u_texture;\n\
	uniform sampler2D u_glow_texture;\n\
	#ifdef USE_DIRT\n\
		uniform sampler2D u_dirt_texture;\n\
	#endif\n\
	uniform vec2 u_texel_size;\n\
	uniform float u_delta;\n\
	uniform float u_intensity;\n\
	uniform float u_dirt_factor;\n\
	\n\
	vec4 sampleBox(vec2 uv) {\n\
		vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\
		vec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\n\
		return s * 0.25;\n\
	}\n\
	void main() {\n\
		vec4 glow = sampleBox( v_coord );\n\
		#ifdef USE_DIRT\n\
			glow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\n\
		#endif\n\
		gl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\n\
	}";


	// Texture Glow *****************************************
	function LGraphTextureGlow() {
		this.addInput("in", "Texture");
		this.addInput("dirt", "Texture");
		this.addOutput("out", "Texture");
		this.addOutput("glow", "Texture");
		this.properties = {
			enabled: true,
			intensity: 1,
			persistence: 0.99,
			iterations: 16,
			threshold: 0,
			scale: 1,
			dirt_factor: 0.5,
			precision: LGraphTexture.DEFAULT
		};

		this.fx = new FXGlow();
	}

	LGraphTextureGlow.title = "Glow";
	LGraphTextureGlow.desc = "Filters a texture giving it a glow effect";

	LGraphTextureGlow.widgets_info = {
		iterations: {
			type: "number",
			min: 0,
			max: 16,
			step: 1,
			precision: 0
		},
		threshold: {
			type: "number",
			min: 0,
			max: 10,
			step: 0.01,
			precision: 2
		},
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureGlow.prototype.onGetInputs = function() {
		return [
			["enabled", "boolean"],
			["threshold", "number"],
			["intensity", "number"],
			["persistence", "number"],
			["iterations", "number"],
			["dirt_factor", "number"]
		];
	};

	LGraphTextureGlow.prototype.onGetOutputs = function() {
		return [["average", "Texture"]];
	};

	LGraphTextureGlow.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isAnyOutputConnected()) {
			return;
		} //saves work

		if (
			this.properties.precision === LGraphTexture.PASS_THROUGH ||
			this.getInputOrProperty("enabled") === false
		) {
			this.setOutputData(0, tex);
			return;
		}

		var width = tex.width;
		var height = tex.height;

		var fx = this.fx;
		fx.threshold = this.getInputOrProperty("threshold");
		fx.iterations = this.getInputOrProperty("iterations");
		fx.intensity = this.getInputOrProperty("intensity");
		fx.persistence = this.getInputOrProperty("persistence");
		fx.dirt_texture = this.getInputData(1);
		fx.dirt_factor = this.getInputOrProperty("dirt_factor");
		fx.scale = this.properties.scale;

		var type = LGraphTexture.getTextureType( this.properties.precision, tex );

		var average_texture = null;
		if (this.isOutputConnected(2)) {
			average_texture = this._average_texture;
			if (
				!average_texture ||
				average_texture.type != tex.type ||
				average_texture.format != tex.format
			) {
				average_texture = this._average_texture = new GL.Texture(
					1,
					1,
					{
						type: tex.type,
						format: tex.format,
						filter: gl.LINEAR
					}
				);
			}
		}

		var glow_texture = null;
		if (this.isOutputConnected(1)) {
			glow_texture = this._glow_texture;
			if (
				!glow_texture ||
				glow_texture.width != tex.width ||
				glow_texture.height != tex.height ||
				glow_texture.type != type ||
				glow_texture.format != tex.format
			) {
				glow_texture = this._glow_texture = new GL.Texture(
					tex.width,
					tex.height,
					{ type: type, format: tex.format, filter: gl.LINEAR }
				);
			}
		}

		var final_texture = null;
		if (this.isOutputConnected(0)) {
			final_texture = this._final_texture;
			if (
				!final_texture ||
				final_texture.width != tex.width ||
				final_texture.height != tex.height ||
				final_texture.type != type ||
				final_texture.format != tex.format
			) {
				final_texture = this._final_texture = new GL.Texture(
					tex.width,
					tex.height,
					{ type: type, format: tex.format, filter: gl.LINEAR }
				);
			}

		}

		//apply FX
		fx.applyFX(tex, final_texture, glow_texture, average_texture );

		if (this.isOutputConnected(0))
			this.setOutputData(0, final_texture);

		if (this.isOutputConnected(1))
			this.setOutputData(1, average_texture);

		if (this.isOutputConnected(2))
			this.setOutputData(2, glow_texture);
	};

	LiteGraph.registerNodeType("texture/glow", LGraphTextureGlow);

	// Texture Filter *****************************************
	function LGraphTextureKuwaharaFilter() {
		this.addInput("Texture", "Texture");
		this.addOutput("Filtered", "Texture");
		this.properties = { intensity: 1, radius: 5 };
	}

	LGraphTextureKuwaharaFilter.title = "Kuwahara Filter";
	LGraphTextureKuwaharaFilter.desc =
		"Filters a texture giving an artistic oil canvas painting";

	LGraphTextureKuwaharaFilter.max_radius = 10;
	LGraphTextureKuwaharaFilter._shaders = [];

	LGraphTextureKuwaharaFilter.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._temp_texture;

		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: tex.type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		//iterations
		var radius = this.properties.radius;
		radius = Math.min(
			Math.floor(radius),
			LGraphTextureKuwaharaFilter.max_radius
		);
		if (radius == 0) {
			//skip blurring
			this.setOutputData(0, tex);
			return;
		}

		var intensity = this.properties.intensity;

		//blur sometimes needs an aspect correction
		var aspect = LiteGraph.camera_aspect;
		if (!aspect && window.gl !== undefined) {
			aspect = gl.canvas.height / gl.canvas.width;
		}
		if (!aspect) {
			aspect = 1;
		}
		aspect = this.properties.preserve_aspect ? aspect : 1;

		if (!LGraphTextureKuwaharaFilter._shaders[radius]) {
			LGraphTextureKuwaharaFilter._shaders[radius] = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureKuwaharaFilter.pixel_shader,
				{ RADIUS: radius.toFixed(0) }
			);
		}

		var shader = LGraphTextureKuwaharaFilter._shaders[radius];
		var mesh = GL.Mesh.getScreenQuad();
		tex.bind(0);

		this._temp_texture.drawTo(function() {
			shader
				.uniforms({
					u_texture: 0,
					u_intensity: intensity,
					u_resolution: [tex.width, tex.height],
					u_iResolution: [1 / tex.width, 1 / tex.height]
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._temp_texture);
	};

	//from https://www.shadertoy.com/view/MsXSz4
	LGraphTextureKuwaharaFilter.pixel_shader =
		"\n\
precision highp float;\n\
varying vec2 v_coord;\n\
uniform sampler2D u_texture;\n\
uniform float u_intensity;\n\
uniform vec2 u_resolution;\n\
uniform vec2 u_iResolution;\n\
#ifndef RADIUS\n\
	#define RADIUS 7\n\
#endif\n\
void main() {\n\
\n\
	const int radius = RADIUS;\n\
	vec2 fragCoord = v_coord;\n\
	vec2 src_size = u_iResolution;\n\
	vec2 uv = v_coord;\n\
	float n = float((radius + 1) * (radius + 1));\n\
	int i;\n\
	int j;\n\
	vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\
	vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\
	vec3 c;\n\
	\n\
	for (int j = -radius; j <= 0; ++j)  {\n\
		for (int i = -radius; i <= 0; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m0 += c;\n\
			s0 += c * c;\n\
		}\n\
	}\n\
	\n\
	for (int j = -radius; j <= 0; ++j)  {\n\
		for (int i = 0; i <= radius; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m1 += c;\n\
			s1 += c * c;\n\
		}\n\
	}\n\
	\n\
	for (int j = 0; j <= radius; ++j)  {\n\
		for (int i = 0; i <= radius; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m2 += c;\n\
			s2 += c * c;\n\
		}\n\
	}\n\
	\n\
	for (int j = 0; j <= radius; ++j)  {\n\
		for (int i = -radius; i <= 0; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m3 += c;\n\
			s3 += c * c;\n\
		}\n\
	}\n\
	\n\
	float min_sigma2 = 1e+2;\n\
	m0 /= n;\n\
	s0 = abs(s0 / n - m0 * m0);\n\
	\n\
	float sigma2 = s0.r + s0.g + s0.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m0, 1.0);\n\
	}\n\
	\n\
	m1 /= n;\n\
	s1 = abs(s1 / n - m1 * m1);\n\
	\n\
	sigma2 = s1.r + s1.g + s1.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m1, 1.0);\n\
	}\n\
	\n\
	m2 /= n;\n\
	s2 = abs(s2 / n - m2 * m2);\n\
	\n\
	sigma2 = s2.r + s2.g + s2.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m2, 1.0);\n\
	}\n\
	\n\
	m3 /= n;\n\
	s3 = abs(s3 / n - m3 * m3);\n\
	\n\
	sigma2 = s3.r + s3.g + s3.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m3, 1.0);\n\
	}\n\
}\n\
";

	LiteGraph.registerNodeType(
		"texture/kuwahara",
		LGraphTextureKuwaharaFilter
	);

	// Texture  *****************************************
	function LGraphTextureXDoGFilter() {
		this.addInput("Texture", "Texture");
		this.addOutput("Filtered", "Texture");
		this.properties = {
			sigma: 1.4,
			k: 1.6,
			p: 21.7,
			epsilon: 79,
			phi: 0.017
		};
	}

	LGraphTextureXDoGFilter.title = "XDoG Filter";
	LGraphTextureXDoGFilter.desc =
		"Filters a texture giving an artistic ink style";

	LGraphTextureXDoGFilter.max_radius = 10;
	LGraphTextureXDoGFilter._shaders = [];

	LGraphTextureXDoGFilter.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: tex.type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		if (!LGraphTextureXDoGFilter._xdog_shader) {
			LGraphTextureXDoGFilter._xdog_shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureXDoGFilter.xdog_pixel_shader
			);
		}
		var shader = LGraphTextureXDoGFilter._xdog_shader;
		var mesh = GL.Mesh.getScreenQuad();

		var sigma = this.properties.sigma;
		var k = this.properties.k;
		var p = this.properties.p;
		var epsilon = this.properties.epsilon;
		var phi = this.properties.phi;
		tex.bind(0);
		this._temp_texture.drawTo(function() {
			shader
				.uniforms({
					src: 0,
					sigma: sigma,
					k: k,
					p: p,
					epsilon: epsilon,
					phi: phi,
					cvsWidth: tex.width,
					cvsHeight: tex.height
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._temp_texture);
	};

	//from https://github.com/RaymondMcGuire/GPU-Based-Image-Processing-Tools/blob/master/lib_webgl/scripts/main.js
	LGraphTextureXDoGFilter.xdog_pixel_shader =
		"\n\
precision highp float;\n\
uniform sampler2D src;\n\n\
uniform float cvsHeight;\n\
uniform float cvsWidth;\n\n\
uniform float sigma;\n\
uniform float k;\n\
uniform float p;\n\
uniform float epsilon;\n\
uniform float phi;\n\
varying vec2 v_coord;\n\n\
float cosh(float val)\n\
{\n\
	float tmp = exp(val);\n\
	float cosH = (tmp + 1.0 / tmp) / 2.0;\n\
	return cosH;\n\
}\n\n\
float tanh(float val)\n\
{\n\
	float tmp = exp(val);\n\
	float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n\
	return tanH;\n\
}\n\n\
float sinh(float val)\n\
{\n\
	float tmp = exp(val);\n\
	float sinH = (tmp - 1.0 / tmp) / 2.0;\n\
	return sinH;\n\
}\n\n\
void main(void){\n\
	vec3 destColor = vec3(0.0);\n\
	float tFrag = 1.0 / cvsHeight;\n\
	float sFrag = 1.0 / cvsWidth;\n\
	vec2 Frag = vec2(sFrag,tFrag);\n\
	vec2 uv = gl_FragCoord.st;\n\
	float twoSigmaESquared = 2.0 * sigma * sigma;\n\
	float twoSigmaRSquared = twoSigmaESquared * k * k;\n\
	int halfWidth = int(ceil( 1.0 * sigma * k ));\n\n\
	const int MAX_NUM_ITERATION = 99999;\n\
	vec2 sum = vec2(0.0);\n\
	vec2 norm = vec2(0.0);\n\n\
	for(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){\n\
		if(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}\n\
		int i = int(cnt / (2*halfWidth+1)) - halfWidth;\n\
		int j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);\n\n\
		float d = length(vec2(i,j));\n\
		vec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), \n\
							exp( -d * d / twoSigmaRSquared ));\n\n\
		vec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;\n\n\
		norm += kernel;\n\
		sum += kernel * L;\n\
	}\n\n\
	sum /= norm;\n\n\
	float H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);\n\
	float edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));\n\
	destColor = vec3(edge);\n\
	gl_FragColor = vec4(destColor, 1.0);\n\
}";

	LiteGraph.registerNodeType("texture/xDoG", LGraphTextureXDoGFilter);

	// Texture Webcam *****************************************
	function LGraphTextureWebcam() {
		this.addOutput("Webcam", "Texture");
		this.properties = { texture_name: "", facingMode: "user" };
		this.boxcolor = "black";
		this.version = 0;
	}

	LGraphTextureWebcam.title = "Webcam";
	LGraphTextureWebcam.desc = "Webcam texture";

	LGraphTextureWebcam.is_webcam_open = false;

	LGraphTextureWebcam.prototype.openStream = function() {
		if (!navigator.getUserMedia) {
			//console.log('getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags');
			return;
		}

		this._waiting_confirmation = true;

		// Not showing vendor prefixes.
		var constraints = {
			audio: false,
			video: { facingMode: this.properties.facingMode }
		};
		navigator.mediaDevices
			.getUserMedia(constraints)
			.then(this.streamReady.bind(this))
			.catch(onFailSoHard);

		var that = this;
		function onFailSoHard(e) {
			LGraphTextureWebcam.is_webcam_open = false;
			console.log("Webcam rejected", e);
			that._webcam_stream = false;
			that.boxcolor = "red";
			that.trigger("stream_error");
		}
	};

	LGraphTextureWebcam.prototype.closeStream = function() {
		if (this._webcam_stream) {
			var tracks = this._webcam_stream.getTracks();
			if (tracks.length) {
				for (var i = 0; i < tracks.length; ++i) {
					tracks[i].stop();
				}
			}
			LGraphTextureWebcam.is_webcam_open = false;
			this._webcam_stream = null;
			this._video = null;
			this.boxcolor = "black";
			this.trigger("stream_closed");
		}
	};

	LGraphTextureWebcam.prototype.streamReady = function(localMediaStream) {
		this._webcam_stream = localMediaStream;
		//this._waiting_confirmation = false;
		this.boxcolor = "green";
		var video = this._video;
		if (!video) {
			video = document.createElement("video");
			video.autoplay = true;
			video.srcObject = localMediaStream;
			this._video = video;
			//document.body.appendChild( video ); //debug
			//when video info is loaded (size and so)
			video.onloadedmetadata = function(e) {
				// Ready to go. Do some stuff.
				LGraphTextureWebcam.is_webcam_open = true;
				console.log(e);
			};
		}
		this.trigger("stream_ready", video);
	};

	LGraphTextureWebcam.prototype.onPropertyChanged = function(
		name,
		value
	) {
		if (name == "facingMode") {
			this.properties.facingMode = value;
			this.closeStream();
			this.openStream();
		}
	};

	LGraphTextureWebcam.prototype.onRemoved = function() {
		if (!this._webcam_stream) {
			return;
		}

		var tracks = this._webcam_stream.getTracks();
		if (tracks.length) {
			for (var i = 0; i < tracks.length; ++i) {
				tracks[i].stop();
			}
		}

		this._webcam_stream = null;
		this._video = null;
	};

	LGraphTextureWebcam.prototype.onDrawBackground = function(ctx) {
		if (this.flags.collapsed || this.size[1] <= 20) {
			return;
		}

		if (!this._video) {
			return;
		}

		//render to graph canvas
		ctx.save();
		if (!ctx.webgl) {
			//reverse image
			ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);
		} else {
			if (this._video_texture) {
				ctx.drawImage(
					this._video_texture,
					0,
					0,
					this.size[0],
					this.size[1]
				);
			}
		}
		ctx.restore();
	};

	LGraphTextureWebcam.prototype.onExecute = function() {
		if (this._webcam_stream == null && !this._waiting_confirmation) {
			this.openStream();
		}

		if (!this._video || !this._video.videoWidth) {
			return;
		}

		var width = this._video.videoWidth;
		var height = this._video.videoHeight;

		var temp = this._video_texture;
		if (!temp || temp.width != width || temp.height != height) {
			this._video_texture = new GL.Texture(width, height, {
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		this._video_texture.uploadImage(this._video);
		this._video_texture.version = ++this.version;

		if (this.properties.texture_name) {
			var container = LGraphTexture.getTexturesContainer();
			container[this.properties.texture_name] = this._video_texture;
		}

		this.setOutputData(0, this._video_texture);
		for (var i = 1; i < this.outputs.length; ++i) {
			if (!this.outputs[i]) {
				continue;
			}
			switch (this.outputs[i].name) {
				case "width":
					this.setOutputData(i, this._video.videoWidth);
					break;
				case "height":
					this.setOutputData(i, this._video.videoHeight);
					break;
			}
		}
	};

	LGraphTextureWebcam.prototype.onGetOutputs = function() {
		return [
			["width", "number"],
			["height", "number"],
			["stream_ready", LiteGraph.EVENT],
			["stream_closed", LiteGraph.EVENT],
			["stream_error", LiteGraph.EVENT]
		];
	};

	LiteGraph.registerNodeType("texture/webcam", LGraphTextureWebcam);

	//from https://github.com/spite/Wagner
	function LGraphLensFX() {
		this.addInput("in", "Texture");
		this.addInput("f", "number");
		this.addOutput("out", "Texture");
		this.properties = {
			enabled: true,
			factor: 1,
			precision: LGraphTexture.LOW
		};

		this._uniforms = { u_texture: 0, u_factor: 1 };
	}

	LGraphLensFX.title = "Lens FX";
	LGraphLensFX.desc = "distortion and chromatic aberration";

	LGraphLensFX.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphLensFX.prototype.onGetInputs = function() {
		return [["enabled", "boolean"]];
	};

	LGraphLensFX.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (
			this.properties.precision === LGraphTexture.PASS_THROUGH ||
			this.getInputOrProperty("enabled") === false
		) {
			this.setOutputData(0, tex);
			return;
		}

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			temp = this._temp_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		var shader = LGraphLensFX._shader;
		if (!shader) {
			shader = LGraphLensFX._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphLensFX.pixel_shader
			);
		}

		var factor = this.getInputData(1);
		if (factor == null) {
			factor = this.properties.factor;
		}

		var uniforms = this._uniforms;
		uniforms.u_factor = factor;

		//apply shader
		gl.disable(gl.DEPTH_TEST);
		temp.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	};

	LGraphLensFX.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_factor;\n\
		vec2 barrelDistortion(vec2 coord, float amt) {\n\
			vec2 cc = coord - 0.5;\n\
			float dist = dot(cc, cc);\n\
			return coord + cc * dist * amt;\n\
		}\n\
		\n\
		float sat( float t )\n\
		{\n\
			return clamp( t, 0.0, 1.0 );\n\
		}\n\
		\n\
		float linterp( float t ) {\n\
			return sat( 1.0 - abs( 2.0*t - 1.0 ) );\n\
		}\n\
		\n\
		float remap( float t, float a, float b ) {\n\
			return sat( (t - a) / (b - a) );\n\
		}\n\
		\n\
		vec4 spectrum_offset( float t ) {\n\
			vec4 ret;\n\
			float lo = step(t,0.5);\n\
			float hi = 1.0-lo;\n\
			float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\
			ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\
		\n\
			return pow( ret, vec4(1.0/2.2) );\n\
		}\n\
		\n\
		const float max_distort = 2.2;\n\
		const int num_iter = 12;\n\
		const float reci_num_iter_f = 1.0 / float(num_iter);\n\
		\n\
		void main()\n\
		{	\n\
			vec2 uv=v_coord;\n\
			vec4 sumcol = vec4(0.0);\n\
			vec4 sumw = vec4(0.0);	\n\
			for ( int i=0; i<num_iter;++i )\n\
			{\n\
				float t = float(i) * reci_num_iter_f;\n\
				vec4 w = spectrum_offset( t );\n\
				sumw += w;\n\
				sumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\n\
			}\n\
			gl_FragColor = sumcol / sumw;\n\
		}";

	LiteGraph.registerNodeType("texture/lensfx", LGraphLensFX);


	function LGraphTextureFromData() {
		this.addInput("in", "");
		this.properties = { precision: LGraphTexture.LOW, width: 0, height: 0, channels: 1 };
		this.addOutput("out", "Texture");
	}

	LGraphTextureFromData.title = "Data->Tex";
	LGraphTextureFromData.desc = "Generates or applies a curve to a texture";
	LGraphTextureFromData.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureFromData.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var data = this.getInputData(0);
		if(!data)
			return;

		var channels = this.properties.channels;
		var w = this.properties.width;
		var h = this.properties.height;
		if(!w || !h)
		{
			w = Math.floor(data.length / channels);
			h = 1;
		}
		var format = gl.RGBA;
		if( channels == 3 )
			format = gl.RGB;
		else if( channels == 1 )
			format = gl.LUMINANCE;

		var temp = this._temp_texture;
		var type = LGraphTexture.getTextureType( this.properties.precision );
		if ( !temp || temp.width != w || temp.height != h || temp.type != type ) {
			temp = this._temp_texture = new GL.Texture( w, h, { type: type, format: format, filter: gl.LINEAR } );
		}

		temp.uploadData( data );
		this.setOutputData(0, temp);
	}

	LiteGraph.registerNodeType("texture/fromdata", LGraphTextureFromData);

	//applies a curve (or generates one)
	function LGraphTextureCurve() {
		this.addInput("in", "Texture");
		this.addOutput("out", "Texture");
		this.properties = { precision: LGraphTexture.LOW, split_channels: false };
		this._values = new Uint8Array(256*4);
		this._values.fill(255);
		this._curve_texture = null;
		this._uniforms = { u_texture: 0, u_curve: 1, u_range: 1.0 };
		this._must_update = true;
		this._points = {
			RGB: [[0,0],[1,1]],
			R: [[0,0],[1,1]],
			G: [[0,0],[1,1]],
			B: [[0,0],[1,1]]
		};
		this.curve_editor = null;
		this.addWidget("toggle","Split Channels",false,"split_channels");
		this.addWidget("combo","Channel","RGB",{ values:["RGB","R","G","B"]});
		this.curve_offset = 68;
		this.size = [ 240, 160 ];
	}

	LGraphTextureCurve.title = "Curve";
	LGraphTextureCurve.desc = "Generates or applies a curve to a texture";
	LGraphTextureCurve.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureCurve.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		var temp = this._temp_texture;
		if(!tex) //generate one texture, nothing else
		{
			if(this._must_update || !this._curve_texture )
				this.updateCurve();
			this.setOutputData(0, this._curve_texture);
			return;
		}

		var type = LGraphTexture.getTextureType( this.properties.precision, tex );
		
		//apply curve to input texture
		if ( !temp || temp.type != type || temp.width != tex.width || temp.height != tex.height || temp.format != tex.format)
			temp = this._temp_texture = new GL.Texture( tex.width, tex.height, { type: type, format: tex.format, filter: gl.LINEAR } );

		var shader = LGraphTextureCurve._shader;
		if (!shader) {
			shader = LGraphTextureCurve._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureCurve.pixel_shader );
		}

		if(this._must_update || !this._curve_texture )
			this.updateCurve();

		var uniforms = this._uniforms;
		var curve_texture = this._curve_texture;

		//apply shader
		temp.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			tex.bind(0);
			curve_texture.bind(1);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	}

	LGraphTextureCurve.prototype.sampleCurve = function(f,points)
	{
		var points = points || this._points.RGB;
		if(!points)
			return;
		for(var i = 0; i < points.length - 1; ++i)
		{
			var p = points[i];
			var pn = points[i+1];
			if(pn[0] < f)
				continue;
			var r = (pn[0] - p[0]);
			if( Math.abs(r) < 0.00001 )
				return p[1];
			var local_f = (f - p[0]) / r;
			return p[1] * (1.0 - local_f) + pn[1] * local_f;
		}
		return 0;
	}

	LGraphTextureCurve.prototype.updateCurve = function()
	{
		var values = this._values;
		var num = values.length / 4;
		var split = this.properties.split_channels;
		for(var i = 0; i < num; ++i)
		{
			if(split)
			{
				values[i*4] = Math.clamp( this.sampleCurve(i/num,this._points.R)*255,0,255);
				values[i*4+1] = Math.clamp( this.sampleCurve(i/num,this._points.G)*255,0,255);
				values[i*4+2] = Math.clamp( this.sampleCurve(i/num,this._points.B)*255,0,255);
			}
			else
			{
				var v = this.sampleCurve(i/num);//sample curve
				values[i*4] = values[i*4+1] = values[i*4+2] = Math.clamp(v*255,0,255);
			}
			values[i*4+3] = 255; //alpha fixed
		}
		if(!this._curve_texture)
			this._curve_texture = new GL.Texture(256,1,{ format: gl.RGBA, magFilter: gl.LINEAR, wrap: gl.CLAMP_TO_EDGE });
		this._curve_texture.uploadData(values,null,true);
	}

	LGraphTextureCurve.prototype.onSerialize = function(o)
	{
		var curves = {};
		for(var i in this._points)
			curves[i] = this._points[i].concat();
		o.curves = curves;
	}

	LGraphTextureCurve.prototype.onConfigure = function(o)
	{
		this._points = o.curves;
		if(this.curve_editor)
			curve_editor.points = this._points;
		this._must_update = true;
	}

	LGraphTextureCurve.prototype.onMouseDown = function(e, localpos, graphcanvas)
	{
		if(this.curve_editor)
		{
			var r = this.curve_editor.onMouseDown([localpos[0],localpos[1]-this.curve_offset], graphcanvas);
			if(r)
				this.captureInput(true);
			return r;
		}
	}

	LGraphTextureCurve.prototype.onMouseMove = function(e, localpos, graphcanvas)
	{
		if(this.curve_editor)
			return this.curve_editor.onMouseMove([localpos[0],localpos[1]-this.curve_offset], graphcanvas);
	}

	LGraphTextureCurve.prototype.onMouseUp = function(e, localpos, graphcanvas)
	{
		if(this.curve_editor)
			return this.curve_editor.onMouseUp([localpos[0],localpos[1]-this.curve_offset], graphcanvas);
		this.captureInput(false);
	}

	LGraphTextureCurve.channel_line_colors = { "RGB":"#666","R":"#F33","G":"#3F3","B":"#33F" };

	LGraphTextureCurve.prototype.onDrawBackground = function(ctx, graphcanvas)
	{
		if(this.flags.collapsed)
			return;

		if(!this.curve_editor)
			this.curve_editor = new LiteGraph.CurveEditor(this._points.R);
		ctx.save();
		ctx.translate(0,this.curve_offset);
		var channel = this.widgets[1].value;

		if(this.properties.split_channels)
		{
			if(channel == "RGB")
			{
				this.widgets[1].value = channel = "R";
				this.widgets[1].disabled = false;
			}
			this.curve_editor.points = this._points.R;
			this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, "#111", LGraphTextureCurve.channel_line_colors.R, true );
			ctx.globalCompositeOperation = "lighten";
			this.curve_editor.points = this._points.G;
			this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, null, LGraphTextureCurve.channel_line_colors.G, true );
			this.curve_editor.points = this._points.B;
			this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, null, LGraphTextureCurve.channel_line_colors.B, true );
			ctx.globalCompositeOperation = "source-over";
		}
		else
		{
			this.widgets[1].value = channel = "RGB";
			this.widgets[1].disabled = true;
		}

		this.curve_editor.points = this._points[channel];
		this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, this.properties.split_channels ? null : "#111", LGraphTextureCurve.channel_line_colors[channel]  );
		ctx.restore();
	}

	LGraphTextureCurve.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_curve;\n\
		uniform float u_range;\n\
		\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord ) * u_range;\n\
			color.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;\n\
			color.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;\n\
			color.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;\n\
			//color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;\n\
			gl_FragColor = color;\n\
		}";

	LiteGraph.registerNodeType("texture/curve", LGraphTextureCurve);

	//simple exposition, but plan to expand it to support different gamma curves
	function LGraphExposition() {
		this.addInput("in", "Texture");
		this.addInput("exp", "number");
		this.addOutput("out", "Texture");
		this.properties = { exposition: 1, precision: LGraphTexture.LOW };
		this._uniforms = { u_texture: 0, u_exposition: 1 };
	}

	LGraphExposition.title = "Exposition";
	LGraphExposition.desc = "Controls texture exposition";

	LGraphExposition.widgets_info = {
		exposition: { widget: "slider", min: 0, max: 3 },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphExposition.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			temp = this._temp_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		var shader = LGraphExposition._shader;
		if (!shader) {
			shader = LGraphExposition._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphExposition.pixel_shader
			);
		}

		var exp = this.properties.exposition;
		var exp_input = this.getInputData(1);
		if (exp_input != null) {
			exp = this.properties.exposition = exp_input;
		}
		var uniforms = this._uniforms;

		//apply shader
		temp.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			tex.bind(0);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	};

	LGraphExposition.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_exposition;\n\
		\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord );\n\
			gl_FragColor = vec4( color.xyz * u_exposition, color.a );\n\
		}";

	LiteGraph.registerNodeType("texture/exposition", LGraphExposition);

	function LGraphToneMapping() {
		this.addInput("in", "Texture");
		this.addInput("avg", "number,Texture");
		this.addOutput("out", "Texture");
		this.properties = {
			enabled: true,
			scale: 1,
			gamma: 1,
			average_lum: 1,
			lum_white: 1,
			precision: LGraphTexture.LOW
		};

		this._uniforms = {
			u_texture: 0,
			u_lumwhite2: 1,
			u_igamma: 1,
			u_scale: 1,
			u_average_lum: 1
		};
	}

	LGraphToneMapping.title = "Tone Mapping";
	LGraphToneMapping.desc =
		"Applies Tone Mapping to convert from high to low";

	LGraphToneMapping.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphToneMapping.prototype.onGetInputs = function() {
		return [["enabled", "boolean"]];
	};

	LGraphToneMapping.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (
			this.properties.precision === LGraphTexture.PASS_THROUGH ||
			this.getInputOrProperty("enabled") === false
		) {
			this.setOutputData(0, tex);
			return;
		}

		var temp = this._temp_texture;

		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			temp = this._temp_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		var avg = this.getInputData(1);
		if (avg == null) {
			avg = this.properties.average_lum;
		}

		var uniforms = this._uniforms;
		var shader = null;

		if (avg.constructor === Number) {
			this.properties.average_lum = avg;
			uniforms.u_average_lum = this.properties.average_lum;
			shader = LGraphToneMapping._shader;
			if (!shader) {
				shader = LGraphToneMapping._shader = new GL.Shader(
					GL.Shader.SCREEN_VERTEX_SHADER,
					LGraphToneMapping.pixel_shader
				);
			}
		} else if (avg.constructor === GL.Texture) {
			uniforms.u_average_texture = avg.bind(1);
			shader = LGraphToneMapping._shader_texture;
			if (!shader) {
				shader = LGraphToneMapping._shader_texture = new GL.Shader(
					GL.Shader.SCREEN_VERTEX_SHADER,
					LGraphToneMapping.pixel_shader,
					{ AVG_TEXTURE: "" }
				);
			}
		}

		uniforms.u_lumwhite2 =
			this.properties.lum_white * this.properties.lum_white;
		uniforms.u_scale = this.properties.scale;
		uniforms.u_igamma = 1 / this.properties.gamma;

		//apply shader
		gl.disable(gl.DEPTH_TEST);
		temp.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, this._temp_texture);
	};

	LGraphToneMapping.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_scale;\n\
		#ifdef AVG_TEXTURE\n\
			uniform sampler2D u_average_texture;\n\
		#else\n\
			uniform float u_average_lum;\n\
		#endif\n\
		uniform float u_lumwhite2;\n\
		uniform float u_igamma;\n\
		vec3 RGB2xyY (vec3 rgb)\n\
		{\n\
			 const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\n\
									   0.2126, 0.7152, 0.0722,\n\
									   0.0193, 0.1192, 0.9505);\n\
			vec3 XYZ = RGB2XYZ * rgb;\n\
			\n\
			float f = (XYZ.x + XYZ.y + XYZ.z);\n\
			return vec3(XYZ.x / f,\n\
						XYZ.y / f,\n\
						XYZ.y);\n\
		}\n\
		\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord );\n\
			vec3 rgb = color.xyz;\n\
			float average_lum = 0.0;\n\
			#ifdef AVG_TEXTURE\n\
				vec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;\n\
				average_lum = (pixel.x + pixel.y + pixel.z) / 3.0;\n\
			#else\n\
				average_lum = u_average_lum;\n\
			#endif\n\
			//Ld - this part of the code is the same for both versions\n\
			float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n\
			float L = (u_scale / average_lum) * lum;\n\
			float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\n\
			//first\n\
			//vec3 xyY = RGB2xyY(rgb);\n\
			//xyY.z *= Ld;\n\
			//rgb = xyYtoRGB(xyY);\n\
			//second\n\
			rgb = (rgb / lum) * Ld;\n\
			rgb = max(rgb,vec3(0.001));\n\
			rgb = pow( rgb, vec3( u_igamma ) );\n\
			gl_FragColor = vec4( rgb, color.a );\n\
		}";

	LiteGraph.registerNodeType("texture/tonemapping", LGraphToneMapping);

	function LGraphTexturePerlin() {
		this.addOutput("out", "Texture");
		this.properties = {
			width: 512,
			height: 512,
			seed: 0,
			persistence: 0.1,
			octaves: 8,
			scale: 1,
			offset: [0, 0],
			amplitude: 1,
			precision: LGraphTexture.DEFAULT
		};
		this._key = 0;
		this._texture = null;
		this._uniforms = {
			u_persistence: 0.1,
			u_seed: 0,
			u_offset: vec2.create(),
			u_scale: 1,
			u_viewport: vec2.create()
		};
	}

	LGraphTexturePerlin.title = "Perlin";
	LGraphTexturePerlin.desc = "Generates a perlin noise texture";

	LGraphTexturePerlin.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
		width: { type: "number", precision: 0, step: 1 },
		height: { type: "number", precision: 0, step: 1 },
		octaves: { type: "number", precision: 0, step: 1, min: 1, max: 50 }
	};

	LGraphTexturePerlin.prototype.onGetInputs = function() {
		return [
			["seed", "number"],
			["persistence", "number"],
			["octaves", "number"],
			["scale", "number"],
			["amplitude", "number"],
			["offset", "vec2"]
		];
	};

	LGraphTexturePerlin.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var w = this.properties.width | 0;
		var h = this.properties.height | 0;
		if (w == 0) {
			w = gl.viewport_data[2];
		} //0 means default
		if (h == 0) {
			h = gl.viewport_data[3];
		} //0 means default
		var type = LGraphTexture.getTextureType(this.properties.precision);

		var temp = this._texture;
		if (
			!temp ||
			temp.width != w ||
			temp.height != h ||
			temp.type != type
		) {
			temp = this._texture = new GL.Texture(w, h, {
				type: type,
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		var persistence = this.getInputOrProperty("persistence");
		var octaves = this.getInputOrProperty("octaves");
		var offset = this.getInputOrProperty("offset");
		var scale = this.getInputOrProperty("scale");
		var amplitude = this.getInputOrProperty("amplitude");
		var seed = this.getInputOrProperty("seed");

		//reusing old texture
		var key =
			"" +
			w +
			h +
			type +
			persistence +
			octaves +
			scale +
			seed +
			offset[0] +
			offset[1] +
			amplitude;
		if (key == this._key) {
			this.setOutputData(0, temp);
			return;
		}
		this._key = key;

		//gather uniforms
		var uniforms = this._uniforms;
		uniforms.u_persistence = persistence;
		uniforms.u_octaves = octaves;
		uniforms.u_offset.set(offset);
		uniforms.u_scale = scale;
		uniforms.u_amplitude = amplitude;
		uniforms.u_seed = seed * 128;
		uniforms.u_viewport[0] = w;
		uniforms.u_viewport[1] = h;

		//render
		var shader = LGraphTexturePerlin._shader;
		if (!shader) {
			shader = LGraphTexturePerlin._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTexturePerlin.pixel_shader
			);
		}

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		temp.drawTo(function() {
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	};

	LGraphTexturePerlin.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform vec2 u_offset;\n\
		uniform float u_scale;\n\
		uniform float u_persistence;\n\
		uniform int u_octaves;\n\
		uniform float u_amplitude;\n\
		uniform vec2 u_viewport;\n\
		uniform float u_seed;\n\
		#define M_PI 3.14159265358979323846\n\
		\n\
		float rand(vec2 c){	return fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\n\
		\n\
		float noise(vec2 p, float freq ){\n\
			float unit = u_viewport.x/freq;\n\
			vec2 ij = floor(p/unit);\n\
			vec2 xy = mod(p,unit)/unit;\n\
			//xy = 3.*xy*xy-2.*xy*xy*xy;\n\
			xy = .5*(1.-cos(M_PI*xy));\n\
			float a = rand((ij+vec2(0.,0.)));\n\
			float b = rand((ij+vec2(1.,0.)));\n\
			float c = rand((ij+vec2(0.,1.)));\n\
			float d = rand((ij+vec2(1.,1.)));\n\
			float x1 = mix(a, b, xy.x);\n\
			float x2 = mix(c, d, xy.x);\n\
			return mix(x1, x2, xy.y);\n\
		}\n\
		\n\
		float pNoise(vec2 p, int res){\n\
			float persistance = u_persistence;\n\
			float n = 0.;\n\
			float normK = 0.;\n\
			float f = 4.;\n\
			float amp = 1.0;\n\
			int iCount = 0;\n\
			for (int i = 0; i<50; i++){\n\
				n+=amp*noise(p, f);\n\
				f*=2.;\n\
				normK+=amp;\n\
				amp*=persistance;\n\
				if (iCount >= res)\n\
					break;\n\
				iCount++;\n\
			}\n\
			float nf = n/normK;\n\
			return nf*nf*nf*nf;\n\
		}\n\
		void main() {\n\
			vec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\n\
			vec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\n\
			gl_FragColor = color;\n\
		}";

	LiteGraph.registerNodeType("texture/perlin", LGraphTexturePerlin);

	function LGraphTextureCanvas2D() {
		this.addInput("v");
		this.addOutput("out", "Texture");
		this.properties = {
			code: LGraphTextureCanvas2D.default_code,
			width: 512,
			height: 512,
			clear: true,
			precision: LGraphTexture.DEFAULT,
			use_html_canvas: false
		};
		this._func = null;
		this._temp_texture = null;
		this.compileCode();
	}

	LGraphTextureCanvas2D.title = "Canvas2D";
	LGraphTextureCanvas2D.desc = "Executes Canvas2D code inside a texture or the viewport.";
	LGraphTextureCanvas2D.help = "Set width and height to 0 to match viewport size.";

	LGraphTextureCanvas2D.default_code = "//vars: canvas,ctx,time\nctx.fillStyle='red';\nctx.fillRect(0,0,50,50);\n";

	LGraphTextureCanvas2D.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
		code: { type: "code" },
		width: { type: "number", precision: 0, step: 1 },
		height: { type: "number", precision: 0, step: 1 }
	};

	LGraphTextureCanvas2D.prototype.onPropertyChanged = function( name, value ) {
		if (name == "code" )
			this.compileCode( value );
	}
	
	LGraphTextureCanvas2D.prototype.compileCode = function( code ) {
		this._func = null;
		if( !LiteGraph.allow_scripts )
			return;

		try {
			this._func = new Function( "canvas", "ctx", "time", "script","v", code );
			this.boxcolor = "#00FF00";
		} catch (err) {
			this.boxcolor = "#FF0000";
			console.error("Error parsing script");
			console.error(err);
		}
	};

	LGraphTextureCanvas2D.prototype.onExecute = function() {
		var func = this._func;
		if (!func || !this.isOutputConnected(0)) {
			return;
		}
		this.executeDraw( func );
	}

	LGraphTextureCanvas2D.prototype.executeDraw = function( func_context ) {

		var width = this.properties.width || gl.canvas.width;
		var height = this.properties.height || gl.canvas.height;
		var temp = this._temp_texture;
		var type = LGraphTexture.getTextureType( this.properties.precision );
		if (!temp || temp.width != width || temp.height != height || temp.type != type ) {
			temp = this._temp_texture = new GL.Texture(width, height, {
				format: gl.RGBA,
				filter: gl.LINEAR,
				type: type
			});
		}

		var v = this.getInputData(0);

		var properties = this.properties;
		var that = this;
		var time = this.graph.getTime();
		var ctx = gl;
		var canvas = gl.canvas;
		if( this.properties.use_html_canvas || !global.enableWebGLCanvas )
		{
			if(!this._canvas)
			{
				canvas = this._canvas = createCanvas(width.height);
				ctx = this._ctx = canvas.getContext("2d");
			}
			else
			{
				canvas = this._canvas;
				ctx = this._ctx;
			}
			canvas.width = width;
			canvas.height = height;
		}

		if(ctx == gl) //using Canvas2DtoWebGL
			temp.drawTo(function() {
				gl.start2D();
				if(properties.clear)
				{
					gl.clearColor(0,0,0,0);
					gl.clear( gl.COLOR_BUFFER_BIT );
				}

				try {
					if (func_context.draw) {
						func_context.draw.call(that, canvas, ctx, time, func_context, v);
					} else {
						func_context.call(that, canvas, ctx, time, func_context,v);
					}
					that.boxcolor = "#00FF00";
				} catch (err) {
					that.boxcolor = "#FF0000";
					console.error("Error executing script");
					console.error(err);
				}
				gl.finish2D();
			});
		else //rendering to offscren canvas and uploading to texture
		{
			if(properties.clear)
				ctx.clearRect(0,0,canvas.width,canvas.height);

			try {
				if (func_context.draw) {
					func_context.draw.call(this, canvas, ctx, time, func_context, v);
				} else {
					func_context.call(this, canvas, ctx, time, func_context,v);
				}
				this.boxcolor = "#00FF00";
			} catch (err) {
				this.boxcolor = "#FF0000";
				console.error("Error executing script");
				console.error(err);
			}
			temp.uploadImage( canvas );
		}

		this.setOutputData(0, temp);
	};

	LiteGraph.registerNodeType("texture/canvas2D", LGraphTextureCanvas2D);

	// To do chroma keying *****************

	function LGraphTextureMatte() {
		this.addInput("in", "Texture");

		this.addOutput("out", "Texture");
		this.properties = {
			key_color: vec3.fromValues(0, 1, 0),
			threshold: 0.8,
			slope: 0.2,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureMatte.title = "Matte";
	LGraphTextureMatte.desc = "Extracts background";

	LGraphTextureMatte.widgets_info = {
		key_color: { widget: "color" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureMatte.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		this._tex = LGraphTexture.getTargetTexture(
			tex,
			this._tex,
			this.properties.precision
		);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		if (!this._uniforms) {
			this._uniforms = {
				u_texture: 0,
				u_key_color: this.properties.key_color,
				u_threshold: 1,
				u_slope: 1
			};
		}
		var uniforms = this._uniforms;

		var mesh = Mesh.getScreenQuad();
		var shader = LGraphTextureMatte._shader;
		if (!shader) {
			shader = LGraphTextureMatte._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureMatte.pixel_shader
			);
		}

		uniforms.u_key_color = this.properties.key_color;
		uniforms.u_threshold = this.properties.threshold;
		uniforms.u_slope = this.properties.slope;

		this._tex.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureMatte.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec3 u_key_color;\n\
		uniform float u_threshold;\n\
		uniform float u_slope;\n\
		\n\
		void main() {\n\
			vec3 color = texture2D( u_texture, v_coord ).xyz;\n\
			float diff = length( normalize(color) - normalize(u_key_color) );\n\
			float edge = u_threshold * (1.0 - u_slope);\n\
			float alpha = smoothstep( edge, u_threshold, diff);\n\
			gl_FragColor = vec4( color, alpha );\n\
		}";

	LiteGraph.registerNodeType("texture/matte", LGraphTextureMatte);

	//***********************************
	function LGraphCubemapToTexture2D() {
		this.addInput("in", "texture");
		this.addInput("yaw", "number");
		this.addOutput("out", "texture");
		this.properties = { yaw: 0 };
	}

	LGraphCubemapToTexture2D.title = "CubemapToTexture2D";
	LGraphCubemapToTexture2D.desc = "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation";

	LGraphCubemapToTexture2D.prototype.onExecute = function() {
		if (!this.isOutputConnected(0))
			return;

		var tex = this.getInputData(0);
		if ( !tex || tex.texture_type != GL.TEXTURE_CUBE_MAP )
			return;
		if( this._last_tex && ( this._last_tex.height != tex.height || this._last_tex.type != tex.type ))
			this._last_tex = null;
		var yaw = this.getInputOrProperty("yaw");
		this._last_tex = GL.Texture.cubemapToTexture2D( tex, tex.height, this._last_tex, true, yaw );
		this.setOutputData( 0, this._last_tex );
	};

	LiteGraph.registerNodeType( "texture/cubemapToTexture2D", LGraphCubemapToTexture2D );
})(this);

(function(global) {

    if (typeof GL == "undefined")
		return;

    var LiteGraph = global.LiteGraph;
	var LGraphCanvas = global.LGraphCanvas;

	var SHADERNODES_COLOR = "#345";

	var LGShaders = LiteGraph.Shaders = {};

	var GLSL_types = LGShaders.GLSL_types = ["float","vec2","vec3","vec4","mat3","mat4","sampler2D","samplerCube"];
	var GLSL_types_const = LGShaders.GLSL_types_const = ["float","vec2","vec3","vec4"];

	var GLSL_functions_desc = {
		"radians": "T radians(T degrees)",
		"degrees": "T degrees(T radians)",
		"sin": "T sin(T angle)",
		"cos": "T cos(T angle)",
		"tan": "T tan(T angle)",
		"asin": "T asin(T x)",
		"acos": "T acos(T x)",
		"atan": "T atan(T x)",
		"atan2": "T atan(T x,T y)",
		"pow": "T pow(T x,T y)",
		"exp": "T exp(T x)",
		"log": "T log(T x)",
		"exp2": "T exp2(T x)",
		"log2": "T log2(T x)",
		"sqrt": "T sqrt(T x)",
		"inversesqrt": "T inversesqrt(T x)",
		"abs": "T abs(T x)",
		"sign": "T sign(T x)",
		"floor": "T floor(T x)",
		"round": "T round(T x)",
		"ceil": "T ceil(T x)",
		"fract": "T fract(T x)",
		"mod": "T mod(T x,T y)", //"T mod(T x,float y)"
		"min": "T min(T x,T y)",
		"max": "T max(T x,T y)",
		"clamp": "T clamp(T x,T minVal = 0.0,T maxVal = 1.0)",
		"mix": "T mix(T x,T y,T a)", //"T mix(T x,T y,float a)"
		"step": "T step(T edge, T edge2, T x)", //"T step(float edge, T x)"
		"smoothstep": "T smoothstep(T edge, T edge2, T x)", //"T smoothstep(float edge, T x)"
		"length":"float length(T x)",
		"distance":"float distance(T p0, T p1)",
		"normalize":"T normalize(T x)",
		"dot": "float dot(T x,T y)",
		"cross": "vec3 cross(vec3 x,vec3 y)",
		"reflect": "vec3 reflect(vec3 V,vec3 N)",
		"refract": "vec3 refract(vec3 V,vec3 N, float IOR)"
	};

	//parse them
	var GLSL_functions = {};
	var GLSL_functions_name = [];
	parseGLSLDescriptions();

	LGShaders.ALL_TYPES = "float,vec2,vec3,vec4";

	function parseGLSLDescriptions()
	{
		GLSL_functions_name.length = 0;

		for(var i in GLSL_functions_desc)
		{
			var op = GLSL_functions_desc[i];
			var index = op.indexOf(" ");
			var return_type = op.substr(0,index);
			var index2 = op.indexOf("(",index);
			var func_name = op.substr(index,index2-index).trim();
			var params = op.substr(index2 + 1, op.length - index2 - 2).split(",");
			for(var j in params)
			{
				var p = params[j].split(" ").filter(function(a){ return a; });
				params[j] = { type: p[0].trim(), name: p[1].trim() };
				if(p[2] == "=")
					params[j].value = p[3].trim();
			}
			GLSL_functions[i] = { return_type: return_type, func: func_name, params: params };
			GLSL_functions_name.push( func_name );
			//console.log( GLSL_functions[i] );
		}
	}

	//common actions to all shader node classes
	function registerShaderNode( type, node_ctor )
	{
		//static attributes
		node_ctor.color = SHADERNODES_COLOR;
		node_ctor.filter = "shader";

		//common methods
		node_ctor.prototype.clearDestination = function(){ this.shader_destination = {};  }
		node_ctor.prototype.propagateDestination = function propagateDestination( dest_name )
		{
			this.shader_destination[ dest_name ] = true;
			if(this.inputs)
			for(var i = 0; i < this.inputs.length; ++i)
			{
				var origin_node = this.getInputNode(i);
				if(origin_node)
					origin_node.propagateDestination( dest_name );
			}
		}
		if(!node_ctor.prototype.onPropertyChanged)
			node_ctor.prototype.onPropertyChanged = function()
			{
				if(this.graph)
					 this.graph._version++;
			}

		/*
		if(!node_ctor.prototype.onGetCode)
			node_ctor.prototype.onGetCode = function()
			{
				//check destination to avoid lonely nodes
				if(!this.shader_destination)
					return;
				//grab inputs with types
				var inputs = [];
				if(this.inputs)
				for(var i = 0; i < this.inputs.length; ++i)
					inputs.push({ type: this.getInputData(i), name: getInputLinkID(this,i) });
				var outputs = [];
				if(this.outputs)
				for(var i = 0; i < this.outputs.length; ++i)
					outputs.push({ name: getOutputLinkID(this,i) });
				//pass to code func
				var results = this.extractCode(inputs);
				//grab output, pass to next
				if(results)
				for(var i = 0; i < results.length; ++i)
				{
					var r = results[i];
					if(!r)
						continue;
					this.setOutputData(i,r.value);
				}
			}
		*/

		LiteGraph.registerNodeType( "shader::" + type, node_ctor );
	}

	function getShaderNodeVarName( node, name )
	{
		return "VAR_" + (name || "TEMP") + "_" + node.id;
	}

	function getInputLinkID( node, slot )
	{
		if(!node.inputs)
			return null;
		var link = node.getInputLink( slot );
		if( !link )
			return null;
		var origin_node = node.graph.getNodeById( link.origin_id );
		if( !origin_node )
			return null;
		if(origin_node.getOutputVarName)
			return origin_node.getOutputVarName(link.origin_slot);
		//generate
		return "link_" + origin_node.id + "_" + link.origin_slot;
	}

	function getOutputLinkID( node, slot )
	{
		if (!node.isOutputConnected(slot))
			return null;
		return "link_" + node.id + "_" + slot;
	}

	LGShaders.registerShaderNode = registerShaderNode;
	LGShaders.getInputLinkID = getInputLinkID;
	LGShaders.getOutputLinkID = getOutputLinkID;
	LGShaders.getShaderNodeVarName = getShaderNodeVarName;
	LGShaders.parseGLSLDescriptions = parseGLSLDescriptions;

	//given a const number, it transform it to a string that matches a type
	var valueToGLSL = LiteGraph.valueToGLSL = function valueToGLSL( v, type, precision )
	{
		var n = 5; //num decimals
		if(precision != null)
			n = precision;
		if(!type)
		{
			if(v.constructor === Number)
				type = "float";
			else if(v.length)
			{
				switch(v.length)
				{
					case 2: type = "vec2"; break;
					case 3: type = "vec3"; break;
					case 4: type = "vec4"; break;
					case 9: type = "mat3"; break;
					case 16: type = "mat4"; break;
					default:
						throw("unknown type for glsl value size");
				}
			}
			else
				throw("unknown type for glsl value: " + v.constructor);
		}
		switch(type)
		{
			case 'float': return v.toFixed(n); break;
			case 'vec2': return "vec2(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + ")"; break;
			case 'color3':
			case 'vec3': return "vec3(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + "," + v[2].toFixed(n) + ")"; break;
			case 'color4':
			case 'vec4': return "vec4(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + "," + v[2].toFixed(n) + "," + v[3].toFixed(n) + ")"; break;
			case 'mat3': return "mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)"; break; //not fully supported yet
			case 'mat4': return "mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0)"; break;//not fully supported yet
			default:
				throw("unknown glsl type in valueToGLSL:", type);
		}

		return "";
	}

	//makes sure that a var is of a type, and if not, it converts it
	var varToTypeGLSL = LiteGraph.varToTypeGLSL = function varToTypeGLSL( v, input_type, output_type )
	{
		if(input_type == output_type)
			return v;
		if(v == null)
			switch(output_type)
			{
				case "float": return "0.0";
				case "vec2":  return "vec2(0.0)";
				case "vec3":  return "vec3(0.0)";
				case "vec4":  return "vec4(0.0,0.0,0.0,1.0)";
				default: //null
					return null;
			}

		if(!output_type)
			throw("error: no output type specified");
		if(output_type == "float")
		{
			switch(input_type)
			{
				//case "float":
				case "vec2":
				case "vec3":
				case "vec4":
					return v + ".x";
					break;
				default: //null
					return "0.0";
					break;
			}
		}
		else if(output_type == "vec2")
		{
			switch(input_type)
			{
				case "float":
					return "vec2("+v+")";
				//case "vec2":
				case "vec3":
				case "vec4":
					return v + ".xy";
				default: //null
					return "vec2(0.0)";
			}
		}
		else if(output_type == "vec3")
		{
			switch(input_type)
			{
				case "float":
					return "vec3("+v+")";
				case "vec2":
					return "vec3(" + v + ",0.0)";
				//case "vec3":
				case "vec4":
					return v + ".xyz";
				default: //null
					return "vec3(0.0)";
			}
		}
		else if(output_type == "vec4")
		{
			switch(input_type)
			{
				case "float":
					return "vec4("+v+")";
				case "vec2":
					return "vec4(" + v + ",0.0,1.0)";
				case "vec3":
					return "vec4(" + v + ",1.0)";
				default: //null
					return "vec4(0.0,0.0,0.0,1.0)";
			}
		}
		throw("type cannot be converted");
	}


	//used to plug incompatible stuff
	var convertVarToGLSLType = LiteGraph.convertVarToGLSLType = function convertVarToGLSLType( varname, type, target_type )
	{
		if(type == target_type)
			return varname;
		if(type == "float")
			return target_type + "(" + varname + ")";
		if(target_type == "vec2") //works for vec2,vec3 and vec4
			return "vec2(" + varname + ".xy)";
		if(target_type == "vec3") //works for vec2,vec3 and vec4
		{
			if(type == "vec2")
				return "vec3(" + varname + ",0.0)";
			if(type == "vec4")
				return "vec4(" + varname + ".xyz)";
		}
		if(target_type == "vec4")
		{
			if(type == "vec2")
				return "vec4(" + varname + ",0.0,0.0)";
			if(target_type == "vec3")
				return "vec4(" + varname + ",1.0)";
		}
		return null;
	}

	//used to host a shader body **************************************
	function LGShaderContext()
	{
		//to store the code template
		this.vs_template = "";
		this.fs_template = "";

		//required so nodes now where to fetch the input data
		this.buffer_names = {
			uvs: "v_coord"
		};

		this.extra = {}; //to store custom info from the nodes (like if this shader supports a feature, etc)

		this._functions = {};
		this._uniforms = {};
		this._codeparts = {};
		this._uniform_value = null;
	}

	LGShaderContext.prototype.clear = function()
	{
		this._uniforms = {};
		this._functions = {};
		this._codeparts = {};
		this._uniform_value = null;

		this.extra = {};
	}

	LGShaderContext.prototype.addUniform = function( name, type, value )
	{
		this._uniforms[ name ] = type;
		if(value != null)
		{
			if(!this._uniform_value)
				this._uniform_value = {};
			this._uniform_value[name] = value;
		}
	}

	LGShaderContext.prototype.addFunction = function( name, code )
	{
		this._functions[name] = code;
	}

	LGShaderContext.prototype.addCode = function( hook, code, destinations )
	{
		destinations = destinations || {"":""};
		for(var i in destinations)
		{
			var h = i ? i + "_" + hook : hook;
			if(!this._codeparts[ h ])
				this._codeparts[ h ] = code + "\n";
			else
				this._codeparts[ h ] += code + "\n";
		}
	}

	//the system works by grabbing code fragments from every node and concatenating them in blocks depending on where must they be attached
	LGShaderContext.prototype.computeCodeBlocks = function( graph, extra_uniforms )
	{
		//prepare context
		this.clear();

		//grab output nodes
		var vertexout = graph.findNodesByType("shader::output/vertex");
		vertexout = vertexout && vertexout.length ? vertexout[0] : null;
		var fragmentout = graph.findNodesByType("shader::output/fragcolor");
		fragmentout = fragmentout && fragmentout.length ? fragmentout[0] : null;
		if(!fragmentout) //??
			return null; 

		//propagate back destinations
		graph.sendEventToAllNodes( "clearDestination" );
		if(vertexout)
			vertexout.propagateDestination("vs");
		if(fragmentout)
			fragmentout.propagateDestination("fs");

		//gets code from graph
		graph.sendEventToAllNodes("onGetCode", this );

		var uniforms = "";
		for(var i in this._uniforms)
			uniforms += "uniform " + this._uniforms[i] + " " + i + ";\n";
		if(extra_uniforms)
			for(var i in extra_uniforms)
				uniforms += "uniform " + extra_uniforms[i] + " " + i + ";\n";

		var functions = "";
		for(var i in this._functions)
			functions += "//" + i + "\n" + this._functions[i] + "\n";

		var blocks = this._codeparts;
		blocks.uniforms = uniforms;
		blocks.functions = functions;
		return blocks;
	}

	//replaces blocks using the vs and fs template and returns the final codes
	LGShaderContext.prototype.computeShaderCode = function( graph )
	{
		var blocks = this.computeCodeBlocks( graph );
		var vs_code = GL.Shader.replaceCodeUsingContext( this.vs_template, blocks );
		var fs_code = GL.Shader.replaceCodeUsingContext( this.fs_template, blocks );
		return {
			vs_code: vs_code,
			fs_code: fs_code
		};
	}

	//generates the shader code from the template and the 
	LGShaderContext.prototype.computeShader = function( graph, shader )
	{
		var finalcode = this.computeShaderCode( graph );
		console.log( finalcode.vs_code, finalcode.fs_code );

		if(!LiteGraph.catch_exceptions)
		{
			this._shader_error = true;
			if(shader)
				shader.updateShader( finalcode.vs_code, finalcode.fs_code );
			else
				shader = new GL.Shader( finalcode.vs_code, finalcode.fs_code );
			this._shader_error = false;
			return shader;
		}

		try
		{
			if(shader)
				shader.updateShader( finalcode.vs_code, finalcode.fs_code );
			else
				shader = new GL.Shader( finalcode.vs_code, finalcode.fs_code );
			this._shader_error = false;
			return shader;
		}
		catch (err)
		{
			if(!this._shader_error)
			{
				console.error(err);
				if(err.indexOf("Fragment shader") != -1)
					console.log( finalcode.fs_code.split("\n").map(function(v,i){ return i + ".- " + v; }).join("\n") );
				else
					console.log( finalcode.vs_code );
			}
			this._shader_error = true;
			return null;
		}

		return null;//never here
	}

	LGShaderContext.prototype.getShader = function( graph )
	{
		//if graph not changed?
		if(this._shader && this._shader._version == graph._version)
			return this._shader;

		//compile shader
		var shader = this.computeShader( graph, this._shader );
		if(!shader)
			return null;
		
		this._shader = shader;
		shader._version = graph._version;
		return shader;
	}

	//some shader nodes could require to fill the box with some uniforms
	LGShaderContext.prototype.fillUniforms = function( uniforms, param )
	{
		if(!this._uniform_value)
			return;

		for(var i in this._uniform_value)
		{
			var v = this._uniform_value[i];
			if(v == null)
				continue;
			if(v.constructor === Function)
				uniforms[i] = v.call( this, param );
			else if(v.constructor === GL.Texture)
			{
				//todo...
			}
			else
				uniforms[i] = v;
		}
	}

	LiteGraph.ShaderContext = LiteGraph.Shaders.Context = LGShaderContext;

	// LGraphShaderGraph *****************************
	// applies a shader graph to texture, it can be uses as an example

	function LGraphShaderGraph() {

		//before inputs
        this.subgraph = new LiteGraph.LGraph();
        this.subgraph._subgraph_node = this;
        this.subgraph._is_subgraph = true;
		this.subgraph.filter = "shader";

		this.addInput("in", "texture");
		this.addOutput("out", "texture");
		this.properties = { width: 0, height: 0, alpha: false, precision: typeof(LGraphTexture) != "undefined" ? LGraphTexture.DEFAULT : 2 };

		var inputNode = this.subgraph.findNodesByType("shader::input/uniform")[0];
		inputNode.pos = [200,300];

		var sampler = LiteGraph.createNode("shader::texture/sampler2D");
		sampler.pos = [400,300];
		this.subgraph.add( sampler );

		var outnode = LiteGraph.createNode("shader::output/fragcolor");
		outnode.pos = [600,300];
		this.subgraph.add( outnode );

		inputNode.connect( 0, sampler );
		sampler.connect( 0, outnode );

		this.size = [180,60];
		this.redraw_on_mouse = true; //force redraw

		this._uniforms = {};
		this._shader = null;
		this._context = new LGShaderContext();
		this._context.vs_template = "#define VERTEX\n" + GL.Shader.SCREEN_VERTEX_SHADER;
		this._context.fs_template = LGraphShaderGraph.template;
	}

	LGraphShaderGraph.template = "\n\
#define FRAGMENT\n\
precision highp float;\n\
varying vec2 v_coord;\n\
{{varying}}\n\
{{uniforms}}\n\
{{functions}}\n\
{{fs_functions}}\n\
void main() {\n\n\
vec2 uv = v_coord;\n\
vec4 fragcolor = vec4(0.0);\n\
vec4 fragcolor1 = vec4(0.0);\n\
{{fs_code}}\n\
gl_FragColor = fragcolor;\n\
}\n\
	";

	LGraphShaderGraph.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphShaderGraph.title = "ShaderGraph";
	LGraphShaderGraph.desc = "Builds a shader using a graph";
	LGraphShaderGraph.input_node_type = "input/uniform";
	LGraphShaderGraph.output_node_type = "output/fragcolor";
	LGraphShaderGraph.title_color = SHADERNODES_COLOR;

	LGraphShaderGraph.prototype.onSerialize = function(o)
	{
		o.subgraph = this.subgraph.serialize();
	}

	LGraphShaderGraph.prototype.onConfigure = function(o)
	{
		this.subgraph.configure(o.subgraph);
	}

	LGraphShaderGraph.prototype.onExecute = function() {
		if (!this.isOutputConnected(0))
			return;

		//read input texture
		var intex = this.getInputData(0);
		if(intex && intex.constructor != GL.Texture)
			intex = null;

		var w = this.properties.width | 0;
		var h = this.properties.height | 0;
		if (w == 0) {
			w = intex ? intex.width : gl.viewport_data[2];
		} //0 means default
		if (h == 0) {
			h = intex ? intex.height : gl.viewport_data[3];
		} //0 means default

		var type = LGraphTexture.getTextureType( this.properties.precision, intex );

		var texture = this._texture;
		if ( !texture || texture.width != w || texture.height != h || texture.type != type ) {
			texture = this._texture = new GL.Texture(w, h, {
				type: type,
				format: this.alpha ? gl.RGBA : gl.RGB,
				filter: gl.LINEAR
			});
		}
		
		var shader = this.getShader( this.subgraph );
		if(!shader)
			return;

		var uniforms = this._uniforms;
		this._context.fillUniforms( uniforms );

		var tex_slot = 0;
		if(this.inputs)
		for(var i = 0; i < this.inputs.length; ++i)
		{
			var input = this.inputs[i];
			var data = this.getInputData(i);
			if(input.type == "texture")
			{
				if(!data)
					data = GL.Texture.getWhiteTexture();
				data = data.bind(tex_slot++);
			}

			if(data != null)
				uniforms[ "u_" + input.name ] = data;
		}

		var mesh = GL.Mesh.getScreenQuad();

		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.BLEND );

		texture.drawTo(function(){
			shader.uniforms( uniforms );
			shader.draw( mesh );
		});

		//use subgraph output 
		this.setOutputData(0, texture );
	};

	//add input node inside subgraph
	LGraphShaderGraph.prototype.onInputAdded = function( slot_info )
	{
		var subnode = LiteGraph.createNode("shader::input/uniform");
		subnode.setProperty("name",slot_info.name);
		subnode.setProperty("type",slot_info.type);
		this.subgraph.add( subnode );
	}

	//remove all
	LGraphShaderGraph.prototype.onInputRemoved = function( slot, slot_info )
	{
		var nodes = this.subgraph.findNodesByType("shader::input/uniform");
		for(var i = 0; i < nodes.length; ++i)
		{
			var node = nodes[i];
			if(node.properties.name == slot_info.name )
				this.subgraph.remove( node );
		}
	}

	LGraphShaderGraph.prototype.computeSize = function()
	{
		var num_inputs = this.inputs ? this.inputs.length : 0;
		var num_outputs = this.outputs ? this.outputs.length : 0;
		return [ 200, Math.max(num_inputs,num_outputs) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT + 10];
	}

	LGraphShaderGraph.prototype.getShader = function()
	{
		var shader = this._context.getShader( this.subgraph );
		if(!shader)
			this.boxcolor = "red";
		else
			this.boxcolor = null;
		return shader;
	}

	LGraphShaderGraph.prototype.onDrawBackground = function(ctx, graphcanvas, canvas, pos)
	{
		if(this.flags.collapsed)
			return;

		//allows to preview the node if the canvas is a webgl canvas
		var tex = this.getOutputData(0);
		var inputs_y = this.inputs ? this.inputs.length * LiteGraph.NODE_SLOT_HEIGHT : 0;
		if (tex && ctx == tex.gl && this.size[1] > inputs_y + LiteGraph.NODE_TITLE_HEIGHT ) {
			ctx.drawImage( tex, 10,y, this.size[0] - 20, this.size[1] - inputs_y - LiteGraph.NODE_TITLE_HEIGHT );
		}

		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;

		//button
		var over = LiteGraph.isInsideRectangle(pos[0],pos[1],this.pos[0],this.pos[1] + y,this.size[0],LiteGraph.NODE_TITLE_HEIGHT);
		ctx.fillStyle = over ? "#555" : "#222";
		ctx.beginPath();
		if (this._shape == LiteGraph.BOX_SHAPE)
			ctx.rect(0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT);
		else
			ctx.roundRect( 0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT, 0, 8);
		ctx.fill();

		//button
		ctx.textAlign = "center";
		ctx.font = "24px Arial";
		ctx.fillStyle = over ? "#DDD" : "#999";
		ctx.fillText( "+", this.size[0] * 0.5, y + 24 );
	}

	LGraphShaderGraph.prototype.onMouseDown = function(e, localpos, graphcanvas)
	{
		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
		if(localpos[1] > y)
		{
			graphcanvas.showSubgraphPropertiesDialog(this);
		}
	}

	LGraphShaderGraph.prototype.onDrawSubgraphBackground = function(graphcanvas)
	{
		//TODO
	}

	LGraphShaderGraph.prototype.getExtraMenuOptions = function(graphcanvas)
	{
		var that = this;
		var options = [{ content: "Print Code", callback: function(){
			var code = that._context.computeShaderCode();
			console.log( code.vs_code, code.fs_code );
		}}];

		return options;
	}

	LiteGraph.registerNodeType( "texture/shaderGraph", LGraphShaderGraph );

	function shaderNodeFromFunction( classname, params, return_type, code )
	{
		//TODO
	}

	//Shader Nodes ***********************************************************

	//applies a shader graph to a code
	function LGraphShaderUniform() {
		this.addOutput("out", "");
		this.properties = { name: "", type: "" };
	}

	LGraphShaderUniform.title = "Uniform";
	LGraphShaderUniform.desc = "Input data for the shader";

	LGraphShaderUniform.prototype.getTitle = function()
	{
		if( this.properties.name && this.flags.collapsed)
			return this.properties.type + " " + this.properties.name;
		return "Uniform";
	}

	LGraphShaderUniform.prototype.onPropertyChanged = function(name,value)
	{
		this.outputs[0].name = this.properties.type + " " + this.properties.name;
	}

	LGraphShaderUniform.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var type = this.properties.type;
		if( !type )
		{
			if( !context.onGetPropertyInfo )
				return;
			var info = context.onGetPropertyInfo( this.property.name );
			if(!info)
				return;
			type = info.type;
		}
		if(type == "number")
			type = "float";
		else if(type == "texture")
			type = "sampler2D";
		if ( LGShaders.GLSL_types.indexOf(type) == -1 )
			return;

		context.addUniform( "u_" + this.properties.name, type );
		this.setOutputData( 0, type );
	}

	LGraphShaderUniform.prototype.getOutputVarName = function(slot)
	{
		return "u_" + this.properties.name;
	}

	registerShaderNode( "input/uniform", LGraphShaderUniform );


	function LGraphShaderAttribute() {
		this.addOutput("out", "vec2");
		this.properties = { name: "coord", type: "vec2" };
	}

	LGraphShaderAttribute.title = "Attribute";
	LGraphShaderAttribute.desc = "Input data from mesh attribute";

	LGraphShaderAttribute.prototype.getTitle = function()
	{
		return "att. " + this.properties.name;
	}

	LGraphShaderAttribute.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var type = this.properties.type;
		if( !type || LGShaders.GLSL_types.indexOf(type) == -1 )
			return;
		if(type == "number")
			type = "float";
		if( this.properties.name != "coord")
		{
			context.addCode( "varying", " varying " + type +" v_" + this.properties.name + ";" );
			//if( !context.varyings[ this.properties.name ] )
			//context.addCode( "vs_code", "v_" + this.properties.name + " = " + input_name + ";" );
		}
		this.setOutputData( 0, type );
	}

	LGraphShaderAttribute.prototype.getOutputVarName = function(slot)
	{
		return "v_" + this.properties.name;
	}

	registerShaderNode( "input/attribute", LGraphShaderAttribute );

	function LGraphShaderSampler2D() {
		this.addInput("tex", "sampler2D");
		this.addInput("uv", "vec2");
		this.addOutput("rgba", "vec4");
		this.addOutput("rgb", "vec3");
	}

	LGraphShaderSampler2D.title = "Sampler2D";
	LGraphShaderSampler2D.desc = "Reads a pixel from a texture";

	LGraphShaderSampler2D.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var texname = getInputLinkID( this, 0 );
		var varname = getShaderNodeVarName(this);
		var code = "vec4 " + varname + " = vec4(0.0);\n";
		if(texname)
		{
			var uvname = getInputLinkID( this, 1 ) || context.buffer_names.uvs;
			code += varname + " = texture2D("+texname+","+uvname+");\n";
		}

		var link0 = getOutputLinkID( this, 0 );
		if(link0)
			code += "vec4 " + getOutputLinkID( this, 0 ) + " = "+varname+";\n";

		var link1 = getOutputLinkID( this, 1 );
		if(link1)
			code += "vec3 " + getOutputLinkID( this, 1 ) + " = "+varname+".xyz;\n";

		context.addCode( "code", code, this.shader_destination );
		this.setOutputData( 0, "vec4" );
		this.setOutputData( 1, "vec3" );
	}

	registerShaderNode( "texture/sampler2D", LGraphShaderSampler2D );

	//*********************************

	function LGraphShaderConstant()
	{
		this.addOutput("","float");

		this.properties = {
			type: "float",
			value: 0
		};

		this.addWidget("combo","type","float",null, { values: GLSL_types_const, property: "type" } );
		this.updateWidgets();
	}

	LGraphShaderConstant.title = "const";

	LGraphShaderConstant.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return valueToGLSL( this.properties.value, this.properties.type, 2 );
		return "Const";
	}

	LGraphShaderConstant.prototype.onPropertyChanged = function(name,value)
	{
		var that = this;
		if(name == "type")
		{
			if(this.outputs[0].type != value)
			{
				this.disconnectOutput(0);
				this.outputs[0].type = value;
			}
			this.widgets.length = 1; //remove extra widgets
			this.updateWidgets();
		}
		if(name == "value")
		{
			if(!value.length)
				this.widgets[1].value = value;
			else
			{
				this.widgets[1].value = value[1];
				if(value.length > 2)
					this.widgets[2].value = value[2];
				if(value.length > 3)
					this.widgets[3].value = value[3];
			}
		}
	}

	LGraphShaderConstant.prototype.updateWidgets = function( old_value )
	{
		var that = this;
		var old_value = this.properties.value;
		var options = { step: 0.01 };
		switch(this.properties.type)
		{
			case 'float': 
				this.properties.value = 0;
				this.addWidget("number","v",0,{ step:0.01, property: "value" });
				break;
			case 'vec2': 
				this.properties.value = old_value && old_value.length == 2 ? [old_value[0],old_value[1]] : [0,0,0];
				this.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); 
				this.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); 
				break;
			case 'vec3': 
				this.properties.value = old_value && old_value.length == 3 ? [old_value[0],old_value[1],old_value[2]] : [0,0,0];
				this.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); 
				this.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); 
				this.addWidget("number","z",this.properties.value[2], function(v){ that.properties.value[2] = v; },options); 
				break;
			case 'vec4': 
				this.properties.value = old_value && old_value.length == 4 ? [old_value[0],old_value[1],old_value[2],old_value[3]] : [0,0,0,0];
				this.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); 
				this.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); 
				this.addWidget("number","z",this.properties.value[2], function(v){ that.properties.value[2] = v; },options); 
				this.addWidget("number","w",this.properties.value[3], function(v){ that.properties.value[3] = v; },options); 
				break;
			default:
				console.error("unknown type for constant");
		}
	}

	LGraphShaderConstant.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var value = valueToGLSL( this.properties.value, this.properties.type );
		var link_name = getOutputLinkID(this,0);
		if(!link_name) //not connected
			return;

		var code = "	" + this.properties.type + " " + link_name + " = " + value + ";";
		context.addCode( "code", code, this.shader_destination );

		this.setOutputData( 0, this.properties.type );
	}

	registerShaderNode( "const/const", LGraphShaderConstant );

	function LGraphShaderVec2()
	{
		this.addInput("xy","vec2");
		this.addInput("x","float");
		this.addInput("y","float");
		this.addOutput("xy","vec2");
		this.addOutput("x","float");
		this.addOutput("y","float");

		this.properties = { x: 0, y: 0 };
	}

	LGraphShaderVec2.title = "vec2";
	LGraphShaderVec2.varmodes = ["xy","x","y"];

	LGraphShaderVec2.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			 this.graph._version++;
	}

	LGraphShaderVec2.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var props = this.properties;

		var varname = getShaderNodeVarName(this);
		var code = "	vec2 " + varname + " = " + valueToGLSL([props.x,props.y]) + ";\n";

		for(var i = 0;i < LGraphShaderVec2.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec2.varmodes[i];
			var inlink = getInputLinkID(this,i);
			if(!inlink)
				continue;
			code += "	" + varname + "."+varmode+" = " + inlink + ";\n";
		}

		for(var i = 0;i < LGraphShaderVec2.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec2.varmodes[i];
			var outlink = getOutputLinkID(this,i);
			if(!outlink)
				continue;
			var type = GLSL_types_const[varmode.length - 1];
			code += "	"+type+" " + outlink + " = " + varname + "." + varmode + ";\n";
			this.setOutputData( i, type );
		}

		context.addCode( "code", code, this.shader_destination );
	}

	registerShaderNode( "const/vec2", LGraphShaderVec2 );	

	function LGraphShaderVec3()
	{
		this.addInput("xyz","vec3");
		this.addInput("x","float");
		this.addInput("y","float");
		this.addInput("z","float");
		this.addInput("xy","vec2");
		this.addInput("xz","vec2");
		this.addInput("yz","vec2");
		this.addOutput("xyz","vec3");
		this.addOutput("x","float");
		this.addOutput("y","float");
		this.addOutput("z","float");
		this.addOutput("xy","vec2");
		this.addOutput("xz","vec2");
		this.addOutput("yz","vec2");

		this.properties = { x:0, y: 0, z: 0 };
	}

	LGraphShaderVec3.title = "vec3";
	LGraphShaderVec3.varmodes = ["xyz","x","y","z","xy","xz","yz"];

	LGraphShaderVec3.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			this.graph._version++;
	}

	LGraphShaderVec3.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var props = this.properties;

		var varname = getShaderNodeVarName(this);
		var code = "vec3 " + varname + " = " + valueToGLSL([props.x,props.y,props.z]) + ";\n";

		for(var i = 0;i < LGraphShaderVec3.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec3.varmodes[i];
			var inlink = getInputLinkID(this,i);
			if(!inlink)
				continue;
			code += "	" + varname + "."+varmode+" = " + inlink + ";\n";
		}

		for(var i = 0; i < LGraphShaderVec3.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec3.varmodes[i];
			var outlink = getOutputLinkID(this,i);
			if(!outlink)
				continue;
			var type = GLSL_types_const[varmode.length - 1];
			code += "	"+type+" " + outlink + " = " + varname + "." + varmode + ";\n";
			this.setOutputData( i, type );
		}

		context.addCode( "code", code, this.shader_destination );
	}

	registerShaderNode( "const/vec3", LGraphShaderVec3 );	


	function LGraphShaderVec4()
	{
		this.addInput("xyzw","vec4");
		this.addInput("xyz","vec3");
		this.addInput("x","float");
		this.addInput("y","float");
		this.addInput("z","float");
		this.addInput("w","float");
		this.addInput("xy","vec2");
		this.addInput("yz","vec2");
		this.addInput("zw","vec2");
		this.addOutput("xyzw","vec4");
		this.addOutput("xyz","vec3");
		this.addOutput("x","float");
		this.addOutput("y","float");
		this.addOutput("z","float");
		this.addOutput("xy","vec2");
		this.addOutput("yz","vec2");
		this.addOutput("zw","vec2");

		this.properties = { x:0, y: 0, z: 0, w: 0 };
	}

	LGraphShaderVec4.title = "vec4";
	LGraphShaderVec4.varmodes = ["xyzw","xyz","x","y","z","w","xy","yz","zw"];

	LGraphShaderVec4.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			this.graph._version++;
	}

	LGraphShaderVec4.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var props = this.properties;

		var varname = getShaderNodeVarName(this);
		var code = "vec4 " + varname + " = " + valueToGLSL([props.x,props.y,props.z,props.w]) + ";\n";

		for(var i = 0;i < LGraphShaderVec4.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec4.varmodes[i];
			var inlink = getInputLinkID(this,i);
			if(!inlink)
				continue;
			code += "	" + varname + "."+varmode+" = " + inlink + ";\n";
		}

		for(var i = 0;i < LGraphShaderVec4.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec4.varmodes[i];
			var outlink = getOutputLinkID(this,i);
			if(!outlink)
				continue;
			var type = GLSL_types_const[varmode.length - 1];
			code += "	"+type+" " + outlink + " = " + varname + "." + varmode + ";\n";
			this.setOutputData( i, type );
		}

		context.addCode( "code", code, this.shader_destination );

	}

	registerShaderNode( "const/vec4", LGraphShaderVec4 );	
	
	//*********************************

	function LGraphShaderFragColor() {
		this.addInput("color", LGShaders.ALL_TYPES );
		this.block_delete = true;
	}

	LGraphShaderFragColor.title = "FragColor";
	LGraphShaderFragColor.desc = "Pixel final color";

	LGraphShaderFragColor.prototype.onGetCode = function( context )
	{
		var link_name = getInputLinkID( this, 0 );
		if(!link_name)
			return;
		var type = this.getInputData(0);
		var code = varToTypeGLSL( link_name, type, "vec4" );
		context.addCode("fs_code", "fragcolor = " + code + ";");
	}

	registerShaderNode( "output/fragcolor", LGraphShaderFragColor );


	/*
	function LGraphShaderDiscard()
	{
		this.addInput("v","T");
		this.addInput("min","T");
		this.properties = { min_value: 0.0 };
		this.addWidget("number","min",0,{ step: 0.01, property: "min_value" });
	}

	LGraphShaderDiscard.title = "Discard";

	LGraphShaderDiscard.prototype.onGetCode = function( context )
	{
		if(!this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var inlink1 = getInputLinkID(this,1);

		if(!inlink && !inlink1) //not connected
			return;
		context.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "output/discard", LGraphShaderDiscard );
	*/


	// *************************************************

	function LGraphShaderOperation()
	{
		this.addInput("A", LGShaders.ALL_TYPES );
		this.addInput("B", LGShaders.ALL_TYPES );
		this.addOutput("out","");
		this.properties = {
			operation: "*"
		};
		this.addWidget("combo","op.",this.properties.operation,{ property: "operation", values: LGraphShaderOperation.operations });
	}

	LGraphShaderOperation.title = "Operation";
	LGraphShaderOperation.operations = ["+","-","*","/"];

	LGraphShaderOperation.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return "A" + this.properties.operation + "B";
		else
			return "Operation";
	}

	LGraphShaderOperation.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		if(!this.isOutputConnected(0))
			return;

		var inlinks = [];
		for(var i = 0; i < 3; ++i)
			inlinks.push( { name: getInputLinkID(this,i), type: this.getInputData(i) || "float" } );

		var outlink = getOutputLinkID(this,0);
		if(!outlink) //not connected
			return;

		//func_desc
		var base_type = inlinks[0].type;
		var return_type = base_type;
		var op = this.properties.operation;

		var params = [];
		for(var i = 0; i < 2; ++i)
		{
			var param_code = inlinks[i].name;
			if(param_code == null) //not plugged
			{
				param_code = p.value != null ? p.value : "(1.0)";
				inlinks[i].type = "float";
			}

			//convert
			if( inlinks[i].type != base_type ) 
			{
				if( inlinks[i].type == "float" && (op == "*" || op == "/") )
				{
					//I find hard to create the opposite condition now, so I prefeer an else
				}
				else
					param_code = convertVarToGLSLType( param_code, inlinks[i].type, base_type );
			}
			params.push( param_code );
		}
		
		context.addCode("code", return_type + " " + outlink + " = "+ params[0] + op + params[1] + ";", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "math/operation", LGraphShaderOperation );


	function LGraphShaderFunc()
	{
		this.addInput("A", LGShaders.ALL_TYPES );
		this.addInput("B", LGShaders.ALL_TYPES );
		this.addOutput("out","");
		this.properties = {
			func: "floor"
		};
		this._current = "floor";
		this.addWidget("combo","func",this.properties.func,{ property: "func", values: GLSL_functions_name });
	}

	LGraphShaderFunc.title = "Func";

	LGraphShaderFunc.prototype.onPropertyChanged = function(name,value)
	{
		if(this.graph)
			this.graph._version++;

		if(name == "func")
		{
			var func_desc = GLSL_functions[ value ];
			if(!func_desc)
				return;

			//remove extra inputs
			for(var i = func_desc.params.length; i < this.inputs.length; ++i)
				this.removeInput(i);

			//add and update inputs
			for(var i = 0; i < func_desc.params.length; ++i)
			{
				var p = func_desc.params[i];
				if( this.inputs[i] )
					this.inputs[i].name = p.name + (p.value ? " (" + p.value + ")" : "");
				else
					this.addInput( p.name, LGShaders.ALL_TYPES );
			}
		}
	}

	LGraphShaderFunc.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return this.properties.func;
		else
			return "Func";
	}

	LGraphShaderFunc.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		if(!this.isOutputConnected(0))
			return;

		var inlinks = [];
		for(var i = 0; i < 3; ++i)
			inlinks.push( { name: getInputLinkID(this,i), type: this.getInputData(i) || "float" } );

		var outlink = getOutputLinkID(this,0);
		if(!outlink) //not connected
			return;

		var func_desc = GLSL_functions[ this.properties.func ];
		if(!func_desc)
			return;

		//func_desc
		var base_type = inlinks[0].type;
		var return_type = func_desc.return_type;
		if( return_type == "T" )
			return_type = base_type;

		var params = [];
		for(var i = 0; i < func_desc.params.length; ++i)
		{
			var p = func_desc.params[i];
			var param_code = inlinks[i].name;
			if(param_code == null) //not plugged
			{
				param_code = p.value != null ? p.value : "(1.0)";
				inlinks[i].type = "float";
			}
			if( (p.type == "T" && inlinks[i].type != base_type) ||
				(p.type != "T" && inlinks[i].type != base_type) )
				param_code = convertVarToGLSLType( param_code, inlinks[i].type, base_type );
			params.push( param_code );
		}
		
		context.addFunction("round","float round(float v){ return floor(v+0.5); }\nvec2 round(vec2 v){ return floor(v+vec2(0.5));}\nvec3 round(vec3 v){ return floor(v+vec3(0.5));}\nvec4 round(vec4 v){ return floor(v+vec4(0.5)); }\n");
		context.addCode("code", return_type + " " + outlink + " = "+func_desc.func+"("+params.join(",")+");", this.shader_destination );

		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "math/func", LGraphShaderFunc );



	function LGraphShaderSnippet()
	{
		this.addInput("A", LGShaders.ALL_TYPES );
		this.addInput("B", LGShaders.ALL_TYPES );
		this.addOutput("C","vec4");
		this.properties = {
			code:"C = A+B",
			type: "vec4"
		}
		this.addWidget("text","code",this.properties.code,{ property: "code" });
		this.addWidget("combo","type",this.properties.type,{ values:["float","vec2","vec3","vec4"], property: "type" });
	}

	LGraphShaderSnippet.title = "Snippet";

	LGraphShaderSnippet.prototype.onPropertyChanged = function(name,value)
	{
		if(this.graph)
			this.graph._version++;

		if(name == "type"&& this.outputs[0].type != value)
		{
			this.disconnectOutput(0);
			this.outputs[0].type = value;
		}
	}

	LGraphShaderSnippet.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return this.properties.code;
		else
			return "Snippet";
	}

	LGraphShaderSnippet.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlinkA = getInputLinkID(this,0);
		if(!inlinkA)
			inlinkA = "1.0";
		var inlinkB = getInputLinkID(this,1);
		if(!inlinkB)
			inlinkB = "1.0";
		var outlink = getOutputLinkID(this,0);
		if(!outlink) //not connected
			return;

		var inA_type = this.getInputData(0) || "float";
		var inB_type = this.getInputData(1) || "float";
		var return_type = this.properties.type;

		//cannot resolve input
		if(inA_type == "T" || inB_type == "T")
		{
			return null;
		}

		var funcname = "funcSnippet" + this.id;

		var func_code = "\n" + return_type + " " + funcname + "( " + inA_type + " A, " + inB_type + " B) {\n";
		func_code += "	" + return_type + " C = " + return_type + "(0.0);\n";
		func_code += "	" + this.properties.code + ";\n";
		func_code += "	return C;\n}\n";

		context.addCode("functions", func_code, this.shader_destination );
		context.addCode("code", return_type + " " + outlink + " = "+funcname+"("+inlinkA+","+inlinkB+");", this.shader_destination );

		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "utils/snippet", LGraphShaderSnippet );

	//************************************

	function LGraphShaderRand()
	{
		this.addOutput("out","float");
	}

	LGraphShaderRand.title = "Rand";

	LGraphShaderRand.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var outlink = getOutputLinkID(this,0);

		context.addUniform( "u_rand" + this.id, "float", function(){ return Math.random(); });
		context.addCode("code", "float " + outlink + " = u_rand" + this.id +";", this.shader_destination );
		this.setOutputData( 0, "float" );
	}

	registerShaderNode( "input/rand", LGraphShaderRand );

	//noise
	//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
	function LGraphShaderNoise()
	{
		this.addInput("out", LGShaders.ALL_TYPES );
		this.addInput("scale", "float" );
		this.addOutput("out","float");
		this.properties = {
			type: "noise",
			scale: 1
		};
		this.addWidget("combo","type", this.properties.type, { property: "type", values: LGraphShaderNoise.NOISE_TYPES });
		this.addWidget("number","scale", this.properties.scale, { property: "scale" });
	}

	LGraphShaderNoise.NOISE_TYPES = ["noise","rand"];

	LGraphShaderNoise.title = "noise";

	LGraphShaderNoise.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var outlink = getOutputLinkID(this,0);

		var intype = this.getInputData(0);
		if(!inlink)
		{
			intype = "vec2";
			inlink = context.buffer_names.uvs;
		}

		context.addFunction("noise",LGraphShaderNoise.shader_functions);
		context.addUniform( "u_noise_scale" + this.id, "float", this.properties.scale );
		if( intype == "float" )
			context.addCode("code", "float " + outlink + " = snoise( vec2(" + inlink +") * u_noise_scale" + this.id +");", this.shader_destination );
		else if( intype == "vec2" || intype == "vec3" )
			context.addCode("code", "float " + outlink + " = snoise(" + inlink +" * u_noise_scale" + this.id +");", this.shader_destination );
		else if( intype == "vec4" )
			context.addCode("code", "float " + outlink + " = snoise(" + inlink +".xyz * u_noise_scale" + this.id +");", this.shader_destination );
		this.setOutputData( 0, "float" );
	}

	registerShaderNode( "math/noise", LGraphShaderNoise );

LGraphShaderNoise.shader_functions = "\n\
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\
\n\
float snoise(vec2 v){\n\
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,-0.577350269189626, 0.024390243902439);\n\
  vec2 i  = floor(v + dot(v, C.yy) );\n\
  vec2 x0 = v -   i + dot(i, C.xx);\n\
  vec2 i1;\n\
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\
  vec4 x12 = x0.xyxy + C.xxzz;\n\
  x12.xy -= i1;\n\
  i = mod(i, 289.0);\n\
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\
  + i.x + vec3(0.0, i1.x, 1.0 ));\n\
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)), 0.0);\n\
  m = m*m ;\n\
  m = m*m ;\n\
  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n\
  vec3 h = abs(x) - 0.5;\n\
  vec3 ox = floor(x + 0.5);\n\
  vec3 a0 = x - ox;\n\
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\
  vec3 g;\n\
  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n\
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\
  return 130.0 * dot(m, g);\n\
}\n\
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\
\n\
float snoise(vec3 v){ \n\
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\
\n\
// First corner\n\
  vec3 i  = floor(v + dot(v, C.yyy) );\n\
  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\
\n\
// Other corners\n\
  vec3 g = step(x0.yzx, x0.xyz);\n\
  vec3 l = 1.0 - g;\n\
  vec3 i1 = min( g.xyz, l.zxy );\n\
  vec3 i2 = max( g.xyz, l.zxy );\n\
\n\
  //  x0 = x0 - 0. + 0.0 * C \n\
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n\
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n\
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\
\n\
// Permutations\n\
  i = mod(i, 289.0 ); \n\
  vec4 p = permute( permute( permute( \n\
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\
\n\
// Gradients\n\
// ( N*N points uniformly over a square, mapped onto an octahedron.)\n\
  float n_ = 1.0/7.0; // N=7\n\
  vec3  ns = n_ * D.wyz - D.xzx;\n\
\n\
  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\
\n\
  vec4 x_ = floor(j * ns.z);\n\
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\
\n\
  vec4 x = x_ *ns.x + ns.yyyy;\n\
  vec4 y = y_ *ns.x + ns.yyyy;\n\
  vec4 h = 1.0 - abs(x) - abs(y);\n\
\n\
  vec4 b0 = vec4( x.xy, y.xy );\n\
  vec4 b1 = vec4( x.zw, y.zw );\n\
\n\
  vec4 s0 = floor(b0)*2.0 + 1.0;\n\
  vec4 s1 = floor(b1)*2.0 + 1.0;\n\
  vec4 sh = -step(h, vec4(0.0));\n\
\n\
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\
\n\
  vec3 p0 = vec3(a0.xy,h.x);\n\
  vec3 p1 = vec3(a0.zw,h.y);\n\
  vec3 p2 = vec3(a1.xy,h.z);\n\
  vec3 p3 = vec3(a1.zw,h.w);\n\
\n\
//Normalise gradients\n\
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\
  p0 *= norm.x;\n\
  p1 *= norm.y;\n\
  p2 *= norm.z;\n\
  p3 *= norm.w;\n\
\n\
// Mix final noise value\n\
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\
  m = m * m;\n\
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n\
}\n\
\n\
vec3 hash3( vec2 p ){\n\
    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\
				   dot(p,vec2(269.5,183.3)), \n\
				   dot(p,vec2(419.2,371.9)) );\n\
	return fract(sin(q)*43758.5453);\n\
}\n\
vec4 hash4( vec3 p ){\n\
    vec4 q = vec4( dot(p,vec3(127.1,311.7,257.3)), \n\
				   dot(p,vec3(269.5,183.3,335.1)), \n\
				   dot(p,vec3(314.5,235.1,467.3)), \n\
				   dot(p,vec3(419.2,371.9,114.9)) );\n\
	return fract(sin(q)*43758.5453);\n\
}\n\
\n\
float iqnoise( in vec2 x, float u, float v ){\n\
    vec2 p = floor(x);\n\
    vec2 f = fract(x);\n\
	\n\
	float k = 1.0+63.0*pow(1.0-v,4.0);\n\
	\n\
	float va = 0.0;\n\
	float wt = 0.0;\n\
    for( int j=-2; j<=2; j++ )\n\
    for( int i=-2; i<=2; i++ )\n\
    {\n\
        vec2 g = vec2( float(i),float(j) );\n\
		vec3 o = hash3( p + g )*vec3(u,u,1.0);\n\
		vec2 r = g - f + o.xy;\n\
		float d = dot(r,r);\n\
		float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\
		va += o.z*ww;\n\
		wt += ww;\n\
    }\n\
	\n\
    return va/wt;\n\
}\n\
"

	function LGraphShaderTime()
	{
		this.addOutput("out","float");
	}

	LGraphShaderTime.title = "Time";

	LGraphShaderTime.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var outlink = getOutputLinkID(this,0);

		context.addUniform( "u_time" + this.id, "float", function(){ return getTime() * 0.001; });
		context.addCode("code", "float " + outlink + " = u_time" + this.id +";", this.shader_destination );
		this.setOutputData( 0, "float" );
	}

	registerShaderNode( "input/time", LGraphShaderTime );


	function LGraphShaderDither()
	{
		this.addInput("in","T");
		this.addOutput("out","float");
	}

	LGraphShaderDither.title = "Dither";

	LGraphShaderDither.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var return_type = "float";
		var outlink = getOutputLinkID(this,0);
		var intype = this.getInputData(0);
		inlink = varToTypeGLSL( inlink, intype, "float" );
		context.addFunction("dither8x8", LGraphShaderDither.dither_func);
		context.addCode("code", return_type + " " + outlink + " = dither8x8("+ inlink +");", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	LGraphShaderDither.dither_values = [0.515625,0.140625,0.640625,0.046875,0.546875,0.171875,0.671875,0.765625,0.265625,0.890625,0.390625,0.796875,0.296875,0.921875,0.421875,0.203125,0.703125,0.078125,0.578125,0.234375,0.734375,0.109375,0.609375,0.953125,0.453125,0.828125,0.328125,0.984375,0.484375,0.859375,0.359375,0.0625,0.5625,0.1875,0.6875,0.03125,0.53125,0.15625,0.65625,0.8125,0.3125,0.9375,0.4375,0.78125,0.28125,0.90625,0.40625,0.25,0.75,0.125,0.625,0.21875,0.71875,0.09375,0.59375,1.0001,0.5,0.875,0.375,0.96875,0.46875,0.84375,0.34375];
	
	LGraphShaderDither.dither_func = "\n\
		float dither8x8(float brightness) {\n\
		  vec2 position = vec2(0.0);\n\
		  #ifdef FRAGMENT\n\
			position = gl_FragCoord.xy;\n\
		  #endif\n\
		  int x = int(mod(position.x, 8.0));\n\
		  int y = int(mod(position.y, 8.0));\n\
		  int index = x + y * 8;\n\
		  float limit = 0.0;\n\
		  if (x < 8) {\n\
			if(index==0) limit = 0.015625;\n\
			"+(LGraphShaderDither.dither_values.map( function(v,i){ return "else if(index== "+(i+1)+") limit = " + v + ";"}).join("\n"))+"\n\
		  }\n\
		  return brightness < limit ? 0.0 : 1.0;\n\
		}\n",

	registerShaderNode( "math/dither", LGraphShaderDither );

	function LGraphShaderRemap()
	{
		this.addInput("", LGShaders.ALL_TYPES );
		this.addOutput("","");
		this.properties = {
			min_value: 0,
			max_value: 1,
			min_value2: 0,
			max_value2: 1
		};
		this.addWidget("number","min",0,{ step: 0.1, property: "min_value" });
		this.addWidget("number","max",1,{ step: 0.1, property: "max_value" });
		this.addWidget("number","min2",0,{ step: 0.1, property: "min_value2"});
		this.addWidget("number","max2",1,{ step: 0.1, property: "max_value2"});
	}

	LGraphShaderRemap.title = "Remap";

	LGraphShaderRemap.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			this.graph._version++;
	}

	LGraphShaderRemap.prototype.onConnectionsChange = function()
	{
		var return_type = this.getInputDataType(0);
		this.outputs[0].type = return_type || "T";
	}

	LGraphShaderRemap.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var outlink = getOutputLinkID(this,0);
		if(!inlink && !outlink) //not connected
			return;

		var return_type = this.getInputDataType(0);
		this.outputs[0].type = return_type;
		if(return_type == "T")
		{
			console.warn("node type is T and cannot be resolved");
			return;
		}

		if(!inlink)
		{
			context.addCode("code","	" + return_type + " " + outlink + " = " + return_type + "(0.0);\n");
			return;
		}

		var minv = valueToGLSL( this.properties.min_value );
		var maxv = valueToGLSL( this.properties.max_value );
		var minv2 = valueToGLSL( this.properties.min_value2 );
		var maxv2 = valueToGLSL( this.properties.max_value2 );

		context.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "math/remap", LGraphShaderRemap );

})(this);



(function(global) {
    var LiteGraph = global.LiteGraph;

	var view_matrix = new Float32Array(16);
	var projection_matrix = new Float32Array(16);
	var viewprojection_matrix = new Float32Array(16);
	var model_matrix = new Float32Array(16);
	var global_uniforms = {
		u_view: view_matrix,
		u_projection: projection_matrix,
		u_viewprojection: viewprojection_matrix,
		u_model: model_matrix 
	};

	LiteGraph.LGraphRender = {
		onRequestCameraMatrices: null //overwrite with your 3D engine specifics, it will receive (view_matrix, projection_matrix,viewprojection_matrix) and must be filled
	};

	function generateGeometryId() {
		return (Math.random() * 100000)|0;
	}

	function LGraphPoints3D() {

		this.addInput("obj", "");
		this.addInput("radius", "number");

		this.addOutput("out", "geometry");
		this.addOutput("points", "[vec3]");
		this.properties = {
			radius: 1,
			num_points: 4096,
			generate_normals: true,
			regular: false,
			mode: LGraphPoints3D.SPHERE,
			force_update: false
		};

		this.points = new Float32Array( this.properties.num_points * 3 );
		this.normals = new Float32Array( this.properties.num_points * 3 );
		this.must_update = true;
		this.version = 0;

		var that = this;
		this.addWidget("button","update",null, function(){ that.must_update = true; });

		this.geometry = {
			vertices: null,
			_id: generateGeometryId()
		}

		this._old_obj = null;
		this._last_radius = null;
	}

	global.LGraphPoints3D = LGraphPoints3D;

	LGraphPoints3D.RECTANGLE = 1;
	LGraphPoints3D.CIRCLE = 2;

	LGraphPoints3D.CUBE = 10;
	LGraphPoints3D.SPHERE = 11;
	LGraphPoints3D.HEMISPHERE = 12;
	LGraphPoints3D.INSIDE_SPHERE = 13;

	LGraphPoints3D.OBJECT = 20;
	LGraphPoints3D.OBJECT_UNIFORMLY = 21;
	LGraphPoints3D.OBJECT_INSIDE = 22;

	LGraphPoints3D.MODE_VALUES = { "rectangle":LGraphPoints3D.RECTANGLE, "circle":LGraphPoints3D.CIRCLE, "cube":LGraphPoints3D.CUBE, "sphere":LGraphPoints3D.SPHERE, "hemisphere":LGraphPoints3D.HEMISPHERE, "inside_sphere":LGraphPoints3D.INSIDE_SPHERE, "object":LGraphPoints3D.OBJECT, "object_uniformly":LGraphPoints3D.OBJECT_UNIFORMLY, "object_inside":LGraphPoints3D.OBJECT_INSIDE };

	LGraphPoints3D.widgets_info = {
		mode: { widget: "combo", values: LGraphPoints3D.MODE_VALUES }
	};

	LGraphPoints3D.title = "list of points";
	LGraphPoints3D.desc = "returns an array of points";

	LGraphPoints3D.prototype.onPropertyChanged = function(name,value)
	{
		this.must_update = true;
	}

	LGraphPoints3D.prototype.onExecute = function() {

		var obj = this.getInputData(0);
		if( obj != this._old_obj || (obj && obj._version != this._old_obj_version) )
		{
			this._old_obj = obj;
			this.must_update = true;
		}

		var radius = this.getInputData(1);
		if(radius == null)
			radius = this.properties.radius;
		if( this._last_radius != radius )
		{
			this._last_radius = radius;
			this.must_update = true;
		}

		if(this.must_update || this.properties.force_update )
		{
			this.must_update = false;
			this.updatePoints();
		}

		this.geometry.vertices = this.points;
		this.geometry.normals = this.normals;
		this.geometry._version = this.version;

		this.setOutputData( 0, this.geometry );
	}

	LGraphPoints3D.prototype.updatePoints = function() {
		var num_points = this.properties.num_points|0;
		if(num_points < 1)
			num_points = 1;

		if(!this.points || this.points.length != num_points * 3)
			this.points = new Float32Array( num_points * 3 );

		if(this.properties.generate_normals)
		{
			if (!this.normals || this.normals.length != this.points.length)
				this.normals = new Float32Array( this.points.length );
		}
		else
			this.normals = null;

		var radius = this._last_radius || this.properties.radius;
		var mode = this.properties.mode;

		var obj = this.getInputData(0);
		this._old_obj_version = obj ? obj._version : null;

		this.points = LGraphPoints3D.generatePoints( radius, num_points, mode, this.points, this.normals, this.properties.regular, obj );

		this.version++;
	}

	//global
	LGraphPoints3D.generatePoints = function( radius, num_points, mode, points, normals, regular, obj )
	{
		var size = num_points * 3;
		if(!points || points.length != size)
			points = new Float32Array( size );
		var temp = new Float32Array(3);
		var UP = new Float32Array([0,1,0]);

		if(regular)
		{
			if( mode == LGraphPoints3D.RECTANGLE)
			{
				var side = Math.floor(Math.sqrt(num_points));
				for(var i = 0; i < side; ++i)
				for(var j = 0; j < side; ++j)
				{
					var pos = i*3 + j*3*side;
					points[pos] = ((i/side) - 0.5) * radius * 2;
					points[pos+1] = 0;
					points[pos+2] = ((j/side) - 0.5) * radius * 2;
				}
				points = new Float32Array( points.subarray(0,side*side*3) );
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
			else if( mode == LGraphPoints3D.SPHERE)
			{
				var side = Math.floor(Math.sqrt(num_points));
				for(var i = 0; i < side; ++i)
				for(var j = 0; j < side; ++j)
				{
					var pos = i*3 + j*3*side;
					polarToCartesian( temp, (i/side) * 2 * Math.PI, ((j/side) - 0.5) * 2 * Math.PI, radius );
					points[pos] = temp[0];
					points[pos+1] = temp[1];
					points[pos+2] = temp[2];
				}
				points = new Float32Array( points.subarray(0,side*side*3) );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.CIRCLE)
			{
				for(var i = 0; i < size; i+=3)
				{
					var angle = 2 * Math.PI * (i/size);
					points[i] = Math.cos( angle ) * radius;
					points[i+1] = 0;
					points[i+2] = Math.sin( angle ) * radius;
				}
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
		}
		else //non regular
		{
			if( mode == LGraphPoints3D.RECTANGLE)
			{
				for(var i = 0; i < size; i+=3)
				{
					points[i] = (Math.random() - 0.5) * radius * 2;
					points[i+1] = 0;
					points[i+2] = (Math.random() - 0.5) * radius * 2;
				}
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
			else if( mode == LGraphPoints3D.CUBE)
			{
				for(var i = 0; i < size; i+=3)
				{
					points[i] = (Math.random() - 0.5) * radius * 2;
					points[i+1] = (Math.random() - 0.5) * radius * 2;
					points[i+2] = (Math.random() - 0.5) * radius * 2;
				}
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
			else if( mode == LGraphPoints3D.SPHERE)
			{
				LGraphPoints3D.generateSphere( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.HEMISPHERE)
			{
				LGraphPoints3D.generateHemisphere( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.CIRCLE)
			{
				LGraphPoints3D.generateInsideCircle( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.INSIDE_SPHERE)
			{
				LGraphPoints3D.generateInsideSphere( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.OBJECT)
			{
				LGraphPoints3D.generateFromObject( points, normals, size, obj, false );
			}
			else if( mode == LGraphPoints3D.OBJECT_UNIFORMLY)
			{
				LGraphPoints3D.generateFromObject( points, normals, size, obj, true );
			}
			else if( mode == LGraphPoints3D.OBJECT_INSIDE)
			{
				LGraphPoints3D.generateFromInsideObject( points, size, obj );
				//if(normals)
				//	LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else
				console.warn("wrong mode in LGraphPoints3D");
		}

		return points;
	}

	LGraphPoints3D.generateSphericalNormals = function(points, normals)
	{
		var temp = new Float32Array(3);
		for(var i = 0; i < normals.length; i+=3)
		{
			temp[0] = points[i];
			temp[1] = points[i+1];
			temp[2] = points[i+2];
			vec3.normalize(temp,temp);
			normals.set(temp,i);
		}
	}

	LGraphPoints3D.generateSphere = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var r1 = Math.random();
			var r2 = Math.random();
			var x = 2 * Math.cos( 2 * Math.PI * r1 ) * Math.sqrt( r2 * (1-r2) );
			var y = 1 - 2 * r2;
			var z = 2 * Math.sin( 2 * Math.PI * r1 ) * Math.sqrt( r2 * (1-r2) );
			points[i] = x * radius;
			points[i+1] = y * radius;
			points[i+2] = z * radius;
		}			
	}

	LGraphPoints3D.generateHemisphere = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var r1 = Math.random();
			var r2 = Math.random();
			var x = Math.cos( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			var y = r2;
			var z = Math.sin( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			points[i] = x * radius;
			points[i+1] = y * radius;
			points[i+2] = z * radius;
		}
	}

	LGraphPoints3D.generateInsideCircle = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var r1 = Math.random();
			var r2 = Math.random();
			var x = Math.cos( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			var y = r2;
			var z = Math.sin( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			points[i] = x * radius;
			points[i+1] = 0;
			points[i+2] = z * radius;
		}
	}

	LGraphPoints3D.generateInsideSphere = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var u = Math.random();
			var v = Math.random();
			var theta = u * 2.0 * Math.PI;
			var phi = Math.acos(2.0 * v - 1.0);
			var r = Math.cbrt(Math.random()) * radius;
			var sinTheta = Math.sin(theta);
			var cosTheta = Math.cos(theta);
			var sinPhi = Math.sin(phi);
			var cosPhi = Math.cos(phi);
			points[i] = r * sinPhi * cosTheta;
			points[i+1] = r * sinPhi * sinTheta;
			points[i+2] = r * cosPhi;
		}	
	}

	function findRandomTriangle( areas, f )
	{
		var l = areas.length;
		var imin = 0;
		var imid = 0;
		var imax = l;

		if(l == 0)
			return -1;
		if(l == 1)
			return 0;
		//dichotimic search
		while (imax >= imin)
		{
			imid = ((imax + imin)*0.5)|0;
			var t = areas[ imid ];
			if( t == f )
				return imid; 
			if( imin == (imax - 1) )
				return imin;
			if (t < f)
				imin = imid;
			else         
				imax = imid;
		}
		return imid;		
	}

	LGraphPoints3D.generateFromObject = function( points, normals, size, obj, evenly )
	{
		if(!obj)
			return;

		var vertices = null;
		var mesh_normals = null;
		var indices = null;
		var areas = null;
		if( obj.constructor === GL.Mesh )
		{
			vertices = obj.vertexBuffers.vertices.data;
			mesh_normals = obj.vertexBuffers.normals ? obj.vertexBuffers.normals.data : null;
			indices = obj.indexBuffers.indices ? obj.indexBuffers.indices.data : null;
			if(!indices)
				indices = obj.indexBuffers.triangles ? obj.indexBuffers.triangles.data : null;
		}
		if(!vertices)
			return null;
		var num_triangles = indices ? indices.length / 3 : vertices.length / (3*3);
		var total_area = 0; //sum of areas of all triangles

		if(evenly)
		{
			areas = new Float32Array(num_triangles); //accum
			for(var i = 0; i < num_triangles; ++i)
			{
				if(indices)
				{
					a = indices[i*3]*3;
					b = indices[i*3+1]*3;
					c = indices[i*3+2]*3;
				}
				else
				{
					a = i*9;
					b = i*9+3;
					c = i*9+6;
				}
				var P1 = vertices.subarray(a,a+3);
				var P2 = vertices.subarray(b,b+3);
				var P3 = vertices.subarray(c,c+3);
				var aL = vec3.distance( P1, P2 );
				var bL = vec3.distance( P2, P3 );
				var cL = vec3.distance( P3, P1 );
				var s = (aL + bL+ cL) / 2;
				total_area += Math.sqrt(s * (s - aL) * (s - bL) * (s - cL));
				areas[i] = total_area;
			}			
			for(var i = 0; i < num_triangles; ++i) //normalize
				areas[i] /= total_area;
		}

		for(var i = 0; i < size; i+=3)
		{
			var r = Math.random();
			var index = evenly ? findRandomTriangle( areas, r ) : Math.floor(r * num_triangles );
			//get random triangle
			var a = 0;
			var b = 0;
			var c = 0;
			if(indices)
			{
				a = indices[index*3]*3;
				b = indices[index*3+1]*3;
				c = indices[index*3+2]*3;
			}
			else
			{
				a = index*9;
				b = index*9+3;
				c = index*9+6;
			}
			var s = Math.random();
			var t = Math.random();
			var sqrt_s = Math.sqrt(s);
			var af = 1 - sqrt_s;
			var bf = sqrt_s * ( 1 - t);
			var cf = t * sqrt_s;
			points[i] = af * vertices[a] + bf*vertices[b] + cf*vertices[c];
			points[i+1] = af * vertices[a+1] + bf*vertices[b+1] + cf*vertices[c+1];
			points[i+2] = af * vertices[a+2] + bf*vertices[b+2] + cf*vertices[c+2];
			if(normals && mesh_normals)
			{
				normals[i] = af * mesh_normals[a] + bf*mesh_normals[b] + cf*mesh_normals[c];
				normals[i+1] = af * mesh_normals[a+1] + bf*mesh_normals[b+1] + cf*mesh_normals[c+1];
				normals[i+2] = af * mesh_normals[a+2] + bf*mesh_normals[b+2] + cf*mesh_normals[c+2];
				var N = normals.subarray(i,i+3);
				vec3.normalize(N,N);
			}
		}
	}

	LGraphPoints3D.generateFromInsideObject = function( points, size, mesh )
	{
		if(!mesh || mesh.constructor !== GL.Mesh)
			return;

		var aabb = mesh.getBoundingBox();
		if(!mesh.octree)
			mesh.octree = new GL.Octree( mesh );
		var octree = mesh.octree;
		var origin = vec3.create();
		var direction = vec3.fromValues(1,0,0);
		var temp = vec3.create();
		var i = 0;
		var tries = 0;
		while(i < size && tries < points.length * 10) //limit to avoid problems
		{
			tries += 1
			var r = vec3.random(temp); //random point inside the aabb
			r[0] = (r[0] * 2 - 1) * aabb[3] + aabb[0];
			r[1] = (r[1] * 2 - 1) * aabb[4] + aabb[1];
			r[2] = (r[2] * 2 - 1) * aabb[5] + aabb[2];
			origin.set(r);
			var hit = octree.testRay( origin, direction, 0, 10000, true, GL.Octree.ALL );
			if(!hit || hit.length % 2 == 0) //not inside
				continue;
			points.set( r, i );
			i+=3;
		}
	}

	LiteGraph.registerNodeType( "geometry/points3D", LGraphPoints3D );



	function LGraphPointsToInstances() {
		this.addInput("points", "geometry");
		this.addOutput("instances", "[mat4]");
		this.properties = {
			mode: 1,
			autoupdate: true
		};

		this.must_update = true;
		this.matrices = [];
		this.first_time = true;
	}

	LGraphPointsToInstances.NORMAL = 0;
	LGraphPointsToInstances.VERTICAL = 1;
	LGraphPointsToInstances.SPHERICAL = 2;
	LGraphPointsToInstances.RANDOM = 3;
	LGraphPointsToInstances.RANDOM_VERTICAL = 4;

	LGraphPointsToInstances.modes = {"normal":0,"vertical":1,"spherical":2,"random":3,"random_vertical":4};
	LGraphPointsToInstances.widgets_info = {
		mode: { widget: "combo", values: LGraphPointsToInstances.modes }
	};

	LGraphPointsToInstances.title = "points to inst";

	LGraphPointsToInstances.prototype.onExecute = function()
	{
		var geo = this.getInputData(0);
		if( !geo )
		{
			this.setOutputData(0,null);
			return;
		}

		if( !this.isOutputConnected(0) )
			return;

		var has_changed = (geo._version != this._version || geo._id != this._geometry_id);

		if( has_changed && this.properties.autoupdate || this.first_time )
		{
			this.first_time = false;
			this.updateInstances( geo );
		}

		this.setOutputData( 0, this.matrices );
	}

	LGraphPointsToInstances.prototype.updateInstances = function( geometry )
	{
		var vertices = geometry.vertices;
		if(!vertices)
			return null;
		var normals = geometry.normals;

		var matrices = this.matrices;
		var num_points = vertices.length / 3;
		if( matrices.length != num_points)
			matrices.length = num_points;
		var identity = mat4.create();
		var temp = vec3.create();
		var zero = vec3.create();
		var UP = vec3.fromValues(0,1,0);
		var FRONT = vec3.fromValues(0,0,-1);
		var RIGHT = vec3.fromValues(1,0,0);
		var R = quat.create();

		var front = vec3.create();
		var right = vec3.create();
		var top = vec3.create();

		for(var i = 0; i < vertices.length; i += 3)
		{
			var index = i/3;
			var m = matrices[index];
			if(!m)
				m = matrices[index] = mat4.create();
			m.set( identity );
			var point = vertices.subarray(i,i+3);

			switch(this.properties.mode)
			{
				case LGraphPointsToInstances.NORMAL: 
					mat4.setTranslation( m, point );
					if(normals)
					{
						var normal = normals.subarray(i,i+3);
						top.set( normal );
						vec3.normalize( top, top );
						vec3.cross( right, FRONT, top );
						vec3.normalize( right, right );
						vec3.cross( front, right, top );
						vec3.normalize( front, front );
						m.set(right,0);
						m.set(top,4);
						m.set(front,8);
						mat4.setTranslation( m, point );
					}
					break;
				case LGraphPointsToInstances.VERTICAL: 
					mat4.setTranslation( m, point );
					break;
				case LGraphPointsToInstances.SPHERICAL: 
					front.set( point );
					vec3.normalize( front, front );
					vec3.cross( right, UP, front );
					vec3.normalize( right, right );
					vec3.cross( top, front, right );
					vec3.normalize( top, top );
					m.set(right,0);
					m.set(top,4);
					m.set(front,8);
					mat4.setTranslation( m, point );
					break;
				case LGraphPointsToInstances.RANDOM:
					temp[0] = Math.random()*2 - 1;
					temp[1] = Math.random()*2 - 1;
					temp[2] = Math.random()*2 - 1;
					vec3.normalize( temp, temp );
					quat.setAxisAngle( R, temp, Math.random() * 2 * Math.PI );
					mat4.fromQuat(m, R);
					mat4.setTranslation( m, point );
					break;
				case LGraphPointsToInstances.RANDOM_VERTICAL:
					quat.setAxisAngle( R, UP, Math.random() * 2 * Math.PI );
					mat4.fromQuat(m, R);
					mat4.setTranslation( m, point );
					break;
			}
		}

		this._version = geometry._version;
		this._geometry_id = geometry._id;
	}

	LiteGraph.registerNodeType( "geometry/points_to_instances", LGraphPointsToInstances );


	function LGraphGeometryTransform() {
		this.addInput("in", "geometry,[mat4]");
		this.addInput("mat4", "mat4");
		this.addOutput("out", "geometry");
		this.properties = {};

		this.geometry = {
			type: "triangles",
			vertices: null,
			_id: generateGeometryId(),
			_version: 0
		};

		this._last_geometry_id = -1;
		this._last_version = -1;
		this._last_key = "";

		this.must_update = true;
	}

	LGraphGeometryTransform.title = "Transform";

	LGraphGeometryTransform.prototype.onExecute = function() {

		var input = this.getInputData(0);
		var model = this.getInputData(1);

		if(!input)
			return;

		//array of matrices
		if(input.constructor === Array)
		{
			if(input.length == 0)
				return;
			this.outputs[0].type = "[mat4]";
			if( !this.isOutputConnected(0) )
				return;

			if(!model)
			{
				this.setOutputData(0,input);
				return;
			}

			if(!this._output)
				this._output = new Array();
			if(this._output.length != input.length)
				this._output.length = input.length;
			for(var i = 0; i < input.length; ++i)
			{
				var m = this._output[i];
				if(!m)
					m = this._output[i] = mat4.create();
				mat4.multiply(m,input[i],model);
			}
			this.setOutputData(0,this._output);
			return;
		}

		//geometry
		if(!input.vertices || !input.vertices.length)
			return;
		var geo = input;
		this.outputs[0].type = "geometry";
		if( !this.isOutputConnected(0) )
			return;
		if(!model)
		{
			this.setOutputData(0,geo);
			return;
		}

		var key = typedArrayToArray(model).join(",");

		if( this.must_update || geo._id != this._last_geometry_id || geo._version != this._last_version || key != this._last_key )
		{
			this.updateGeometry(geo, model);
			this._last_key = key;
			this._last_version = geo._version;
			this._last_geometry_id = geo._id;
			this.must_update = false;
		}

		this.setOutputData(0,this.geometry);
	}

	LGraphGeometryTransform.prototype.updateGeometry = function(geometry, model) {
		var old_vertices = geometry.vertices;
		var vertices = this.geometry.vertices;
		if( !vertices || vertices.length != old_vertices.length )
			vertices = this.geometry.vertices = new Float32Array( old_vertices.length );
		var temp = vec3.create();

		for(var i = 0, l = vertices.length; i < l; i+=3)
		{
			temp[0] = old_vertices[i]; temp[1] = old_vertices[i+1]; temp[2] = old_vertices[i+2]; 
			mat4.multiplyVec3( temp, model, temp );
			vertices[i] = temp[0]; vertices[i+1] = temp[1]; vertices[i+2] = temp[2];
		}

		if(geometry.normals)
		{
			if( !this.geometry.normals || this.geometry.normals.length != geometry.normals.length )
				this.geometry.normals = new Float32Array( geometry.normals.length );
			var normals = this.geometry.normals;
			var normal_model = mat4.invert(mat4.create(), model);
			if(normal_model)
				mat4.transpose(normal_model, normal_model);
			var old_normals = geometry.normals;
			for(var i = 0, l = normals.length; i < l; i+=3)
			{
				temp[0] = old_normals[i]; temp[1] = old_normals[i+1]; temp[2] = old_normals[i+2]; 
				mat4.multiplyVec3( temp, normal_model, temp );
				normals[i] = temp[0]; normals[i+1] = temp[1]; normals[i+2] = temp[2];
			}
		}

		this.geometry.type = geometry.type;
		this.geometry._version++;
	}

	LiteGraph.registerNodeType( "geometry/transform", LGraphGeometryTransform );


	function LGraphGeometryPolygon() {
		this.addInput("sides", "number");
		this.addInput("radius", "number");
		this.addOutput("out", "geometry");
		this.properties = { sides: 6, radius: 1, uvs: false }

		this.geometry = {
			type: "line_loop",
			vertices: null,
			_id: generateGeometryId()
		};
		this.geometry_id = -1;
		this.version = -1;
		this.must_update = true;

		this.last_info = { sides: -1, radius: -1 };
	}

	LGraphGeometryPolygon.title = "Polygon";

	LGraphGeometryPolygon.prototype.onExecute = function() {

		if( !this.isOutputConnected(0) )
			return;

		var sides = this.getInputOrProperty("sides");
		var radius = this.getInputOrProperty("radius");
		sides = Math.max(3,sides)|0;

		//update
		if( this.last_info.sides != sides || this.last_info.radius != radius )
			this.updateGeometry(sides, radius);

		this.setOutputData(0,this.geometry);
	}

	LGraphGeometryPolygon.prototype.updateGeometry = function(sides, radius) {
		var num = 3*sides;
		var vertices = this.geometry.vertices;
		if( !vertices || vertices.length != num )
			vertices = this.geometry.vertices = new Float32Array( 3*sides );
		var delta = (Math.PI * 2) / sides;
		var gen_uvs = this.properties.uvs;
		if(gen_uvs)
		{
			uvs = this.geometry.coords = new Float32Array( 3*sides );
		}


		for(var i = 0; i < sides; ++i)
		{
			var angle = delta * -i;
			var x = Math.cos( angle ) * radius;
			var y = 0;
			var z = Math.sin( angle ) * radius;
			vertices[i*3] = x;
			vertices[i*3+1] = y;
			vertices[i*3+2] = z;

			if(gen_uvs)
			{
				

			}
		}
		this.geometry._id = ++this.geometry_id;
		this.geometry._version = ++this.version;
		this.last_info.sides = sides;
		this.last_info.radius = radius;
	}

	LiteGraph.registerNodeType( "geometry/polygon", LGraphGeometryPolygon );


	function LGraphGeometryExtrude() {

		this.addInput("", "geometry");
		this.addOutput("", "geometry");
		this.properties = { top_cap: true, bottom_cap: true, offset: [0,100,0] };
		this.version = -1;

		this._last_geo_version = -1;
		this._must_update = true;
	}

	LGraphGeometryExtrude.title = "extrude";

	LGraphGeometryExtrude.prototype.onPropertyChanged = function(name, value)
	{
		this._must_update = true;
	}

	LGraphGeometryExtrude.prototype.onExecute = function()
	{
		var geo = this.getInputData(0);
		if( !geo || !this.isOutputConnected(0) )
			return;

		if(geo.version != this._last_geo_version || this._must_update)
		{
			this._geo = this.extrudeGeometry( geo, this._geo );
			if(this._geo)
				this._geo.version = this.version++;
			this._must_update = false;
		}

		this.setOutputData(0, this._geo);
	}

	LGraphGeometryExtrude.prototype.extrudeGeometry = function( geo )
	{
		//for every pair of vertices
		var vertices = geo.vertices;
		var num_points = vertices.length / 3;

		var tempA = vec3.create();
		var tempB = vec3.create();
		var tempC = vec3.create();
		var tempD = vec3.create();
		var offset = new Float32Array( this.properties.offset );

		if(geo.type == "line_loop")
		{
			var new_vertices = new Float32Array( num_points * 6 * 3 ); //every points become 6 ( caps not included )
			var npos = 0;
			for(var i = 0, l = vertices.length; i < l; i += 3)
			{
				tempA[0] = vertices[i]; tempA[1] = vertices[i+1]; tempA[2] = vertices[i+2];

				if( i+3 < l ) //loop
				{
					tempB[0] = vertices[i+3]; tempB[1] = vertices[i+4]; tempB[2] = vertices[i+5];
				}
				else
				{
					tempB[0] = vertices[0]; tempB[1] = vertices[1]; tempB[2] = vertices[2];
				}

				vec3.add( tempC, tempA, offset );
				vec3.add( tempD, tempB, offset );

				new_vertices.set( tempA, npos ); npos += 3;
				new_vertices.set( tempB, npos ); npos += 3;
				new_vertices.set( tempC, npos ); npos += 3;

				new_vertices.set( tempB, npos ); npos += 3;
				new_vertices.set( tempD, npos ); npos += 3;
				new_vertices.set( tempC, npos ); npos += 3;
			}
		}

		var out_geo = {
			_id: generateGeometryId(),
			type: "triangles",
			vertices: new_vertices
		};

		return out_geo;
	}

	LiteGraph.registerNodeType( "geometry/extrude", LGraphGeometryExtrude );


	function LGraphGeometryEval() {
		this.addInput("in", "geometry");
		this.addOutput("out", "geometry");

		this.properties = {
			code: "V[1] += 0.01 * Math.sin(I + T*0.001);",
			execute_every_frame: false
		};

		this.geometry = null;
		this.geometry_id = -1;
		this.version = -1;
		this.must_update = true;

		this.vertices = null;
		this.func = null;
	}

	LGraphGeometryEval.title = "geoeval";
	LGraphGeometryEval.desc = "eval code";

	LGraphGeometryEval.widgets_info = {
		code: { widget: "code" }
	};

	LGraphGeometryEval.prototype.onConfigure = function(o)
	{
		this.compileCode();
	}

	LGraphGeometryEval.prototype.compileCode = function()
	{
		if(!this.properties.code)
			return;

		try
		{
			this.func = new Function("V","I","T", this.properties.code); 
			this.boxcolor = "#AFA";
			this.must_update = true;
		}
		catch (err)
		{
			this.boxcolor = "red";
		}
	}

	LGraphGeometryEval.prototype.onPropertyChanged = function(name, value)
	{
		if(name == "code")
		{
			this.properties.code = value;
			this.compileCode();
		}
	}

	LGraphGeometryEval.prototype.onExecute = function() {
		var geometry = this.getInputData(0);
		if(!geometry)
			return;

		if(!this.func)
		{
			this.setOutputData(0,geometry);
			return;
		}

		if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update || this.properties.execute_every_frame )
		{
			this.must_update = false;
			this.geometry_id = geometry._id;
			if(this.properties.execute_every_frame)
				this.version++;
			else
				this.version = geometry._version;
			var func = this.func;
			var T = getTime();

			//clone
			if(!this.geometry)
				this.geometry = {};
			for(var i in geometry)
			{
				if(geometry[i] == null)
					continue;
				if( geometry[i].constructor == Float32Array )
					this.geometry[i] = new Float32Array( geometry[i] );
				else
					this.geometry[i] = geometry[i];
			}
			this.geometry._id = geometry._id;
			if(this.properties.execute_every_frame)
				this.geometry._version = this.version;
			else
				this.geometry._version = geometry._version + 1;

			var V = vec3.create();
			var vertices = this.vertices;
			if(!vertices || this.vertices.length != geometry.vertices.length)
				vertices = this.vertices = new Float32Array( geometry.vertices );
			else
				vertices.set( geometry.vertices );
			for(var i = 0; i < vertices.length; i+=3)
			{
				V[0] = vertices[i];
				V[1] = vertices[i+1];
				V[2] = vertices[i+2];
				func(V,i/3,T);
				vertices[i] = V[0];
				vertices[i+1] = V[1];
				vertices[i+2] = V[2];
			}
			this.geometry.vertices = vertices;
		}

		this.setOutputData(0,this.geometry);
	}

	LiteGraph.registerNodeType( "geometry/eval", LGraphGeometryEval );

/*
function LGraphGeometryDisplace() {
		this.addInput("in", "geometry");
		this.addInput("img", "image");
		this.addOutput("out", "geometry");

		this.properties = {
			grid_size: 1
		};

		this.geometry = null;
		this.geometry_id = -1;
		this.version = -1;
		this.must_update = true;

		this.vertices = null;
	}

	LGraphGeometryDisplace.title = "displace";
	LGraphGeometryDisplace.desc = "displace points";

	LGraphGeometryDisplace.prototype.onExecute = function() {
		var geometry = this.getInputData(0);
		var image = this.getInputData(1);
		if(!geometry)
			return;

		if(!image)
		{
			this.setOutputData(0,geometry);
			return;
		}

		if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )
		{
			this.must_update = false;
			this.geometry_id = geometry._id;
			this.version = geometry._version;

			//copy
			this.geometry = {};
			for(var i in geometry)
				this.geometry[i] = geometry[i];
			this.geometry._id = geometry._id;
			this.geometry._version = geometry._version + 1;

			var grid_size = this.properties.grid_size;
			if(grid_size != 0)
			{
				var vertices = this.vertices;
				if(!vertices || this.vertices.length != this.geometry.vertices.length)
					vertices = this.vertices = new Float32Array( this.geometry.vertices );
				for(var i = 0; i < vertices.length; i+=3)
				{
					vertices[i] = Math.round(vertices[i]/grid_size) * grid_size;
					vertices[i+1] = Math.round(vertices[i+1]/grid_size) * grid_size;
					vertices[i+2] = Math.round(vertices[i+2]/grid_size) * grid_size;
				}
				this.geometry.vertices = vertices;
			}
		}

		this.setOutputData(0,this.geometry);
	}

	LiteGraph.registerNodeType( "geometry/displace", LGraphGeometryDisplace );
*/

	function LGraphConnectPoints() {
		this.addInput("in", "geometry");
		this.addOutput("out", "geometry");

		this.properties = {
			min_dist: 0.4,
			max_dist: 0.5,
			max_connections: 0,
			probability: 1
		};

		this.geometry_id = -1;
		this.version = -1;
		this.my_version = 1;
		this.must_update = true;
	}

	LGraphConnectPoints.title = "connect points";
	LGraphConnectPoints.desc = "adds indices between near points";

	LGraphConnectPoints.prototype.onPropertyChanged = function(name,value)
	{
		this.must_update = true;
	}

	LGraphConnectPoints.prototype.onExecute = function() {
		var geometry = this.getInputData(0);
		if(!geometry)
			return;

		if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )
		{
			this.must_update = false;
			this.geometry_id = geometry._id;
			this.version = geometry._version;

			//copy
			this.geometry = {};
			for(var i in geometry)
				this.geometry[i] = geometry[i];
			this.geometry._id = generateGeometryId();
			this.geometry._version = this.my_version++;

			var vertices = geometry.vertices;
			var l = vertices.length;
			var min_dist = this.properties.min_dist;
			var max_dist = this.properties.max_dist;
			var probability = this.properties.probability;
			var max_connections = this.properties.max_connections;
			var indices = [];
			
			for(var i = 0; i < l; i+=3)
			{
				var x = vertices[i];
				var y = vertices[i+1];
				var z = vertices[i+2];
				var connections = 0;
				for(var j = i+3; j < l; j+=3)
				{
					var x2 = vertices[j];
					var y2 = vertices[j+1];
					var z2 = vertices[j+2];
					var dist = Math.sqrt( (x-x2)*(x-x2) + (y-y2)*(y-y2) + (z-z2)*(z-z2));
					if(dist > max_dist || dist < min_dist || (probability < 1 && probability < Math.random()) )
						continue;
					indices.push(i/3,j/3);
					connections += 1;
					if(max_connections && connections > max_connections)
						break;
				}
			}
			this.geometry.indices = this.indices = new Uint32Array(indices);
		}

		if(this.indices && this.indices.length)
		{
			this.geometry.indices = this.indices;
			this.setOutputData( 0, this.geometry );
		}
		else
			this.setOutputData( 0, null );
	}

	LiteGraph.registerNodeType( "geometry/connectPoints", LGraphConnectPoints );

    //Works with Litegl.js to create WebGL nodes
    if (typeof GL == "undefined") //LiteGL RELATED **********************************************
		return;

	function LGraphToGeometry() {
		this.addInput("mesh", "mesh");
		this.addOutput("out", "geometry");

		this.geometry = {};
		this.last_mesh = null;
	}

	LGraphToGeometry.title = "to geometry";
	LGraphToGeometry.desc = "converts a mesh to geometry";

	LGraphToGeometry.prototype.onExecute = function() {
		var mesh = this.getInputData(0);
		if(!mesh)
			return;

		if(mesh != this.last_mesh)
		{
			this.last_mesh = mesh;
			for(i in mesh.vertexBuffers)
			{
				var buffer = mesh.vertexBuffers[i];
				this.geometry[i] = buffer.data
			}
			if(mesh.indexBuffers["triangles"])
				this.geometry.indices = mesh.indexBuffers["triangles"].data;

			this.geometry._id = generateGeometryId();
			this.geometry._version = 0;
		}

		this.setOutputData(0,this.geometry);
		if(this.geometry)
			this.setOutputData(1,this.geometry.vertices);
	}

	LiteGraph.registerNodeType( "geometry/toGeometry", LGraphToGeometry );

	function LGraphGeometryToMesh() {
		this.addInput("in", "geometry");
		this.addOutput("mesh", "mesh");
		this.properties = {};
		this.version = -1;
		this.mesh = null;
	}

	LGraphGeometryToMesh.title = "Geo to Mesh";

	LGraphGeometryToMesh.prototype.updateMesh = function(geometry)
	{
		if(!this.mesh)
			this.mesh = new GL.Mesh();

		for(var i in geometry)
		{
			if(i[0] == "_")
				continue;

			var buffer_data = geometry[i];

			var info = GL.Mesh.common_buffers[i];
			if(!info && i != "indices") //unknown buffer
				continue;
			var spacing = info ? info.spacing : 3;
			var mesh_buffer = this.mesh.vertexBuffers[i];

			if(!mesh_buffer || mesh_buffer.data.length != buffer_data.length)
			{
				mesh_buffer = new GL.Buffer( i == "indices" ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER, buffer_data, spacing, GL.DYNAMIC_DRAW );
			}
			else
			{
				mesh_buffer.data.set( buffer_data );
				mesh_buffer.upload(GL.DYNAMIC_DRAW);
			}

			this.mesh.addBuffer( i, mesh_buffer );
		}

		if(this.mesh.vertexBuffers.normals &&this.mesh.vertexBuffers.normals.data.length != this.mesh.vertexBuffers.vertices.data.length )
		{
			var n = new Float32Array([0,1,0]);
			var normals = new Float32Array( this.mesh.vertexBuffers.vertices.data.length );
			for(var i = 0; i < normals.length; i+= 3)
				normals.set( n, i );
			mesh_buffer = new GL.Buffer( GL.ARRAY_BUFFER, normals, 3 );
			this.mesh.addBuffer( "normals", mesh_buffer );
		}

		this.mesh.updateBoundingBox();
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
		return this.mesh;
	}

	LGraphGeometryToMesh.prototype.onExecute = function() {

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if( this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );
		this.setOutputData(0, this.mesh);
	}

	LiteGraph.registerNodeType( "geometry/toMesh", LGraphGeometryToMesh );

	function LGraphRenderMesh() {
		this.addInput("mesh", "mesh");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");

		this.properties = {
			enabled: true,
			primitive: GL.TRIANGLES,
			additive: false,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);
		this.model_matrix = mat4.create();
		this.uniforms = {
			u_color: this.color,
			u_model: this.model_matrix
		};
	}

	LGraphRenderMesh.title = "Render Mesh";
	LGraphRenderMesh.desc = "renders a mesh flat";

	LGraphRenderMesh.PRIMITIVE_VALUES = { "points":GL.POINTS, "lines":GL.LINES, "line_loop":GL.LINE_LOOP,"line_strip":GL.LINE_STRIP, "triangles":GL.TRIANGLES, "triangle_fan":GL.TRIANGLE_FAN, "triangle_strip":GL.TRIANGLE_STRIP };

	LGraphRenderMesh.widgets_info = {
		primitive: { widget: "combo", values: LGraphRenderMesh.PRIMITIVE_VALUES },
		color: { widget: "color" }
	};

	LGraphRenderMesh.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var mesh = this.getInputData(0);
		if(!mesh)
			return;

		if(!LiteGraph.LGraphRender.onRequestCameraMatrices)
		{
			console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;
		var texture = this.getInputData(2);
		if(texture)
		{
			shader = gl.shaders["textured"];
			if(!shader)
				shader = gl.shaders["textured"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_TEXTURE:"" });
		}
		else
		{
			shader = gl.shaders["flat"];
			if(!shader)
				shader = gl.shaders["flat"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code );
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var model_matrix = this.model_matrix;
		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = 1;
		var primitive = this.properties.primitive;

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );
		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		var indices = "indices";
		if( mesh.indexBuffers.triangles )
			indices = "triangles";
		shader.draw( mesh, primitive, indices );
		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_mesh", LGraphRenderMesh );

	//**************************


	function LGraphGeometryPrimitive() {
		this.addInput("size", "number");
		this.addOutput("out", "mesh");
		this.properties = { type: 1, size: 1, subdivisions: 32 };

		this.version = (Math.random() * 100000)|0;
		this.last_info = { type: -1, size: -1, subdivisions: -1 };
	}

	LGraphGeometryPrimitive.title = "Primitive";

	LGraphGeometryPrimitive.VALID = { "CUBE":1, "PLANE":2, "CYLINDER":3, "SPHERE":4, "CIRCLE":5, "HEMISPHERE":6, "ICOSAHEDRON":7, "CONE":8, "QUAD":9 };
	LGraphGeometryPrimitive.widgets_info = {
		type: { widget: "combo", values: LGraphGeometryPrimitive.VALID }
	};

	LGraphGeometryPrimitive.prototype.onExecute = function() {

		if( !this.isOutputConnected(0) )
			return;

		var size = this.getInputOrProperty("size");

		//update
		if( this.last_info.type != this.properties.type || this.last_info.size != size || this.last_info.subdivisions != this.properties.subdivisions )
			this.updateMesh( this.properties.type, size, this.properties.subdivisions );

		this.setOutputData(0,this._mesh);
	}

	LGraphGeometryPrimitive.prototype.updateMesh = function(type, size, subdivisions)
	{
		subdivisions = Math.max(0,subdivisions)|0;

		switch (type)
		{
			case 1: //CUBE: 
				this._mesh = GL.Mesh.cube({size: size, normals:true,coords:true});
				break;
			case 2: //PLANE:
				this._mesh = GL.Mesh.plane({size: size, xz: true, detail: subdivisions, normals:true,coords:true});
				break;
			case 3: //CYLINDER:
				this._mesh = GL.Mesh.cylinder({size: size, subdivisions: subdivisions, normals:true,coords:true});
				break;
			case 4: //SPHERE:
				this._mesh = GL.Mesh.sphere({size: size, "long": subdivisions, lat: subdivisions, normals:true,coords:true});
				break;
			case 5: //CIRCLE:
				this._mesh = GL.Mesh.circle({size: size, slices: subdivisions, normals:true, coords:true});
				break;
			case 6: //HEMISPHERE:
				this._mesh = GL.Mesh.sphere({size: size, "long": subdivisions, lat: subdivisions, normals:true, coords:true, hemi: true});
				break;
			case 7: //ICOSAHEDRON:
				this._mesh = GL.Mesh.icosahedron({size: size, subdivisions:subdivisions });
				break;
			case 8: //CONE:
				this._mesh = GL.Mesh.cone({radius: size, height: size, subdivisions:subdivisions });
				break;
			case 9: //QUAD:
				this._mesh = GL.Mesh.plane({size: size, xz: false, detail: subdivisions, normals:true, coords:true });
				break;
		}

		this.last_info.type = type;
		this.last_info.size = size;
		this.last_info.subdivisions = subdivisions;
		this._mesh.version = this.version++;
	}

	LiteGraph.registerNodeType( "geometry/mesh_primitive", LGraphGeometryPrimitive );


	function LGraphRenderPoints() {
		this.addInput("in", "geometry");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");
		this.properties = {
			enabled: true,
			point_size: 0.1,
			fixed_size: false,
			additive: true,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);

		this.uniforms = {
			u_point_size: 1,
			u_perspective: 1,
			u_point_perspective: 1,
			u_color: this.color
		};

		this.geometry_id = -1;
		this.version = -1;
		this.mesh = null;
	}

	LGraphRenderPoints.title = "renderPoints";
	LGraphRenderPoints.desc = "render points with a texture";

	LGraphRenderPoints.widgets_info = {
		color: { widget: "color" }
	};

	LGraphRenderPoints.prototype.updateMesh = function(geometry)
	{
		var buffer = this.buffer;
		if(!this.buffer || !this.buffer.data || this.buffer.data.length != geometry.vertices.length)
			this.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);
		else
		{
			this.buffer.data.set( geometry.vertices );
			this.buffer.upload(GL.DYNAMIC_DRAW);
		}

		if(!this.mesh)
			this.mesh = new GL.Mesh();

		this.mesh.addBuffer("vertices",this.buffer);
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
	}

	LGraphRenderPoints.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if(this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );

		if(!LiteGraph.LGraphRender.onRequestCameraMatrices)
		{
			console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;

		var texture = this.getInputData(2);
		
		if(texture)
		{
			shader = gl.shaders["textured_points"];
			if(!shader)
				shader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_TEXTURED_POINTS:"" });
		}
		else
		{
			shader = gl.shaders["points"];
			if(!shader)
				shader = gl.shaders["points"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_POINTS: "" });
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = this.properties.point_size;
		this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
		this.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );

		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		shader.draw( this.mesh, GL.POINTS );

		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_points", LGraphRenderPoints );

	LGraphRenderPoints.vertex_shader_code = '\
		precision mediump float;\n\
		attribute vec3 a_vertex;\n\
		varying vec3 v_vertex;\n\
		attribute vec3 a_normal;\n\
		varying vec3 v_normal;\n\
		#ifdef USE_COLOR\n\
			attribute vec4 a_color;\n\
			varying vec4 v_color;\n\
		#endif\n\
		attribute vec2 a_coord;\n\
		varying vec2 v_coord;\n\
		#ifdef USE_SIZE\n\
			attribute float a_extra;\n\
		#endif\n\
		#ifdef USE_INSTANCING\n\
			attribute mat4 u_model;\n\
		#else\n\
			uniform mat4 u_model;\n\
		#endif\n\
		uniform mat4 u_viewprojection;\n\
		uniform float u_point_size;\n\
		uniform float u_perspective;\n\
		uniform float u_point_perspective;\n\
		float computePointSize(float radius, float w)\n\
		{\n\
			if(radius < 0.0)\n\
				return -radius;\n\
			return u_perspective * radius / w;\n\
		}\n\
		void main() {\n\
			v_coord = a_coord;\n\
			#ifdef USE_COLOR\n\
				v_color = a_color;\n\
			#endif\n\
			v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\n\
			v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\n\
			gl_Position = u_viewprojection * vec4(v_vertex,1.0);\n\
			gl_PointSize = u_point_size;\n\
			#ifdef USE_SIZE\n\
				gl_PointSize = a_extra;\n\
			#endif\n\
			if(u_point_perspective != 0.0)\n\
				gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\n\
		}\
	';

	LGraphRenderPoints.fragment_shader_code = '\
		precision mediump float;\n\
		uniform vec4 u_color;\n\
		#ifdef USE_COLOR\n\
			varying vec4 v_color;\n\
		#endif\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		void main() {\n\
			vec4 color = u_color;\n\
			#ifdef USE_TEXTURED_POINTS\n\
				color *= texture2D(u_texture, gl_PointCoord.xy);\n\
			#else\n\
				#ifdef USE_TEXTURE\n\
				  color *= texture2D(u_texture, v_coord);\n\
				  if(color.a < 0.1)\n\
					discard;\n\
				#endif\n\
				#ifdef USE_POINTS\n\
					float dist = length( gl_PointCoord.xy - vec2(0.5) );\n\
					if( dist > 0.45 )\n\
						discard;\n\
				#endif\n\
			#endif\n\
			#ifdef USE_COLOR\n\
				color *= v_color;\n\
			#endif\n\
			gl_FragColor = color;\n\
		}\
	';

	//based on https://inconvergent.net/2019/depth-of-field/
	/*
	function LGraphRenderGeometryDOF() {
		this.addInput("in", "geometry");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");
		this.properties = {
			enabled: true,
			lines: true,
			point_size: 0.1,
			fixed_size: false,
			additive: true,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);

		this.uniforms = {
			u_point_size: 1,
			u_perspective: 1,
			u_point_perspective: 1,
			u_color: this.color
		};

		this.geometry_id = -1;
		this.version = -1;
		this.mesh = null;
	}

	LGraphRenderGeometryDOF.widgets_info = {
		color: { widget: "color" }
	};

	LGraphRenderGeometryDOF.prototype.updateMesh = function(geometry)
	{
		var buffer = this.buffer;
		if(!this.buffer || this.buffer.data.length != geometry.vertices.length)
			this.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);
		else
		{
			this.buffer.data.set( geometry.vertices );
			this.buffer.upload(GL.DYNAMIC_DRAW);
		}

		if(!this.mesh)
			this.mesh = new GL.Mesh();

		this.mesh.addBuffer("vertices",this.buffer);
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
	}

	LGraphRenderGeometryDOF.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if(this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );

		if(!LiteGraph.LGraphRender.onRequestCameraMatrices)
		{
			console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;

		var texture = this.getInputData(2);
		
		if(texture)
		{
			shader = gl.shaders["textured_points"];
			if(!shader)
				shader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_TEXTURED_POINTS:"" });
		}
		else
		{
			shader = gl.shaders["points"];
			if(!shader)
				shader = gl.shaders["points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_POINTS: "" });
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = this.properties.point_size;
		this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
		this.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );

		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		shader.draw( this.mesh, GL.POINTS );

		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_dof", LGraphRenderGeometryDOF );

	LGraphRenderGeometryDOF.vertex_shader_code = '\
		precision mediump float;\n\
		attribute vec3 a_vertex;\n\
		varying vec3 v_vertex;\n\
		attribute vec3 a_normal;\n\
		varying vec3 v_normal;\n\
		#ifdef USE_COLOR\n\
			attribute vec4 a_color;\n\
			varying vec4 v_color;\n\
		#endif\n\
		attribute vec2 a_coord;\n\
		varying vec2 v_coord;\n\
		#ifdef USE_SIZE\n\
			attribute float a_extra;\n\
		#endif\n\
		#ifdef USE_INSTANCING\n\
			attribute mat4 u_model;\n\
		#else\n\
			uniform mat4 u_model;\n\
		#endif\n\
		uniform mat4 u_viewprojection;\n\
		uniform float u_point_size;\n\
		uniform float u_perspective;\n\
		uniform float u_point_perspective;\n\
		float computePointSize(float radius, float w)\n\
		{\n\
			if(radius < 0.0)\n\
				return -radius;\n\
			return u_perspective * radius / w;\n\
		}\n\
		void main() {\n\
			v_coord = a_coord;\n\
			#ifdef USE_COLOR\n\
				v_color = a_color;\n\
			#endif\n\
			v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\n\
			v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\n\
			gl_Position = u_viewprojection * vec4(v_vertex,1.0);\n\
			gl_PointSize = u_point_size;\n\
			#ifdef USE_SIZE\n\
				gl_PointSize = a_extra;\n\
			#endif\n\
			if(u_point_perspective != 0.0)\n\
				gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\n\
		}\
	';

	LGraphRenderGeometryDOF.fragment_shader_code = '\
		precision mediump float;\n\
		uniform vec4 u_color;\n\
		#ifdef USE_COLOR\n\
			varying vec4 v_color;\n\
		#endif\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		void main() {\n\
			vec4 color = u_color;\n\
			#ifdef USE_TEXTURED_POINTS\n\
				color *= texture2D(u_texture, gl_PointCoord.xy);\n\
			#else\n\
				#ifdef USE_TEXTURE\n\
				  color *= texture2D(u_texture, v_coord);\n\
				  if(color.a < 0.1)\n\
					discard;\n\
				#endif\n\
				#ifdef USE_POINTS\n\
					float dist = length( gl_PointCoord.xy - vec2(0.5) );\n\
					if( dist > 0.45 )\n\
						discard;\n\
				#endif\n\
			#endif\n\
			#ifdef USE_COLOR\n\
				color *= v_color;\n\
			#endif\n\
			gl_FragColor = color;\n\
		}\
	';
	*/



})(this);
(function(global) {
    var LiteGraph = global.LiteGraph;
    var LGraphTexture = global.LGraphTexture;

    //Works with Litegl.js to create WebGL nodes
    if (typeof GL != "undefined") {
        // Texture Lens *****************************************
        function LGraphFXLens() {
            this.addInput("Texture", "Texture");
            this.addInput("Aberration", "number");
            this.addInput("Distortion", "number");
            this.addInput("Blur", "number");
            this.addOutput("Texture", "Texture");
            this.properties = {
                aberration: 1.0,
                distortion: 1.0,
                blur: 1.0,
                precision: LGraphTexture.DEFAULT
            };

            if (!LGraphFXLens._shader) {
                LGraphFXLens._shader = new GL.Shader(
                    GL.Shader.SCREEN_VERTEX_SHADER,
                    LGraphFXLens.pixel_shader
                );
                LGraphFXLens._texture = new GL.Texture(3, 1, {
                    format: gl.RGB,
                    wrap: gl.CLAMP_TO_EDGE,
                    magFilter: gl.LINEAR,
                    minFilter: gl.LINEAR,
                    pixel_data: [255, 0, 0, 0, 255, 0, 0, 0, 255]
                });
            }
        }

        LGraphFXLens.title = "Lens";
        LGraphFXLens.desc = "Camera Lens distortion";
        LGraphFXLens.widgets_info = {
            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
        };

        LGraphFXLens.prototype.onExecute = function() {
            var tex = this.getInputData(0);
            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
                this.setOutputData(0, tex);
                return;
            }

            if (!tex) {
                return;
            }

            this._tex = LGraphTexture.getTargetTexture(
                tex,
                this._tex,
                this.properties.precision
            );

            var aberration = this.properties.aberration;
            if (this.isInputConnected(1)) {
                aberration = this.getInputData(1);
                this.properties.aberration = aberration;
            }

            var distortion = this.properties.distortion;
            if (this.isInputConnected(2)) {
                distortion = this.getInputData(2);
                this.properties.distortion = distortion;
            }

            var blur = this.properties.blur;
            if (this.isInputConnected(3)) {
                blur = this.getInputData(3);
                this.properties.blur = blur;
            }

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var mesh = Mesh.getScreenQuad();
            var shader = LGraphFXLens._shader;
            //var camera = LS.Renderer._current_camera;

            this._tex.drawTo(function() {
                tex.bind(0);
                shader
                    .uniforms({
                        u_texture: 0,
                        u_aberration: aberration,
                        u_distortion: distortion,
                        u_blur: blur
                    })
                    .draw(mesh);
            });

            this.setOutputData(0, this._tex);
        };

        LGraphFXLens.pixel_shader =
            "precision highp float;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform float u_aberration;\n\
			uniform float u_distortion;\n\
			uniform float u_blur;\n\
			\n\
			void main() {\n\
				vec2 coord = v_coord;\n\
				float dist = distance(vec2(0.5), coord);\n\
				vec2 dist_coord = coord - vec2(0.5);\n\
				float percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\n\
				dist_coord *= percent;\n\
				coord = dist_coord + vec2(0.5);\n\
				vec4 color = texture2D(u_texture,coord, u_blur * dist);\n\
				color.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\n\
				color.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\n\
				gl_FragColor = color;\n\
			}\n\
			";
        /*
			float normalized_tunable_sigmoid(float xs, float k)\n\
			{\n\
				xs = xs * 2.0 - 1.0;\n\
				float signx = sign(xs);\n\
				float absx = abs(xs);\n\
				return signx * ((-k - 1.0)*absx)/(2.0*(-2.0*k*absx+k-1.0)) + 0.5;\n\
			}\n\
		*/

        LiteGraph.registerNodeType("fx/lens", LGraphFXLens);
        global.LGraphFXLens = LGraphFXLens;

        /* not working yet
	function LGraphDepthOfField()
	{
		this.addInput("Color","Texture");
		this.addInput("Linear Depth","Texture");
		this.addInput("Camera","camera");
		this.addOutput("Texture","Texture");
		this.properties = { high_precision: false };
	}

	LGraphDepthOfField.title = "Depth Of Field";
	LGraphDepthOfField.desc = "Applies a depth of field effect";

	LGraphDepthOfField.prototype.onExecute = function()
	{
		var tex = this.getInputData(0);
		var depth = this.getInputData(1);
		var camera = this.getInputData(2);

		if(!tex || !depth || !camera) 
		{
			this.setOutputData(0, tex);
			return;
		}

		var precision = gl.UNSIGNED_BYTE;
		if(this.properties.high_precision)
			precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;			
		if(!this._temp_texture || this._temp_texture.type != precision ||
			this._temp_texture.width != tex.width || this._temp_texture.height != tex.height)
			this._temp_texture = new GL.Texture( tex.width, tex.height, { type: precision, format: gl.RGBA, filter: gl.LINEAR });

		var shader = LGraphDepthOfField._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphDepthOfField._pixel_shader );

		var screen_mesh = Mesh.getScreenQuad();

		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.BLEND );

		var camera_position = camera.getEye();
		var focus_point = camera.getCenter();
		var distance = vec3.distance( camera_position, focus_point );
		var far = camera.far;
		var focus_range = distance * 0.5;

		this._temp_texture.drawTo( function() {
			tex.bind(0);
			depth.bind(1);
			shader.uniforms({u_texture:0, u_depth_texture:1, u_resolution: [1/tex.width, 1/tex.height], u_far: far, u_focus_point: distance, u_focus_scale: focus_range }).draw(screen_mesh);
		});

		this.setOutputData(0, this._temp_texture);
	}

	//from http://tuxedolabs.blogspot.com.es/2018/05/bokeh-depth-of-field-in-single-pass.html
	LGraphDepthOfField._pixel_shader = "\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture; //Image to be processed\n\
		uniform sampler2D u_depth_texture; //Linear depth, where 1.0 == far plane\n\
		uniform vec2 u_iresolution; //The size of a pixel: vec2(1.0/width, 1.0/height)\n\
		uniform float u_far; // Far plane\n\
		uniform float u_focus_point;\n\
		uniform float u_focus_scale;\n\
		\n\
		const float GOLDEN_ANGLE = 2.39996323;\n\
		const float MAX_BLUR_SIZE = 20.0;\n\
		const float RAD_SCALE = 0.5; // Smaller = nicer blur, larger = faster\n\
		\n\
		float getBlurSize(float depth, float focusPoint, float focusScale)\n\
		{\n\
		 float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\
		 return abs(coc) * MAX_BLUR_SIZE;\n\
		}\n\
		\n\
		vec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n\
		{\n\
		 float centerDepth = texture2D(u_depth_texture, texCoord).r * u_far;\n\
		 float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n\
		 vec3 color = texture2D(u_texture, v_coord).rgb;\n\
		 float tot = 1.0;\n\
		\n\
		 float radius = RAD_SCALE;\n\
		 for (float ang = 0.0; ang < 100.0; ang += GOLDEN_ANGLE)\n\
		 {\n\
		  vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * u_iresolution * radius;\n\
			\n\
		  vec3 sampleColor = texture2D(u_texture, tc).rgb;\n\
		  float sampleDepth = texture2D(u_depth_texture, tc).r * u_far;\n\
		  float sampleSize = getBlurSize( sampleDepth, focusPoint, focusScale );\n\
		  if (sampleDepth > centerDepth)\n\
		   sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n\
			\n\
		  float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n\
		  color += mix(color/tot, sampleColor, m);\n\
		  tot += 1.0;\n\
		  radius += RAD_SCALE/radius;\n\
		  if(radius>=MAX_BLUR_SIZE)\n\
			 return color / tot;\n\
		 }\n\
		 return color / tot;\n\
		}\n\
		void main()\n\
		{\n\
			gl_FragColor = vec4( depthOfField( v_coord, u_focus_point, u_focus_scale ), 1.0 );\n\
			//gl_FragColor = vec4( texture2D(u_depth_texture, v_coord).r );\n\
		}\n\
		";

	LiteGraph.registerNodeType("fx/DOF", LGraphDepthOfField );
	global.LGraphDepthOfField = LGraphDepthOfField;
	*/

        //*******************************************************

        function LGraphFXBokeh() {
            this.addInput("Texture", "Texture");
            this.addInput("Blurred", "Texture");
            this.addInput("Mask", "Texture");
            this.addInput("Threshold", "number");
            this.addOutput("Texture", "Texture");
            this.properties = {
                shape: "",
                size: 10,
                alpha: 1.0,
                threshold: 1.0,
                high_precision: false
            };
        }

        LGraphFXBokeh.title = "Bokeh";
        LGraphFXBokeh.desc = "applies an Bokeh effect";

        LGraphFXBokeh.widgets_info = { shape: { widget: "texture" } };

        LGraphFXBokeh.prototype.onExecute = function() {
            var tex = this.getInputData(0);
            var blurred_tex = this.getInputData(1);
            var mask_tex = this.getInputData(2);
            if (!tex || !mask_tex || !this.properties.shape) {
                this.setOutputData(0, tex);
                return;
            }

            if (!blurred_tex) {
                blurred_tex = tex;
            }

            var shape_tex = LGraphTexture.getTexture(this.properties.shape);
            if (!shape_tex) {
                return;
            }

            var threshold = this.properties.threshold;
            if (this.isInputConnected(3)) {
                threshold = this.getInputData(3);
                this.properties.threshold = threshold;
            }

            var precision = gl.UNSIGNED_BYTE;
            if (this.properties.high_precision) {
                precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
            }
            if (
                !this._temp_texture ||
                this._temp_texture.type != precision ||
                this._temp_texture.width != tex.width ||
                this._temp_texture.height != tex.height
            ) {
                this._temp_texture = new GL.Texture(tex.width, tex.height, {
                    type: precision,
                    format: gl.RGBA,
                    filter: gl.LINEAR
                });
            }

            //iterations
            var size = this.properties.size;

            var first_shader = LGraphFXBokeh._first_shader;
            if (!first_shader) {
                first_shader = LGraphFXBokeh._first_shader = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    LGraphFXBokeh._first_pixel_shader
                );
            }

            var second_shader = LGraphFXBokeh._second_shader;
            if (!second_shader) {
                second_shader = LGraphFXBokeh._second_shader = new GL.Shader(
                    LGraphFXBokeh._second_vertex_shader,
                    LGraphFXBokeh._second_pixel_shader
                );
            }

            var points_mesh = this._points_mesh;
            if (
                !points_mesh ||
                points_mesh._width != tex.width ||
                points_mesh._height != tex.height ||
                points_mesh._spacing != 2
            ) {
                points_mesh = this.createPointsMesh(tex.width, tex.height, 2);
            }

            var screen_mesh = Mesh.getScreenQuad();

            var point_size = this.properties.size;
            var min_light = this.properties.min_light;
            var alpha = this.properties.alpha;

            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);

            this._temp_texture.drawTo(function() {
                tex.bind(0);
                blurred_tex.bind(1);
                mask_tex.bind(2);
                first_shader
                    .uniforms({
                        u_texture: 0,
                        u_texture_blur: 1,
                        u_mask: 2,
                        u_texsize: [tex.width, tex.height]
                    })
                    .draw(screen_mesh);
            });

            this._temp_texture.drawTo(function() {
                //clear because we use blending
                //gl.clearColor(0.0,0.0,0.0,1.0);
                //gl.clear( gl.COLOR_BUFFER_BIT );
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);

                tex.bind(0);
                shape_tex.bind(3);
                second_shader
                    .uniforms({
                        u_texture: 0,
                        u_mask: 2,
                        u_shape: 3,
                        u_alpha: alpha,
                        u_threshold: threshold,
                        u_pointSize: point_size,
                        u_itexsize: [1.0 / tex.width, 1.0 / tex.height]
                    })
                    .draw(points_mesh, gl.POINTS);
            });

            this.setOutputData(0, this._temp_texture);
        };

        LGraphFXBokeh.prototype.createPointsMesh = function(
            width,
            height,
            spacing
        ) {
            var nwidth = Math.round(width / spacing);
            var nheight = Math.round(height / spacing);

            var vertices = new Float32Array(nwidth * nheight * 2);

            var ny = -1;
            var dx = (2 / width) * spacing;
            var dy = (2 / height) * spacing;
            for (var y = 0; y < nheight; ++y) {
                var nx = -1;
                for (var x = 0; x < nwidth; ++x) {
                    var pos = y * nwidth * 2 + x * 2;
                    vertices[pos] = nx;
                    vertices[pos + 1] = ny;
                    nx += dx;
                }
                ny += dy;
            }

            this._points_mesh = GL.Mesh.load({ vertices2D: vertices });
            this._points_mesh._width = width;
            this._points_mesh._height = height;
            this._points_mesh._spacing = spacing;

            return this._points_mesh;
        };

        /*
	LGraphTextureBokeh._pixel_shader = "precision highp float;\n\
			varying vec2 a_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_shape;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D( u_texture, gl_PointCoord );\n\
				color *= v_color * u_alpha;\n\
				gl_FragColor = color;\n\
			}\n";
	*/

        LGraphFXBokeh._first_pixel_shader =
            "precision highp float;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_texture_blur;\n\
			uniform sampler2D u_mask;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				vec4 blurred_color = texture2D(u_texture_blur, v_coord);\n\
				float mask = texture2D(u_mask, v_coord).x;\n\
			   gl_FragColor = mix(color, blurred_color, mask);\n\
			}\n\
			";

        LGraphFXBokeh._second_vertex_shader =
            "precision highp float;\n\
			attribute vec2 a_vertex2D;\n\
			varying vec4 v_color;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_mask;\n\
			uniform vec2 u_itexsize;\n\
			uniform float u_pointSize;\n\
			uniform float u_threshold;\n\
			void main() {\n\
				vec2 coord = a_vertex2D * 0.5 + 0.5;\n\
				v_color = texture2D( u_texture, coord );\n\
				v_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\n\
				v_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\n\
				v_color += texture2D( u_texture, coord + u_itexsize);\n\
				v_color *= 0.25;\n\
				float mask = texture2D(u_mask, coord).x;\n\
				float luminance = length(v_color) * mask;\n\
				/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\n\
				luminance -= u_threshold;\n\
				if(luminance < 0.0)\n\
				{\n\
					gl_Position.x = -100.0;\n\
					return;\n\
				}\n\
				gl_PointSize = u_pointSize;\n\
				gl_Position = vec4(a_vertex2D,0.0,1.0);\n\
			}\n\
			";

        LGraphFXBokeh._second_pixel_shader =
            "precision highp float;\n\
			varying vec4 v_color;\n\
			uniform sampler2D u_shape;\n\
			uniform float u_alpha;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D( u_shape, gl_PointCoord );\n\
				color *= v_color * u_alpha;\n\
				gl_FragColor = color;\n\
			}\n";

        LiteGraph.registerNodeType("fx/bokeh", LGraphFXBokeh);
        global.LGraphFXBokeh = LGraphFXBokeh;

        //************************************************

        function LGraphFXGeneric() {
            this.addInput("Texture", "Texture");
            this.addInput("value1", "number");
            this.addInput("value2", "number");
            this.addOutput("Texture", "Texture");
            this.properties = {
                fx: "halftone",
                value1: 1,
                value2: 1,
                precision: LGraphTexture.DEFAULT
            };
        }

        LGraphFXGeneric.title = "FX";
        LGraphFXGeneric.desc = "applies an FX from a list";

        LGraphFXGeneric.widgets_info = {
            fx: {
                widget: "combo",
                values: ["halftone", "pixelate", "lowpalette", "noise", "gamma"]
            },
            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
        };
        LGraphFXGeneric.shaders = {};

        LGraphFXGeneric.prototype.onExecute = function() {
            if (!this.isOutputConnected(0)) {
                return;
            } //saves work

            var tex = this.getInputData(0);
            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
                this.setOutputData(0, tex);
                return;
            }

            if (!tex) {
                return;
            }

            this._tex = LGraphTexture.getTargetTexture(
                tex,
                this._tex,
                this.properties.precision
            );

            //iterations
            var value1 = this.properties.value1;
            if (this.isInputConnected(1)) {
                value1 = this.getInputData(1);
                this.properties.value1 = value1;
            }

            var value2 = this.properties.value2;
            if (this.isInputConnected(2)) {
                value2 = this.getInputData(2);
                this.properties.value2 = value2;
            }

            var fx = this.properties.fx;
            var shader = LGraphFXGeneric.shaders[fx];
            if (!shader) {
                var pixel_shader_code = LGraphFXGeneric["pixel_shader_" + fx];
                if (!pixel_shader_code) {
                    return;
                }

                shader = LGraphFXGeneric.shaders[fx] = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    pixel_shader_code
                );
            }

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var mesh = Mesh.getScreenQuad();
            var camera = global.LS ? LS.Renderer._current_camera : null;
            var camera_planes;
            if (camera) {
                camera_planes = [
                    LS.Renderer._current_camera.near,
                    LS.Renderer._current_camera.far
                ];
            } else {
                camera_planes = [1, 100];
            }

            var noise = null;
            if (fx == "noise") {
                noise = LGraphTexture.getNoiseTexture();
            }

            this._tex.drawTo(function() {
                tex.bind(0);
                if (fx == "noise") {
                    noise.bind(1);
                }

                shader
                    .uniforms({
                        u_texture: 0,
                        u_noise: 1,
                        u_size: [tex.width, tex.height],
                        u_rand: [Math.random(), Math.random()],
                        u_value1: value1,
                        u_value2: value2,
                        u_camera_planes: camera_planes
                    })
                    .draw(mesh);
            });

            this.setOutputData(0, this._tex);
        };

        LGraphFXGeneric.pixel_shader_halftone =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			\n\
			float pattern() {\n\
				float s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\n\
				vec2 tex = v_coord * u_size.xy;\n\
				vec2 point = vec2(\n\
				   c * tex.x - s * tex.y ,\n\
				   s * tex.x + c * tex.y \n\
				) * u_value2;\n\
				return (sin(point.x) * sin(point.y)) * 4.0;\n\
			}\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				float average = (color.r + color.g + color.b) / 3.0;\n\
				gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\
			}\n";

        LGraphFXGeneric.pixel_shader_pixelate =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			\n\
			void main() {\n\
				vec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\n\
				vec4 color = texture2D(u_texture, coord);\n\
				gl_FragColor = color;\n\
			}\n";

        LGraphFXGeneric.pixel_shader_lowpalette =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				gl_FragColor = floor(color * u_value1) / u_value1;\n\
			}\n";

        LGraphFXGeneric.pixel_shader_noise =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_noise;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			uniform vec2 u_rand;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				vec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\n\
				gl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\n\
			}\n";

        LGraphFXGeneric.pixel_shader_gamma =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform float u_value1;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				float gamma = 1.0 / u_value1;\n\
				gl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\n\
			}\n";

        LiteGraph.registerNodeType("fx/generic", LGraphFXGeneric);
        global.LGraphFXGeneric = LGraphFXGeneric;

        // Vigneting ************************************

        function LGraphFXVigneting() {
            this.addInput("Tex.", "Texture");
            this.addInput("intensity", "number");

            this.addOutput("Texture", "Texture");
            this.properties = {
                intensity: 1,
                invert: false,
                precision: LGraphTexture.DEFAULT
            };

            if (!LGraphFXVigneting._shader) {
                LGraphFXVigneting._shader = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    LGraphFXVigneting.pixel_shader
                );
            }
        }

        LGraphFXVigneting.title = "Vigneting";
        LGraphFXVigneting.desc = "Vigneting";

        LGraphFXVigneting.widgets_info = {
            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
        };

        LGraphFXVigneting.prototype.onExecute = function() {
            var tex = this.getInputData(0);

            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
                this.setOutputData(0, tex);
                return;
            }

            if (!tex) {
                return;
            }

            this._tex = LGraphTexture.getTargetTexture(
                tex,
                this._tex,
                this.properties.precision
            );

            var intensity = this.properties.intensity;
            if (this.isInputConnected(1)) {
                intensity = this.getInputData(1);
                this.properties.intensity = intensity;
            }

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);

            var mesh = Mesh.getScreenQuad();
            var shader = LGraphFXVigneting._shader;
            var invert = this.properties.invert;

            this._tex.drawTo(function() {
                tex.bind(0);
                shader
                    .uniforms({
                        u_texture: 0,
                        u_intensity: intensity,
                        u_isize: [1 / tex.width, 1 / tex.height],
                        u_invert: invert ? 1 : 0
                    })
                    .draw(mesh);
            });

            this.setOutputData(0, this._tex);
        };

        LGraphFXVigneting.pixel_shader =
            "precision highp float;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform float u_intensity;\n\
			uniform int u_invert;\n\
			\n\
			void main() {\n\
				float luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				if(u_invert == 1)\n\
					luminance = 1.0 - luminance;\n\
				luminance = mix(1.0, luminance, u_intensity);\n\
			   gl_FragColor = vec4( luminance * color.xyz, color.a);\n\
			}\n\
			";

        LiteGraph.registerNodeType("fx/vigneting", LGraphFXVigneting);
        global.LGraphFXVigneting = LGraphFXVigneting;
    }
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;
    var MIDI_COLOR = "#243";

    function MIDIEvent(data) {
        this.channel = 0;
        this.cmd = 0;
        this.data = new Uint32Array(3);

        if (data) {
            this.setup(data);
        }
    }

    LiteGraph.MIDIEvent = MIDIEvent;

    MIDIEvent.prototype.fromJSON = function(o) {
        this.setup(o.data);
    };

    MIDIEvent.prototype.setup = function(data) {
        var raw_data = data;
        if (data.constructor === Object) {
            raw_data = data.data;
        }

        this.data.set(raw_data);

        var midiStatus = raw_data[0];
        this.status = midiStatus;

        var midiCommand = midiStatus & 0xf0;

        if (midiStatus >= 0xf0) {
            this.cmd = midiStatus;
        } else {
            this.cmd = midiCommand;
        }

        if (this.cmd == MIDIEvent.NOTEON && this.velocity == 0) {
            this.cmd = MIDIEvent.NOTEOFF;
        }

        this.cmd_str = MIDIEvent.commands[this.cmd] || "";

        if (
            midiCommand >= MIDIEvent.NOTEON ||
            midiCommand <= MIDIEvent.NOTEOFF
        ) {
            this.channel = midiStatus & 0x0f;
        }
    };

    Object.defineProperty(MIDIEvent.prototype, "velocity", {
        get: function() {
            if (this.cmd == MIDIEvent.NOTEON) {
                return this.data[2];
            }
            return -1;
        },
        set: function(v) {
            this.data[2] = v; //  v / 127;
        },
        enumerable: true
    });

    MIDIEvent.notes = [
        "A",
        "A#",
        "B",
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#"
    ];
    MIDIEvent.note_to_index = {
        A: 0,
        "A#": 1,
        B: 2,
        C: 3,
        "C#": 4,
        D: 5,
        "D#": 6,
        E: 7,
        F: 8,
        "F#": 9,
        G: 10,
        "G#": 11
    };

    Object.defineProperty(MIDIEvent.prototype, "note", {
        get: function() {
            if (this.cmd != MIDIEvent.NOTEON) {
                return -1;
            }
            return MIDIEvent.toNoteString(this.data[1], true);
        },
        set: function(v) {
            throw "notes cannot be assigned this way, must modify the data[1]";
        },
        enumerable: true
    });

    Object.defineProperty(MIDIEvent.prototype, "octave", {
        get: function() {
            if (this.cmd != MIDIEvent.NOTEON) {
                return -1;
            }
            var octave = this.data[1] - 24;
            return Math.floor(octave / 12 + 1);
        },
        set: function(v) {
            throw "octave cannot be assigned this way, must modify the data[1]";
        },
        enumerable: true
    });

    //returns HZs
    MIDIEvent.prototype.getPitch = function() {
        return Math.pow(2, (this.data[1] - 69) / 12) * 440;
    };

    MIDIEvent.computePitch = function(note) {
        return Math.pow(2, (note - 69) / 12) * 440;
    };

    MIDIEvent.prototype.getCC = function() {
        return this.data[1];
    };

    MIDIEvent.prototype.getCCValue = function() {
        return this.data[2];
    };

    //not tested, there is a formula missing here
    MIDIEvent.prototype.getPitchBend = function() {
        return this.data[1] + (this.data[2] << 7) - 8192;
    };

    MIDIEvent.computePitchBend = function(v1, v2) {
        return v1 + (v2 << 7) - 8192;
    };

    MIDIEvent.prototype.setCommandFromString = function(str) {
        this.cmd = MIDIEvent.computeCommandFromString(str);
    };

    MIDIEvent.computeCommandFromString = function(str) {
        if (!str) {
            return 0;
        }

        if (str && str.constructor === Number) {
            return str;
        }

        str = str.toUpperCase();
        switch (str) {
            case "NOTE ON":
            case "NOTEON":
                return MIDIEvent.NOTEON;
                break;
            case "NOTE OFF":
            case "NOTEOFF":
                return MIDIEvent.NOTEON;
                break;
            case "KEY PRESSURE":
            case "KEYPRESSURE":
                return MIDIEvent.KEYPRESSURE;
                break;
            case "CONTROLLER CHANGE":
            case "CONTROLLERCHANGE":
            case "CC":
                return MIDIEvent.CONTROLLERCHANGE;
                break;
            case "PROGRAM CHANGE":
            case "PROGRAMCHANGE":
            case "PC":
                return MIDIEvent.PROGRAMCHANGE;
                break;
            case "CHANNEL PRESSURE":
            case "CHANNELPRESSURE":
                return MIDIEvent.CHANNELPRESSURE;
                break;
            case "PITCH BEND":
            case "PITCHBEND":
                return MIDIEvent.PITCHBEND;
                break;
            case "TIME TICK":
            case "TIMETICK":
                return MIDIEvent.TIMETICK;
                break;
            default:
                return Number(str); //asume its a hex code
        }
    };

    //transform from a pitch number to string like "C4"
    MIDIEvent.toNoteString = function(d, skip_octave) {
        d = Math.round(d); //in case it has decimals
        var note = d - 21;
        var octave = Math.floor((d - 24) / 12 + 1);
        note = note % 12;
        if (note < 0) {
            note = 12 + note;
        }
        return MIDIEvent.notes[note] + (skip_octave ? "" : octave);
    };

    MIDIEvent.NoteStringToPitch = function(str) {
        str = str.toUpperCase();
        var note = str[0];
        var octave = 4;

        if (str[1] == "#") {
            note += "#";
            if (str.length > 2) {
                octave = Number(str[2]);
            }
        } else {
            if (str.length > 1) {
                octave = Number(str[1]);
            }
        }
        var pitch = MIDIEvent.note_to_index[note];
        if (pitch == null) {
            return null;
        }
        return (octave - 1) * 12 + pitch + 21;
    };

    MIDIEvent.prototype.toString = function() {
        var str = "" + this.channel + ". ";
        switch (this.cmd) {
            case MIDIEvent.NOTEON:
                str += "NOTEON " + MIDIEvent.toNoteString(this.data[1]);
                break;
            case MIDIEvent.NOTEOFF:
                str += "NOTEOFF " + MIDIEvent.toNoteString(this.data[1]);
                break;
            case MIDIEvent.CONTROLLERCHANGE:
                str += "CC " + this.data[1] + " " + this.data[2];
                break;
            case MIDIEvent.PROGRAMCHANGE:
                str += "PC " + this.data[1];
                break;
            case MIDIEvent.PITCHBEND:
                str += "PITCHBEND " + this.getPitchBend();
                break;
            case MIDIEvent.KEYPRESSURE:
                str += "KEYPRESS " + this.data[1];
                break;
        }

        return str;
    };

    MIDIEvent.prototype.toHexString = function() {
        var str = "";
        for (var i = 0; i < this.data.length; i++) {
            str += this.data[i].toString(16) + " ";
        }
    };

    MIDIEvent.prototype.toJSON = function() {
        return {
            data: [this.data[0], this.data[1], this.data[2]],
            object_class: "MIDIEvent"
        };
    };

    MIDIEvent.NOTEOFF = 0x80;
    MIDIEvent.NOTEON = 0x90;
    MIDIEvent.KEYPRESSURE = 0xa0;
    MIDIEvent.CONTROLLERCHANGE = 0xb0;
    MIDIEvent.PROGRAMCHANGE = 0xc0;
    MIDIEvent.CHANNELPRESSURE = 0xd0;
    MIDIEvent.PITCHBEND = 0xe0;
    MIDIEvent.TIMETICK = 0xf8;

    MIDIEvent.commands = {
        0x80: "note off",
        0x90: "note on",
        0xa0: "key pressure",
        0xb0: "controller change",
        0xc0: "program change",
        0xd0: "channel pressure",
        0xe0: "pitch bend",
        0xf0: "system",
        0xf2: "Song pos",
        0xf3: "Song select",
        0xf6: "Tune request",
        0xf8: "time tick",
        0xfa: "Start Song",
        0xfb: "Continue Song",
        0xfc: "Stop Song",
        0xfe: "Sensing",
        0xff: "Reset"
    };

    MIDIEvent.commands_short = {
        0x80: "NOTEOFF",
        0x90: "NOTEOFF",
        0xa0: "KEYP",
        0xb0: "CC",
        0xc0: "PC",
        0xd0: "CP",
        0xe0: "PB",
        0xf0: "SYS",
        0xf2: "POS",
        0xf3: "SELECT",
        0xf6: "TUNEREQ",
        0xf8: "TT",
        0xfa: "START",
        0xfb: "CONTINUE",
        0xfc: "STOP",
        0xfe: "SENS",
        0xff: "RESET"
    };

    MIDIEvent.commands_reversed = {};
    for (var i in MIDIEvent.commands) {
        MIDIEvent.commands_reversed[MIDIEvent.commands[i]] = i;
    }

    //MIDI wrapper, instantiate by MIDIIn and MIDIOut
    function MIDIInterface(on_ready, on_error) {
        if (!navigator.requestMIDIAccess) {
            this.error = "not suppoorted";
            if (on_error) {
                on_error("Not supported");
            } else {
                console.error("MIDI NOT SUPPORTED, enable by chrome://flags");
            }
            return;
        }

        this.on_ready = on_ready;

        this.state = {
            note: [],
            cc: []
        };

		this.input_ports = null;
		this.input_ports_info = [];
		this.output_ports = null;
		this.output_ports_info = [];

        navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));
    }

    MIDIInterface.input = null;

    MIDIInterface.MIDIEvent = MIDIEvent;

    MIDIInterface.prototype.onMIDISuccess = function(midiAccess) {
        console.log("MIDI ready!");
        console.log(midiAccess);
        this.midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
        this.updatePorts();

        if (this.on_ready) {
            this.on_ready(this);
        }
    };

    MIDIInterface.prototype.updatePorts = function() {
        var midi = this.midi;
        this.input_ports = midi.inputs;
		this.input_ports_info = [];
        this.output_ports = midi.outputs;
		this.output_ports_info = [];

        var num = 0;

        var it = this.input_ports.values();
        var it_value = it.next();
        while (it_value && it_value.done === false) {
            var port_info = it_value.value;
			this.input_ports_info.push(port_info);
            console.log( "Input port [type:'" + port_info.type + "'] id:'" + port_info.id + "' manufacturer:'" + port_info.manufacturer + "' name:'" + port_info.name + "' version:'" + port_info.version + "'" );
            num++;
            it_value = it.next();
        }
        this.num_input_ports = num;

        num = 0;
        var it = this.output_ports.values();
        var it_value = it.next();
        while (it_value && it_value.done === false) {
            var port_info = it_value.value;
			this.output_ports_info.push(port_info);
            console.log( "Output port [type:'" + port_info.type + "'] id:'" + port_info.id + "' manufacturer:'" + port_info.manufacturer + "' name:'" + port_info.name + "' version:'" + port_info.version + "'" );
            num++;
            it_value = it.next();
        }
        this.num_output_ports = num;
    };

    MIDIInterface.prototype.onMIDIFailure = function(msg) {
        console.error("Failed to get MIDI access - " + msg);
    };

    MIDIInterface.prototype.openInputPort = function(port, callback) {
        var input_port = this.input_ports.get("input-" + port);
        if (!input_port) {
            return false;
        }
        MIDIInterface.input = this;
        var that = this;

        input_port.onmidimessage = function(a) {
            var midi_event = new MIDIEvent(a.data);
            that.updateState(midi_event);
            if (callback) {
                callback(a.data, midi_event);
            }
            if (MIDIInterface.on_message) {
                MIDIInterface.on_message(a.data, midi_event);
            }
        };
        console.log("port open: ", input_port);
        return true;
    };

    MIDIInterface.parseMsg = function(data) {};

    MIDIInterface.prototype.updateState = function(midi_event) {
        switch (midi_event.cmd) {
            case MIDIEvent.NOTEON:
                this.state.note[midi_event.value1 | 0] = midi_event.value2;
                break;
            case MIDIEvent.NOTEOFF:
                this.state.note[midi_event.value1 | 0] = 0;
                break;
            case MIDIEvent.CONTROLLERCHANGE:
                this.state.cc[midi_event.getCC()] = midi_event.getCCValue();
                break;
        }
    };

    MIDIInterface.prototype.sendMIDI = function(port, midi_data) {
        if (!midi_data) {
            return;
        }

        var output_port = this.output_ports_info[port];//this.output_ports.get("output-" + port);
        if (!output_port) {
            return;
        }

        MIDIInterface.output = this;

        if (midi_data.constructor === MIDIEvent) {
            output_port.send(midi_data.data);
        } else {
            output_port.send(midi_data);
        }
    };

    function LGMIDIIn() {
        this.addOutput("on_midi", LiteGraph.EVENT);
        this.addOutput("out", "midi");
        this.properties = { port: 0 };
        this._last_midi_event = null;
        this._current_midi_event = null;
        this.boxcolor = "#AAA";
        this._last_time = 0;

        var that = this;
        new MIDIInterface(function(midi) {
            //open
            that._midi = midi;
            if (that._waiting) {
                that.onStart();
            }
            that._waiting = false;
        });
    }

    LGMIDIIn.MIDIInterface = MIDIInterface;

    LGMIDIIn.title = "MIDI Input";
    LGMIDIIn.desc = "Reads MIDI from a input port";
    LGMIDIIn.color = MIDI_COLOR;

    LGMIDIIn.prototype.getPropertyInfo = function(name) {
        if (!this._midi) {
            return;
        }

        if (name == "port") {
            var values = {};
            for (var i = 0; i < this._midi.input_ports_info.length; ++i) {
                var input = this._midi.input_ports_info[i];
                values[i] = i + ".- " + input.name + " version:" + input.version;
            }
            return { type: "enum", values: values };
        }
    };

    LGMIDIIn.prototype.onStart = function() {
        if (this._midi) {
            this._midi.openInputPort(
                this.properties.port,
                this.onMIDIEvent.bind(this)
            );
        } else {
            this._waiting = true;
        }
    };

    LGMIDIIn.prototype.onMIDIEvent = function(data, midi_event) {
        this._last_midi_event = midi_event;
        this.boxcolor = "#AFA";
        this._last_time = LiteGraph.getTime();
        this.trigger("on_midi", midi_event);
        if (midi_event.cmd == MIDIEvent.NOTEON) {
            this.trigger("on_noteon", midi_event);
        } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {
            this.trigger("on_noteoff", midi_event);
        } else if (midi_event.cmd == MIDIEvent.CONTROLLERCHANGE) {
            this.trigger("on_cc", midi_event);
        } else if (midi_event.cmd == MIDIEvent.PROGRAMCHANGE) {
            this.trigger("on_pc", midi_event);
        } else if (midi_event.cmd == MIDIEvent.PITCHBEND) {
            this.trigger("on_pitchbend", midi_event);
        }
    };

    LGMIDIIn.prototype.onDrawBackground = function(ctx) {
        this.boxcolor = "#AAA";
        if (!this.flags.collapsed && this._last_midi_event) {
            ctx.fillStyle = "white";
            var now = LiteGraph.getTime();
            var f = 1.0 - Math.max(0, (now - this._last_time) * 0.001);
            if (f > 0) {
                var t = ctx.globalAlpha;
                ctx.globalAlpha *= f;
                ctx.font = "12px Tahoma";
                ctx.fillText(
                    this._last_midi_event.toString(),
                    2,
                    this.size[1] * 0.5 + 3
                );
                //ctx.fillRect(0,0,this.size[0],this.size[1]);
                ctx.globalAlpha = t;
            }
        }
    };

    LGMIDIIn.prototype.onExecute = function() {
        if (this.outputs) {
            var last = this._last_midi_event;
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                var v = null;
                switch (output.name) {
                    case "midi":
                        v = this._midi;
                        break;
                    case "last_midi":
                        v = last;
                        break;
                    default:
                        continue;
                }
                this.setOutputData(i, v);
            }
        }
    };

    LGMIDIIn.prototype.onGetOutputs = function() {
        return [
            ["last_midi", "midi"],
            ["on_midi", LiteGraph.EVENT],
            ["on_noteon", LiteGraph.EVENT],
            ["on_noteoff", LiteGraph.EVENT],
            ["on_cc", LiteGraph.EVENT],
            ["on_pc", LiteGraph.EVENT],
            ["on_pitchbend", LiteGraph.EVENT]
        ];
    };

    LiteGraph.registerNodeType("midi/input", LGMIDIIn);

    function LGMIDIOut() {
        this.addInput("send", LiteGraph.EVENT);
        this.properties = { port: 0 };

        var that = this;
        new MIDIInterface(function(midi) {
            that._midi = midi;
			that.widget.options.values = that.getMIDIOutputs();
        });
		this.widget = this.addWidget("combo","Device",this.properties.port,{ property: "port", values: this.getMIDIOutputs.bind(this) });
		this.size = [340,60];
    }

    LGMIDIOut.MIDIInterface = MIDIInterface;

    LGMIDIOut.title = "MIDI Output";
    LGMIDIOut.desc = "Sends MIDI to output channel";
    LGMIDIOut.color = MIDI_COLOR;

    LGMIDIOut.prototype.onGetPropertyInfo = function(name) {
        if (!this._midi) {
            return;
        }

        if (name == "port") {
			var values = this.getMIDIOutputs();
            return { type: "enum", values: values };
        }
    };
	LGMIDIOut.default_ports = {0:"unknown"};

	LGMIDIOut.prototype.getMIDIOutputs = function()
	{
		var values = {};
		if(!this._midi)
			return LGMIDIOut.default_ports;
		if(this._midi.output_ports_info)
		for (var i = 0; i < this._midi.output_ports_info.length; ++i) {
			var output = this._midi.output_ports_info[i];
			if(!output)
				continue;
			var name = i + ".- " + output.name + " version:" + output.version;
			values[i] = name;
		}
		return values;
	}

    LGMIDIOut.prototype.onAction = function(event, midi_event) {
        //console.log(midi_event);
        if (!this._midi) {
            return;
        }
        if (event == "send") {
            this._midi.sendMIDI(this.properties.port, midi_event);
        }
        this.trigger("midi", midi_event);
    };

    LGMIDIOut.prototype.onGetInputs = function() {
        return [["send", LiteGraph.ACTION]];
    };

    LGMIDIOut.prototype.onGetOutputs = function() {
        return [["on_midi", LiteGraph.EVENT]];
    };

    LiteGraph.registerNodeType("midi/output", LGMIDIOut);


    function LGMIDIShow() {
        this.addInput("on_midi", LiteGraph.EVENT);
        this._str = "";
        this.size = [200, 40];
    }

    LGMIDIShow.title = "MIDI Show";
    LGMIDIShow.desc = "Shows MIDI in the graph";
    LGMIDIShow.color = MIDI_COLOR;

    LGMIDIShow.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this._str;
        }
        return this.title;
    };

    LGMIDIShow.prototype.onAction = function(event, midi_event) {
        if (!midi_event) {
            return;
        }
        if (midi_event.constructor === MIDIEvent) {
            this._str = midi_event.toString();
        } else {
            this._str = "???";
        }
    };

    LGMIDIShow.prototype.onDrawForeground = function(ctx) {
        if (!this._str || this.flags.collapsed) {
            return;
        }

        ctx.font = "30px Arial";
        ctx.fillText(this._str, 10, this.size[1] * 0.8);
    };

    LGMIDIShow.prototype.onGetInputs = function() {
        return [["in", LiteGraph.ACTION]];
    };

    LGMIDIShow.prototype.onGetOutputs = function() {
        return [["on_midi", LiteGraph.EVENT]];
    };

    LiteGraph.registerNodeType("midi/show", LGMIDIShow);

    function LGMIDIFilter() {
        this.properties = {
            channel: -1,
            cmd: -1,
            min_value: -1,
            max_value: -1
        };

        var that = this;
        this._learning = false;
        this.addWidget("button", "Learn", "", function() {
            that._learning = true;
            that.boxcolor = "#FA3";
        });

        this.addInput("in", LiteGraph.EVENT);
        this.addOutput("on_midi", LiteGraph.EVENT);
        this.boxcolor = "#AAA";
    }

    LGMIDIFilter.title = "MIDI Filter";
    LGMIDIFilter.desc = "Filters MIDI messages";
    LGMIDIFilter.color = MIDI_COLOR;

    LGMIDIFilter["@cmd"] = {
        type: "enum",
        title: "Command",
        values: MIDIEvent.commands_reversed
    };

    LGMIDIFilter.prototype.getTitle = function() {
        var str = null;
        if (this.properties.cmd == -1) {
            str = "Nothing";
        } else {
            str = MIDIEvent.commands_short[this.properties.cmd] || "Unknown";
        }

        if (
            this.properties.min_value != -1 &&
            this.properties.max_value != -1
        ) {
            str +=
                " " +
                (this.properties.min_value == this.properties.max_value
                    ? this.properties.max_value
                    : this.properties.min_value +
                      ".." +
                      this.properties.max_value);
        }

        return "Filter: " + str;
    };

    LGMIDIFilter.prototype.onPropertyChanged = function(name, value) {
        if (name == "cmd") {
            var num = Number(value);
            if (isNaN(num)) {
                num = MIDIEvent.commands[value] || 0;
            }
            this.properties.cmd = num;
        }
    };

    LGMIDIFilter.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (this._learning) {
            this._learning = false;
            this.boxcolor = "#AAA";
            this.properties.channel = midi_event.channel;
            this.properties.cmd = midi_event.cmd;
            this.properties.min_value = this.properties.max_value =
                midi_event.data[1];
        } else {
            if (
                this.properties.channel != -1 &&
                midi_event.channel != this.properties.channel
            ) {
                return;
            }
            if (
                this.properties.cmd != -1 &&
                midi_event.cmd != this.properties.cmd
            ) {
                return;
            }
            if (
                this.properties.min_value != -1 &&
                midi_event.data[1] < this.properties.min_value
            ) {
                return;
            }
            if (
                this.properties.max_value != -1 &&
                midi_event.data[1] > this.properties.max_value
            ) {
                return;
            }
        }

        this.trigger("on_midi", midi_event);
    };

    LiteGraph.registerNodeType("midi/filter", LGMIDIFilter);

    function LGMIDIEvent() {
        this.properties = {
            channel: 0,
            cmd: 144, //0x90
            value1: 1,
            value2: 1
        };

        this.addInput("send", LiteGraph.EVENT);
        this.addInput("assign", LiteGraph.EVENT);
        this.addOutput("on_midi", LiteGraph.EVENT);

        this.midi_event = new MIDIEvent();
        this.gate = false;
    }

    LGMIDIEvent.title = "MIDIEvent";
    LGMIDIEvent.desc = "Create a MIDI Event";
    LGMIDIEvent.color = MIDI_COLOR;

    LGMIDIEvent.prototype.onAction = function(event, midi_event) {
        if (event == "assign") {
            this.properties.channel = midi_event.channel;
            this.properties.cmd = midi_event.cmd;
            this.properties.value1 = midi_event.data[1];
            this.properties.value2 = midi_event.data[2];
            if (midi_event.cmd == MIDIEvent.NOTEON) {
                this.gate = true;
            } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {
                this.gate = false;
            }
            return;
        }

        //send
        var midi_event = this.midi_event;
        midi_event.channel = this.properties.channel;
        if (this.properties.cmd && this.properties.cmd.constructor === String) {
            midi_event.setCommandFromString(this.properties.cmd);
        } else {
            midi_event.cmd = this.properties.cmd;
        }
        midi_event.data[0] = midi_event.cmd | midi_event.channel;
        midi_event.data[1] = Number(this.properties.value1);
        midi_event.data[2] = Number(this.properties.value2);

        this.trigger("on_midi", midi_event);
    };

    LGMIDIEvent.prototype.onExecute = function() {
        var props = this.properties;

        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == -1) {
                    continue;
                }
                switch (input.name) {
                    case "note":
                        var v = this.getInputData(i);
                        if (v != null) {
                            if (v.constructor === String) {
                                v = MIDIEvent.NoteStringToPitch(v);
                            }
                            this.properties.value1 = (v | 0) % 255;
                        }
                        break;
                    case "cmd":
                        var v = this.getInputData(i);
                        if (v != null) {
                            this.properties.cmd = v;
                        }
                        break;
                    case "value1":
                        var v = this.getInputData(i);
                        if (v != null) {
                            this.properties.value1 = Math.clamp(v|0,0,127);
                        }
                        break;
                    case "value2":
                        var v = this.getInputData(i);
                        if (v != null) {
                            this.properties.value2 = Math.clamp(v|0,0,127);
                        }
                        break;
                }
            }
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                var v = null;
                switch (output.name) {
                    case "midi":
                        v = new MIDIEvent();
                        v.setup([props.cmd, props.value1, props.value2]);
                        v.channel = props.channel;
                        break;
                    case "command":
                        v = props.cmd;
                        break;
                    case "cc":
                        v = props.value1;
                        break;
                    case "cc_value":
                        v = props.value2;
                        break;
                    case "note":
                        v =
                            props.cmd == MIDIEvent.NOTEON ||
                            props.cmd == MIDIEvent.NOTEOFF
                                ? props.value1
                                : null;
                        break;
                    case "velocity":
                        v = props.cmd == MIDIEvent.NOTEON ? props.value2 : null;
                        break;
                    case "pitch":
                        v =
                            props.cmd == MIDIEvent.NOTEON
                                ? MIDIEvent.computePitch(props.value1)
                                : null;
                        break;
                    case "pitchbend":
                        v =
                            props.cmd == MIDIEvent.PITCHBEND
                                ? MIDIEvent.computePitchBend(
                                      props.value1,
                                      props.value2
                                  )
                                : null;
                        break;
                    case "gate":
                        v = this.gate;
                        break;
                    default:
                        continue;
                }
                if (v !== null) {
                    this.setOutputData(i, v);
                }
            }
        }
    };

    LGMIDIEvent.prototype.onPropertyChanged = function(name, value) {
        if (name == "cmd") {
            this.properties.cmd = MIDIEvent.computeCommandFromString(value);
        }
    };

    LGMIDIEvent.prototype.onGetInputs = function() {
        return [["cmd", "number"],["note", "number"],["value1", "number"],["value2", "number"]];
    };

    LGMIDIEvent.prototype.onGetOutputs = function() {
        return [
            ["midi", "midi"],
            ["on_midi", LiteGraph.EVENT],
            ["command", "number"],
            ["note", "number"],
            ["velocity", "number"],
            ["cc", "number"],
            ["cc_value", "number"],
            ["pitch", "number"],
            ["gate", "bool"],
            ["pitchbend", "number"]
        ];
    };

    LiteGraph.registerNodeType("midi/event", LGMIDIEvent);

    function LGMIDICC() {
        this.properties = {
            //		channel: 0,
            cc: 1,
            value: 0
        };

        this.addOutput("value", "number");
    }

    LGMIDICC.title = "MIDICC";
    LGMIDICC.desc = "gets a Controller Change";
    LGMIDICC.color = MIDI_COLOR;

    LGMIDICC.prototype.onExecute = function() {
        var props = this.properties;
        if (MIDIInterface.input) {
            this.properties.value =
                MIDIInterface.input.state.cc[this.properties.cc];
        }
        this.setOutputData(0, this.properties.value);
    };

    LiteGraph.registerNodeType("midi/cc", LGMIDICC);

    function LGMIDIGenerator() {
        this.addInput("generate", LiteGraph.ACTION);
        this.addInput("scale", "string");
        this.addInput("octave", "number");
        this.addOutput("note", LiteGraph.EVENT);
        this.properties = {
            notes: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#",
            octave: 2,
            duration: 0.5,
            mode: "sequence"
        };

        this.notes_pitches = LGMIDIGenerator.processScale(
            this.properties.notes
        );
        this.sequence_index = 0;
    }

    LGMIDIGenerator.title = "MIDI Generator";
    LGMIDIGenerator.desc = "Generates a random MIDI note";
    LGMIDIGenerator.color = MIDI_COLOR;

    LGMIDIGenerator.processScale = function(scale) {
        var notes = scale.split(",");
        for (var i = 0; i < notes.length; ++i) {
            var n = notes[i];
            if ((n.length == 2 && n[1] != "#") || n.length > 2) {
                notes[i] = -LiteGraph.MIDIEvent.NoteStringToPitch(n);
            } else {
                notes[i] = MIDIEvent.note_to_index[n] || 0;
            }
        }
        return notes;
    };

    LGMIDIGenerator.prototype.onPropertyChanged = function(name, value) {
        if (name == "notes") {
            this.notes_pitches = LGMIDIGenerator.processScale(value);
        }
    };

    LGMIDIGenerator.prototype.onExecute = function() {
        var octave = this.getInputData(2);
        if (octave != null) {
            this.properties.octave = octave;
        }

        var scale = this.getInputData(1);
        if (scale) {
            this.notes_pitches = LGMIDIGenerator.processScale(scale);
        }
    };

    LGMIDIGenerator.prototype.onAction = function(event, midi_event) {
        //var range = this.properties.max - this.properties.min;
        //var pitch = this.properties.min + ((Math.random() * range)|0);
        var pitch = 0;
        var range = this.notes_pitches.length;
        var index = 0;

        if (this.properties.mode == "sequence") {
            index = this.sequence_index = (this.sequence_index + 1) % range;
        } else if (this.properties.mode == "random") {
            index = Math.floor(Math.random() * range);
        }

        var note = this.notes_pitches[index];
        if (note >= 0) {
            pitch = note + (this.properties.octave - 1) * 12 + 33;
        } else {
            pitch = -note;
        }

        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 10]);
        var duration = this.properties.duration || 1;
        this.trigger("note", midi_event);

        //noteoff
        setTimeout(
            function() {
                var midi_event = new MIDIEvent();
                midi_event.setup([MIDIEvent.NOTEOFF, pitch, 0]);
                this.trigger("note", midi_event);
            }.bind(this),
            duration * 1000
        );
    };

    LiteGraph.registerNodeType("midi/generator", LGMIDIGenerator);

    function LGMIDITranspose() {
        this.properties = {
            amount: 0
        };
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("amount", "number");
        this.addOutput("out", LiteGraph.EVENT);

        this.midi_event = new MIDIEvent();
    }

    LGMIDITranspose.title = "MIDI Transpose";
    LGMIDITranspose.desc = "Transpose a MIDI note";
    LGMIDITranspose.color = MIDI_COLOR;

    LGMIDITranspose.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (
            midi_event.data[0] == MIDIEvent.NOTEON ||
            midi_event.data[0] == MIDIEvent.NOTEOFF
        ) {
            this.midi_event = new MIDIEvent();
            this.midi_event.setup(midi_event.data);
            this.midi_event.data[1] = Math.round(
                this.midi_event.data[1] + this.properties.amount
            );
            this.trigger("out", this.midi_event);
        } else {
            this.trigger("out", midi_event);
        }
    };

    LGMIDITranspose.prototype.onExecute = function() {
        var amount = this.getInputData(1);
        if (amount != null) {
            this.properties.amount = amount;
        }
    };

    LiteGraph.registerNodeType("midi/transpose", LGMIDITranspose);

    function LGMIDIQuantize() {
        this.properties = {
            scale: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#"
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("scale", "string");
        this.addOutput("out", LiteGraph.EVENT);

        this.valid_notes = new Array(12);
        this.offset_notes = new Array(12);
        this.processScale(this.properties.scale);
    }

    LGMIDIQuantize.title = "MIDI Quantize Pitch";
    LGMIDIQuantize.desc = "Transpose a MIDI note tp fit an scale";
    LGMIDIQuantize.color = MIDI_COLOR;

    LGMIDIQuantize.prototype.onPropertyChanged = function(name, value) {
        if (name == "scale") {
            this.processScale(value);
        }
    };

    LGMIDIQuantize.prototype.processScale = function(scale) {
        this._current_scale = scale;
        this.notes_pitches = LGMIDIGenerator.processScale(scale);
        for (var i = 0; i < 12; ++i) {
            this.valid_notes[i] = this.notes_pitches.indexOf(i) != -1;
        }
        for (var i = 0; i < 12; ++i) {
            if (this.valid_notes[i]) {
                this.offset_notes[i] = 0;
                continue;
            }
            for (var j = 1; j < 12; ++j) {
                if (this.valid_notes[(i - j) % 12]) {
                    this.offset_notes[i] = -j;
                    break;
                }
                if (this.valid_notes[(i + j) % 12]) {
                    this.offset_notes[i] = j;
                    break;
                }
            }
        }
    };

    LGMIDIQuantize.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (
            midi_event.data[0] == MIDIEvent.NOTEON ||
            midi_event.data[0] == MIDIEvent.NOTEOFF
        ) {
            this.midi_event = new MIDIEvent();
            this.midi_event.setup(midi_event.data);
            var note = midi_event.note;
            var index = MIDIEvent.note_to_index[note];
            var offset = this.offset_notes[index];
            this.midi_event.data[1] += offset;
            this.trigger("out", this.midi_event);
        } else {
            this.trigger("out", midi_event);
        }
    };

    LGMIDIQuantize.prototype.onExecute = function() {
        var scale = this.getInputData(1);
        if (scale != null && scale != this._current_scale) {
            this.processScale(scale);
        }
    };

    LiteGraph.registerNodeType("midi/quantize", LGMIDIQuantize);

	function LGMIDIFromFile() {
        this.properties = {
            url: "",
			autoplay: true
        };

        this.addInput("play", LiteGraph.ACTION);
        this.addInput("pause", LiteGraph.ACTION);
        this.addOutput("note", LiteGraph.EVENT);
		this._midi = null;
		this._current_time = 0;
		this._playing = false;

        if (typeof MidiParser == "undefined") {
            console.error(
                "midi-parser.js not included, LGMidiPlay requires that library: https://raw.githubusercontent.com/colxi/midi-parser-js/master/src/main.js"
            );
            this.boxcolor = "red";
		}

	}

    LGMIDIFromFile.title = "MIDI fromFile";
    LGMIDIFromFile.desc = "Plays a MIDI file";
    LGMIDIFromFile.color = MIDI_COLOR;

	LGMIDIFromFile.prototype.onAction = function( name )
	{
		if(name == "play")
			this.play();
		else if(name == "pause")
			this._playing = !this._playing;
	}

	LGMIDIFromFile.prototype.onPropertyChanged = function(name,value)
	{
		if(name == "url")
			this.loadMIDIFile(value);
	}

    LGMIDIFromFile.prototype.onExecute = function() {
		if(!this._midi)
			return;

		if(!this._playing)
			return;

		this._current_time += this.graph.elapsed_time;
		var current_time = this._current_time * 100;

		for(var i = 0; i < this._midi.tracks; ++i)
		{
			var track = this._midi.track[i];
			if(!track._last_pos)
			{
				track._last_pos = 0;
				track._time = 0;
			}

			var elem = track.event[ track._last_pos ];
			if(elem && (track._time + elem.deltaTime) <= current_time )
			{
				track._last_pos++;
				track._time += elem.deltaTime;

				if(elem.data)
				{
					var midi_cmd = elem.type << 4 + elem.channel;
					var midi_event = new MIDIEvent();
					midi_event.setup([midi_cmd, elem.data[0], elem.data[1]]);
					this.trigger("note", midi_event);
				}
			}
			
		}
    };

	LGMIDIFromFile.prototype.play = function()
	{
		this._playing = true;
		this._current_time = 0;
		if(!this._midi)
			return;

		for(var i = 0; i < this._midi.tracks; ++i)
		{
			var track = this._midi.track[i];
			track._last_pos = 0;
			track._time = 0;
		}		
	}

	LGMIDIFromFile.prototype.loadMIDIFile = function(url)
	{
		var that = this;
		LiteGraph.fetchFile( url, "arraybuffer", function(data)
		{
			that.boxcolor = "#AFA";
			that._midi = MidiParser.parse( new Uint8Array(data) );
			if(that.properties.autoplay)
				that.play();
		}, function(err){
			that.boxcolor = "#FAA";
			that._midi = null;
		});
	}

	LGMIDIFromFile.prototype.onDropFile = function(file)
	{
		this.properties.url = "";
		this.loadMIDIFile( file );
	}

    LiteGraph.registerNodeType("midi/fromFile", LGMIDIFromFile);


    function LGMIDIPlay() {
        this.properties = {
            volume: 0.5,
            duration: 1
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("volume", "number");
        this.addInput("duration", "number");
        this.addOutput("note", LiteGraph.EVENT);

        if (typeof AudioSynth == "undefined") {
            console.error(
                "Audiosynth.js not included, LGMidiPlay requires that library"
            );
            this.boxcolor = "red";
        } else {
            var Synth = (this.synth = new AudioSynth());
            this.instrument = Synth.createInstrument("piano");
        }
    }

    LGMIDIPlay.title = "MIDI Play";
    LGMIDIPlay.desc = "Plays a MIDI note";
    LGMIDIPlay.color = MIDI_COLOR;

    LGMIDIPlay.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (this.instrument && midi_event.data[0] == MIDIEvent.NOTEON) {
            var note = midi_event.note; //C#
            if (!note || note == "undefined" || note.constructor !== String) {
                return;
            }
            this.instrument.play(
                note,
                midi_event.octave,
                this.properties.duration,
                this.properties.volume
            );
        }
        this.trigger("note", midi_event);
    };

    LGMIDIPlay.prototype.onExecute = function() {
        var volume = this.getInputData(1);
        if (volume != null) {
            this.properties.volume = volume;
        }

        var duration = this.getInputData(2);
        if (duration != null) {
            this.properties.duration = duration;
        }
    };

    LiteGraph.registerNodeType("midi/play", LGMIDIPlay);

    function LGMIDIKeys() {
        this.properties = {
            num_octaves: 2,
            start_octave: 2
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("note", LiteGraph.EVENT);
        this.size = [400, 100];
        this.keys = [];
        this._last_key = -1;
    }

    LGMIDIKeys.title = "MIDI Keys";
    LGMIDIKeys.desc = "Keyboard to play notes";
    LGMIDIKeys.color = MIDI_COLOR;

    LGMIDIKeys.keys = [
        { x: 0, w: 1, h: 1, t: 0 },
        { x: 0.75, w: 0.5, h: 0.6, t: 1 },
        { x: 1, w: 1, h: 1, t: 0 },
        { x: 1.75, w: 0.5, h: 0.6, t: 1 },
        { x: 2, w: 1, h: 1, t: 0 },
        { x: 2.75, w: 0.5, h: 0.6, t: 1 },
        { x: 3, w: 1, h: 1, t: 0 },
        { x: 4, w: 1, h: 1, t: 0 },
        { x: 4.75, w: 0.5, h: 0.6, t: 1 },
        { x: 5, w: 1, h: 1, t: 0 },
        { x: 5.75, w: 0.5, h: 0.6, t: 1 },
        { x: 6, w: 1, h: 1, t: 0 }
    ];

    LGMIDIKeys.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var num_keys = this.properties.num_octaves * 12;
        this.keys.length = num_keys;
        var key_width = this.size[0] / (this.properties.num_octaves * 7);
        var key_height = this.size[1];

        ctx.globalAlpha = 1;

        for (
            var k = 0;
            k < 2;
            k++ //draw first whites (0) then blacks (1)
        ) {
            for (var i = 0; i < num_keys; ++i) {
                var key_info = LGMIDIKeys.keys[i % 12];
                if (key_info.t != k) {
                    continue;
                }
                var octave = Math.floor(i / 12);
                var x = octave * 7 * key_width + key_info.x * key_width;
                if (k == 0) {
                    ctx.fillStyle = this.keys[i] ? "#CCC" : "white";
                } else {
                    ctx.fillStyle = this.keys[i] ? "#333" : "black";
                }
                ctx.fillRect(
                    x + 1,
                    0,
                    key_width * key_info.w - 2,
                    key_height * key_info.h
                );
            }
        }
    };

    LGMIDIKeys.prototype.getKeyIndex = function(pos) {
        var num_keys = this.properties.num_octaves * 12;
        var key_width = this.size[0] / (this.properties.num_octaves * 7);
        var key_height = this.size[1];

        for (
            var k = 1;
            k >= 0;
            k-- //test blacks first (1) then whites (0)
        ) {
            for (var i = 0; i < this.keys.length; ++i) {
                var key_info = LGMIDIKeys.keys[i % 12];
                if (key_info.t != k) {
                    continue;
                }
                var octave = Math.floor(i / 12);
                var x = octave * 7 * key_width + key_info.x * key_width;
                var w = key_width * key_info.w;
                var h = key_height * key_info.h;
                if (pos[0] < x || pos[0] > x + w || pos[1] > h) {
                    continue;
                }
                return i;
            }
        }
        return -1;
    };

    LGMIDIKeys.prototype.onAction = function(event, params) {
        if (event == "reset") {
            for (var i = 0; i < this.keys.length; ++i) {
                this.keys[i] = false;
            }
            return;
        }

        if (!params || params.constructor !== MIDIEvent) {
            return;
        }
        var midi_event = params;
        var start_note = (this.properties.start_octave - 1) * 12 + 29;
        var index = midi_event.data[1] - start_note;
        if (index >= 0 && index < this.keys.length) {
            if (midi_event.data[0] == MIDIEvent.NOTEON) {
                this.keys[index] = true;
            } else if (midi_event.data[0] == MIDIEvent.NOTEOFF) {
                this.keys[index] = false;
            }
        }

        this.trigger("note", midi_event);
    };

    LGMIDIKeys.prototype.onMouseDown = function(e, pos) {
        if (pos[1] < 0) {
            return;
        }
        var index = this.getKeyIndex(pos);
        this.keys[index] = true;
        this._last_key = index;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);
        this.trigger("note", midi_event);
        return true;
    };

    LGMIDIKeys.prototype.onMouseMove = function(e, pos) {
        if (pos[1] < 0 || this._last_key == -1) {
            return;
        }
        this.setDirtyCanvas(true);
        var index = this.getKeyIndex(pos);
        if (this._last_key == index) {
            return true;
        }
        this.keys[this._last_key] = false;
        var pitch =
            (this.properties.start_octave - 1) * 12 + 29 + this._last_key;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);
        this.trigger("note", midi_event);

        this.keys[index] = true;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);
        this.trigger("note", midi_event);

        this._last_key = index;
        return true;
    };

    LGMIDIKeys.prototype.onMouseUp = function(e, pos) {
        if (pos[1] < 0) {
            return;
        }
        var index = this.getKeyIndex(pos);
        this.keys[index] = false;
        this._last_key = -1;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);
        this.trigger("note", midi_event);
        return true;
    };

    LiteGraph.registerNodeType("midi/keys", LGMIDIKeys);

    function now() {
        return window.performance.now();
    }
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    var LGAudio = {};
    global.LGAudio = LGAudio;

    LGAudio.getAudioContext = function() {
        if (!this._audio_context) {
            window.AudioContext =
                window.AudioContext || window.webkitAudioContext;
            if (!window.AudioContext) {
                console.error("AudioContext not supported by browser");
                return null;
            }
            this._audio_context = new AudioContext();
            this._audio_context.onmessage = function(msg) {
                console.log("msg", msg);
            };
            this._audio_context.onended = function(msg) {
                console.log("ended", msg);
            };
            this._audio_context.oncomplete = function(msg) {
                console.log("complete", msg);
            };
        }

        //in case it crashes
        //if(this._audio_context.state == "suspended")
        //	this._audio_context.resume();
        return this._audio_context;
    };

    LGAudio.connect = function(audionodeA, audionodeB) {
        try {
            audionodeA.connect(audionodeB);
        } catch (err) {
            console.warn("LGraphAudio:", err);
        }
    };

    LGAudio.disconnect = function(audionodeA, audionodeB) {
        try {
            audionodeA.disconnect(audionodeB);
        } catch (err) {
            console.warn("LGraphAudio:", err);
        }
    };

    LGAudio.changeAllAudiosConnections = function(node, connect) {
        if (node.inputs) {
            for (var i = 0; i < node.inputs.length; ++i) {
                var input = node.inputs[i];
                var link_info = node.graph.links[input.link];
                if (!link_info) {
                    continue;
                }

                var origin_node = node.graph.getNodeById(link_info.origin_id);
                var origin_audionode = null;
                if (origin_node.getAudioNodeInOutputSlot) {
                    origin_audionode = origin_node.getAudioNodeInOutputSlot(
                        link_info.origin_slot
                    );
                } else {
                    origin_audionode = origin_node.audionode;
                }

                var target_audionode = null;
                if (node.getAudioNodeInInputSlot) {
                    target_audionode = node.getAudioNodeInInputSlot(i);
                } else {
                    target_audionode = node.audionode;
                }

                if (connect) {
                    LGAudio.connect(origin_audionode, target_audionode);
                } else {
                    LGAudio.disconnect(origin_audionode, target_audionode);
                }
            }
        }

        if (node.outputs) {
            for (var i = 0; i < node.outputs.length; ++i) {
                var output = node.outputs[i];
                for (var j = 0; j < output.links.length; ++j) {
                    var link_info = node.graph.links[output.links[j]];
                    if (!link_info) {
                        continue;
                    }

                    var origin_audionode = null;
                    if (node.getAudioNodeInOutputSlot) {
                        origin_audionode = node.getAudioNodeInOutputSlot(i);
                    } else {
                        origin_audionode = node.audionode;
                    }

                    var target_node = node.graph.getNodeById(
                        link_info.target_id
                    );
                    var target_audionode = null;
                    if (target_node.getAudioNodeInInputSlot) {
                        target_audionode = target_node.getAudioNodeInInputSlot(
                            link_info.target_slot
                        );
                    } else {
                        target_audionode = target_node.audionode;
                    }

                    if (connect) {
                        LGAudio.connect(origin_audionode, target_audionode);
                    } else {
                        LGAudio.disconnect(origin_audionode, target_audionode);
                    }
                }
            }
        }
    };

    //used by many nodes
    LGAudio.onConnectionsChange = function(
        connection,
        slot,
        connected,
        link_info
    ) {
        //only process the outputs events
        if (connection != LiteGraph.OUTPUT) {
            return;
        }

        var target_node = null;
        if (link_info) {
            target_node = this.graph.getNodeById(link_info.target_id);
        }

        if (!target_node) {
            return;
        }

        //get origin audionode
        var local_audionode = null;
        if (this.getAudioNodeInOutputSlot) {
            local_audionode = this.getAudioNodeInOutputSlot(slot);
        } else {
            local_audionode = this.audionode;
        }

        //get target audionode
        var target_audionode = null;
        if (target_node.getAudioNodeInInputSlot) {
            target_audionode = target_node.getAudioNodeInInputSlot(
                link_info.target_slot
            );
        } else {
            target_audionode = target_node.audionode;
        }

        //do the connection/disconnection
        if (connected) {
            LGAudio.connect(local_audionode, target_audionode);
        } else {
            LGAudio.disconnect(local_audionode, target_audionode);
        }
    };

    //this function helps creating wrappers to existing classes
    LGAudio.createAudioNodeWrapper = function(class_object) {
        var old_func = class_object.prototype.onPropertyChanged;

        class_object.prototype.onPropertyChanged = function(name, value) {
            if (old_func) {
                old_func.call(this, name, value);
            }

            if (!this.audionode) {
                return;
            }

            if (this.audionode[name] === undefined) {
                return;
            }

            if (this.audionode[name].value !== undefined) {
                this.audionode[name].value = value;
            } else {
                this.audionode[name] = value;
            }
        };

        class_object.prototype.onConnectionsChange =
            LGAudio.onConnectionsChange;
    };

    //contains the samples decoded of the loaded audios in AudioBuffer format
    LGAudio.cached_audios = {};

    LGAudio.loadSound = function(url, on_complete, on_error) {
        if (LGAudio.cached_audios[url] && url.indexOf("blob:") == -1) {
            if (on_complete) {
                on_complete(LGAudio.cached_audios[url]);
            }
            return;
        }

        if (LGAudio.onProcessAudioURL) {
            url = LGAudio.onProcessAudioURL(url);
        }

        //load new sample
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = "arraybuffer";

        var context = LGAudio.getAudioContext();

        // Decode asynchronously
        request.onload = function() {
            console.log("AudioSource loaded");
            context.decodeAudioData(
                request.response,
                function(buffer) {
                    console.log("AudioSource decoded");
                    LGAudio.cached_audios[url] = buffer;
                    if (on_complete) {
                        on_complete(buffer);
                    }
                },
                onError
            );
        };
        request.send();

        function onError(err) {
            console.log("Audio loading sample error:", err);
            if (on_error) {
                on_error(err);
            }
        }

        return request;
    };

    //****************************************************

    function LGAudioSource() {
        this.properties = {
            src: "",
            gain: 0.5,
            loop: true,
            autoplay: true,
            playbackRate: 1
        };

        this._loading_audio = false;
        this._audiobuffer = null; //points to AudioBuffer with the audio samples decoded
        this._audionodes = [];
        this._last_sourcenode = null; //the last AudioBufferSourceNode (there could be more if there are several sounds playing)

        this.addOutput("out", "audio");
        this.addInput("gain", "number");

        //init context
        var context = LGAudio.getAudioContext();

        //create gain node to control volume
        this.audionode = context.createGain();
        this.audionode.graphnode = this;
        this.audionode.gain.value = this.properties.gain;

        //debug
        if (this.properties.src) {
            this.loadSound(this.properties.src);
        }
    }

	LGAudioSource.desc = "Plays an audio file";
    LGAudioSource["@src"] = { widget: "resource" };
    LGAudioSource.supported_extensions = ["wav", "ogg", "mp3"];

    LGAudioSource.prototype.onAdded = function(graph) {
        if (graph.status === LGraph.STATUS_RUNNING) {
            this.onStart();
        }
    };

    LGAudioSource.prototype.onStart = function() {
        if (!this._audiobuffer) {
            return;
        }

        if (this.properties.autoplay) {
			this.playBuffer(this._audiobuffer);
        }
    };

    LGAudioSource.prototype.onStop = function() {
        this.stopAllSounds();
    };

    LGAudioSource.prototype.onPause = function() {
        this.pauseAllSounds();
    };

    LGAudioSource.prototype.onUnpause = function() {
        this.unpauseAllSounds();
        //this.onStart();
    };

    LGAudioSource.prototype.onRemoved = function() {
        this.stopAllSounds();
        if (this._dropped_url) {
            URL.revokeObjectURL(this._url);
        }
    };

    LGAudioSource.prototype.stopAllSounds = function() {
        //iterate and stop
        for (var i = 0; i < this._audionodes.length; ++i) {
            if (this._audionodes[i].started) {
                this._audionodes[i].started = false;
                this._audionodes[i].stop();
            }
            //this._audionodes[i].disconnect( this.audionode );
        }
        this._audionodes.length = 0;
    };

    LGAudioSource.prototype.pauseAllSounds = function() {
        LGAudio.getAudioContext().suspend();
    };

    LGAudioSource.prototype.unpauseAllSounds = function() {
        LGAudio.getAudioContext().resume();
    };

    LGAudioSource.prototype.onExecute = function() {
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == null) {
                    continue;
                }
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                if (input.name == "gain")
                    this.audionode.gain.value = v;
                else if (input.name == "src") {
                    this.setProperty("src",v);
                } else if (input.name == "playbackRate") {
                    this.properties.playbackRate = v;
                    for (var j = 0; j < this._audionodes.length; ++j) {
                        this._audionodes[j].playbackRate.value = v;
                    }
                }
            }
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                if (output.name == "buffer" && this._audiobuffer) {
                    this.setOutputData(i, this._audiobuffer);
                }
            }
        }
    };

    LGAudioSource.prototype.onAction = function(event) {
        if (this._audiobuffer) {
            if (event == "Play") {
                this.playBuffer(this._audiobuffer);
            } else if (event == "Stop") {
                this.stopAllSounds();
            }
        }
    };

    LGAudioSource.prototype.onPropertyChanged = function(name, value) {
        if (name == "src") {
            this.loadSound(value);
        } else if (name == "gain") {
            this.audionode.gain.value = value;
        } else if (name == "playbackRate") {
            for (var j = 0; j < this._audionodes.length; ++j) {
                this._audionodes[j].playbackRate.value = value;
            }
        }
    };

    LGAudioSource.prototype.playBuffer = function(buffer) {
        var that = this;
        var context = LGAudio.getAudioContext();

        //create a new audionode (this is mandatory, AudioAPI doesnt like to reuse old ones)
        var audionode = context.createBufferSource(); //create a AudioBufferSourceNode
        this._last_sourcenode = audionode;
        audionode.graphnode = this;
        audionode.buffer = buffer;
        audionode.loop = this.properties.loop;
        audionode.playbackRate.value = this.properties.playbackRate;
        this._audionodes.push(audionode);
        audionode.connect(this.audionode); //connect to gain

		this._audionodes.push(audionode);

		this.trigger("start");

        audionode.onended = function() {
            //console.log("ended!");
            that.trigger("ended");
            //remove
            var index = that._audionodes.indexOf(audionode);
            if (index != -1) {
                that._audionodes.splice(index, 1);
            }
        };

        if (!audionode.started) {
            audionode.started = true;
            audionode.start();
        }
        return audionode;
    };

    LGAudioSource.prototype.loadSound = function(url) {
        var that = this;

        //kill previous load
        if (this._request) {
            this._request.abort();
            this._request = null;
        }

        this._audiobuffer = null; //points to the audiobuffer once the audio is loaded
        this._loading_audio = false;

        if (!url) {
            return;
        }

        this._request = LGAudio.loadSound(url, inner);

        this._loading_audio = true;
        this.boxcolor = "#AA4";

        function inner(buffer) {
            this.boxcolor = LiteGraph.NODE_DEFAULT_BOXCOLOR;
            that._audiobuffer = buffer;
            that._loading_audio = false;
            //if is playing, then play it
            if (that.graph && that.graph.status === LGraph.STATUS_RUNNING) {
                that.onStart();
            } //this controls the autoplay already
        }
    };

    //Helps connect/disconnect AudioNodes when new connections are made in the node
    LGAudioSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;

    LGAudioSource.prototype.onGetInputs = function() {
        return [
            ["playbackRate", "number"],
			["src","string"],
            ["Play", LiteGraph.ACTION],
            ["Stop", LiteGraph.ACTION]
        ];
    };

    LGAudioSource.prototype.onGetOutputs = function() {
        return [["buffer", "audiobuffer"], ["start", LiteGraph.EVENT], ["ended", LiteGraph.EVENT]];
    };

    LGAudioSource.prototype.onDropFile = function(file) {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
        var url = URL.createObjectURL(file);
        this.properties.src = url;
        this.loadSound(url);
        this._dropped_url = url;
    };

    LGAudioSource.title = "Source";
    LGAudioSource.desc = "Plays audio";
    LiteGraph.registerNodeType("audio/source", LGAudioSource);

    //****************************************************

    function LGAudioMediaSource() {
        this.properties = {
            gain: 0.5
        };

        this._audionodes = [];
        this._media_stream = null;

        this.addOutput("out", "audio");
        this.addInput("gain", "number");

        //create gain node to control volume
        var context = LGAudio.getAudioContext();
        this.audionode = context.createGain();
        this.audionode.graphnode = this;
        this.audionode.gain.value = this.properties.gain;
    }

    LGAudioMediaSource.prototype.onAdded = function(graph) {
        if (graph.status === LGraph.STATUS_RUNNING) {
            this.onStart();
        }
    };

    LGAudioMediaSource.prototype.onStart = function() {
        if (this._media_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }
    };

    LGAudioMediaSource.prototype.onStop = function() {
        this.audionode.gain.value = 0;
    };

    LGAudioMediaSource.prototype.onPause = function() {
        this.audionode.gain.value = 0;
    };

    LGAudioMediaSource.prototype.onUnpause = function() {
        this.audionode.gain.value = this.properties.gain;
    };

    LGAudioMediaSource.prototype.onRemoved = function() {
        this.audionode.gain.value = 0;
        if (this.audiosource_node) {
            this.audiosource_node.disconnect(this.audionode);
            this.audiosource_node = null;
        }
        if (this._media_stream) {
            var tracks = this._media_stream.getTracks();
            if (tracks.length) {
                tracks[0].stop();
            }
        }
    };

    LGAudioMediaSource.prototype.openStream = function() {
        if (!navigator.mediaDevices) {
            console.log(
                "getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags"
            );
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        navigator.mediaDevices
            .getUserMedia({ audio: true, video: false })
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(err) {
            console.log("Media rejected", err);
            that._media_stream = false;
            that.boxcolor = "red";
        }
    };

    LGAudioMediaSource.prototype.streamReady = function(localMediaStream) {
        this._media_stream = localMediaStream;
        //this._waiting_confirmation = false;

        //init context
        if (this.audiosource_node) {
            this.audiosource_node.disconnect(this.audionode);
        }
        var context = LGAudio.getAudioContext();
        this.audiosource_node = context.createMediaStreamSource(
            localMediaStream
        );
        this.audiosource_node.graphnode = this;
        this.audiosource_node.connect(this.audionode);
        this.boxcolor = "white";
    };

    LGAudioMediaSource.prototype.onExecute = function() {
        if (this._media_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == null) {
                    continue;
                }
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                if (input.name == "gain") {
                    this.audionode.gain.value = this.properties.gain = v;
                }
            }
        }
    };

    LGAudioMediaSource.prototype.onAction = function(event) {
        if (event == "Play") {
            this.audionode.gain.value = this.properties.gain;
        } else if (event == "Stop") {
            this.audionode.gain.value = 0;
        }
    };

    LGAudioMediaSource.prototype.onPropertyChanged = function(name, value) {
        if (name == "gain") {
            this.audionode.gain.value = value;
        }
    };

    //Helps connect/disconnect AudioNodes when new connections are made in the node
    LGAudioMediaSource.prototype.onConnectionsChange =
        LGAudio.onConnectionsChange;

    LGAudioMediaSource.prototype.onGetInputs = function() {
        return [
            ["playbackRate", "number"],
            ["Play", LiteGraph.ACTION],
            ["Stop", LiteGraph.ACTION]
        ];
    };

    LGAudioMediaSource.title = "MediaSource";
    LGAudioMediaSource.desc = "Plays microphone";
    LiteGraph.registerNodeType("audio/media_source", LGAudioMediaSource);

    //*****************************************************

    function LGAudioAnalyser() {
        this.properties = {
            fftSize: 2048,
            minDecibels: -100,
            maxDecibels: -10,
            smoothingTimeConstant: 0.5
        };

        var context = LGAudio.getAudioContext();

        this.audionode = context.createAnalyser();
        this.audionode.graphnode = this;
        this.audionode.fftSize = this.properties.fftSize;
        this.audionode.minDecibels = this.properties.minDecibels;
        this.audionode.maxDecibels = this.properties.maxDecibels;
        this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;

        this.addInput("in", "audio");
        this.addOutput("freqs", "array");
        this.addOutput("samples", "array");

        this._freq_bin = null;
        this._time_bin = null;
    }

    LGAudioAnalyser.prototype.onPropertyChanged = function(name, value) {
        this.audionode[name] = value;
    };

    LGAudioAnalyser.prototype.onExecute = function() {
        if (this.isOutputConnected(0)) {
            //send FFT
            var bufferLength = this.audionode.frequencyBinCount;
            if (!this._freq_bin || this._freq_bin.length != bufferLength) {
                this._freq_bin = new Uint8Array(bufferLength);
            }
            this.audionode.getByteFrequencyData(this._freq_bin);
            this.setOutputData(0, this._freq_bin);
        }

        //send analyzer
        if (this.isOutputConnected(1)) {
            //send Samples
            var bufferLength = this.audionode.frequencyBinCount;
            if (!this._time_bin || this._time_bin.length != bufferLength) {
                this._time_bin = new Uint8Array(bufferLength);
            }
            this.audionode.getByteTimeDomainData(this._time_bin);
            this.setOutputData(1, this._time_bin);
        }

        //properties
        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }

        //time domain
        //this.audionode.getFloatTimeDomainData( dataArray );
    };

    LGAudioAnalyser.prototype.onGetInputs = function() {
        return [
            ["minDecibels", "number"],
            ["maxDecibels", "number"],
            ["smoothingTimeConstant", "number"]
        ];
    };

    LGAudioAnalyser.prototype.onGetOutputs = function() {
        return [["freqs", "array"], ["samples", "array"]];
    };

    LGAudioAnalyser.title = "Analyser";
    LGAudioAnalyser.desc = "Audio Analyser";
    LiteGraph.registerNodeType("audio/analyser", LGAudioAnalyser);

    //*****************************************************

    function LGAudioGain() {
        //default
        this.properties = {
            gain: 1
        };

        this.audionode = LGAudio.getAudioContext().createGain();
        this.addInput("in", "audio");
        this.addInput("gain", "number");
        this.addOutput("out", "audio");
    }

    LGAudioGain.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudio.createAudioNodeWrapper(LGAudioGain);

    LGAudioGain.title = "Gain";
    LGAudioGain.desc = "Audio gain";
    LiteGraph.registerNodeType("audio/gain", LGAudioGain);

    function LGAudioConvolver() {
        //default
        this.properties = {
            impulse_src: "",
            normalize: true
        };

        this.audionode = LGAudio.getAudioContext().createConvolver();
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudio.createAudioNodeWrapper(LGAudioConvolver);

    LGAudioConvolver.prototype.onRemove = function() {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
    };

    LGAudioConvolver.prototype.onPropertyChanged = function(name, value) {
        if (name == "impulse_src") {
            this.loadImpulse(value);
        } else if (name == "normalize") {
            this.audionode.normalize = value;
        }
    };

    LGAudioConvolver.prototype.onDropFile = function(file) {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
        this._dropped_url = URL.createObjectURL(file);
        this.properties.impulse_src = this._dropped_url;
        this.loadImpulse(this._dropped_url);
    };

    LGAudioConvolver.prototype.loadImpulse = function(url) {
        var that = this;

        //kill previous load
        if (this._request) {
            this._request.abort();
            this._request = null;
        }

        this._impulse_buffer = null;
        this._loading_impulse = false;

        if (!url) {
            return;
        }

        //load new sample
        this._request = LGAudio.loadSound(url, inner);
        this._loading_impulse = true;

        // Decode asynchronously
        function inner(buffer) {
            that._impulse_buffer = buffer;
            that.audionode.buffer = buffer;
            console.log("Impulse signal set");
            that._loading_impulse = false;
        }
    };

    LGAudioConvolver.title = "Convolver";
    LGAudioConvolver.desc = "Convolves the signal (used for reverb)";
    LiteGraph.registerNodeType("audio/convolver", LGAudioConvolver);

    function LGAudioDynamicsCompressor() {
        //default
        this.properties = {
            threshold: -50,
            knee: 40,
            ratio: 12,
            reduction: -20,
            attack: 0,
            release: 0.25
        };

        this.audionode = LGAudio.getAudioContext().createDynamicsCompressor();
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudio.createAudioNodeWrapper(LGAudioDynamicsCompressor);

    LGAudioDynamicsCompressor.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }
        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudioDynamicsCompressor.prototype.onGetInputs = function() {
        return [
            ["threshold", "number"],
            ["knee", "number"],
            ["ratio", "number"],
            ["reduction", "number"],
            ["attack", "number"],
            ["release", "number"]
        ];
    };

    LGAudioDynamicsCompressor.title = "DynamicsCompressor";
    LGAudioDynamicsCompressor.desc = "Dynamics Compressor";
    LiteGraph.registerNodeType(
        "audio/dynamicsCompressor",
        LGAudioDynamicsCompressor
    );

    function LGAudioWaveShaper() {
        //default
        this.properties = {};

        this.audionode = LGAudio.getAudioContext().createWaveShaper();
        this.addInput("in", "audio");
        this.addInput("shape", "waveshape");
        this.addOutput("out", "audio");
    }

    LGAudioWaveShaper.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }
        var v = this.getInputData(1);
        if (v === undefined) {
            return;
        }
        this.audionode.curve = v;
    };

    LGAudioWaveShaper.prototype.setWaveShape = function(shape) {
        this.audionode.curve = shape;
    };

    LGAudio.createAudioNodeWrapper(LGAudioWaveShaper);

    /* disabled till I dont find a way to do a wave shape
LGAudioWaveShaper.title = "WaveShaper";
LGAudioWaveShaper.desc = "Distortion using wave shape";
LiteGraph.registerNodeType("audio/waveShaper", LGAudioWaveShaper);
*/

    function LGAudioMixer() {
        //default
        this.properties = {
            gain1: 0.5,
            gain2: 0.5
        };

        this.audionode = LGAudio.getAudioContext().createGain();

        this.audionode1 = LGAudio.getAudioContext().createGain();
        this.audionode1.gain.value = this.properties.gain1;
        this.audionode2 = LGAudio.getAudioContext().createGain();
        this.audionode2.gain.value = this.properties.gain2;

        this.audionode1.connect(this.audionode);
        this.audionode2.connect(this.audionode);

        this.addInput("in1", "audio");
        this.addInput("in1 gain", "number");
        this.addInput("in2", "audio");
        this.addInput("in2 gain", "number");

        this.addOutput("out", "audio");
    }

    LGAudioMixer.prototype.getAudioNodeInInputSlot = function(slot) {
        if (slot == 0) {
            return this.audionode1;
        } else if (slot == 2) {
            return this.audionode2;
        }
    };

    LGAudioMixer.prototype.onPropertyChanged = function(name, value) {
        if (name == "gain1") {
            this.audionode1.gain.value = value;
        } else if (name == "gain2") {
            this.audionode2.gain.value = value;
        }
    };

    LGAudioMixer.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];

            if (input.link == null || input.type == "audio") {
                continue;
            }

            var v = this.getInputData(i);
            if (v === undefined) {
                continue;
            }

            if (i == 1) {
                this.audionode1.gain.value = v;
            } else if (i == 3) {
                this.audionode2.gain.value = v;
            }
        }
    };

    LGAudio.createAudioNodeWrapper(LGAudioMixer);

    LGAudioMixer.title = "Mixer";
    LGAudioMixer.desc = "Audio mixer";
    LiteGraph.registerNodeType("audio/mixer", LGAudioMixer);

    function LGAudioADSR() {
        //default
        this.properties = {
            A: 0.1,
            D: 0.1,
            S: 0.1,
            R: 0.1
        };

        this.audionode = LGAudio.getAudioContext().createGain();
        this.audionode.gain.value = 0;
        this.addInput("in", "audio");
        this.addInput("gate", "bool");
        this.addOutput("out", "audio");
        this.gate = false;
    }

    LGAudioADSR.prototype.onExecute = function() {
        var audioContext = LGAudio.getAudioContext();
        var now = audioContext.currentTime;
        var node = this.audionode;
        var gain = node.gain;
        var current_gate = this.getInputData(1);

        var A = this.getInputOrProperty("A");
        var D = this.getInputOrProperty("D");
        var S = this.getInputOrProperty("S");
        var R = this.getInputOrProperty("R");

        if (!this.gate && current_gate) {
            gain.cancelScheduledValues(0);
            gain.setValueAtTime(0, now);
            gain.linearRampToValueAtTime(1, now + A);
            gain.linearRampToValueAtTime(S, now + A + D);
        } else if (this.gate && !current_gate) {
            gain.cancelScheduledValues(0);
            gain.setValueAtTime(gain.value, now);
            gain.linearRampToValueAtTime(0, now + R);
        }

        this.gate = current_gate;
    };

    LGAudioADSR.prototype.onGetInputs = function() {
        return [
            ["A", "number"],
            ["D", "number"],
            ["S", "number"],
            ["R", "number"]
        ];
    };

    LGAudio.createAudioNodeWrapper(LGAudioADSR);

    LGAudioADSR.title = "ADSR";
    LGAudioADSR.desc = "Audio envelope";
    LiteGraph.registerNodeType("audio/adsr", LGAudioADSR);

    function LGAudioDelay() {
        //default
        this.properties = {
            delayTime: 0.5
        };

        this.audionode = LGAudio.getAudioContext().createDelay(10);
        this.audionode.delayTime.value = this.properties.delayTime;
        this.addInput("in", "audio");
        this.addInput("time", "number");
        this.addOutput("out", "audio");
    }

    LGAudio.createAudioNodeWrapper(LGAudioDelay);

    LGAudioDelay.prototype.onExecute = function() {
        var v = this.getInputData(1);
        if (v !== undefined) {
            this.audionode.delayTime.value = v;
        }
    };

    LGAudioDelay.title = "Delay";
    LGAudioDelay.desc = "Audio delay";
    LiteGraph.registerNodeType("audio/delay", LGAudioDelay);

    function LGAudioBiquadFilter() {
        //default
        this.properties = {
            frequency: 350,
            detune: 0,
            Q: 1
        };
        this.addProperty("type", "lowpass", "enum", {
            values: [
                "lowpass",
                "highpass",
                "bandpass",
                "lowshelf",
                "highshelf",
                "peaking",
                "notch",
                "allpass"
            ]
        });

        //create node
        this.audionode = LGAudio.getAudioContext().createBiquadFilter();

        //slots
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudioBiquadFilter.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudioBiquadFilter.prototype.onGetInputs = function() {
        return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];
    };

    LGAudio.createAudioNodeWrapper(LGAudioBiquadFilter);

    LGAudioBiquadFilter.title = "BiquadFilter";
    LGAudioBiquadFilter.desc = "Audio filter";
    LiteGraph.registerNodeType("audio/biquadfilter", LGAudioBiquadFilter);

    function LGAudioOscillatorNode() {
        //default
        this.properties = {
            frequency: 440,
            detune: 0,
            type: "sine"
        };
        this.addProperty("type", "sine", "enum", {
            values: ["sine", "square", "sawtooth", "triangle", "custom"]
        });

        //create node
        this.audionode = LGAudio.getAudioContext().createOscillator();

        //slots
        this.addOutput("out", "audio");
    }

    LGAudioOscillatorNode.prototype.onStart = function() {
        if (!this.audionode.started) {
            this.audionode.started = true;
            try {
                this.audionode.start();
            } catch (err) {}
        }
    };

    LGAudioOscillatorNode.prototype.onStop = function() {
        if (this.audionode.started) {
            this.audionode.started = false;
            this.audionode.stop();
        }
    };

    LGAudioOscillatorNode.prototype.onPause = function() {
        this.onStop();
    };

    LGAudioOscillatorNode.prototype.onUnpause = function() {
        this.onStart();
    };

    LGAudioOscillatorNode.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 0; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudioOscillatorNode.prototype.onGetInputs = function() {
        return [
            ["frequency", "number"],
            ["detune", "number"],
            ["type", "string"]
        ];
    };

    LGAudio.createAudioNodeWrapper(LGAudioOscillatorNode);

    LGAudioOscillatorNode.title = "Oscillator";
    LGAudioOscillatorNode.desc = "Oscillator";
    LiteGraph.registerNodeType("audio/oscillator", LGAudioOscillatorNode);

    //*****************************************************

    //EXTRA

    function LGAudioVisualization() {
        this.properties = {
            continuous: true,
            mark: -1
        };

        this.addInput("data", "array");
        this.addInput("mark", "number");
        this.size = [300, 200];
        this._last_buffer = null;
    }

    LGAudioVisualization.prototype.onExecute = function() {
        this._last_buffer = this.getInputData(0);
        var v = this.getInputData(1);
        if (v !== undefined) {
            this.properties.mark = v;
        }
        this.setDirtyCanvas(true, false);
    };

    LGAudioVisualization.prototype.onDrawForeground = function(ctx) {
        if (!this._last_buffer) {
            return;
        }

        var buffer = this._last_buffer;

        //delta represents how many samples we advance per pixel
        var delta = buffer.length / this.size[0];
        var h = this.size[1];

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, this.size[0], this.size[1]);
        ctx.strokeStyle = "white";
        ctx.beginPath();
        var x = 0;

        if (this.properties.continuous) {
            ctx.moveTo(x, h);
            for (var i = 0; i < buffer.length; i += delta) {
                ctx.lineTo(x, h - (buffer[i | 0] / 255) * h);
                x++;
            }
        } else {
            for (var i = 0; i < buffer.length; i += delta) {
                ctx.moveTo(x + 0.5, h);
                ctx.lineTo(x + 0.5, h - (buffer[i | 0] / 255) * h);
                x++;
            }
        }
        ctx.stroke();

        if (this.properties.mark >= 0) {
            var samplerate = LGAudio.getAudioContext().sampleRate;
            var binfreq = samplerate / buffer.length;
            var x = (2 * (this.properties.mark / binfreq)) / delta;
            if (x >= this.size[0]) {
                x = this.size[0] - 1;
            }
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.moveTo(x, h);
            ctx.lineTo(x, 0);
            ctx.stroke();
        }
    };

    LGAudioVisualization.title = "Visualization";
    LGAudioVisualization.desc = "Audio Visualization";
    LiteGraph.registerNodeType("audio/visualization", LGAudioVisualization);

    function LGAudioBandSignal() {
        //default
        this.properties = {
            band: 440,
            amplitude: 1
        };

        this.addInput("freqs", "array");
        this.addOutput("signal", "number");
    }

    LGAudioBandSignal.prototype.onExecute = function() {
        this._freqs = this.getInputData(0);
        if (!this._freqs) {
            return;
        }

        var band = this.properties.band;
        var v = this.getInputData(1);
        if (v !== undefined) {
            band = v;
        }

        var samplerate = LGAudio.getAudioContext().sampleRate;
        var binfreq = samplerate / this._freqs.length;
        var index = 2 * (band / binfreq);
        var v = 0;
        if (index < 0) {
            v = this._freqs[0];
        }
        if (index >= this._freqs.length) {
            v = this._freqs[this._freqs.length - 1];
        } else {
            var pos = index | 0;
            var v0 = this._freqs[pos];
            var v1 = this._freqs[pos + 1];
            var f = index - pos;
            v = v0 * (1 - f) + v1 * f;
        }

        this.setOutputData(0, (v / 255) * this.properties.amplitude);
    };

    LGAudioBandSignal.prototype.onGetInputs = function() {
        return [["band", "number"]];
    };

    LGAudioBandSignal.title = "Signal";
    LGAudioBandSignal.desc = "extract the signal of some frequency";
    LiteGraph.registerNodeType("audio/signal", LGAudioBandSignal);

    function LGAudioScript() {
        if (!LGAudioScript.default_code) {
            var code = LGAudioScript.default_function.toString();
            var index = code.indexOf("{") + 1;
            var index2 = code.lastIndexOf("}");
            LGAudioScript.default_code = code.substr(index, index2 - index);
        }

        //default
        this.properties = {
            code: LGAudioScript.default_code
        };

        //create node
        var ctx = LGAudio.getAudioContext();
        if (ctx.createScriptProcessor) {
            this.audionode = ctx.createScriptProcessor(4096, 1, 1);
        }
        //buffer size, input channels, output channels
        else {
            console.warn("ScriptProcessorNode deprecated");
            this.audionode = ctx.createGain(); //bypass audio
        }

        this.processCode();
        if (!LGAudioScript._bypass_function) {
            LGAudioScript._bypass_function = this.audionode.onaudioprocess;
        }

        //slots
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudioScript.prototype.onAdded = function(graph) {
        if (graph.status == LGraph.STATUS_RUNNING) {
            this.audionode.onaudioprocess = this._callback;
        }
    };

    LGAudioScript["@code"] = { widget: "code", type: "code" };

    LGAudioScript.prototype.onStart = function() {
        this.audionode.onaudioprocess = this._callback;
    };

    LGAudioScript.prototype.onStop = function() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    };

    LGAudioScript.prototype.onPause = function() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    };

    LGAudioScript.prototype.onUnpause = function() {
        this.audionode.onaudioprocess = this._callback;
    };

    LGAudioScript.prototype.onExecute = function() {
        //nothing! because we need an onExecute to receive onStart... fix that
    };

    LGAudioScript.prototype.onRemoved = function() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    };

    LGAudioScript.prototype.processCode = function() {
        try {
            var func = new Function("properties", this.properties.code);
            this._script = new func(this.properties);
            this._old_code = this.properties.code;
            this._callback = this._script.onaudioprocess;
        } catch (err) {
            console.error("Error in onaudioprocess code", err);
            this._callback = LGAudioScript._bypass_function;
            this.audionode.onaudioprocess = this._callback;
        }
    };

    LGAudioScript.prototype.onPropertyChanged = function(name, value) {
        if (name == "code") {
            this.properties.code = value;
            this.processCode();
            if (this.graph && this.graph.status == LGraph.STATUS_RUNNING) {
                this.audionode.onaudioprocess = this._callback;
            }
        }
    };

    LGAudioScript.default_function = function() {
        this.onaudioprocess = function(audioProcessingEvent) {
            // The input buffer is the song we loaded earlier
            var inputBuffer = audioProcessingEvent.inputBuffer;

            // The output buffer contains the samples that will be modified and played
            var outputBuffer = audioProcessingEvent.outputBuffer;

            // Loop through the output channels (in this case there is only one)
            for (
                var channel = 0;
                channel < outputBuffer.numberOfChannels;
                channel++
            ) {
                var inputData = inputBuffer.getChannelData(channel);
                var outputData = outputBuffer.getChannelData(channel);

                // Loop through the 4096 samples
                for (var sample = 0; sample < inputBuffer.length; sample++) {
                    // make output equal to the same as the input
                    outputData[sample] = inputData[sample];
                }
            }
        };
    };

    LGAudio.createAudioNodeWrapper(LGAudioScript);

    LGAudioScript.title = "Script";
    LGAudioScript.desc = "apply script to signal";
    LiteGraph.registerNodeType("audio/script", LGAudioScript);

    function LGAudioDestination() {
        this.audionode = LGAudio.getAudioContext().destination;
        this.addInput("in", "audio");
    }

    LGAudioDestination.title = "Destination";
    LGAudioDestination.desc = "Audio output";
    LiteGraph.registerNodeType("audio/destination", LGAudioDestination);
})(this);

//event related nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    function LGWebSocket() {
        this.size = [60, 20];
        this.addInput("send", LiteGraph.ACTION);
        this.addOutput("received", LiteGraph.EVENT);
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.properties = {
            url: "",
            room: "lgraph", //allows to filter messages,
            only_send_changes: true
        };
        this._ws = null;
        this._last_sent_data = [];
        this._last_received_data = [];
    }

    LGWebSocket.title = "WebSocket";
    LGWebSocket.desc = "Send data through a websocket";

    LGWebSocket.prototype.onPropertyChanged = function(name, value) {
        if (name == "url") {
            this.connectSocket();
        }
    };

    LGWebSocket.prototype.onExecute = function() {
        if (!this._ws && this.properties.url) {
            this.connectSocket();
        }

        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {
            return;
        }

        var room = this.properties.room;
        var only_changes = this.properties.only_send_changes;

        for (var i = 1; i < this.inputs.length; ++i) {
            var data = this.getInputData(i);
            if (data == null) {
                continue;
            }
            var json;
            try {
                json = JSON.stringify({
                    type: 0,
                    room: room,
                    channel: i,
                    data: data
                });
            } catch (err) {
                continue;
            }
            if (only_changes && this._last_sent_data[i] == json) {
                continue;
            }

            this._last_sent_data[i] = json;
            this._ws.send(json);
        }

        for (var i = 1; i < this.outputs.length; ++i) {
            this.setOutputData(i, this._last_received_data[i]);
        }

        if (this.boxcolor == "#AFA") {
            this.boxcolor = "#6C6";
        }
    };

    LGWebSocket.prototype.connectSocket = function() {
        var that = this;
        var url = this.properties.url;
        if (url.substr(0, 2) != "ws") {
            url = "ws://" + url;
        }
        this._ws = new WebSocket(url);
        this._ws.onopen = function() {
            console.log("ready");
            that.boxcolor = "#6C6";
        };
        this._ws.onmessage = function(e) {
            that.boxcolor = "#AFA";
            var data = JSON.parse(e.data);
            if (data.room && data.room != that.properties.room) {
                return;
            }
            if (data.type == 1) {
                if (
                    data.data.object_class &&
                    LiteGraph[data.data.object_class]
                ) {
                    var obj = null;
                    try {
                        obj = new LiteGraph[data.data.object_class](data.data);
                        that.triggerSlot(0, obj);
                    } catch (err) {
                        return;
                    }
                } else {
                    that.triggerSlot(0, data.data);
                }
            } else {
                that._last_received_data[data.channel || 0] = data.data;
            }
        };
        this._ws.onerror = function(e) {
            console.log("couldnt connect to websocket");
            that.boxcolor = "#E88";
        };
        this._ws.onclose = function(e) {
            console.log("connection closed");
            that.boxcolor = "#000";
        };
    };

    LGWebSocket.prototype.send = function(data) {
        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {
            return;
        }
        this._ws.send(JSON.stringify({ type: 1, msg: data }));
    };

    LGWebSocket.prototype.onAction = function(action, param) {
        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {
            return;
        }
        this._ws.send({
            type: 1,
            room: this.properties.room,
            action: action,
            data: param
        });
    };

    LGWebSocket.prototype.onGetInputs = function() {
        return [["in", 0]];
    };

    LGWebSocket.prototype.onGetOutputs = function() {
        return [["out", 0]];
    };

    LiteGraph.registerNodeType("network/websocket", LGWebSocket);

    //It is like a websocket but using the SillyServer.js server that bounces packets back to all clients connected:
    //For more information: https://github.com/jagenjo/SillyServer.js

    function LGSillyClient() {
        //this.size = [60,20];
        this.room_widget = this.addWidget(
            "text",
            "Room",
            "lgraph",
            this.setRoom.bind(this)
        );
        this.addWidget(
            "button",
            "Reconnect",
            null,
            this.connectSocket.bind(this)
        );

        this.addInput("send", LiteGraph.ACTION);
        this.addOutput("received", LiteGraph.EVENT);
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.properties = {
            url: "tamats.com:55000",
            room: "lgraph",
            only_send_changes: true
        };

        this._server = null;
        this.connectSocket();
        this._last_sent_data = [];
        this._last_received_data = [];

		if(typeof(SillyClient) == "undefined")
			console.warn("remember to add SillyClient.js to your project: https://tamats.com/projects/sillyserver/src/sillyclient.js");
    }

    LGSillyClient.title = "SillyClient";
    LGSillyClient.desc = "Connects to SillyServer to broadcast messages";

    LGSillyClient.prototype.onPropertyChanged = function(name, value) {
        if (name == "room") {
            this.room_widget.value = value;
        }
        this.connectSocket();
    };

    LGSillyClient.prototype.setRoom = function(room_name) {
        this.properties.room = room_name;
        this.room_widget.value = room_name;
        this.connectSocket();
    };

    //force label names
    LGSillyClient.prototype.onDrawForeground = function() {
        for (var i = 1; i < this.inputs.length; ++i) {
            var slot = this.inputs[i];
            slot.label = "in_" + i;
        }
        for (var i = 1; i < this.outputs.length; ++i) {
            var slot = this.outputs[i];
            slot.label = "out_" + i;
        }
    };

    LGSillyClient.prototype.onExecute = function() {
        if (!this._server || !this._server.is_connected) {
            return;
        }

        var only_send_changes = this.properties.only_send_changes;

        for (var i = 1; i < this.inputs.length; ++i) {
            var data = this.getInputData(i);
			var prev_data = this._last_sent_data[i];
            if (data != null) {
                if (only_send_changes)
				{	
					var is_equal = true;
					if( data && data.length && prev_data && prev_data.length == data.length && data.constructor !== String)
					{
						for(var j = 0; j < data.length; ++j)
							if( prev_data[j] != data[j] )
							{
								is_equal = false;
								break;
							}
					}
					else if(this._last_sent_data[i] != data)
						is_equal = false;
					if(is_equal)
							continue;
                }
                this._server.sendMessage({ type: 0, channel: i, data: data });
				if( data.length && data.constructor !== String )
				{
					if( this._last_sent_data[i] )
					{
						this._last_sent_data[i].length = data.length;
						for(var j = 0; j < data.length; ++j)
							this._last_sent_data[i][j] = data[j];
					}
					else //create
					{
						if(data.constructor === Array)
							this._last_sent_data[i] = data.concat();
						else
							this._last_sent_data[i] = new data.constructor( data );
					}
				}
				else
	                this._last_sent_data[i] = data; //should be cloned
            }
        }

        for (var i = 1; i < this.outputs.length; ++i) {
            this.setOutputData(i, this._last_received_data[i]);
        }

        if (this.boxcolor == "#AFA") {
            this.boxcolor = "#6C6";
        }
    };

    LGSillyClient.prototype.connectSocket = function() {
        var that = this;
        if (typeof SillyClient == "undefined") {
            if (!this._error) {
                console.error(
                    "SillyClient node cannot be used, you must include SillyServer.js"
                );
            }
            this._error = true;
            return;
        }

        this._server = new SillyClient();
        this._server.on_ready = function() {
            console.log("ready");
            that.boxcolor = "#6C6";
        };
        this._server.on_message = function(id, msg) {
            var data = null;
            try {
                data = JSON.parse(msg);
            } catch (err) {
                return;
            }

            if (data.type == 1) {
                //EVENT slot
                if (
                    data.data.object_class &&
                    LiteGraph[data.data.object_class]
                ) {
                    var obj = null;
                    try {
                        obj = new LiteGraph[data.data.object_class](data.data);
                        that.triggerSlot(0, obj);
                    } catch (err) {
                        return;
                    }
                } else {
                    that.triggerSlot(0, data.data);
                }
            } //for FLOW slots
            else {
                that._last_received_data[data.channel || 0] = data.data;
            }
            that.boxcolor = "#AFA";
        };
        this._server.on_error = function(e) {
            console.log("couldnt connect to websocket");
            that.boxcolor = "#E88";
        };
        this._server.on_close = function(e) {
            console.log("connection closed");
            that.boxcolor = "#000";
        };

        if (this.properties.url && this.properties.room) {
            try {
                this._server.connect(this.properties.url, this.properties.room);
            } catch (err) {
                console.error("SillyServer error: " + err);
                this._server = null;
                return;
            }
            this._final_url = this.properties.url + "/" + this.properties.room;
        }
    };

    LGSillyClient.prototype.send = function(data) {
        if (!this._server || !this._server.is_connected) {
            return;
        }
        this._server.sendMessage({ type: 1, data: data });
    };

    LGSillyClient.prototype.onAction = function(action, param) {
        if (!this._server || !this._server.is_connected) {
            return;
        }
        this._server.sendMessage({ type: 1, action: action, data: param });
    };

    LGSillyClient.prototype.onGetInputs = function() {
        return [["in", 0]];
    };

    LGSillyClient.prototype.onGetOutputs = function() {
        return [["out", 0]];
    };

    LiteGraph.registerNodeType("network/sillyclient", LGSillyClient);
})(this);



/***/ }),

/***/ "./src/main/UI/GraphManager.ts":
/*!*************************************!*\
  !*** ./src/main/UI/GraphManager.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphManager": () => (/* binding */ GraphManager)
/* harmony export */ });
/* harmony import */ var deepslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepslate */ "./node_modules/deepslate/dist/deepslate.esm.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/density_function_output */ "./src/main/nodes/density_function_output.ts");
/* harmony import */ var _nodes_register__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nodes/register */ "./src/main/nodes/register.ts");
/* harmony import */ var _MenuManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MenuManager */ "./src/main/UI/MenuManager.ts");





var GraphManager = /** @class */ (function () {
    function GraphManager() {
    }
    GraphManager.init = function () {
        var _this = this;
        litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.clearRegisteredTypes(); // don't use default node types
        (0,_nodes_register__WEBPACK_IMPORTED_MODULE_3__.registerNodes)();
        this.graph = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraph();
        this.canvas = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraphCanvas("#mycanvas", this.graph);
        this.canvas.autoresize = true;
        this.canvas.canvas.onresize = function () {
            _this.canvas.dirty_canvas = true;
        };
        this.canvas.onDrawLinkTooltip = function (ctx, link, canvas) {
            return true;
        };
        this.canvas.onShowNodePanel = function (n) { };
        this.output_node = new _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__.DensityFunctionOutput(); // not registered as only one exists
        this.output_node.pos = [900, 400];
        this.graph.add(this.output_node);
        this.graph.start();
        document.onkeydown = function (ev) {
            if ((ev.ctrlKey || ev.metaKey) && ev.key === "s") {
                ev.preventDefault();
                _MenuManager__WEBPACK_IMPORTED_MODULE_4__.MenuManager.save();
            }
            else {
                _this.canvas.processKey(ev);
            }
        };
    };
    GraphManager.clear = function () {
        this.graph.clear();
        this.named_nodes = {};
        this.output_node = new _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__.DensityFunctionOutput(); // not registered as only one exists
        this.output_node.pos = [900, 400];
        this.graph.add(this.output_node);
        this.graph.runStep();
    };
    GraphManager.getOutput = function () {
        var _a;
        this.graph.runStep();
        return (_a = this.output_node.getInputDataByName("result")) !== null && _a !== void 0 ? _a : { json: {}, error: true };
    };
    GraphManager.loadJSON = function (json) {
        var _this = this;
        if (json.noise_router !== undefined) {
            var menu_info = [];
            Object.keys(json.noise_router).forEach(function (element) { return menu_info.push({
                content: element,
                callback: function () {
                    _this.loadJSON(json.noise_router[element]);
                    _MenuManager__WEBPACK_IMPORTED_MODULE_4__.MenuManager.fileName = element + ".json";
                }
            }); });
            var options = { top: 200, left: 200 };
            var e = console.error;
            console.error = function () { };
            var menu = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ContextMenu(menu_info, options, this.canvas.getCanvasWindow());
            console.error = e;
            return false;
        }
        else {
            this.graph.clear();
            this.named_nodes = {};
            this.output_node = new _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__.DensityFunctionOutput(); // not registered as only one exists
            this.graph.add(this.output_node);
            var _a = this.createNodeFromJson(json, [900 - 250, 400]), n = _a[0], y = _a[1];
            n.connect(0, this.output_node, 0);
            this.output_node.pos = [900, y / 2];
            this.graph.runStep();
            _MenuManager__WEBPACK_IMPORTED_MODULE_4__.MenuManager.setEdited(false);
            return true;
        }
    };
    GraphManager.createNodeFromJson = function (json, pos) {
        var _a, _b;
        if (typeof json === "string") {
            if (json in this.named_nodes && this.named_nodes[json].pos[0] <= pos[0] + 400) {
                return [this.named_nodes[json], pos[1]];
            }
            else {
                var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/named");
                node.properties.id = json;
                node.updateWidgets();
                node.pos = pos;
                this.graph.add(node);
                node.collapse(false);
                this.named_nodes[json] = node;
                return [node, pos[1] + 150];
            }
        }
        else if (typeof json === "number") {
            var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/constant");
            node.properties.value = json;
            node.updateWidgets();
            node.pos = pos;
            this.graph.add(node);
            node.collapse(false);
            return [node, pos[1] + 150];
        }
        else if (json.type === "minecraft:spline") {
            var y = pos[1];
            var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/spline");
            node.properties.min_value = json.min_value;
            node.properties.max_value = json.max_value;
            var locations = [];
            var values = [];
            var derivatives = [];
            var _loop_1 = function (point) {
                if (typeof point.value !== "number") {
                    alert("Multidimenional Splines are not supported (yet)");
                    throw Error("Multidimenional Splines are not supported (yet)");
                }
                locations.push(point.location);
                values.push(function () { return point.value; });
                derivatives.push(point.derivative);
            };
            for (var _i = 0, _c = json.spline.points; _i < _c.length; _i++) {
                var point = _c[_i];
                _loop_1(point);
            }
            node.splineWidget.value = new deepslate__WEBPACK_IMPORTED_MODULE_0__.Spline("spine", function (c) { return c; }, locations, values, derivatives);
            node.splineWidget.min_input = locations[0] - 0.1;
            node.splineWidget.max_input = locations[locations.length - 1] + 0.1;
            node.updateWidgets();
            var n;
            _a = this.createNodeFromJson(json.spline.coordinate, [pos[0] - 250, y]), n = _a[0], y = _a[1];
            n.connect(0, node, "coordinate");
            node.pos = [pos[0], (pos[1] + y - 150) / 2];
            this.graph.add(node);
            return [node, y];
        }
        else if (json.type) {
            var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/" + (json.type.replace("minecraft:", "")));
            var y = pos[1];
            if (node) {
                for (var property in node.properties) {
                    if (json[property] !== undefined) {
                        node.properties[property] = json[property];
                    }
                    else {
                        console.warn("missing property " + property);
                    }
                }
                node.updateWidgets();
                for (var i = 0; i < node.input_names.length; i++) {
                    var input = node.input_names[i];
                    if (json[input] !== undefined) {
                        var n;
                        _b = this.createNodeFromJson(json[input], [pos[0] - 250, y]), n = _b[0], y = _b[1];
                        n.connect(0, node, input);
                    }
                    else {
                        console.warn("missing density function " + input);
                    }
                }
            }
            node.pos = [pos[0], (pos[1] + y - 150) / 2];
            this.graph.add(node);
            return [node, y];
        }
        else {
            throw new Error("could not load density function " + JSON.stringify(json));
        }
    };
    return GraphManager;
}());



/***/ }),

/***/ "./src/main/UI/MenuManager.ts":
/*!************************************!*\
  !*** ./src/main/UI/MenuManager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MenuManager": () => (/* binding */ MenuManager)
/* harmony export */ });
/* harmony import */ var _GraphManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphManager */ "./src/main/UI/GraphManager.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var MenuManager = /** @class */ (function () {
    function MenuManager() {
    }
    MenuManager.addHandlers = function () {
        var _this = this;
        this.save_button = document.getElementById("menu-button-save");
        document.getElementById("menu-button-new").onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.edited && !confirm("You have unsaved changes, continue?")) {
                    return [2 /*return*/];
                }
                _GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.clear();
                this.fileHandle = undefined;
                this.fileName = "density_function.json";
                this.save_button.classList.add("disabled");
                this.edited = false;
                return [2 /*return*/];
            });
        }); };
        document.getElementById("menu-button-open").onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, file, jsonString, input;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.edited && !confirm("You have unsaved changes, continue?")) {
                            return [2 /*return*/];
                        }
                        if (!("showOpenFilePicker" in window)) return [3 /*break*/, 4];
                        _a = this;
                        return [4 /*yield*/, window.showOpenFilePicker({
                                types: [
                                    {
                                        description: "All JSON files",
                                        accept: {
                                            "application/json": [".json"]
                                        }
                                    }
                                ]
                            })];
                    case 1:
                        _a.fileHandle = (_b.sent())[0];
                        return [4 /*yield*/, this.fileHandle.getFile()];
                    case 2:
                        file = _b.sent();
                        return [4 /*yield*/, file.text()];
                    case 3:
                        jsonString = _b.sent();
                        if (_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.loadJSON(JSON.parse(jsonString))) {
                            this.fileName = this.fileHandle.name;
                            this.save_button.classList.remove("disabled");
                        }
                        else {
                            this.fileHandle = undefined;
                            this.fileName = "density_function.json";
                            this.save_button.classList.add("disabled");
                        }
                        this.edited = false;
                        return [3 /*break*/, 5];
                    case 4:
                        input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.onchange = function (evt) {
                            var file = evt.target.files[0];
                            var reader = new FileReader();
                            reader.readAsText(file, 'UTF-8');
                            reader.onload = function (evt) {
                                var jsonString = evt.target.result;
                                _this.fileHandle = undefined;
                                if (_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.loadJSON(JSON.parse(jsonString))) {
                                    _this.fileName = file.name;
                                }
                                else {
                                    _this.fileName = "density_function.json";
                                }
                                _this.edited = false;
                            };
                        };
                        input.click();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        document.getElementById("menu-button-save-as").onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.saveAs()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        this.save_button.onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.save()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    MenuManager.getJsonString = function () {
        var output = _GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.getOutput();
        if (output.error && !confirm("Some nodes have unconnected inputs, the resulting JSON will be invalid. Continue?")) {
            return undefined;
        }
        else {
            var jsonString = JSON.stringify(output.json, null, 2);
            return jsonString;
        }
    };
    MenuManager.save = function () {
        return __awaiter(this, void 0, void 0, function () {
            var jsonString, writable;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.fileHandle) return [3 /*break*/, 4];
                        jsonString = this.getJsonString();
                        if (jsonString === undefined)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.fileHandle.createWritable()];
                    case 1:
                        writable = _a.sent();
                        return [4 /*yield*/, writable.write(jsonString)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, writable.close()];
                    case 3:
                        _a.sent();
                        this.edited = false;
                        return [3 /*break*/, 5];
                    case 4:
                        this.saveAs();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    MenuManager.saveAs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var jsonString, _a, writable, bb, a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        jsonString = this.getJsonString();
                        if (jsonString === undefined)
                            return [2 /*return*/];
                        if (!("showSaveFilePicker" in window)) return [3 /*break*/, 5];
                        _a = this;
                        return [4 /*yield*/, window.showSaveFilePicker({ types: [
                                    {
                                        description: "All JSON files",
                                        accept: {
                                            "application/json": [".json"]
                                        }
                                    }
                                ], suggestedName: this.fileName
                            })];
                    case 1:
                        _a.fileHandle = _b.sent();
                        this.fileName = this.fileHandle.name;
                        return [4 /*yield*/, this.fileHandle.createWritable()];
                    case 2:
                        writable = _b.sent();
                        return [4 /*yield*/, writable.write(jsonString)];
                    case 3:
                        _b.sent();
                        return [4 /*yield*/, writable.close()];
                    case 4:
                        _b.sent();
                        this.edited = false;
                        this.save_button.classList.remove("disabled");
                        return [3 /*break*/, 6];
                    case 5:
                        bb = new Blob([jsonString], { type: 'text/plain' });
                        a = document.createElement('a');
                        a.download = this.fileName;
                        a.href = window.URL.createObjectURL(bb);
                        a.click();
                        this.edited = false;
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    MenuManager.setEdited = function (force) {
        if (force === void 0) { force = true; }
        this.edited = force;
    };
    MenuManager.fileName = "density_function.json";
    MenuManager.edited = false;
    return MenuManager;
}());



/***/ }),

/***/ "./src/main/nodes/LGraphNodeFixed.ts":
/*!*******************************************!*\
  !*** ./src/main/nodes/LGraphNodeFixed.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LGraphNodeFixed": () => (/* binding */ LGraphNodeFixed)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/MenuManager */ "./src/main/UI/MenuManager.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var LGraphNodeFixed = /** @class */ (function (_super) {
    __extends(LGraphNodeFixed, _super);
    function LGraphNodeFixed() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LGraphNodeFixed.prototype.onPropertyChanged = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
        return false;
    };
    LGraphNodeFixed.prototype.onConnectionsChange = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
    };
    LGraphNodeFixed.prototype.onAdded = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
    };
    LGraphNodeFixed.prototype.onRemoved = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
    };
    LGraphNodeFixed.prototype.getMenuOptions = function (onExecute) {
        return [];
    };
    LGraphNodeFixed.prototype.updateWidgets = function () { };
    return LGraphNodeFixed;
}(litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode));



/***/ }),

/***/ "./src/main/nodes/constant_density_function.ts":
/*!*****************************************************!*\
  !*** ./src/main/nodes/constant_density_function.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstantDensityFunction": () => (/* binding */ ConstantDensityFunction)
/* harmony export */ });
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ConstantDensityFunction = /** @class */ (function (_super) {
    __extends(ConstantDensityFunction, _super);
    function ConstantDensityFunction() {
        var _this = _super.call(this) || this;
        var output = _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.addProperty("value", 0, "number");
        _this.wdgt = _this.addWidget("number", "Value", 0, function (value) { _this.properties.value = value; });
        _this.title = "Constant";
        _this.color = "#000033";
        return _this;
    }
    ConstantDensityFunction.prototype.updateWidgets = function () {
        this.wdgt.value = this.properties.value;
    };
    ConstantDensityFunction.prototype.getTitle = function () {
        if (this.flags.collapsed) {
            return this.properties.value;
        }
        return this.title;
    };
    ;
    ConstantDensityFunction.prototype.onExecute = function () {
        this.setOutputData(0, {
            json: this.properties.value,
            error: false
        });
    };
    ConstantDensityFunction.title = "constant";
    return ConstantDensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/density_function.ts":
/*!********************************************!*\
  !*** ./src/main/nodes/density_function.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DensityFunction": () => (/* binding */ DensityFunction)
/* harmony export */ });
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var spline_values = ["offset", "factor", "jaggedness"];
var sampler_types = ["type_1", "type_2"];
var DensityFunction = /** @class */ (function (_super) {
    __extends(DensityFunction, _super);
    function DensityFunction(name, args) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.wdgs = {};
        _this.input_names = [];
        args.forEach(function (type, argument) {
            if (type === "densityFunction") {
                _this.addInput(argument, "densityFunction", { label: argument, locked: true, nameLocked: true });
                _this.input_names.push(argument);
            }
            else if (type === "number") {
                _this.addProperty(argument, 0, "number");
                _this.wdgs[argument] = _this.addWidget("number", argument, 0, function (value) { _this.properties[argument] = value; });
            }
            else if (type === "spline") {
                _this.addProperty(argument, 0, "string");
                _this.wdgs[argument] = _this.addWidget("combo", argument, "offset", function (value) { _this.properties[argument] = value; }, { values: spline_values });
            }
            else if (type === "noise") {
                _this.addProperty(argument, 0, "string");
                _this.wdgs[argument] = _this.addWidget("text", argument, "minecraft:", function (value) { _this.properties[argument] = value; });
            }
            else if (type === "sampler_type") {
                _this.addProperty(argument, 0, "string");
                _this.wdgs[argument] = _this.addWidget("combo", argument, "type_1", function (value) { _this.properties[argument] = value; }, { values: sampler_types });
            }
        });
        _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.title = name.replace("minecraft:", "");
        _this.color = _this.inputs.length > 0 ? "#330000" : "#000033";
        return _this;
    }
    DensityFunction.prototype.updateWidgets = function () {
        for (var property in this.properties) {
            this.wdgs[property].value = this.properties[property];
        }
    };
    DensityFunction.prototype.onConnectionsChange = function () {
        this.color = this.inputs.filter(function (i) { return !i.link; }).length > 0 ? "#330000" : "#000033";
    };
    DensityFunction.prototype.onExecute = function () {
        var _this = this;
        this.onConnectionsChange();
        var inputs = {};
        var error = false;
        var input_has_error = false;
        this.input_names.forEach(function (input) {
            var i = _this.getInputDataByName(input);
            if (i === undefined) {
                error = true;
            }
            else {
                inputs[input] = i.json;
                input_has_error || (input_has_error = i.error);
            }
        });
        this.setOutputData(0, {
            json: __assign(__assign({ type: this.name }, this.properties), inputs),
            error: error || input_has_error
        });
    };
    return DensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/density_function_output.ts":
/*!***************************************************!*\
  !*** ./src/main/nodes/density_function_output.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DensityFunctionOutput": () => (/* binding */ DensityFunctionOutput)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var DensityFunctionOutput = /** @class */ (function (_super) {
    __extends(DensityFunctionOutput, _super);
    //static removable = false
    function DensityFunctionOutput() {
        var _this = _super.call(this) || this;
        _this.title = "Output";
        _this.color = "#330000";
        _this.addInput("result", "densityFunction", { label: "result", locked: true, nameLocked: true });
        _this.removable = false;
        _this.clonable = false;
        return _this;
    }
    DensityFunctionOutput.prototype.onConnectionsChange = function () {
        console.log("test");
        this.color = !this.inputs[0].link ? "#330000" : "#000033";
    };
    DensityFunctionOutput.prototype.onExecute = function () {
    };
    DensityFunctionOutput.prototype.getMenuOptions = function (onExecute) {
        return [];
    };
    DensityFunctionOutput.title = "Output";
    return DensityFunctionOutput;
}(litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode));



/***/ }),

/***/ "./src/main/nodes/density_function_spline.ts":
/*!***************************************************!*\
  !*** ./src/main/nodes/density_function_spline.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SplineDensityFunction": () => (/* binding */ SplineDensityFunction)
/* harmony export */ });
/* harmony import */ var _widgets_SplineWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../widgets/SplineWidget */ "./src/main/widgets/SplineWidget.ts");
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var spline_values = ["offset", "factor", "jaggedness"];
var sampler_types = ["type_1", "type_2"];
var SplineDensityFunction = /** @class */ (function (_super) {
    __extends(SplineDensityFunction, _super);
    function SplineDensityFunction() {
        var _this = _super.call(this) || this;
        _this.wdgs = {};
        _this.addInput("coordinate", "densityFunction", { label: "coordinate", locked: true, nameLocked: true });
        _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.splineWidget = _this.addCustomWidget(new _widgets_SplineWidget__WEBPACK_IMPORTED_MODULE_0__.SplineWidget());
        _this.addProperty("min_value", -1, "number");
        _this.wdgs.min_value = _this.addWidget("number", "min_value", -1, function (value) {
            _this.properties.min_value = value;
            _this.splineWidget.min_value = value;
        });
        _this.addProperty("max_value", 1, "number");
        _this.wdgs.max_value = _this.addWidget("number", "max_value", 1, function (value) {
            _this.properties.max_value = value;
            _this.splineWidget.max_value = value;
        });
        _this.title = "spline";
        _this.color = "#330000";
        return _this;
    }
    SplineDensityFunction.prototype.updateWidgets = function () {
        this.wdgs.min_value.value = this.properties.min_value;
        this.wdgs.max_value.value = this.properties.max_value;
        this.splineWidget.min_value = this.properties.min_value;
        this.splineWidget.max_value = this.properties.max_value;
    };
    SplineDensityFunction.prototype.onConnectionsChange = function () {
        this.color = !this.inputs[0].link ? "#330000" : "#000033";
    };
    SplineDensityFunction.prototype.onExecute = function () {
        var points = [];
        for (var i = 0; i < this.splineWidget.value.locations.length; i++) {
            points.push({
                location: this.splineWidget.value.locations[i],
                value: this.splineWidget.value.values[i](0),
                derivative: this.splineWidget.value.derivatives[i]
            });
        }
        var input = this.getInputDataByName("coordinate");
        var error = (input === undefined || input.error);
        this.setOutputData(0, {
            json: {
                type: "minecraft:spline",
                min_value: this.properties.min_value,
                max_value: this.properties.max_value,
                spline: {
                    coordinate: input.json,
                    points: points
                }
            },
            error: error
        });
    };
    SplineDensityFunction.title = "spline";
    return SplineDensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_1__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/named_density_function.ts":
/*!**************************************************!*\
  !*** ./src/main/nodes/named_density_function.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NamedDensityFunction": () => (/* binding */ NamedDensityFunction)
/* harmony export */ });
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var NamedDensityFunction = /** @class */ (function (_super) {
    __extends(NamedDensityFunction, _super);
    function NamedDensityFunction() {
        var _this = _super.call(this) || this;
        _this.getTitle = function () {
            if (this.flags.collapsed) {
                var id = this.properties.id;
                if (id.length > 20) {
                    id = id.substring(id.lastIndexOf("/") + 1);
                }
                return id;
            }
            return this.title;
        };
        _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.addProperty("id", "", "string");
        _this.wdgt = _this.addWidget("text", "Id", "", function (value) { _this.properties.id = value; });
        _this.title = "Named Density Function";
        _this.color = "#003300";
        return _this;
    }
    NamedDensityFunction.prototype.updateWidgets = function () {
        this.wdgt.value = this.properties.id;
    };
    NamedDensityFunction.prototype.onExecute = function () {
        this.setOutputData(0, {
            json: this.properties.id,
            error: false
        });
    };
    NamedDensityFunction.title = "Named Density Function";
    return NamedDensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/register.ts":
/*!************************************!*\
  !*** ./src/main/nodes/register.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerNodes": () => (/* binding */ registerNodes)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vanilla_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vanilla/schemas */ "./src/main/vanilla/schemas.ts");
/* harmony import */ var _constant_density_function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant_density_function */ "./src/main/nodes/constant_density_function.ts");
/* harmony import */ var _density_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./density_function */ "./src/main/nodes/density_function.ts");
/* harmony import */ var _density_function_spline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./density_function_spline */ "./src/main/nodes/density_function_spline.ts");
/* harmony import */ var _named_density_function__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./named_density_function */ "./src/main/nodes/named_density_function.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






function registerNodes() {
    litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/named", _named_density_function__WEBPACK_IMPORTED_MODULE_5__.NamedDensityFunction);
    litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/constant", _constant_density_function__WEBPACK_IMPORTED_MODULE_2__.ConstantDensityFunction);
    litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/spline", _density_function_spline__WEBPACK_IMPORTED_MODULE_4__.SplineDensityFunction);
    _vanilla_schemas__WEBPACK_IMPORTED_MODULE_1__.schemas.forEach(function (schema, n) {
        var f = /** @class */ (function (_super) {
            __extends(f, _super);
            function f() {
                return _super.call(this, n, new Map(Object.entries(schema))) || this;
            }
            f.title = n.replace("minecraft:", "");
            return f;
        }(_density_function__WEBPACK_IMPORTED_MODULE_3__.DensityFunction));
        litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/" + (n.replace("minecraft:", "")), f);
    });
}


/***/ }),

/***/ "./src/main/vanilla/schemas.ts":
/*!*************************************!*\
  !*** ./src/main/vanilla/schemas.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "noise_router_fields": () => (/* binding */ noise_router_fields)
/* harmony export */ });
var schemas = new Map(Object.entries({
    'minecraft:abs': {
        argument: "densityFunction",
    },
    'minecraft:add': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:beardifier': {},
    'minecraft:blend_alpha': {},
    'minecraft:blend_density': {
        argument: "densityFunction",
    },
    'minecraft:blend_offset': {},
    'minecraft:cache_2d': {
        argument: "densityFunction",
    },
    'minecraft:cache_all_in_cell': {
        argument: "densityFunction",
    },
    'minecraft:cache_once': {
        argument: "densityFunction",
    },
    'minecraft:clamp': {
        input: "densityFunction",
        min: "number",
        max: "number",
    },
    'minecraft:cube': {
        argument: "densityFunction",
    },
    "minecraft:end_islands": {},
    'minecraft:flat_cache': {
        argument: "densityFunction",
    },
    'minecraft:half_negative': {
        argument: "densityFunction",
    },
    'minecraft:interpolated': {
        argument: "densityFunction",
    },
    'minecraft:max': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:min': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:mul': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:noise': {
        noise: "noise",
        xz_scale: "number",
        y_scale: "number",
    },
    "minecraft:old_blended_noise": {},
    'minecraft:quarter_negative': {
        argument: "densityFunction",
    },
    'minecraft:range_choice': {
        input: "densityFunction",
        min_inclusive: "number",
        max_exclusive: "number",
        when_in_range: "densityFunction",
        when_out_of_range: "densityFunction",
    },
    'minecraft:shift': {
        argument: "densityFunction",
    },
    'minecraft:shift_a': {
        argument: "densityFunction",
    },
    'minecraft:shift_b': {
        argument: "densityFunction",
    },
    'minecraft:shifted_noise': {
        shift_x: "densityFunction",
        shift_y: "densityFunction",
        shift_z: "densityFunction",
        noise: "noise",
        xz_scale: "number",
        y_scale: "number",
    },
    'minecraft:slide': {
        argument: "densityFunction",
    },
    'minecraft:square': {
        argument: "densityFunction",
    },
    'minecraft:squeeze': {
        argument: "densityFunction",
    },
    'minecraft:terrain_shaper_spline': {
        spline: "spline",
        min_value: "number",
        max_value: "number",
        continentalness: "densityFunction",
        erosion: "densityFunction",
        weirdness: "densityFunction",
    },
    'minecraft:weird_scaled_sampler': {
        rarity_value_mapper: "sampler_type",
        noise: "noise",
        input: "densityFunction",
    },
    'minecraft:y_clamped_gradient': {
        from_y: "number",
        to_y: "number",
        from_value: "number",
        to_value: "number",
    }
}));
var noise_router_fields = [
    "final_density",
    "vein_toggle",
    "vein_ridged",
    "vein_gap",
    "erosion",
    "depth",
    "ridges",
    "initial_density_without_jaggedness",
    "lava",
    "temperature",
    "vegetation",
    "continents",
    "barrier",
    "fluid_level_floodedness",
    "fluid_level_spread"
];


/***/ }),

/***/ "./src/main/widgets/SplineWidget.ts":
/*!******************************************!*\
  !*** ./src/main/widgets/SplineWidget.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SplineWidget": () => (/* binding */ SplineWidget)
/* harmony export */ });
/* harmony import */ var deepslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepslate */ "./node_modules/deepslate/dist/deepslate.esm.js");

var SplineWidget = /** @class */ (function () {
    function SplineWidget() {
        this.value = new deepslate__WEBPACK_IMPORTED_MODULE_0__.Spline("spine", function (c) { return c; }, [-1, 1], [function () { return -1; }, function () { return 1; }], [1, 1]);
        this.min_input = -1;
        this.max_input = 1;
        this.min_value = -1;
        this.max_value = 1;
        this.options = {};
        this.dragging_id = -1;
        this.selected_id = -1;
        this.dragging_derivative = false;
        this.last_click_time = 0;
        this.expand_timer = undefined;
        this.shrink_timer = undefined;
    }
    SplineWidget.prototype.draw = function (ctx, node, width, posY, _height) {
        this.node = node;
        ctx.save();
        width -= 20;
        this.widged_width = width;
        this.widget_posy = posY;
        ctx.fillStyle = "black";
        ctx.rect(10, posY, width, width);
        ctx.clip();
        ctx.fillRect(10, posY, width, width);
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = "gray";
        for (var location = Math.floor(this.min_input / 2) * 2; location <= this.max_input; location += 0.5) {
            ctx.beginPath();
            var x_1 = this.inputToPos(location, width);
            ctx.lineTo(x_1, posY);
            ctx.lineTo(x_1, posY + width);
            ctx.stroke();
        }
        for (var value = Math.floor(this.min_value / 2) * 2; value <= this.max_value; value += 0.5) {
            ctx.beginPath();
            var y = this.outputToPos(value, width);
            ctx.lineTo(10, y);
            ctx.lineTo(10 + width, y);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        ctx.beginPath();
        var step = 5;
        for (var x = 0; x <= width; x += step) {
            ctx.lineTo(x + 10, this.outputToPos(this.value.apply(this.posToInput(x + 10, width)), width));
        }
        ctx.lineTo(width + 10, this.outputToPos(this.value.apply(this.posToInput(width + 10, width)), width));
        ctx.stroke();
        for (var i = 0; i < this.value.locations.length; i++) {
            var x_2 = this.inputToPos(this.value.locations[i], width);
            var y = this.outputToPos(this.value.values[i](0), width);
            ctx.fillStyle = i == this.selected_id ? "orange" : "white";
            ctx.beginPath();
            ctx.arc(x_2, y, i == this.selected_id ? 3 : 2, 0, 2 * Math.PI);
            ctx.fill();
            if (i == this.selected_id) {
                ctx.strokeStyle = "orange";
                ctx.lineWidth = 0.5;
                var derivative = this.value.derivatives[i] * (this.max_input - this.min_input) / (this.max_value - this.min_value);
                var angle = Math.atan(derivative);
                ctx.beginPath();
                ctx.lineTo(x_2 - 30 * Math.cos(angle), y + 30 * Math.sin(angle));
                ctx.lineTo(x_2 + 30 * Math.cos(angle), y - 30 * Math.sin(angle));
                ctx.stroke();
            }
        }
        //ctx.fillText(this.max_value.toFixed(2), 10, posY+12)
        //ctx.fillText(this.min_value.toFixed(2), 10, posY+width-1)
        ctx.restore();
        ctx.fillStyle = "white";
        ctx.fillText(this.min_input.toFixed(2), 10, posY + width + 12);
        ctx.fillText(this.max_input.toFixed(2), 10 + width - ctx.measureText(this.max_input.toFixed(2)).width, posY + width + 12);
        if (this.selected_id >= 0) {
            ctx.fillStyle = "orange";
            var text = "(" + this.value.locations[this.selected_id].toFixed(2) + ", " + this.value.values[this.selected_id](0).toFixed(2) + ")";
            ctx.fillText(text, 10 + width / 2 - ctx.measureText(text).width / 2, posY + width + 12);
        }
    };
    SplineWidget.prototype.posToInput = function (pos, width) {
        return (pos - 10) / width * (this.max_input - this.min_input) + this.min_input;
    };
    SplineWidget.prototype.inputToPos = function (input, width) {
        return (input - this.min_input) / (this.max_input - this.min_input) * width + 10;
    };
    SplineWidget.prototype.posToOutput = function (pos, width) {
        return (1 - ((pos - this.widget_posy) / width)) * (this.max_value - this.min_value) + this.min_value;
    };
    SplineWidget.prototype.outputToPos = function (output, height) {
        return (1 - ((output - this.min_value) / (this.max_value - this.min_value))) * height + this.widget_posy;
    };
    SplineWidget.prototype.mouse = function (event, pos, node) {
        if (event.type === "mousedown") {
            for (var i = 0; i < this.value.locations.length; i++) {
                var x = this.inputToPos(this.value.locations[i], this.widged_width);
                var y = this.outputToPos(this.value.values[i](0), this.widged_width);
                var distance = (x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1]);
                if (distance < 100) {
                    if (this.selected_id == i && (new Date().getTime() - this.last_click_time) < 500 && this.value.locations.length > 1) {
                        this.value.locations.splice(i, 1);
                        this.value.values.splice(i, 1);
                        this.value.derivatives.splice(i, 1);
                        this.dragging_id = -1;
                        this.selected_id = -1;
                        return false;
                    }
                    else {
                        this.dragging_id = i;
                        this.selected_id = i;
                        this.dragging_derivative = false;
                        this.last_click_time = new Date().getTime();
                        this.stopShrink();
                        return false;
                    }
                }
                else if (distance < 1000 && i == this.selected_id) {
                    var derivative = this.value.derivatives[i] * (this.max_input - this.min_input) / (this.max_value - this.min_value);
                    var mouse_angle = Math.atan((y - pos[1]) / (-x + pos[0]));
                    var derivative_angle = Math.atan(derivative);
                    if (Math.abs(mouse_angle - derivative_angle) < 0.1) {
                        this.dragging_id = i;
                        this.dragging_derivative = true;
                        this.stopShrink();
                        return false;
                    }
                }
            }
            var location_1 = this.posToInput(pos[0], this.widged_width);
            var value_1 = this.posToOutput(pos[1], this.widged_width);
            if (Math.abs(this.outputToPos(this.value.apply(location_1), this.widged_width) - pos[1]) < 10) {
                var index = this.value.locations.findIndex(function (loc) { return loc > location_1; });
                if (index === -1)
                    index = this.value.locations.length;
                this.value.locations.splice(index, 0, location_1);
                this.value.values.splice(index, 0, function () { return value_1; });
                this.value.derivatives.splice(index, 0, 0);
                this.dragging_id = index;
                this.selected_id = index;
                this.dragging_derivative = false;
                this.stopShrink();
                return false;
            }
            this.dragging_id = -1;
            this.selected_id = -1;
        }
        else if (event.type === "mousemove" && this.dragging_id >= 0) {
            if (this.dragging_derivative) {
                var x = this.inputToPos(this.value.locations[this.dragging_id], this.widged_width);
                var y = this.outputToPos(this.value.values[this.dragging_id](0), this.widged_width);
                this.value.derivatives[this.dragging_id] = (y - pos[1]) / (-x + pos[0]) / (this.max_input - this.min_input) * (this.max_value - this.min_value);
            }
            else {
                if (pos[0] < 0) {
                    this.startExpand("left");
                }
                else if (pos[0] > this.widged_width + 20) {
                    this.startExpand("right");
                }
                else {
                    this.stopExpand();
                }
                var location_2 = Math.clamp(this.posToInput(pos[0], this.widged_width), this.min_input, this.max_input);
                var value_2 = Math.clamp(this.posToOutput(pos[1], this.widged_width), this.min_value, this.max_value);
                var derivative = this.value.derivatives[this.dragging_id];
                while (this.dragging_id > 0 && location_2 < this.value.locations[this.dragging_id - 1]) {
                    this.value.locations[this.dragging_id] = this.value.locations[this.dragging_id - 1];
                    this.value.derivatives[this.dragging_id] = this.value.derivatives[this.dragging_id - 1];
                    this.value.values[this.dragging_id] = this.value.values[this.dragging_id - 1];
                    this.dragging_id--;
                    this.selected_id--;
                }
                while (this.dragging_id < this.value.locations.length - 1 && location_2 > this.value.locations[this.dragging_id + 1]) {
                    this.value.locations[this.dragging_id] = this.value.locations[this.dragging_id + 1];
                    this.value.derivatives[this.dragging_id] = this.value.derivatives[this.dragging_id + 1];
                    this.value.values[this.dragging_id] = this.value.values[this.dragging_id + 1];
                    this.dragging_id++;
                    this.selected_id++;
                }
                this.value.locations[this.dragging_id] = location_2;
                this.value.values[this.dragging_id] = function () { return value_2; };
                this.value.derivatives[this.dragging_id] = derivative;
            }
            return false;
        }
        else if (event.type === "mouseup") {
            this.stopExpand();
            this.dragging_id = -1;
            this.startShrink();
        }
        return false;
    };
    SplineWidget.prototype.computeSize = function (width) {
        return [width, width - 20 + 15];
    };
    SplineWidget.prototype.startExpand = function (direction) {
        var _this = this;
        if (!this.expand_timer) {
            this.expand_timer = setInterval(function () {
                var _a;
                if (direction === "left") {
                    _this.min_input -= 0.02;
                    _this.value.locations[_this.dragging_id] = _this.min_input;
                }
                else {
                    _this.max_input += 0.02;
                    _this.value.locations[_this.dragging_id] = _this.max_input;
                }
                (_a = _this.node) === null || _a === void 0 ? void 0 : _a.setDirtyCanvas(true, false);
            }, 20);
        }
    };
    SplineWidget.prototype.stopExpand = function () {
        if (this.expand_timer) {
            clearInterval(this.expand_timer);
            this.expand_timer = undefined;
        }
    };
    SplineWidget.prototype.startShrink = function () {
        var _this = this;
        if (!this.shrink_timer) {
            this.shrink_timer = setInterval(function () {
                var _a;
                var changed = false;
                if (_this.min_input < _this.value.locations[0] - 0.3) {
                    _this.min_input += 0.02;
                    changed = true;
                }
                if (_this.max_input > _this.value.locations[_this.value.locations.length - 1] + 0.3) {
                    _this.max_input -= 0.02;
                    changed = true;
                }
                if (!changed) {
                    _this.stopShrink();
                }
                else {
                    (_a = _this.node) === null || _a === void 0 ? void 0 : _a.setDirtyCanvas(true, false);
                }
            }, 20);
        }
    };
    SplineWidget.prototype.stopShrink = function () {
        if (this.shrink_timer) {
            clearInterval(this.shrink_timer);
            this.shrink_timer = undefined;
        }
    };
    return SplineWidget;
}());



/***/ }),

/***/ "./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deflate": () => (/* binding */ Deflate_1),
/* harmony export */   "Inflate": () => (/* binding */ Inflate_1),
/* harmony export */   "constants": () => (/* binding */ constants_1),
/* harmony export */   "default": () => (/* binding */ pako),
/* harmony export */   "deflate": () => (/* binding */ deflate_1),
/* harmony export */   "deflateRaw": () => (/* binding */ deflateRaw_1),
/* harmony export */   "gzip": () => (/* binding */ gzip_1),
/* harmony export */   "inflate": () => (/* binding */ inflate_1),
/* harmony export */   "inflateRaw": () => (/* binding */ inflateRaw_1),
/* harmony export */   "ungzip": () => (/* binding */ ungzip_1)
/* harmony export */ });

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


const deflate$2 = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;

var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 30;       /* got a data error -- remain here until reset */
const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;

var pako = {
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
};




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./src/main/app.ts ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _UI_GraphManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI/GraphManager */ "./src/main/UI/GraphManager.ts");
/* harmony import */ var _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UI/MenuManager */ "./src/main/UI/MenuManager.ts");


onload = function () {
    _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.addHandlers();
    _UI_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.init();
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxxQkFBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSw0Q0FBNEM7QUFDNUMsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25DLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUEsOEVBQThFO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNFQUFzRSxPQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTzs7QUFFckI7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDBCQUEwQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsb0RBQW9EO0FBQ3BELCtCQUErQjtBQUMvQixtRUFBbUU7O0FBRW5FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdIQUF3SCwwQ0FBMEM7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFDQUFxQztBQUNuRztBQUNBLG1DQUFtQztBQUNuQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrREFBa0QsaUNBQWlDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2QkFBNkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLCtFQUErRTtBQUMvRTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsc0RBQXNEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sd0JBQXdCLDRDQUE0QztBQUMxRixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFROztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixlQUFlOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FB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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLDJCQUEyQjs7QUFFM0IsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSwwQ0FBMEM7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBb0Q7QUFDOUQsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFnRDs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCwwQ0FBMEMsY0FBYztBQUN4RCw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUUsc0RBQXNELCtDQUErQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0NBQWdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUE0Qzs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQXNEO0FBQ2hFLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxrREFBa0Q7QUFDNUQsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTOztBQUVU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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxlQUFlLEVBQUU7QUFDNUMsc0JBQXNCLEVBQUU7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdC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QXNDO0FBQ3RDLGdGQUFnRjtBQUNoRjtBQUNBLHdHQUF3RztBQUN4RztBQUNBLGdJQUFnSTtBQUNoSSxvRUFBb0UsT0FBTztBQUMzRSxvR0FBb0csTUFBTTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsdUJBQXVCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixFQUFFLFNBQVM7QUFDWCxFQUFFLFVBQVU7QUFDWixFQUFFLFdBQVc7QUFDYixFQUFFLGNBQWM7QUFDaEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLEVBQUUsU0FBUztBQUNYLHlCQUF5QjtBQUN6QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ3RFLG9DQUFvQyxrQ0FBa0M7QUFDdEUscUNBQXFDLGtDQUFrQztBQUN2RSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0tBQWdLO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0UsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1SSxnQkFBZ0I7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RUFBdUUsMERBQTBEO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtB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QSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDViw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QVksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUMsQ0FBQztRQUNyRyxLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7UUFDOUUsS0FBSSxDQUFDLFlBQVksR0FBRyxLQUFJLENBQUMsZUFBZSxDQUFlLElBQUksK0RBQVksRUFBRSxDQUFDO1FBQzFFLEtBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQztRQUMzQyxLQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLEVBQUUsVUFBQyxLQUFLO1lBQ2xFLEtBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLEtBQUs7WUFDakMsS0FBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsS0FBSztRQUN2QyxDQUFDLENBQUM7UUFDRixLQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsUUFBUSxDQUFDO1FBQzFDLEtBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxDQUFDLEVBQUUsVUFBQyxLQUFLO1lBQ2pFLEtBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLEtBQUs7WUFDakMsS0FBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsS0FBSztRQUN2QyxDQUFDLENBQUM7UUFFRixLQUFJLENBQUMsS0FBSyxHQUFHLFFBQVE7UUFDckIsS0FBSSxDQUFDLEtBQUssR0FBRyxTQUFTOztJQUMxQixDQUFDO0lBRU0sNkNBQWEsR0FBcEI7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVM7UUFDckQsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTO1FBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUztJQUMzRCxDQUFDO0lBRUQsbURBQW1CLEdBQW5CO1FBQ0ksSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVM7SUFDN0QsQ0FBQztJQUVELHlDQUFTLEdBQVQ7UUFFSSxJQUFNLE1BQU0sR0FBRyxFQUFFO1FBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFHLENBQUMsRUFBRSxFQUFDO1lBQ2hFLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ1IsUUFBUSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLEtBQUssRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQzthQUNyRCxDQUFDO1NBQ0w7UUFFRCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDO1FBRW5ELElBQU0sS0FBSyxHQUFHLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDO1FBRWxELElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFO1lBQ2xCLElBQUksRUFBRTtnQkFDRixJQUFJLEVBQUUsa0JBQWtCO2dCQUN4QixTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTO2dCQUNwQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTO2dCQUNwQyxNQUFNLEVBQUU7b0JBQ0osVUFBVSxFQUFFLEtBQUssQ0FBQyxJQUFJO29CQUN0QixNQUFNLEVBQUUsTUFBTTtpQkFDakI7YUFDSjtZQUNELEtBQUssRUFBRSxLQUFLO1NBQ2YsQ0FBQztJQUNOLENBQUM7SUFqRU0sMkJBQUssR0FBRyxRQUFRO0lBa0UzQiw0QkFBQztDQUFBLENBcEUwQyw2REFBZSxHQW9FekQ7QUFwRWlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05rQjtBQUVwRDtJQUEwQyx3Q0FBZTtJQUtyRDtRQUFBLFlBQ0ksaUJBQU8sU0FNVjtRQU1ELGNBQVEsR0FBRztZQUNQLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUU7Z0JBQ3RCLElBQUksRUFBRSxHQUFVLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDbEMsSUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBQztvQkFDZixFQUFFLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsQ0FBQztpQkFDM0M7Z0JBQ0QsT0FBTyxFQUFFLENBQUM7YUFDYjtZQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN0QixDQUFDLENBQUM7UUFwQkUsS0FBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUMsaUJBQWlCLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO1FBQzdFLEtBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUM7UUFDcEMsS0FBSSxDQUFDLElBQUksR0FBRyxLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLFVBQUMsS0FBSyxJQUFNLEtBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxHQUFHLEtBQUssR0FBQyxDQUFDO1FBQ3JGLEtBQUksQ0FBQyxLQUFLLEdBQUcsd0JBQXdCO1FBQ3JDLEtBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUzs7SUFDMUIsQ0FBQztJQUVNLDRDQUFhLEdBQXBCO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQ3hDLENBQUM7SUFhRCx3Q0FBUyxHQUFUO1FBQ0ksSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUU7WUFDbEIsSUFBSSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN4QixLQUFLLEVBQUUsS0FBSztTQUNmLENBQUM7SUFDTixDQUFDO0lBakNNLDBCQUFLLEdBQUcsd0JBQXdCO0lBa0MzQywyQkFBQztDQUFBLENBbkN5Qyw2REFBZSxHQW1DeEQ7QUFuQ2dDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pRO0FBQ0k7QUFDeUI7QUFDakI7QUFDYTtBQUNGO0FBR3pELFNBQVMsYUFBYTtJQUN6QixvRUFBMEIsQ0FBQyx3QkFBd0IsRUFBRSx5RUFBb0IsQ0FBRSxDQUFDO0lBQzVFLG9FQUEwQixDQUFDLDJCQUEyQixFQUFFLCtFQUF1QixDQUFFLENBQUM7SUFDbEYsb0VBQTBCLENBQUMseUJBQXlCLEVBQUUsMkVBQXFCLENBQUUsQ0FBQztJQUU5RSw2REFBZSxDQUFDLFVBQUMsTUFBTSxFQUFFLENBQUM7UUFDdEI7WUFBZ0IscUJBQWU7WUFHM0I7dUJBQ0ksa0JBQU0sQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUM3QyxDQUFDO1lBSk0sT0FBSyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQztZQUs5QyxRQUFDO1NBQUEsQ0FOZSw4REFBZSxHQU05QjtRQUNELG9FQUEwQixDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEYsQ0FBQyxDQUFDO0FBSU4sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQk0sSUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUMxQyxlQUFlLEVBQUU7UUFDYixRQUFRLEVBQUUsaUJBQWlCO0tBQzlCO0lBQ0QsZUFBZSxFQUFFO1FBQ2IsU0FBUyxFQUFFLGlCQUFpQjtRQUM1QixTQUFTLEVBQUUsaUJBQWlCO0tBQy9CO0lBQ0Qsc0JBQXNCLEVBQUUsRUFBRTtJQUMxQix1QkFBdUIsRUFBRSxFQUFFO0lBQzNCLHlCQUF5QixFQUFFO1FBQ3ZCLFFBQVEsRUFBRSxpQkFBaUI7S0FDOUI7SUFDRCx3QkFBd0IsRUFBRSxFQUFFO0lBQzVCLG9CQUFvQixFQUFFO1FBQ2xCLFFBQVEsRUFBRSxpQkFBaUI7S0FDOUI7SUFDRCw2QkFBNkIsRUFBRTtRQUMzQixRQUFRLEVBQUUsaUJBQWlCO0tBQzlCO0lBQ0Qsc0JBQXNCLEVBQUU7UUFDcEIsUUFBUSxFQUFFLGlCQUFpQjtLQUM5QjtJQUNELGlCQUFpQixFQUFFO1FBQ2YsS0FBSyxFQUFFLGlCQUFpQjtRQUN4QixHQUFHLEVBQUUsUUFBUTtRQUNiLEdBQUcsRUFBRSxRQUFRO0tBQ2hCO0lBQ0QsZ0JBQWdCLEVBQUU7UUFDZCxRQUFRLEVBQUUsaUJBQWlCO0tBQzlCO0lBQ0QsdUJBQXVCLEVBQUUsRUFBRTtJQUMzQixzQkFBc0IsRUFBRTtRQUNwQixRQUFRLEVBQUUsaUJBQWlCO0tBQzlCO0lBQ0QseUJBQXlCLEVBQUU7UUFDdkIsUUFBUSxFQUFFLGlCQUFpQjtLQUM5QjtJQUNELHdCQUF3QixFQUFFO1FBQ3RCLFFBQVEsRUFBRSxpQkFBaUI7S0FDOUI7SUFDRCxlQUFlLEVBQUU7UUFDYixTQUFTLEVBQUUsaUJBQWlCO1FBQzVCLFNBQVMsRUFBRSxpQkFBaUI7S0FDL0I7SUFDRCxlQUFlLEVBQUU7UUFDYixTQUFTLEVBQUUsaUJBQWlCO1FBQzVCLFNBQVMsRUFBRSxpQkFBaUI7S0FDL0I7SUFDRCxlQUFlLEVBQUU7UUFDYixTQUFTLEVBQUUsaUJBQWlCO1FBQzVCLFNBQVMsRUFBRSxpQkFBaUI7S0FDL0I7SUFDRCxpQkFBaUIsRUFBRTtRQUNmLEtBQUssRUFBRSxPQUFPO1FBQ2QsUUFBUSxFQUFFLFFBQVE7UUFDbEIsT0FBTyxFQUFFLFFBQVE7S0FDcEI7SUFDRCw2QkFBNkIsRUFBRSxFQUFFO0lBQ2pDLDRCQUE0QixFQUFFO1FBQzFCLFFBQVEsRUFBRSxpQkFBaUI7S0FDOUI7SUFDRCx3QkFBd0IsRUFBRTtRQUN0QixLQUFLLEVBQUUsaUJBQWlCO1FBQ3hCLGFBQWEsRUFBRSxRQUFRO1FBQ3ZCLGFBQWEsRUFBRSxRQUFRO1FBQ3ZCLGFBQWEsRUFBRSxpQkFBaUI7UUFDaEMsaUJBQWlCLEVBQUUsaUJBQWlCO0tBQ3ZDO0lBQ0QsaUJBQWlCLEVBQUU7UUFDZixRQUFRLEVBQUUsaUJBQWlCO0tBQzlCO0lBQ0QsbUJBQW1CLEVBQUU7UUFDakIsUUFBUSxFQUFFLGlCQUFpQjtLQUM5QjtJQUNELG1CQUFtQixFQUFFO1FBQ2pCLFFBQVEsRUFBRSxpQkFBaUI7S0FDOUI7SUFDRCx5QkFBeUIsRUFBRTtRQUN2QixPQUFPLEVBQUUsaUJBQWlCO1FBQzFCLE9BQU8sRUFBRSxpQkFBaUI7UUFDMUIsT0FBTyxFQUFFLGlCQUFpQjtRQUMxQixLQUFLLEVBQUUsT0FBTztRQUNkLFFBQVEsRUFBRSxRQUFRO1FBQ2xCLE9BQU8sRUFBRSxRQUFRO0tBQ3BCO0lBQ0QsaUJBQWlCLEVBQUU7UUFDZixRQUFRLEVBQUUsaUJBQWlCO0tBQzlCO0lBQ0Qsa0JBQWtCLEVBQUU7UUFDaEIsUUFBUSxFQUFFLGlCQUFpQjtLQUM5QjtJQUNELG1CQUFtQixFQUFFO1FBQ2pCLFFBQVEsRUFBRSxpQkFBaUI7S0FDOUI7SUFDRCxpQ0FBaUMsRUFBRTtRQUMvQixNQUFNLEVBQUUsUUFBUTtRQUNoQixTQUFTLEVBQUUsUUFBUTtRQUNuQixTQUFTLEVBQUUsUUFBUTtRQUNuQixlQUFlLEVBQUUsaUJBQWlCO1FBQ2xDLE9BQU8sRUFBRSxpQkFBaUI7UUFDMUIsU0FBUyxFQUFFLGlCQUFpQjtLQUMvQjtJQUNELGdDQUFnQyxFQUFFO1FBQzlCLG1CQUFtQixFQUFFLGNBQWM7UUFDbkMsS0FBSyxFQUFFLE9BQU87UUFDZCxLQUFLLEVBQUUsaUJBQWlCO0tBQzNCO0lBQ0QsOEJBQThCLEVBQUU7UUFDNUIsTUFBTSxFQUFFLFFBQVE7UUFDaEIsSUFBSSxFQUFFLFFBQVE7UUFDZCxVQUFVLEVBQUUsUUFBUTtRQUNwQixRQUFRLEVBQUUsUUFBUTtLQUNyQjtDQUNKLENBQUMsQ0FBQztBQUVJLElBQU0sbUJBQW1CLEdBQUc7SUFDL0IsZUFBZTtJQUNmLGFBQWE7SUFDYixhQUFhO0lBQ2IsVUFBVTtJQUNWLFNBQVM7SUFDVCxPQUFPO0lBQ1AsUUFBUTtJQUNSLG9DQUFvQztJQUNwQyxNQUFNO0lBQ04sYUFBYTtJQUNiLFlBQVk7SUFDWixZQUFZO0lBQ1osU0FBUztJQUNULHlCQUF5QjtJQUN6QixvQkFBb0I7Q0FDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbklrQztBQUduQztJQUFBO1FBRUksVUFBSyxHQUFtQixJQUFJLDZDQUFNLENBQVMsT0FBTyxFQUFFLFVBQUMsQ0FBQyxJQUFLLFFBQUMsRUFBRCxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLGNBQU0sUUFBQyxDQUFDLEVBQUYsQ0FBRSxFQUFFLGNBQU0sUUFBQyxFQUFELENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0YsY0FBUyxHQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLGNBQVMsR0FBVyxDQUFDLENBQUM7UUFDdEIsY0FBUyxHQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLGNBQVMsR0FBVyxDQUFDLENBQUM7UUFFN0IsWUFBTyxHQUFHLEVBQUU7UUFLSixnQkFBVyxHQUFXLENBQUMsQ0FBQztRQUN4QixnQkFBVyxHQUFXLENBQUMsQ0FBQztRQUN4Qix3QkFBbUIsR0FBWSxLQUFLO1FBQ3BDLG9CQUFlLEdBQVcsQ0FBQztRQThNM0IsaUJBQVksR0FBaUIsU0FBUztRQXVCdEMsaUJBQVksR0FBaUIsU0FBUztJQTRCbEQsQ0FBQztJQTdQRywyQkFBSSxHQUFKLFVBQUssR0FBNkIsRUFBRSxJQUFnQixFQUFFLEtBQWEsRUFBRSxJQUFZLEVBQUUsT0FBZTtRQUM5RixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUk7UUFFaEIsR0FBRyxDQUFDLElBQUksRUFBRTtRQUNWLEtBQUssSUFBRSxFQUFFLENBQUM7UUFDVixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUs7UUFDekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJO1FBRXZCLEdBQUcsQ0FBQyxTQUFTLEdBQUcsT0FBTztRQUN2QixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQztRQUNoQyxHQUFHLENBQUMsSUFBSSxFQUFFO1FBQ1YsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUM7UUFFcEMsR0FBRyxDQUFDLFNBQVMsR0FBRyxHQUFHO1FBQ25CLEdBQUcsQ0FBQyxXQUFXLEdBQUcsTUFBTTtRQUN4QixLQUFLLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUcsUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUcsUUFBUSxJQUFFLEdBQUcsRUFBQztZQUNoRyxHQUFHLENBQUMsU0FBUyxFQUFFO1lBQ2YsSUFBTSxHQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDO1lBQzFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLElBQUksQ0FBQztZQUNuQixHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxJQUFJLEdBQUcsS0FBSyxDQUFDO1lBQzNCLEdBQUcsQ0FBQyxNQUFNLEVBQUU7U0FDZjtRQUNELEtBQUssSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRyxLQUFLLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRyxLQUFLLElBQUUsR0FBRyxFQUFDO1lBQ3ZGLEdBQUcsQ0FBQyxTQUFTLEVBQUU7WUFDZixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7WUFDeEMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ2pCLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDdkIsR0FBRyxDQUFDLE1BQU0sRUFBRTtTQUNmO1FBRUQsR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDO1FBQ2pCLEdBQUcsQ0FBQyxXQUFXLEdBQUcsT0FBTztRQUN6QixHQUFHLENBQUMsU0FBUyxFQUFFO1FBQ2YsSUFBTSxJQUFJLEdBQUcsQ0FBQztRQUNkLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBRSxLQUFLLEVBQUUsQ0FBQyxJQUFFLElBQUksRUFBQztZQUM5QixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUM5RjtRQUNELEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ25HLEdBQUcsQ0FBQyxNQUFNLEVBQUU7UUFFWixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRyxDQUFDLEdBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFHLENBQUMsRUFBRSxFQUFDO1lBQ2pELElBQU0sR0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO1lBQ3pELElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO1lBQzFELEdBQUcsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBTztZQUMxRCxHQUFHLENBQUMsU0FBUyxFQUFFO1lBQ2YsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3RCxHQUFHLENBQUMsSUFBSSxFQUFFO1lBQ1YsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBQztnQkFDdEIsR0FBRyxDQUFDLFdBQVcsR0FBRyxRQUFRO2dCQUMxQixHQUFHLENBQUMsU0FBUyxHQUFHLEdBQUc7Z0JBQ25CLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7Z0JBQ3BILElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2dCQUNuQyxHQUFHLENBQUMsU0FBUyxFQUFFO2dCQUNmLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBQyxHQUFHLEVBQUUsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDMUQsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBRSxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMxRCxHQUFHLENBQUMsTUFBTSxFQUFFO2FBQ2Y7U0FDTDtRQUVELHNEQUFzRDtRQUN0RCwyREFBMkQ7UUFFM0QsR0FBRyxDQUFDLE9BQU8sRUFBRTtRQUViLEdBQUcsQ0FBQyxTQUFTLEdBQUcsT0FBTztRQUN2QixHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEdBQUMsS0FBSyxHQUFDLEVBQUUsQ0FBQztRQUMxRCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFLLEdBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLEdBQUMsS0FBSyxHQUFDLEVBQUUsQ0FBQztRQUNqSCxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxFQUFDO1lBQ3RCLEdBQUcsQ0FBQyxTQUFTLEdBQUcsUUFBUTtZQUN4QixJQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHO1lBQ3JJLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsR0FBQyxLQUFLLEdBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxHQUFDLENBQUMsRUFBRSxJQUFJLEdBQUMsS0FBSyxHQUFDLEVBQUUsQ0FBQztTQUM5RTtJQUNKLENBQUM7SUFFTyxpQ0FBVSxHQUFsQixVQUFtQixHQUFXLEVBQUUsS0FBYTtRQUN6QyxPQUFPLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTO0lBQ2hGLENBQUM7SUFFTyxpQ0FBVSxHQUFsQixVQUFtQixLQUFhLEVBQUUsS0FBYTtRQUMzQyxPQUFPLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEtBQUssR0FBRyxFQUFFO0lBQ3BGLENBQUM7SUFFTyxrQ0FBVyxHQUFuQixVQUFvQixHQUFXLEVBQUUsS0FBYTtRQUMxQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUztJQUN2RyxDQUFDO0lBRU8sa0NBQVcsR0FBbkIsVUFBb0IsTUFBYyxFQUFFLE1BQWM7UUFDOUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVc7SUFDNUcsQ0FBQztJQUVELDRCQUFLLEdBQUwsVUFBTSxLQUFpQixFQUFFLEdBQVksRUFBRSxJQUFnQjtRQUNuRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFDO1lBQzNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUcsQ0FBQyxFQUFFLEVBQUM7Z0JBQ2pELElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFDckUsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDO2dCQUd0RSxJQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RFLElBQUksUUFBUSxHQUFHLEdBQUcsRUFBQztvQkFDZixJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUUsR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7d0JBQy9HLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO3dCQUNqQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzt3QkFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO3dCQUNyQixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQzt3QkFDckIsT0FBTyxLQUFLO3FCQUNmO3lCQUFNO3dCQUNILElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQzt3QkFDcEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDO3dCQUNwQixJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSzt3QkFDaEMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTt3QkFDM0MsSUFBSSxDQUFDLFVBQVUsRUFBRTt3QkFDakIsT0FBTyxLQUFLO3FCQUNmO2lCQUNKO3FCQUFNLElBQUksUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBQztvQkFDaEQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztvQkFDcEgsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMxRCxJQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO29CQUM5QyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLGdCQUFnQixDQUFDLEdBQUMsR0FBRyxFQUFDO3dCQUM3QyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUM7d0JBQ3BCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJO3dCQUMvQixJQUFJLENBQUMsVUFBVSxFQUFFO3dCQUNqQixPQUFPLEtBQUs7cUJBQ2Y7aUJBQ0o7YUFDSjtZQUVELElBQU0sVUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDM0QsSUFBTSxPQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUV6RCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFDO2dCQUN4RixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBQyxHQUFHLElBQUssVUFBRyxHQUFHLFVBQVEsRUFBZCxDQUFjLENBQUM7Z0JBQ25FLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQztvQkFDWixLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTTtnQkFDdkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsVUFBUSxDQUFDO2dCQUMvQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxjQUFNLGNBQUssRUFBTCxDQUFLLENBQUM7Z0JBQy9DLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLO2dCQUN4QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUs7Z0JBQ3hCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxLQUFLO2dCQUNoQyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNqQixPQUFPLEtBQUs7YUFDZjtZQUVELElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO2FBQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsRUFBQztZQUMzRCxJQUFJLElBQUksQ0FBQyxtQkFBbUIsRUFBQztnQkFDekIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFDcEYsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFFckYsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQzthQUNqSjtpQkFBTTtnQkFDSCxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUM7b0JBQ1gsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7aUJBQzNCO3FCQUFNLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxFQUFDO29CQUN2QyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztpQkFDNUI7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLFVBQVUsRUFBRTtpQkFDcEI7Z0JBRUQsSUFBTSxVQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUN2RyxJQUFNLE9BQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7Z0JBQ3JHLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7Z0JBRzNELE9BQU8sSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksVUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUMsQ0FBQyxDQUFDLEVBQUM7b0JBQy9FLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFDLENBQUMsQ0FBQztvQkFDakYsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUMsQ0FBQyxDQUFDO29CQUNyRixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBQyxDQUFDLENBQUM7b0JBQzNFLElBQUksQ0FBQyxXQUFXLEVBQUU7b0JBQ2xCLElBQUksQ0FBQyxXQUFXLEVBQUU7aUJBQ3JCO2dCQUdELE9BQU8sSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLFVBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFDLENBQUMsQ0FBQyxFQUFDO29CQUM3RyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBQyxDQUFDLENBQUM7b0JBQ2pGLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFDLENBQUMsQ0FBQztvQkFDckYsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUMsQ0FBQyxDQUFDO29CQUMzRSxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNsQixJQUFJLENBQUMsV0FBVyxFQUFFO2lCQUNyQjtnQkFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsVUFBUTtnQkFDakQsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLGNBQU0sY0FBSyxFQUFMLENBQUs7Z0JBQ2pELElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxVQUFVO2FBRXhEO1lBQ0QsT0FBTyxLQUFLO1NBQ2Y7YUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFDO1lBQ2hDLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7WUFDckIsSUFBSSxDQUFDLFdBQVcsRUFBRTtTQUNyQjtRQUVELE9BQU8sS0FBSztJQUNoQixDQUFDO0lBRUQsa0NBQVcsR0FBWCxVQUFZLEtBQWE7UUFDckIsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUMsRUFBRSxHQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFHTyxrQ0FBVyxHQUFuQixVQUFvQixTQUF5QjtRQUE3QyxpQkFhQztRQVpHLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFDO1lBQ2YsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7O2dCQUM1QixJQUFJLFNBQVMsS0FBSyxNQUFNLEVBQUM7b0JBQ3JCLEtBQUksQ0FBQyxTQUFTLElBQUksSUFBSTtvQkFDdEIsS0FBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEtBQUksQ0FBQyxTQUFTO2lCQUMxRDtxQkFBTTtvQkFDSCxLQUFJLENBQUMsU0FBUyxJQUFJLElBQUk7b0JBQ3RCLEtBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxLQUFJLENBQUMsU0FBUztpQkFDMUQ7Z0JBQ0QsV0FBSSxDQUFDLElBQUksMENBQUUsY0FBYyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUM7WUFDMUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNiO0lBQ0wsQ0FBQztJQUVPLGlDQUFVLEdBQWxCO1FBQ0ksSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFDO1lBQ2xCLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO1lBQ2hDLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUztTQUNoQztJQUNMLENBQUM7SUFHTyxrQ0FBVyxHQUFuQjtRQUFBLGlCQW1CQztRQWxCRyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBQztZQUNuQixJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQzs7Z0JBQzVCLElBQUksT0FBTyxHQUFHLEtBQUs7Z0JBQ25CLElBQUksS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBQyxHQUFHLEVBQUM7b0JBQzdDLEtBQUksQ0FBQyxTQUFTLElBQUksSUFBSTtvQkFDdEIsT0FBTyxHQUFHLElBQUk7aUJBQ2pCO2dCQUNELElBQUksS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUMsR0FBRyxFQUFDO29CQUMzRSxLQUFJLENBQUMsU0FBUyxJQUFJLElBQUk7b0JBQ3RCLE9BQU8sR0FBRyxJQUFJO2lCQUNqQjtnQkFDRCxJQUFJLENBQUMsT0FBTyxFQUFDO29CQUNULEtBQUksQ0FBQyxVQUFVLEVBQUU7aUJBQ3BCO3FCQUFNO29CQUNILFdBQUksQ0FBQyxJQUFJLDBDQUFFLGNBQWMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDO2lCQUN6QztZQUNMLENBQUMsRUFBRSxFQUFFLENBQUM7U0FDVDtJQUNMLENBQUM7SUFFTyxpQ0FBVSxHQUFsQjtRQUNJLElBQUksSUFBSSxDQUFDLFlBQVksRUFBQztZQUNsQixhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUNoQyxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVM7U0FDaEM7SUFDTCxDQUFDO0lBQ0wsbUJBQUM7QUFBRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyUkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7O0FBR0EsdUJBQXVCLHNCQUFzQixxQkFBcUI7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDOzs7O0FBSUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixZQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBLCtDQUErQztBQUMvQyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBLGNBQWMsZ0JBQWdCLE9BQU87QUFDckMsY0FBYyxnQkFBZ0IsT0FBTztBQUNyQyxjQUFjLGdCQUFnQixPQUFPOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVEsT0FBTzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQiw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7O0FBRTdCLHlDQUF5Qzs7QUFFekMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRCxjQUFjLGVBQWU7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQSxNQUFNOztBQUVOLGdDQUFnQztBQUNoQzs7QUFFQSxNQUFNO0FBQ047O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUI7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IseUNBQXlDOztBQUV6Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZUFBZTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOLFdBQVcsbUNBQW1DOztBQUU5QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsaUNBQWlDO0FBQ2pDLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSSxNQUFNLEdBQUcsTUFBTSxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxLQUFLLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBLDREQUE0RDtBQUM1RCx3Q0FBd0M7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsSUFBSTtBQUNKO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsb0VBQW9FOzs7OztBQUs1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQixtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMscUNBQXFDO0FBQ3JDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qjs7O0FBR0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHFDQUFxQzs7QUFFN0MsUUFBUSx1Q0FBdUM7Ozs7QUFJL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlPOzs7Ozs7O1VDbmpOek87VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7O0FDSGlEO0FBQ0Y7QUFFL0MsTUFBTSxHQUFHO0lBQ0wsb0VBQXVCLEVBQUU7SUFDekIsK0RBQWlCLEVBQUU7QUFDdkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2RlZXBzbGF0ZS9kaXN0L2RlZXBzbGF0ZS5lc20uanMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQ0LmpzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMy5qcyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL25vZGVfbW9kdWxlcy9saXRlZ3JhcGguanMvYnVpbGQvbGl0ZWdyYXBoLmpzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vVUkvR3JhcGhNYW5hZ2VyLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vVUkvTWVudU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi9ub2Rlcy9MR3JhcGhOb2RlRml4ZWQudHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi9ub2Rlcy9jb25zdGFudF9kZW5zaXR5X2Z1bmN0aW9uLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vbm9kZXMvZGVuc2l0eV9mdW5jdGlvbi50cyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL3NyYy9tYWluL25vZGVzL2RlbnNpdHlfZnVuY3Rpb25fb3V0cHV0LnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vbm9kZXMvZGVuc2l0eV9mdW5jdGlvbl9zcGxpbmUudHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi9ub2Rlcy9uYW1lZF9kZW5zaXR5X2Z1bmN0aW9uLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vbm9kZXMvcmVnaXN0ZXIudHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi92YW5pbGxhL3NjaGVtYXMudHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi93aWRnZXRzL1NwbGluZVdpZGdldC50cyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi9hcHAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHQgZnJvbVwicGFrb1wiO2ltcG9ydHt2ZWMzIGFzIGUsbWF0NCBhcyBzLGdsTWF0cml4IGFzIGl9ZnJvbVwiZ2wtbWF0cml4XCI7dmFyIG47IWZ1bmN0aW9uKHQpe3QuVVA9XCJ1cFwiLHQuRE9XTj1cImRvd25cIix0Lk5PUlRIPVwibm9ydGhcIix0LkVBU1Q9XCJlYXN0XCIsdC5TT1VUSD1cInNvdXRoXCIsdC5XRVNUPVwid2VzdFwifShufHwobj17fSkpO2NvbnN0IHI9e1tuLlVQXTpbMCwxLDBdLFtuLkRPV05dOlswLC0xLDBdLFtuLk5PUlRIXTpbMCwwLC0xXSxbbi5FQVNUXTpbMSwwLDBdLFtuLlNPVVRIXTpbMCwwLDFdLFtuLldFU1RdOlstMSwwLDBdfTt2YXIgbzshZnVuY3Rpb24odCl7dC5BTEw9W3QuVVAsdC5ET1dOLHQuTk9SVEgsdC5FQVNULHQuU09VVEgsdC5XRVNUXSx0Lm5vcm1hbD1mdW5jdGlvbih0KXtyZXR1cm4gclt0XX19KG58fChuPXt9KSksZnVuY3Rpb24odCl7dC5jcmVhdGU9ZnVuY3Rpb24odCxlLHMpe3JldHVyblt0LGUsc119LHQub2Zmc2V0PWZ1bmN0aW9uKHQsZSxzLGkpe3JldHVyblt0WzBdK2UsdFsxXStzLHRbMl0raV19LHQudG93YXJkcz1mdW5jdGlvbihlLHMpe3JldHVybiB0Lm9mZnNldChlLC4uLm4ubm9ybWFsKHMpKX19KG98fChvPXt9KSk7Y29uc3QgYT17ZW5kOjAsYnl0ZToxLHNob3J0OjIsaW50OjMsbG9uZzo0LGZsb2F0OjUsZG91YmxlOjYsYnl0ZUFycmF5Ojcsc3RyaW5nOjgsbGlzdDo5LGNvbXBvdW5kOjEwLGludEFycmF5OjExLGxvbmdBcnJheToxMn0sbD1bXCJlbmRcIixcImJ5dGVcIixcInNob3J0XCIsXCJpbnRcIixcImxvbmdcIixcImZsb2F0XCIsXCJkb3VibGVcIixcImJ5dGVBcnJheVwiLFwic3RyaW5nXCIsXCJsaXN0XCIsXCJjb21wb3VuZFwiLFwiaW50QXJyYXlcIixcImxvbmdBcnJheVwiXTtjbGFzcyBoe2NvbnN0cnVjdG9yKHQsZT0hMSl7dGhpcy5ieXRlPXRoaXMucmVhZE51bS5iaW5kKHRoaXMsXCJnZXRJbnQ4XCIsMSksdGhpcy5zaG9ydD10aGlzLnJlYWROdW0uYmluZCh0aGlzLFwiZ2V0SW50MTZcIiwyKSx0aGlzLmludD10aGlzLnJlYWROdW0uYmluZCh0aGlzLFwiZ2V0SW50MzJcIiw0KSx0aGlzLmZsb2F0PXRoaXMucmVhZE51bS5iaW5kKHRoaXMsXCJnZXRGbG9hdDMyXCIsNCksdGhpcy5kb3VibGU9dGhpcy5yZWFkTnVtLmJpbmQodGhpcyxcImdldEZsb2F0NjRcIiw4KSx0aGlzLm9mZnNldD0wLHRoaXMubGl0dGxlRW5kaWFuPWUsdGhpcy5hcnJheVZpZXc9dCx0aGlzLmRhdGFWaWV3PW5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQpfWVuZCgpe3JldHVybiBudWxsfXJlYWROdW0odCxlKXtjb25zdCBzPXRoaXMuZGF0YVZpZXdbdF0odGhpcy5vZmZzZXQsdGhpcy5saXR0bGVFbmRpYW4pO3JldHVybiB0aGlzLm9mZnNldCs9ZSxzfWxvbmcoKXtyZXR1cm5bdGhpcy5pbnQoKSx0aGlzLmludCgpXX1ieXRlQXJyYXkoKXtjb25zdCB0PXRoaXMuaW50KCksZT1bXTtmb3IobGV0IHM9MDtzPHQ7cysrKWUucHVzaCh0aGlzLmJ5dGUoKSk7cmV0dXJuIGV9aW50QXJyYXkoKXtjb25zdCB0PXRoaXMuaW50KCksZT1bXTtmb3IobGV0IHM9MDtzPHQ7cysrKWUucHVzaCh0aGlzLmludCgpKTtyZXR1cm4gZX1sb25nQXJyYXkoKXtjb25zdCB0PXRoaXMuaW50KCksZT1bXTtmb3IobGV0IHM9MDtzPHQ7cysrKWUucHVzaCh0aGlzLmxvbmcoKSk7cmV0dXJuIGV9c3RyaW5nKCl7Y29uc3QgdD10aGlzLnNob3J0KCksZT10aGlzLmFycmF5Vmlldy5zbGljZSh0aGlzLm9mZnNldCx0aGlzLm9mZnNldCt0KTtyZXR1cm4gdGhpcy5vZmZzZXQrPXQsZnVuY3Rpb24odCl7dmFyIGUscz1bXTtmb3IoZT0wO2U8dC5sZW5ndGg7ZSsrKTA9PSgxMjgmdFtlXSk/cy5wdXNoKDEyNyZ0W2VdKTplKzE8dC5sZW5ndGgmJjE5Mj09KDIyNCZ0W2VdKSYmMTI4PT0oMTkyJnRbZSsxXSk/cy5wdXNoKCgzMSZ0W2VdKTw8Nnw2MyZ0W2UrMV0pOmUrMjx0Lmxlbmd0aCYmMjI0PT0oMjQwJnRbZV0pJiYxMjg9PSgxOTImdFtlKzFdKSYmMTI4PT0oMTkyJnRbZSsyXSk/cy5wdXNoKCgxNSZ0W2VdKTw8MTJ8KDYzJnRbZSsxXSk8PDZ8NjMmdFtlKzJdKTplKzM8dC5sZW5ndGgmJjI0MD09KDI0OCZ0W2VdKSYmMTI4PT0oMTkyJnRbZSsxXSkmJjEyOD09KDE5MiZ0W2UrMl0pJiYxMjg9PSgxOTImdFtlKzNdKSYmcy5wdXNoKCg3JnRbZV0pPDwxOHwoNjMmdFtlKzFdKTw8MTJ8KDYzJnRbZSsyXSk8PDZ8NjMmdFtlKzNdKTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHMpfShlKX1saXN0KCl7Y29uc3QgdD1sW3RoaXMuYnl0ZSgpXSxlPXRoaXMuaW50KCkscz1bXTtmb3IobGV0IGk9MDtpPGU7aSsrKXMucHVzaCh0aGlzW3RdKCkpO3JldHVybnt0eXBlOnQsdmFsdWU6c319Y29tcG91bmQoKXtjb25zdCB0PXt9O2Zvcig7Oyl7Y29uc3QgZT1sW3RoaXMuYnl0ZSgpXTtpZihcImVuZFwiPT09ZSlicmVhaztjb25zdCBzPXRoaXMuc3RyaW5nKCksaT10aGlzW2VdKCk7dFtzXT17dHlwZTplLHZhbHVlOml9fXJldHVybiB0fX1jbGFzcyB1e2NvbnN0cnVjdG9yKHQ9ITEpe3RoaXMuYnl0ZT10aGlzLndyaXRlTnVtLmJpbmQodGhpcyxcInNldEludDhcIiwxKSx0aGlzLnNob3J0PXRoaXMud3JpdGVOdW0uYmluZCh0aGlzLFwic2V0SW50MTZcIiwyKSx0aGlzLmludD10aGlzLndyaXRlTnVtLmJpbmQodGhpcyxcInNldEludDMyXCIsNCksdGhpcy5mbG9hdD10aGlzLndyaXRlTnVtLmJpbmQodGhpcyxcInNldEZsb2F0MzJcIiw0KSx0aGlzLmRvdWJsZT10aGlzLndyaXRlTnVtLmJpbmQodGhpcyxcInNldEZsb2F0NjRcIiw4KSx0aGlzLm9mZnNldD0wLHRoaXMubGl0dGxlRW5kaWFuPXQsdGhpcy5idWZmZXI9bmV3IEFycmF5QnVmZmVyKDEwMjQpLHRoaXMuYXJyYXlWaWV3PW5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSx0aGlzLmRhdGFWaWV3PW5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcil9YWNjb21tb2RhdGUodCl7Y29uc3QgZT10aGlzLm9mZnNldCt0O2lmKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg+PWUpcmV0dXJuO2xldCBzPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Zm9yKDtzPGU7KXMqPTI7Y29uc3QgaT1uZXcgQXJyYXlCdWZmZXIocyksbj1uZXcgVWludDhBcnJheShpKTtuLnNldCh0aGlzLmFycmF5VmlldyksdGhpcy5vZmZzZXQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCYmbi5maWxsKDAsdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCx0aGlzLm9mZnNldCksdGhpcy5idWZmZXI9aSx0aGlzLmRhdGFWaWV3PW5ldyBEYXRhVmlldyhpKSx0aGlzLmFycmF5Vmlldz1ufWdldERhdGEoKXtyZXR1cm4gdGhpcy5hY2NvbW1vZGF0ZSgwKSx0aGlzLmFycmF5Vmlldy5zbGljZSgwLHRoaXMub2Zmc2V0KX1lbmQodCl7fXdyaXRlTnVtKHQsZSxzKXt0aGlzLmFjY29tbW9kYXRlKGUpLHRoaXMuZGF0YVZpZXdbdF0odGhpcy5vZmZzZXQscyx0aGlzLmxpdHRsZUVuZGlhbiksdGhpcy5vZmZzZXQrPWV9bG9uZyh0KXt0aGlzLmludCh0WzBdKSx0aGlzLmludCh0WzFdKX1ieXRlQXJyYXkodCl7dGhpcy5pbnQodC5sZW5ndGgpLHRoaXMuYWNjb21tb2RhdGUodC5sZW5ndGgpLHRoaXMuYXJyYXlWaWV3LnNldCh0LHRoaXMub2Zmc2V0KSx0aGlzLm9mZnNldCs9dC5sZW5ndGh9aW50QXJyYXkodCl7dGhpcy5pbnQodC5sZW5ndGgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMuaW50KHRbZV0pfWxvbmdBcnJheSh0KXt0aGlzLmludCh0Lmxlbmd0aCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdGhpcy5sb25nKHRbZV0pfXN0cmluZyh0KXtjb25zdCBlPWZ1bmN0aW9uKHQpe3ZhciBlLHMsaT1bXTtmb3IoZT0wO2U8dC5sZW5ndGg7ZSsrKShzPXQuY2hhckNvZGVBdChlKSk8MTI4P2kucHVzaChzKTpzPDIwNDg/KGkucHVzaCgxOTJ8cz4+NiksaS5wdXNoKDEyOHw2MyZzKSk6czw2NTUzNj8oaS5wdXNoKDIyNHxzPj4xMiksaS5wdXNoKDEyOHxzPj42JjYzKSxpLnB1c2goMTI4fDYzJnMpKTooaS5wdXNoKDI0MHxzPj4xOCY3KSxpLnB1c2goMTI4fHM+PjEyJjYzKSxpLnB1c2goMTI4fHM+PjYmNjMpLGkucHVzaCgxMjh8NjMmcykpO3JldHVybiBpfSh0KTt0aGlzLnNob3J0KGUubGVuZ3RoKSx0aGlzLmFjY29tbW9kYXRlKGUubGVuZ3RoKSx0aGlzLmFycmF5Vmlldy5zZXQoZSx0aGlzLm9mZnNldCksdGhpcy5vZmZzZXQrPWUubGVuZ3RofWxpc3QodCl7dGhpcy5ieXRlKGFbdC50eXBlXSksdGhpcy5pbnQodC52YWx1ZS5sZW5ndGgpLHQudmFsdWU7Zm9yKGxldCBlPTA7ZTx0LnZhbHVlLmxlbmd0aDtlKyspdGhpc1t0LnR5cGVdKHQudmFsdWVbZV0pfWNvbXBvdW5kKHQpe2Zvcihjb25zdCBlIGluIHQpdGhpcy5ieXRlKGFbdFtlXS50eXBlXSksdGhpcy5zdHJpbmcoZSksdGhpc1t0W2VdLnR5cGVdKHRbZV0udmFsdWUpO3RoaXMuYnl0ZShhLmVuZCl9fWZ1bmN0aW9uIGModCxlKXtjb25zdCBzPW5ldyBoKHQsZSk7aWYocy5ieXRlKCkhPT1hLmNvbXBvdW5kKXRocm93IG5ldyBFcnJvcihcIlRvcCB0YWcgc2hvdWxkIGJlIGEgY29tcG91bmRcIik7cmV0dXJue25hbWU6cy5zdHJpbmcoKSx2YWx1ZTpzLmNvbXBvdW5kKCl9fWZ1bmN0aW9uIGQoZSxzKXtyZXR1cm4gYyh0LmluZmxhdGUoZSkscyl9ZnVuY3Rpb24gZih0LGUpe3JldHVybiAyPT09KHM9bmV3IFVpbnQ4QXJyYXkodC5zbGljZSgwLDIpKSkubGVuZ3RoJiYzMT09PXNbMF0mJjEzOT09PXNbMV0/e2NvbXByZXNzZWQ6ITAscmVzdWx0OmQodCxlKX06e2NvbXByZXNzZWQ6ITEscmVzdWx0OmModCxlKX07dmFyIHN9ZnVuY3Rpb24gZyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgcz0wO3M8MzI7cys9MSlmb3IobGV0IGk9MDtpPDMyO2krPTEpe2NvbnN0IG49NCooKDMxJnMpKzMyKigzMSZpKSk7aWYoMD09PXRbbiszXSljb250aW51ZTtjb25zdCByPSh0W25dPDwxNikrKHRbbisxXTw8OCkrdFtuKzJdLG89KHRbbis0MDk2XTw8MjQpKyh0W24rNDA5N108PDE2KSsodFtuKzQwOThdPDw4KSt0W24rNDA5OV0sYT00MDk2KnIsbD0odFthXTw8MjQpKyh0W2ErMV08PDE2KSsodFthKzJdPDw4KSt0W2ErM10saD10W2ErNF0sdT10LnNsaWNlKGErNSxhKzQrbCk7ZS5wdXNoKHt4OnMsejppLHRpbWVzdGFtcDpvLGNvbXByZXNzaW9uOmgsZGF0YTp1fSl9cmV0dXJuIGV9ZnVuY3Rpb24gcCh0LGUscyl7Y29uc3QgaT14KHQsZSxzKTtzd2l0Y2goaS5jb21wcmVzc2lvbil7Y2FzZSAxOmNhc2UgMjppLm5idD1kKGkuZGF0YSk7YnJlYWs7Y2FzZSAzOmkubmJ0PWMoaS5kYXRhKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21wcmVzc2lvbiBtb2RlICR7aS5jb21wcmVzc2lvbn1gKX1yZXR1cm4gaX1mdW5jdGlvbiBtKHQsZSl7Y29uc3Qgcz1uZXcgdShlKTtyZXR1cm4gcy5ieXRlKGEuY29tcG91bmQpLHMuc3RyaW5nKHQubmFtZSkscy5jb21wb3VuZCh0LnZhbHVlKSxzLmdldERhdGEoKX1mdW5jdGlvbiB2KGUscyxpKXtjb25zdCBuPW0oZSxzKTtyZXR1cm4gdFtpP1wiZGVmbGF0ZVwiOlwiZ3ppcFwiXShuKX1mdW5jdGlvbiBiKHQsZSxzKXtyZXR1cm4gZT92KHQscyk6bSh0LHMpfWZ1bmN0aW9uIHcodCl7bGV0IGU9MDtmb3IoY29uc3QgcyBvZiB0KWUrPU1hdGguY2VpbChzLmRhdGEubGVuZ3RoLzQwOTYpO2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkoODE5Mis0MDk2KmUpLGk9bmV3IERhdGFWaWV3KHMuYnVmZmVyKTtsZXQgbj0yO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9NCooKDMxJmUueCkrMzIqKDMxJmUueikpLHI9TWF0aC5jZWlsKGUuZGF0YS5sZW5ndGgvNDA5Nik7aS5zZXRJbnQ4KHQsbj4+MTYpLGkuc2V0SW50MTYodCsxLDY1NTM1Jm4pLGkuc2V0SW50OCh0KzMsciksaS5zZXRJbnQzMih0KzQwOTYsZS50aW1lc3RhbXApO2NvbnN0IG89NDA5NipuO2kuc2V0SW50MzIobyxlLmRhdGEubGVuZ3RoKzEpLGkuc2V0SW50OChvKzQsZS5jb21wcmVzc2lvbikscy5zZXQoZS5kYXRhLG8rNSksbis9cn1yZXR1cm4gc31mdW5jdGlvbiBQKHQsZSxzLGkpe2NvbnN0IG49eCh0LGUscyk7c3dpdGNoKG4uY29tcHJlc3Npb24pe2Nhc2UgMTpuLmRhdGE9dihpKTticmVhaztjYXNlIDI6bi5kYXRhPXYoaSwhMSwhMCk7YnJlYWs7Y2FzZSAzOm4uZGF0YT1tKGkpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbXByZXNzaW9uIG1vZGUgJHtuLmNvbXByZXNzaW9ufWApfXJldHVybiBufWZ1bmN0aW9uIHgodCxlLHMpe2NvbnN0IGk9dC5maW5kKCh0PT50Lng9PT1lJiZ0Lno9PT1zKSk7aWYodm9pZCAwPT09aSl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGNodW5rIFske2V9LCAke3N9XWApO3JldHVybiBpfWZ1bmN0aW9uIHkodCxlLHMpe2lmKCF0W2VdKXRocm93IG5ldyBFcnJvcihgTWlzc2luZyAke2V9IHRhZ2ApO2lmKHRbZV0udHlwZSE9PXMpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2V9IHRvIGJlIG9mIHR5cGUgJHtzfSwgYnV0IGZvdW5kICR7dFtlXS50eXBlfWApO3JldHVybiB0W2VdLnZhbHVlfWZ1bmN0aW9uIEEodCxlLHMsaSl7Y29uc3Qgbj15KHQsZSxcImxpc3RcIik7aWYobi50eXBlIT09cyl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7ZX0gdG8gYmUgYSBsaXN0IG9mICR7c31zLCBidXQgZm91bmQgJHtuLnR5cGV9c2ApO2lmKGkmJm4udmFsdWUubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7ZX0gdG8gYmUgYSBsaXN0IG9mIGxlbmd0aCAke2l9LCBidXQgZm91bmQgbGVuZ3RoICR7bi52YWx1ZS5sZW5ndGh9YCk7cmV0dXJuIG4udmFsdWV9ZnVuY3Rpb24gUyh0LGUpe3RyeXtyZXR1cm4gdCgpfWNhdGNoKHQpe3JldHVybiBlfX1jbGFzcyBCe2NvbnN0cnVjdG9yKHQsZT17fSl7dGhpcy5uYW1lPXQsdGhpcy5wcm9wZXJ0aWVzPWV9Z2V0TmFtZSgpe3JldHVybiB0aGlzLm5hbWV9Z2V0UHJvcGVydGllcygpe3JldHVybiB0aGlzLnByb3BlcnRpZXN9Z2V0UHJvcGVydHkodCl7cmV0dXJuIHRoaXMucHJvcGVydGllc1t0XX1pc0ZsdWlkKCl7cmV0dXJuXCJtaW5lY3JhZnQ6d2F0ZXJcIj09PXRoaXMubmFtZXx8XCJtaW5lY3JhZnQ6bGF2YVwiPT09dGhpcy5uYW1lfWVxdWFscyh0KXtyZXR1cm4gdGhpcy5uYW1lPT09dC5uYW1lJiZPYmplY3Qua2V5cyh0aGlzLnByb3BlcnRpZXMpLmV2ZXJ5KChlPT50LnByb3BlcnRpZXNbZV09PT10aGlzLnByb3BlcnRpZXNbZV0pKX10b1N0cmluZygpe3JldHVybiAwPT09T2JqZWN0LmtleXModGhpcy5wcm9wZXJ0aWVzKS5sZW5ndGg/dGhpcy5uYW1lOmAke3RoaXMubmFtZX1bJHtPYmplY3QuZW50cmllcyh0aGlzLnByb3BlcnRpZXMpLm1hcCgoKFt0LGVdKT0+dCtcIj1cIitlKSkuam9pbihcIixcIil9XWB9c3RhdGljIGZyb21OYnQodCl7Y29uc3QgZT15KHQudmFsdWUsXCJOYW1lXCIsXCJzdHJpbmdcIikscz1TKCgoKT0+eSh0LnZhbHVlLFwiUHJvcGVydGllc1wiLFwiY29tcG91bmRcIikpLHt9KSxpPU9iamVjdC5rZXlzKHMpLnJlZHVjZSgoKHQsZSk9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W2VdOnkocyxlLFwic3RyaW5nXCIpfSkpLHt9KTtyZXR1cm4gbmV3IEIoZSxpKX1zdGF0aWMgZnJvbUpzb24odCl7dmFyIGUscztjb25zdCBpPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e30sbj1udWxsIT09KHM9ay5yZWFkU3RyaW5nKGkuTmFtZSkpJiZ2b2lkIDAhPT1zP3M6XCJtaW5lY3JhZnQ6c3RvbmVcIixyPWsucmVhZE1hcChpLlByb3BlcnRpZXMsKHQ9Pnt2YXIgZTtyZXR1cm4gbnVsbCE9PShlPWsucmVhZFN0cmluZyh0KSkmJnZvaWQgMCE9PWU/ZTpcIlwifSkpO3JldHVybiBuZXcgQihuLHIpfX1CLkFJUj1uZXcgQihcIm1pbmVjcmFmdDphaXJcIik7Y2xhc3MgRXtjb25zdHJ1Y3Rvcih0KXt0aGlzLm1pblk9dCx0aGlzLnN0b3JhZ2U9QXJyYXkoRS5TSVpFKSx0aGlzLnBhbGV0dGU9W0IuQUlSXX1nZXQgbWluQmxvY2tZKCl7cmV0dXJuIHRoaXMubWluWTw8NH1pbmRleCh0LGUscyl7cmV0dXJuKHQ8PDgpKyhlPDw0KStzfWdldEJsb2NrU3RhdGUodCxlLHMpe3ZhciBpO2NvbnN0IG49dGhpcy5zdG9yYWdlW3RoaXMuaW5kZXgodCxlLHMpXTtyZXR1cm4gbnVsbCE9PShpPXRoaXMucGFsZXR0ZVtuXSkmJnZvaWQgMCE9PWk/aTpCLkFJUn1zZXRCbG9ja1N0YXRlKHQsZSxzLGkpe2xldCBuPXRoaXMucGFsZXR0ZS5maW5kSW5kZXgoKHQ9PnQuZXF1YWxzKGkpKSk7LTE9PT1uJiYobj10aGlzLnBhbGV0dGUubGVuZ3RoLHRoaXMucGFsZXR0ZS5wdXNoKGkpKSx0aGlzLnN0b3JhZ2VbdGhpcy5pbmRleCh0LGUscyldPW59fUUuV0lEVEg9MTYsRS5TSVpFPUUuV0lEVEgqRS5XSURUSCpFLldJRFRIO2NsYXNzIEN7Y29uc3RydWN0b3IodCxlLHMpe3RoaXMubWluWT10LHRoaXMuaGVpZ2h0PWUsdGhpcy5wb3M9cyx0aGlzLnNlY3Rpb25zPUFycmF5KHRoaXMuc2VjdGlvbnNDb3VudCkuZmlsbChudWxsKX1nZXQgbWF4WSgpe3JldHVybiB0aGlzLm1pblkrdGhpcy5oZWlnaHR9Z2V0IG1pblNlY3Rpb24oKXtyZXR1cm4gdGhpcy5taW5ZPj40fWdldCBtYXhTZWN0aW9uKCl7cmV0dXJuIDErKHRoaXMubWF4WS0xPj40KX1nZXQgc2VjdGlvbnNDb3VudCgpe3JldHVybiB0aGlzLm1heFNlY3Rpb24tdGhpcy5taW5TZWN0aW9ufWdldFNlY3Rpb25JbmRleCh0KXtyZXR1cm4odD4+NCktdGhpcy5taW5TZWN0aW9ufWdldEJsb2NrU3RhdGUodCl7dmFyIGU7Y29uc3RbcyxpLG5dPXQscj10aGlzLnNlY3Rpb25zW3RoaXMuZ2V0U2VjdGlvbkluZGV4KGkpXTtyZXR1cm4gbnVsbCE9PShlPW51bGw9PXI/dm9pZCAwOnIuZ2V0QmxvY2tTdGF0ZSgxNSZzLDE1JmksMTUmbikpJiZ2b2lkIDAhPT1lP2U6Qi5BSVJ9c2V0QmxvY2tTdGF0ZSh0LGUpe2NvbnN0W3MsaSxuXT10LHI9dGhpcy5nZXRTZWN0aW9uSW5kZXgoaSk7bGV0IG89dGhpcy5zZWN0aW9uc1tyXTtpZihudWxsPT09byl7aWYoZS5lcXVhbHMoQi5BSVIpKXJldHVybjtvPXRoaXMuZ2V0T3JDcmVhdGVTZWN0aW9uKHIpfW8uc2V0QmxvY2tTdGF0ZSgxNSZzLDE1JmksMTUmbixlKX1nZXRPckNyZWF0ZVNlY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuc2VjdGlvbnNbdF0mJih0aGlzLnNlY3Rpb25zW3RdPW5ldyBFKHRoaXMubWluU2VjdGlvbit0KSksdGhpcy5zZWN0aW9uc1t0XX19dmFyIEksayxSOyFmdW5jdGlvbih0KXt0LmNyZWF0ZT1mdW5jdGlvbih0LGUpe3JldHVyblt0LGVdfSx0LmZyb21CbG9ja1Bvcz1mdW5jdGlvbih0KXtyZXR1cm5bdFswXT4+NCx0WzJdPj40XX0sdC5mcm9tTG9uZz1mdW5jdGlvbih0KXtyZXR1cm5bNDI5NDk2NzI5NSZOdW1iZXIodCksTnVtYmVyKHQ+PkJpZ0ludCgzMikpXX0sdC5taW5CbG9ja1g9ZnVuY3Rpb24odCl7cmV0dXJuIHRbMF08PDR9LHQubWluQmxvY2taPWZ1bmN0aW9uKHQpe3JldHVybiB0WzFdPDw0fSx0Lm1heEJsb2NrWD1mdW5jdGlvbih0KXtyZXR1cm4gdFswXTw8MTl9LHQubWF4QmxvY2taPWZ1bmN0aW9uKHQpe3JldHVybiB0WzFdPDwxOX19KEl8fChJPXt9KSksZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQ/dDp2b2lkIDB9dC5yZWFkTnVtYmVyPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P3Q6dm9pZCAwfSx0LnJlYWRJbnQ9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/TWF0aC5mbG9vcih0KTp2b2lkIDB9LHQucmVhZFN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90OnZvaWQgMH0sdC5yZWFkQm9vbGVhbj1mdW5jdGlvbih0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHQ/dDp2b2lkIDB9LHQucmVhZE9iamVjdD1lLHQucmVhZEFycmF5PWZ1bmN0aW9uKHQsZSl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PmUodCkpKX0sdC5yZWFkTWFwPWZ1bmN0aW9uKHQscyl7dmFyIGk7Y29uc3Qgbj1udWxsIT09KGk9ZSh0KSkmJnZvaWQgMCE9PWk/aTp7fTtyZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG4pLm1hcCgoKFt0LGVdKT0+W3QscyhlKV0pKSl9LHQuY29tcG9zZT1mdW5jdGlvbih0LGUscyl7Y29uc3QgaT1lKHQpO3JldHVybiBpP3MoaSk6dm9pZCAwfX0oa3x8KGs9e30pKTtjbGFzcyBfe2NvbnN0cnVjdG9yKHQsZT1bXSxzPVtdKXt0aGlzLnNpemU9dCx0aGlzLnBhbGV0dGU9ZSx0aGlzLmJsb2Nrcz1zLHRoaXMuYmxvY2tzTWFwPVtdLHMuZm9yRWFjaCgoZT0+e2lmKCF0aGlzLmlzSW5zaWRlKGUucG9zKSl0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGJsb2NrIGF0ICR7ZS5wb3N9IHdoaWNoIGlzIG91dHNpZGUgdGhlIHN0cnVjdHVyZSBib3VuZHMgJHt0aGlzLnNpemV9YCk7dGhpcy5ibG9ja3NNYXBbZS5wb3NbMF0qdFsxXSp0WzJdK2UucG9zWzFdKnRbMl0rZS5wb3NbMl1dPWV9KSl9Z2V0U2l6ZSgpe3JldHVybiB0aGlzLnNpemV9YWRkQmxvY2sodCxlLHMsaSl7aWYoIXRoaXMuaXNJbnNpZGUodCkpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGJsb2NrIGF0ICR7dH0gb3V0c2lkZSB0aGUgc3RydWN0dXJlIGJvdW5kcyAke3RoaXMuc2l6ZX1gKTtjb25zdCBuPW5ldyBCKGUscyk7bGV0IHI9dGhpcy5wYWxldHRlLmZpbmRJbmRleCgodD0+dC5lcXVhbHMobikpKTtyZXR1cm4tMT09PXImJihyPXRoaXMucGFsZXR0ZS5sZW5ndGgsdGhpcy5wYWxldHRlLnB1c2gobikpLHRoaXMuYmxvY2tzLnB1c2goe3Bvczp0LHN0YXRlOnIsbmJ0Oml9KSx0aGlzLmJsb2Nrc01hcFt0WzBdKnRoaXMuc2l6ZVsxXSp0aGlzLnNpemVbMl0rdFsxXSp0aGlzLnNpemVbMl0rdFsyXV09e3Bvczp0LHN0YXRlOnIsbmJ0Oml9LHRoaXN9Z2V0QmxvY2tzKCl7cmV0dXJuIHRoaXMuYmxvY2tzLm1hcCgodD0+KHtwb3M6dC5wb3Msc3RhdGU6dGhpcy5wYWxldHRlW3Quc3RhdGVdLG5idDp0Lm5idH0pKSl9Z2V0QmxvY2sodCl7aWYoIXRoaXMuaXNJbnNpZGUodCkpcmV0dXJuIG51bGw7Y29uc3QgZT10aGlzLmJsb2Nrc01hcFt0WzBdKnRoaXMuc2l6ZVsxXSp0aGlzLnNpemVbMl0rdFsxXSp0aGlzLnNpemVbMl0rdFsyXV07aWYoIWUpcmV0dXJuIG51bGw7cmV0dXJue3BvczplLnBvcyxzdGF0ZTp0aGlzLnBhbGV0dGVbZS5zdGF0ZV0sbmJ0OmUubmJ0fX1pc0luc2lkZSh0KXtyZXR1cm4gdFswXT49MCYmdFswXTx0aGlzLnNpemVbMF0mJnRbMV0+PTAmJnRbMV08dGhpcy5zaXplWzFdJiZ0WzJdPj0wJiZ0WzJdPHRoaXMuc2l6ZVsyXX1zdGF0aWMgZnJvbU5idCh0KXtjb25zdCBlPUEodC52YWx1ZSxcInNpemVcIixcImludFwiLDMpLHM9QSh0LnZhbHVlLFwicGFsZXR0ZVwiLFwiY29tcG91bmRcIikubWFwKCh0PT5CLmZyb21OYnQoe25hbWU6XCJcIix2YWx1ZTp0fSkpKSxpPUEodC52YWx1ZSxcImJsb2Nrc1wiLFwiY29tcG91bmRcIikubWFwKCh0PT4oe3BvczpBKHQsXCJwb3NcIixcImludFwiLDMpLHN0YXRlOnkodCxcInN0YXRlXCIsXCJpbnRcIiksbmJ0OlMoKCgpPT55KHQsXCJuYnRcIixcImNvbXBvdW5kXCIpKSx2b2lkIDApfSkpKTtyZXR1cm4gbmV3IF8oZSxzLGkpfX1mdW5jdGlvbiBGKHQpe3JldHVybiB0KnR9ZnVuY3Rpb24gTSh0LGUscyl7cmV0dXJuIE1hdGgubWF4KGUsTWF0aC5taW4ocyx0KSl9ZnVuY3Rpb24gTih0LGUscyl7cmV0dXJuIGUrdCoocy1lKX1mdW5jdGlvbiBUKHQsZSxzLGksbixyKXtyZXR1cm4gTihlLE4odCxzLGkpLE4odCxuLHIpKX1mdW5jdGlvbiBPKHQsZSxzLGksbixyLG8sYSxsLGgsdSl7cmV0dXJuIE4ocyxUKHQsZSxpLG4scixvKSxUKHQsZSxhLGwsaCx1KSl9ZnVuY3Rpb24gVSh0LGUscyl7cmV0dXJuIHM8MD90OnM+MT9lOk4ocyx0LGUpfWZ1bmN0aW9uIEQodCl7cmV0dXJuIHQqdCp0Kih0Kig2KnQtMTUpKzEwKX1mdW5jdGlvbiBMKHQsZSxzKXtsZXQgaT1lLXQ7Zm9yKDtpPjA7KXtjb25zdCBlPU1hdGguZmxvb3IoaS8yKSxuPXQrZTtzKG4pP2k9ZToodD1uKzEsaS09ZSsxKX1yZXR1cm4gdH1jbGFzcyB6e2NvbnN0cnVjdG9yKHQpe3RoaXMueG89MjU2KnQubmV4dERvdWJsZSgpLHRoaXMueW89MjU2KnQubmV4dERvdWJsZSgpLHRoaXMuem89MjU2KnQubmV4dERvdWJsZSgpLHRoaXMucD1BcnJheSgyNTYpO2ZvcihsZXQgdD0wO3Q8MjU2O3QrPTEpdGhpcy5wW3RdPXQ7Zm9yKGxldCBlPTA7ZTwyNTY7ZSs9MSl7Y29uc3Qgcz10Lm5leHRJbnQoMjU2LWUpLGk9dGhpcy5wW2VdO3RoaXMucFtlXT10aGlzLnBbZStzXSx0aGlzLnBbZStzXT1pfX1zYW1wbGUyRCh0LGUpe2xldCBzLGksbjtjb25zdCByPSh0K2UpKnouRjIsbz1NYXRoLmZsb29yKHQrciksYT10LShvLShzPShvKyhpPU1hdGguZmxvb3IoZStyKSkpKnouRzIpKTtsZXQgbCxoO2E+KG49ZS0oaS1zKSk/KGw9MSxoPTApOihsPTAsaD0xKTtjb25zdCB1PWEtbCt6LkcyLGM9bi1oK3ouRzIsZD1hLTErMip6LkcyLGY9bi0xKzIqei5HMixnPTI1NSZvLHA9MjU1JmksbT10aGlzLlAoZyt0aGlzLlAocCkpJTEyLHY9dGhpcy5QKGcrbCt0aGlzLlAocCtoKSklMTIsYj10aGlzLlAoZysxK3RoaXMuUChwKzEpKSUxMjtyZXR1cm4gNzAqKHRoaXMuZ2V0Q29ybmVyTm9pc2UzRChtLGEsbiwwLC41KSt0aGlzLmdldENvcm5lck5vaXNlM0Qodix1LGMsMCwuNSkrdGhpcy5nZXRDb3JuZXJOb2lzZTNEKGIsZCxmLDAsLjUpKX1zYW1wbGUodCxlLHMpe2NvbnN0IGk9LjMzMzMzMzMzMzMzMzMzMzMqKHQrZStzKSxuPU1hdGguZmxvb3IodCtpKSxyPU1hdGguZmxvb3IoZStpKSxvPU1hdGguZmxvb3IocytpKSxhPS4xNjY2NjY2NjY2NjY2NjY2NioobityK28pLGw9dC0obi1hKSxoPWUtKHItYSksdT1zLShvLWEpO2xldCBjLGQsZixnLHAsbTtsPj1oP2g+PXU/KGM9MSxkPTAsZj0wLGc9MSxwPTEsbT0wKTpsPj11PyhjPTEsZD0wLGY9MCxnPTEscD0wLG09MSk6KGM9MCxkPTAsZj0xLGc9MSxwPTAsbT0xKTpoPHU/KGM9MCxkPTAsZj0xLGc9MCxwPTEsbT0xKTpsPHU/KGM9MCxkPTEsZj0wLGc9MCxwPTEsbT0xKTooYz0wLGQ9MSxmPTAsZz0xLHA9MSxtPTApO2NvbnN0IHY9bC1jKy4xNjY2NjY2NjY2NjY2NjY2NixiPWgtZCsuMTY2NjY2NjY2NjY2NjY2NjYsdz11LWYrLjE2NjY2NjY2NjY2NjY2NjY2LFA9bC1nKy4zMzMzMzMzMzMzMzMzMzMzLHg9aC1wKy4zMzMzMzMzMzMzMzMzMzMzLHk9dS1tKy4zMzMzMzMzMzMzMzMzMzMzLEE9bC0uNSxTPWgtLjUsQj11LS41LEU9MjU1Jm4sQz0yNTUmcixJPTI1NSZvLGs9dGhpcy5QKEUrdGhpcy5QKEMrdGhpcy5QKEkpKSklMTIsUj10aGlzLlAoRStjK3RoaXMuUChDK2QrdGhpcy5QKEkrZikpKSUxMixfPXRoaXMuUChFK2crdGhpcy5QKEMrcCt0aGlzLlAoSSttKSkpJTEyLEY9dGhpcy5QKEUrMSt0aGlzLlAoQysxK3RoaXMuUChJKzEpKSklMTI7cmV0dXJuIDMyKih0aGlzLmdldENvcm5lck5vaXNlM0QoayxsLGgsdSwuNikrdGhpcy5nZXRDb3JuZXJOb2lzZTNEKFIsdixiLHcsLjYpK3RoaXMuZ2V0Q29ybmVyTm9pc2UzRChfLFAseCx5LC42KSt0aGlzLmdldENvcm5lck5vaXNlM0QoRixBLFMsQiwuNikpfVAodCl7cmV0dXJuIHRoaXMucFsyNTUmdF19Z2V0Q29ybmVyTm9pc2UzRCh0LGUscyxpLG4pe2xldCByLG89bi1lKmUtcypzLWkqaTtyZXR1cm4gbzwwP3I9MDoobyo9byxyPW8qbyp6LmdyYWREb3QodCxlLHMsaSkpLHJ9c3RhdGljIGdyYWREb3QodCxlLHMsaSl7Y29uc3Qgbj16LkdSQURJRU5UWzE1JnRdO3JldHVybiBuWzBdKmUrblsxXSpzK25bMl0qaX19ei5HUkFESUVOVD1bWzEsMSwwXSxbLTEsMSwwXSxbMSwtMSwwXSxbLTEsLTEsMF0sWzEsMCwxXSxbLTEsMCwxXSxbMSwwLC0xXSxbLTEsMCwtMV0sWzAsMSwxXSxbMCwtMSwxXSxbMCwxLC0xXSxbMCwtMSwtMV0sWzEsMSwwXSxbMCwtMSwxXSxbLTEsMSwwXSxbMCwtMSwtMV1dLHouRjI9LjUqKE1hdGguc3FydCgzKS0xKSx6LkcyPSgzLU1hdGguc3FydCgzKSkvNjtjbGFzcyBWe2NvbnN0cnVjdG9yKHQpe3RoaXMueG89MjU2KnQubmV4dERvdWJsZSgpLHRoaXMueW89MjU2KnQubmV4dERvdWJsZSgpLHRoaXMuem89MjU2KnQubmV4dERvdWJsZSgpLHRoaXMucD1BcnJheSgyNTYpO2ZvcihsZXQgdD0wO3Q8MjU2O3QrPTEpdGhpcy5wW3RdPXQ+MTI3P3QtMjU2OnQ7Zm9yKGxldCBlPTA7ZTwyNTY7ZSs9MSl7Y29uc3Qgcz10Lm5leHRJbnQoMjU2LWUpLGk9dGhpcy5wW2VdO3RoaXMucFtlXT10aGlzLnBbZStzXSx0aGlzLnBbZStzXT1pfX1zYW1wbGUodCxlLHMsaT0wLG49MCl7Y29uc3Qgcj10K3RoaXMueG8sbz1lK3RoaXMueW8sYT1zK3RoaXMuem8sbD1NYXRoLmZsb29yKHIpLGg9TWF0aC5mbG9vcihvKSx1PU1hdGguZmxvb3IoYSksYz1yLWwsZD1vLWgsZj1hLXU7bGV0IGc9MDtpZigwIT09aSl7Y29uc3QgdD1uPj0wJiZuPGQ/bjpkO2c9TWF0aC5mbG9vcih0L2krMWUtNykqaX1yZXR1cm4gdGhpcy5zYW1wbGVBbmRMZXJwKGwsaCx1LGMsZC1nLGYsZCl9c2FtcGxlQW5kTGVycCh0LGUscyxpLG4scixvKXtjb25zdCBhPXRoaXMuUCh0KSxsPXRoaXMuUCh0KzEpLGg9dGhpcy5QKGErZSksdT10aGlzLlAoYStlKzEpLGM9dGhpcy5QKGwrZSksZD10aGlzLlAobCtlKzEpLGY9ei5ncmFkRG90KHRoaXMuUChoK3MpLGksbixyKSxnPXouZ3JhZERvdCh0aGlzLlAoYytzKSxpLTEsbixyKSxwPXouZ3JhZERvdCh0aGlzLlAodStzKSxpLG4tMSxyKSxtPXouZ3JhZERvdCh0aGlzLlAoZCtzKSxpLTEsbi0xLHIpLHY9ei5ncmFkRG90KHRoaXMuUChoK3MrMSksaSxuLHItMSksYj16LmdyYWREb3QodGhpcy5QKGMrcysxKSxpLTEsbixyLTEpLHc9ei5ncmFkRG90KHRoaXMuUCh1K3MrMSksaSxuLTEsci0xKSxQPXouZ3JhZERvdCh0aGlzLlAoZCtzKzEpLGktMSxuLTEsci0xKTtyZXR1cm4gTyhEKGkpLEQobyksRChyKSxmLGcscCxtLHYsYix3LFApfVAodCl7cmV0dXJuIDI1NSZ0aGlzLnBbMjU1JnRdfX1jbGFzcyBqe2NvbnN0cnVjdG9yKHQsZSxzKXtpZigxLWU8cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpdmUgb2N0YXZlcyBhcmUgbm90IGFsbG93ZWRcIik7dGhpcy5ub2lzZUxldmVscz1BcnJheShzLmxlbmd0aCk7Zm9yKGxldCBpPS1lO2k+PTA7aS09MSlpPHMubGVuZ3RoJiYwIT09c1tpXT90aGlzLm5vaXNlTGV2ZWxzW2ldPW5ldyBWKHQpOnQuY29uc3VtZSgyNjIpO3RoaXMuYW1wbGl0dWRlcz1zLHRoaXMubG93ZXN0RnJlcUlucHV0RmFjdG9yPU1hdGgucG93KDIsZSksdGhpcy5sb3dlc3RGcmVxVmFsdWVGYWN0b3I9TWF0aC5wb3coMixzLmxlbmd0aC0xKS8oTWF0aC5wb3coMixzLmxlbmd0aCktMSl9c2FtcGxlKHQsZSxzLGk9MCxuPTAscj0hMSl7bGV0IG89MCxhPXRoaXMubG93ZXN0RnJlcUlucHV0RmFjdG9yLGw9dGhpcy5sb3dlc3RGcmVxVmFsdWVGYWN0b3I7Zm9yKGxldCBoPTA7aDx0aGlzLm5vaXNlTGV2ZWxzLmxlbmd0aDtoKz0xKXtjb25zdCB1PXRoaXMubm9pc2VMZXZlbHNbaF07dSYmKG8rPXRoaXMuYW1wbGl0dWRlc1toXSpsKnUuc2FtcGxlKGoud3JhcCh0KmEpLHI/LXUueW86ai53cmFwKGUqYSksai53cmFwKHMqYSksaSphLG4qYSkpLGEqPTIsbC89Mn1yZXR1cm4gb31nZXRPY3RhdmVOb2lzZSh0KXtyZXR1cm4gdGhpcy5ub2lzZUxldmVsc1t0aGlzLm5vaXNlTGV2ZWxzLmxlbmd0aC0xLXRdfXN0YXRpYyB3cmFwKHQpe3JldHVybiB0LTMzNTU0NDMyKk1hdGguZmxvb3IodC8zMzU1NDQzMisuNSl9fWNsYXNzIFl7Y29uc3RydWN0b3IodCl7dGhpcy5taW5MaW1pdE5vaXNlPW5ldyBqKHQsLTE1LFsxLDEsMSwxLDEsMSwxLDEsMSwwLDAsMCwwLDAsMCwwXSksdGhpcy5tYXhMaW1pdE5vaXNlPW5ldyBqKHQsLTE1LFsxLDEsMSwxLDEsMSwxLDEsMSwwLDAsMCwwLDAsMCwwXSksdGhpcy5tYWluTm9pc2U9bmV3IGoodCwtNyxbMSwxLDEsMSwxLDAsMCwwXSl9c2FtcGxlKHQsZSxzLGksbixyLG8pe2xldCBhLGw9MCxoPTE7Zm9yKGxldCBpPTA7aTw4O2krPTEpe2lmKGE9dGhpcy5tYWluTm9pc2UuZ2V0T2N0YXZlTm9pc2UoaSksYSl7Y29uc3QgaT1yKmgsbj1vKmgsdT1qLndyYXAodCppKSxjPWoud3JhcChlKm4pLGQ9ai53cmFwKHMqaSk7bCs9YS5zYW1wbGUodSxjLGQsbixlKm4pL2h9aC89Mn1sPShsLzEwKzEpLzIsaD0xO2xldCB1PTAsYz0wO2ZvcihsZXQgcj0wO3I8MTY7cis9MSl7Y29uc3Qgbz1pKmgsZD1uKmgsZj1qLndyYXAodCpvKSxnPWoud3JhcChlKmQpLHA9ai53cmFwKHMqbyk7bDwxJiYoYT10aGlzLm1pbkxpbWl0Tm9pc2UuZ2V0T2N0YXZlTm9pc2UocikpJiYodSs9YS5zYW1wbGUoZixnLHAsZCxlKmQpL2gpLGw+MCYmKGE9dGhpcy5tYXhMaW1pdE5vaXNlLmdldE9jdGF2ZU5vaXNlKHIpKSYmKGMrPWEuc2FtcGxlKGYsZyxwLGQsZSpkKS9oKSxoLz0yfXJldHVybiBVKHUvNTEyLGMvNTEyLGwpfX1jbGFzcyBYe2NvbnN0cnVjdG9yKHQse2ZpcnN0T2N0YXZlOmUsYW1wbGl0dWRlczpzfSl7dGhpcy5maXJzdD1uZXcgaih0LGUscyksdGhpcy5zZWNvbmQ9bmV3IGoodCxlLHMpO2xldCBpPTEvMCxuPS0xLzA7Zm9yKGxldCB0PTA7dDxzLmxlbmd0aDt0Kz0xKTAhPT1zW3RdJiYoaT1NYXRoLm1pbihpLHQpLG49TWF0aC5tYXgobix0KSk7Y29uc3Qgcj0uMSooMSsxLyhuLWkrMSkpO3RoaXMudmFsdWVGYWN0b3I9MS82L3J9c2FtcGxlKHQsZSxzKXtjb25zdCBpPXQqWC5JTlBVVF9GQUNUT1Isbj1lKlguSU5QVVRfRkFDVE9SLHI9cypYLklOUFVUX0ZBQ1RPUjtyZXR1cm4odGhpcy5maXJzdC5zYW1wbGUodCxlLHMpK3RoaXMuc2Vjb25kLnNhbXBsZShpLG4scikpKnRoaXMudmFsdWVGYWN0b3J9fVguSU5QVVRfRkFDVE9SPTEuMDE4MTI2ODg4MjE3NTIyNyxmdW5jdGlvbih0KXt0LmZyb21Kc29uPWZ1bmN0aW9uKHQpe3ZhciBlLHMsaTtjb25zdCBuPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJue2ZpcnN0T2N0YXZlOm51bGwhPT0ocz1rLnJlYWRJbnQobi5maXJzdE9jdGF2ZSkpJiZ2b2lkIDAhPT1zP3M6MCxhbXBsaXR1ZGVzOm51bGwhPT0oaT1rLnJlYWRBcnJheShuLmFtcGxpdHVkZXMsKHQ9Pnt2YXIgZTtyZXR1cm4gbnVsbCE9PShlPWsucmVhZE51bWJlcih0KSkmJnZvaWQgMCE9PWU/ZTowfSkpKSYmdm9pZCAwIT09aT9pOltdfX19KFJ8fChSPXt9KSk7Y2xhc3MgSHtjb25zdHJ1Y3Rvcih0LGUpe2NvbnN0IHM9ZVtlLmxlbmd0aC0xXSxpPS1lWzBdK3MrMSxuPW5ldyBTZXQoZSkscj1uZXcgeih0KTt0aGlzLm5vaXNlTGV2ZWxzPUFycmF5KGkpLHM+PTAmJnM8aSYmbi5oYXMoMCkmJih0aGlzLm5vaXNlTGV2ZWxzW3NdPXIpO2ZvcihsZXQgZT1zKzE7ZTxpO2UrPTEpZT49MCYmbi5oYXMocy1lKT90aGlzLm5vaXNlTGV2ZWxzW2VdPW5ldyB6KHQpOnQuY29uc3VtZSgyNjIpO2lmKHM+MCl0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGl2ZSBvY3RhdmVzIGFyZSBub3QgYWxsb3dlZFwiKTt0aGlzLmhpZ2hlc3RGcmVxSW5wdXRGYWN0b3I9TWF0aC5wb3coMixzKSx0aGlzLmhpZ2hlc3RGcmVxVmFsdWVGYWN0b3I9MS8oTWF0aC5wb3coMixpKS0xKX1zYW1wbGUodCxlLHMpe2xldCBpPTAsbj10aGlzLmhpZ2hlc3RGcmVxSW5wdXRGYWN0b3Iscj10aGlzLmhpZ2hlc3RGcmVxVmFsdWVGYWN0b3I7Zm9yKGxldCBvPTA7bzx0aGlzLm5vaXNlTGV2ZWxzLmxlbmd0aDtvKz0xKXtjb25zdCBhPXRoaXMubm9pc2VMZXZlbHNbb107YSYmKGkrPXIqYS5zYW1wbGUyRCh0Km4rKHM/YS54bzowKSxlKm4rKHM/YS55bzowKSkpLG4vPTIscio9Mn1yZXR1cm4gaX19Y2xhc3MgV3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlZWQ9QmlnSW50KDApLHRoaXMuc2V0U2VlZCh0KX1mb3JrKCl7cmV0dXJuIG5ldyBXKHRoaXMubmV4dExvbmcoKSl9c2V0U2VlZCh0KXt0aGlzLnNlZWQ9dF5XLk1VTFRJUExJRVImVy5NT0RVTFVTX01BU0t9YWR2YW5jZSgpe3RoaXMuc2VlZD10aGlzLnNlZWQqVy5NVUxUSVBMSUVSK1cuSU5DUkVNRU5UJlcuTU9EVUxVU19NQVNLfWNvbnN1bWUodCl7Zm9yKGxldCBlPTA7ZTx0O2UrPTEpdGhpcy5hZHZhbmNlKCl9bmV4dCh0KXt0aGlzLmFkdmFuY2UoKTtjb25zdCBlPU51bWJlcih0aGlzLnNlZWQ+PkJpZ0ludChXLk1PRFVMVVNfQklUUy10KSk7cmV0dXJuIGU+MjE0NzQ4MzY0Nz9lLTQyOTQ5NjcyOTY6ZX1uZXh0SW50KHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMubmV4dCgzMik7aWYoMD09KHQmdC0xKSlyZXR1cm4gTnVtYmVyKEJpZ0ludCh0KSpCaWdJbnQodGhpcy5uZXh0KDMxKSk+PkJpZ0ludCgzMSkpO2xldCBlLHM7Zm9yKDsoZT10aGlzLm5leHQoMzEpKS0ocz1lJXQpKyh0LTEpPDA7KTtyZXR1cm4gc31uZXh0TG9uZygpe3JldHVybihCaWdJbnQodGhpcy5uZXh0KDMyKSk8PEJpZ0ludCgzMikpK0JpZ0ludCh0aGlzLm5leHQoMzIpKX1uZXh0RmxvYXQoKXtyZXR1cm4gdGhpcy5uZXh0KDI0KSpXLkZMT0FUX01VTFRJUExJRVJ9bmV4dERvdWJsZSgpe2NvbnN0IHQ9dGhpcy5uZXh0KDMwKTtyZXR1cm4gdGhpcy5hZHZhbmNlKCksdCpXLkRPVUJMRV9NVUxUSVBMSUVSfX1XLk1PRFVMVVNfQklUUz00OCxXLk1PRFVMVVNfTUFTSz1CaWdJbnQoXCIyODE0NzQ5NzY3MTA2NTVcIiksVy5NVUxUSVBMSUVSPUJpZ0ludChcIjI1MjE0OTAzOTE3XCIpLFcuSU5DUkVNRU5UPUJpZ0ludChcIjExXCIpLFcuRkxPQVRfTVVMVElQTElFUj0xL01hdGgucG93KDIsMjQpLFcuRE9VQkxFX01VTFRJUExJRVI9MS9NYXRoLnBvdygyLDMwKTtjbGFzcyBKIGV4dGVuZHMgV3tjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb3VudD0wfWdldENvdW50KCl7cmV0dXJuIHRoaXMuY291bnR9bmV4dCh0KXtyZXR1cm4gdGhpcy5jb3VudCs9MSxzdXBlci5uZXh0KHQpfX1jbGFzcyBae2NvbnN0cnVjdG9yKHQsZSxzPVtdLGk9W10sbj1bXSl7dGhpcy5uYW1lPXQsdGhpcy5jb29yZGluYXRlPWUsdGhpcy5sb2NhdGlvbnM9cyx0aGlzLnZhbHVlcz1pLHRoaXMuZGVyaXZhdGl2ZXM9bn1hcHBseSh0KXtjb25zdCBlPXRoaXMuY29vcmRpbmF0ZSh0KSxzPUwoMCx0aGlzLmxvY2F0aW9ucy5sZW5ndGgsKHQ9PmU8dGhpcy5sb2NhdGlvbnNbdF0pKS0xLGk9dGhpcy5sb2NhdGlvbnMubGVuZ3RoLTE7aWYoczwwKXJldHVybiB0aGlzLnZhbHVlc1swXSh0KSt0aGlzLmRlcml2YXRpdmVzWzBdKihlLXRoaXMubG9jYXRpb25zWzBdKTtpZihzPT09aSlyZXR1cm4gdGhpcy52YWx1ZXNbaV0odCkrdGhpcy5kZXJpdmF0aXZlc1tpXSooZS10aGlzLmxvY2F0aW9uc1tpXSk7Y29uc3Qgbj10aGlzLmxvY2F0aW9uc1tzXSxyPXRoaXMubG9jYXRpb25zW3MrMV0sbz10aGlzLmRlcml2YXRpdmVzW3NdLGE9dGhpcy5kZXJpdmF0aXZlc1tzKzFdLGw9KGUtbikvKHItbiksaD10aGlzLnZhbHVlc1tzXSh0KSx1PXRoaXMudmFsdWVzW3MrMV0odCksYz1vKihyLW4pLSh1LWgpLGQ9LWEqKHItbikrKHUtaCk7cmV0dXJuIE4obCxoLHUpK2wqKDEtbCkqTihsLGMsZCl9YWRkUG9pbnQodCxlLHM9MCl7cmV0dXJuIHRoaXMubG9jYXRpb25zLnB1c2godCksdGhpcy52YWx1ZXMucHVzaChcIm51bWJlclwiPT10eXBlb2YgZT8oKT0+ZTplLmFwcGx5LmJpbmQoZSkpLHRoaXMuZGVyaXZhdGl2ZXMucHVzaChzKSx0aGlzfX1jb25zdCAkPXQ9PlsodD4+MTYmMjU1KS8yNTYsKHQ+PjgmMjU1KS8yNTYsKDI1NSZ0KS8yNTZdLEc9WzEyNC8yNTYsMTg5LzI1NiwxMDcvMjU2XSxxPSQoNjM5NjI1NyksSz0kKDg0MzE0NDUpLFE9JCg0NzY0OTUyKSx0dD0kKDQxNTkyMDQpLGV0PSQoODQzMTQ0NSksc3Q9JCgyMTI5OTY4KSxpdD10PT5bdC84LDEtdC8zMiw2NCp0XSxudD17bGFyZ2VfZmVybjooKT0+Ryx0YWxsX2dyYXNzOigpPT5HLGdyYXNzX2Jsb2NrOigpPT5HLGZlcm46KCk9PkcsZ3Jhc3M6KCk9PkcscG90dGVkX2Zlcm46KCk9Pkcsc3BydWNlX2xlYXZlczooKT0+cSxiaXJjaF9sZWF2ZXM6KCk9Pkssb2FrX2xlYXZlczooKT0+USxqdW5nbGVfbGVhdmVzOigpPT5RLGFjYWNpYV9sZWF2ZXM6KCk9PlEsZGFya19vYWtfbGVhdmVzOigpPT5RLHZpbmU6KCk9PlEsd2F0ZXI6KCk9PnR0LGJ1YmJsZV9jb2x1bW46KCk9PnR0LGNhdWxkcm9uOigpPT50dCxyZWRzdG9uZV93aXJlOnQ9Pnt2YXIgZTtyZXR1cm4odD0+e2NvbnN0IGU9dC8xNTtyZXR1cm5bLjYqZSsoZT4wPy40Oi4zKSxNKGUqZSouNy0uNSwwLDEpLE0oZSplKi42LS43LDAsMSldfSkocGFyc2VJbnQobnVsbCE9PShlPXQucG93ZXIpJiZ2b2lkIDAhPT1lP2U6XCIwXCIpKX0sc3VnYXJfY2FuZTooKT0+RyxhdHRhY2hlZF9tZWxvbl9zdGVtOigpPT5ldCxhdHRhY2hlZF9wdW1wa2luX3N0ZW06KCk9PmV0LG1lbG9uX3N0ZW06dD0+e3ZhciBlO3JldHVybiBpdChwYXJzZUludChudWxsIT09KGU9dC5hZ2UpJiZ2b2lkIDAhPT1lP2U6XCIwXCIpKX0scHVtcGtpbl9zdGVtOnQ9Pnt2YXIgZTtyZXR1cm4gaXQocGFyc2VJbnQobnVsbCE9PShlPXQuYWdlKSYmdm9pZCAwIT09ZT9lOlwiMFwiKSl9LGxpbHlfcGFkOigpPT5zdH07dmFyIHJ0O2Z1bmN0aW9uIG90KC4uLnQpe2xldCBlPTA7Zm9yKGNvbnN0IHMgb2YgdCllKz1zLmxlbmd0aDtjb25zdCBzPW5ldyBGbG9hdDMyQXJyYXkoZSk7bGV0IGk9MDtmb3IoY29uc3QgZSBvZiB0KXMuc2V0KGUsaSksaSs9ZS5sZW5ndGg7cmV0dXJuIHN9ZnVuY3Rpb24gYXQodCxzKXtjb25zdCBpPWUuY3JlYXRlKCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKz0zKWlbMF09dFtuXSxpWzFdPXRbbisxXSxpWzJdPXRbbisyXSxlLnRyYW5zZm9ybU1hdDQoaSxpLHMpLHRbbl09aVswXSx0W24rMV09aVsxXSx0W24rMl09aVsyXX0hZnVuY3Rpb24odCl7dC5yb3RhdGU9ZnVuY3Rpb24odCxlLHMpe2xldHt1cDppLGRvd246bixub3J0aDpyLGVhc3Q6byxzb3V0aDphLHdlc3Q6bH09dDtzd2l0Y2gocyl7Y2FzZSA5MDpbcixvLGEsbF09W28sYSxsLHJdO2JyZWFrO2Nhc2UgMTgwOltyLG8sYSxsXT1bYSxsLHIsb107YnJlYWs7Y2FzZSAyNzA6W3IsbyxhLGxdPVtsLHIsbyxhXX1zd2l0Y2goZSl7Y2FzZSA5MDpbaSxyLG4sYV09W3IsbixhLGldO2JyZWFrO2Nhc2UgMTgwOltpLHIsbixhXT1bbixhLGkscl07YnJlYWs7Y2FzZSAyNzA6W2kscixuLGFdPVthLGkscixuXX1yZXR1cm57dXA6aSxkb3duOm4sbm9ydGg6cixlYXN0Om8sc291dGg6YSx3ZXN0Omx9fX0ocnR8fChydD17fSkpO2NsYXNzIGx0e2NvbnN0cnVjdG9yKHQsZSxzKXt0aGlzLmlkPXQsdGhpcy52YXJpYW50cz1lLHRoaXMubXVsdGlwYXJ0PXMsdGhpcy52YXJpYW50cz1lfWdldE1vZGVsVmFyaWFudHModCl7aWYodGhpcy52YXJpYW50cyl7Y29uc3QgZT1PYmplY3Qua2V5cyh0aGlzLnZhcmlhbnRzKS5maWx0ZXIoKGU9PnRoaXMubWF0Y2hlc1ZhcmlhbnQoZSx0KSkpO2lmKDA9PT1lLmxlbmd0aClyZXR1cm5bXTtjb25zdCBzPXRoaXMudmFyaWFudHNbZVswXV07cmV0dXJuW0FycmF5LmlzQXJyYXkocyk/c1swXTpzXX1pZih0aGlzLm11bHRpcGFydCl7cmV0dXJuIHRoaXMubXVsdGlwYXJ0LmZpbHRlcigoZT0+IWUud2hlbnx8dGhpcy5tYXRjaGVzQ2FzZShlLndoZW4sdCkpKS5tYXAoKHQ9PkFycmF5LmlzQXJyYXkodC5hcHBseSk/dC5hcHBseVswXTp0LmFwcGx5KSl9cmV0dXJuW119Z2V0QnVmZmVycyh0LGUsbixyLG8sYSl7dmFyIGwsaCx1LGM7Y29uc3QgZD10aGlzLmdldE1vZGVsVmFyaWFudHMoZSksZj1bXSxnPVtdLHA9W10sbT1bXTtmb3IoY29uc3QgdiBvZiBkKXtjb25zdCBkPXJ0LnJvdGF0ZShhLG51bGwhPT0obD12LngpJiZ2b2lkIDAhPT1sP2w6MCxudWxsIT09KGg9di55KSYmdm9pZCAwIT09aD9oOjApLGI9ci5nZXRCbG9ja01vZGVsKHYubW9kZWwpLmdldEJ1ZmZlcnModCxlLG4sbyxkKTtpZih2Lnh8fHYueSl7Y29uc3QgdD1zLmNyZWF0ZSgpO3MuaWRlbnRpdHkodCkscy50cmFuc2xhdGUodCx0LFs4LDgsOF0pLHMucm90YXRlWSh0LHQsLWkudG9SYWRpYW4obnVsbCE9PSh1PXYueSkmJnZvaWQgMCE9PXU/dTowKSkscy5yb3RhdGVYKHQsdCwtaS50b1JhZGlhbihudWxsIT09KGM9di54KSYmdm9pZCAwIT09Yz9jOjApKSxzLnRyYW5zbGF0ZSh0LHQsWy04LC04LC04XSksYXQoYi5wb3NpdGlvbix0KX1mLnB1c2goYi5wb3NpdGlvbiksZy5wdXNoKC4uLmIudGV4Q29vcmQpLHAucHVzaCguLi5iLnRpbnRDb2xvciksbS5wdXNoKC4uLmIuaW5kZXgpLG8rPWIudGV4Q29vcmQubGVuZ3RoLzJ9Y29uc3Qgdj1zLmNyZWF0ZSgpO3MuaWRlbnRpdHkodikscy5zY2FsZSh2LHYsWy4wNjI1LC4wNjI1LC4wNjI1XSk7Y29uc3QgYj1vdCguLi5mKTtyZXR1cm4gYXQoYix2KSx7cG9zaXRpb246Yix0ZXhDb29yZDpnLHRpbnRDb2xvcjpwLGluZGV4Om19fW1hdGNoZXNWYXJpYW50KHQsZSl7cmV0dXJuIHQuc3BsaXQoXCIsXCIpLmV2ZXJ5KCh0PT57Y29uc3RbcyxpXT10LnNwbGl0KFwiPVwiKTtyZXR1cm4gZVtzXT09PWl9KSl9bWF0Y2hlc0Nhc2UodCxlKXtpZihBcnJheS5pc0FycmF5KHQuT1IpKXJldHVybiB0Lk9SLnNvbWUoKHQ9PnRoaXMubWF0Y2hlc0Nhc2UodCxlKSkpO2NvbnN0IHM9dDtyZXR1cm4gT2JqZWN0LmtleXMocykuZXZlcnkoKHQ9PnNbdF0uc3BsaXQoXCJ8XCIpLmluY2x1ZGVzKGVbdF0pKSl9c3RhdGljIGZyb21Kc29uKHQsZSl7cmV0dXJuIG5ldyBsdCh0LGUudmFyaWFudHMsZS5tdWx0aXBhcnQpfX1jb25zdCBodD17MDpbMCwzLDIsMywyLDEsMCwxXSw5MDpbMiwzLDIsMSwwLDEsMCwzXSwxODA6WzIsMSwwLDEsMCwzLDIsM10sMjcwOlswLDEsMCwzLDIsMywyLDFdfSx1dD17eDpbMSwwLDBdLHk6WzAsMSwwXSx6OlswLDAsMV19LGN0PTEuNDE0MjEzNTYyMzcsZHQ9e3g6WzEsY3QsY3RdLHk6W2N0LDEsY3RdLHo6W2N0LGN0LDFdfTtjbGFzcyBmdHtjb25zdHJ1Y3Rvcih0LGUscyxpKXt0aGlzLmlkPXQsdGhpcy5wYXJlbnQ9ZSx0aGlzLnRleHR1cmVzPXMsdGhpcy5lbGVtZW50cz1pLHRoaXMuZmxhdHRlbmVkPSExfWdldEJ1ZmZlcnModCxlLHMsaSxuKXt2YXIgcjtjb25zdCBvPVtdLGE9W10sbD1bXSxoPVtdO2Zvcihjb25zdCB1IG9mIG51bGwhPT0ocj10aGlzLmVsZW1lbnRzKSYmdm9pZCAwIT09cj9yOltdKXtjb25zdCByPXRoaXMuZ2V0RWxlbWVudEJ1ZmZlcnModCxlLHUsaSxzLG4pO28ucHVzaChyLnBvc2l0aW9uKSxhLnB1c2goLi4uci50ZXhDb29yZCksbC5wdXNoKC4uLnIudGludENvbG9yKSxoLnB1c2goLi4uci5pbmRleCksaSs9ci50ZXhDb29yZC5sZW5ndGgvMn1yZXR1cm57cG9zaXRpb246b3QoLi4ubyksdGV4Q29vcmQ6YSx0aW50Q29sb3I6bCxpbmRleDpofX1nZXRFbGVtZW50QnVmZmVycyh0LG4scixvLGEsbCl7dmFyIGgsdSxjLGQsZixnLHAsbSx2LGIsdyxQO2NvbnN0IHg9ci5mcm9tWzBdLHk9ci5mcm9tWzFdLEE9ci5mcm9tWzJdLFM9ci50b1swXSxCPXIudG9bMV0sRT1yLnRvWzJdLEM9W10sST1bXSxrPVtdLFI9W10sXz0oZSxzLGkpPT57dmFyIHIsbCxoLHUsYyxkLGYsZyxwLG0sdixiO2NvbnN0W3csUCx4LHldPWEuZ2V0VGV4dHVyZVVWKHRoaXMuZ2V0VGV4dHVyZShlLnRleHR1cmUpKSxBPSh4LXcpLzE2LFM9KHktUCkvMTYsQj1BLzE2LEU9Uy8xNjtzWzBdPShudWxsIT09KGw9bnVsbD09PShyPWUudXYpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyWzBdKSYmdm9pZCAwIT09bD9sOnNbMF0pKkErQixzWzFdPShudWxsIT09KHU9bnVsbD09PShoPWUudXYpfHx2b2lkIDA9PT1oP3ZvaWQgMDpoWzFdKSYmdm9pZCAwIT09dT91OnNbMV0pKlMrRSxzWzJdPShudWxsIT09KGQ9bnVsbD09PShjPWUudXYpfHx2b2lkIDA9PT1jP3ZvaWQgMDpjWzJdKSYmdm9pZCAwIT09ZD9kOnNbMl0pKkEtQixzWzNdPShudWxsIT09KGc9bnVsbD09PShmPWUudXYpfHx2b2lkIDA9PT1mP3ZvaWQgMDpmWzNdKSYmdm9pZCAwIT09Zz9nOnNbM10pKlMtRTtjb25zdCBfPWh0W251bGwhPT0ocD1lLnJvdGF0aW9uKSYmdm9pZCAwIT09cD9wOjBdO0kucHVzaCh3K3NbX1swXV0sUCtzW19bMV1dLHcrc1tfWzJdXSxQK3NbX1szXV0sdytzW19bNF1dLFArc1tfWzVdXSx3K3NbX1s2XV0sUCtzW19bN11dKTtjb25zdCBGPShudWxsIT09KG09ZS50aW50aW5kZXgpJiZ2b2lkIDAhPT1tP206LTEpPj0wJiZudWxsIT09KGI9bnVsbD09PSh2PW50W3Quc2xpY2UoMTApXSl8fHZvaWQgMD09PXY/dm9pZCAwOnYuY2FsbChudCxuKSkmJnZvaWQgMCE9PWI/YjpbMSwxLDFdO2sucHVzaCguLi5GLC4uLkYsLi4uRiwuLi5GKSxDLnB1c2goLi4uaSksUi5wdXNoKG8sbysxLG8rMixvLG8rMixvKzMpLG8rPTR9OyEobnVsbD09PSh1PW51bGw9PT0oaD1yLmZhY2VzKXx8dm9pZCAwPT09aD92b2lkIDA6aC51cCl8fHZvaWQgMD09PXU/dm9pZCAwOnUudGV4dHVyZSl8fHIuZmFjZXMudXAuY3VsbGZhY2UmJmxbci5mYWNlcy51cC5jdWxsZmFjZV18fF8oci5mYWNlcy51cCxbeCwxNi1FLFMsMTYtQV0sW3gsQixFLFMsQixFLFMsQixBLHgsQixBXSksIShudWxsPT09KGQ9bnVsbD09PShjPXIuZmFjZXMpfHx2b2lkIDA9PT1jP3ZvaWQgMDpjLmRvd24pfHx2b2lkIDA9PT1kP3ZvaWQgMDpkLnRleHR1cmUpfHxyLmZhY2VzLmRvd24uY3VsbGZhY2UmJmxbci5mYWNlcy5kb3duLmN1bGxmYWNlXXx8XyhyLmZhY2VzLmRvd24sWzE2LUUsMTYtUywxNi1BLDE2LXhdLFt4LHksQSxTLHksQSxTLHksRSx4LHksRV0pLCEobnVsbD09PShnPW51bGw9PT0oZj1yLmZhY2VzKXx8dm9pZCAwPT09Zj92b2lkIDA6Zi5zb3V0aCl8fHZvaWQgMD09PWc/dm9pZCAwOmcudGV4dHVyZSl8fHIuZmFjZXMuc291dGguY3VsbGZhY2UmJmxbci5mYWNlcy5zb3V0aC5jdWxsZmFjZV18fF8oci5mYWNlcy5zb3V0aCxbeCwxNi1CLFMsMTYteV0sW3gseSxFLFMseSxFLFMsQixFLHgsQixFXSksIShudWxsPT09KG09bnVsbD09PShwPXIuZmFjZXMpfHx2b2lkIDA9PT1wP3ZvaWQgMDpwLm5vcnRoKXx8dm9pZCAwPT09bT92b2lkIDA6bS50ZXh0dXJlKXx8ci5mYWNlcy5ub3J0aC5jdWxsZmFjZSYmbFtyLmZhY2VzLm5vcnRoLmN1bGxmYWNlXXx8XyhyLmZhY2VzLm5vcnRoLFsxNi1TLDE2LUIsMTYteCwxNi15XSxbUyx5LEEseCx5LEEseCxCLEEsUyxCLEFdKSwhKG51bGw9PT0oYj1udWxsPT09KHY9ci5mYWNlcyl8fHZvaWQgMD09PXY/dm9pZCAwOnYuZWFzdCl8fHZvaWQgMD09PWI/dm9pZCAwOmIudGV4dHVyZSl8fHIuZmFjZXMuZWFzdC5jdWxsZmFjZSYmbFtyLmZhY2VzLmVhc3QuY3VsbGZhY2VdfHxfKHIuZmFjZXMuZWFzdCxbMTYtRSwxNi1CLDE2LUEsMTYteV0sW1MseSxFLFMseSxBLFMsQixBLFMsQixFXSksIShudWxsPT09KFA9bnVsbD09PSh3PXIuZmFjZXMpfHx2b2lkIDA9PT13P3ZvaWQgMDp3Lndlc3QpfHx2b2lkIDA9PT1QP3ZvaWQgMDpQLnRleHR1cmUpfHxyLmZhY2VzLndlc3QuY3VsbGZhY2UmJmxbci5mYWNlcy53ZXN0LmN1bGxmYWNlXXx8XyhyLmZhY2VzLndlc3QsW0EsMTYtQixFLDE2LXldLFt4LHksQSx4LHksRSx4LEIsRSx4LEIsQV0pO2NvbnN0IEY9cy5jcmVhdGUoKTtpZihzLmlkZW50aXR5KEYpLHIucm90YXRpb24pe2NvbnN0IHQ9ZS5mcm9tVmFsdWVzKC4uLnIucm90YXRpb24ub3JpZ2luKTtzLnRyYW5zbGF0ZShGLEYsdCkscy5yb3RhdGUoRixGLGkudG9SYWRpYW4oci5yb3RhdGlvbi5hbmdsZSksdXRbci5yb3RhdGlvbi5heGlzXSksci5yb3RhdGlvbi5yZXNjYWxlJiZzLnNjYWxlKEYsRixkdFtyLnJvdGF0aW9uLmF4aXNdKSxlLm5lZ2F0ZSh0LHQpLHMudHJhbnNsYXRlKEYsRix0KX1jb25zdCBNPW5ldyBGbG9hdDMyQXJyYXkoQyk7cmV0dXJuIGF0KE0sRikse3Bvc2l0aW9uOk0sdGV4Q29vcmQ6SSx0aW50Q29sb3I6ayxpbmRleDpSfX1nZXRUZXh0dXJlKHQpe2Zvcih2YXIgZSxzO3Quc3RhcnRzV2l0aChcIiNcIik7KXQ9bnVsbCE9PShzPW51bGw9PT0oZT10aGlzLnRleHR1cmVzKXx8dm9pZCAwPT09ZT92b2lkIDA6ZVt0LnNsaWNlKDEpXSkmJnZvaWQgMCE9PXM/czpcIlwiO3JldHVybiB0LnN0YXJ0c1dpdGgoXCJtaW5lY3JhZnQ6XCIpfHwodD1cIm1pbmVjcmFmdDpcIit0KSx0fWZsYXR0ZW4odCl7dmFyIGU7aWYoIXRoaXMuZmxhdHRlbmVkJiZ0aGlzLnBhcmVudCl7Y29uc3Qgcz10LmdldEJsb2NrTW9kZWwodGhpcy5wYXJlbnQpO2lmKCFzKXJldHVybiBjb25zb2xlLndhcm4oYHBhcmVudCAke3RoaXMucGFyZW50fSBkb2VzIG5vdCBleGlzdCFgKSx2b2lkKHRoaXMuZmxhdHRlbmVkPSEwKTtzLmZsYXR0ZW4odCksdGhpcy5lbGVtZW50c3x8KHRoaXMuZWxlbWVudHM9cy5lbGVtZW50cyksdGhpcy50ZXh0dXJlc3x8KHRoaXMudGV4dHVyZXM9e30pLE9iamVjdC5rZXlzKG51bGwhPT0oZT1zLnRleHR1cmVzKSYmdm9pZCAwIT09ZT9lOnt9KS5mb3JFYWNoKCh0PT57dGhpcy50ZXh0dXJlc1t0XXx8KHRoaXMudGV4dHVyZXNbdF09cy50ZXh0dXJlc1t0XSl9KSksdGhpcy5mbGF0dGVuZWQ9ITB9fXN0YXRpYyBmcm9tSnNvbih0LGUpe2xldCBzPWUucGFyZW50O3JldHVybiBzJiYhcy5zdGFydHNXaXRoKFwibWluZWNyYWZ0OlwiKSYmKHM9XCJtaW5lY3JhZnQ6XCIrcyksbmV3IGZ0KHQscyxlLnRleHR1cmVzLGUuZWxlbWVudHMpfX1jbGFzcyBndHtjb25zdHJ1Y3Rvcih0LGUscyl7dGhpcy5nbD10LHRoaXMucHJvZ3JhbT10aGlzLmluaXRTaGFkZXJQcm9ncmFtKGUscyl9Z2V0UHJvZ3JhbSgpe3JldHVybiB0aGlzLnByb2dyYW19aW5pdFNoYWRlclByb2dyYW0odCxlKXtjb25zdCBzPXRoaXMubG9hZFNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIsdCksaT10aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIsZSksbj10aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtpZih0aGlzLmdsLmF0dGFjaFNoYWRlcihuLHMpLHRoaXMuZ2wuYXR0YWNoU2hhZGVyKG4saSksdGhpcy5nbC5saW5rUHJvZ3JhbShuKSwhdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKG4sdGhpcy5nbC5MSU5LX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbGluayBzaGFkZXIgcHJvZ3JhbTogJHt0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKG4pfWApO3JldHVybiBufWxvYWRTaGFkZXIodCxlKXtjb25zdCBzPXRoaXMuZ2wuY3JlYXRlU2hhZGVyKHQpO2lmKHRoaXMuZ2wuc2hhZGVyU291cmNlKHMsZSksdGhpcy5nbC5jb21waWxlU2hhZGVyKHMpLCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzLHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBlPW5ldyBFcnJvcihgQ29tcGlsaW5nICR7dD09PXRoaXMuZ2wuVkVSVEVYX1NIQURFUj9cInZlcnRleFwiOlwiZnJhZ21lbnRcIn0gc2hhZGVyOiAke3RoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzKX1gKTt0aHJvdyB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzKSxlfXJldHVybiBzfX1mdW5jdGlvbiBwdCh0LGUscyxpLG4pe2NvbnN0IHI9bmV3IGx0KFwiXCIse1wiXCI6e21vZGVsOlwiXCJ9fSx2b2lkIDApLG89e2dldEJsb2NrTW9kZWw6KCk9Pm59O3JldHVybiBuLmZsYXR0ZW4obyksci5nZXRCdWZmZXJzKHQse30sZSxvLHMsaSl9ZnVuY3Rpb24gbXQodCxlLHMsaSxyLG8pe2NvbnN0IGE9ci51cD8xNjpbMTQuMiwxMi41LDEwLjUsOSw3LDUuMywzLjcsMS45LDE2LDE2LDE2LDE2LDE2LDE2LDE2LDE2XVtzXTtyZXR1cm4gcHQoYG1pbmVjcmFmdDoke3R9YCxpLGUscixuZXcgZnQoXCJcIixcIlwiLHtzdGlsbDpgbWluZWNyYWZ0OmJsb2NrLyR7dH1fc3RpbGxgLGZsb3c6YG1pbmVjcmFmdDpibG9jay8ke3R9X2Zsb3dgfSxbe2Zyb206WzAsMCwwXSx0bzpbMTYsYSwxNl0sZmFjZXM6e3VwOnt0ZXh0dXJlOlwiI3N0aWxsXCIsdGludGluZGV4Om8sY3VsbGZhY2U6bi5VUH0sZG93bjp7dGV4dHVyZTpcIiNzdGlsbFwiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uRE9XTn0sbm9ydGg6e3RleHR1cmU6XCIjZmxvd1wiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uTk9SVEh9LGVhc3Q6e3RleHR1cmU6XCIjZmxvd1wiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uRUFTVH0sc291dGg6e3RleHR1cmU6XCIjZmxvd1wiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uU09VVEh9LHdlc3Q6e3RleHR1cmU6XCIjZmxvd1wiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uV0VTVH19fV0pKX1jb25zdCB2dD17XCJtaW5lY3JhZnQ6d2F0ZXJcIjoodCxlLHMsaSk9Pm10KFwid2F0ZXJcIix0LHBhcnNlSW50KGUubGV2ZWwpLHMsaSwwKSxcIm1pbmVjcmFmdDpsYXZhXCI6KHQsZSxzLGkpPT5tdChcImxhdmFcIix0LHBhcnNlSW50KGUubGV2ZWwpLHMsaSksXCJtaW5lY3JhZnQ6Y2hlc3RcIjoodCxlLHMpPT5mdW5jdGlvbih0LGUscyxpKXtyZXR1cm4gcHQoXCJtaW5lY3JhZnQ6Y2hlc3RcIixpLHQse30sbmV3IGZ0KFwiXCIsXCJcIix7MDpcIm1pbmVjcmFmdDpibG9jay9jaGVzdFwifSxbe2Zyb206WzEsMCwxXSx0bzpbMTUsMTQsMTVdLGZhY2VzOnt1cDp7dGV4dHVyZTpcIiMwXCJ9LGRvd246e3RleHR1cmU6XCIjMFwifSxub3J0aDp7dGV4dHVyZTpcIiMwXCJ9LGVhc3Q6e3RleHR1cmU6XCIjMFwifSxzb3V0aDp7dGV4dHVyZTpcIiMwXCJ9LHdlc3Q6e3RleHR1cmU6XCIjMFwifX19XSkpfSh0LGUuZmFjaW5nLGUudHlwZSxzKX0sYnQ9bmV3IFNldChPYmplY3Qua2V5cyh2dCkpO2NsYXNzIHd0e2NvbnN0cnVjdG9yKHQsZSxzLGkpe3ZhciBuLHI7dGhpcy5nbD10LHRoaXMuc3RydWN0dXJlPWUsdGhpcy5yZXNvdXJjZXM9cyx0aGlzLmNodW5rcz1bXSwobnVsbD09aT92b2lkIDA6aS5mYWNlc1BlckJ1ZmZlcikmJmNvbnNvbGUud2FybihcIndlYmdsIHJlbmRlciB3YXJuaW5nOiBmYWNlc1BlckJ1ZmZlciBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCBpbiBmYXZvciBvZiBjaHVua1NpemVcIiksdGhpcy5jaHVua1NpemU9bnVsbCE9PShuPW51bGw9PWk/dm9pZCAwOmkuY2h1bmtTaXplKSYmdm9pZCAwIT09bj9uOjE2LHRoaXMudXNlSW52aXNpYmxlQmxvY2tCdWZmZXI9bnVsbD09PShyPW51bGw9PWk/dm9pZCAwOmkudXNlSW52aXNpYmxlQmxvY2tCdWZmZXIpfHx2b2lkIDA9PT1yfHxyLHRoaXMuc2hhZGVyUHJvZ3JhbT1uZXcgZ3QodCxcIlxcbiAgYXR0cmlidXRlIHZlYzQgdmVydFBvcztcXG4gIGF0dHJpYnV0ZSB2ZWMyIHRleENvb3JkO1xcbiAgYXR0cmlidXRlIHZlYzMgdGludENvbG9yO1xcbiAgYXR0cmlidXRlIHZlYzMgbm9ybWFsO1xcblxcbiAgdW5pZm9ybSBtYXQ0IG1WaWV3O1xcbiAgdW5pZm9ybSBtYXQ0IG1Qcm9qO1xcblxcbiAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXhDb29yZDtcXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2VGludENvbG9yO1xcbiAgdmFyeWluZyBoaWdocCBmbG9hdCB2TGlnaHRpbmc7XFxuXFxuICB2b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IG1Qcm9qICogbVZpZXcgKiB2ZXJ0UG9zO1xcbiAgICB2VGV4Q29vcmQgPSB0ZXhDb29yZDtcXG4gICAgdlRpbnRDb2xvciA9IHRpbnRDb2xvcjtcXG4gICAgdkxpZ2h0aW5nID0gbm9ybWFsLnkgKiAwLjIgKyBhYnMobm9ybWFsLnopICogMC4xICsgMC44O1xcbiAgfVxcblwiLFwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleENvb3JkO1xcbiAgdmFyeWluZyBoaWdocCB2ZWMzIHZUaW50Q29sb3I7XFxuICB2YXJ5aW5nIGhpZ2hwIGZsb2F0IHZMaWdodGluZztcXG5cXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXI7XFxuXFxuICB2b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHNhbXBsZXIsIHZUZXhDb29yZCk7XFxuICAgIGlmKHRleENvbG9yLmEgPCAwLjAxKSBkaXNjYXJkO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHRleENvbG9yLnh5eiAqIHZUaW50Q29sb3IgKiB2TGlnaHRpbmcsIHRleENvbG9yLmEpO1xcbiAgfVxcblwiKS5nZXRQcm9ncmFtKCksdGhpcy5ncmlkU2hhZGVyUHJvZ3JhbT1uZXcgZ3QodCxcIlxcbiAgYXR0cmlidXRlIHZlYzQgdmVydFBvcztcXG4gIGF0dHJpYnV0ZSB2ZWMzIHZlcnRDb2xvcjtcXG5cXG4gIHVuaWZvcm0gbWF0NCBtVmlldztcXG4gIHVuaWZvcm0gbWF0NCBtUHJvajtcXG5cXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2Q29sb3I7XFxuXFxuICB2b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IG1Qcm9qICogbVZpZXcgKiB2ZXJ0UG9zO1xcbiAgICB2Q29sb3IgPSB2ZXJ0Q29sb3I7XFxuICB9XFxuXCIsXCJcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2Q29sb3I7XFxuXFxuICB2b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgMS4wKTtcXG4gIH1cXG5cIikuZ2V0UHJvZ3JhbSgpLHRoaXMuY29sb3JTaGFkZXJQcm9ncmFtPW5ldyBndCh0LFwiXFxuICBhdHRyaWJ1dGUgdmVjNCB2ZXJ0UG9zO1xcbiAgYXR0cmlidXRlIHZlYzMgYmxvY2tQb3M7XFxuXFxuICB1bmlmb3JtIG1hdDQgbVZpZXc7XFxuICB1bmlmb3JtIG1hdDQgbVByb2o7XFxuXFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkNvbG9yO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBtUHJvaiAqIG1WaWV3ICogdmVydFBvcztcXG4gICAgdkNvbG9yID0gYmxvY2tQb3MgLyAyNTYuMDtcXG4gIH1cXG5cIixcIlxcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgdmFyeWluZyBoaWdocCB2ZWMzIHZDb2xvcjtcXG5cXG4gIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodkNvbG9yLCAxLjApO1xcbiAgfVxcblwiKS5nZXRQcm9ncmFtKCksdGhpcy51cGRhdGVTdHJ1Y3R1cmVCdWZmZXJzKCksdGhpcy5ncmlkQnVmZmVycz10aGlzLmdldEdyaWRCdWZmZXJzKCksdGhpcy5vdXRsaW5lQnVmZmVycz10aGlzLmdldE91dGxpbmVCdWZmZXJzKCksdGhpcy5pbnZpc2libGVCbG9ja0J1ZmZlcnM9dGhpcy5nZXRJbnZpc2libGVCbG9ja0J1ZmZlcnMoKSx0aGlzLmF0bGFzVGV4dHVyZT10aGlzLmdldEJsb2NrVGV4dHVyZSgpLHRoaXMucHJvak1hdHJpeD10aGlzLmdldFBlcnNwZWN0aXZlKCksdGhpcy5hY3RpdmVTaGFkZXI9dGhpcy5zaGFkZXJQcm9ncmFtLHRoaXMuaW5pdGlhbGl6ZSgpfXNldFN0cnVjdHVyZSh0KXt0aGlzLnN0cnVjdHVyZT10LHRoaXMudXBkYXRlU3RydWN0dXJlQnVmZmVycygpLHRoaXMuZ3JpZEJ1ZmZlcnM9dGhpcy5nZXRHcmlkQnVmZmVycygpLHRoaXMuaW52aXNpYmxlQmxvY2tCdWZmZXJzPXRoaXMuZ2V0SW52aXNpYmxlQmxvY2tCdWZmZXJzKCl9aW5pdGlhbGl6ZSgpe3RoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCksdGhpcy5nbC5kZXB0aEZ1bmModGhpcy5nbC5MRVFVQUwpLHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpLHRoaXMuZ2wuYmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLHRoaXMuZ2wuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5nbC5lbmFibGUodGhpcy5nbC5DVUxMX0ZBQ0UpLHRoaXMuZ2wuY3VsbEZhY2UodGhpcy5nbC5CQUNLKX1nZXRCbG9ja1RleHR1cmUoKXtjb25zdCB0PXRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO3JldHVybiB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCx0KSx0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELDAsdGhpcy5nbC5SR0JBLHRoaXMuZ2wuUkdCQSx0aGlzLmdsLlVOU0lHTkVEX0JZVEUsdGhpcy5yZXNvdXJjZXMuZ2V0VGV4dHVyZUF0bGFzKCkpLHRoaXMuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5nbC5URVhUVVJFXzJEKSx0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLHRoaXMuZ2wuTkVBUkVTVCksdH1nZXRQZXJzcGVjdGl2ZSgpe2NvbnN0IHQ9NzAqTWF0aC5QSS8xODAsZT10aGlzLmdsLmNhbnZhcy5jbGllbnRXaWR0aC90aGlzLmdsLmNhbnZhcy5jbGllbnRIZWlnaHQsaT1zLmNyZWF0ZSgpO3JldHVybiBzLnBlcnNwZWN0aXZlKGksdCxlLC4xLDUwMCksaX1nZXRDaHVuayh0KXtjb25zdCBlPTIqTWF0aC5hYnModFswXSkrKHRbMF08MD8xOjApLHM9MipNYXRoLmFicyh0WzFdKSsodFsxXTwwPzE6MCksaT0yKk1hdGguYWJzKHRbMl0pKyh0WzJdPDA/MTowKTtyZXR1cm4gdGhpcy5jaHVua3NbZV18fCh0aGlzLmNodW5rc1tlXT1bXSksdGhpcy5jaHVua3NbZV1bc118fCh0aGlzLmNodW5rc1tlXVtzXT1bXSksdGhpcy5jaHVua3NbZV1bc11baV18fCh0aGlzLmNodW5rc1tlXVtzXVtpXT17cG9zaXRpb25zOltdLHRleHR1cmVDb29yZGluYXRlczpbXSx0aW50Q29sb3JzOltdLGJsb2NrUG9zaXRpb25zOltdLG5vcm1hbHM6W10saW5kaWNlczpbXSxpbmRleE9mZnNldDowfSksdGhpcy5jaHVua3NbZV1bc11baV19dXBkYXRlU3RydWN0dXJlQnVmZmVycyh0KXt2YXIgaTtjb25zdCByPSh0LGksbik9Pntjb25zdCByPXMuY3JlYXRlKCk7cy50cmFuc2xhdGUocixyLGkpLGF0KHQucG9zaXRpb24sciksbi5wb3NpdGlvbnMucHVzaCh0LnBvc2l0aW9uKSxuLnRleHR1cmVDb29yZGluYXRlcy5wdXNoKC4uLnQudGV4Q29vcmQpLG4udGludENvbG9ycy5wdXNoKC4uLnQudGludENvbG9yKTtmb3IobGV0IHM9MDtzPHQucG9zaXRpb24ubGVuZ3RoO3MrPTEyKXtjb25zdCBpPWUuZnJvbVZhbHVlcyh0LnBvc2l0aW9uW3NdLHQucG9zaXRpb25bcysxXSx0LnBvc2l0aW9uW3MrMl0pLHI9ZS5mcm9tVmFsdWVzKHQucG9zaXRpb25bcyszXSx0LnBvc2l0aW9uW3MrNF0sdC5wb3NpdGlvbltzKzVdKSxvPWUuZnJvbVZhbHVlcyh0LnBvc2l0aW9uW3MrNl0sdC5wb3NpdGlvbltzKzddLHQucG9zaXRpb25bcys4XSk7ZS5zdWJ0cmFjdChyLHIsaSksZS5zdWJ0cmFjdChvLG8saSksZS5jcm9zcyhyLHIsbyksZS5ub3JtYWxpemUocixyKSxuLm5vcm1hbHMucHVzaCguLi5yLC4uLnIsLi4uciwuLi5yKX1mb3IobGV0IGU9MDtlPHQudGV4Q29vcmQubGVuZ3RoLzI7ZSs9MSluLmJsb2NrUG9zaXRpb25zLnB1c2goLi4uaSk7bi5pbmRpY2VzLnB1c2goLi4udC5pbmRleCksbi5pbmRleE9mZnNldCs9dC50ZXhDb29yZC5sZW5ndGgvMn0sbz10PT57dC5wb3NpdGlvbnM9W10sdC50ZXh0dXJlQ29vcmRpbmF0ZXM9W10sdC50aW50Q29sb3JzPVtdLHQuYmxvY2tQb3NpdGlvbnM9W10sdC5ub3JtYWxzPVtdLHQuaW5kaWNlcz1bXSx0LmluZGV4T2Zmc2V0PTB9LGE9dD0+e3QuYnVmZmVyPyh0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci5wb3NpdGlvbix0aGlzLmdsLkFSUkFZX0JVRkZFUixvdCguLi50LnBvc2l0aW9ucykpLHRoaXMudXBkYXRlQnVmZmVyKHQuYnVmZmVyLnRleENvb3JkLHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC50ZXh0dXJlQ29vcmRpbmF0ZXMpKSx0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci50aW50Q29sb3IsdGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0LnRpbnRDb2xvcnMpKSx0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci5ub3JtYWwsdGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0Lm5vcm1hbHMpKSx0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci5ibG9ja1Bvcyx0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQuYmxvY2tQb3NpdGlvbnMpKSx0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci5pbmRleCx0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG5ldyBVaW50MTZBcnJheSh0LmluZGljZXMpKSx0LmJ1ZmZlci5sZW5ndGg9dC5pbmRpY2VzLmxlbmd0aCk6dC5idWZmZXI9e3Bvc2l0aW9uOnRoaXMuY3JlYXRlQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG90KC4uLnQucG9zaXRpb25zKSksdGV4Q29vcmQ6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0LnRleHR1cmVDb29yZGluYXRlcykpLHRpbnRDb2xvcjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQudGludENvbG9ycykpLGJsb2NrUG9zOnRoaXMuY3JlYXRlQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC5ibG9ja1Bvc2l0aW9ucykpLG5vcm1hbDp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQubm9ybWFscykpLGluZGV4OnRoaXMuY3JlYXRlQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbmV3IFVpbnQxNkFycmF5KHQuaW5kaWNlcykpLGxlbmd0aDp0LmluZGljZXMubGVuZ3RofX07bGV0IGw7dD90LmZvckVhY2goKHQ9Pntjb25zdCBlPXRoaXMuZ2V0Q2h1bmsodCk7byhlKX0pKTp0aGlzLmNodW5rcy5mb3JFYWNoKCh0PT50LmZvckVhY2goKHQ9PnQuZm9yRWFjaCgodD0+e28odCl9KSkpKSkpO2Zvcihjb25zdCBzIG9mIHRoaXMuc3RydWN0dXJlLmdldEJsb2NrcygpKXtjb25zdCBvPXMuc3RhdGUuZ2V0TmFtZSgpLGE9cy5zdGF0ZS5nZXRQcm9wZXJ0aWVzKCksaD1udWxsIT09KGk9dGhpcy5yZXNvdXJjZXMuZ2V0RGVmYXVsdEJsb2NrUHJvcGVydGllcyhvKSkmJnZvaWQgMCE9PWk/aTp7fTtPYmplY3QuZW50cmllcyhoKS5mb3JFYWNoKCgoW3QsZV0pPT57YVt0XXx8KGFbdF09ZSl9KSk7Y29uc3QgdT1bTWF0aC5mbG9vcihzLnBvc1swXS90aGlzLmNodW5rU2l6ZSksTWF0aC5mbG9vcihzLnBvc1sxXS90aGlzLmNodW5rU2l6ZSksTWF0aC5mbG9vcihzLnBvc1syXS90aGlzLmNodW5rU2l6ZSldO2lmKHQmJiF0LnNvbWUoKHQ9PmUuZXF1YWxzKHQsdSkpKSljb250aW51ZTtjb25zdCBjPXRoaXMuZ2V0Q2h1bmsodSk7dHJ5e2NvbnN0IHQ9dGhpcy5yZXNvdXJjZXMuZ2V0QmxvY2tEZWZpbml0aW9uKG8pLGU9e3VwOnRoaXMubmVlZHNDdWxsKHMsbi5VUCksZG93bjp0aGlzLm5lZWRzQ3VsbChzLG4uRE9XTiksd2VzdDp0aGlzLm5lZWRzQ3VsbChzLG4uV0VTVCksZWFzdDp0aGlzLm5lZWRzQ3VsbChzLG4uRUFTVCksbm9ydGg6dGhpcy5uZWVkc0N1bGwocyxuLk5PUlRIKSxzb3V0aDp0aGlzLm5lZWRzQ3VsbChzLG4uU09VVEgpfTt0JiYobD10LmdldEJ1ZmZlcnMobyxhLHRoaXMucmVzb3VyY2VzLHRoaXMucmVzb3VyY2VzLGMuaW5kZXhPZmZzZXQsZSkscihsLHMucG9zLGMpKSxidC5oYXMobykmJihsPXZ0W29dKGMuaW5kZXhPZmZzZXQsYSx0aGlzLnJlc291cmNlcyxlKSxyKGwscy5wb3MsYykpfWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IoYEVycm9yIHJlbmRlcmluZyBibG9jayAke299YCx0KX19dD90LmZvckVhY2goKHQ9Pntjb25zdCBlPXRoaXMuZ2V0Q2h1bmsodCk7YShlKX0pKTp0aGlzLmNodW5rcy5mb3JFYWNoKCh0PT50LmZvckVhY2goKHQ9PnQuZm9yRWFjaCgodD0+e2EodCl9KSkpKSkpfW5lZWRzQ3VsbCh0LGUpe3ZhciBzLGk7Y29uc3Qgcj1udWxsPT09KHM9dGhpcy5zdHJ1Y3R1cmUuZ2V0QmxvY2soby50b3dhcmRzKHQucG9zLGUpKSl8fHZvaWQgMD09PXM/dm9pZCAwOnMuc3RhdGU7cmV0dXJuISFyJiYoKG51bGw9PT0oaT10aGlzLnJlc291cmNlcy5nZXRCbG9ja0ZsYWdzKHIuZ2V0TmFtZSgpKSl8fHZvaWQgMD09PWk/dm9pZCAwOmkub3BhcXVlKT8hKGU9PT1uLlVQJiZ0LnN0YXRlLmlzRmx1aWQoKSk6dC5zdGF0ZS5pc0ZsdWlkKCkmJnIuaXNGbHVpZCgpKX1nZXRHcmlkQnVmZmVycygpe2NvbnN0W3QsZSxzXT10aGlzLnN0cnVjdHVyZS5nZXRTaXplKCksaT1bXSxuPVtdO2kucHVzaCgwLDAsMCx0LDAsMCksbi5wdXNoKDEsMCwwLDEsMCwwKSxpLnB1c2goMCwwLDAsMCwwLHMpLG4ucHVzaCgwLDAsMSwwLDAsMSksaS5wdXNoKDAsMCwwLDAsZSwwKSxpLnB1c2godCwwLDAsdCxlLDApLGkucHVzaCgwLDAscywwLGUscyksaS5wdXNoKHQsMCxzLHQsZSxzKSxpLnB1c2goMCxlLDAsMCxlLHMpLGkucHVzaCh0LGUsMCx0LGUscyksaS5wdXNoKDAsZSwwLHQsZSwwKSxpLnB1c2goMCxlLHMsdCxlLHMpO2ZvcihsZXQgZT0xO2U8PXQ7ZSs9MSlpLnB1c2goZSwwLDAsZSwwLHMpO2ZvcihsZXQgZT0xO2U8PXM7ZSs9MSlpLnB1c2goMCwwLGUsdCwwLGUpO2ZvcihsZXQgZT0wO2U8OCt0K3M7ZSs9MSluLnB1c2goLjgsLjgsLjgsLjgsLjgsLjgpO3JldHVybntwb3NpdGlvbjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KGkpKSxjb2xvcjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KG4pKSxsZW5ndGg6aS5sZW5ndGgvM319Z2V0T3V0bGluZUJ1ZmZlcnMoKXtjb25zdCB0PVtdLGU9W107cmV0dXJuIHRoaXMuYWRkQ3ViZSh0LGUsWzEsMSwxXSxbMCwwLDBdLFsxLDEsMV0pLHtwb3NpdGlvbjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQpKSxjb2xvcjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KGUpKSxsZW5ndGg6dC5sZW5ndGgvM319Z2V0SW52aXNpYmxlQmxvY2tCdWZmZXJzKCl7aWYoIXRoaXMudXNlSW52aXNpYmxlQmxvY2tCdWZmZXIpcmV0dXJuO2NvbnN0IHQ9dGhpcy5zdHJ1Y3R1cmUuZ2V0U2l6ZSgpLGU9W10scz1bXTtmb3IobGV0IGk9MDtpPHRbMF07aSs9MSlmb3IobGV0IG49MDtuPHRbMV07bis9MSlmb3IobGV0IHI9MDtyPHRbMl07cis9MSl7Y29uc3QgdD10aGlzLnN0cnVjdHVyZS5nZXRCbG9jayhbaSxuLHJdKTt2b2lkIDAhPT10JiYobnVsbD09PXQ/dGhpcy5hZGRDdWJlKGUscyxbMSwuMjUsLjI1XSxbaSsuNDM3NSxuKy40Mzc1LHIrLjQzNzVdLFtpKy41NjI1LG4rLjU2MjUscisuNTYyNV0pOlwibWluZWNyYWZ0OmFpclwiPT09dC5zdGF0ZS5nZXROYW1lKCk/dGhpcy5hZGRDdWJlKGUscyxbLjUsLjUsMV0sW2krLjM3NSxuKy4zNzUscisuMzc1XSxbaSsuNjI1LG4rLjYyNSxyKy42MjVdKTpcIm1pbmVjcmFmdDpjYXZlX2FpclwiPT09dC5zdGF0ZS5nZXROYW1lKCkmJnRoaXMuYWRkQ3ViZShlLHMsWy41LDEsLjVdLFtpKy4zNzUsbisuMzc1LHIrLjM3NV0sW2krLjYyNSxuKy42MjUscisuNjI1XSkpfXJldHVybntwb3NpdGlvbjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KGUpKSxjb2xvcjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHMpKSxsZW5ndGg6ZS5sZW5ndGgvM319YWRkQ3ViZSh0LGUscyxpLG4pe3QucHVzaChpWzBdLGlbMV0saVsyXSxpWzBdLGlbMV0sblsyXSksdC5wdXNoKG5bMF0saVsxXSxpWzJdLG5bMF0saVsxXSxuWzJdKSx0LnB1c2goaVswXSxpWzFdLGlbMl0sblswXSxpWzFdLGlbMl0pLHQucHVzaChpWzBdLGlbMV0sblsyXSxuWzBdLGlbMV0sblsyXSksdC5wdXNoKGlbMF0saVsxXSxpWzJdLGlbMF0sblsxXSxpWzJdKSx0LnB1c2goblswXSxpWzFdLGlbMl0sblswXSxuWzFdLGlbMl0pLHQucHVzaChpWzBdLGlbMV0sblsyXSxpWzBdLG5bMV0sblsyXSksdC5wdXNoKG5bMF0saVsxXSxuWzJdLG5bMF0sblsxXSxuWzJdKSx0LnB1c2goaVswXSxuWzFdLGlbMl0saVswXSxuWzFdLG5bMl0pLHQucHVzaChuWzBdLG5bMV0saVsyXSxuWzBdLG5bMV0sblsyXSksdC5wdXNoKGlbMF0sblsxXSxpWzJdLG5bMF0sblsxXSxpWzJdKSx0LnB1c2goaVswXSxuWzFdLG5bMl0sblswXSxuWzFdLG5bMl0pO2ZvcihsZXQgdD0wO3Q8MjQ7dCs9MSllLnB1c2goLi4ucyl9Y3JlYXRlQnVmZmVyKHQsZSl7Y29uc3Qgcz10aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO3JldHVybiB0aGlzLmdsLmJpbmRCdWZmZXIodCxzKSx0aGlzLmdsLmJ1ZmZlckRhdGEodCxlLHRoaXMuZ2wuRFlOQU1JQ19EUkFXKSxzfXVwZGF0ZUJ1ZmZlcih0LGUscyl7dGhpcy5nbC5iaW5kQnVmZmVyKGUsdCksdGhpcy5nbC5idWZmZXJEYXRhKGUscyx0aGlzLmdsLlNUQVRJQ19EUkFXKX1kcmF3R3JpZCh0KXt0aGlzLnNldFNoYWRlcih0aGlzLmdyaWRTaGFkZXJQcm9ncmFtKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0aGlzLmdyaWRCdWZmZXJzLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0Q29sb3JcIiwzLHRoaXMuZ3JpZEJ1ZmZlcnMuY29sb3IpLHRoaXMuc2V0VW5pZm9ybShcIm1WaWV3XCIsdCksdGhpcy5zZXRVbmlmb3JtKFwibVByb2pcIix0aGlzLnByb2pNYXRyaXgpLHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLkxJTkVTLDAsdGhpcy5ncmlkQnVmZmVycy5sZW5ndGgpfWRyYXdJbnZpc2libGVCbG9ja3ModCl7dGhpcy51c2VJbnZpc2libGVCbG9ja0J1ZmZlciYmKHRoaXMuc2V0U2hhZGVyKHRoaXMuZ3JpZFNoYWRlclByb2dyYW0pLHRoaXMuc2V0VmVydGV4QXR0cihcInZlcnRQb3NcIiwzLHRoaXMuaW52aXNpYmxlQmxvY2tCdWZmZXJzLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0Q29sb3JcIiwzLHRoaXMuaW52aXNpYmxlQmxvY2tCdWZmZXJzLmNvbG9yKSx0aGlzLnNldFVuaWZvcm0oXCJtVmlld1wiLHQpLHRoaXMuc2V0VW5pZm9ybShcIm1Qcm9qXCIsdGhpcy5wcm9qTWF0cml4KSx0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5MSU5FUywwLHRoaXMuaW52aXNpYmxlQmxvY2tCdWZmZXJzLmxlbmd0aCkpfWRyYXdTdHJ1Y3R1cmUodCl7dGhpcy5zZXRTaGFkZXIodGhpcy5zaGFkZXJQcm9ncmFtKSx0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCksdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsdGhpcy5hdGxhc1RleHR1cmUpLHRoaXMuc2V0VW5pZm9ybShcIm1WaWV3XCIsdCksdGhpcy5zZXRVbmlmb3JtKFwibVByb2pcIix0aGlzLnByb2pNYXRyaXgpLHRoaXMuY2h1bmtzLmZvckVhY2goKHQ9Pnt0LmZvckVhY2goKHQ9Pnt0LmZvckVhY2goKHQ9Pnt0LmJ1ZmZlciYmKHRoaXMuc2V0VmVydGV4QXR0cihcInZlcnRQb3NcIiwzLHQuYnVmZmVyLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ0ZXhDb29yZFwiLDIsdC5idWZmZXIudGV4Q29vcmQpLHRoaXMuc2V0VmVydGV4QXR0cihcInRpbnRDb2xvclwiLDMsdC5idWZmZXIudGludENvbG9yKSx0aGlzLnNldFZlcnRleEF0dHIoXCJub3JtYWxcIiwzLHQuYnVmZmVyLm5vcm1hbCksdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsdC5idWZmZXIuaW5kZXgpLHRoaXMuZ2wuZHJhd0VsZW1lbnRzKHRoaXMuZ2wuVFJJQU5HTEVTLHQuYnVmZmVyLmxlbmd0aCx0aGlzLmdsLlVOU0lHTkVEX1NIT1JULDApKX0pKX0pKX0pKX1kcmF3Q29sb3JlZFN0cnVjdHVyZSh0KXt0aGlzLnNldFNoYWRlcih0aGlzLmNvbG9yU2hhZGVyUHJvZ3JhbSksdGhpcy5zZXRVbmlmb3JtKFwibVZpZXdcIix0KSx0aGlzLnNldFVuaWZvcm0oXCJtUHJvalwiLHRoaXMucHJvak1hdHJpeCksdGhpcy5jaHVua3MuZm9yRWFjaCgodD0+e3QuZm9yRWFjaCgodD0+e3QuZm9yRWFjaCgodD0+e3QuYnVmZmVyJiYodGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydFBvc1wiLDMsdC5idWZmZXIucG9zaXRpb24pLHRoaXMuc2V0VmVydGV4QXR0cihcImJsb2NrUG9zXCIsMyx0LmJ1ZmZlci5ibG9ja1BvcyksdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsdC5idWZmZXIuaW5kZXgpLHRoaXMuZ2wuZHJhd0VsZW1lbnRzKHRoaXMuZ2wuVFJJQU5HTEVTLHQuYnVmZmVyLmxlbmd0aCx0aGlzLmdsLlVOU0lHTkVEX1NIT1JULDApKX0pKX0pKX0pKX1kcmF3T3V0bGluZSh0LGUpe3RoaXMuc2V0U2hhZGVyKHRoaXMuZ3JpZFNoYWRlclByb2dyYW0pLHRoaXMuc2V0VmVydGV4QXR0cihcInZlcnRQb3NcIiwzLHRoaXMub3V0bGluZUJ1ZmZlcnMucG9zaXRpb24pLHRoaXMuc2V0VmVydGV4QXR0cihcInZlcnRDb2xvclwiLDMsdGhpcy5vdXRsaW5lQnVmZmVycy5jb2xvcik7Y29uc3QgaT1zLmNyZWF0ZSgpO3MuY29weShpLHQpLHMudHJhbnNsYXRlKGksaSxlKSx0aGlzLnNldFVuaWZvcm0oXCJtVmlld1wiLGkpLHRoaXMuc2V0VW5pZm9ybShcIm1Qcm9qXCIsdGhpcy5wcm9qTWF0cml4KSx0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5MSU5FUywwLHRoaXMub3V0bGluZUJ1ZmZlcnMubGVuZ3RoKX1zZXRWaWV3cG9ydCh0LGUscyxpKXt0aGlzLmdsLnZpZXdwb3J0KHQsZSxzLGkpLHRoaXMucHJvak1hdHJpeD10aGlzLmdldFBlcnNwZWN0aXZlKCl9c2V0U2hhZGVyKHQpe3RoaXMuZ2wudXNlUHJvZ3JhbSh0KSx0aGlzLmFjdGl2ZVNoYWRlcj10fXNldFZlcnRleEF0dHIodCxlLHMpe2NvbnN0IGk9dGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLmFjdGl2ZVNoYWRlcix0KTt0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIscyksdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGksZSx0aGlzLmdsLkZMT0FULCExLDAsMCksdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKX1zZXRVbmlmb3JtKHQsZSl7Y29uc3Qgcz10aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmFjdGl2ZVNoYWRlcix0KTt0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYocywhMSxlKX19XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9mdW5jdGlvbiBQdCh0LGUscyxpKXtyZXR1cm4gbmV3KHN8fChzPVByb21pc2UpKSgoZnVuY3Rpb24obixyKXtmdW5jdGlvbiBvKHQpe3RyeXtsKGkubmV4dCh0KSl9Y2F0Y2godCl7cih0KX19ZnVuY3Rpb24gYSh0KXt0cnl7bChpLnRocm93KHQpKX1jYXRjaCh0KXtyKHQpfX1mdW5jdGlvbiBsKHQpe3ZhciBlO3QuZG9uZT9uKHQudmFsdWUpOihlPXQudmFsdWUsZSBpbnN0YW5jZW9mIHM/ZTpuZXcgcygoZnVuY3Rpb24odCl7dChlKX0pKSkudGhlbihvLGEpfWwoKGk9aS5hcHBseSh0LGV8fFtdKSkubmV4dCgpKX0pKX1jbGFzcyB4dHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuaW1nPXQsdGhpcy5pZE1hcD1lLHRoaXMucGFydD0xNi90LndpZHRofWdldFRleHR1cmVBdGxhcygpe3JldHVybiB0aGlzLmltZ31nZXRUZXh0dXJlVVYodCl7dmFyIGU7cmV0dXJuIG51bGwhPT0oZT10aGlzLmlkTWFwW3RdKSYmdm9pZCAwIT09ZT9lOlswLDAsdGhpcy5wYXJ0LHRoaXMucGFydF19c3RhdGljIGZyb21CbG9icyh0KXtyZXR1cm4gUHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBlPU1hdGguc3FydChPYmplY3Qua2V5cyh0KS5sZW5ndGgrMSkscz1NYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhlKS9NYXRoLmxvZygyKSkpLGk9MTYqcyxuPTEvcyxyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7ci53aWR0aD1pLHIuaGVpZ2h0PWk7Y29uc3Qgbz1yLmdldENvbnRleHQoXCIyZFwiKTt0aGlzLmRyYXdJbnZhbGlkVGV4dHVyZShvKTtjb25zdCBhPXt9O2xldCBsPTE7cmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHQpLm1hcCgoZT0+UHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBpPWwlcyxyPU1hdGguZmxvb3IobC9zKTtsKz0xLGFbZV09W24qaSxuKnIsbippK24sbipyK25dO2NvbnN0IGg9eWllbGQgY3JlYXRlSW1hZ2VCaXRtYXAodFtlXSk7by5kcmF3SW1hZ2UoaCwwLDAsMTYsMTYsMTYqaSwxNipyLDE2LDE2KX0pKSkpKSxuZXcgeHQoby5nZXRJbWFnZURhdGEoMCwwLGksaSksYSl9KSl9c3RhdGljIGVtcHR5KCl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Qud2lkdGg9MTYsdC5oZWlnaHQ9MTY7Y29uc3QgZT10LmdldENvbnRleHQoXCIyZFwiKTtyZXR1cm4geHQuZHJhd0ludmFsaWRUZXh0dXJlKGUpLG5ldyB4dChlLmdldEltYWdlRGF0YSgwLDAsMTYsMTYpLHt9KX1zdGF0aWMgZHJhd0ludmFsaWRUZXh0dXJlKHQpe3QuZmlsbFN0eWxlPVwiYmxhY2tcIix0LmZpbGxSZWN0KDAsMCwxNiwxNiksdC5maWxsU3R5bGU9XCJtYWdlbnRhXCIsdC5maWxsUmVjdCgwLDAsOCw4KSx0LmZpbGxSZWN0KDgsOCw4LDgpfX12YXIgeXQsQXQsU3QsQnQsRXQsQ3QsSXQsa3Q7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9uZXcgcyh0LG51bGwhPWU/ZTp0KTp0fXQudGFyZ2V0PWZ1bmN0aW9uKHQsZSxzLGkscixvKXtyZXR1cm4gbmV3IG4odCxlLHMsaSxyLG8pfSx0LnBhcmFtZXRlcnM9ZnVuY3Rpb24odCxzLG4scixvLGEsbCl7cmV0dXJuIG5ldyBpKGUodCksZShzKSxlKG4pLGUociksZShvKSxlKGEpLGwpfSx0LnBhcmFtPWU7Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubWluPXQsdGhpcy5tYXg9ZX1kaXN0YW5jZSh0KXtjb25zdCBlPShcIm51bWJlclwiPT10eXBlb2YgdD90OnQubWluKS10aGlzLm1heCxzPXRoaXMubWluLShcIm51bWJlclwiPT10eXBlb2YgdD90OnQubWF4KTtyZXR1cm4gZT4wP2U6TWF0aC5tYXgocywwKX11bmlvbih0KXtyZXR1cm4gbmV3IHMoTWF0aC5taW4odGhpcy5taW4sdC5taW4pLE1hdGgubWF4KHRoaXMubWF4LHQubWF4KSl9c3RhdGljIGZyb21Kc29uKHQpe3ZhciBlO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiBuZXcgcyh0LHQpO2NvbnN0W2ksbl09bnVsbCE9PShlPWsucmVhZEFycmF5KHQsKHQ9PmsucmVhZE51bWJlcih0KSkpKSYmdm9pZCAwIT09ZT9lOltdO3JldHVybiBuZXcgcyhudWxsIT1pP2k6MCxudWxsIT1uP246MCl9fXQuUGFyYW09cztjbGFzcyBpe2NvbnN0cnVjdG9yKHQsZSxzLGksbixyLG8pe3RoaXMudGVtcGVyYXR1cmU9dCx0aGlzLmh1bWlkaXR5PWUsdGhpcy5jb250aW5lbnRhbG5lc3M9cyx0aGlzLmVyb3Npb249aSx0aGlzLmRlcHRoPW4sdGhpcy53ZWlyZG5lc3M9cix0aGlzLm9mZnNldD1vfWZpdHRuZXNzKHQpe3JldHVybiBGKHRoaXMudGVtcGVyYXR1cmUuZGlzdGFuY2UodC50ZW1wZXJhdHVyZSkpK0YodGhpcy5odW1pZGl0eS5kaXN0YW5jZSh0Lmh1bWlkaXR5KSkrRih0aGlzLmNvbnRpbmVudGFsbmVzcy5kaXN0YW5jZSh0LmNvbnRpbmVudGFsbmVzcykpK0YodGhpcy5lcm9zaW9uLmRpc3RhbmNlKHQuZXJvc2lvbikpK0YodGhpcy5kZXB0aC5kaXN0YW5jZSh0LmRlcHRoKSkrRih0aGlzLndlaXJkbmVzcy5kaXN0YW5jZSh0LndlaXJkbmVzcykpK0YodGhpcy5vZmZzZXQtdC5vZmZzZXQpfXNwYWNlKCl7cmV0dXJuW3RoaXMudGVtcGVyYXR1cmUsdGhpcy5odW1pZGl0eSx0aGlzLmNvbnRpbmVudGFsbmVzcyx0aGlzLmVyb3Npb24sdGhpcy5kZXB0aCx0aGlzLndlaXJkbmVzcyxuZXcgcyh0aGlzLm9mZnNldCx0aGlzLm9mZnNldCldfXN0YXRpYyBmcm9tSnNvbih0KXt2YXIgZSxuO2NvbnN0IHI9bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm4gbmV3IGkocy5mcm9tSnNvbihyLnRlbXBlcmF0dXJlKSxzLmZyb21Kc29uKHIuaHVtaWRpdHkpLHMuZnJvbUpzb24oci5jb250aW5lbnRhbG5lc3MpLHMuZnJvbUpzb24oci5lcm9zaW9uKSxzLmZyb21Kc29uKHIuZGVwdGgpLHMuZnJvbUpzb24oci53ZWlyZG5lc3MpLG51bGwhPT0obj1rLnJlYWRJbnQoci5vZmZzZXQpKSYmdm9pZCAwIT09bj9uOjApfX10LlBhcmFtUG9pbnQ9aTtjbGFzcyBue2NvbnN0cnVjdG9yKHQsZSxzLGksbixyKXt0aGlzLnRlbXBlcmF0dXJlPXQsdGhpcy5odW1pZGl0eT1lLHRoaXMuY29udGluZW50YWxuZXNzPXMsdGhpcy5lcm9zaW9uPWksdGhpcy5kZXB0aD1uLHRoaXMud2VpcmRuZXNzPXJ9Z2V0IG9mZnNldCgpe3JldHVybiAwfXRvQXJyYXkoKXtyZXR1cm5bdGhpcy50ZW1wZXJhdHVyZSx0aGlzLmh1bWlkaXR5LHRoaXMuY29udGluZW50YWxuZXNzLHRoaXMuZXJvc2lvbix0aGlzLmRlcHRoLHRoaXMud2VpcmRuZXNzLHRoaXMub2Zmc2V0XX19dC5UYXJnZXRQb2ludD1uO3QuUGFyYW1ldGVycz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnRoaW5ncz10LHRoaXMuaW5kZXg9bmV3IHIodCl9ZmluZCh0KXtyZXR1cm4gdGhpcy5pbmRleC5zZWFyY2godCwoKHQsZSk9PnQuZGlzdGFuY2UoZSkpKX19O2NsYXNzIHJ7Y29uc3RydWN0b3IodCl7dGhpcy5yb290PXIuYnVpbGQodC5tYXAoKChbdCxlXSk9Pm5ldyBsKHQsZSkpKSl9c3RhdGljIGJ1aWxkKHQpe2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtpZih0Lmxlbmd0aDw9ci5DSElMRFJFTl9QRVJfTk9ERSl7Y29uc3QgZT10Lm1hcCgodD0+e2xldCBlPTA7Zm9yKGxldCBzPTA7czw3O3MrPTEpe2NvbnN0IGk9dC5zcGFjZVtzXTtlKz1NYXRoLmFicygoaS5taW4raS5tYXgpLzIpfXJldHVybntrZXk6ZSxub2RlOnR9fSkpLnNvcnQoKCh0LGUpPT50LmtleS1lLmtleSkpLm1hcCgoKHtub2RlOnR9KT0+dCkpO3JldHVybiBuZXcgYShlKX1sZXQgZT0xLzAscz0tMSxpPVtdO2ZvcihsZXQgbj0wO248NzsrK24pe3Iuc29ydCh0LG4sITEpLGk9ci5idWNrZXRpemUodCk7bGV0IG89MDtmb3IoY29uc3QgdCBvZiBpKW8rPXIuYXJlYSh0LnNwYWNlKTtlPm8mJihlPW8scz1uKX1yZXR1cm4gdD1yLnNvcnQodCxzLCExKSxpPXIuYnVja2V0aXplKHQpLGk9ci5zb3J0KGkscywhMCksbmV3IGEoaS5tYXAoKHQ9PnIuYnVpbGQodC5jaGlsZHJlbikpKSl9c3RhdGljIHNvcnQodCxlLHMpe3JldHVybiB0Lm1hcCgodD0+e2NvbnN0IGk9dC5zcGFjZVtlXSxuPShpLm1pbitpLm1heCkvMjtyZXR1cm57a2V5OnM/TWF0aC5hYnMobik6bixub2RlOnR9fSkpLnNvcnQoKCh0LGUpPT50LmtleS1lLmtleSkpLm1hcCgoKHtub2RlOnR9KT0+dCkpfXN0YXRpYyBidWNrZXRpemUodCl7Y29uc3QgZT1bXTtsZXQgcz1bXTtjb25zdCBpPU1hdGgucG93KDEwLE1hdGguZmxvb3IoTWF0aC5sb2codC5sZW5ndGgtLjAxKS9NYXRoLmxvZygxMCkpKTtmb3IoY29uc3QgbiBvZiB0KXMucHVzaChuKSxzLmxlbmd0aDxpfHwoZS5wdXNoKG5ldyBhKHMpKSxzPVtdKTtyZXR1cm4gMCE9PXMubGVuZ3RoJiZlLnB1c2gobmV3IGEocykpLGV9c3RhdGljIGFyZWEodCl7bGV0IGU9MDtmb3IoY29uc3QgcyBvZiB0KWUrPU1hdGguYWJzKHMubWF4LXMubWluKTtyZXR1cm4gZX1zZWFyY2godCxlKXtyZXR1cm4gdGhpcy5yb290LnNlYXJjaCh0LnRvQXJyYXkoKSxlKS50aGluZygpfX1yLkNISUxEUkVOX1BFUl9OT0RFPTEwLHQuUlRyZWU9cjtjbGFzcyBve2NvbnN0cnVjdG9yKHQpe3RoaXMuc3BhY2U9dH1kaXN0YW5jZSh0KXtsZXQgZT0wO2ZvcihsZXQgcz0wO3M8NztzKz0xKWUrPUYodGhpcy5zcGFjZVtzXS5kaXN0YW5jZSh0W3NdKSk7cmV0dXJuIGV9fXQuUk5vZGU9bztjbGFzcyBhIGV4dGVuZHMgb3tjb25zdHJ1Y3Rvcih0KXtzdXBlcihhLmJ1aWxkU3BhY2UodCkpLHRoaXMuY2hpbGRyZW49dH1zdGF0aWMgYnVpbGRTcGFjZSh0KXtsZXQgZT1bLi4uQXJyYXkoNyldLm1hcCgoKCk9Pm5ldyBzKDEvMCwtMS8wKSkpO2Zvcihjb25zdCBzIG9mIHQpZT1bLi4uQXJyYXkoNyldLm1hcCgoKHQsaSk9PmVbaV0udW5pb24ocy5zcGFjZVtpXSkpKTtyZXR1cm4gZX1zZWFyY2godCxlKXtsZXQgcz0xLzAsaT1udWxsO2Zvcihjb25zdCBuIG9mIHRoaXMuY2hpbGRyZW4pe2NvbnN0IHI9ZShuLHQpO2lmKHM8PXIpY29udGludWU7Y29uc3Qgbz1uLnNlYXJjaCh0LGUpLGE9bj09bz9yOmUobyx0KTtzPD1hfHwocz1hLGk9byl9cmV0dXJuIGl9fXQuUlN1YlRyZWU9YTtjbGFzcyBsIGV4dGVuZHMgb3tjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQuc3BhY2UoKSksdGhpcy50aGluZz1lfXNlYXJjaCgpe3JldHVybiB0aGlzfX10LlJMZWFmPWx9KHl0fHwoeXQ9e30pKTtjbGFzcyBSdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmJpb21lPXR9Z2V0QmlvbWUoKXtyZXR1cm4gdGhpcy5iaW9tZX1zdGF0aWMgZnJvbUpzb24odCl7dmFyIGUscztjb25zdCBpPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e30sbj1udWxsIT09KHM9ay5yZWFkU3RyaW5nKGkuYmlvbWUpKSYmdm9pZCAwIT09cz9zOlwibWluZWNyYWZ0OnRoZV92b2lkXCI7cmV0dXJuIG5ldyBSdChuKX19Y2xhc3MgX3R7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJhbWV0ZXJzPXR9Z2V0QmlvbWUodCxlLHMsaSl7Y29uc3Qgbj1pKHQsZSxzKTtyZXR1cm4gdGhpcy5wYXJhbWV0ZXJzLmZpbmQobil9c3RhdGljIGZyb21Kc29uKHQpe3ZhciBlLHM7Y29uc3QgaT1udWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9LG49KG51bGwhPT0ocz1rLnJlYWRBcnJheShpLmJpb21lcywodD0+e3ZhciBlO3JldHVybih0PT57dmFyIGU7cmV0dXJue2Jpb21lOm51bGwhPT0oZT1rLnJlYWRTdHJpbmcodC5iaW9tZSkpJiZ2b2lkIDAhPT1lP2U6XCJtaW5lY3JhZnQ6dGhlX3ZvaWRcIixwYXJhbWV0ZXJzOnl0LlBhcmFtUG9pbnQuZnJvbUpzb24odC5wYXJhbWV0ZXJzKX19KShudWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9KX0pKSkmJnZvaWQgMCE9PXM/czpbXSkubWFwKCh0PT5bdC5wYXJhbWV0ZXJzLCgpPT50LmJpb21lXSkpO3JldHVybiBuZXcgX3QobmV3IHl0LlBhcmFtZXRlcnMobikpfX0hZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gaC5hcHBseSh0KSsuMDE1fWZ1bmN0aW9uIHModCl7cmV0dXJuIHUuYXBwbHkodCl9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gYy5hcHBseSh0KX1mdW5jdGlvbiBuKHQpe3JldHVybiAzKi0oTWF0aC5hYnMoTWF0aC5hYnModCktLjY2NjY2NjcpLS4zMzMzMzMzNCl9dC5vZmZzZXQ9ZSx0LmZhY3Rvcj1zLHQucGVha3M9aSx0LnBlYWtzQW5kVmFsbGV5cz1uLHQucG9pbnQ9ZnVuY3Rpb24odCxlLHMpe3JldHVybntjb250aW5lbnRzOnQsZXJvc2lvbjplLHdlaXJkbmVzczpzLHJpZGdlczpuKHMpfX0sdC5uZWFyV2F0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHQ8LS4yKSYmKHQ8LS4wNXx8TWF0aC5hYnMoZSk8LjE1KX0sdC5zaGFwZT1mdW5jdGlvbih0LG4pe3JldHVybntvZmZzZXQ6ZSh0KSxmYWN0b3I6cyh0KSxwZWFrczppKHQpLG5lYXJXYXRlcjpufX07Y29uc3Qgcj1mKFwiYmVhY2hTcGxpbmVcIiwtLjE1LC0uMDUsMCwwLC4xLDAsLS4wMywhMSwhMSksbz1mKFwibG93U3BsaW5lXCIsLS4xLC0uMSwuMDMsLjEsLjEsLjAxLC0uMDMsITEsITEpLGE9ZihcIm1pZFNwbGluZVwiLC0uMSwtLjEsLjAzLC4xLC43LC4wMSwtLjAzLCEwLCEwKSxsPWYoXCJoaWdoU3BsaW5lXCIsLS4wNSwuMywuMDMsLjEsMSwuMDEsLjAxLCEwLCEwKSxoPW5ldyBaKFwib2Zmc2V0U2FtcGxlclwiLCh0PT50LmNvbnRpbmVudHMpKS5hZGRQb2ludCgtMS4xLC4wNDQpLmFkZFBvaW50KC0xLjAyLC0uMjIyMikuYWRkUG9pbnQoLS41MSwtLjIyMjIpLmFkZFBvaW50KC0uNDQsLS4xMikuYWRkUG9pbnQoLS4xOCwtLjEyKS5hZGRQb2ludCgtLjE2LHIpLmFkZFBvaW50KC0uMTUscikuYWRkUG9pbnQoLS4xLG8pLmFkZFBvaW50KC4yNSxhKS5hZGRQb2ludCgxLGwpLHU9bmV3IFooXCJGYWN0b3ItQ29udGluZW50c1wiLCh0PT50LmNvbnRpbmVudHMpKS5hZGRQb2ludCgtLjE5LDUwNSkuYWRkUG9pbnQoLS4xNSxkKFwiZXJvc2lvbkNvYXN0XCIsODAwLCEwLFwicmlkZ2VDb2FzdC1PbGRNb3VudGFpbnNcIikpLmFkZFBvaW50KC0uMSxkKFwiZXJvc2lvbklubGFuZFwiLDcwMCwhMCxcInJpZGdlSW5sYW5kLU9sZE1vdW50YWluc1wiKSkuYWRkUG9pbnQoLjAzLGQoXCJlcm9zaW9uTWlkSW5sYW5kXCIsNjUwLCEwLFwicmlkZ2VNaWRJbmxhbmQtT2xkTW91bnRhaW5zXCIpKS5hZGRQb2ludCguMDYsZChcImVyb3Npb25GYXJJbmxhbmRcIiw2MDAsITEsXCJyaWRnZUZhcklubGFuZC1PbGRNb3VudGFpbnNcIikpLGM9bmV3IFooXCJQZWFrc1wiLCh0PT50LmNvbnRpbmVudHMpKS5hZGRQb2ludCguMSwwKS5hZGRQb2ludCguMixuZXcgWihcIlBlYWtzLWVyb3Npb25cIiwodD0+dC5lcm9zaW9uKSkuYWRkUG9pbnQoLS44LG5ldyBaKFwiUGVha3MtZXJvc2lvbi1yaWRnZXNcIiwodD0+dC5yaWRnZXMpKS5hZGRQb2ludCgtMSwwKS5hZGRQb2ludCguMiwwKS5hZGRQb2ludCgxLG5ldyBaKFwiUGVha3MtZXJvc2lvbi1yaWRnZXMtd2VpcmRuZXNzXCIsKHQ9PnQud2VpcmRuZXNzKSkuYWRkUG9pbnQoLS4wMSw4MCkuYWRkUG9pbnQoLjAxLDIwKSkpLmFkZFBvaW50KC0uNCwwKSk7ZnVuY3Rpb24gZCh0LGUscyxpKXtjb25zdCBuPW5ldyBaKHQsKHQ9PnQuZXJvc2lvbikpLmFkZFBvaW50KC0uNixlKS5hZGRQb2ludCgtLjUsMzQyKS5hZGRQb2ludCgtLjM1LGUpLmFkZFBvaW50KC0uMjUsZSkuYWRkUG9pbnQoLS4xLDM0MikuYWRkUG9pbnQoLjAzLGUpO2lmKHMpe2NvbnN0IHQ9bmV3IFooXCJ3ZWlyZG5lc3NTaGF0dGVyZWRcIiwodD0+dC53ZWlyZG5lc3MpKS5hZGRQb2ludCgwLGUpLmFkZFBvaW50KC4xLDgwKSxzPW5ldyBaKFwicmlkZ2VzU2hhdHRlcmVkXCIsKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLS45LGUpLmFkZFBvaW50KC0uNjksdCk7bi5hZGRQb2ludCguMzUsZSkuYWRkUG9pbnQoLjQ1LHMpLmFkZFBvaW50KC41NSxzKS5hZGRQb2ludCguNjIsZSl9ZWxzZXtjb25zdCB0PW5ldyBaKGksKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLS43LGUpLmFkZFBvaW50KC0uMTUsMTc1KSxzPW5ldyBaKGksKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLjQ1LGUpLmFkZFBvaW50KC43LDIwMCk7bi5hZGRQb2ludCguMDUscykuYWRkUG9pbnQoLjQscykuYWRkUG9pbnQoLjQ1LHQpLmFkZFBvaW50KC41NSx0KS5hZGRQb2ludCguNTgsZSl9cmV0dXJuIG59ZnVuY3Rpb24gZih0LGUscyxpLG4scixvLGEsbCxoKXtjb25zdCB1PWcoTihyLC42LDEuNSksaCksYz1nKE4ociwuNiwxKSxoKSxkPWcocixoKSxmPXYodCtcIi13aWRlUGxhdGVhdVwiLGUtLjE1LC41KnIsTiguNSwuNSwuNSkqciwuNSpyLC42KnIsLjUpLHA9dih0K1wiLW5hcnJvd1BsYXRlYXVcIixlLG8qcixpKnIsLjUqciwuNipyLC41KSxtPXYodCtcIi1wbGFpbnNcIixlLG8sbyxpLG4sLjUpLGI9dih0K1wiLXBsYWluc0ZhcklubGFuZFwiLGUsbyxvLGksbiwuNSksdz1uZXcgWih0LCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC0xLGUpLmFkZFBvaW50KC0uNCxtKS5hZGRQb2ludCgwLG4rLjA3KSxQPXYodCtcIi1zd2FtcHNcIiwtLjAyLGEsYSxpLG4sMCkseD1uZXcgWih0LCh0PT50LmVyb3Npb24pKS5hZGRQb2ludCgtLjg1LHUpLmFkZFBvaW50KC0uNyxjKS5hZGRQb2ludCgtLjQsZCkuYWRkUG9pbnQoLS4zNSxmKS5hZGRQb2ludCgtLjEscCkuYWRkUG9pbnQoLjIsbSk7cmV0dXJuIGwmJnguYWRkUG9pbnQoLjQsYikuYWRkUG9pbnQoLjQ1LHcpLmFkZFBvaW50KC41NSx3KS5hZGRQb2ludCguNTgsYikseC5hZGRQb2ludCguNyxQKSx4fWZ1bmN0aW9uIGcodCxlKXtjb25zdCBzPW5ldyBaKGBNLXNwbGluZSBmb3IgY29udGluZW50YWxuZXNzOiAke3R9ICR7ZX1gLCh0PT50LnJpZGdlcykpLGk9cCgtMSx0LC0uNyksbj1wKDEsdCwtLjcpLHI9ZnVuY3Rpb24odCl7cmV0dXJuLjUqKDEtdCkvKC40NjA4Mjk0NyooMS0uNSooMS10KSkpLTEuMTd9KHQpO2lmKC0uNjU8ciYmcjwxKXtjb25zdCBlPXAoLS42NSx0LC0uNyksbz1wKC0uNzUsdCwtLjcpLGE9bShpLG8sLTEsLS43NSk7cy5hZGRQb2ludCgtMSxpLGEpLHMuYWRkUG9pbnQoLS43NSxvKSxzLmFkZFBvaW50KC0uNjUsZSk7Y29uc3QgbD1wKHIsdCwtLjcpLGg9bShsLG4sciwxKTtzLmFkZFBvaW50KHItLjAxLGwpLHMuYWRkUG9pbnQocixsLGgpLHMuYWRkUG9pbnQoMSxuLGgpfWVsc2V7Y29uc3QgdD1tKGksbiwtMSwxKTtlPyhzLmFkZFBvaW50KC0xLE1hdGgubWF4KC4yLGkpKSxzLmFkZFBvaW50KDAsTiguNSxpLG4pLHQpKTpzLmFkZFBvaW50KC0xLGksdCkscy5hZGRQb2ludCgxLG4sdCl9cmV0dXJuIHN9ZnVuY3Rpb24gcCh0LGUscyl7Y29uc3QgaT0uNDYwODI5NDcqKHQrMS4xNykqKDEtLjUqKDEtZSkpLS41KigxLWUpO3JldHVybiB0PHM/TWF0aC5tYXgoaSwtLjIyMjIpOk1hdGgubWF4KGksMCl9ZnVuY3Rpb24gbSh0LGUscyxpKXtyZXR1cm4oZS10KS8oaS1zKX1mdW5jdGlvbiB2KHQsZSxzLGksbixyLG8pe2NvbnN0IGE9TWF0aC5tYXgoLjUqKHMtZSksbyksbD01KihpLXMpO3JldHVybiBuZXcgWih0LCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC0xLGUsYSkuYWRkUG9pbnQoLS40LHMsTWF0aC5taW4oYSxsKSkuYWRkUG9pbnQoMCxpLGwpLmFkZFBvaW50KC40LG4sMioobi1pKSkuYWRkUG9pbnQoMSxyLC43KihyLW4pKX19KEF0fHwoQXQ9e30pKTtjbGFzcyBGdHtjb25zdHJ1Y3Rvcih0LGUscyxpLG4scil7dGhpcy5jZWxsQ291bnRZPWUsdGhpcy5jZWxsQ291bnRaPXMsdGhpcy5jZWxsTWluWT1uLHRoaXMuZmlsbGVyPXIsdGhpcy5ub2lzZTAwMD0wLHRoaXMubm9pc2UwMDE9MCx0aGlzLm5vaXNlMTAwPTAsdGhpcy5ub2lzZTEwMT0wLHRoaXMubm9pc2UwMTA9MCx0aGlzLm5vaXNlMDExPTAsdGhpcy5ub2lzZTExMD0wLHRoaXMubm9pc2UxMTE9MCx0aGlzLnZhbHVlWFowMD0wLHRoaXMudmFsdWVYWjEwPTAsdGhpcy52YWx1ZVhaMDE9MCx0aGlzLnZhbHVlWFoxMT0wLHRoaXMudmFsdWVaMD0wLHRoaXMudmFsdWVaMT0wLHRoaXMubWluQ2VsbFg9aVswXSp0LHRoaXMubWluQ2VsbFo9aVsxXSpzLHRoaXMuc2xpY2UwPUZ0LmFsbG9jYXRlU2xpY2UoZSxzKSx0aGlzLnNsaWNlMT1GdC5hbGxvY2F0ZVNsaWNlKGUscyl9c3RhdGljIGFsbG9jYXRlU2xpY2UodCxlKXtjb25zdCBzPUFycmF5KGUrMSk7Zm9yKGxldCBpPTA7aTxlKzE7aSs9MSlzW2ldPUFycmF5KHQrMSk7cmV0dXJuIHN9aW5pdGlhbGl6ZUZvckZpcnN0Q2VsbFgoKXt0aGlzLmZpbGxTbGljZSh0aGlzLnNsaWNlMCx0aGlzLm1pbkNlbGxYKX1hZHZhbmNlQ2VsbFgodCl7dGhpcy5maWxsU2xpY2UodGhpcy5zbGljZTEsdGhpcy5taW5DZWxsWCt0KzEpfWZpbGxTbGljZSh0LGUpe2ZvcihsZXQgcz0wO3M8dGhpcy5jZWxsQ291bnRaKzE7cys9MSl0aGlzLmZpbGxlcih0W3NdLGUsdGhpcy5taW5DZWxsWitzLHRoaXMuY2VsbE1pblksdGhpcy5jZWxsQ291bnRZKX1zZWxlY3RDZWxsWVoodCxlKXt0aGlzLm5vaXNlMDAwPXRoaXMuc2xpY2UwW2VdW3RdLHRoaXMubm9pc2UwMDE9dGhpcy5zbGljZTBbZSsxXVt0XSx0aGlzLm5vaXNlMTAwPXRoaXMuc2xpY2UxW2VdW3RdLHRoaXMubm9pc2UxMDE9dGhpcy5zbGljZTFbZSsxXVt0XSx0aGlzLm5vaXNlMDEwPXRoaXMuc2xpY2UwW2VdW3QrMV0sdGhpcy5ub2lzZTAxMT10aGlzLnNsaWNlMFtlKzFdW3QrMV0sdGhpcy5ub2lzZTExMD10aGlzLnNsaWNlMVtlXVt0KzFdLHRoaXMubm9pc2UxMTE9dGhpcy5zbGljZTFbZSsxXVt0KzFdfXVwZGF0ZUZvclkodCl7dGhpcy52YWx1ZVhaMDA9Tih0LHRoaXMubm9pc2UwMDAsdGhpcy5ub2lzZTAxMCksdGhpcy52YWx1ZVhaMTA9Tih0LHRoaXMubm9pc2UxMDAsdGhpcy5ub2lzZTExMCksdGhpcy52YWx1ZVhaMDE9Tih0LHRoaXMubm9pc2UwMDEsdGhpcy5ub2lzZTAxMSksdGhpcy52YWx1ZVhaMTE9Tih0LHRoaXMubm9pc2UxMDEsdGhpcy5ub2lzZTExMSl9dXBkYXRlRm9yWCh0KXt0aGlzLnZhbHVlWjA9Tih0LHRoaXMudmFsdWVYWjAwLHRoaXMudmFsdWVYWjEwKSx0aGlzLnZhbHVlWjE9Tih0LHRoaXMudmFsdWVYWjAxLHRoaXMudmFsdWVYWjExKX1jYWxjdWxhdGVWYWx1ZSh0KXtyZXR1cm4gTih0LHRoaXMudmFsdWVaMCx0aGlzLnZhbHVlWjEpfXN3YXBTbGljZXMoKXtbdGhpcy5zbGljZTAsdGhpcy5zbGljZTFdPVt0aGlzLnNsaWNlMSx0aGlzLnNsaWNlMF19fWNsYXNzIE10e2NvbnN0cnVjdG9yKHQsZSxzLGksbixyLG8sYSl7dGhpcy5jZWxsV2lkdGg9dCx0aGlzLmNlbGxIZWlnaHQ9ZSx0aGlzLmNlbGxDb3VudFk9cyx0aGlzLmJpb21lU291cmNlPWksdGhpcy5zZXR0aW5ncz1uLHRoaXMuc2hhcGVPdmVycmlkZT1hO2NvbnN0IGw9bmV3IFcobyksaD1uLnVzZUxlZ2FjeVJhbmRvbT9uZXcgVyhvKTpsLmZvcmsoKTt0aGlzLmJsZW5kZWROb2lzZT1uZXcgWShoKSxsLmNvbnN1bWUoOCksdGhpcy50ZW1wZXJhdHVyZU5vaXNlPW5ldyBYKG5ldyBKKG8pLHIudGVtcGVyYXR1cmUpLHRoaXMuaHVtaWRpdHlOb2lzZT1uZXcgWChuZXcgSihvK0JpZ0ludCgxKSksci5odW1pZGl0eSksdGhpcy5jb250aW5lbnRhbG5lc3NOb2lzZT1uZXcgWChuZXcgSihvK0JpZ0ludCgyKSksci5jb250aW5lbnRhbG5lc3MpLHRoaXMuZXJvc2lvbk5vaXNlPW5ldyBYKG5ldyBKKG8rQmlnSW50KDMpKSxyLmVyb3Npb24pLHRoaXMud2VpcmRuZXNzTm9pc2U9bmV3IFgobmV3IEoobytCaWdJbnQoNCkpLHIud2VpcmRuZXNzKSx0aGlzLm9mZnNldE5vaXNlPW5ldyBYKG5ldyBKKG8rQmlnSW50KDUpKSxyLnNoaWZ0KSx0aGlzLm1vdW50YWluUGVha05vaXNlPW5ldyBYKGwuZm9yaygpLHtmaXJzdE9jdGF2ZTotMTYsYW1wbGl0dWRlczpbMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV19KX1nZXRDbGltYXRlKHQsZSxzKXtjb25zdCBpPXQrdGhpcy5nZXRPZmZzZXQodCwwLHMpLG49ZSt0aGlzLmdldE9mZnNldChlLHMsdCkscj1zK3RoaXMuZ2V0T2Zmc2V0KHMsdCwwKSxvPXRoaXMudGVtcGVyYXR1cmVOb2lzZS5zYW1wbGUoaSxuLHIpLGE9dGhpcy5odW1pZGl0eU5vaXNlLnNhbXBsZShpLG4sciksbD10aGlzLmNvbnRpbmVudGFsbmVzc05vaXNlLnNhbXBsZShpLDAsciksaD10aGlzLmVyb3Npb25Ob2lzZS5zYW1wbGUoaSwwLHIpLHU9dGhpcy53ZWlyZG5lc3NOb2lzZS5zYW1wbGUoaSwwLHIpLGM9QXQub2Zmc2V0KEF0LnBvaW50KGwsaCx1KSksZD1NdC5jb21wdXRlRGltZW5zaW9uRGVuc2l0eSgxLC0uNTE4NzUsNCplKStjO3JldHVybiBuZXcgeXQuVGFyZ2V0UG9pbnQobyxhLGwsaCxkLHUpfWdldFRlcnJhaW5TaGFwZSh0LGUpe2lmKHRoaXMuc2hhcGVPdmVycmlkZSlyZXR1cm4gdGhpcy5zaGFwZU92ZXJyaWRlO2NvbnN0IHM9dCt0aGlzLmdldE9mZnNldCh0LDAsZSksaT1lK3RoaXMuZ2V0T2Zmc2V0KGUsdCwwKSxuPXRoaXMuY29udGluZW50YWxuZXNzTm9pc2Uuc2FtcGxlKHMsMCxpKSxyPXRoaXMuZXJvc2lvbk5vaXNlLnNhbXBsZShzLDAsaSksbz10aGlzLndlaXJkbmVzc05vaXNlLnNhbXBsZShzLDAsaSksYT1BdC5wb2ludChuLHIsbyksbD1BdC5uZWFyV2F0ZXIobixvKTtyZXR1cm4gQXQuc2hhcGUoYSxsKX1nZXRPZmZzZXQodCxlLHMpe3JldHVybiA0KnRoaXMub2Zmc2V0Tm9pc2Uuc2FtcGxlKHQsZSxzKX1maWxsTm9pc2VDb2x1bW4odCxlLHMsaSxuKXtjb25zdCByPWUqdGhpcy5jZWxsV2lkdGg+PjIsbz1zKnRoaXMuY2VsbFdpZHRoPj4yLHtvZmZzZXQ6YSxmYWN0b3I6bCxwZWFrczpofT10aGlzLmdldFRlcnJhaW5TaGFwZShyLG8pLHU9Njg0LjQxMip0aGlzLnNldHRpbmdzLnNhbXBsaW5nLnh6U2NhbGUsYz02ODQuNDEyKnRoaXMuc2V0dGluZ3Muc2FtcGxpbmcueVNjYWxlLGQ9dS90aGlzLnNldHRpbmdzLnNhbXBsaW5nLnh6RmFjdG9yLGY9Yy90aGlzLnNldHRpbmdzLnNhbXBsaW5nLnlGYWN0b3I7Zm9yKGxldCByPTA7cjw9bjtyKz0xKXtjb25zdCBuPXIraSxvPXRoaXMuYmxlbmRlZE5vaXNlLnNhbXBsZShlLG4scyx1LGMsZCxmKSxnPXRoaXMuc2FtcGxlUGVha05vaXNlKGgsZSp0aGlzLmNlbGxIZWlnaHQscyp0aGlzLmNlbGxIZWlnaHQpLzEyOCxwPXRoaXMuY29tcHV0ZUluaXRpYWxEZW5zaXR5KG4qdGhpcy5jZWxsSGVpZ2h0LGEsbCwwLGcpK287dFtyXT10aGlzLmFwcGx5U2xpZGUocCxuKX19c2FtcGxlUGVha05vaXNlKHQsZSxzKXtpZigwPT09dClyZXR1cm4gMDtjb25zdCBpPTNlMy90aGlzLmNlbGxXaWR0aCxuPXRoaXMubW91bnRhaW5QZWFrTm9pc2Uuc2FtcGxlKGUqaSwwLHMqaSk7cmV0dXJuIG4+MD90Km46dC8yKm59Y29tcHV0ZUluaXRpYWxEZW5zaXR5KHQsZSxzLGksbil7Y29uc3Qgcj0oTXQuY29tcHV0ZURpbWVuc2lvbkRlbnNpdHkodGhpcy5zZXR0aW5ncy5kZW5zaXR5RmFjdG9yLHRoaXMuc2V0dGluZ3MuZGVuc2l0eU9mZnNldCx0LGkpK2UrbikqcztyZXR1cm4gcioocj4wPzQ6MSl9YXBwbHlTbGlkZSh0LGUpe2NvbnN0IHM9ZS1NYXRoLmZsb29yKHRoaXMuc2V0dGluZ3MubWluWS90aGlzLmNlbGxIZWlnaHQpO2lmKHRoaXMuc2V0dGluZ3MudG9wU2xpZGUuc2l6ZT4wKXtjb25zdCBlPSh0aGlzLmNlbGxDb3VudFktcy10aGlzLnNldHRpbmdzLnRvcFNsaWRlLm9mZnNldCkvdGhpcy5zZXR0aW5ncy50b3BTbGlkZS5zaXplO3Q9VSh0aGlzLnNldHRpbmdzLnRvcFNsaWRlLnRhcmdldCx0LGUpfWlmKHRoaXMuc2V0dGluZ3MuYm90dG9tU2xpZGUuc2l6ZT4wKXtjb25zdCBlPShzLXRoaXMuc2V0dGluZ3MuYm90dG9tU2xpZGUub2Zmc2V0KS90aGlzLnNldHRpbmdzLmJvdHRvbVNsaWRlLnNpemU7dD1VKHRoaXMuc2V0dGluZ3MuYm90dG9tU2xpZGUudGFyZ2V0LHQsZSl9cmV0dXJuIHR9c3RhdGljIGNvbXB1dGVEaW1lbnNpb25EZW5zaXR5KHQsZSxzLGk9MCl7cmV0dXJuIHQqKDEtcy8xMjgraSkrZX19Y2xhc3MgTnR7Y29uc3RydWN0b3IodCxlLHMsaSl7dGhpcy5zZWVkPXQsdGhpcy5iaW9tZVNvdXJjZT1lLHRoaXMuc2V0dGluZ3M9cyx0aGlzLmNlbGxIZWlnaHQ9cy5ub2lzZS55U2l6ZTw8Mix0aGlzLmNlbGxXaWR0aD1zLm5vaXNlLnh6U2l6ZTw8Mix0aGlzLmNlbGxDb3VudFhaPU1hdGguZmxvb3IoMTYvdGhpcy5jZWxsV2lkdGgpLHRoaXMuY2VsbENvdW50WT1NYXRoLmZsb29yKHMubm9pc2UuaGVpZ2h0L3RoaXMuY2VsbEhlaWdodCksdGhpcy5zYW1wbGVyPW5ldyBNdCh0aGlzLmNlbGxXaWR0aCx0aGlzLmNlbGxIZWlnaHQsdGhpcy5jZWxsQ291bnRZLGUscy5ub2lzZSxzLm9jdGF2ZXMsdCxpKX1maWxsKHQpe2NvbnN0IGU9TWF0aC5tYXgodC5taW5ZLHRoaXMuc2V0dGluZ3Mubm9pc2UubWluWSkscz1NYXRoLm1pbih0Lm1heFksdGhpcy5zZXR0aW5ncy5ub2lzZS5taW5ZK3RoaXMuc2V0dGluZ3Mubm9pc2UuaGVpZ2h0KSxpPU1hdGguZmxvb3IoZS90aGlzLmNlbGxIZWlnaHQpLG49TWF0aC5mbG9vcigocy1lKS90aGlzLmNlbGxIZWlnaHQpLHI9SS5taW5CbG9ja1godC5wb3MpLG89SS5taW5CbG9ja1oodC5wb3MpLGE9bmV3IEZ0KHRoaXMuY2VsbENvdW50WFosbix0aGlzLmNlbGxDb3VudFhaLHQucG9zLGksdGhpcy5zYW1wbGVyLmZpbGxOb2lzZUNvbHVtbi5iaW5kKHRoaXMuc2FtcGxlcikpLGw9QXJyYXkoYSk7bC5mb3JFYWNoKCh0PT50LmluaXRpYWxpemVGb3JGaXJzdENlbGxYKCkpKTtmb3IobGV0IGU9MDtlPHRoaXMuY2VsbENvdW50WFo7ZSs9MSl7bC5mb3JFYWNoKCh0PT50LmFkdmFuY2VDZWxsWChlKSkpO2ZvcihsZXQgcz0wO3M8dGhpcy5jZWxsQ291bnRYWjtzKz0xKXtsZXQgaD10LmdldE9yQ3JlYXRlU2VjdGlvbih0LnNlY3Rpb25zQ291bnQtMSk7Zm9yKGxldCB1PW4tMTt1Pj0wO3UtPTEpe2wuZm9yRWFjaCgodD0+dC5zZWxlY3RDZWxsWVoodSxzKSkpO2ZvcihsZXQgbj10aGlzLmNlbGxIZWlnaHQtMTtuPj0wO24tPTEpe2NvbnN0IGM9KGkrdSkqdGhpcy5jZWxsSGVpZ2h0K24sZD0xNSZjLGY9dC5nZXRTZWN0aW9uSW5kZXgoYyk7dC5nZXRTZWN0aW9uSW5kZXgoaC5taW5CbG9ja1kpIT09ZiYmKGg9dC5nZXRPckNyZWF0ZVNlY3Rpb24oZikpO2NvbnN0IGc9bi90aGlzLmNlbGxIZWlnaHQ7bC5mb3JFYWNoKCh0PT50LnVwZGF0ZUZvclkoZykpKTtmb3IobGV0IHQ9MDt0PHRoaXMuY2VsbFdpZHRoO3QrPTEpe2NvbnN0IGk9citlKnRoaXMuY2VsbFdpZHRoK3Qsbj0xNSZpLHU9dC90aGlzLmNlbGxXaWR0aDtsLmZvckVhY2goKHQ9PnQudXBkYXRlRm9yWCh1KSkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jZWxsV2lkdGg7dCs9MSl7Y29uc3QgZT1vK3MqdGhpcy5jZWxsV2lkdGgrdCxyPTE1JmUsbD10L3RoaXMuY2VsbFdpZHRoLHU9YS5jYWxjdWxhdGVWYWx1ZShsKSxmPXRoaXMuYmFzZVN0YXRlKGksYyxlLHUpO2YuZXF1YWxzKEIuQUlSKXx8aC5zZXRCbG9ja1N0YXRlKG4sZCxyLGYpfX19fX1sLmZvckVhY2goKHQ9PnQuc3dhcFNsaWNlcygpKSl9fWJhc2VTdGF0ZSh0LGUscyxpKXtyZXR1cm4oaT0oaT1NKGkvMjAwLC0xLDEpKS8yLWkqaSppLzI0KT4wP3RoaXMuc2V0dGluZ3MuZGVmYXVsdEJsb2NrOmU8dGhpcy5zZXR0aW5ncy5zZWFMZXZlbD90aGlzLnNldHRpbmdzLmRlZmF1bHRGbHVpZDpCLkFJUn19IWZ1bmN0aW9uKHQpe3QuZnJvbUpzb249ZnVuY3Rpb24odCl7dmFyIGUscyxpLG4scixvLGEsbCxoLHUsYyxkO2NvbnN0IGY9bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm57bWluWTpudWxsIT09KHM9ay5yZWFkSW50KGYubWluX3kpKSYmdm9pZCAwIT09cz9zOjAsaGVpZ2h0Om51bGwhPT0oaT1rLnJlYWRJbnQoZi5oZWlnaHQpKSYmdm9pZCAwIT09aT9pOjI1Nix4elNpemU6bnVsbCE9PShuPWsucmVhZEludChmLnNpemVfaG9yaXpvbnRhbCkpJiZ2b2lkIDAhPT1uP246MSx5U2l6ZTpudWxsIT09KHI9ay5yZWFkSW50KGYuc2l6ZV92ZXJ0aWNhbCkpJiZ2b2lkIDAhPT1yP3I6MSxkZW5zaXR5RmFjdG9yOm51bGwhPT0obz1rLnJlYWROdW1iZXIoZi5kZW5zaXR5X2ZhY3RvcikpJiZ2b2lkIDAhPT1vP286MCxkZW5zaXR5T2Zmc2V0Om51bGwhPT0oYT1rLnJlYWROdW1iZXIoZi5kZW5zaXR5X29mZnNldCkpJiZ2b2lkIDAhPT1hP2E6MCxzYW1wbGluZzpCdC5mcm9tSnNvbihmLnNhbXBsaW5nKSx0b3BTbGlkZTpFdC5mcm9tSnNvbihmLnRvcF9zbGlkZSksYm90dG9tU2xpZGU6RXQuZnJvbUpzb24oZi5ib3R0b21fc2xpZGUpLHVzZVNpbXBsZXhTdXJmYWNlTm9pc2U6bnVsbCE9PShsPWsucmVhZEJvb2xlYW4oZi5zaW1wbGV4X3N1cmZhY2Vfbm9pc2UpKSYmdm9pZCAwIT09bCYmbCxyYW5kb21EZW5zaXR5T2Zmc2V0Om51bGwhPT0oaD1rLnJlYWRCb29sZWFuKGYucmFuZG9tX2RlbnNpdHlfb2Zmc2V0KSkmJnZvaWQgMCE9PWgmJmgsaXNsYW5kTm9pc2VPdmVycmlkZTpudWxsIT09KHU9ay5yZWFkQm9vbGVhbihmLmlzbGFuZF9ub2lzZV9vdmVycmlkZSkpJiZ2b2lkIDAhPT11JiZ1LGlzQW1wbGlmaWVkOm51bGwhPT0oYz1rLnJlYWRCb29sZWFuKGYuYW1wbGlmaWVkKSkmJnZvaWQgMCE9PWMmJmMsdXNlTGVnYWN5UmFuZG9tOm51bGwhPT0oZD1rLnJlYWRCb29sZWFuKGYudXNlX2xlZ2FjeV9yYW5kb20pKSYmdm9pZCAwIT09ZCYmZH19fShTdHx8KFN0PXt9KSksZnVuY3Rpb24odCl7dC5mcm9tSnNvbj1mdW5jdGlvbih0KXt2YXIgZSxzLGksbixyO2NvbnN0IG89bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm57eHpTY2FsZTpudWxsIT09KHM9ay5yZWFkTnVtYmVyKG8ueHpfc2NhbGUpKSYmdm9pZCAwIT09cz9zOjEseVNjYWxlOm51bGwhPT0oaT1rLnJlYWROdW1iZXIoby55X3NjYWxlKSkmJnZvaWQgMCE9PWk/aToxLHh6RmFjdG9yOm51bGwhPT0obj1rLnJlYWROdW1iZXIoby54el9mYWN0b3IpKSYmdm9pZCAwIT09bj9uOjgwLHlGYWN0b3I6bnVsbCE9PShyPWsucmVhZE51bWJlcihvLnlfZmFjdG9yKSkmJnZvaWQgMCE9PXI/cjo4MH19fShCdHx8KEJ0PXt9KSksZnVuY3Rpb24odCl7dC5mcm9tSnNvbj1mdW5jdGlvbih0KXt2YXIgZSxzLGksbjtjb25zdCByPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJue3RhcmdldDpudWxsIT09KHM9ay5yZWFkTnVtYmVyKHIudGFyZ2V0KSkmJnZvaWQgMCE9PXM/czowLHNpemU6bnVsbCE9PShpPWsucmVhZEludChyLnNpemUpKSYmdm9pZCAwIT09aT9pOjAsb2Zmc2V0Om51bGwhPT0obj1rLnJlYWRJbnQoci5vZmZzZXQpKSYmdm9pZCAwIT09bj9uOjB9fX0oRXR8fChFdD17fSkpLGZ1bmN0aW9uKHQpe3QuZnJvbUpzb249ZnVuY3Rpb24odCl7dmFyIGUscyxpLG4scixvLGEsbCxoLHU7Y29uc3QgYz1udWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9O3JldHVybntzdHJ1Y3R1cmVzOkl0LmZyb21Kc29uKGMuc3RydWN0dXJlcyksbm9pc2U6U3QuZnJvbUpzb24oYy5ub2lzZSksb2N0YXZlczprdC5mcm9tSnNvbihjLm9jdGF2ZXMpLGRlZmF1bHRCbG9jazpCLmZyb21Kc29uKGMuZGVmYXVsdF9ibG9jayksZGVmYXVsdEZsdWlkOkIuZnJvbUpzb24oYy5kZWZhdWx0X2ZsdWlkKSxiZWRyb2NrUm9vZlBvc2l0aW9uOm51bGwhPT0ocz1rLnJlYWRJbnQoYy5iZWRyb2NrX3Jvb2ZfcG9zaXRpb24pKSYmdm9pZCAwIT09cz9zOjAsYmVkcm9ja0Zsb29yUG9zaXRpb246bnVsbCE9PShpPWsucmVhZEludChjLmJlZHJvY2tfZmxvb3JfcG9zaXRpb24pKSYmdm9pZCAwIT09aT9pOjAsc2VhTGV2ZWw6bnVsbCE9PShuPWsucmVhZEludChjLnNlYV9sZXZlbCkpJiZ2b2lkIDAhPT1uP246MCxkaXNhYmxlTW9iR2VuZXJhdGlvbjpudWxsIT09KHI9ay5yZWFkQm9vbGVhbihjLmRpc2FibGVfbW9iX2dlbmVyYXRpb24pKSYmdm9pZCAwIT09ciYmcixhcXVpZmVyc0VuYWJsZWQ6bnVsbCE9PShvPWsucmVhZEJvb2xlYW4oYy5hcXVpZmVyc19lbmFibGVkKSkmJnZvaWQgMCE9PW8mJm8sbm9pc2VDYXZlc0VuYWJsZWQ6bnVsbCE9PShhPWsucmVhZEJvb2xlYW4oYy5ub2lzZV9jYXZlc19lbmFibGVkKSkmJnZvaWQgMCE9PWEmJmEsZGVlcHNsYXRlRW5hYmxlZDpudWxsIT09KGw9ay5yZWFkQm9vbGVhbihjLmRlZXBzbGF0ZV9lbmFibGVkKSkmJnZvaWQgMCE9PWwmJmwsb3JlVmVpbnNFbmFibGVkOm51bGwhPT0oaD1rLnJlYWRCb29sZWFuKGMub3JlX3ZlaW5zX2VuYWJsZWQpKSYmdm9pZCAwIT09aCYmaCxub29kbGVDYXZlc0VuYWJsZWQ6bnVsbCE9PSh1PWsucmVhZEJvb2xlYW4oYy5ub29kbGVfY2F2ZXNfZW5hYmxlZCkpJiZ2b2lkIDAhPT11JiZ1fX19KEN0fHwoQ3Q9e30pKSxmdW5jdGlvbih0KXt0LmZyb21Kc29uPWZ1bmN0aW9uKHQpe3ZhciBlO2NvbnN0IHM9bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm57c3Ryb25naG9sZDprLmNvbXBvc2Uocy5zdHJvbmdob2xkLGsucmVhZE9iamVjdCwodD0+e3ZhciBlLHMsaTtyZXR1cm57ZGlzdGFuY2U6bnVsbCE9PShlPWsucmVhZEludCh0LmRpc3RhbmNlKSkmJnZvaWQgMCE9PWU/ZTowLHNwcmVhZDpudWxsIT09KHM9ay5yZWFkSW50KHQuc3ByZWFkKSkmJnZvaWQgMCE9PXM/czowLGNvdW50Om51bGwhPT0oaT1rLnJlYWRJbnQodC5jb3VudCkpJiZ2b2lkIDAhPT1pP2k6MH19KSksc3RydWN0dXJlczprLnJlYWRNYXAocy5zdHJ1Y3R1cmVzLCh0PT57dmFyIGU7cmV0dXJuKHQ9Pnt2YXIgZSxzLGk7cmV0dXJue3NwYWNpbmc6bnVsbCE9PShlPWsucmVhZEludCh0LnNwYWNpbmcpKSYmdm9pZCAwIT09ZT9lOjAsc2VwYXJhdGlvbjpudWxsIT09KHM9ay5yZWFkSW50KHQuc2VwYXJhdGlvbikpJiZ2b2lkIDAhPT1zP3M6MCxzYWx0Om51bGwhPT0oaT1rLnJlYWRJbnQodC5zYWx0KSkmJnZvaWQgMCE9PWk/aTowfX0pKG51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e30pfSkpfX19KEl0fHwoSXQ9e30pKSxmdW5jdGlvbih0KXt0LmZyb21Kc29uPWZ1bmN0aW9uKHQpe3ZhciBlO2NvbnN0IHM9bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm57dGVtcGVyYXR1cmU6Ui5mcm9tSnNvbihzLnRlbXBlcmF0dXJlKSxodW1pZGl0eTpSLmZyb21Kc29uKHMuaHVtaWRpdHkpLGNvbnRpbmVudGFsbmVzczpSLmZyb21Kc29uKHMuY29udGluZW50YWxuZXNzKSxlcm9zaW9uOlIuZnJvbUpzb24ocy5lcm9zaW9uKSx3ZWlyZG5lc3M6Ui5mcm9tSnNvbihzLndlaXJkbmVzcyksc2hpZnQ6Ui5mcm9tSnNvbihzLnNoaWZ0KX19fShrdHx8KGt0PXt9KSk7ZXhwb3J0e1kgYXMgQmxlbmRlZE5vaXNlLG50IGFzIEJsb2NrQ29sb3JzLGx0IGFzIEJsb2NrRGVmaW5pdGlvbixmdCBhcyBCbG9ja01vZGVsLG8gYXMgQmxvY2tQb3MsQiBhcyBCbG9ja1N0YXRlLEMgYXMgQ2h1bmssSSBhcyBDaHVua1BvcyxFIGFzIENodW5rU2VjdGlvbix5dCBhcyBDbGltYXRlLG4gYXMgRGlyZWN0aW9uLFJ0IGFzIEZpeGVkQmlvbWUsViBhcyBJbXByb3ZlZE5vaXNlLGsgYXMgSnNvbixfdCBhcyBNdWx0aU5vaXNlLGggYXMgTmJ0UmVhZGVyLHUgYXMgTmJ0V3JpdGVyLE50IGFzIE5vaXNlQ2h1bmtHZW5lcmF0b3IsQ3QgYXMgTm9pc2VHZW5lcmF0b3JTZXR0aW5ncyxGdCBhcyBOb2lzZUludGVycG9sYXRvcixrdCBhcyBOb2lzZU9jdGF2ZXMsUiBhcyBOb2lzZVBhcmFtZXRlcnMsTXQgYXMgTm9pc2VTYW1wbGVyLEJ0IGFzIE5vaXNlU2FtcGxpbmdTZXR0aW5ncyxTdCBhcyBOb2lzZVNldHRpbmdzLEV0IGFzIE5vaXNlU2xpZGVTZXR0aW5ncyxYIGFzIE5vcm1hbE5vaXNlLGogYXMgUGVybGluTm9pc2UsSCBhcyBQZXJsaW5TaW1wbGV4Tm9pc2UsVyBhcyBSYW5kb20seiBhcyBTaW1wbGV4Tm9pc2UsWiBhcyBTcGxpbmUsXyBhcyBTdHJ1Y3R1cmUsd3QgYXMgU3RydWN0dXJlUmVuZGVyZXIsSXQgYXMgU3RydWN0dXJlU2V0dGluZ3MsQXQgYXMgVGVycmFpblNoYXBlcix4dCBhcyBUZXh0dXJlQXRsYXMsSiBhcyBXb3JsZGdlblJhbmRvbSxMIGFzIGJpbmFyeVNlYXJjaCxNIGFzIGNsYW1wLFUgYXMgY2xhbXBlZExlcnAsQSBhcyBnZXRMaXN0VGFnLFMgYXMgZ2V0T3B0aW9uYWwseSBhcyBnZXRUYWcsTiBhcyBsZXJwLFQgYXMgbGVycDIsTyBhcyBsZXJwMyxmIGFzIHJlYWQscCBhcyByZWFkQ2h1bmssZCBhcyByZWFkQ29tcHJlc3NlZCxnIGFzIHJlYWRSZWdpb24sYyBhcyByZWFkVW5jb21wcmVzc2VkLEQgYXMgc21vb3Roc3RlcCxGIGFzIHNxdWFyZSxsIGFzIHRhZ05hbWVzLGEgYXMgdGFnVHlwZXMsYiBhcyB3cml0ZSxQIGFzIHdyaXRlQ2h1bmssdiBhcyB3cml0ZUNvbXByZXNzZWQsdyBhcyB3cml0ZVJlZ2lvbixtIGFzIHdyaXRlVW5jb21wcmVzc2VkfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXBzbGF0ZS5lc20uanMubWFwXG4iLCIvKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmV4cG9ydCB2YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IHZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiA0eDQgTWF0cml4PGJyPkZvcm1hdDogY29sdW1uLW1ham9yLCB3aGVuIHR5cGVkIG91dCBpdCBsb29rcyBsaWtlIHJvdy1tYWpvcjxicj5UaGUgbWF0cmljZXMgYXJlIGJlaW5nIHBvc3QgbXVsdGlwbGllZC5cbiAqIEBtb2R1bGUgbWF0NFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFs1XSA9IDE7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM107XG4gICAgdmFyIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG4gICAgdmFyIGEyMyA9IGFbMTFdO1xuICAgIG91dFsxXSA9IGFbNF07XG4gICAgb3V0WzJdID0gYVs4XTtcbiAgICBvdXRbM10gPSBhWzEyXTtcbiAgICBvdXRbNF0gPSBhMDE7XG4gICAgb3V0WzZdID0gYVs5XTtcbiAgICBvdXRbN10gPSBhWzEzXTtcbiAgICBvdXRbOF0gPSBhMDI7XG4gICAgb3V0WzldID0gYTEyO1xuICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICBvdXRbMTJdID0gYTAzO1xuICAgIG91dFsxM10gPSBhMTM7XG4gICAgb3V0WzE0XSA9IGEyMztcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbNF07XG4gICAgb3V0WzJdID0gYVs4XTtcbiAgICBvdXRbM10gPSBhWzEyXTtcbiAgICBvdXRbNF0gPSBhWzFdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs5XTtcbiAgICBvdXRbN10gPSBhWzEzXTtcbiAgICBvdXRbOF0gPSBhWzJdO1xuICAgIG91dFs5XSA9IGFbNl07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICBvdXRbMTJdID0gYVszXTtcbiAgICBvdXRbMTNdID0gYVs3XTtcbiAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgb3V0WzBdID0gYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpO1xuICBvdXRbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSA9IGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzNdID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSA9IGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKTtcbiAgb3V0WzZdID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gPSBhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFs4XSA9IGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKTtcbiAgb3V0WzldID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07IC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuXG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzJdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFszXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbNF07XG4gIGIxID0gYls1XTtcbiAgYjIgPSBiWzZdO1xuICBiMyA9IGJbN107XG4gIG91dFs0XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbNV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFs3XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbOF07XG4gIGIxID0gYls5XTtcbiAgYjIgPSBiWzEwXTtcbiAgYjMgPSBiWzExXTtcbiAgb3V0WzhdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs5XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxMV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzEyXTtcbiAgYjEgPSBiWzEzXTtcbiAgYjIgPSBiWzE0XTtcbiAgYjMgPSBiWzE1XTtcbiAgb3V0WzEyXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMTNdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxNF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzE1XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gIGlmIChhID09PSBvdXQpIHtcbiAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgfSBlbHNlIHtcbiAgICBhMDAgPSBhWzBdO1xuICAgIGEwMSA9IGFbMV07XG4gICAgYTAyID0gYVsyXTtcbiAgICBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07XG4gICAgYTExID0gYVs1XTtcbiAgICBhMTIgPSBhWzZdO1xuICAgIGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTtcbiAgICBhMjEgPSBhWzldO1xuICAgIGEyMiA9IGFbMTBdO1xuICAgIGEyMyA9IGFbMTFdO1xuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuICAgIG91dFszXSA9IGEwMztcbiAgICBvdXRbNF0gPSBhMTA7XG4gICAgb3V0WzVdID0gYTExO1xuICAgIG91dFs2XSA9IGExMjtcbiAgICBvdXRbN10gPSBhMTM7XG4gICAgb3V0WzhdID0gYTIwO1xuICAgIG91dFs5XSA9IGEyMTtcbiAgICBvdXRbMTBdID0gYTIyO1xuICAgIG91dFsxMV0gPSBhMjM7XG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgdmFyIHggPSBheGlzWzBdLFxuICAgICAgeSA9IGF4aXNbMV0sXG4gICAgICB6ID0gYXhpc1syXTtcbiAgdmFyIGxlbiA9IE1hdGguaHlwb3QoeCwgeSwgeik7XG4gIHZhciBzLCBjLCB0O1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICB2YXIgYjAwLCBiMDEsIGIwMjtcbiAgdmFyIGIxMCwgYjExLCBiMTI7XG4gIHZhciBiMjAsIGIyMSwgYjIyO1xuXG4gIGlmIChsZW4gPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYztcbiAgYTAwID0gYVswXTtcbiAgYTAxID0gYVsxXTtcbiAgYTAyID0gYVsyXTtcbiAgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTtcbiAgYTExID0gYVs1XTtcbiAgYTEyID0gYVs2XTtcbiAgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTtcbiAgYTIxID0gYVs5XTtcbiAgYTIyID0gYVsxMF07XG4gIGEyMyA9IGFbMTFdOyAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcblxuICBiMDAgPSB4ICogeCAqIHQgKyBjO1xuICBiMDEgPSB5ICogeCAqIHQgKyB6ICogcztcbiAgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzO1xuICBiMTEgPSB5ICogeSAqIHQgKyBjO1xuICBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIGIyMSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBiMjIgPSB6ICogeiAqIHQgKyBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IHZbMV07XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSB2WzJdO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgb3V0WzFdID0geHkgKyB3ejtcbiAgb3V0WzJdID0geHogLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geHkgLSB3ejtcbiAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgb3V0WzZdID0geXogKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geHogKyB3eTtcbiAgb3V0WzldID0geXogLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgTWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7bWF0NH0gbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdDIob3V0LCBhKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICB2YXIgbWFnbml0dWRlID0gYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6ICsgYncgKiBidzsgLy9Pbmx5IHNjYWxlIGlmIGl0IG1ha2VzIHNlbnNlXG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMiAvIG1hZ25pdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgfVxuXG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgYSwgdHJhbnNsYXRpb24pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcbiAqICB3aXRoIGEgbm9ybWFsaXplZCBRdWF0ZXJuaW9uIHBhcmFtdGVyLCB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmVcbiAqICB0aGUgc2FtZSBhcyB0aGUgc2NhbGluZyB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudFxuICogQHBhcmFtICB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgdmFyIG0xMSA9IG1hdFswXTtcbiAgdmFyIG0xMiA9IG1hdFsxXTtcbiAgdmFyIG0xMyA9IG1hdFsyXTtcbiAgdmFyIG0yMSA9IG1hdFs0XTtcbiAgdmFyIG0yMiA9IG1hdFs1XTtcbiAgdmFyIG0yMyA9IG1hdFs2XTtcbiAgdmFyIG0zMSA9IG1hdFs4XTtcbiAgdmFyIG0zMiA9IG1hdFs5XTtcbiAgdmFyIG0zMyA9IG1hdFsxMF07XG4gIG91dFswXSA9IE1hdGguaHlwb3QobTExLCBtMTIsIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguaHlwb3QobTIxLCBtMjIsIG0yMyk7XG4gIG91dFsyXSA9IE1hdGguaHlwb3QobTMxLCBtMzIsIG0zMyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICB2YXIgb3ggPSBvWzBdO1xuICB2YXIgb3kgPSBvWzFdO1xuICB2YXIgb3ogPSBvWzJdO1xuICB2YXIgb3V0MCA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICB2YXIgb3V0MSA9ICh4eSArIHd6KSAqIHN4O1xuICB2YXIgb3V0MiA9ICh4eiAtIHd5KSAqIHN4O1xuICB2YXIgb3V0NCA9ICh4eSAtIHd6KSAqIHN5O1xuICB2YXIgb3V0NSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICB2YXIgb3V0NiA9ICh5eiArIHd4KSAqIHN5O1xuICB2YXIgb3V0OCA9ICh4eiArIHd5KSAqIHN6O1xuICB2YXIgb3V0OSA9ICh5eiAtIHd4KSAqIHN6O1xuICB2YXIgb3V0MTAgPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgb3V0WzZdID0gb3V0NjtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gb3V0ODtcbiAgb3V0WzldID0gb3V0OTtcbiAgb3V0WzEwXSA9IG91dDEwO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXQwICogb3ggKyBvdXQ0ICogb3kgKyBvdXQ4ICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dDEgKiBveCArIG91dDUgKiBveSArIG91dDkgKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0MiAqIG94ICsgb3V0NiAqIG95ICsgb3V0MTAgKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xuICB2YXIgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IG5lYXIgKiAyICogcmw7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IG5lYXIgKiAyICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyICogMiAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxuICogVGhlIG5lYXIvZmFyIGNsaXAgcGxhbmVzIGNvcnJlc3BvbmQgdG8gYSBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlIFogcmFuZ2Ugb2YgWy0xLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR0wvT3BlbkdMJ3MgY2xpcCB2b2x1bWUuXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVOTyhvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgbmY7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTVdID0gMDtcblxuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzEwXSA9IC0xO1xuICAgIG91dFsxNF0gPSAtMiAqIG5lYXI7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQucGVyc3BlY3RpdmVOT31cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgcGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZU5PO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3IgV2ViR1BVIHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFswLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR1BVL1Z1bGthbi9EaXJlY3RYL01ldGFsJ3MgY2xpcCB2b2x1bWUuXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVaTyhvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgbmY7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTVdID0gMDtcblxuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gZmFyICogbmY7XG4gICAgb3V0WzE0XSA9IGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC1uZWFyO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbLTEsIDFdLFxuICogd2hpY2ggbWF0Y2hlcyBXZWJHTC9PcGVuR0wncyBjbGlwIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG9OTyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgdmFyIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAtMiAqIGxyO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAtMiAqIGJ0O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMiAqIG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQub3J0aG9OT31cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgb3J0aG8gPSBvcnRob05PO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFswLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR1BVL1Z1bGthbi9EaXJlY3RYL01ldGFsJ3MgY2xpcCB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvWk8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gbmVhciAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXG4gKiBJZiB5b3Ugd2FudCBhIG1hdHJpeCB0aGF0IGFjdHVhbGx5IG1ha2VzIGFuIG9iamVjdCBsb29rIGF0IGFub3RoZXIgb2JqZWN0LCB5b3Ugc2hvdWxkIHVzZSB0YXJnZXRUbyBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuO1xuICB2YXIgZXlleCA9IGV5ZVswXTtcbiAgdmFyIGV5ZXkgPSBleWVbMV07XG4gIHZhciBleWV6ID0gZXllWzJdO1xuICB2YXIgdXB4ID0gdXBbMF07XG4gIHZhciB1cHkgPSB1cFsxXTtcbiAgdmFyIHVweiA9IHVwWzJdO1xuICB2YXIgY2VudGVyeCA9IGNlbnRlclswXTtcbiAgdmFyIGNlbnRlcnkgPSBjZW50ZXJbMV07XG4gIHZhciBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcbiAgbGVuID0gMSAvIE1hdGguaHlwb3QoejAsIHoxLCB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG4gIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeDAsIHgxLCB4Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB4MCA9IDA7XG4gICAgeDEgPSAwO1xuICAgIHgyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh5MCwgeTEsIHkyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHkwID0gMDtcbiAgICB5MSA9IDA7XG4gICAgeTIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeTAgKj0gbGVuO1xuICAgIHkxICo9IGxlbjtcbiAgICB5MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geTA7XG4gIG91dFsyXSA9IHowO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4MTtcbiAgb3V0WzVdID0geTE7XG4gIG91dFs2XSA9IHoxO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4MjtcbiAgb3V0WzldID0geTI7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0YXJnZXRUbyhvdXQsIGV5ZSwgdGFyZ2V0LCB1cCkge1xuICB2YXIgZXlleCA9IGV5ZVswXSxcbiAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICB1cHkgPSB1cFsxXSxcbiAgICAgIHVweiA9IHVwWzJdO1xuICB2YXIgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgICAgejIgPSBleWV6IC0gdGFyZ2V0WzJdO1xuICB2YXIgbGVuID0gejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG5cbiAgdmFyIHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MixcbiAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0geDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHgxO1xuICBvdXRbMl0gPSB4MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gejEgKiB4MiAtIHoyICogeDE7XG4gIG91dFs1XSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICBvdXRbNl0gPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gejA7XG4gIG91dFs5XSA9IHoxO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gZXlleDtcbiAgb3V0WzEzXSA9IGV5ZXk7XG4gIG91dFsxNF0gPSBleWV6O1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSwgYVs5XSwgYVsxMF0sIGFbMTFdLCBhWzEyXSwgYVsxM10sIGFbMTRdLCBhWzE1XSk7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgb3V0WzldID0gYVs5XSAqIGI7XG4gIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldICogc2NhbGU7XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdICogc2NhbGU7XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdICogc2NhbGU7XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdICogc2NhbGU7XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdICogc2NhbGU7XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdICogc2NhbGU7XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJiBhWzEyXSA9PT0gYlsxMl0gJiYgYVsxM10gPT09IGJbMTNdICYmIGFbMTRdID09PSBiWzE0XSAmJiBhWzE1XSA9PT0gYlsxNV07XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBhOCA9IGFbOF0sXG4gICAgICBhOSA9IGFbOV0sXG4gICAgICBhMTAgPSBhWzEwXSxcbiAgICAgIGExMSA9IGFbMTFdO1xuICB2YXIgYTEyID0gYVsxMl0sXG4gICAgICBhMTMgPSBhWzEzXSxcbiAgICAgIGExNCA9IGFbMTRdLFxuICAgICAgYTE1ID0gYVsxNV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIHZhciBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHZhciBiOCA9IGJbOF0sXG4gICAgICBiOSA9IGJbOV0sXG4gICAgICBiMTAgPSBiWzEwXSxcbiAgICAgIGIxMSA9IGJbMTFdO1xuICB2YXIgYjEyID0gYlsxMl0sXG4gICAgICBiMTMgPSBiWzEzXSxcbiAgICAgIGIxNCA9IGJbMTRdLFxuICAgICAgYjE1ID0gYlsxNV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJiBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiYgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJiBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiYgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJiBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIHZhciB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7XG4gIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICB2YXIgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqIENhbiBhbHNvIGJlIHVzZWQgZm9yIGR1YWwgcXVhdGVybmlvbnMuIChNdWx0aXBseSBpdCB3aXRoIHRoZSByZWFsIHBhcnQpXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4ocmFkKSArIHBbMF0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhyYWQpIC0gcFswXSAqIE1hdGguc2luKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBtYWcxID0gTWF0aC5zcXJ0KGF4ICogYXggKyBheSAqIGF5ICsgYXogKiBheiksXG4gICAgICBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiksXG4gICAgICBtYWcgPSBtYWcxICogbWFnMixcbiAgICAgIGNvc2luZSA9IG1hZyAmJiBkb3QoYSwgYikgLyBtYWc7XG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB6ZXJvXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiLy9wYWNrZXIgdmVyc2lvblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICAgTGl0ZUdyYXBoIENMQVNTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvKipcbiAgICAgKiBUaGUgR2xvYmFsIFNjb3BlLiBJdCBjb250YWlucyBhbGwgdGhlIHJlZ2lzdGVyZWQgbm9kZSBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQGNsYXNzIExpdGVHcmFwaFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuXG4gICAgdmFyIExpdGVHcmFwaCA9IChnbG9iYWwuTGl0ZUdyYXBoID0ge1xuICAgICAgICBWRVJTSU9OOiAwLjQsXG5cbiAgICAgICAgQ0FOVkFTX0dSSURfU0laRTogMTAsXG5cbiAgICAgICAgTk9ERV9USVRMRV9IRUlHSFQ6IDMwLFxuICAgICAgICBOT0RFX1RJVExFX1RFWFRfWTogMjAsXG4gICAgICAgIE5PREVfU0xPVF9IRUlHSFQ6IDIwLFxuICAgICAgICBOT0RFX1dJREdFVF9IRUlHSFQ6IDIwLFxuICAgICAgICBOT0RFX1dJRFRIOiAxNDAsXG4gICAgICAgIE5PREVfTUlOX1dJRFRIOiA1MCxcbiAgICAgICAgTk9ERV9DT0xMQVBTRURfUkFESVVTOiAxMCxcbiAgICAgICAgTk9ERV9DT0xMQVBTRURfV0lEVEg6IDgwLFxuICAgICAgICBOT0RFX1RJVExFX0NPTE9SOiBcIiM5OTlcIixcbiAgICAgICAgTk9ERV9TRUxFQ1RFRF9USVRMRV9DT0xPUjogXCIjRkZGXCIsXG4gICAgICAgIE5PREVfVEVYVF9TSVpFOiAxNCxcbiAgICAgICAgTk9ERV9URVhUX0NPTE9SOiBcIiNBQUFcIixcbiAgICAgICAgTk9ERV9TVUJURVhUX1NJWkU6IDEyLFxuICAgICAgICBOT0RFX0RFRkFVTFRfQ09MT1I6IFwiIzMzM1wiLFxuICAgICAgICBOT0RFX0RFRkFVTFRfQkdDT0xPUjogXCIjMzUzNTM1XCIsXG4gICAgICAgIE5PREVfREVGQVVMVF9CT1hDT0xPUjogXCIjNjY2XCIsXG4gICAgICAgIE5PREVfREVGQVVMVF9TSEFQRTogXCJib3hcIixcbiAgICAgICAgTk9ERV9CT1hfT1VUTElORV9DT0xPUjogXCIjRkZGXCIsXG4gICAgICAgIERFRkFVTFRfU0hBRE9XX0NPTE9SOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgICBERUZBVUxUX0dST1VQX0ZPTlQ6IDI0LFxuXG4gICAgICAgIFdJREdFVF9CR0NPTE9SOiBcIiMyMjJcIixcbiAgICAgICAgV0lER0VUX09VVExJTkVfQ09MT1I6IFwiIzY2NlwiLFxuICAgICAgICBXSURHRVRfVEVYVF9DT0xPUjogXCIjREREXCIsXG4gICAgICAgIFdJREdFVF9TRUNPTkRBUllfVEVYVF9DT0xPUjogXCIjOTk5XCIsXG5cbiAgICAgICAgTElOS19DT0xPUjogXCIjOUE5XCIsXG4gICAgICAgIEVWRU5UX0xJTktfQ09MT1I6IFwiI0E4NlwiLFxuICAgICAgICBDT05ORUNUSU5HX0xJTktfQ09MT1I6IFwiI0FGQVwiLFxuXG4gICAgICAgIE1BWF9OVU1CRVJfT0ZfTk9ERVM6IDEwMDAsIC8vYXZvaWQgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgREVGQVVMVF9QT1NJVElPTjogWzEwMCwgMTAwXSwgLy9kZWZhdWx0IG5vZGUgcG9zaXRpb25cbiAgICAgICAgVkFMSURfU0hBUEVTOiBbXCJkZWZhdWx0XCIsIFwiYm94XCIsIFwicm91bmRcIiwgXCJjYXJkXCJdLCAvLyxcImNpcmNsZVwiXG5cbiAgICAgICAgLy9zaGFwZXMgYXJlIHVzZWQgZm9yIG5vZGVzIGJ1dCBhbHNvIGZvciBzbG90c1xuICAgICAgICBCT1hfU0hBUEU6IDEsXG4gICAgICAgIFJPVU5EX1NIQVBFOiAyLFxuICAgICAgICBDSVJDTEVfU0hBUEU6IDMsXG4gICAgICAgIENBUkRfU0hBUEU6IDQsXG4gICAgICAgIEFSUk9XX1NIQVBFOiA1LFxuXG4gICAgICAgIC8vZW51bXNcbiAgICAgICAgSU5QVVQ6IDEsXG4gICAgICAgIE9VVFBVVDogMixcblxuICAgICAgICBFVkVOVDogLTEsIC8vZm9yIG91dHB1dHNcbiAgICAgICAgQUNUSU9OOiAtMSwgLy9mb3IgaW5wdXRzXG5cbiAgICAgICAgQUxXQVlTOiAwLFxuICAgICAgICBPTl9FVkVOVDogMSxcbiAgICAgICAgTkVWRVI6IDIsXG4gICAgICAgIE9OX1RSSUdHRVI6IDMsXG5cbiAgICAgICAgVVA6IDEsXG4gICAgICAgIERPV046IDIsXG4gICAgICAgIExFRlQ6IDMsXG4gICAgICAgIFJJR0hUOiA0LFxuICAgICAgICBDRU5URVI6IDUsXG5cbiAgICAgICAgU1RSQUlHSFRfTElOSzogMCxcbiAgICAgICAgTElORUFSX0xJTks6IDEsXG4gICAgICAgIFNQTElORV9MSU5LOiAyLFxuXG4gICAgICAgIE5PUk1BTF9USVRMRTogMCxcbiAgICAgICAgTk9fVElUTEU6IDEsXG4gICAgICAgIFRSQU5TUEFSRU5UX1RJVExFOiAyLFxuICAgICAgICBBVVRPSElERV9USVRMRTogMyxcblxuICAgICAgICBwcm94eTogbnVsbCwgLy91c2VkIHRvIHJlZGlyZWN0IGNhbGxzXG4gICAgICAgIG5vZGVfaW1hZ2VzX3BhdGg6IFwiXCIsXG5cbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBjYXRjaF9leGNlcHRpb25zOiB0cnVlLFxuICAgICAgICB0aHJvd19lcnJvcnM6IHRydWUsXG4gICAgICAgIGFsbG93X3NjcmlwdHM6IGZhbHNlLCAvL2lmIHNldCB0byB0cnVlIHNvbWUgbm9kZXMgbGlrZSBGb3JtdWxhIHdvdWxkIGJlIGFsbG93ZWQgdG8gZXZhbHVhdGUgY29kZSB0aGF0IGNvbWVzIGZyb20gdW5zYWZlIHNvdXJjZXMgKGxpa2Ugbm9kZSBjb25maWd1cmF0aW9uKSwgd2hpY2ggY291bGQgbGVhZCB0byBleHBsb2l0c1xuICAgICAgICByZWdpc3RlcmVkX25vZGVfdHlwZXM6IHt9LCAvL25vZGV0eXBlcyBieSBzdHJpbmdcbiAgICAgICAgbm9kZV90eXBlc19ieV9maWxlX2V4dGVuc2lvbjoge30sIC8vdXNlZCBmb3IgZHJvcHBpbmcgZmlsZXMgaW4gdGhlIGNhbnZhc1xuICAgICAgICBOb2Rlczoge30sIC8vbm9kZSB0eXBlcyBieSBjbGFzc25hbWVcblx0XHRHbG9iYWxzOiB7fSwgLy91c2VkIHRvIHN0b3JlIHZhcnMgYmV0d2VlbiBncmFwaHNcblxuICAgICAgICBzZWFyY2hib3hfZXh0cmFzOiB7fSwgLy91c2VkIHRvIGFkZCBleHRyYSBmZWF0dXJlcyB0byB0aGUgc2VhcmNoIGJveFxuICAgICAgICBhdXRvX3NvcnRfbm9kZV90eXBlczogZmFsc2UsIC8vIElmIHNldCB0byB0cnVlLCB3aWxsIGF1dG9tYXRpY2FsbHkgc29ydCBub2RlIHR5cGVzIC8gY2F0ZWdvcmllcyBpbiB0aGUgY29udGV4dCBtZW51c1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIG5vZGUgY2xhc3Mgc28gaXQgY2FuIGJlIGxpc3RlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3Rlck5vZGVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIG5hbWUgb2YgdGhlIG5vZGUgYW5kIHBhdGhcbiAgICAgICAgICogQHBhcmFtIHtDbGFzc30gYmFzZV9jbGFzcyBjbGFzcyBjb250YWluaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgYSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHJlZ2lzdGVyTm9kZVR5cGU6IGZ1bmN0aW9uKHR5cGUsIGJhc2VfY2xhc3MpIHtcbiAgICAgICAgICAgIGlmICghYmFzZV9jbGFzcy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCByZWdpc3RlciBhIHNpbXBsZSBvYmplY3QsIGl0IG11c3QgYmUgYSBjbGFzcyB3aXRoIGEgcHJvdG90eXBlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlX2NsYXNzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJOb2RlIHJlZ2lzdGVyZWQ6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzID0gdHlwZS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICB2YXIgY2xhc3NuYW1lID0gYmFzZV9jbGFzcy5uYW1lO1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gdHlwZS5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgICBiYXNlX2NsYXNzLmNhdGVnb3J5ID0gdHlwZS5zdWJzdHIoMCwgcG9zKTtcblxuICAgICAgICAgICAgaWYgKCFiYXNlX2NsYXNzLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgYmFzZV9jbGFzcy50aXRsZSA9IGNsYXNzbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaW5mby5uYW1lID0gbmFtZS5zdWJzdHIocG9zKzEsbmFtZS5sZW5ndGggLSBwb3MpO1xuXG4gICAgICAgICAgICAvL2V4dGVuZCBjbGFzc1xuICAgICAgICAgICAgaWYgKGJhc2VfY2xhc3MucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy9pcyBhIGNsYXNzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBMR3JhcGhOb2RlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VfY2xhc3MucHJvdG90eXBlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlX2NsYXNzLnByb3RvdHlwZVtpXSA9IExHcmFwaE5vZGUucHJvdG90eXBlW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW3R5cGVdO1xuXHRcdFx0aWYocHJldilcblx0XHRcdFx0Y29uc29sZS5sb2coXCJyZXBsYWNpbmcgbm9kZSB0eXBlOiBcIiArIHR5cGUpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRpZiggIU9iamVjdC5oYXNPd25Qcm9wZXJ0eSggYmFzZV9jbGFzcy5wcm90b3R5cGUsIFwic2hhcGVcIikgKVxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYmFzZV9jbGFzcy5wcm90b3R5cGUsIFwic2hhcGVcIiwge1xuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0c3dpdGNoICh2KSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJkZWZhdWx0XCI6XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3NoYXBlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiYm94XCI6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2hhcGUgPSBMaXRlR3JhcGguQk9YX1NIQVBFO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwicm91bmRcIjpcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaGFwZSA9IExpdGVHcmFwaC5ST1VORF9TSEFQRTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBcImNpcmNsZVwiOlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NoYXBlID0gTGl0ZUdyYXBoLkNJUkNMRV9TSEFQRTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBcImNhcmRcIjpcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaGFwZSA9IExpdGVHcmFwaC5DQVJEX1NIQVBFO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NoYXBlID0gdjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3NoYXBlO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly93YXJuaW5nc1xuXHRcdFx0XHRpZiAoYmFzZV9jbGFzcy5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdFwiTGl0ZUdyYXBoIG5vZGUgY2xhc3MgXCIgK1xuXHRcdFx0XHRcdFx0XHR0eXBlICtcblx0XHRcdFx0XHRcdFx0XCIgaGFzIG9uUHJvcGVydHlDaGFuZ2UgbWV0aG9kLCBpdCBtdXN0IGJlIGNhbGxlZCBvblByb3BlcnR5Q2hhbmdlZCB3aXRoIGQgYXQgdGhlIGVuZFwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vdXNlZCB0byBrbm93IHdoaWNoIG5vZGVzIGNyZWF0ZSB3aGVuIGRyYWdnaW5nIGZpbGVzIHRvIHRoZSBjYW52YXNcblx0XHRcdFx0aWYgKGJhc2VfY2xhc3Muc3VwcG9ydGVkX2V4dGVuc2lvbnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpIGluIGJhc2VfY2xhc3Muc3VwcG9ydGVkX2V4dGVuc2lvbnMpIHtcblx0XHRcdFx0XHRcdHZhciBleHQgPSBiYXNlX2NsYXNzLnN1cHBvcnRlZF9leHRlbnNpb25zW2ldO1xuXHRcdFx0XHRcdFx0aWYoZXh0ICYmIGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKVxuXHRcdFx0XHRcdFx0XHR0aGlzLm5vZGVfdHlwZXNfYnlfZmlsZV9leHRlbnNpb25bIGV4dC50b0xvd2VyQ2FzZSgpIF0gPSBiYXNlX2NsYXNzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1t0eXBlXSA9IGJhc2VfY2xhc3M7XG4gICAgICAgICAgICBpZiAoYmFzZV9jbGFzcy5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Ob2Rlc1tjbGFzc25hbWVdID0gYmFzZV9jbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGgub25Ob2RlVHlwZVJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBMaXRlR3JhcGgub25Ob2RlVHlwZVJlZ2lzdGVyZWQodHlwZSwgYmFzZV9jbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBMaXRlR3JhcGgub25Ob2RlVHlwZVJlcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgTGl0ZUdyYXBoLm9uTm9kZVR5cGVSZXBsYWNlZCh0eXBlLCBiYXNlX2NsYXNzLCBwcmV2KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy93YXJuaW5nc1xuICAgICAgICAgICAgaWYgKGJhc2VfY2xhc3MucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgIFwiTGl0ZUdyYXBoIG5vZGUgY2xhc3MgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBoYXMgb25Qcm9wZXJ0eUNoYW5nZSBtZXRob2QsIGl0IG11c3QgYmUgY2FsbGVkIG9uUHJvcGVydHlDaGFuZ2VkIHdpdGggZCBhdCB0aGUgZW5kXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHQvL3VzZWQgdG8ga25vdyB3aGljaCBub2RlcyBjcmVhdGUgd2hlbiBkcmFnZ2luZyBmaWxlcyB0byB0aGUgY2FudmFzXG4gICAgICAgICAgICBpZiAoYmFzZV9jbGFzcy5zdXBwb3J0ZWRfZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGJhc2VfY2xhc3Muc3VwcG9ydGVkX2V4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgZXh0ID0gYmFzZV9jbGFzcy5zdXBwb3J0ZWRfZXh0ZW5zaW9uc1tpXTtcblx0XHRcdFx0XHRpZihleHQgJiYgZXh0LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX3R5cGVzX2J5X2ZpbGVfZXh0ZW5zaW9uWyBleHQudG9Mb3dlckNhc2UoKSBdID0gYmFzZV9jbGFzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZXMgYSBub2RlIHR5cGUgZnJvbSB0aGUgc3lzdGVtXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3Rlck5vZGVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdHlwZSBuYW1lIG9mIHRoZSBub2RlIG9yIHRoZSBub2RlIGNvbnN0cnVjdG9yIGl0c2VsZlxuICAgICAgICAgKi9cbiAgICAgICAgdW5yZWdpc3Rlck5vZGVUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgYmFzZV9jbGFzcyA9IHR5cGUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW3R5cGVdIDogdHlwZTtcblx0XHRcdGlmKCFiYXNlX2NsYXNzKVxuXHRcdFx0XHR0aHJvdyhcIm5vZGUgdHlwZSBub3QgZm91bmQ6IFwiICsgdHlwZSApO1xuXHRcdFx0ZGVsZXRlIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW2Jhc2VfY2xhc3MudHlwZV07XG5cdFx0XHRpZihiYXNlX2NsYXNzLmNvbnN0cnVjdG9yLm5hbWUpXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLk5vZGVzW2Jhc2VfY2xhc3MuY29uc3RydWN0b3IubmFtZV07XG5cdFx0fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IG5vZGV0eXBlIGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiwgaXQgd3JhcHMgaXQgd2l0aCBhIHByb3BlciBjbGFzcyBhbmQgZ2VuZXJhdGVzIGlucHV0cyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKiBVc2VmdWwgdG8gd3JhcCBzaW1wbGUgbWV0aG9kcyB0aGF0IGRvIG5vdCByZXF1aXJlIHByb3BlcnRpZXMsIGFuZCB0aGF0IG9ubHkgcHJvY2VzcyBzb21lIGlucHV0IHRvIGdlbmVyYXRlIGFuIG91dHB1dC5cbiAgICAgICAgICogQG1ldGhvZCB3cmFwRnVuY3Rpb25Bc05vZGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZSBuYW1lIHdpdGggbmFtZXNwYWNlIChwLmUuOiAnbWF0aC9zdW0nKVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtX3R5cGVzIFtvcHRpb25hbF0gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdHlwZSBvZiBldmVyeSBwYXJhbWV0ZXIsIG90aGVyd2lzZSBwYXJhbWV0ZXJzIHdpbGwgYWNjZXB0IGFueSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXR1cm5fdHlwZSBbb3B0aW9uYWxdIHN0cmluZyB3aXRoIHRoZSByZXR1cm4gdHlwZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZ2VuZXJpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBbb3B0aW9uYWxdIHByb3BlcnRpZXMgdG8gYmUgY29uZmlndXJhYmxlXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwRnVuY3Rpb25Bc05vZGU6IGZ1bmN0aW9uKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICBwYXJhbV90eXBlcyxcbiAgICAgICAgICAgIHJldHVybl90eXBlLFxuICAgICAgICAgICAgcHJvcGVydGllc1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBBcnJheShmdW5jLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBMaXRlR3JhcGguZ2V0UGFyYW1ldGVyTmFtZXMoZnVuYyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29kZSArPVxuICAgICAgICAgICAgICAgICAgICBcInRoaXMuYWRkSW5wdXQoJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNbaV0gK1xuICAgICAgICAgICAgICAgICAgICBcIicsXCIgK1xuICAgICAgICAgICAgICAgICAgICAocGFyYW1fdHlwZXMgJiYgcGFyYW1fdHlwZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCInXCIgKyBwYXJhbV90eXBlc1tpXSArIFwiJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiMFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiKTtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgKz1cbiAgICAgICAgICAgICAgICBcInRoaXMuYWRkT3V0cHV0KCdvdXQnLFwiICtcbiAgICAgICAgICAgICAgICAocmV0dXJuX3R5cGUgPyBcIidcIiArIHJldHVybl90eXBlICsgXCInXCIgOiAwKSArXG4gICAgICAgICAgICAgICAgXCIpO1xcblwiO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBjb2RlICs9XG4gICAgICAgICAgICAgICAgICAgIFwidGhpcy5wcm9wZXJ0aWVzID0gXCIgKyBKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKSArIFwiO1xcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsYXNzb2JqID0gRnVuY3Rpb24oY29kZSk7XG4gICAgICAgICAgICBjbGFzc29iai50aXRsZSA9IG5hbWUuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICAgICAgY2xhc3NvYmouZGVzYyA9IFwiR2VuZXJhdGVkIGZyb20gXCIgKyBmdW5jLm5hbWU7XG4gICAgICAgICAgICBjbGFzc29iai5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24gb25FeGVjdXRlKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgciA9IGZ1bmMuYXBwbHkodGhpcywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck5vZGVUeXBlKG5hbWUsIGNsYXNzb2JqKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgcHJldmlvdXNseSByZWdpc3RlcmVkIG5vZGUncyB0eXBlc1xuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJSZWdpc3RlcmVkVHlwZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubm9kZV90eXBlc19ieV9maWxlX2V4dGVuc2lvbiA9IHt9O1xuICAgICAgICAgICAgdGhpcy5Ob2RlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hib3hfZXh0cmFzID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgdGhpcyBtZXRob2QgdG8gYWxsIG5vZGV0eXBlcywgZXhpc3RpbmcgYW5kIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICogKFlvdSBjYW4gYWRkIGl0IHRvIExHcmFwaE5vZGUucHJvdG90eXBlIGJ1dCB0aGVuIGV4aXN0aW5nIG5vZGUgdHlwZXMgd29udCBoYXZlIGl0KVxuICAgICAgICAgKiBAbWV0aG9kIGFkZE5vZGVNZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkTm9kZU1ldGhvZDogZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgICAgICAgICAgTEdyYXBoTm9kZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlcykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvdG90eXBlW1wiX1wiICsgbmFtZV0gPSB0eXBlLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9IC8va2VlcCBvbGQgaW4gY2FzZSBvZiByZXBsYWNpbmdcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5vZGUgb2YgYSBnaXZlbiB0eXBlIHdpdGggYSBuYW1lLiBUaGUgbm9kZSBpcyBub3QgYXR0YWNoZWQgdG8gYW55IGdyYXBoIHlldC5cbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVOb2RlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGZ1bGwgbmFtZSBvZiB0aGUgbm9kZSBjbGFzcy4gcC5lLiBcIm1hdGgvc2luXCJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIHRvIGRpc3Rpbmd1aXNoIGZyb20gb3RoZXIgbm9kZXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gc2V0IG9wdGlvbnNcbiAgICAgICAgICovXG5cbiAgICAgICAgY3JlYXRlTm9kZTogZnVuY3Rpb24odHlwZSwgdGl0bGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBiYXNlX2NsYXNzID0gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoIWJhc2VfY2xhc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dyYXBoTm9kZSB0eXBlIFwiJyArIHR5cGUgKyAnXCIgbm90IHJlZ2lzdGVyZWQuJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGJhc2VfY2xhc3MucHJvdG90eXBlIHx8IGJhc2VfY2xhc3M7XG5cbiAgICAgICAgICAgIHRpdGxlID0gdGl0bGUgfHwgYmFzZV9jbGFzcy50aXRsZSB8fCB0eXBlO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGguY2F0Y2hfZXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgYmFzZV9jbGFzcyh0aXRsZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IGJhc2VfY2xhc3ModGl0bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUudGl0bGUgJiYgdGl0bGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLnByb3BlcnRpZXNfaW5mbykge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllc19pbmZvID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBub2RlLmZsYWdzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2l6ZSA9IG5vZGUuY29tcHV0ZVNpemUoKTtcblx0XHRcdFx0Ly9jYWxsIG9ucmVzaXplP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLnBvcykge1xuICAgICAgICAgICAgICAgIG5vZGUucG9zID0gTGl0ZUdyYXBoLkRFRkFVTFRfUE9TSVRJT04uY29uY2F0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUubW9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUubW9kZSA9IExpdGVHcmFwaC5BTFdBWVM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZXh0cmEgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVtpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHJlZ2lzdGVyZWQgbm9kZSB0eXBlIHdpdGggYSBnaXZlbiBuYW1lXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Tm9kZVR5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZnVsbCBuYW1lIG9mIHRoZSBub2RlIGNsYXNzLiBwLmUuIFwibWF0aC9zaW5cIlxuICAgICAgICAgKiBAcmV0dXJuIHtDbGFzc30gdGhlIG5vZGUgY2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIGdldE5vZGVUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbdHlwZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGUgdHlwZXMgbWF0Y2hpbmcgb25lIGNhdGVnb3J5XG4gICAgICAgICAqIEBtZXRob2QgZ2V0Tm9kZVR5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IHdpdGggYWxsIHRoZSBub2RlIGNsYXNzZXNcbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Tm9kZVR5cGVzSW5DYXRlZ29yeTogZnVuY3Rpb24oY2F0ZWdvcnksIGZpbHRlcikge1xuICAgICAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmZpbHRlciAhPSBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUuY2F0ZWdvcnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLmNhdGVnb3J5ID09IGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9fc29ydF9ub2RlX3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgci5zb3J0KChhLCBiKSA9PiBhLnRpdGxlLmxvY2FsZUNvbXBhcmUoYi50aXRsZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgd2l0aCBhbGwgdGhlIG5vZGUgdHlwZSBjYXRlZ29yaWVzXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Tm9kZVR5cGVzQ2F0ZWdvcmllc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsdGVyIG9ubHkgbm9kZXMgd2l0aCBjdG9yLmZpbHRlciBlcXVhbCBjYW4gYmUgc2hvd25cbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IHdpdGggYWxsIHRoZSBuYW1lcyBvZiB0aGUgY2F0ZWdvcmllc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Tm9kZVR5cGVzQ2F0ZWdvcmllczogZnVuY3Rpb24oIGZpbHRlciApIHtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzID0geyBcIlwiOiAxIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlLmNhdGVnb3J5ICYmICF0eXBlLnNraXBfbGlzdCApXG4gICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdGlmKHR5cGUuZmlsdGVyICE9IGZpbHRlcilcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzW3R5cGUuY2F0ZWdvcnldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9fc29ydF9ub2RlX3R5cGVzID8gcmVzdWx0LnNvcnQoKSA6IHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvL2RlYnVnIHB1cnBvc2VzOiByZWxvYWRzIGFsbCB0aGUganMgc2NyaXB0cyB0aGF0IG1hdGNoZXMgYSB3aWxkY2FyZFxuICAgICAgICByZWxvYWROb2RlczogZnVuY3Rpb24oZm9sZGVyX3dpbGRjYXJkKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICAvL3dlaXJkLCB0aGlzIGFycmF5IGNoYW5nZXMgYnkgaXRzIG93biwgc28gd2UgdXNlIGEgY29weVxuICAgICAgICAgICAgdmFyIHNjcmlwdF9maWxlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdG1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0X2ZpbGVzLnB1c2godG1wW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRvY0hlYWRPYmogPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gICAgICAgICAgICBmb2xkZXJfd2lsZGNhcmQgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgZm9sZGVyX3dpbGRjYXJkO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBzY3JpcHRfZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gc2NyaXB0X2ZpbGVzW2ldLnNyYztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFzcmMgfHxcbiAgICAgICAgICAgICAgICAgICAgc3JjLnN1YnN0cigwLCBmb2xkZXJfd2lsZGNhcmQubGVuZ3RoKSAhPSBmb2xkZXJfd2lsZGNhcmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWxvYWRpbmc6IFwiICsgc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZHluYW1pY1NjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBkb2NIZWFkT2JqLmFwcGVuZENoaWxkKGR5bmFtaWNTY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICBkb2NIZWFkT2JqLnJlbW92ZUNoaWxkKHNjcmlwdF9maWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGgudGhyb3dfZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciB3aGlsZSByZWxvYWRpbmcgXCIgKyBzcmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJOb2RlcyByZWxvYWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvL3NlcGFyYXRlZCBqdXN0IHRvIGltcHJvdmUgaWYgaXQgZG9lc24ndCB3b3JrXG4gICAgICAgIGNsb25lT2JqZWN0OiBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSByW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiB0aGUgdHlwZXMgb2YgdHdvIHNsb3RzIGFyZSBjb21wYXRpYmxlICh0YWtpbmcgaW50byBhY2NvdW50IHdpbGRjYXJkcywgZXRjKVxuICAgICAgICAgKiBAbWV0aG9kIGlzVmFsaWRDb25uZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlX2FcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVfYlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZXkgY2FuIGJlIGNvbm5lY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGZ1bmN0aW9uKHR5cGVfYSwgdHlwZV9iKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXR5cGVfYSB8fCAvL2dlbmVyaWMgb3V0cHV0XG4gICAgICAgICAgICAgICAgIXR5cGVfYiB8fCAvL2dlbmVyaWMgaW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlX2EgPT0gdHlwZV9iIHx8IC8vc2FtZSB0eXBlIChpcyB2YWxpZCBmb3IgdHJpZ2dlcnMpXG4gICAgICAgICAgICAgICAgKHR5cGVfYSA9PSBMaXRlR3JhcGguRVZFTlQgJiYgdHlwZV9iID09IExpdGVHcmFwaC5BQ1RJT04pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5mb3JjZSBzdHJpbmcgdHlwZSB0byBoYW5kbGUgdG9Mb3dlckNhc2UgY2FsbCAoLTEgbnVtYmVyIG5vdCBvaylcbiAgICAgICAgICAgIHR5cGVfYSA9IFN0cmluZyh0eXBlX2EpO1xuICAgICAgICAgICAgdHlwZV9iID0gU3RyaW5nKHR5cGVfYik7XG4gICAgICAgICAgICB0eXBlX2EgPSB0eXBlX2EudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHR5cGVfYiA9IHR5cGVfYi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBGb3Igbm9kZXMgc3VwcG9ydGluZyBtdWx0aXBsZSBjb25uZWN0aW9uIHR5cGVzXG4gICAgICAgICAgICBpZiAodHlwZV9hLmluZGV4T2YoXCIsXCIpID09IC0xICYmIHR5cGVfYi5pbmRleE9mKFwiLFwiKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlX2EgPT0gdHlwZV9iO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBhbGwgcGVybXV0YXRpb25zIHRvIHNlZSBpZiBvbmUgaXMgdmFsaWRcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWRfdHlwZXNfYSA9IHR5cGVfYS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkX3R5cGVzX2IgPSB0eXBlX2Iuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBwb3J0ZWRfdHlwZXNfYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3VwcG9ydGVkX3R5cGVzX2IubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZF90eXBlc19hW2ldID09IHN1cHBvcnRlZF90eXBlc19iW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIHN0cmluZyBpbiB0aGUgc2VhcmNoIGJveCBzbyB3aGVuIHRoZSB1c2VyIHR5cGVzIGl0IGl0IHdpbGwgcmVjb21tZW5kIHRoaXMgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyU2VhcmNoYm94RXh0cmFcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVfdHlwZSB0aGUgbm9kZSByZWNvbW1lbmRlZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gdGV4dCB0byBzaG93IG5leHQgdG8gaXRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgaXQgY291bGQgY29udGFpbiBpbmZvIG9mIGhvdyB0aGUgbm9kZSBzaG91bGQgYmUgY29uZmlndXJlZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZXkgY2FuIGJlIGNvbm5lY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTZWFyY2hib3hFeHRyYTogZnVuY3Rpb24obm9kZV90eXBlLCBkZXNjcmlwdGlvbiwgZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hib3hfZXh0cmFzW2Rlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGVfdHlwZSxcbiAgICAgICAgICAgICAgICBkZXNjOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcGVyIHRvIGxvYWQgZmlsZXMgKGZyb20gdXJsIHVzaW5nIGZldGNoIG9yIGZyb20gZmlsZSB1c2luZyBGaWxlUmVhZGVyKVxuICAgICAgICAgKiBAbWV0aG9kIGZldGNoRmlsZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xGaWxlfEJsb2J9IHVybCB0aGUgdXJsIG9mIHRoZSBmaWxlIChvciB0aGUgZmlsZSBpdHNlbGYpXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGFuIHN0cmluZyB0byBrbm93IGhvdyB0byBmZXRjaCBpdDogXCJ0ZXh0XCIsXCJhcnJheWJ1ZmZlclwiLFwianNvblwiLFwiYmxvYlwiXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uX2NvbXBsZXRlIGNhbGxiYWNrKGRhdGEpXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uX2Vycm9yIGluIGNhc2Ugb2YgYW4gZXJyb3JcbiAgICAgICAgICogQHJldHVybiB7RmlsZVJlYWRlcnxQcm9taXNlfSByZXR1cm5zIHRoZSBvYmplY3QgdXNlZCB0byBcbiAgICAgICAgICovXG5cdFx0ZmV0Y2hGaWxlOiBmdW5jdGlvbiggdXJsLCB0eXBlLCBvbl9jb21wbGV0ZSwgb25fZXJyb3IgKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRpZighdXJsKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJ0ZXh0XCI7XG5cdFx0XHRpZiggdXJsLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodXJsLnN1YnN0cigwLCA0KSA9PSBcImh0dHBcIiAmJiBMaXRlR3JhcGgucHJveHkpIHtcblx0XHRcdFx0XHR1cmwgPSBMaXRlR3JhcGgucHJveHkgKyB1cmwuc3Vic3RyKHVybC5pbmRleE9mKFwiOlwiKSArIDMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmZXRjaCh1cmwpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0aWYoIXJlc3BvbnNlLm9rKVxuXHRcdFx0XHRcdFx0IHRocm93IG5ldyBFcnJvcihcIkZpbGUgbm90IGZvdW5kXCIpOyAvL2l0IHdpbGwgYmUgY2F0Y2ggYmVsb3dcblx0XHRcdFx0XHRpZih0eXBlID09IFwiYXJyYXlidWZmZXJcIilcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXHRcdFx0XHRcdGVsc2UgaWYodHlwZSA9PSBcInRleHRcIiB8fCB0eXBlID09IFwic3RyaW5nXCIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXHRcdFx0XHRcdGVsc2UgaWYodHlwZSA9PSBcImpzb25cIilcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdFx0XHRcdFx0ZWxzZSBpZih0eXBlID09IFwiYmxvYlwiKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdGlmKG9uX2NvbXBsZXRlKVxuXHRcdFx0XHRcdFx0b25fY29tcGxldGUoZGF0YSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJlcnJvciBmZXRjaGluZyBmaWxlOlwiLHVybCk7XG5cdFx0XHRcdFx0aWYob25fZXJyb3IpXG5cdFx0XHRcdFx0XHRvbl9lcnJvcihlcnJvcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiggdXJsLmNvbnN0cnVjdG9yID09PSBGaWxlIHx8IHVybC5jb25zdHJ1Y3RvciA9PT0gQmxvYilcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIHYgPSBlLnRhcmdldC5yZXN1bHQ7XG5cdFx0XHRcdFx0aWYoIHR5cGUgPT0gXCJqc29uXCIgKVxuXHRcdFx0XHRcdFx0diA9IEpTT04ucGFyc2Uodik7XG5cdFx0XHRcdFx0aWYob25fY29tcGxldGUpXG5cdFx0XHRcdFx0XHRvbl9jb21wbGV0ZSh2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0eXBlID09IFwiYXJyYXlidWZmZXJcIilcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHVybCk7XG5cdFx0XHRcdGVsc2UgaWYodHlwZSA9PSBcInRleHRcIiB8fCB0eXBlID09IFwianNvblwiKVxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzVGV4dCh1cmwpO1xuXHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJibG9iXCIpXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcodXJsKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cbiAgICB9KTtcblxuICAgIC8vdGltZXIgdGhhdCB3b3JrcyBldmVyeXdoZXJlXG4gICAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIExpdGVHcmFwaC5nZXRUaW1lID0gcGVyZm9ybWFuY2Uubm93LmJpbmQocGVyZm9ybWFuY2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIERhdGUgIT0gXCJ1bmRlZmluZWRcIiAmJiBEYXRlLm5vdykge1xuICAgICAgICBMaXRlR3JhcGguZ2V0VGltZSA9IERhdGUubm93LmJpbmQoRGF0ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIExpdGVHcmFwaC5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gdFswXSAqIDAuMDAxICsgdFsxXSAqIDFlLTY7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgTGl0ZUdyYXBoLmdldFRpbWUgPSBmdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTEdyYXBoIENMQVNTXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIExHcmFwaCBpcyB0aGUgY2xhc3MgdGhhdCBjb250YWluIGEgZnVsbCBncmFwaC4gV2UgaW5zdGFudGlhdGUgb25lIGFuZCBhZGQgbm9kZXMgdG8gaXQsIGFuZCB0aGVuIHdlIGNhbiBydW4gdGhlIGV4ZWN1dGlvbiBsb29wLlxuXHQgKiBzdXBwb3J0ZWQgY2FsbGJhY2tzOlxuXHRcdCsgb25Ob2RlQWRkZWQ6IHdoZW4gYSBuZXcgbm9kZSBpcyBhZGRlZCB0byB0aGUgZ3JhcGhcblx0XHQrIG9uTm9kZVJlbW92ZWQ6IHdoZW4gYSBub2RlIGluc2lkZSB0aGlzIGdyYXBoIGlzIHJlbW92ZWRcblx0XHQrIG9uTm9kZUNvbm5lY3Rpb25DaGFuZ2U6IHNvbWUgY29ubmVjdGlvbiBoYXMgY2hhbmdlZCBpbiB0aGUgZ3JhcGggKGNvbm5lY3RlZCBvciBkaXNjb25uZWN0ZWQpXG4gICAgICpcbiAgICAgKiBAY2xhc3MgTEdyYXBoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG8gZGF0YSBmcm9tIHByZXZpb3VzIHNlcmlhbGl6YXRpb24gW29wdGlvbmFsXVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTEdyYXBoKG8pIHtcbiAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHcmFwaCBjcmVhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUobyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbG9iYWwuTEdyYXBoID0gTGl0ZUdyYXBoLkxHcmFwaCA9IExHcmFwaDtcblxuICAgIC8vZGVmYXVsdCBzdXBwb3J0ZWQgdHlwZXNcbiAgICBMR3JhcGguc3VwcG9ydGVkX3R5cGVzID0gW1wibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwiYm9vbGVhblwiXTtcblxuICAgIC8vdXNlZCB0byBrbm93IHdoaWNoIHR5cGVzIG9mIGNvbm5lY3Rpb25zIHN1cHBvcnQgdGhpcyBncmFwaCAoc29tZSBncmFwaHMgZG8gbm90IGFsbG93IGNlcnRhaW4gdHlwZXMpXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRTdXBwb3J0ZWRUeXBlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRfdHlwZXMgfHwgTEdyYXBoLnN1cHBvcnRlZF90eXBlcztcbiAgICB9O1xuXG4gICAgTEdyYXBoLlNUQVRVU19TVE9QUEVEID0gMTtcbiAgICBMR3JhcGguU1RBVFVTX1JVTk5JTkcgPSAyO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbm9kZXMgZnJvbSB0aGlzIGdyYXBoXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBMR3JhcGguU1RBVFVTX1NUT1BQRUQ7XG5cbiAgICAgICAgdGhpcy5sYXN0X25vZGVfaWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RfbGlua19pZCA9IDA7XG5cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IC0xOyAvL3VzZWQgdG8gZGV0ZWN0IGNoYW5nZXNcblxuICAgICAgICAvL3NhZmUgY2xlYXJcbiAgICAgICAgaWYgKHRoaXMuX25vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vblJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vblJlbW92ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL25vZGVzXG4gICAgICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgICAgIHRoaXMuX25vZGVzX2J5X2lkID0ge307XG4gICAgICAgIHRoaXMuX25vZGVzX2luX29yZGVyID0gW107IC8vbm9kZXMgc29ydGVkIGluIGV4ZWN1dGlvbiBvcmRlclxuICAgICAgICB0aGlzLl9ub2Rlc19leGVjdXRhYmxlID0gbnVsbDsgLy9ub2RlcyB0aGF0IGNvbnRhaW4gb25FeGVjdXRlIHNvcnRlZCBpbiBleGVjdXRpb24gb3JkZXJcblxuICAgICAgICAvL290aGVyIHNjZW5lIHN0dWZmXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuXG4gICAgICAgIC8vbGlua3NcbiAgICAgICAgdGhpcy5saW5rcyA9IHt9OyAvL2NvbnRhaW5lciB3aXRoIGFsbCB0aGUgbGlua3NcblxuICAgICAgICAvL2l0ZXJhdGlvbnNcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSAwO1xuXG4gICAgICAgIC8vY3VzdG9tIGRhdGFcbiAgICAgICAgdGhpcy5jb25maWcgPSB7fTtcblx0XHR0aGlzLnZhcnMgPSB7fTtcblx0XHR0aGlzLmV4dHJhID0ge307IC8vdG8gc3RvcmUgY3VzdG9tIGRhdGFcblxuICAgICAgICAvL3RpbWluZ1xuICAgICAgICB0aGlzLmdsb2JhbHRpbWUgPSAwO1xuICAgICAgICB0aGlzLnJ1bm5pbmd0aW1lID0gMDtcbiAgICAgICAgdGhpcy5maXhlZHRpbWUgPSAwO1xuICAgICAgICB0aGlzLmZpeGVkdGltZV9sYXBzZSA9IDAuMDE7XG4gICAgICAgIHRoaXMuZWxhcHNlZF90aW1lID0gMC4wMTtcbiAgICAgICAgdGhpcy5sYXN0X3VwZGF0ZV90aW1lID0gMDtcbiAgICAgICAgdGhpcy5zdGFydHRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMuY2F0Y2hfZXJyb3JzID0gdHJ1ZTtcblxuICAgICAgICAvL3N1YmdyYXBoX2RhdGFcbiAgICAgICAgdGhpcy5pbnB1dHMgPSB7fTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0ge307XG5cbiAgICAgICAgLy9ub3RpZnkgY2FudmFzIHRvIHJlZHJhd1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuXG4gICAgICAgIHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwiY2xlYXJcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBDYW52YXMgdG8gdGhpcyBncmFwaFxuICAgICAqIEBtZXRob2QgYXR0YWNoQ2FudmFzXG4gICAgICogQHBhcmFtIHtHcmFwaENhbnZhc30gZ3JhcGhfY2FudmFzXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmF0dGFjaENhbnZhcyA9IGZ1bmN0aW9uKGdyYXBoY2FudmFzKSB7XG4gICAgICAgIGlmIChncmFwaGNhbnZhcy5jb25zdHJ1Y3RvciAhPSBMR3JhcGhDYW52YXMpIHtcbiAgICAgICAgICAgIHRocm93IFwiYXR0YWNoQ2FudmFzIGV4cGVjdHMgYSBMR3JhcGhDYW52YXMgaW5zdGFuY2VcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JhcGhjYW52YXMuZ3JhcGggJiYgZ3JhcGhjYW52YXMuZ3JhcGggIT0gdGhpcykge1xuICAgICAgICAgICAgZ3JhcGhjYW52YXMuZ3JhcGguZGV0YWNoQ2FudmFzKGdyYXBoY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoY2FudmFzLmdyYXBoID0gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5saXN0X29mX2dyYXBoY2FudmFzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0X29mX2dyYXBoY2FudmFzLnB1c2goZ3JhcGhjYW52YXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggQ2FudmFzIGZyb20gdGhpcyBncmFwaFxuICAgICAqIEBtZXRob2QgZGV0YWNoQ2FudmFzXG4gICAgICogQHBhcmFtIHtHcmFwaENhbnZhc30gZ3JhcGhfY2FudmFzXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5kZXRhY2hDYW52YXMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xuICAgICAgICBpZiAoIXRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5pbmRleE9mKGdyYXBoY2FudmFzKTtcbiAgICAgICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdyYXBoY2FudmFzLmdyYXBoID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0X29mX2dyYXBoY2FudmFzLnNwbGljZShwb3MsIDEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcnVubmluZyB0aGlzIGdyYXBoIGV2ZXJ5IGludGVydmFsIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYmV0d2VlbiBleGVjdXRpb25zLCBpZiAwIHRoZW4gaXQgcmVuZGVycyB0byB0aGUgbW9uaXRvciByZWZyZXNoIHJhdGVcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gTEdyYXBoLlNUQVRVU19SVU5OSU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBMR3JhcGguU1RBVFVTX1JVTk5JTkc7XG5cbiAgICAgICAgaWYgKHRoaXMub25QbGF5RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMub25QbGF5RXZlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VuZEV2ZW50VG9BbGxOb2RlcyhcIm9uU3RhcnRcIik7XG5cbiAgICAgICAgLy9sYXVuY2hcbiAgICAgICAgdGhpcy5zdGFydHRpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmxhc3RfdXBkYXRlX3RpbWUgPSB0aGlzLnN0YXJ0dGltZTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCAwO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHQvL2V4ZWN1dGUgb25jZSBwZXIgZnJhbWVcbiAgICAgICAgaWYgKCBpbnRlcnZhbCA9PSAwICYmIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuICAgICAgICAgICAgZnVuY3Rpb24gb25fZnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuZXhlY3V0aW9uX3RpbWVyX2lkICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvbl9mcmFtZSk7XG5cdFx0XHRcdGlmKHRoYXQub25CZWZvcmVTdGVwKVxuXHRcdFx0XHRcdHRoYXQub25CZWZvcmVTdGVwKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5ydW5TdGVwKDEsICF0aGF0LmNhdGNoX2Vycm9ycyk7XG5cdFx0XHRcdGlmKHRoYXQub25BZnRlclN0ZXApXG5cdFx0XHRcdFx0dGhhdC5vbkFmdGVyU3RlcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25fdGltZXJfaWQgPSAtMTtcbiAgICAgICAgICAgIG9uX2ZyYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7IC8vZXhlY3V0ZSBldmVyeSAnaW50ZXJ2YWwnIG1zXG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGlvbl90aW1lcl9pZCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vZXhlY3V0ZVxuXHRcdFx0XHRpZih0aGF0Lm9uQmVmb3JlU3RlcClcblx0XHRcdFx0XHR0aGF0Lm9uQmVmb3JlU3RlcCgpO1xuICAgICAgICAgICAgICAgIHRoYXQucnVuU3RlcCgxLCAhdGhhdC5jYXRjaF9lcnJvcnMpO1xuXHRcdFx0XHRpZih0aGF0Lm9uQWZ0ZXJTdGVwKVxuXHRcdFx0XHRcdHRoYXQub25BZnRlclN0ZXAoKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgZXhlY3V0aW9uIGxvb3Agb2YgdGhlIGdyYXBoXG4gICAgICogQG1ldGhvZCBzdG9wIGV4ZWN1dGlvblxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PSBMR3JhcGguU1RBVFVTX1NUT1BQRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gTEdyYXBoLlNUQVRVU19TVE9QUEVEO1xuXG4gICAgICAgIGlmICh0aGlzLm9uU3RvcEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9uU3RvcEV2ZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5leGVjdXRpb25fdGltZXJfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uX3RpbWVyX2lkICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmV4ZWN1dGlvbl90aW1lcl9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGlvbl90aW1lcl9pZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbmRFdmVudFRvQWxsTm9kZXMoXCJvblN0b3BcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJ1biBOIHN0ZXBzIChjeWNsZXMpIG9mIHRoZSBncmFwaFxuICAgICAqIEBtZXRob2QgcnVuU3RlcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW0gbnVtYmVyIG9mIHN0ZXBzIHRvIHJ1biwgZGVmYXVsdCBpcyAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb19ub3RfY2F0Y2hfZXJyb3JzIFtvcHRpb25hbF0gaWYgeW91IHdhbnQgdG8gdHJ5L2NhdGNoIGVycm9ycyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgbWF4IG51bWJlciBvZiBub2RlcyB0byBleGVjdXRlICh1c2VkIHRvIGV4ZWN1dGUgZnJvbSBzdGFydCB0byBhIG5vZGUpXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnJ1blN0ZXAgPSBmdW5jdGlvbihudW0sIGRvX25vdF9jYXRjaF9lcnJvcnMsIGxpbWl0ICkge1xuICAgICAgICBudW0gPSBudW0gfHwgMTtcblxuICAgICAgICB2YXIgc3RhcnQgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmdsb2JhbHRpbWUgPSAwLjAwMSAqIChzdGFydCAtIHRoaXMuc3RhcnR0aW1lKTtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl9ub2Rlc19leGVjdXRhYmxlXG4gICAgICAgICAgICA/IHRoaXMuX25vZGVzX2V4ZWN1dGFibGVcbiAgICAgICAgICAgIDogdGhpcy5fbm9kZXM7XG4gICAgICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0bGltaXQgPSBsaW1pdCB8fCBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGRvX25vdF9jYXRjaF9lcnJvcnMpIHtcbiAgICAgICAgICAgIC8vaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5tb2RlID09IExpdGVHcmFwaC5BTFdBWVMgJiYgbm9kZS5vbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25FeGVjdXRlKCk7IC8vaGFyZCB0byBzZW5kIGVsYXBzZWQgdGltZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5maXhlZHRpbWUgKz0gdGhpcy5maXhlZHRpbWVfbGFwc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25FeGVjdXRlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXhlY3V0ZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9uQWZ0ZXJFeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFmdGVyRXhlY3V0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvL2l0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGUgPT0gTGl0ZUdyYXBoLkFMV0FZUyAmJiBub2RlLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25FeGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkdGltZSArPSB0aGlzLmZpeGVkdGltZV9sYXBzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25FeGVjdXRlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGVTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkFmdGVyRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQWZ0ZXJFeGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzX2luX2V4ZWN1dGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNfaW5fZXhlY3V0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLnRocm93X2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBkdXJpbmcgZXhlY3V0aW9uOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdyA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gc3RhcnQ7XG4gICAgICAgIGlmIChlbGFwc2VkID09IDApIHtcbiAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uX3RpbWUgPSAwLjAwMSAqIGVsYXBzZWQ7XG4gICAgICAgIHRoaXMuZ2xvYmFsdGltZSArPSAwLjAwMSAqIGVsYXBzZWQ7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uICs9IDE7XG4gICAgICAgIHRoaXMuZWxhcHNlZF90aW1lID0gKG5vdyAtIHRoaXMubGFzdF91cGRhdGVfdGltZSkgKiAwLjAwMTtcbiAgICAgICAgdGhpcy5sYXN0X3VwZGF0ZV90aW1lID0gbm93O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBncmFwaCBleGVjdXRpb24gb3JkZXIgYWNjb3JkaW5nIHRvIHJlbGV2YW5jZSBvZiB0aGUgbm9kZXMgKG5vZGVzIHdpdGggb25seSBvdXRwdXRzIGhhdmUgbW9yZSByZWxldmFuY2UgdGhhblxuICAgICAqIG5vZGVzIHdpdGggb25seSBpbnB1dHMuXG4gICAgICogQG1ldGhvZCB1cGRhdGVFeGVjdXRpb25PcmRlclxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUudXBkYXRlRXhlY3V0aW9uT3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbm9kZXNfaW5fb3JkZXIgPSB0aGlzLmNvbXB1dGVFeGVjdXRpb25PcmRlcihmYWxzZSk7XG4gICAgICAgIHRoaXMuX25vZGVzX2V4ZWN1dGFibGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlc19pbl9vcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGVzX2luX29yZGVyW2ldLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzX2V4ZWN1dGFibGUucHVzaCh0aGlzLl9ub2Rlc19pbl9vcmRlcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9UaGlzIGlzIG1vcmUgaW50ZXJuYWwsIGl0IGNvbXB1dGVzIHRoZSBleGVjdXRhYmxlIG5vZGVzIGluIG9yZGVyIGFuZCByZXR1cm5zIGl0XG4gICAgTEdyYXBoLnByb3RvdHlwZS5jb21wdXRlRXhlY3V0aW9uT3JkZXIgPSBmdW5jdGlvbihcbiAgICAgICAgb25seV9vbkV4ZWN1dGUsXG4gICAgICAgIHNldF9sZXZlbFxuICAgICkge1xuICAgICAgICB2YXIgTCA9IFtdO1xuICAgICAgICB2YXIgUyA9IFtdO1xuICAgICAgICB2YXIgTSA9IHt9O1xuICAgICAgICB2YXIgdmlzaXRlZF9saW5rcyA9IHt9OyAvL3RvIGF2b2lkIHJlcGVhdGluZyBsaW5rc1xuICAgICAgICB2YXIgcmVtYWluaW5nX2xpbmtzID0ge307IC8vdG8gYVxuXG4gICAgICAgIC8vc2VhcmNoIGZvciB0aGUgbm9kZXMgd2l0aG91dCBpbnB1dHMgKHN0YXJ0aW5nIG5vZGVzKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX25vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChvbmx5X29uRXhlY3V0ZSAmJiAhbm9kZS5vbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTVtub2RlLmlkXSA9IG5vZGU7IC8vYWRkIHRvIHBlbmRpbmcgbm9kZXNcblxuICAgICAgICAgICAgdmFyIG51bSA9IDA7IC8vbnVtIG9mIGlucHV0IGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbDIgPSBub2RlLmlucHV0cy5sZW5ndGg7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlucHV0c1tqXSAmJiBub2RlLmlucHV0c1tqXS5saW5rICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtID09IDApIHtcbiAgICAgICAgICAgICAgICAvL2lzIGEgc3RhcnRpbmcgbm9kZVxuICAgICAgICAgICAgICAgIFMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0X2xldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2xldmVsID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vbnVtIG9mIGlucHV0IGxpbmtzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0X2xldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2xldmVsID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nX2xpbmtzW25vZGUuaWRdID0gbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChTLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZ2V0IGFuIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gUy5zaGlmdCgpO1xuICAgICAgICAgICAgTC5wdXNoKG5vZGUpOyAvL2FkZCB0byBvcmRlcmVkIGxpc3RcbiAgICAgICAgICAgIGRlbGV0ZSBNW25vZGUuaWRdOyAvL3JlbW92ZSBmcm9tIHRoZSBwZW5kaW5nIG5vZGVzXG5cbiAgICAgICAgICAgIGlmICghbm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZm9yIGV2ZXJ5IG91dHB1dFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIC8vbm90IGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmtzID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmtzLmxlbmd0aCA9PSAwXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vZm9yIGV2ZXJ5IGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dHB1dC5saW5rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IG91dHB1dC5saW5rc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hbHJlYWR5IHZpc2l0ZWQgbGluayAoaWdub3JlIGl0KVxuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZF9saW5rc1tsaW5rLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdldE5vZGVCeUlkKGxpbmsudGFyZ2V0X2lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldF9ub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRfbGlua3NbbGluay5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRfbGV2ZWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghdGFyZ2V0X25vZGUuX2xldmVsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUuX2xldmVsIDw9IG5vZGUuX2xldmVsKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlLl9sZXZlbCA9IG5vZGUuX2xldmVsICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRfbGlua3NbbGluay5pZF0gPSB0cnVlOyAvL21hcmsgYXMgdmlzaXRlZFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdfbGlua3NbdGFyZ2V0X25vZGUuaWRdIC09IDE7IC8vcmVkdWNlIHRoZSBudW1iZXIgb2YgbGlua3MgcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdfbGlua3NbdGFyZ2V0X25vZGUuaWRdID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMucHVzaCh0YXJnZXRfbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy9pZiBubyBtb3JlIGxpbmtzLCB0aGVuIGFkZCB0byBzdGFydGVycyBhcnJheVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhlIHJlbWFpbmluZyBvbmVzIChsb29wcylcbiAgICAgICAgZm9yICh2YXIgaSBpbiBNKSB7XG4gICAgICAgICAgICBMLnB1c2goTVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTC5sZW5ndGggIT0gdGhpcy5fbm9kZXMubGVuZ3RoICYmIExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwic29tZXRoaW5nIHdlbnQgd3JvbmcsIG5vZGVzIG1pc3NpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbCA9IEwubGVuZ3RoO1xuXG4gICAgICAgIC8vc2F2ZSBvcmRlciBudW1iZXIgaW4gdGhlIG5vZGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIExbaV0ub3JkZXIgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zb3J0IG5vdyBieSBwcmlvcml0eVxuICAgICAgICBMID0gTC5zb3J0KGZ1bmN0aW9uKEEsIEIpIHtcbiAgICAgICAgICAgIHZhciBBcCA9IEEuY29uc3RydWN0b3IucHJpb3JpdHkgfHwgQS5wcmlvcml0eSB8fCAwO1xuICAgICAgICAgICAgdmFyIEJwID0gQi5jb25zdHJ1Y3Rvci5wcmlvcml0eSB8fCBCLnByaW9yaXR5IHx8IDA7XG4gICAgICAgICAgICBpZiAoQXAgPT0gQnApIHtcbiAgICAgICAgICAgICAgICAvL2lmIHNhbWUgcHJpb3JpdHksIHNvcnQgYnkgb3JkZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gQS5vcmRlciAtIEIub3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQXAgLSBCcDsgLy9zb3J0IGJ5IHByaW9yaXR5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vc2F2ZSBvcmRlciBudW1iZXIgaW4gdGhlIG5vZGUsIGFnYWluLi4uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBMW2ldLm9yZGVyID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBMO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgbm9kZXMgdGhhdCBjb3VsZCBhZmZlY3QgdGhpcyBvbmUgKGFuY2VzdG9ycykgYnkgY3Jhd2xpbmcgYWxsIHRoZSBpbnB1dHMgcmVjdXJzaXZlbHkuXG4gICAgICogSXQgZG9lc24ndCBpbmNsdWRlIHRoZSBub2RlIGl0c2VsZlxuICAgICAqIEBtZXRob2QgZ2V0QW5jZXN0b3JzXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IHdpdGggYWxsIHRoZSBMR3JhcGhOb2RlcyB0aGF0IGFmZmVjdCB0aGlzIG5vZGUsIGluIG9yZGVyIG9mIGV4ZWN1dGlvblxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0QW5jZXN0b3JzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgICAgIHZhciBwZW5kaW5nID0gW25vZGVdO1xuICAgICAgICB2YXIgdmlzaXRlZCA9IHt9O1xuXG4gICAgICAgIHdoaWxlIChwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbY3VycmVudC5pZF0gJiYgY3VycmVudCAhPSBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtjdXJyZW50LmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudC5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBjdXJyZW50LmdldElucHV0Tm9kZShpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgJiYgYW5jZXN0b3JzLmluZGV4T2YoaW5wdXQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW5jZXN0b3JzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIGV2ZXJ5IG5vZGUgaW4gYSBtb3JlIHJlYWRhYmxlIG1hbm5lclxuICAgICAqIEBtZXRob2QgYXJyYW5nZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuYXJyYW5nZSA9IGZ1bmN0aW9uKG1hcmdpbikge1xuICAgICAgICBtYXJnaW4gPSBtYXJnaW4gfHwgMTAwO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuY29tcHV0ZUV4ZWN1dGlvbk9yZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBjb2wgPSBub2RlLl9sZXZlbCB8fCAxO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5zW2NvbF0pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zW2NvbF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbHVtbnNbY29sXS5wdXNoKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBtYXJnaW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWF4X3NpemUgPSAxMDA7XG4gICAgICAgICAgICB2YXIgeSA9IG1hcmdpbiArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjb2x1bW5bal07XG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gPSB4O1xuICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdID0geTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zaXplWzBdID4gbWF4X3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4X3NpemUgPSBub2RlLnNpemVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkgKz0gbm9kZS5zaXplWzFdICsgbWFyZ2luICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCArPSBtYXhfc2l6ZSArIG1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aW1lIHRoZSBncmFwaCBoYXMgYmVlbiBydW5uaW5nIGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEBtZXRob2QgZ2V0VGltZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGUgZ3JhcGggaGFzIGJlZW4gcnVubmluZ1xuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWx0aW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSBhY2N1bXVsYXRlZCB1c2luZyB0aGUgZml4ZWR0aW1lX2xhcHNlIHZhci4gVGhpcyBpcyB1c2VkIGluIGNvbnRleHQgd2hlcmUgdGhlIHRpbWUgaW5jcmVtZW50cyBzaG91bGQgYmUgY29uc3RhbnRcbiAgICAgKiBAbWV0aG9kIGdldEZpeGVkVGltZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGUgZ3JhcGggaGFzIGJlZW4gcnVubmluZ1xuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRGaXhlZFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4ZWR0aW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0b29rIHRvIGNvbXB1dGUgdGhlIGxhdGVzdCBpdGVyYXRpb24uIFRha2UgaW50byBhY2NvdW50IHRoYXQgdGhpcyBudW1iZXIgY291bGQgYmUgbm90IGNvcnJlY3RcbiAgICAgKiBpZiB0aGUgbm9kZXMgYXJlIHVzaW5nIGdyYXBoaWNhbCBhY3Rpb25zXG4gICAgICogQG1ldGhvZCBnZXRFbGFwc2VkVGltZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIHRoZSBsYXN0IGN5Y2xlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldEVsYXBzZWRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWRfdGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gZXZlbnQgdG8gYWxsIHRoZSBub2RlcywgdXNlZnVsIHRvIHRyaWdnZXIgc3R1ZmZcbiAgICAgKiBAbWV0aG9kIHNlbmRFdmVudFRvQWxsTm9kZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZnVuY3Rpb24gdG8gYmUgY2FsbGVkKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBwYXJhbWV0ZXJzIGluIGFycmF5IGZvcm1hdFxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2VuZEV2ZW50VG9BbGxOb2RlcyA9IGZ1bmN0aW9uKGV2ZW50bmFtZSwgcGFyYW1zLCBtb2RlKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IExpdGVHcmFwaC5BTFdBWVM7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fbm9kZXNfaW5fb3JkZXIgPyB0aGlzLl9ub2Rlc19pbl9vcmRlciA6IHRoaXMuX25vZGVzO1xuICAgICAgICBpZiAoIW5vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaiA8IGw7ICsraikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tqXTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUuY29uc3RydWN0b3IgPT09IExpdGVHcmFwaC5TdWJncmFwaCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50bmFtZSAhPSBcIm9uRXhlY3V0ZVwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5tb2RlID09IG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZW5kRXZlbnRUb0FsbE5vZGVzKGV2ZW50bmFtZSwgcGFyYW1zLCBtb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbm9kZVtldmVudG5hbWVdIHx8IG5vZGUubW9kZSAhPSBtb2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlW2V2ZW50bmFtZV0oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHBhcmFtcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBub2RlW2V2ZW50bmFtZV0uYXBwbHkobm9kZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZVtldmVudG5hbWVdKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZW5kQWN0aW9uVG9DYW52YXMgPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5saXN0X29mX2dyYXBoY2FudmFzW2ldO1xuICAgICAgICAgICAgaWYgKGNbYWN0aW9uXSkge1xuICAgICAgICAgICAgICAgIGNbYWN0aW9uXS5hcHBseShjLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgbm9kZSBpbnN0YW5jZSB0byB0aGlzIGdyYXBoXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge0xHcmFwaE5vZGV9IG5vZGUgdGhlIGluc3RhbmNlIG9mIHRoZSBub2RlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5vZGUsIHNraXBfY29tcHV0ZV9vcmRlcikge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ3JvdXBzXG4gICAgICAgIGlmIChub2RlLmNvbnN0cnVjdG9yID09PSBMR3JhcGhHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgIG5vZGUuZ3JhcGggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ub2Rlc1xuICAgICAgICBpZiAobm9kZS5pZCAhPSAtMSAmJiB0aGlzLl9ub2Rlc19ieV9pZFtub2RlLmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJMaXRlR3JhcGg6IHRoZXJlIGlzIGFscmVhZHkgYSBub2RlIHdpdGggdGhpcyBJRCwgY2hhbmdpbmcgaXRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuaWQgPSArK3RoaXMubGFzdF9ub2RlX2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX25vZGVzLmxlbmd0aCA+PSBMaXRlR3JhcGguTUFYX05VTUJFUl9PRl9OT0RFUykge1xuICAgICAgICAgICAgdGhyb3cgXCJMaXRlR3JhcGg6IG1heCBudW1iZXIgb2Ygbm9kZXMgaW4gYSBncmFwaCByZWFjaGVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2dpdmUgaGltIGFuIGlkXG4gICAgICAgIGlmIChub2RlLmlkID09IG51bGwgfHwgbm9kZS5pZCA9PSAtMSkge1xuICAgICAgICAgICAgbm9kZS5pZCA9ICsrdGhpcy5sYXN0X25vZGVfaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0X25vZGVfaWQgPCBub2RlLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3Rfbm9kZV9pZCA9IG5vZGUuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmdyYXBoID0gdGhpcztcbiAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuXG4gICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuX25vZGVzX2J5X2lkW25vZGUuaWRdID0gbm9kZTtcblxuICAgICAgICBpZiAobm9kZS5vbkFkZGVkKSB7XG4gICAgICAgICAgICBub2RlLm9uQWRkZWQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb25maWcuYWxpZ25fdG9fZ3JpZCkge1xuICAgICAgICAgICAgbm9kZS5hbGlnblRvR3JpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwX2NvbXB1dGVfb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXhlY3V0aW9uT3JkZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uTm9kZUFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9kZUFkZGVkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2UoKTtcblxuICAgICAgICByZXR1cm4gbm9kZTsgLy90byBjaGFpbiBhY3Rpb25zXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgKiBAcGFyYW0ge0xHcmFwaE5vZGV9IG5vZGUgdGhlIGluc3RhbmNlIG9mIHRoZSBub2RlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IExpdGVHcmFwaC5MR3JhcGhHcm91cCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ3JvdXBzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZ3JhcGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuICAgICAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vbm90IGZvdW5kXG5cbiAgICAgICAgaWYgKG5vZGUuaWdub3JlX3JlbW92ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vY2Fubm90IGJlIHJlbW92ZWRcblxuXHRcdHRoaXMuYmVmb3JlQ2hhbmdlKCk7IC8vc3VyZT9cblxuICAgICAgICAvL2Rpc2Nvbm5lY3QgaW5wdXRzXG4gICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbm9kZS5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNsb3QubGluayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vZGlzY29ubmVjdCBvdXRwdXRzXG4gICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNsb3QubGlua3MgIT0gbnVsbCAmJiBzbG90LmxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3RPdXRwdXQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9ub2RlLmlkID0gLTE7IC8vd2h5P1xuXG4gICAgICAgIC8vY2FsbGJhY2tcbiAgICAgICAgaWYgKG5vZGUub25SZW1vdmVkKSB7XG4gICAgICAgICAgICBub2RlLm9uUmVtb3ZlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5ncmFwaCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICAvL3JlbW92ZSBmcm9tIGNhbnZhcyByZW5kZXJcbiAgICAgICAgaWYgKHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5saXN0X29mX2dyYXBoY2FudmFzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjYW52YXMuc2VsZWN0ZWRfbm9kZXNbbm9kZS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhbnZhcy5zZWxlY3RlZF9ub2Rlc1tub2RlLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5ub2RlX2RyYWdnZWQgPT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMubm9kZV9kcmFnZ2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbW92ZSBmcm9tIGNvbnRhaW5lcnNcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuX25vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGlmIChwb3MgIT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlLmlkXTtcblxuICAgICAgICBpZiAodGhpcy5vbk5vZGVSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9kZVJlbW92ZWQobm9kZSk7XG4gICAgICAgIH1cblxuXHRcdC8vY2xvc2UgcGFuZWxzXG5cdFx0dGhpcy5zZW5kQWN0aW9uVG9DYW52YXMoXCJjaGVja1BhbmVsc1wiKTtcblxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuXHRcdHRoaXMuYWZ0ZXJDaGFuZ2UoKTsgLy9zdXJlP1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRXhlY3V0aW9uT3JkZXIoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5vZGUgYnkgaXRzIGlkLlxuICAgICAqIEBtZXRob2QgZ2V0Tm9kZUJ5SWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzX2J5X2lkW2lkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBtYXRjaGVzIGEgY2xhc3NcbiAgICAgKiBAbWV0aG9kIGZpbmROb2Rlc0J5Q2xhc3NcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBjbGFzc09iamVjdCB0aGUgY2xhc3MgaXRzZWxmIChub3QgYW4gc3RyaW5nKVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgd2l0aCBhbGwgdGhlIG5vZGVzIG9mIHRoaXMgdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZmluZE5vZGVzQnlDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzT2JqZWN0LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS5jb25zdHJ1Y3RvciA9PT0gY2xhc3NPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9ub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBtYXRjaGVzIGEgdHlwZVxuICAgICAqIEBtZXRob2QgZmluZE5vZGVzQnlUeXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgd2l0aCBhbGwgdGhlIG5vZGVzIG9mIHRoaXMgdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZmluZE5vZGVzQnlUeXBlID0gZnVuY3Rpb24odHlwZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX25vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGVzW2ldLnR5cGUudG9Mb3dlckNhc2UoKSA9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IG5vZGUgdGhhdCBtYXRjaGVzIGEgbmFtZSBpbiBpdHMgdGl0bGVcbiAgICAgKiBAbWV0aG9kIGZpbmROb2RlQnlUaXRsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBub2RlIHRvIHNlYXJjaFxuICAgICAqIEByZXR1cm4ge05vZGV9IHRoZSBub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmZpbmROb2RlQnlUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZXNbaV0udGl0bGUgPT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgbWF0Y2hlcyBhIG5hbWVcbiAgICAgKiBAbWV0aG9kIGZpbmROb2Rlc0J5VGl0bGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgbm9kZSB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlcyB3aXRoIHRoaXMgbmFtZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZmluZE5vZGVzQnlUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS50aXRsZSA9PSB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AtbW9zdCBub2RlIGluIHRoaXMgcG9zaXRpb24gb2YgdGhlIGNhbnZhc1xuICAgICAqIEBtZXRob2QgZ2V0Tm9kZU9uUG9zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSBpbiBjYW52YXMgc3BhY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIGluIGNhbnZhcyBzcGFjZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzX2xpc3QgYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlcyB0byBzZWFyY2ggZnJvbSwgYnkgZGVmYXVsdCBpcyBhbGwgdGhlIG5vZGVzIGluIHRoZSBncmFwaFxuICAgICAqIEByZXR1cm4ge0xHcmFwaE5vZGV9IHRoZSBub2RlIGF0IHRoaXMgcG9zaXRpb24gb3IgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZU9uUG9zID0gZnVuY3Rpb24oeCwgeSwgbm9kZXNfbGlzdCwgbWFyZ2luKSB7XG4gICAgICAgIG5vZGVzX2xpc3QgPSBub2Rlc19saXN0IHx8IHRoaXMuX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gbm9kZXNfbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG4gPSBub2Rlc19saXN0W2ldO1xuICAgICAgICAgICAgaWYgKG4uaXNQb2ludEluc2lkZSh4LCB5LCBtYXJnaW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcC1tb3N0IGdyb3VwIGluIHRoYXQgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIGdldEdyb3VwT25Qb3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIGluIGNhbnZhcyBzcGFjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGUgaW4gY2FudmFzIHNwYWNlXG4gICAgICogQHJldHVybiB7TEdyYXBoR3JvdXB9IHRoZSBncm91cCBvciBudWxsXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRHcm91cE9uUG9zID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZ3JvdXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuX2dyb3Vwc1tpXTtcbiAgICAgICAgICAgIGlmIChnLmlzUG9pbnRJbnNpZGUoeCwgeSwgMiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIG5vZGUgdHlwZSBtYXRjaGVzIHRoZSBub2RlIHR5cGUgcmVnaXN0ZXJlZCwgdXNlZCB3aGVuIHJlcGxhY2luZyBhIG5vZGV0eXBlIGJ5IGEgbmV3ZXIgdmVyc2lvbiBkdXJpbmcgZXhlY3V0aW9uXG4gICAgICogdGhpcyByZXBsYWNlcyB0aGUgb25lcyB1c2luZyB0aGUgb2xkIHZlcnNpb24gd2l0aCB0aGUgbmV3IHZlcnNpb25cbiAgICAgKiBAbWV0aG9kIGNoZWNrTm9kZVR5cGVzXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5jaGVja05vZGVUeXBlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIGN0b3IgPSBMaXRlR3JhcGgucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW25vZGUudHlwZV07XG4gICAgICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PSBjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vZGUgYmVpbmcgcmVwbGFjZWQgYnkgbmV3ZXIgdmVyc2lvbjogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgICAgdmFyIG5ld25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1tpXSA9IG5ld25vZGU7XG4gICAgICAgICAgICBuZXdub2RlLmNvbmZpZ3VyZShub2RlLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIG5ld25vZGUuZ3JhcGggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNfYnlfaWRbbmV3bm9kZS5pZF0gPSBuZXdub2RlO1xuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgbmV3bm9kZS5pbnB1dHMgPSBub2RlLmlucHV0cy5jb25jYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBuZXdub2RlLm91dHB1dHMgPSBub2RlLm91dHB1dHMuY29uY2F0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVFeGVjdXRpb25PcmRlcigpO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqIEdMT0JBTFMgKioqKioqKioqKioqKioqKipcblxuICAgIExHcmFwaC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIHRoaXMuX2lucHV0X25vZGVzID0gdGhpcy5maW5kTm9kZXNCeUNsYXNzKFxuICAgICAgICAgICAgTGl0ZUdyYXBoLkdyYXBoSW5wdXQsXG4gICAgICAgICAgICB0aGlzLl9pbnB1dF9ub2Rlc1xuICAgICAgICApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2lucHV0X25vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2lucHV0X25vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5uYW1lICE9IGFjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5vbkFjdGlvbihhY3Rpb24sIHBhcmFtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcbiAgICAgICAgaWYgKHRoaXMub25UcmlnZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLm9uVHJpZ2dlcihhY3Rpb24sIHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoaXMgZ3JhcGggaXQgaGFzIGEgZ2xvYmFsIGdyYXBoIGlucHV0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBtZXRob2QgYWRkR2xvYmFsSW5wdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBbb3B0aW9uYWxdXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hZGRJbnB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW25hbWVdO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vYWxyZWFkeSBleGlzdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblx0XHR0aGlzLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICB0aGlzLmlucHV0c1tuYW1lXSA9IHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblx0XHR0aGlzLmFmdGVyQ2hhbmdlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub25JbnB1dEFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRBZGRlZChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSBkYXRhIHRvIHRoZSBnbG9iYWwgZ3JhcGggaW5wdXRcbiAgICAgKiBAbWV0aG9kIHNldEdsb2JhbElucHV0RGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXRJbnB1dERhdGEgPSBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW25hbWVdO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQudmFsdWUgPSBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCBnZXRJbnB1dERhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4geyp9IHRoZSBkYXRhXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRJbnB1dERhdGEgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW25hbWVdO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIG5hbWUgb2YgYSBnbG9iYWwgZ3JhcGggaW5wdXRcbiAgICAgKiBAbWV0aG9kIHJlbmFtZUlucHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZF9uYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld19uYW1lXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5yZW5hbWVJbnB1dCA9IGZ1bmN0aW9uKG9sZF9uYW1lLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IG9sZF9uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW29sZF9uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzW25hbWVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwidGhlcmUgaXMgYWxyZWFkeSBvbmUgaW5wdXQgd2l0aCB0aGF0IG5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0c1tuYW1lXSA9IHRoaXMuaW5wdXRzW29sZF9uYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5wdXRzW29sZF9uYW1lXTtcbiAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRSZW5hbWVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRSZW5hbWVkKG9sZF9uYW1lLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIGEgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCBjaGFuZ2VJbnB1dFR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5jaGFuZ2VJbnB1dFR5cGUgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzW25hbWVdLnR5cGUgJiZcbiAgICAgICAgICAgIFN0cmluZyh0aGlzLmlucHV0c1tuYW1lXS50eXBlKS50b0xvd2VyQ2FzZSgpID09XG4gICAgICAgICAgICAgICAgU3RyaW5nKHR5cGUpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0c1tuYW1lXS50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuICAgICAgICBpZiAodGhpcy5vbklucHV0VHlwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dFR5cGVDaGFuZ2VkKG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBnbG9iYWwgZ3JhcGggaW5wdXRcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUlucHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUucmVtb3ZlSW5wdXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRSZW1vdmVkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZ2xvYmFsIGdyYXBoIG91dHB1dFxuICAgICAqIEBtZXRob2QgYWRkT3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmFkZE91dHB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0c1tuYW1lXSA9IHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbk91dHB1dEFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0QWRkZWQobmFtZSwgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgZGF0YSB0byB0aGUgZ2xvYmFsIG91dHB1dFxuICAgICAqIEBtZXRob2Qgc2V0T3V0cHV0RGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXRPdXRwdXREYXRhID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIGdsb2JhbCBncmFwaCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIGdldE91dHB1dERhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4geyp9IHRoZSBkYXRhXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRPdXRwdXREYXRhID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW25hbWVdO1xuICAgICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC52YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuYW1lcyBhIGdsb2JhbCBncmFwaCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIHJlbmFtZU91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdfbmFtZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUucmVuYW1lT3V0cHV0ID0gZnVuY3Rpb24ob2xkX25hbWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHNbb2xkX25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzW25hbWVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwidGhlcmUgaXMgYWxyZWFkeSBvbmUgb3V0cHV0IHdpdGggdGhhdCBuYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRwdXRzW25hbWVdID0gdGhpcy5vdXRwdXRzW29sZF9uYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMub3V0cHV0c1tvbGRfbmFtZV07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbk91dHB1dFJlbmFtZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25PdXRwdXRSZW5hbWVkKG9sZF9uYW1lLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIGEgZ2xvYmFsIGdyYXBoIG91dHB1dFxuICAgICAqIEBtZXRob2QgY2hhbmdlT3V0cHV0VHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmNoYW5nZU91dHB1dFR5cGUgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbbmFtZV0udHlwZSAmJlxuICAgICAgICAgICAgU3RyaW5nKHRoaXMub3V0cHV0c1tuYW1lXS50eXBlKS50b0xvd2VyQ2FzZSgpID09XG4gICAgICAgICAgICAgICAgU3RyaW5nKHR5cGUpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm91dHB1dHNbbmFtZV0udHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRUeXBlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dFR5cGVDaGFuZ2VkKG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBnbG9iYWwgZ3JhcGggb3V0cHV0XG4gICAgICogQG1ldGhvZCByZW1vdmVPdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUucmVtb3ZlT3V0cHV0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dHNbbmFtZV07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbk91dHB1dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25PdXRwdXRSZW1vdmVkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnRyaWdnZXJJbnB1dCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuZmluZE5vZGVzQnlUaXRsZShuYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbm9kZXNbaV0ub25UcmlnZ2VyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnNldENhbGxiYWNrID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmZpbmROb2Rlc0J5VGl0bGUobmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5vZGVzW2ldLnNldFRyaWdnZXIoZnVuYyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8vdXNlZCBmb3IgdW5kbywgY2FsbGVkIGJlZm9yZSBhbnkgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIGdyYXBoXG4gICAgTEdyYXBoLnByb3RvdHlwZS5iZWZvcmVDaGFuZ2UgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLm9uQmVmb3JlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmVmb3JlQ2hhbmdlKHRoaXMsaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kQWN0aW9uVG9DYW52YXMoXCJvbkJlZm9yZUNoYW5nZVwiLCB0aGlzKTtcbiAgICB9O1xuXG5cdC8vdXNlZCB0byByZXNlbmQgYWN0aW9ucywgY2FsbGVkIGFmdGVyIGFueSBjaGFuZ2UgaXMgbWFkZSB0byB0aGUgZ3JhcGhcbiAgICBMR3JhcGgucHJvdG90eXBlLmFmdGVyQ2hhbmdlID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgICBpZiAodGhpcy5vbkFmdGVyQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJDaGFuZ2UodGhpcyxpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcIm9uQWZ0ZXJDaGFuZ2VcIiwgdGhpcyk7XG4gICAgfTtcblxuICAgIExHcmFwaC5wcm90b3R5cGUuY29ubmVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIGxpbmtfaW5mbykge1xuICAgICAgICB0aGlzLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25DaGFuZ2Uobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcIm9uQ29ubmVjdGlvbkNoYW5nZVwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBpZiB0aGUgZ3JhcGggaXMgaW4gbGl2ZSBtb2RlXG4gICAgICogQG1ldGhvZCBpc0xpdmVcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuaXNMaXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0X29mX2dyYXBoY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXNbaV07XG4gICAgICAgICAgICBpZiAoYy5saXZlX21vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNsZWFycyB0aGUgdHJpZ2dlcmVkIHNsb3QgYW5pbWF0aW9uIGluIGFsbCBsaW5rcyAoc3RvcCB2aXN1YWwgYW5pbWF0aW9uKVxuICAgICAqIEBtZXRob2QgY2xlYXJUcmlnZ2VyZWRTbG90c1xuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY2xlYXJUcmlnZ2VyZWRTbG90cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMubGlua3MpIHtcbiAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmxpbmtzW2ldO1xuICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5rX2luZm8uX2xhc3RfdGltZSkge1xuICAgICAgICAgICAgICAgIGxpbmtfaW5mby5fbGFzdF90aW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiBDYWxsZWQgd2hlbiBzb21ldGhpbmcgdmlzdWFsbHkgY2hhbmdlZCAobm90IHRoZSBncmFwaCEpICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHcmFwaCBjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwic2V0RGlydHlcIiwgW3RydWUsIHRydWVdKTtcbiAgICAgICAgaWYgKHRoaXMub25fY2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uX2NoYW5nZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnNldERpcnR5Q2FudmFzID0gZnVuY3Rpb24oZmcsIGJnKSB7XG4gICAgICAgIHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwic2V0RGlydHlcIiwgW2ZnLCBiZ10pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGxpbmtcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUxpbmtcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGlua19pZFxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUucmVtb3ZlTGluayA9IGZ1bmN0aW9uKGxpbmtfaWQpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5SWQobGluay50YXJnZXRfaWQpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0SW5wdXQobGluay50YXJnZXRfc2xvdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9zYXZlIGFuZCByZWNvdmVyIGFwcCBzdGF0ZSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvIGFib3V0IHRoaXMgZ3JhcGgsIGl0IGNhbiBiZSBzZXJpYWxpemVkXG4gICAgICogQG1ldGhvZCBzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHZhbHVlIG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGVzX2luZm8gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5vZGVzX2luZm8ucHVzaCh0aGlzLl9ub2Rlc1tpXS5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3BhY2sgbGluayBpbmZvIGludG8gYSBub24tdmVyYm9zZSBmb3JtYXRcbiAgICAgICAgdmFyIGxpbmtzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5saW5rcykge1xuICAgICAgICAgICAgLy9saW5rcyBpcyBhbiBPQkpFQ1RcbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rc1tpXTtcbiAgICAgICAgICAgIGlmICghbGluay5zZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvL3dlaXJkIGJ1ZyBJIGhhdmVudCBzb2x2ZWQgeWV0XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcIndlaXJkIExMaW5rIGJ1ZywgbGluayBpbmZvIGlzIG5vdCBhIExMaW5rIGJ1dCBhIHJlZ3VsYXIgb2JqZWN0XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rMiA9IG5ldyBMTGluaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gbGluaykgeyBcbiAgICAgICAgICAgICAgICAgICAgbGluazJbal0gPSBsaW5rW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtzW2ldID0gbGluazI7XG4gICAgICAgICAgICAgICAgbGluayA9IGxpbmsyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmsuc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3Vwc19pbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBncm91cHNfaW5mby5wdXNoKHRoaXMuX2dyb3Vwc1tpXS5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGxhc3Rfbm9kZV9pZDogdGhpcy5sYXN0X25vZGVfaWQsXG4gICAgICAgICAgICBsYXN0X2xpbmtfaWQ6IHRoaXMubGFzdF9saW5rX2lkLFxuICAgICAgICAgICAgbm9kZXM6IG5vZGVzX2luZm8sXG4gICAgICAgICAgICBsaW5rczogbGlua3MsXG4gICAgICAgICAgICBncm91cHM6IGdyb3Vwc19pbmZvLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcblx0XHRcdGV4dHJhOiB0aGlzLmV4dHJhLFxuICAgICAgICAgICAgdmVyc2lvbjogTGl0ZUdyYXBoLlZFUlNJT05cbiAgICAgICAgfTtcblxuXHRcdGlmKHRoaXMub25TZXJpYWxpemUpXG5cdFx0XHR0aGlzLm9uU2VyaWFsaXplKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgYSBncmFwaCBmcm9tIGEgSlNPTiBzdHJpbmdcbiAgICAgKiBAbWV0aG9kIGNvbmZpZ3VyZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgY29uZmlndXJlIGEgZ3JhcGggZnJvbSBhIEpTT04gc3RyaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5zIGlmIHRoZXJlIHdhcyBhbnkgZXJyb3IgcGFyc2luZ1xuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24oZGF0YSwga2VlcF9vbGQpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtlZXBfb2xkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZXMgPSBkYXRhLm5vZGVzO1xuXG4gICAgICAgIC8vZGVjb2RlIGxpbmtzIGluZm8gKHRoZXkgYXJlIHZlcnkgdmVyYm9zZSlcbiAgICAgICAgaWYgKGRhdGEubGlua3MgJiYgZGF0YS5saW5rcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxpbmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfZGF0YSA9IGRhdGEubGlua3NbaV07XG5cdFx0XHRcdGlmKCFsaW5rX2RhdGEpIC8vd2VpcmQgYnVnXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJzZXJpYWxpemVkIGdyYXBoIGxpbmsgZGF0YSBjb250YWlucyBlcnJvcnMsIHNraXBwaW5nLlwiKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gbmV3IExMaW5rKCk7XG4gICAgICAgICAgICAgICAgbGluay5jb25maWd1cmUobGlua19kYXRhKTtcbiAgICAgICAgICAgICAgICBsaW5rc1tsaW5rLmlkXSA9IGxpbms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmxpbmtzID0gbGlua3M7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvcHkgYWxsIHN0b3JlZCBmaWVsZHNcbiAgICAgICAgZm9yICh2YXIgaSBpbiBkYXRhKSB7XG5cdFx0XHRpZihpID09IFwibm9kZXNcIiB8fCBpID09IFwiZ3JvdXBzXCIgKSAvL2xpbmtzIG11c3QgYmUgYWNjZXB0ZWRcblx0XHRcdFx0Y29udGludWU7XG4gICAgICAgICAgICB0aGlzW2ldID0gZGF0YVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlcnJvciA9IGZhbHNlO1xuXG4gICAgICAgIC8vY3JlYXRlIG5vZGVzXG4gICAgICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbl9pbmZvID0gbm9kZXNbaV07IC8vc3RvcmVkIGluZm9cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKG5faW5mby50eXBlLCBuX2luZm8udGl0bGUpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vZGUgbm90IGZvdW5kIG9yIGhhcyBlcnJvcnM6IFwiICsgbl9pbmZvLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2luIGNhc2Ugb2YgZXJyb3Igd2UgY3JlYXRlIGEgcmVwbGFjZW1lbnQgbm9kZSB0byBhdm9pZCBsb3NpbmcgaW5mb1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV3IExHcmFwaE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sYXN0X3NlcmlhbGl6YXRpb24gPSBuX2luZm87XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaGFzX2Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLmlkID0gbl9pbmZvLmlkOyAvL2lkIGl0IG9yIGl0IHdpbGwgY3JlYXRlIGEgbmV3IGlkXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobm9kZSwgdHJ1ZSk7IC8vYWRkIGJlZm9yZSBjb25maWd1cmUsIG90aGVyd2lzZSBjb25maWd1cmUgY2Fubm90IGNyZWF0ZSBsaW5rc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2NvbmZpZ3VyZSBub2RlcyBhZnRlcndhcmRzIHNvIHRoZXkgY2FuIHJlYWNoIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5faW5mbyA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlQnlJZChuX2luZm8uaWQpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY29uZmlndXJlKG5faW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9ncm91cHNcbiAgICAgICAgdGhpcy5fZ3JvdXBzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChkYXRhLmdyb3Vwcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBMaXRlR3JhcGguTEdyYXBoR3JvdXAoKTtcbiAgICAgICAgICAgICAgICBncm91cC5jb25maWd1cmUoZGF0YS5ncm91cHNbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRXhlY3V0aW9uT3JkZXIoKTtcblxuXHRcdHRoaXMuZXh0cmEgPSBkYXRhLmV4dHJhIHx8IHt9O1xuXG5cdFx0aWYodGhpcy5vbkNvbmZpZ3VyZSlcblx0XHRcdHRoaXMub25Db25maWd1cmUoZGF0YSk7XG5cbiAgICAgICAgdGhpcy5fdmVyc2lvbisrO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcblxuICAgIExHcmFwaC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly9mcm9tIGZpbGVcblx0XHRpZih1cmwuY29uc3RydWN0b3IgPT09IEZpbGUgfHwgdXJsLmNvbnN0cnVjdG9yID09PSBCbG9iKVxuXHRcdHtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0cmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG5cdFx0XHRcdHRoYXQuY29uZmlndXJlKGRhdGEpO1xuXHRcdFx0XHRpZihjYWxsYmFjaylcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJlYWRlci5yZWFkQXNUZXh0KHVybCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9pcyBhIHN0cmluZywgdGhlbiBhbiBVUkxcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXEub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgICAgICByZXEuc2VuZChudWxsKTtcbiAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uKG9FdmVudCkge1xuICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGdyYXBoOlwiLCByZXEuc3RhdHVzLCByZXEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZSggcmVxLnJlc3BvbnNlICk7XG4gICAgICAgICAgICB0aGF0LmNvbmZpZ3VyZShkYXRhKTtcblx0XHRcdGlmKGNhbGxiYWNrKVxuXHRcdFx0XHRjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgZ3JhcGg6XCIsIGVycik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIExHcmFwaC5wcm90b3R5cGUub25Ob2RlVHJhY2UgPSBmdW5jdGlvbihub2RlLCBtc2csIGNvbG9yKSB7XG4gICAgICAgIC8vVE9ET1xuICAgIH07XG5cbiAgICAvL3RoaXMgaXMgdGhlIGNsYXNzIGluIGNoYXJnZSBvZiBzdG9yaW5nIGxpbmsgaW5mb3JtYXRpb25cbiAgICBmdW5jdGlvbiBMTGluayhpZCwgdHlwZSwgb3JpZ2luX2lkLCBvcmlnaW5fc2xvdCwgdGFyZ2V0X2lkLCB0YXJnZXRfc2xvdCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMub3JpZ2luX2lkID0gb3JpZ2luX2lkO1xuICAgICAgICB0aGlzLm9yaWdpbl9zbG90ID0gb3JpZ2luX3Nsb3Q7XG4gICAgICAgIHRoaXMudGFyZ2V0X2lkID0gdGFyZ2V0X2lkO1xuICAgICAgICB0aGlzLnRhcmdldF9zbG90ID0gdGFyZ2V0X3Nsb3Q7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BvcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7IC8vY2VudGVyXG4gICAgfVxuXG4gICAgTExpbmsucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKG8uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gb1swXTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX2lkID0gb1sxXTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX3Nsb3QgPSBvWzJdO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRfaWQgPSBvWzNdO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRfc2xvdCA9IG9bNF07XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBvWzVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG8uaWQ7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBvLnR5cGU7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9pZCA9IG8ub3JpZ2luX2lkO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5fc2xvdCA9IG8ub3JpZ2luX3Nsb3Q7XG4gICAgICAgICAgICB0aGlzLnRhcmdldF9pZCA9IG8udGFyZ2V0X2lkO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRfc2xvdCA9IG8udGFyZ2V0X3Nsb3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTExpbmsucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX2lkLFxuICAgICAgICAgICAgdGhpcy5vcmlnaW5fc2xvdCxcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X2lkLFxuICAgICAgICAgICAgdGhpcy50YXJnZXRfc2xvdCxcbiAgICAgICAgICAgIHRoaXMudHlwZVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGguTExpbmsgPSBMTGluaztcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAgIE5vZGUgQ0xBU1MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLypcblx0dGl0bGU6IHN0cmluZ1xuXHRwb3M6IFt4LHldXG5cdHNpemU6IFt4LHldXG5cblx0aW5wdXR8b3V0cHV0OiBldmVyeSBjb25uZWN0aW9uXG5cdFx0KyAgeyBuYW1lOnN0cmluZywgdHlwZTpzdHJpbmcsIHBvczogW3gseV09T3B0aW9uYWwsIGRpcmVjdGlvbjogXCJpbnB1dFwifFwib3V0cHV0XCIsIGxpbmtzOiBBcnJheSB9KTtcblxuXHRnZW5lcmFsIHByb3BlcnRpZXM6XG5cdFx0KyBjbGlwX2FyZWE6IGlmIHlvdSByZW5kZXIgb3V0c2lkZSB0aGUgbm9kZSwgaXQgd2lsbCBiZSBjbGlwcGVkXG5cdFx0KyB1bnNhZmVfZXhlY3V0aW9uOiBub3QgYWxsb3dlZCBmb3Igc2FmZSBleGVjdXRpb25cblx0XHQrIHNraXBfcmVwZWF0ZWRfb3V0cHV0czogd2hlbiBhZGRpbmcgbmV3IG91dHB1dHMsIGl0IHdvbnQgc2hvdyBpZiB0aGVyZSBpcyBvbmUgYWxyZWFkeSBjb25uZWN0ZWRcblx0XHQrIHJlc2l6YWJsZTogaWYgc2V0IHRvIGZhbHNlIGl0IHdvbnQgYmUgcmVzaXphYmxlIHdpdGggdGhlIG1vdXNlXG5cdFx0KyBob3Jpem9udGFsOiBzbG90cyBhcmUgZGlzdHJpYnV0ZWQgaG9yaXpvbnRhbGx5XG5cdFx0KyB3aWRnZXRzX3N0YXJ0X3k6IHdpZGdldHMgc3RhcnQgYXQgeSBkaXN0YW5jZSBmcm9tIHRoZSB0b3Agb2YgdGhlIG5vZGVcblx0XG5cdGZsYWdzIG9iamVjdDpcblx0XHQrIGNvbGxhcHNlZDogaWYgaXQgaXMgY29sbGFwc2VkXG5cblx0c3VwcG9ydGVkIGNhbGxiYWNrczpcblx0XHQrIG9uQWRkZWQ6IHdoZW4gYWRkZWQgdG8gZ3JhcGggKHdhcm5pbmc6IHRoaXMgaXMgY2FsbGVkIEJFRk9SRSB0aGUgbm9kZSBpcyBjb25maWd1cmVkIHdoZW4gbG9hZGluZylcblx0XHQrIG9uUmVtb3ZlZDogd2hlbiByZW1vdmVkIGZyb20gZ3JhcGhcblx0XHQrIG9uU3RhcnQ6XHR3aGVuIHRoZSBncmFwaCBzdGFydHMgcGxheWluZ1xuXHRcdCsgb25TdG9wOlx0d2hlbiB0aGUgZ3JhcGggc3RvcHMgcGxheWluZ1xuXHRcdCsgb25EcmF3Rm9yZWdyb3VuZDogcmVuZGVyIHRoZSBpbnNpZGUgd2lkZ2V0cyBpbnNpZGUgdGhlIG5vZGVcblx0XHQrIG9uRHJhd0JhY2tncm91bmQ6IHJlbmRlciB0aGUgYmFja2dyb3VuZCBhcmVhIGluc2lkZSB0aGUgbm9kZSAob25seSBpbiBlZGl0IG1vZGUpXG5cdFx0KyBvbk1vdXNlRG93blxuXHRcdCsgb25Nb3VzZU1vdmVcblx0XHQrIG9uTW91c2VVcFxuXHRcdCsgb25Nb3VzZUVudGVyXG5cdFx0KyBvbk1vdXNlTGVhdmVcblx0XHQrIG9uRXhlY3V0ZTogZXhlY3V0ZSB0aGUgbm9kZVxuXHRcdCsgb25Qcm9wZXJ0eUNoYW5nZWQ6IHdoZW4gYSBwcm9wZXJ0eSBpcyBjaGFuZ2VkIGluIHRoZSBwYW5lbCAocmV0dXJuIHRydWUgdG8gc2tpcCBkZWZhdWx0IGJlaGF2aW91cilcblx0XHQrIG9uR2V0SW5wdXRzOiByZXR1cm5zIGFuIGFycmF5IG9mIHBvc3NpYmxlIGlucHV0c1xuXHRcdCsgb25HZXRPdXRwdXRzOiByZXR1cm5zIGFuIGFycmF5IG9mIHBvc3NpYmxlIG91dHB1dHNcblx0XHQrIG9uQm91bmRpbmc6IGluIGNhc2UgdGhpcyBub2RlIGhhcyBhIGJpZ2dlciBib3VuZGluZyB0aGFuIHRoZSBub2RlIGl0c2VsZiAodGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBib3VuZGluZyBhcyBbeCx5LHcsaF0pXG5cdFx0KyBvbkRibENsaWNrOiBkb3VibGUgY2xpY2tlZCBpbiB0aGUgbm9kZVxuXHRcdCsgb25JbnB1dERibENsaWNrOiBpbnB1dCBzbG90IGRvdWJsZSBjbGlja2VkIChjYW4gYmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhIG5vZGUgY29ubmVjdGVkKVxuXHRcdCsgb25PdXRwdXREYmxDbGljazogb3V0cHV0IHNsb3QgZG91YmxlIGNsaWNrZWQgKGNhbiBiZSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgY3JlYXRlIGEgbm9kZSBjb25uZWN0ZWQpXG5cdFx0KyBvbkNvbmZpZ3VyZTogY2FsbGVkIGFmdGVyIHRoZSBub2RlIGhhcyBiZWVuIGNvbmZpZ3VyZWRcblx0XHQrIG9uU2VyaWFsaXplOiB0byBhZGQgZXh0cmEgaW5mbyB3aGVuIHNlcmlhbGl6aW5nICh0aGUgY2FsbGJhY2sgcmVjZWl2ZXMgdGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSBmaWxsZWQgd2l0aCB0aGUgZGF0YSlcblx0XHQrIG9uU2VsZWN0ZWRcblx0XHQrIG9uRGVzZWxlY3RlZFxuXHRcdCsgb25Ecm9wSXRlbSA6IERPTSBpdGVtIGRyb3BwZWQgb3ZlciB0aGUgbm9kZVxuXHRcdCsgb25Ecm9wRmlsZSA6IGZpbGUgZHJvcHBlZCBvdmVyIHRoZSBub2RlXG5cdFx0KyBvbkNvbm5lY3RJbnB1dCA6IGlmIHJldHVybnMgZmFsc2UgdGhlIGluY29taW5nIGNvbm5lY3Rpb24gd2lsbCBiZSBjYW5jZWxlZFxuXHRcdCsgb25Db25uZWN0aW9uc0NoYW5nZSA6IGEgY29ubmVjdGlvbiBjaGFuZ2VkIChuZXcgb25lIG9yIHJlbW92ZWQpIChMaXRlR3JhcGguSU5QVVQgb3IgTGl0ZUdyYXBoLk9VVFBVVCwgc2xvdCwgdHJ1ZSBpZiBjb25uZWN0ZWQsIGxpbmtfaW5mbywgaW5wdXRfaW5mbyApXG5cdFx0KyBvbkFjdGlvbjogYWN0aW9uIHNsb3QgdHJpZ2dlcmVkXG5cdFx0KyBnZXRFeHRyYU1lbnVPcHRpb25zOiB0byBhZGQgb3B0aW9uIHRvIGNvbnRleHQgbWVudVxuKi9cblxuICAgIC8qKlxuICAgICAqIEJhc2UgQ2xhc3MgZm9yIGFsbCB0aGUgbm9kZSB0eXBlIGNsYXNzZXNcbiAgICAgKiBAY2xhc3MgTEdyYXBoTm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSBmb3IgdGhlIG5vZGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExHcmFwaE5vZGUodGl0bGUpIHtcbiAgICAgICAgdGhpcy5fY3Rvcih0aXRsZSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsLkxHcmFwaE5vZGUgPSBMaXRlR3JhcGguTEdyYXBoTm9kZSA9IExHcmFwaE5vZGU7XG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5fY3RvciA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZSB8fCBcIlVubmFtZWRcIjtcbiAgICAgICAgdGhpcy5zaXplID0gW0xpdGVHcmFwaC5OT0RFX1dJRFRILCA2MF07XG4gICAgICAgIHRoaXMuZ3JhcGggPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IG5ldyBGbG9hdDMyQXJyYXkoMTAsIDEwKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb3NcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2IHx8IHYubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc1swXSA9IHZbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zWzFdID0gdlsxXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmlkID0gLTE7IC8vbm90IGtub3cgdGlsbCBub3QgYWRkZWRcbiAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcblxuICAgICAgICAvL2lucHV0cyBhdmFpbGFibGU6IGFycmF5IG9mIGlucHV0c1xuICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vbG9jYWwgZGF0YVxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTsgLy9mb3IgdGhlIHZhbHVlc1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNfaW5mbyA9IFtdOyAvL2ZvciB0aGUgaW5mb1xuXG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29uZmlndXJlIGEgbm9kZSBmcm9tIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIGluZm9cbiAgICAgKiBAbWV0aG9kIGNvbmZpZ3VyZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqIGluIGluZm8pIHtcbiAgICAgICAgICAgIGlmIChqID09IFwicHJvcGVydGllc1wiKSB7XG4gICAgICAgICAgICAgICAgLy9pIGRvbid0IHdhbnQgdG8gY2xvbmUgcHJvcGVydGllcywgSSB3YW50IHRvIHJldXNlIHRoZSBvbGQgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBpbmZvLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW2tdID0gaW5mby5wcm9wZXJ0aWVzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vblByb3BlcnR5Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByb3BlcnR5Q2hhbmdlZCggaywgaW5mby5wcm9wZXJ0aWVzW2tdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmZvW2pdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluZm9bal0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIC8vb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbal0gJiYgdGhpc1tqXS5jb25maWd1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tqXS5jb25maWd1cmUoaW5mb1tqXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tqXSA9IExpdGVHcmFwaC5jbG9uZU9iamVjdChpbmZvW2pdLCB0aGlzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vdmFsdWVcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbal0gPSBpbmZvW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmZvLnRpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlID0gdGhpcy5jb25zdHJ1Y3Rvci50aXRsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ3JhcGgubGlua3NbaW5wdXQubGlua11cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLklOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICApOyAvL2xpbmtfaW5mbyBoYXMgYmVlbiBjcmVhdGVkIG5vdywgc28gaXRzIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dHB1dC5saW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXQubGlua3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdyYXBoLmxpbmtzW291dHB1dC5saW5rc1tqXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk9VVFBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTsgLy9saW5rX2luZm8gaGFzIGJlZW4gY3JlYXRlZCBub3csIHNvIGl0cyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRcdGlmKCB0aGlzLndpZGdldHMgKVxuXHRcdHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aWRnZXRzLmxlbmd0aDsgKytpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdyA9IHRoaXMud2lkZ2V0c1tpXTtcblx0XHRcdFx0aWYoIXcpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdGlmKHcub3B0aW9ucyAmJiB3Lm9wdGlvbnMucHJvcGVydHkgJiYgdGhpcy5wcm9wZXJ0aWVzWyB3Lm9wdGlvbnMucHJvcGVydHkgXSlcblx0XHRcdFx0XHR3LnZhbHVlID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHRoaXMucHJvcGVydGllc1sgdy5vcHRpb25zLnByb3BlcnR5IF0gKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluZm8ud2lkZ2V0c192YWx1ZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLndpZGdldHNfdmFsdWVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMud2lkZ2V0c1tpXSkge1xuXHRcdFx0XHRcdFx0dGhpcy53aWRnZXRzW2ldLnZhbHVlID0gaW5mby53aWRnZXRzX3ZhbHVlc1tpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cbiAgICAgICAgaWYgKHRoaXMub25Db25maWd1cmUpIHtcbiAgICAgICAgICAgIHRoaXMub25Db25maWd1cmUoaW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VyaWFsaXplIHRoZSBjb250ZW50XG4gICAgICogQG1ldGhvZCBzZXJpYWxpemVcbiAgICAgKi9cblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NyZWF0ZSBzZXJpYWxpemF0aW9uIG9iamVjdFxuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgcG9zOiB0aGlzLnBvcyxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgIGZsYWdzOiBMaXRlR3JhcGguY2xvbmVPYmplY3QodGhpcy5mbGFncyksXG5cdFx0XHRvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZXJlIHdlcmUgZXJyb3JzXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBMR3JhcGhOb2RlICYmIHRoaXMubGFzdF9zZXJpYWxpemF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0X3NlcmlhbGl6YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIG8uaW5wdXRzID0gdGhpcy5pbnB1dHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICAvL2NsZWFyIG91dHB1dHMgbGFzdCBkYXRhIChiZWNhdXNlIGRhdGEgaW4gY29ubmVjdGlvbnMgaXMgbmV2ZXIgc2VyaWFsaXplZCBidXQgc3RvcmVkIGluc2lkZSB0aGUgb3V0cHV0cyBpbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRwdXRzW2ldLl9kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgby5vdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGl0bGUgJiYgdGhpcy50aXRsZSAhPSB0aGlzLmNvbnN0cnVjdG9yLnRpdGxlKSB7XG4gICAgICAgICAgICBvLnRpdGxlID0gdGhpcy50aXRsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIG8ucHJvcGVydGllcyA9IExpdGVHcmFwaC5jbG9uZU9iamVjdCh0aGlzLnByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0cyAmJiB0aGlzLnNlcmlhbGl6ZV93aWRnZXRzKSB7XG4gICAgICAgICAgICBvLndpZGdldHNfdmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2lkZ2V0cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRpZih0aGlzLndpZGdldHNbaV0pXG5cdCAgICAgICAgICAgICAgICBvLndpZGdldHNfdmFsdWVzW2ldID0gdGhpcy53aWRnZXRzW2ldLnZhbHVlO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0by53aWRnZXRzX3ZhbHVlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW8udHlwZSkge1xuICAgICAgICAgICAgby50eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgIG8uY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJnY29sb3IpIHtcbiAgICAgICAgICAgIG8uYmdjb2xvciA9IHRoaXMuYmdjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3hjb2xvcikge1xuICAgICAgICAgICAgby5ib3hjb2xvciA9IHRoaXMuYm94Y29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgIG8uc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25TZXJpYWxpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU2VyaWFsaXplKG8pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcIm5vZGUgb25TZXJpYWxpemUgc2hvdWxkbnQgcmV0dXJuIGFueXRoaW5nLCBkYXRhIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIG9iamVjdCBwYXNzIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXJcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgLyogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgbm9kZSAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUodGhpcy50eXBlKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2UgY2xvbmUgaXQgYmVjYXVzZSBzZXJpYWxpemUgcmV0dXJucyBzaGFyZWQgY29udGFpbmVyc1xuICAgICAgICB2YXIgZGF0YSA9IExpdGVHcmFwaC5jbG9uZU9iamVjdCh0aGlzLnNlcmlhbGl6ZSgpKTtcblxuICAgICAgICAvL3JlbW92ZSBsaW5rc1xuICAgICAgICBpZiAoZGF0YS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmlucHV0c1tpXS5saW5rID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEub3V0cHV0c1tpXS5saW5rcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm91dHB1dHNbaV0ubGlua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZGF0YVtcImlkXCJdO1xuICAgICAgICAvL3JlbW92ZSBsaW5rc1xuICAgICAgICBub2RlLmNvbmZpZ3VyZShkYXRhKTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VyaWFsaXplIGFuZCBzdHJpbmdpZnlcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICovXG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zZXJpYWxpemUoKSk7XG4gICAgfTtcbiAgICAvL0xHcmFwaE5vZGUucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oaW5mbykge30gLy90aGlzIGNhbm5vdCBiZSBkb25lIGZyb20gd2l0aGluLCBtdXN0IGJlIGRvbmUgaW4gTGl0ZUdyYXBoXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIHN0cmluZ1xuICAgICAqIEBtZXRob2QgZ2V0VGl0bGVcbiAgICAgKi9cblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlIHx8IHRoaXMuY29uc3RydWN0b3IudGl0bGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHlcbiAgICAgKiBAbWV0aG9kIHNldFByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cblx0XHRpZiggdmFsdWUgPT09IHRoaXMucHJvcGVydGllc1tuYW1lXSApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHByZXZfdmFsdWUgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5vblByb3BlcnR5Q2hhbmdlZCkge1xuICAgICAgICAgICAgaWYoIHRoaXMub25Qcm9wZXJ0eUNoYW5nZWQobmFtZSwgdmFsdWUsIHByZXZfdmFsdWUpID09PSBmYWxzZSApIC8vYWJvcnQgY2hhbmdlXG5cdFx0XHRcdHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHByZXZfdmFsdWU7XG4gICAgICAgIH1cblx0XHRpZih0aGlzLndpZGdldHMpIC8vd2lkZ2V0cyBjb3VsZCBiZSBsaW5rZWQgdG8gcHJvcGVydGllc1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMud2lkZ2V0cy5sZW5ndGg7ICsraSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHcgPSB0aGlzLndpZGdldHNbaV07XG5cdFx0XHRcdGlmKCF3KVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRpZih3Lm9wdGlvbnMucHJvcGVydHkgPT0gbmFtZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHcudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuICAgIH07XG5cbiAgICAvLyBFeGVjdXRpb24gKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIG91dHB1dCBkYXRhXG4gICAgICogQG1ldGhvZCBzZXRPdXRwdXREYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5zZXRPdXRwdXREYXRhID0gZnVuY3Rpb24oc2xvdCwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGlzIG1heWJlIHNsb3cgYW5kIGEgbmljaGUgY2FzZVxuICAgICAgICAvL2lmKHNsb3QgJiYgc2xvdC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKVxuICAgICAgICAvL1x0c2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qoc2xvdCk7XG5cbiAgICAgICAgaWYgKHNsb3QgPT0gLTEgfHwgc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0X2luZm8gPSB0aGlzLm91dHB1dHNbc2xvdF07XG4gICAgICAgIGlmICghb3V0cHV0X2luZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc3RvcmUgZGF0YSBpbiB0aGUgb3V0cHV0IGl0c2VsZiBpbiBjYXNlIHdlIHdhbnQgdG8gZGVidWdcbiAgICAgICAgb3V0cHV0X2luZm8uX2RhdGEgPSBkYXRhO1xuXG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIGNvbm5lY3Rpb25zLCBwYXNzIHRoZSBkYXRhIHRvIHRoZSBjb25uZWN0aW9uc1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRzW3Nsb3RdLmxpbmtzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0c1tzbG90XS5saW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX2lkID0gdGhpcy5vdXRwdXRzW3Nsb3RdLmxpbmtzW2ldO1xuXHRcdFx0XHR2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG5cdFx0XHRcdGlmKGxpbmspXG5cdFx0XHRcdFx0bGluay5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBvdXRwdXQgZGF0YSB0eXBlLCB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBiZSBhYmxlIHRvIG92ZXJ3cml0ZSB0aGUgZGF0YSB0eXBlXG4gICAgICogQG1ldGhvZCBzZXRPdXRwdXREYXRhVHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGF0eXBlXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0T3V0cHV0RGF0YVR5cGUgPSBmdW5jdGlvbihzbG90LCB0eXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsb3QgPT0gLTEgfHwgc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dF9pbmZvID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dF9pbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9zdG9yZSBkYXRhIGluIHRoZSBvdXRwdXQgaXRzZWxmIGluIGNhc2Ugd2Ugd2FudCB0byBkZWJ1Z1xuICAgICAgICBvdXRwdXRfaW5mby50eXBlID0gdHlwZTtcblxuICAgICAgICAvL2lmIHRoZXJlIGFyZSBjb25uZWN0aW9ucywgcGFzcyB0aGUgZGF0YSB0byB0aGUgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tzbG90XS5saW5rcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMub3V0cHV0c1tzbG90XS5saW5rc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgZGF0YSAoZGF0YSB0cmF2ZWxpbmcgdGhyb3VnaCB0aGUgY29ubmVjdGlvbikgZnJvbSBvbmUgc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXREYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlX3VwZGF0ZSBpZiBzZXQgdG8gdHJ1ZSBpdCB3aWxsIGZvcmNlIHRoZSBjb25uZWN0ZWQgbm9kZSBvZiB0aGlzIHNsb3QgdG8gb3V0cHV0IGRhdGEgaW50byB0aGlzIGxpbmtcbiAgICAgKiBAcmV0dXJuIHsqfSBkYXRhIG9yIGlmIGl0IGlzIG5vdCBjb25uZWN0ZWQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dERhdGEgPSBmdW5jdGlvbihzbG90LCBmb3JjZV91cGRhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChzbG90ID49IHRoaXMuaW5wdXRzLmxlbmd0aCB8fCB0aGlzLmlucHV0c1tzbG90XS5saW5rID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rX2lkID0gdGhpcy5pbnB1dHNbc2xvdF0ubGluaztcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgIC8vYnVnOiB3ZWlyZCBjYXNlIGJ1dCBpdCBoYXBwZW5zIHNvbWV0aW1lc1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvcmNlX3VwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc3BlY2lhbCBjYXNlOiB1c2VkIHRvIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBpbmNvbWluZyBjb25uZWN0aW9uIGJlZm9yZSB0aGUgZ3JhcGggaGFzIGJlZW4gZXhlY3V0ZWRcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmsub3JpZ2luX2lkKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluay5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudXBkYXRlT3V0cHV0RGF0YSkge1xuICAgICAgICAgICAgbm9kZS51cGRhdGVPdXRwdXREYXRhKGxpbmsub3JpZ2luX3Nsb3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUub25FeGVjdXRlKSB7XG4gICAgICAgICAgICBub2RlLm9uRXhlY3V0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmsuZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBpbnB1dCBkYXRhIHR5cGUgKGluIGNhc2UgdGhpcyBzdXBwb3J0cyBtdWx0aXBsZSBpbnB1dCB0eXBlcylcbiAgICAgKiBAbWV0aG9kIGdldElucHV0RGF0YVR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZGF0YXR5cGUgaW4gc3RyaW5nIGZvcm1hdFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldElucHV0RGF0YVR5cGUgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChzbG90ID49IHRoaXMuaW5wdXRzLmxlbmd0aCB8fCB0aGlzLmlucHV0c1tzbG90XS5saW5rID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5rX2lkID0gdGhpcy5pbnB1dHNbc2xvdF0ubGluaztcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgIC8vYnVnOiB3ZWlyZCBjYXNlIGJ1dCBpdCBoYXBwZW5zIHNvbWV0aW1lc1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmsub3JpZ2luX2lkKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluay50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRfaW5mbyA9IG5vZGUub3V0cHV0c1tsaW5rLm9yaWdpbl9zbG90XTtcbiAgICAgICAgaWYgKG91dHB1dF9pbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0X2luZm8udHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBpbnB1dCBkYXRhIGZyb20gb25lIHNsb3QgdXNpbmcgaXRzIG5hbWUgaW5zdGVhZCBvZiBzbG90IG51bWJlclxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXREYXRhQnlOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNsb3RfbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VfdXBkYXRlIGlmIHNldCB0byB0cnVlIGl0IHdpbGwgZm9yY2UgdGhlIGNvbm5lY3RlZCBub2RlIG9mIHRoaXMgc2xvdCB0byBvdXRwdXQgZGF0YSBpbnRvIHRoaXMgbGlua1xuICAgICAqIEByZXR1cm4geyp9IGRhdGEgb3IgaWYgaXQgaXMgbm90IGNvbm5lY3RlZCByZXR1cm5zIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dERhdGFCeU5hbWUgPSBmdW5jdGlvbihcbiAgICAgICAgc2xvdF9uYW1lLFxuICAgICAgICBmb3JjZV91cGRhdGVcbiAgICApIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRJbnB1dFNsb3Qoc2xvdF9uYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldElucHV0RGF0YShzbG90LCBmb3JjZV91cGRhdGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0ZWxscyB5b3UgaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIGluIG9uZSBpbnB1dCBzbG90XG4gICAgICogQG1ldGhvZCBpc0lucHV0Q29ubmVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmlzSW5wdXRDb25uZWN0ZWQgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xvdCA8IHRoaXMuaW5wdXRzLmxlbmd0aCAmJiB0aGlzLmlucHV0c1tzbG90XS5saW5rICE9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRlbGxzIHlvdSBpbmZvIGFib3V0IGFuIGlucHV0IGNvbm5lY3Rpb24gKHdoaWNoIG5vZGUsIHR5cGUsIGV0YylcbiAgICAgKiBAbWV0aG9kIGdldElucHV0SW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgb3IgbnVsbCB7IGxpbms6IGlkLCBuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZyBvciAwIH1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dEluZm8gPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90IDwgdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dHNbc2xvdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgaW5mbyBpbiB0aGUgY29ubmVjdGlvbiBvZiBhbiBpbnB1dCBzbG90XG4gICAgICogQG1ldGhvZCBnZXRJbnB1dExpbmtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge0xMaW5rfSBvYmplY3Qgb3IgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldElucHV0TGluayA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsb3QgPCB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzbG90X2luZm8gPSB0aGlzLmlucHV0c1tzbG90XTtcblx0XHRcdHJldHVybiB0aGlzLmdyYXBoLmxpbmtzWyBzbG90X2luZm8ubGluayBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBub2RlIGNvbm5lY3RlZCBpbiB0aGUgaW5wdXQgc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXROb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtMR3JhcGhOb2RlfSBub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dE5vZGUgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90ID49IHRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbc2xvdF07XG4gICAgICAgIGlmICghaW5wdXQgfHwgaW5wdXQubGluayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbaW5wdXQubGlua107XG4gICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rX2luZm8ub3JpZ2luX2lkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdmFsdWUgb2YgYW4gaW5wdXQgd2l0aCB0aGlzIG5hbWUsIG90aGVyd2lzZSBjaGVja3MgaWYgdGhlcmUgaXMgYSBwcm9wZXJ0eSB3aXRoIHRoYXQgbmFtZVxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXRPclByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldElucHV0T3JQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzID8gdGhpcy5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5mbyA9IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gaW5wdXRfaW5mby5uYW1lICYmIGlucHV0X2luZm8ubGluayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2lucHV0X2luZm8ubGlua107XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmsuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IHRoZSBsYXN0IG91dHB1dCBkYXRhIHRoYXQgd2VudCBpbiB0aGF0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGdldE91dHB1dERhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gIG9iamVjdCBvciBudWxsXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90ID49IHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLm91dHB1dHNbc2xvdF07XG4gICAgICAgIHJldHVybiBpbmZvLl9kYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0ZWxscyB5b3UgaW5mbyBhYm91dCBhbiBvdXRwdXQgY29ubmVjdGlvbiAod2hpY2ggbm9kZSwgdHlwZSwgZXRjKVxuICAgICAqIEBtZXRob2QgZ2V0T3V0cHV0SW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgb2JqZWN0IG9yIG51bGwgeyBuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgbGlua3M6IFsgaWRzIG9mIGxpbmtzIGluIG51bWJlciBdIH1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRPdXRwdXRJbmZvID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsb3QgPCB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0ZWxscyB5b3UgaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIGluIG9uZSBvdXRwdXQgc2xvdFxuICAgICAqIEBtZXRob2QgaXNPdXRwdXRDb25uZWN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuaXNPdXRwdXRDb25uZWN0ZWQgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHNsb3QgPCB0aGlzLm91dHB1dHMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MgJiZcbiAgICAgICAgICAgIHRoaXMub3V0cHV0c1tzbG90XS5saW5rcy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGlmIHRoZXJlIGlzIGFueSBjb25uZWN0aW9uIGluIHRoZSBvdXRwdXQgc2xvdHNcbiAgICAgKiBAbWV0aG9kIGlzQW55T3V0cHV0Q29ubmVjdGVkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5pc0FueU91dHB1dENvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzW2ldLmxpbmtzICYmIHRoaXMub3V0cHV0c1tpXS5saW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlcyBhbGwgdGhlIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIG91dHB1dCBzbG90XG4gICAgICogQG1ldGhvZCBnZXRPdXRwdXROb2Rlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0Tm9kZXMgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzIHx8IHRoaXMub3V0cHV0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbc2xvdF07XG4gICAgICAgIGlmICghb3V0cHV0LmxpbmtzIHx8IG91dHB1dC5saW5rcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5saW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSBvdXRwdXQubGlua3NbaV07XG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGluay50YXJnZXRfaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2godGFyZ2V0X25vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYW4gZXZlbnQgaW4gdGhpcyBub2RlLCB0aGlzIHdpbGwgdHJpZ2dlciBhbnkgb3V0cHV0IHdpdGggdGhlIHNhbWUgbmFtZVxuICAgICAqIEBtZXRob2QgdHJpZ2dlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lICggXCJvbl9wbGF5XCIsIC4uLiApIGlmIGFjdGlvbiBpcyBlcXVpdmFsZW50IHRvIGZhbHNlIHRoZW4gdGhlIGV2ZW50IGlzIHNlbmQgdG8gYWxsXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzIHx8ICF0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmFwaClcbiAgICAgICAgICAgIHRoaXMuZ3JhcGguX2xhc3RfdHJpZ2dlcl90aW1lID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcbiAgICAgICAgICAgIGlmICggIW91dHB1dCB8fCBvdXRwdXQudHlwZSAhPT0gTGl0ZUdyYXBoLkVWRU5UIHx8IChhY3Rpb24gJiYgb3V0cHV0Lm5hbWUgIT0gYWN0aW9uKSApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTbG90KGksIHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbiBzbG90IGV2ZW50IGluIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgdHJpZ2dlclNsb3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2xvdCB0aGUgaW5kZXggb2YgdGhlIG91dHB1dCBzbG90XG4gICAgICogQHBhcmFtIHsqfSBwYXJhbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5rX2lkIFtvcHRpb25hbF0gaW4gY2FzZSB5b3Ugd2FudCB0byB0cmlnZ2VyIGFuZCBzcGVjaWZpYyBvdXRwdXQgbGluayBpbiBhIHNsb3RcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS50cmlnZ2VyU2xvdCA9IGZ1bmN0aW9uKHNsb3QsIHBhcmFtLCBsaW5rX2lkKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmtzID0gb3V0cHV0LmxpbmtzO1xuICAgICAgICBpZiAoIWxpbmtzIHx8ICFsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLl9sYXN0X3RyaWdnZXJfdGltZSA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZvciBldmVyeSBsaW5rIGF0dGFjaGVkIGhlcmVcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5rcy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgdmFyIGlkID0gbGlua3Nba107XG4gICAgICAgICAgICBpZiAobGlua19pZCAhPSBudWxsICYmIGxpbmtfaWQgIT0gaWQpIHtcbiAgICAgICAgICAgICAgICAvL3RvIHNraXAgbGlua3NcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtzW2tdXTtcbiAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgLy9ub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rX2luZm8uX2xhc3RfdGltZSA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLnRhcmdldF9pZCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAvL25vZGUgbm90IGZvdW5kP1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3VzZWQgdG8gbWFyayBldmVudHMgaW4gZ3JhcGhcbiAgICAgICAgICAgIHZhciB0YXJnZXRfY29ubmVjdGlvbiA9IG5vZGUuaW5wdXRzW2xpbmtfaW5mby50YXJnZXRfc2xvdF07XG5cblx0XHRcdGlmIChub2RlLm1vZGUgPT09IExpdGVHcmFwaC5PTl9UUklHR0VSKVxuXHRcdFx0e1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9uRXhlY3V0ZShwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobm9kZS5vbkFjdGlvbikge1xuICAgICAgICAgICAgICAgIG5vZGUub25BY3Rpb24odGFyZ2V0X2Nvbm5lY3Rpb24ubmFtZSwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNsZWFycyB0aGUgdHJpZ2dlciBzbG90IGFuaW1hdGlvblxuICAgICAqIEBtZXRob2QgY2xlYXJUcmlnZ2VyZWRTbG90XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNsb3QgdGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgc2xvdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5rX2lkIFtvcHRpb25hbF0gaW4gY2FzZSB5b3Ugd2FudCB0byB0cmlnZ2VyIGFuZCBzcGVjaWZpYyBvdXRwdXQgbGluayBpbiBhIHNsb3RcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jbGVhclRyaWdnZXJlZFNsb3QgPSBmdW5jdGlvbihzbG90LCBsaW5rX2lkKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmtzID0gb3V0cHV0LmxpbmtzO1xuICAgICAgICBpZiAoIWxpbmtzIHx8ICFsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZm9yIGV2ZXJ5IGxpbmsgYXR0YWNoZWQgaGVyZVxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpbmtzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBsaW5rc1trXTtcbiAgICAgICAgICAgIGlmIChsaW5rX2lkICE9IG51bGwgJiYgbGlua19pZCAhPSBpZCkge1xuICAgICAgICAgICAgICAgIC8vdG8gc2tpcCBsaW5rc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbbGlua3Nba11dO1xuICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcbiAgICAgICAgICAgICAgICAvL25vdCBjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtfaW5mby5fbGFzdF90aW1lID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIG5vZGUgc2l6ZSBhbmQgdHJpZ2dlcnMgY2FsbGJhY2tcbiAgICAgKiBAbWV0aG9kIHNldFNpemVcbiAgICAgKiBAcGFyYW0ge3ZlYzJ9IHNpemVcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSlcblx0e1xuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cdFx0aWYodGhpcy5vblJlc2l6ZSlcblx0XHRcdHRoaXMub25SZXNpemUodGhpcy5zaXplKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IHByb3BlcnR5IHRvIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgYWRkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdF92YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHN0cmluZyBkZWZpbmluZyB0aGUgb3V0cHV0IHR5cGUgKFwidmVjM1wiLFwibnVtYmVyXCIsLi4uKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYV9pbmZvIHRoaXMgY2FuIGJlIHVzZWQgdG8gaGF2ZSBzcGVjaWFsIHByb3BlcnRpZXMgb2YgdGhlIHByb3BlcnR5IChsaWtlIHZhbHVlcywgZXRjKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24oXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRfdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGV4dHJhX2luZm9cbiAgICApIHtcbiAgICAgICAgdmFyIG8gPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIGRlZmF1bHRfdmFsdWU6IGRlZmF1bHRfdmFsdWUgfTtcbiAgICAgICAgaWYgKGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZXh0cmFfaW5mbykge1xuICAgICAgICAgICAgICAgIG9baV0gPSBleHRyYV9pbmZvW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzX2luZm8pIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc19pbmZvID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzX2luZm8ucHVzaChvKTtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IGRlZmF1bHRfdmFsdWU7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICAvL2Nvbm5lY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgb3V0cHV0IHNsb3QgdG8gdXNlIGluIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgYWRkT3V0cHV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIG91dHB1dCB0eXBlIChcInZlYzNcIixcIm51bWJlclwiLC4uLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFfaW5mbyB0aGlzIGNhbiBiZSB1c2VkIHRvIGhhdmUgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIGFuIG91dHB1dCAobGFiZWwsIHNwZWNpYWwgY29sb3IsIHBvc2l0aW9uLCBldGMpXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkT3V0cHV0ID0gZnVuY3Rpb24obmFtZSwgdHlwZSwgZXh0cmFfaW5mbykge1xuICAgICAgICB2YXIgbyA9IHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgbGlua3M6IG51bGwgfTtcbiAgICAgICAgaWYgKGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZXh0cmFfaW5mbykge1xuICAgICAgICAgICAgICAgIG9baV0gPSBleHRyYV9pbmZvW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKG8pO1xuICAgICAgICBpZiAodGhpcy5vbk91dHB1dEFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0QWRkZWQobyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBvdXRwdXQgc2xvdCB0byB1c2UgaW4gdGhpcyBub2RlXG4gICAgICogQG1ldGhvZCBhZGRPdXRwdXRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdHJpcGxldHMgbGlrZSBbW25hbWUsdHlwZSxleHRyYV9pbmZvXSxbLi4uXV1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRPdXRwdXRzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHZhciBvID0geyBuYW1lOiBpbmZvWzBdLCB0eXBlOiBpbmZvWzFdLCBsaW5rOiBudWxsIH07XG4gICAgICAgICAgICBpZiAoYXJyYXlbMl0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGluZm9bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgb1tqXSA9IGluZm9bMl1bal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2gobyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vbk91dHB1dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk91dHB1dEFkZGVkKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuIGV4aXN0aW5nIG91dHB1dCBzbG90XG4gICAgICogQG1ldGhvZCByZW1vdmVPdXRwdXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnJlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0cHV0KHNsb3QpO1xuICAgICAgICB0aGlzLm91dHB1dHMuc3BsaWNlKHNsb3QsIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gc2xvdDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dHB1dHNbaV0gfHwgIXRoaXMub3V0cHV0c1tpXS5saW5rcykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5vdXRwdXRzW2ldLmxpbmtzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rc1tqXV07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5rLm9yaWdpbl9zbG90IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICBpZiAodGhpcy5vbk91dHB1dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25PdXRwdXRSZW1vdmVkKHNsb3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBpbnB1dCBzbG90IHRvIHVzZSBpbiB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZElucHV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIGlucHV0IHR5cGUgKFwidmVjM1wiLFwibnVtYmVyXCIsLi4uKSwgaXQgaXRzIGEgZ2VuZXJpYyBvbmUgdXNlIDBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFfaW5mbyB0aGlzIGNhbiBiZSB1c2VkIHRvIGhhdmUgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIGFuIGlucHV0IChsYWJlbCwgY29sb3IsIHBvc2l0aW9uLCBldGMpXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkSW5wdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCBleHRyYV9pbmZvKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IDA7XG4gICAgICAgIHZhciBvID0geyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlLCBsaW5rOiBudWxsIH07XG4gICAgICAgIGlmIChleHRyYV9pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgICAgICBvW2ldID0gZXh0cmFfaW5mb1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0cy5wdXNoKG8pO1xuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0QWRkZWQobyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYWRkIHNldmVyYWwgbmV3IGlucHV0IHNsb3RzIGluIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgYWRkSW5wdXRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdHJpcGxldHMgbGlrZSBbW25hbWUsdHlwZSxleHRyYV9pbmZvXSxbLi4uXV1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRJbnB1dHMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGFycmF5W2ldO1xuICAgICAgICAgICAgdmFyIG8gPSB7IG5hbWU6IGluZm9bMF0sIHR5cGU6IGluZm9bMV0sIGxpbms6IG51bGwgfTtcbiAgICAgICAgICAgIGlmIChhcnJheVsyXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gaW5mb1syXSkge1xuICAgICAgICAgICAgICAgICAgICBvW2pdID0gaW5mb1syXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dHMucHVzaChvKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uSW5wdXRBZGRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25JbnB1dEFkZGVkKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuIGV4aXN0aW5nIGlucHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUlucHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5yZW1vdmVJbnB1dCA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SW5wdXQoc2xvdCk7XG4gICAgICAgIHZhciBzbG90X2luZm8gPSB0aGlzLmlucHV0cy5zcGxpY2Uoc2xvdCwgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzbG90OyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dHNbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1t0aGlzLmlucHV0c1tpXS5saW5rXTtcbiAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluay50YXJnZXRfc2xvdCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2l6ZSggdGhpcy5jb21wdXRlU2l6ZSgpICk7XG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRSZW1vdmVkKHNsb3QsIHNsb3RfaW5mb1swXSApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBhbiBzcGVjaWFsIGNvbm5lY3Rpb24gdG8gdGhpcyBub2RlICh1c2VkIGZvciBzcGVjaWFsIGtpbmRzIG9mIGdyYXBocylcbiAgICAgKiBAbWV0aG9kIGFkZENvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHN0cmluZyBkZWZpbmluZyB0aGUgaW5wdXQgdHlwZSAoXCJ2ZWMzXCIsXCJudW1iZXJcIiwuLi4pXG4gICAgICogQHBhcmFtIHtbeCx5XX0gcG9zIHBvc2l0aW9uIG9mIHRoZSBjb25uZWN0aW9uIGluc2lkZSB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gaWYgaXMgaW5wdXQgb3Igb3V0cHV0XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIHBvcywgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgbGlua3M6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKG8pO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZXMgdGhlIG1pbmltdW0gc2l6ZSBvZiBhIG5vZGUgYWNjb3JkaW5nIHRvIGl0cyBpbnB1dHMgYW5kIG91dHB1dCBzbG90c1xuICAgICAqIEBtZXRob2QgY29tcHV0ZVNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluSGVpZ2h0XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgdG90YWwgc2l6ZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnNpemUuY29uY2F0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93cyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggOiAxLFxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID8gdGhpcy5vdXRwdXRzLmxlbmd0aCA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHNpemUgPSBvdXQgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xuICAgICAgICByb3dzID0gTWF0aC5tYXgocm93cywgMSk7XG4gICAgICAgIHZhciBmb250X3NpemUgPSBMaXRlR3JhcGguTk9ERV9URVhUX1NJWkU7IC8vYWx0aG91Z2ggaXQgc2hvdWxkIGJlIGdyYXBoY2FudmFzLmlubmVyX3RleHRfZm9udCBzaXplXG5cbiAgICAgICAgdmFyIGZvbnRfc2l6ZSA9IGZvbnRfc2l6ZTtcbiAgICAgICAgdmFyIHRpdGxlX3dpZHRoID0gY29tcHV0ZV90ZXh0X3NpemUodGhpcy50aXRsZSk7XG4gICAgICAgIHZhciBpbnB1dF93aWR0aCA9IDA7XG4gICAgICAgIHZhciBvdXRwdXRfd2lkdGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGlucHV0LmxhYmVsIHx8IGlucHV0Lm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF93aWR0aCA9IGNvbXB1dGVfdGV4dF9zaXplKHRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dF93aWR0aCA8IHRleHRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfd2lkdGggPSB0ZXh0X3dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBvdXRwdXQubGFiZWwgfHwgb3V0cHV0Lm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF93aWR0aCA9IGNvbXB1dGVfdGV4dF9zaXplKHRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRfd2lkdGggPCB0ZXh0X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF93aWR0aCA9IHRleHRfd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZVswXSA9IE1hdGgubWF4KGlucHV0X3dpZHRoICsgb3V0cHV0X3dpZHRoICsgMTAsIHRpdGxlX3dpZHRoKTtcbiAgICAgICAgc2l6ZVswXSA9IE1hdGgubWF4KHNpemVbMF0sIExpdGVHcmFwaC5OT0RFX1dJRFRIKTtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0cyAmJiB0aGlzLndpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzaXplWzBdID0gTWF0aC5tYXgoc2l6ZVswXSwgTGl0ZUdyYXBoLk5PREVfV0lEVEggKiAxLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZVsxXSA9ICh0aGlzLmNvbnN0cnVjdG9yLnNsb3Rfc3RhcnRfeSB8fCAwKSArIHJvd3MgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVDtcblxuICAgICAgICB2YXIgd2lkZ2V0c19oZWlnaHQgPSAwO1xuICAgICAgICBpZiAodGhpcy53aWRnZXRzICYmIHRoaXMud2lkZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy53aWRnZXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZGdldHNbaV0uY29tcHV0ZVNpemUpXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNfaGVpZ2h0ICs9IHRoaXMud2lkZ2V0c1tpXS5jb21wdXRlU2l6ZShzaXplWzBdKVsxXSArIDQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzX2hlaWdodCArPSBMaXRlR3JhcGguTk9ERV9XSURHRVRfSEVJR0hUICsgNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZGdldHNfaGVpZ2h0ICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgaGVpZ2h0IHVzaW5nIHdpZGdldHMgaGVpZ2h0XG4gICAgICAgIGlmKCB0aGlzLndpZGdldHNfdXAgKVxuICAgICAgICAgICAgc2l6ZVsxXSA9IE1hdGgubWF4KCBzaXplWzFdLCB3aWRnZXRzX2hlaWdodCApO1xuICAgICAgICBlbHNlIGlmKCB0aGlzLndpZGdldHNfc3RhcnRfeSAhPSBudWxsIClcbiAgICAgICAgICAgIHNpemVbMV0gPSBNYXRoLm1heCggc2l6ZVsxXSwgd2lkZ2V0c19oZWlnaHQgKyB0aGlzLndpZGdldHNfc3RhcnRfeSApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzaXplWzFdICs9IHdpZGdldHNfaGVpZ2h0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVfdGV4dF9zaXplKHRleHQpIHtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvbnRfc2l6ZSAqIHRleHQubGVuZ3RoICogMC42O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5taW5faGVpZ2h0ICYmXG4gICAgICAgICAgICBzaXplWzFdIDwgdGhpcy5jb25zdHJ1Y3Rvci5taW5faGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgc2l6ZVsxXSA9IHRoaXMuY29uc3RydWN0b3IubWluX2hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemVbMV0gKz0gNjsgLy9tYXJnaW5cblxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhbGwgdGhlIGluZm8gYXZhaWxhYmxlIGFib3V0IGEgcHJvcGVydHkgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcm9wZXJ0eUluZm9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBvYmplY3Qgd2l0aCBhbGwgdGhlIGF2YWlsYWJsZSBpbmZvXG4gICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUluZm8gPSBmdW5jdGlvbiggcHJvcGVydHkgKVxuXHR7XG4gICAgICAgIHZhciBpbmZvID0gbnVsbDtcblxuXHRcdC8vdGhlcmUgYXJlIHNldmVyYWwgd2F5cyB0byBkZWZpbmUgaW5mbyBhYm91dCBhIHByb3BlcnR5XG5cdFx0Ly9sZWdhY3kgbW9kZVxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXNfaW5mbykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXNfaW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNfaW5mb1tpXS5uYW1lID09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8gPSB0aGlzLnByb3BlcnRpZXNfaW5mb1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cdFx0Ly9saXRlc2NlbmUgbW9kZSB1c2luZyB0aGUgY29uc3RydWN0b3Jcblx0XHRpZih0aGlzLmNvbnN0cnVjdG9yW1wiQFwiICsgcHJvcGVydHldKVxuXHRcdFx0aW5mbyA9IHRoaXMuY29uc3RydWN0b3JbXCJAXCIgKyBwcm9wZXJ0eV07XG5cblx0XHRpZih0aGlzLmNvbnN0cnVjdG9yLndpZGdldHNfaW5mbyAmJiB0aGlzLmNvbnN0cnVjdG9yLndpZGdldHNfaW5mb1twcm9wZXJ0eV0pXG5cdFx0XHRpbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci53aWRnZXRzX2luZm9bcHJvcGVydHldO1xuXG5cdFx0Ly9saXRlc2NlbmUgbW9kZSB1c2luZyB0aGUgY29uc3RydWN0b3Jcblx0XHRpZiAoIWluZm8gJiYgdGhpcy5vbkdldFByb3BlcnR5SW5mbykge1xuICAgICAgICAgICAgaW5mbyA9IHRoaXMub25HZXRQcm9wZXJ0eUluZm8ocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgaW5mbyA9IHt9O1xuXHRcdGlmKCFpbmZvLnR5cGUpXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlb2YgdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5XTtcblx0XHRpZihpbmZvLndpZGdldCA9PSBcImNvbWJvXCIpXG5cdFx0XHRpbmZvLnR5cGUgPSBcImVudW1cIjtcblxuXHRcdHJldHVybiBpbmZvO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgd2lkZ2V0IGluc2lkZSB0aGUgbm9kZSwgaXQgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3Agb2YgdGhlIG5vZGUsIHlvdSBjYW4gY29udHJvbCBsb3RzIG9mIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkV2lkZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHdpZGdldCB0eXBlIChjb3VsZCBiZSBcIm51bWJlclwiLFwic3RyaW5nXCIsXCJjb21ib1wiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIHRleHQgdG8gc2hvdyBvbiB0aGUgd2lkZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBpdCBjaGFuZ2VzIChvcHRpb25hbGx5LCBpdCBjYW4gYmUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIG1vZGlmeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb2JqZWN0IHRoYXQgY29udGFpbnMgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIHRoaXMgd2lkZ2V0IFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNyZWF0ZWQgd2lkZ2V0IG9iamVjdFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uKCB0eXBlLCBuYW1lLCB2YWx1ZSwgY2FsbGJhY2ssIG9wdGlvbnMgKVxuXHR7XG4gICAgICAgIGlmICghdGhpcy53aWRnZXRzKSB7XG4gICAgICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgfVxuXG5cdFx0aWYoIW9wdGlvbnMgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2suY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHR7XG5cdFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIC8vb3B0aW9ucyBjYW4gYmUgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdG9wdGlvbnMgPSB7IHByb3BlcnR5OiBvcHRpb25zIH07XG5cblx0XHRpZihjYWxsYmFjayAmJiBjYWxsYmFjay5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSAvL2NhbGxiYWNrIGNhbiBiZSB0aGUgcHJvcGVydHkgbmFtZVxuXHRcdHtcblx0XHRcdGlmKCFvcHRpb25zKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRvcHRpb25zLnByb3BlcnR5ID0gY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoY2FsbGJhY2sgJiYgY2FsbGJhY2suY29uc3RydWN0b3IgIT09IEZ1bmN0aW9uKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUud2FybihcImFkZFdpZGdldDogY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdH1cblxuICAgICAgICB2YXIgdyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcub3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHcueSA9IHcub3B0aW9ucy55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiAhdy5vcHRpb25zLmNhbGxiYWNrICYmICF3Lm9wdGlvbnMucHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxpdGVHcmFwaCBhZGRXaWRnZXQoLi4uKSB3aXRob3V0IGEgY2FsbGJhY2sgb3IgcHJvcGVydHkgYXNzaWduZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gXCJjb21ib1wiICYmICF3Lm9wdGlvbnMudmFsdWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkxpdGVHcmFwaCBhZGRXaWRnZXQoJ2NvbWJvJywuLi4pIHJlcXVpcmVzIHRvIHBhc3MgdmFsdWVzIGluIG9wdGlvbnM6IHsgdmFsdWVzOlsncmVkJywnYmx1ZSddIH1cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcblx0XHR0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICByZXR1cm4gdztcbiAgICB9O1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkQ3VzdG9tV2lkZ2V0ID0gZnVuY3Rpb24oY3VzdG9tX3dpZGdldCkge1xuICAgICAgICBpZiAoIXRoaXMud2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2goY3VzdG9tX3dpZGdldCk7XG4gICAgICAgIHJldHVybiBjdXN0b21fd2lkZ2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBib3VuZGluZyBvZiB0aGUgb2JqZWN0LCB1c2VkIGZvciByZW5kZXJpbmcgcHVycG9zZXNcbiAgICAgKiBib3VuZGluZyBpczogW3RvcGxlZnRfY29ybmVyeCwgdG9wbGVmdF9jb3JuZXJ5LCB3aWR0aCwgaGVpZ2h0XVxuICAgICAqIEBtZXRob2QgZ2V0Qm91bmRpbmdcbiAgICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXlbNF19IHRoZSB0b3RhbCBzaXplXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmcgPSBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIG91dFswXSA9IHRoaXMucG9zWzBdIC0gNDtcbiAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgIG91dFsyXSA9IHRoaXMuc2l6ZVswXSArIDQ7XG4gICAgICAgIG91dFszXSA9IHRoaXMuZmxhZ3MuY29sbGFwc2VkID8gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUIDogdGhpcy5zaXplWzFdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuXG4gICAgICAgIGlmICh0aGlzLm9uQm91bmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub25Cb3VuZGluZyhvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGUgc2hhcGUgb2YgYSBub2RlXG4gICAgICogQG1ldGhvZCBpc1BvaW50SW5zaWRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuaXNQb2ludEluc2lkZSA9IGZ1bmN0aW9uKHgsIHksIG1hcmdpbiwgc2tpcF90aXRsZSkge1xuICAgICAgICBtYXJnaW4gPSBtYXJnaW4gfHwgMDtcblxuICAgICAgICB2YXIgbWFyZ2luX3RvcCA9IHRoaXMuZ3JhcGggJiYgdGhpcy5ncmFwaC5pc0xpdmUoKSA/IDAgOiBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgIGlmIChza2lwX3RpdGxlKSB7XG4gICAgICAgICAgICBtYXJnaW5fdG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbGFncyAmJiB0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgLy9pZiAoIGRpc3RhbmNlKFt4LHldLCBbdGhpcy5wb3NbMF0gKyB0aGlzLnNpemVbMF0qMC41LCB0aGlzLnBvc1sxXSArIHRoaXMuc2l6ZVsxXSowLjVdKSA8IExpdGVHcmFwaC5OT0RFX0NPTExBUFNFRF9SQURJVVMpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zWzBdIC0gbWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAtIG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2NvbGxhcHNlZF93aWR0aCB8fCBMaXRlR3JhcGguTk9ERV9DT0xMQVBTRURfV0lEVEgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDIgKiBtYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDIgKiBtYXJnaW5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHRoaXMucG9zWzBdIC0gNCAtIG1hcmdpbiA8IHggJiZcbiAgICAgICAgICAgIHRoaXMucG9zWzBdICsgdGhpcy5zaXplWzBdICsgNCArIG1hcmdpbiA+IHggJiZcbiAgICAgICAgICAgIHRoaXMucG9zWzFdIC0gbWFyZ2luX3RvcCAtIG1hcmdpbiA8IHkgJiZcbiAgICAgICAgICAgIHRoaXMucG9zWzFdICsgdGhpcy5zaXplWzFdICsgbWFyZ2luID4geVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgbm9kZSBzbG90LCBhbmQgcmV0dXJucyBpbmZvIGFib3V0IHdoaWNoIHNsb3RcbiAgICAgKiBAbWV0aG9kIGdldFNsb3RJblBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gaWYgZm91bmQgdGhlIG9iamVjdCBjb250YWlucyB7IGlucHV0fG91dHB1dDogc2xvdCBvYmplY3QsIHNsb3Q6IG51bWJlciwgbGlua19wb3M6IFt4LHldIH1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRTbG90SW5Qb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgLy9zZWFyY2ggZm9yIGlucHV0c1xuICAgICAgICB2YXIgbGlua19wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGksIGxpbmtfcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1swXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlucHV0OiBpbnB1dCwgc2xvdDogaSwgbGlua19wb3M6IGxpbmtfcG9zIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbm5lY3Rpb25Qb3MoZmFsc2UsIGksIGxpbmtfcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1swXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG91dHB1dDogb3V0cHV0LCBzbG90OiBpLCBsaW5rX3BvczogbGlua19wb3MgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgaW5wdXQgc2xvdCB3aXRoIGEgZ2l2ZW4gbmFtZSAodXNlZCBmb3IgZHluYW1pYyBzbG90cyksIC0xIGlmIG5vdCBmb3VuZFxuICAgICAqIEBtZXRob2QgZmluZElucHV0U2xvdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBzbG90XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgc2xvdCAoLTEgaWYgbm90IGZvdW5kKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmZpbmRJbnB1dFNsb3QgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gdGhpcy5pbnB1dHNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgb3V0cHV0IHNsb3Qgd2l0aCBhIGdpdmVuIG5hbWUgKHVzZWQgZm9yIGR5bmFtaWMgc2xvdHMpLCAtMSBpZiBub3QgZm91bmRcbiAgICAgKiBAbWV0aG9kIGZpbmRPdXRwdXRTbG90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHNsb3RcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBzbG90ICgtMSBpZiBub3QgZm91bmQpXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZmluZE91dHB1dFNsb3QgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSB0aGlzLm91dHB1dHNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0aGlzIG5vZGUgb3V0cHV0IHRvIHRoZSBpbnB1dCBvZiBhbm90aGVyIG5vZGVcbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcl9vcl9zdHJpbmd9IHNsb3QgKGNvdWxkIGJlIHRoZSBudW1iZXIgb2YgdGhlIHNsb3Qgb3IgdGhlIHN0cmluZyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBzbG90KVxuICAgICAqIEBwYXJhbSB7TEdyYXBoTm9kZX0gbm9kZSB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcl9vcl9zdHJpbmd9IHRhcmdldF9zbG90IHRoZSBpbnB1dCBzbG90IG9mIHRoZSB0YXJnZXQgbm9kZSAoY291bGQgYmUgdGhlIG51bWJlciBvZiB0aGUgc2xvdCBvciB0aGUgc3RyaW5nIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNsb3QsIG9yIC0xIHRvIGNvbm5lY3QgYSB0cmlnZ2VyKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGxpbmtfaW5mbyBpcyBjcmVhdGVkLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihzbG90LCB0YXJnZXRfbm9kZSwgdGFyZ2V0X3Nsb3QpIHtcbiAgICAgICAgdGFyZ2V0X3Nsb3QgPSB0YXJnZXRfc2xvdCB8fCAwO1xuXG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgLy9jb3VsZCBiZSBjb25uZWN0ZWQgYmVmb3JlIGFkZGluZyBpdCB0byBhIGdyYXBoXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIkNvbm5lY3Q6IEVycm9yLCBub2RlIGRvZXNuJ3QgYmVsb25nIHRvIGFueSBncmFwaC4gTm9kZXMgbXVzdCBiZSBhZGRlZCBmaXJzdCB0byBhIGdyYXBoIGJlZm9yZSBjb25uZWN0aW5nIHRoZW0uXCJcbiAgICAgICAgICAgICk7IC8vZHVlIHRvIGxpbmsgaWRzIGJlaW5nIGFzc29jaWF0ZWQgd2l0aCBncmFwaHNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zZWVrIGZvciB0aGUgb3V0cHV0IHNsb3RcbiAgICAgICAgaWYgKHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qoc2xvdCk7XG4gICAgICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgbm8gc2xvdCBvZiBuYW1lIFwiICsgc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm91dHB1dHMgfHwgc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgc2xvdCBudW1iZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0X25vZGUgJiYgdGFyZ2V0X25vZGUuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAgICAgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKHRhcmdldF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldF9ub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcInRhcmdldCBub2RlIGlzIG51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYXZvaWQgbG9vcGJhY2tcbiAgICAgICAgaWYgKHRhcmdldF9ub2RlID09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy95b3UgY2FuIHNwZWNpZnkgdGhlIHNsb3QgYnkgbmFtZVxuICAgICAgICBpZiAodGFyZ2V0X3Nsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgdGFyZ2V0X3Nsb3QgPSB0YXJnZXRfbm9kZS5maW5kSW5wdXRTbG90KHRhcmdldF9zbG90KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRfc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvbm5lY3Q6IEVycm9yLCBubyBzbG90IG9mIG5hbWUgXCIgKyB0YXJnZXRfc2xvdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRfc2xvdCA9PT0gTGl0ZUdyYXBoLkVWRU5UKSB7XG4gICAgICAgICAgICAvL3NlYXJjaCBmb3IgZmlyc3Qgc2xvdCB3aXRoIGV2ZW50P1xuICAgICAgICAgICAgLypcblx0XHQvL2NyZWF0ZSBpbnB1dCBmb3IgdHJpZ2dlclxuXHRcdHZhciBpbnB1dCA9IHRhcmdldF9ub2RlLmFkZElucHV0KFwib25UcmlnZ2VyXCIsIExpdGVHcmFwaC5FVkVOVCApO1xuXHRcdHRhcmdldF9zbG90ID0gdGFyZ2V0X25vZGUuaW5wdXRzLmxlbmd0aCAtIDE7IC8vbGFzdCBvbmUgaXMgdGhlIG9uZSBjcmVhdGVkXG5cdFx0dGFyZ2V0X25vZGUubW9kZSA9IExpdGVHcmFwaC5PTl9UUklHR0VSO1xuXHRcdCovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0YXJnZXRfbm9kZS5pbnB1dHMgfHxcbiAgICAgICAgICAgIHRhcmdldF9zbG90ID49IHRhcmdldF9ub2RlLmlucHV0cy5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgc2xvdCBudW1iZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy9pZiB0aGVyZSBpcyBzb21ldGhpbmcgYWxyZWFkeSBwbHVnZ2VkIHRoZXJlLCBkaXNjb25uZWN0XG4gICAgICAgIGlmICh0YXJnZXRfbm9kZS5pbnB1dHNbdGFyZ2V0X3Nsb3RdLmxpbmsgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRhcmdldF9ub2RlLmRpc2Nvbm5lY3RJbnB1dCh0YXJnZXRfc2xvdCk7XG5cdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2h5IGhlcmU/P1xuICAgICAgICAvL3RoaXMuc2V0RGlydHlDYW52YXMoZmFsc2UsdHJ1ZSk7XG4gICAgICAgIC8vdGhpcy5ncmFwaC5jb25uZWN0aW9uQ2hhbmdlKCB0aGlzICk7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tzbG90XTtcblxuICAgICAgICAvL2FsbG93cyBub2RlcyB0byBibG9jayBjb25uZWN0aW9uXG4gICAgICAgIGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3RJbnB1dCkge1xuICAgICAgICAgICAgaWYgKCB0YXJnZXRfbm9kZS5vbkNvbm5lY3RJbnB1dCh0YXJnZXRfc2xvdCwgb3V0cHV0LnR5cGUsIG91dHB1dCwgdGhpcywgc2xvdCkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGFyZ2V0X25vZGUuaW5wdXRzW3RhcmdldF9zbG90XTtcbiAgICAgICAgdmFyIGxpbmtfaW5mbyA9IG51bGw7XG5cblx0XHQvL3RoaXMgc2xvdHMgY2Fubm90IGJlIGNvbm5lY3RlZCAoZGlmZmVyZW50IHR5cGVzKVxuICAgICAgICBpZiAoIUxpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbihvdXRwdXQudHlwZSwgaW5wdXQudHlwZSkpXG5cdFx0e1xuXHQgICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXMoZmFsc2UsIHRydWUpO1xuXHRcdFx0aWYoY2hhbmdlZClcblx0XHQgICAgICAgIHRoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSh0aGlzLCBsaW5rX2luZm8pO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoIWNoYW5nZWQpXG5cdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuXG5cdFx0Ly9jcmVhdGUgbGluayBjbGFzc1xuXHRcdGxpbmtfaW5mbyA9IG5ldyBMTGluayhcblx0XHRcdCsrdGhpcy5ncmFwaC5sYXN0X2xpbmtfaWQsXG5cdFx0XHRpbnB1dC50eXBlLFxuXHRcdFx0dGhpcy5pZCxcblx0XHRcdHNsb3QsXG5cdFx0XHR0YXJnZXRfbm9kZS5pZCxcblx0XHRcdHRhcmdldF9zbG90XG5cdFx0KTtcblxuXHRcdC8vYWRkIHRvIGdyYXBoIGxpbmtzIGxpc3Rcblx0XHR0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaW5mby5pZF0gPSBsaW5rX2luZm87XG5cblx0XHQvL2Nvbm5lY3QgaW4gb3V0cHV0XG5cdFx0aWYgKG91dHB1dC5saW5rcyA9PSBudWxsKSB7XG5cdFx0XHRvdXRwdXQubGlua3MgPSBbXTtcblx0XHR9XG5cdFx0b3V0cHV0LmxpbmtzLnB1c2gobGlua19pbmZvLmlkKTtcblx0XHQvL2Nvbm5lY3QgaW4gaW5wdXRcblx0XHR0YXJnZXRfbm9kZS5pbnB1dHNbdGFyZ2V0X3Nsb3RdLmxpbmsgPSBsaW5rX2luZm8uaWQ7XG5cdFx0aWYgKHRoaXMuZ3JhcGgpIHtcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcblx0XHR9XG5cdFx0aWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuXHRcdFx0dGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuXHRcdFx0XHRMaXRlR3JhcGguT1VUUFVULFxuXHRcdFx0XHRzbG90LFxuXHRcdFx0XHR0cnVlLFxuXHRcdFx0XHRsaW5rX2luZm8sXG5cdFx0XHRcdG91dHB1dFxuXHRcdFx0KTtcblx0XHR9IC8vbGlua19pbmZvIGhhcyBiZWVuIGNyZWF0ZWQgbm93LCBzbyBpdHMgdXBkYXRlZFxuXHRcdGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG5cdFx0XHR0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuXHRcdFx0XHRMaXRlR3JhcGguSU5QVVQsXG5cdFx0XHRcdHRhcmdldF9zbG90LFxuXHRcdFx0XHR0cnVlLFxuXHRcdFx0XHRsaW5rX2luZm8sXG5cdFx0XHRcdGlucHV0XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcblx0XHRcdHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcblx0XHRcdFx0TGl0ZUdyYXBoLklOUFVULFxuXHRcdFx0XHR0YXJnZXRfbm9kZSxcblx0XHRcdFx0dGFyZ2V0X3Nsb3QsXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHNsb3Rcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG5cdFx0XHRcdExpdGVHcmFwaC5PVVRQVVQsXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHNsb3QsXG5cdFx0XHRcdHRhcmdldF9ub2RlLFxuXHRcdFx0XHR0YXJnZXRfc2xvdFxuXHRcdFx0KTtcblx0XHR9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyhmYWxzZSwgdHJ1ZSk7XG5cdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuXHRcdHRoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSh0aGlzLCBsaW5rX2luZm8pO1xuXG4gICAgICAgIHJldHVybiBsaW5rX2luZm87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3Qgb25lIG91dHB1dCB0byBhbiBzcGVjaWZpYyBub2RlXG4gICAgICogQG1ldGhvZCBkaXNjb25uZWN0T3V0cHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcGFyYW0ge0xHcmFwaE5vZGV9IHRhcmdldF9ub2RlIHRoZSB0YXJnZXQgbm9kZSB0byB3aGljaCB0aGlzIHNsb3QgaXMgY29ubmVjdGVkIFtPcHRpb25hbCwgaWYgbm90IHRhcmdldF9ub2RlIGlzIHNwZWNpZmllZCBhbGwgbm9kZXMgd2lsbCBiZSBkaXNjb25uZWN0ZWRdXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gaWYgaXQgd2FzIGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5kaXNjb25uZWN0T3V0cHV0ID0gZnVuY3Rpb24oc2xvdCwgdGFyZ2V0X25vZGUpIHtcbiAgICAgICAgaWYgKHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qoc2xvdCk7XG4gICAgICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgbm8gc2xvdCBvZiBuYW1lIFwiICsgc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vdXRwdXRzIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIHNsb3QgbnVtYmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ2V0IG91dHB1dCBzbG90XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbc2xvdF07XG4gICAgICAgIGlmICghb3V0cHV0IHx8ICFvdXRwdXQubGlua3MgfHwgb3V0cHV0LmxpbmtzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL29uZSBvZiB0aGUgb3V0cHV0IGxpbmtzIGluIHRoaXMgc2xvdFxuICAgICAgICBpZiAodGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKHRhcmdldF9ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRhcmdldCBOb2RlIG5vdCBmb3VuZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG91dHB1dC5saW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IG91dHB1dC5saW5rc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcblxuICAgICAgICAgICAgICAgIC8vaXMgdGhlIGxpbmsgd2UgYXJlIHNlYXJjaGluZyBmb3IuLi5cbiAgICAgICAgICAgICAgICBpZiAobGlua19pbmZvLnRhcmdldF9pZCA9PSB0YXJnZXRfbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGlua3Muc3BsaWNlKGksIDEpOyAvL3JlbW92ZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRhcmdldF9ub2RlLmlucHV0c1tsaW5rX2luZm8udGFyZ2V0X3Nsb3RdO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5saW5rID0gbnVsbDsgLy9yZW1vdmUgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07IC8vcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGxpbmtzIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSAvL2xpbmtfaW5mbyBoYXNuJ3QgYmVlbiBtb2RpZmllZCBzbyBpdHMgb2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5JTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vYWxsIHRoZSBsaW5rcyBpbiB0aGlzIG91dHB1dCBzbG90XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvdXRwdXQubGlua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSBvdXRwdXQubGlua3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9idWc6IGl0IGhhcHBlbnMgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLnRhcmdldF9pZCk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHRhcmdldF9ub2RlLmlucHV0c1tsaW5rX2luZm8udGFyZ2V0X3Nsb3RdO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5saW5rID0gbnVsbDsgLy9yZW1vdmUgb3RoZXIgc2lkZSBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5JTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IC8vbGlua19pbmZvIGhhc24ndCBiZWVuIG1vZGlmaWVkIHNvIGl0cyBva1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdOyAvL3JlbW92ZSB0aGUgbGluayBmcm9tIHRoZSBsaW5rcyBwb29sXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLklOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQubGlua3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyhmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3Qgb25lIGlucHV0XG4gICAgICogQG1ldGhvZCBkaXNjb25uZWN0SW5wdXRcbiAgICAgKiBAcGFyYW0ge251bWJlcl9vcl9zdHJpbmd9IHNsb3QgKGNvdWxkIGJlIHRoZSBudW1iZXIgb2YgdGhlIHNsb3Qgb3IgdGhlIHN0cmluZyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBzbG90KVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGl0IHdhcyBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdElucHV0ID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICAvL3NlZWsgZm9yIHRoZSBvdXRwdXQgc2xvdFxuICAgICAgICBpZiAoc2xvdC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KHNsb3QpO1xuICAgICAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIG5vIHNsb3Qgb2YgbmFtZSBcIiArIHNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaW5wdXRzIHx8IHNsb3QgPj0gdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgc2xvdCBudW1iZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbc2xvdF07XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rX2lkID0gdGhpcy5pbnB1dHNbc2xvdF0ubGluaztcblx0XHRpZihsaW5rX2lkICE9IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhpcy5pbnB1dHNbc2xvdF0ubGluayA9IG51bGw7XG5cblx0XHRcdC8vcmVtb3ZlIG90aGVyIHNpZGVcblx0XHRcdHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuXHRcdFx0aWYgKGxpbmtfaW5mbykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby5vcmlnaW5faWQpO1xuXHRcdFx0XHRpZiAoIXRhcmdldF9ub2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG91dHB1dCA9IHRhcmdldF9ub2RlLm91dHB1dHNbbGlua19pbmZvLm9yaWdpbl9zbG90XTtcblx0XHRcdFx0aWYgKCFvdXRwdXQgfHwgIW91dHB1dC5saW5rcyB8fCBvdXRwdXQubGlua3MubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3NlYXJjaCBpbiB0aGUgaW5wdXRzIGxpc3QgZm9yIHRoaXMgbGlua1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG91dHB1dC5saW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAob3V0cHV0LmxpbmtzW2ldID09IGxpbmtfaWQpIHtcblx0XHRcdFx0XHRcdG91dHB1dC5saW5rcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTsgLy9yZW1vdmUgZnJvbSB0aGUgcG9vbFxuXHRcdFx0XHRpZiAodGhpcy5ncmFwaCkge1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG5cdFx0XHRcdFx0dGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuXHRcdFx0XHRcdFx0TGl0ZUdyYXBoLklOUFVULFxuXHRcdFx0XHRcdFx0c2xvdCxcblx0XHRcdFx0XHRcdGZhbHNlLFxuXHRcdFx0XHRcdFx0bGlua19pbmZvLFxuXHRcdFx0XHRcdFx0aW5wdXRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZShcblx0XHRcdFx0XHRcdExpdGVHcmFwaC5PVVRQVVQsXG5cdFx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdFx0XHRsaW5rX2luZm8sXG5cdFx0XHRcdFx0XHRvdXRwdXRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcblx0XHRcdFx0XHRcdExpdGVHcmFwaC5PVVRQVVQsXG5cdFx0XHRcdFx0XHR0YXJnZXRfbm9kZSxcblx0XHRcdFx0XHRcdGlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShMaXRlR3JhcGguSU5QVVQsIHRoaXMsIHNsb3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSAvL2xpbmsgIT0gbnVsbFxuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXMoZmFsc2UsIHRydWUpO1xuXHRcdGlmKHRoaXMuZ3JhcGgpXG5cdCAgICAgICAgdGhpcy5ncmFwaC5jb25uZWN0aW9uQ2hhbmdlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY2VudGVyIG9mIGEgY29ubmVjdGlvbiBwb2ludCBpbiBjYW52YXMgY29vcmRzXG4gICAgICogQG1ldGhvZCBnZXRDb25uZWN0aW9uUG9zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc19pbnB1dCB0cnVlIGlmIGlmIGEgaW5wdXQgc2xvdCwgZmFsc2UgaWYgaXQgaXMgYW4gb3V0cHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcGFyYW0ge3ZlYzJ9IG91dCBbb3B0aW9uYWxdIGEgcGxhY2UgdG8gc3RvcmUgdGhlIG91dHB1dCwgdG8gZnJlZSBnYXJiYWdlXG4gICAgICogQHJldHVybiB7W3gseV19IHRoZSBwb3NpdGlvblxuICAgICAqKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9zID0gZnVuY3Rpb24oXG4gICAgICAgIGlzX2lucHV0LFxuICAgICAgICBzbG90X251bWJlcixcbiAgICAgICAgb3V0XG4gICAgKSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgICAgICB2YXIgbnVtX3Nsb3RzID0gMDtcbiAgICAgICAgaWYgKGlzX2lucHV0ICYmIHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBudW1fc2xvdHMgPSB0aGlzLmlucHV0cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc19pbnB1dCAmJiB0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIG51bV9zbG90cyA9IHRoaXMub3V0cHV0cy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjU7XG5cbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB2YXIgdyA9IHRoaXMuX2NvbGxhcHNlZF93aWR0aCB8fCBMaXRlR3JhcGguTk9ERV9DT0xMQVBTRURfV0lEVEg7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF0gKyB3ICogMC41O1xuICAgICAgICAgICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2VpcmQgZmVhdHVyZSB0aGF0IG5ldmVyIGdvdCBmaW5pc2hlZFxuICAgICAgICBpZiAoaXNfaW5wdXQgJiYgc2xvdF9udW1iZXIgPT0gLTEpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHRoaXMucG9zWzBdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogMC41O1xuICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKiAwLjU7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9oYXJkLWNvZGVkIHBvc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc19pbnB1dCAmJlxuICAgICAgICAgICAgbnVtX3Nsb3RzID4gc2xvdF9udW1iZXIgJiZcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzW3Nsb3RfbnVtYmVyXS5wb3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHRoaXMuaW5wdXRzW3Nsb3RfbnVtYmVyXS5wb3NbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSArIHRoaXMuaW5wdXRzW3Nsb3RfbnVtYmVyXS5wb3NbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgIWlzX2lucHV0ICYmXG4gICAgICAgICAgICBudW1fc2xvdHMgPiBzbG90X251bWJlciAmJlxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzW3Nsb3RfbnVtYmVyXS5wb3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHRoaXMub3V0cHV0c1tzbG90X251bWJlcl0ucG9zWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gKyB0aGlzLm91dHB1dHNbc2xvdF9udW1iZXJdLnBvc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2hvcml6b250YWwgZGlzdHJpYnV0ZWQgc2xvdHNcbiAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgb3V0WzBdID1cbiAgICAgICAgICAgICAgICB0aGlzLnBvc1swXSArIChzbG90X251bWJlciArIDAuNSkgKiAodGhpcy5zaXplWzBdIC8gbnVtX3Nsb3RzKTtcbiAgICAgICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSArIHRoaXMuc2l6ZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2RlZmF1bHQgdmVydGljYWwgc2xvdHNcbiAgICAgICAgaWYgKGlzX2lucHV0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dFswXSA9IHRoaXMucG9zWzBdICsgdGhpcy5zaXplWzBdICsgMSAtIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBvdXRbMV0gPVxuICAgICAgICAgICAgdGhpcy5wb3NbMV0gK1xuICAgICAgICAgICAgKHNsb3RfbnVtYmVyICsgMC43KSAqIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICtcbiAgICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yLnNsb3Rfc3RhcnRfeSB8fCAwKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgLyogRm9yY2UgYWxpZ24gdG8gZ3JpZCAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFsaWduVG9HcmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucG9zWzBdID1cbiAgICAgICAgICAgIExpdGVHcmFwaC5DQU5WQVNfR1JJRF9TSVpFICpcbiAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wb3NbMF0gLyBMaXRlR3JhcGguQ0FOVkFTX0dSSURfU0laRSk7XG4gICAgICAgIHRoaXMucG9zWzFdID1cbiAgICAgICAgICAgIExpdGVHcmFwaC5DQU5WQVNfR1JJRF9TSVpFICpcbiAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wb3NbMV0gLyBMaXRlR3JhcGguQ0FOVkFTX0dSSURfU0laRSk7XG4gICAgfTtcblxuICAgIC8qIENvbnNvbGUgb3V0cHV0ICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnNvbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc29sZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25zb2xlLnB1c2gobXNnKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc29sZS5sZW5ndGggPiBMR3JhcGhOb2RlLk1BWF9DT05TT0xFKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNvbGUuc2hpZnQoKTtcbiAgICAgICAgfVxuXG5cdFx0aWYodGhpcy5ncmFwaC5vbk5vZGVUcmFjZSlcblx0ICAgICAgICB0aGlzLmdyYXBoLm9uTm9kZVRyYWNlKHRoaXMsIG1zZyk7XG4gICAgfTtcblxuICAgIC8qIEZvcmNlcyB0byByZWRyYXcgb3IgdGhlIG1haW4gY2FudmFzIChMR3JhcGhOb2RlKSBvciB0aGUgYmcgY2FudmFzIChsaW5rcykgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5zZXREaXJ0eUNhbnZhcyA9IGZ1bmN0aW9uKFxuICAgICAgICBkaXJ0eV9mb3JlZ3JvdW5kLFxuICAgICAgICBkaXJ0eV9iYWNrZ3JvdW5kXG4gICAgKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGguc2VuZEFjdGlvblRvQ2FudmFzKFwic2V0RGlydHlcIiwgW1xuICAgICAgICAgICAgZGlydHlfZm9yZWdyb3VuZCxcbiAgICAgICAgICAgIGRpcnR5X2JhY2tncm91bmRcbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zcmMgPSBMaXRlR3JhcGgubm9kZV9pbWFnZXNfcGF0aCArIHVybDtcbiAgICAgICAgaW1nLnJlYWR5ID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfTtcblxuICAgIC8vc2FmZSBMR3JhcGhOb2RlIGFjdGlvbiBleGVjdXRpb24gKG5vdCBzdXJlIGlmIHNhZmUpXG4gICAgLypcbkxHcmFwaE5vZGUucHJvdG90eXBlLmV4ZWN1dGVBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24pXG57XG5cdGlmKGFjdGlvbiA9PSBcIlwiKSByZXR1cm4gZmFsc2U7XG5cblx0aWYoIGFjdGlvbi5pbmRleE9mKFwiO1wiKSAhPSAtMSB8fCBhY3Rpb24uaW5kZXhPZihcIn1cIikgIT0gLTEpXG5cdHtcblx0XHR0aGlzLnRyYWNlKFwiRXJyb3I6IEFjdGlvbiBjb250YWlucyB1bnNhZmUgY2hhcmFjdGVyc1wiKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgdG9rZW5zID0gYWN0aW9uLnNwbGl0KFwiKFwiKTtcblx0dmFyIGZ1bmNfbmFtZSA9IHRva2Vuc1swXTtcblx0aWYoIHR5cGVvZih0aGlzW2Z1bmNfbmFtZV0pICE9IFwiZnVuY3Rpb25cIilcblx0e1xuXHRcdHRoaXMudHJhY2UoXCJFcnJvcjogQWN0aW9uIG5vdCBmb3VuZCBvbiBub2RlOiBcIiArIGZ1bmNfbmFtZSk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNvZGUgPSBhY3Rpb247XG5cblx0dHJ5XG5cdHtcblx0XHR2YXIgX2ZvbyA9IGV2YWw7XG5cdFx0ZXZhbCA9IG51bGw7XG5cdFx0KG5ldyBGdW5jdGlvbihcIndpdGgodGhpcykgeyBcIiArIGNvZGUgKyBcIn1cIikpLmNhbGwodGhpcyk7XG5cdFx0ZXZhbCA9IF9mb287XG5cdH1cblx0Y2F0Y2ggKGVycilcblx0e1xuXHRcdHRoaXMudHJhY2UoXCJFcnJvciBleGVjdXRpbmcgYWN0aW9uIHtcIiArIGFjdGlvbiArIFwifSA6XCIgKyBlcnIpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuKi9cblxuICAgIC8qIEFsbG93cyB0byBnZXQgb25Nb3VzZU1vdmUgYW5kIG9uTW91c2VVcCBldmVudHMgZXZlbiBpZiB0aGUgbW91c2UgaXMgb3V0IG9mIGZvY3VzICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuY2FwdHVyZUlucHV0ID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGggfHwgIXRoaXMuZ3JhcGgubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmdyYXBoLmxpc3Rfb2ZfZ3JhcGhjYW52YXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGxpc3RbaV07XG4gICAgICAgICAgICAvL3JlbGVhc2luZyBzb21lYm9keSBlbHNlcyBjYXB0dXJlPyFcbiAgICAgICAgICAgIGlmICghdiAmJiBjLm5vZGVfY2FwdHVyaW5nX2lucHV0ICE9IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jaGFuZ2VcbiAgICAgICAgICAgIGMubm9kZV9jYXB0dXJpbmdfaW5wdXQgPSB2ID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgdGhlIG5vZGUgdG8gbWFrZSBpdCBzbWFsbGVyIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIGNvbGxhcHNlXG4gICAgICoqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5jb2xsYXBzYWJsZSA9PT0gZmFsc2UgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIG5vZGUgdG8gZG8gbm90IG1vdmUgb3IgcmVhbGlnbiBvbiBaXG4gICAgICogQG1ldGhvZCBwaW5cbiAgICAgKiovXG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5waW4gPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5waW5uZWQgPSAhdGhpcy5mbGFncy5waW5uZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzLnBpbm5lZCA9IHY7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUubG9jYWxUb1NjcmVlbiA9IGZ1bmN0aW9uKHgsIHksIGdyYXBoY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoeCArIHRoaXMucG9zWzBdKSAqIGdyYXBoY2FudmFzLnNjYWxlICsgZ3JhcGhjYW52YXMub2Zmc2V0WzBdLFxuICAgICAgICAgICAgKHkgKyB0aGlzLnBvc1sxXSkgKiBncmFwaGNhbnZhcy5zY2FsZSArIGdyYXBoY2FudmFzLm9mZnNldFsxXVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBMR3JhcGhHcm91cCh0aXRsZSkge1xuICAgICAgICB0aGlzLl9jdG9yKHRpdGxlKTtcbiAgICB9XG5cbiAgICBnbG9iYWwuTEdyYXBoR3JvdXAgPSBMaXRlR3JhcGguTEdyYXBoR3JvdXAgPSBMR3JhcGhHcm91cDtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5fY3RvciA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZSB8fCBcIkdyb3VwXCI7XG4gICAgICAgIHRoaXMuZm9udF9zaXplID0gMjQ7XG4gICAgICAgIHRoaXMuY29sb3IgPSBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMucGFsZV9ibHVlXG4gICAgICAgICAgICA/IExHcmFwaENhbnZhcy5ub2RlX2NvbG9ycy5wYWxlX2JsdWUuZ3JvdXBjb2xvclxuICAgICAgICAgICAgOiBcIiNBQUFcIjtcbiAgICAgICAgdGhpcy5fYm91bmRpbmcgPSBuZXcgRmxvYXQzMkFycmF5KFsxMCwgMTAsIDE0MCwgODBdKTtcbiAgICAgICAgdGhpcy5fcG9zID0gdGhpcy5fYm91bmRpbmcuc3ViYXJyYXkoMCwgMik7XG4gICAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9ib3VuZGluZy5zdWJhcnJheSgyLCA0KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ncmFwaCA9IG51bGw7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicG9zXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghdiB8fCB2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc1sxXSA9IHZbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYgfHwgdi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZVswXSA9IE1hdGgubWF4KDE0MCwgdlswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZVsxXSA9IE1hdGgubWF4KDgwLCB2WzFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBvLnRpdGxlO1xuICAgICAgICB0aGlzLl9ib3VuZGluZy5zZXQoby5ib3VuZGluZyk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBvLmNvbG9yO1xuICAgICAgICB0aGlzLmZvbnQgPSBvLmZvbnQ7XG4gICAgfTtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLl9ib3VuZGluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgICAgICAgICAgYm91bmRpbmc6IFtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGJbMF0pLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoYlsxXSksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChiWzJdKSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGJbM10pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgICBmb250OiB0aGlzLmZvbnRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgTEdyYXBoR3JvdXAucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkZWx0YXgsIGRlbHRheSwgaWdub3JlX25vZGVzKSB7XG4gICAgICAgIHRoaXMuX3Bvc1swXSArPSBkZWx0YXg7XG4gICAgICAgIHRoaXMuX3Bvc1sxXSArPSBkZWx0YXk7XG4gICAgICAgIGlmIChpZ25vcmVfbm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgICAgICAgbm9kZS5wb3NbMF0gKz0gZGVsdGF4O1xuICAgICAgICAgICAgbm9kZS5wb3NbMV0gKz0gZGVsdGF5O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5yZWNvbXB1dGVJbnNpZGVOb2RlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgdmFyIG5vZGVfYm91bmRpbmcgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLmdldEJvdW5kaW5nKG5vZGVfYm91bmRpbmcpO1xuICAgICAgICAgICAgaWYgKCFvdmVybGFwQm91bmRpbmcodGhpcy5fYm91bmRpbmcsIG5vZGVfYm91bmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vb3V0IG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoR3JvdXAucHJvdG90eXBlLmlzUG9pbnRJbnNpZGUgPSBMR3JhcGhOb2RlLnByb3RvdHlwZS5pc1BvaW50SW5zaWRlO1xuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5zZXREaXJ0eUNhbnZhcyA9IExHcmFwaE5vZGUucHJvdG90eXBlLnNldERpcnR5Q2FudmFzO1xuXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvL1NjYWxlIGFuZCBPZmZzZXRcbiAgICBmdW5jdGlvbiBEcmFnQW5kU2NhbGUoZWxlbWVudCwgc2tpcF9ldmVudHMpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLm1heF9zY2FsZSA9IDEwO1xuICAgICAgICB0aGlzLm1pbl9zY2FsZSA9IDAuMTtcbiAgICAgICAgdGhpcy5vbnJlZHJhdyA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZSA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFza2lwX2V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cyhlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIExpdGVHcmFwaC5EcmFnQW5kU2NhbGUgPSBEcmFnQW5kU2NhbGU7XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICAgICAgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrID0gdGhpcy5vbk1vdXNlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2spO1xuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwibW91c2V3aGVlbFwiLFxuICAgICAgICAgICAgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuY29tcHV0ZVZpc2libGVBcmVhID0gZnVuY3Rpb24oIHZpZXdwb3J0ICkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMF0gPSB0aGlzLnZpc2libGVfYXJlYVsxXSA9IHRoaXMudmlzaWJsZV9hcmVhWzJdID0gdGhpcy52aXNpYmxlX2FyZWFbM10gPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZWxlbWVudC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIHZhciBzdGFydHggPSAtdGhpcy5vZmZzZXRbMF07XG4gICAgICAgIHZhciBzdGFydHkgPSAtdGhpcy5vZmZzZXRbMV07XG5cdFx0aWYoIHZpZXdwb3J0IClcblx0XHR7XG5cdFx0XHRzdGFydHggKz0gdmlld3BvcnRbMF0gLyB0aGlzLnNjYWxlO1xuXHRcdFx0c3RhcnR5ICs9IHZpZXdwb3J0WzFdIC8gdGhpcy5zY2FsZTtcblx0XHRcdHdpZHRoID0gdmlld3BvcnRbMl07XG5cdFx0XHRoZWlnaHQgPSB2aWV3cG9ydFszXTtcblx0XHR9XG4gICAgICAgIHZhciBlbmR4ID0gc3RhcnR4ICsgd2lkdGggLyB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgZW5keSA9IHN0YXJ0eSArIGhlaWdodCAvIHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzBdID0gc3RhcnR4O1xuICAgICAgICB0aGlzLnZpc2libGVfYXJlYVsxXSA9IHN0YXJ0eTtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMl0gPSBlbmR4IC0gc3RhcnR4O1xuICAgICAgICB0aGlzLnZpc2libGVfYXJlYVszXSA9IGVuZHkgLSBzdGFydHk7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUub25Nb3VzZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgdmFyIHkgPSBlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgZS5jYW52YXN4ID0geDtcbiAgICAgICAgZS5jYW52YXN5ID0geTtcbiAgICAgICAgZS5kcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmc7XG5cblx0XHR2YXIgaXNfaW5zaWRlID0gIXRoaXMudmlld3BvcnQgfHwgKCB0aGlzLnZpZXdwb3J0ICYmIHggPj0gdGhpcy52aWV3cG9ydFswXSAmJiB4IDwgKHRoaXMudmlld3BvcnRbMF0gKyB0aGlzLnZpZXdwb3J0WzJdKSAmJiB5ID49IHRoaXMudmlld3BvcnRbMV0gJiYgeSA8ICh0aGlzLnZpZXdwb3J0WzFdICsgdGhpcy52aWV3cG9ydFszXSkgKTtcblxuICAgICAgICB2YXIgaWdub3JlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9ubW91c2UpIHtcbiAgICAgICAgICAgIGlnbm9yZSA9IHRoaXMub25tb3VzZShlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJtb3VzZWRvd25cIiAmJiBpc19pbnNpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayApO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayApO1xuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAoIWlnbm9yZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSB4IC0gdGhpcy5sYXN0X21vdXNlWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXkgPSB5IC0gdGhpcy5sYXN0X21vdXNlWzFdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW91c2VEcmFnKGRlbHRheCwgZGVsdGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09IFwibW91c2V1cFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayApO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCBcIm1vdXNldXBcIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrICk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2sgKTtcbiAgICAgICAgfSBlbHNlIGlmICggaXNfaW5zaWRlICYmXG4gICAgICAgICAgICAoZS50eXBlID09IFwibW91c2V3aGVlbFwiIHx8XG4gICAgICAgICAgICBlLnR5cGUgPT0gXCJ3aGVlbFwiIHx8XG4gICAgICAgICAgICBlLnR5cGUgPT0gXCJET01Nb3VzZVNjcm9sbFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGUuZXZlbnRUeXBlID0gXCJtb3VzZXdoZWVsXCI7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09IFwid2hlZWxcIikge1xuICAgICAgICAgICAgICAgIGUud2hlZWwgPSAtZS5kZWx0YVk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUud2hlZWwgPVxuICAgICAgICAgICAgICAgICAgICBlLndoZWVsRGVsdGFZICE9IG51bGwgPyBlLndoZWVsRGVsdGFZIDogZS5kZXRhaWwgKiAtNjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZnJvbSBzdGFjayBvdmVyZmxvd1xuICAgICAgICAgICAgZS5kZWx0YSA9IGUud2hlZWxEZWx0YVxuICAgICAgICAgICAgICAgID8gZS53aGVlbERlbHRhIC8gNDBcbiAgICAgICAgICAgICAgICA6IGUuZGVsdGFZXG4gICAgICAgICAgICAgICAgPyAtZS5kZWx0YVkgLyAzXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZWx0YVNjYWxlKDEuMCArIGUuZGVsdGEgKiAwLjA1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVswXSA9IHg7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVsxXSA9IHk7XG5cblx0XHRpZihpc19pbnNpZGUpXG5cdFx0e1xuXHQgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0XHQgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQgICAgcmV0dXJuIGZhbHNlO1xuXHRcdH1cbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS50b0NhbnZhc0NvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMub2Zmc2V0WzBdLCB0aGlzLm9mZnNldFsxXSk7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuY29udmVydE9mZnNldFRvQ2FudmFzID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIC8vcmV0dXJuIFtwb3NbMF0gLyB0aGlzLnNjYWxlIC0gdGhpcy5vZmZzZXRbMF0sIHBvc1sxXSAvIHRoaXMuc2NhbGUgLSB0aGlzLm9mZnNldFsxXV07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAocG9zWzBdICsgdGhpcy5vZmZzZXRbMF0pICogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgIChwb3NbMV0gKyB0aGlzLm9mZnNldFsxXSkgKiB0aGlzLnNjYWxlXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuY29udmVydENhbnZhc1RvT2Zmc2V0ID0gZnVuY3Rpb24ocG9zLCBvdXQpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IFswLCAwXTtcbiAgICAgICAgb3V0WzBdID0gcG9zWzBdIC8gdGhpcy5zY2FsZSAtIHRoaXMub2Zmc2V0WzBdO1xuICAgICAgICBvdXRbMV0gPSBwb3NbMV0gLyB0aGlzLnNjYWxlIC0gdGhpcy5vZmZzZXRbMV07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUubW91c2VEcmFnID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLm9mZnNldFswXSArPSB4IC8gdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy5vZmZzZXRbMV0gKz0geSAvIHRoaXMuc2NhbGU7XG5cbiAgICAgICAgaWYgKHRoaXMub25yZWRyYXcpIHtcbiAgICAgICAgICAgIHRoaXMub25yZWRyYXcodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS5jaGFuZ2VTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlLCB6b29taW5nX2NlbnRlcikge1xuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLm1pbl9zY2FsZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbl9zY2FsZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IHRoaXMubWF4X3NjYWxlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4X3NjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09IHRoaXMuc2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB6b29taW5nX2NlbnRlciA9IHpvb21pbmdfY2VudGVyIHx8IFtcbiAgICAgICAgICAgIHJlY3Qud2lkdGggKiAwLjUsXG4gICAgICAgICAgICByZWN0LmhlaWdodCAqIDAuNVxuICAgICAgICBdO1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5jb252ZXJ0Q2FudmFzVG9PZmZzZXQoem9vbWluZ19jZW50ZXIpO1xuICAgICAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnNjYWxlIC0gMSkgPCAwLjAxKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfY2VudGVyID0gdGhpcy5jb252ZXJ0Q2FudmFzVG9PZmZzZXQoem9vbWluZ19jZW50ZXIpO1xuICAgICAgICB2YXIgZGVsdGFfb2Zmc2V0ID0gW1xuICAgICAgICAgICAgbmV3X2NlbnRlclswXSAtIGNlbnRlclswXSxcbiAgICAgICAgICAgIG5ld19jZW50ZXJbMV0gLSBjZW50ZXJbMV1cbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLm9mZnNldFswXSArPSBkZWx0YV9vZmZzZXRbMF07XG4gICAgICAgIHRoaXMub2Zmc2V0WzFdICs9IGRlbHRhX29mZnNldFsxXTtcblxuICAgICAgICBpZiAodGhpcy5vbnJlZHJhdykge1xuICAgICAgICAgICAgdGhpcy5vbnJlZHJhdyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmNoYW5nZURlbHRhU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSwgem9vbWluZ19jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTY2FsZSh0aGlzLnNjYWxlICogdmFsdWUsIHpvb21pbmdfY2VudGVyKTtcbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5vZmZzZXRbMF0gPSAwO1xuICAgICAgICB0aGlzLm9mZnNldFsxXSA9IDA7XG4gICAgfTtcblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTEdyYXBoQ2FudmFzOiBMR3JhcGggcmVuZGVyZXIgQ0xBU1NcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpcyBpbiBjaGFyZ2Ugb2YgcmVuZGVyaW5nIG9uZSBncmFwaCBpbnNpZGUgYSBjYW52YXMuIEFuZCBwcm92aWRlcyBhbGwgdGhlIGludGVyYWN0aW9uIHJlcXVpcmVkLlxuICAgICAqIFZhbGlkIGNhbGxiYWNrcyBhcmU6IG9uTm9kZVNlbGVjdGVkLCBvbk5vZGVEZXNlbGVjdGVkLCBvblNob3dOb2RlUGFuZWwsIG9uTm9kZURibENsaWNrZWRcbiAgICAgKlxuICAgICAqIEBjbGFzcyBMR3JhcGhDYW52YXNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXN9IGNhbnZhcyB0aGUgY2FudmFzIHdoZXJlIHlvdSB3YW50IHRvIHJlbmRlciAoaXQgYWNjZXB0cyBhIHNlbGVjdG9yIGluIHN0cmluZyBmb3JtYXQgb3IgdGhlIGNhbnZhcyBlbGVtZW50IGl0c2VsZilcbiAgICAgKiBAcGFyYW0ge0xHcmFwaH0gZ3JhcGggW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFtvcHRpb25hbF0geyBza2lwX3JlbmRlcmluZywgYXV0b3Jlc2l6ZSwgdmlld3BvcnQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExHcmFwaENhbnZhcyhjYW52YXMsIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vaWYoZ3JhcGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgLy9cdHRocm93IChcIk5vIGdyYXBoIGFzc2lnbmVkXCIpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRfaW1hZ2UgPSBMR3JhcGhDYW52YXMuREVGQVVMVF9CQUNLR1JPVU5EX0lNQUdFO1xuXG4gICAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHMgPSBuZXcgRHJhZ0FuZFNjYWxlKCk7XG4gICAgICAgIHRoaXMuem9vbV9tb2RpZnlfYWxwaGEgPSB0cnVlOyAvL290aGVyd2lzZSBpdCBnZW5lcmF0ZXMgdWdseSBwYXR0ZXJucyB3aGVuIHNjYWxpbmcgZG93biB0b28gbXVjaFxuXG4gICAgICAgIHRoaXMudGl0bGVfdGV4dF9mb250ID0gXCJcIiArIExpdGVHcmFwaC5OT0RFX1RFWFRfU0laRSArIFwicHggQXJpYWxcIjtcbiAgICAgICAgdGhpcy5pbm5lcl90ZXh0X2ZvbnQgPVxuICAgICAgICAgICAgXCJub3JtYWwgXCIgKyBMaXRlR3JhcGguTk9ERV9TVUJURVhUX1NJWkUgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIHRoaXMubm9kZV90aXRsZV9jb2xvciA9IExpdGVHcmFwaC5OT0RFX1RJVExFX0NPTE9SO1xuICAgICAgICB0aGlzLmRlZmF1bHRfbGlua19jb2xvciA9IExpdGVHcmFwaC5MSU5LX0NPTE9SO1xuICAgICAgICB0aGlzLmRlZmF1bHRfY29ubmVjdGlvbl9jb2xvciA9IHtcbiAgICAgICAgICAgIGlucHV0X29mZjogXCIjNzc4XCIsXG4gICAgICAgICAgICBpbnB1dF9vbjogXCIjN0Y3XCIsXG4gICAgICAgICAgICBvdXRwdXRfb2ZmOiBcIiM3NzhcIixcbiAgICAgICAgICAgIG91dHB1dF9vbjogXCIjN0Y3XCJcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmhpZ2hxdWFsaXR5X3JlbmRlciA9IHRydWU7XG4gICAgICAgIHRoaXMudXNlX2dyYWRpZW50cyA9IGZhbHNlOyAvL3NldCB0byB0cnVlIHRvIHJlbmRlciB0aXRsZWJhciB3aXRoIGdyYWRpZW50c1xuICAgICAgICB0aGlzLmVkaXRvcl9hbHBoYSA9IDE7IC8vdXNlZCBmb3IgdHJhbnNpdGlvblxuICAgICAgICB0aGlzLnBhdXNlX3JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFyX2JhY2tncm91bmQgPSB0cnVlO1xuXG5cdFx0dGhpcy5yZWFkX29ubHkgPSBmYWxzZTsgLy9pZiBzZXQgdG8gdHJ1ZSB1c2VycyBjYW5ub3QgbW9kaWZ5IHRoZSBncmFwaFxuICAgICAgICB0aGlzLnJlbmRlcl9vbmx5X3NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXZlX21vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93X2luZm8gPSB0cnVlO1xuICAgICAgICB0aGlzLmFsbG93X2RyYWdjYW52YXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmFsbG93X2RyYWdub2RlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gPSB0cnVlOyAvL2FsbG93IHRvIGNvbnRyb2wgd2lkZ2V0cywgYnV0dG9ucywgY29sbGFwc2UsIGV0Y1xuICAgICAgICB0aGlzLmFsbG93X3NlYXJjaGJveCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsb3dfcmVjb25uZWN0X2xpbmtzID0gZmFsc2U7IC8vYWxsb3dzIHRvIGNoYW5nZSBhIGNvbm5lY3Rpb24gd2l0aCBoYXZpbmcgdG8gcmVkbyBpdCBhZ2FpblxuXHRcdHRoaXMuYWxpZ25fdG9fZ3JpZCA9IGZhbHNlOyAvL3NuYXAgdG8gZ3JpZFxuXG4gICAgICAgIHRoaXMuZHJhZ19tb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7IC8vYWxsb3dzIHRvIGZpbHRlciB0byBvbmx5IGFjY2VwdCBzb21lIHR5cGUgb2Ygbm9kZXMgaW4gYSBncmFwaFxuXG5cdFx0dGhpcy5zZXRfY2FudmFzX2RpcnR5X29uX21vdXNlX2V2ZW50ID0gdHJ1ZTsgLy9mb3JjZXMgdG8gcmVkcmF3IHRoZSBjYW52YXMgaWYgdGhlIG1vdXNlIGRvZXMgYW55dGhpbmdcbiAgICAgICAgdGhpcy5hbHdheXNfcmVuZGVyX2JhY2tncm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfc2hhZG93cyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyX2NhbnZhc19ib3JkZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcl9jb25uZWN0aW9uc19zaGFkb3dzID0gZmFsc2U7IC8vdG9vIG11Y2ggY3B1XG4gICAgICAgIHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25zX2JvcmRlciA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyX2N1cnZlZF9jb25uZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9jb25uZWN0aW9uX2Fycm93cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9jb2xsYXBzZWRfc2xvdHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcl9leGVjdXRpb25fb3JkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfdGl0bGVfY29sb3JlZCA9IHRydWU7XG5cdFx0dGhpcy5yZW5kZXJfbGlua190b29sdGlwID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmxpbmtzX3JlbmRlcl9tb2RlID0gTGl0ZUdyYXBoLlNQTElORV9MSU5LO1xuXG4gICAgICAgIHRoaXMubW91c2UgPSBbMCwgMF07IC8vbW91c2UgaW4gY2FudmFzIGNvb3JkaW5hdGVzLCB3aGVyZSAwLDAgaXMgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYmx1ZSByZWN0YW5nbGVcbiAgICAgICAgdGhpcy5ncmFwaF9tb3VzZSA9IFswLCAwXTsgLy9tb3VzZSBpbiBncmFwaCBjb29yZGluYXRlcywgd2hlcmUgMCwwIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGJsdWUgcmVjdGFuZ2xlXG5cdFx0dGhpcy5jYW52YXNfbW91c2UgPSB0aGlzLmdyYXBoX21vdXNlOyAvL0xFR0FDWTogUkVNT1ZFIFRISVMsIFVTRSBHUkFQSF9NT1VTRSBJTlNURUFEXG5cbiAgICAgICAgLy90byBwZXJzb25hbGl6ZSB0aGUgc2VhcmNoIGJveFxuICAgICAgICB0aGlzLm9uU2VhcmNoQm94ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblNlYXJjaEJveFNlbGVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgLy9jYWxsYmFja3NcbiAgICAgICAgdGhpcy5vbk1vdXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkRyYXdCYWNrZ3JvdW5kID0gbnVsbDsgLy90byByZW5kZXIgYmFja2dyb3VuZCBvYmplY3RzIChiZWhpbmQgbm9kZXMgYW5kIGNvbm5lY3Rpb25zKSBpbiB0aGUgY2FudmFzIGFmZmVjdGVkIGJ5IHRyYW5zZm9ybVxuICAgICAgICB0aGlzLm9uRHJhd0ZvcmVncm91bmQgPSBudWxsOyAvL3RvIHJlbmRlciBmb3JlZ3JvdW5kIG9iamVjdHMgKGFib3ZlIG5vZGVzIGFuZCBjb25uZWN0aW9ucykgaW4gdGhlIGNhbnZhcyBhZmZlY3RlZCBieSB0cmFuc2Zvcm1cbiAgICAgICAgdGhpcy5vbkRyYXdPdmVybGF5ID0gbnVsbDsgLy90byByZW5kZXIgZm9yZWdyb3VuZCBvYmplY3RzIG5vdCBhZmZlY3RlZCBieSB0cmFuc2Zvcm0gKGZvciBHVUlzKVxuXHRcdHRoaXMub25EcmF3TGlua1Rvb2x0aXAgPSBudWxsOyAvL2NhbGxlZCB3aGVuIHJlbmRlcmluZyBhIHRvb2x0aXBcblx0XHR0aGlzLm9uTm9kZU1vdmVkID0gbnVsbDsgLy9jYWxsZWQgYWZ0ZXIgbW92aW5nIGEgbm9kZVxuXHRcdHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSBudWxsOyAvL2NhbGxlZCBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXNcblx0XHR0aGlzLm9uQ29ubmVjdGluZ0NoYW5nZSA9IG51bGw7IC8vY2FsbGVkIGJlZm9yZSBhbnkgbGluayBjaGFuZ2VzXG5cdFx0dGhpcy5vbkJlZm9yZUNoYW5nZSA9IG51bGw7IC8vY2FsbGVkIGJlZm9yZSBtb2RpZnlpbmcgdGhlIGdyYXBoXG5cdFx0dGhpcy5vbkFmdGVyQ2hhbmdlID0gbnVsbDsgLy9jYWxsZWQgYWZ0ZXIgbW9kaWZ5aW5nIHRoZSBncmFwaFxuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnNfd2lkdGggPSAzO1xuICAgICAgICB0aGlzLnJvdW5kX3JhZGl1cyA9IDg7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50X25vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0ID0gbnVsbDsgLy91c2VkIGZvciB3aWRnZXRzXG5cdFx0dGhpcy5vdmVyX2xpbmtfY2VudGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlX3Bvc2l0aW9uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLnZpc2libGVfYXJlYSA9IHRoaXMuZHMudmlzaWJsZV9hcmVhO1xuICAgICAgICB0aGlzLnZpc2libGVfbGlua3MgPSBbXTtcblxuXHRcdHRoaXMudmlld3BvcnQgPSBvcHRpb25zLnZpZXdwb3J0IHx8IG51bGw7IC8vdG8gY29uc3RyYWludCByZW5kZXIgYXJlYSB0byBhIHBvcnRpb24gb2YgdGhlIGNhbnZhc1xuXG4gICAgICAgIC8vbGluayBjYW52YXMgYW5kIGdyYXBoXG4gICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgZ3JhcGguYXR0YWNoQ2FudmFzKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDYW52YXMoY2FudmFzLG9wdGlvbnMuc2tpcF9ldmVudHMpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnNraXBfcmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmF1dG9yZXNpemUgPSBvcHRpb25zLmF1dG9yZXNpemU7XG4gICAgfVxuXG4gICAgZ2xvYmFsLkxHcmFwaENhbnZhcyA9IExpdGVHcmFwaC5MR3JhcGhDYW52YXMgPSBMR3JhcGhDYW52YXM7XG5cblx0TEdyYXBoQ2FudmFzLkRFRkFVTFRfQkFDS0dST1VORF9JTUFHRSA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFHUUFBQUJrQ0FJQUFBRC9nQUlEQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRQkpSRUZVZU5yczFyRUt3akFVaGxFVFVrajN2UDlyZG1yMVlzYW1tazJ3NXdkeHVMZ2NNSHlwdGZhd3VaWDRwSlNXWlRuZm51L2xuSWUvak5OeEhIR05uLy9ITmJidis0ZHI2VisxMXVGNTI3YXJVNyt1NjNxZmEvYm5taDhzV0xCZ3dZSmxxUmY4TUVwdFhQQlhKWGEzN0JTbDNpeFlzR0RCTWxpd0ZMeUNWL0RlTElNRkN4WXNXTEJNd1N0NEJlL05nZ1hMWU1HQ0JVdkJLM2lOcnVDOVdiQmd3WUpsc0dBcGVBV3Y0TDFaQmdzV0xGaXdZSm1DVi9BSzNwc0ZDNWJCZ2dVTGxvSlg4QnBkd1h1ellNR0NCY3Rnd1ZMd0NsN0JlN01NRml4WXNHREJzdThGSDFGYVNtRXhWZkF4QmEvZ3ZWbXdZTUdDWmJCZy9XNHZBUVlBNXRSRjlRWWx2L1FBQUFBQVNVVk9SSzVDWUlJPVwiO1xuXG4gICAgTEdyYXBoQ2FudmFzLmxpbmtfdHlwZV9jb2xvcnMgPSB7XG4gICAgICAgIFwiLTFcIjogTGl0ZUdyYXBoLkVWRU5UX0xJTktfQ09MT1IsXG4gICAgICAgIG51bWJlcjogXCIjQUFBXCIsXG4gICAgICAgIG5vZGU6IFwiI0RDQVwiXG4gICAgfTtcbiAgICBMR3JhcGhDYW52YXMuZ3JhZGllbnRzID0ge307IC8vY2FjaGUgb2YgZ3JhZGllbnRzXG5cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgYWxsIHRoZSBkYXRhIGluc2lkZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdF9kcmF3X3RpbWUgPSAwO1xuICAgICAgICB0aGlzLnJlbmRlcl90aW1lID0gMDtcbiAgICAgICAgdGhpcy5mcHMgPSAwO1xuXG4gICAgICAgIC8vdGhpcy5zY2FsZSA9IDE7XG4gICAgICAgIC8vdGhpcy5vZmZzZXQgPSBbMCwwXTtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwID0gbnVsbDtcblxuICAgICAgICB0aGlzLnZpc2libGVfbm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVfb3ZlciA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfbm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3MgPSB7fTtcblxuXHRcdHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eV9hcmVhID0gbnVsbDtcblxuICAgICAgICB0aGlzLm5vZGVfaW5fcGFuZWwgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxhc3RfbW91c2UgPSBbMCwgMF07XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZWNsaWNrID0gMDtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWEuc2V0KFswLCAwLCAwLCAwXSk7XG5cbiAgICAgICAgaWYgKHRoaXMub25DbGVhcikge1xuICAgICAgICAgICAgdGhpcy5vbkNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXNzaWducyBhIGdyYXBoLCB5b3UgY2FuIHJlYXNzaWduIGdyYXBocyB0byB0aGUgc2FtZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0R3JhcGhcbiAgICAgKiBAcGFyYW0ge0xHcmFwaH0gZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNldEdyYXBoID0gZnVuY3Rpb24oZ3JhcGgsIHNraXBfY2xlYXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGggPT0gZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcF9jbGVhcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFncmFwaCAmJiB0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmRldGFjaENhbnZhcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoLmF0dGFjaENhbnZhcyh0aGlzKTtcblxuXHRcdC8vcmVtb3ZlIHRoZSBncmFwaCBzdGFjayBpbiBjYXNlIGEgc3ViZ3JhcGggd2FzIG9wZW5cblx0XHRpZiAodGhpcy5fZ3JhcGhfc3RhY2spXG5cdFx0XHR0aGlzLl9ncmFwaF9zdGFjayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdG9wIGxldmVsIGdyYXBoIChpbiBjYXNlIHRoZXJlIGFyZSBzdWJncmFwaHMgb3BlbiBvbiB0aGUgY2FudmFzKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRUb3BHcmFwaFxuICAgICAqIEByZXR1cm4ge0xHcmFwaH0gZ3JhcGhcbiAgICAgKi9cblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5nZXRUb3BHcmFwaCA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdGlmKHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aClcblx0XHRcdHJldHVybiB0aGlzLl9ncmFwaF9zdGFja1swXTtcblx0XHRyZXR1cm4gdGhpcy5ncmFwaDtcblx0fVxuXG4gICAgLyoqXG4gICAgICogb3BlbnMgYSBncmFwaCBjb250YWluZWQgaW5zaWRlIGEgbm9kZSBpbiB0aGUgY3VycmVudCBncmFwaFxuICAgICAqXG4gICAgICogQG1ldGhvZCBvcGVuU3ViZ3JhcGhcbiAgICAgKiBAcGFyYW0ge0xHcmFwaH0gZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLm9wZW5TdWJncmFwaCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgIGlmICghZ3JhcGgpIHtcbiAgICAgICAgICAgIHRocm93IFwiZ3JhcGggY2Fubm90IGJlIG51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoID09IGdyYXBoKSB7XG4gICAgICAgICAgICB0aHJvdyBcImdyYXBoIGNhbm5vdCBiZSB0aGUgc2FtZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dyYXBoX3N0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhfc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2dyYXBoX3N0YWNrLnB1c2godGhpcy5ncmFwaCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaC5hdHRhY2hDYW52YXModGhpcyk7XG5cdFx0dGhpcy5jaGVja1BhbmVscygpO1xuICAgICAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZXMgYSBzdWJncmFwaCBjb250YWluZWQgaW5zaWRlIGEgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBjbG9zZVN1YmdyYXBoXG4gICAgICogQHBhcmFtIHtMR3JhcGh9IGFzc2lnbnMgYSBncmFwaFxuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2xvc2VTdWJncmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2dyYXBoX3N0YWNrIHx8IHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YmdyYXBoX25vZGUgPSB0aGlzLmdyYXBoLl9zdWJncmFwaF9ub2RlO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaF9zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzID0ge307XG4gICAgICAgIGdyYXBoLmF0dGFjaENhbnZhcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYgKHN1YmdyYXBoX25vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyT25Ob2RlKHN1YmdyYXBoX25vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2Rlcyhbc3ViZ3JhcGhfbm9kZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHZpc3VhbHkgYWN0aXZlIGdyYXBoIChpbiBjYXNlIHRoZXJlIGFyZSBtb3JlIGluIHRoZSBzdGFjaylcbiAgICAgKiBAbWV0aG9kIGdldEN1cnJlbnRHcmFwaFxuICAgICAqIEByZXR1cm4ge0xHcmFwaH0gdGhlIGFjdGl2ZSBncmFwaFxuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZ2V0Q3VycmVudEdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhc3NpZ25zIGEgY2FudmFzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldENhbnZhc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBhc3NpZ25zIGEgY2FudmFzIChhbHNvIGFjY2VwdHMgdGhlIElEIG9mIHRoZSBlbGVtZW50IChub3QgYSBzZWxlY3RvcilcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNldENhbnZhcyA9IGZ1bmN0aW9uKGNhbnZhcywgc2tpcF9ldmVudHMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIGlmIChjYW52YXMuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBjcmVhdGluZyBMaXRlR3JhcGggY2FudmFzOiBDYW52YXMgbm90IGZvdW5kXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FudmFzICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICAvL21heWJlIGRldGFjaCBldmVudHMgZnJvbSBvbGRfY2FudmFzXG4gICAgICAgICAgICBpZiAoIXNraXBfZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLmRzLmVsZW1lbnQgPSBjYW52YXM7XG5cbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcy5jYW52YXMudGFiaW5kZXggPSBcIjEwMDBcIjtcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSArPSBcIiBsZ3JhcGhjYW52YXNcIjtcbiAgICAgICAgY2FudmFzLmRhdGEgPSB0aGlzO1xuICAgICAgICBjYW52YXMudGFiaW5kZXggPSBcIjFcIjsgLy90byBhbGxvdyBrZXkgZXZlbnRzXG5cbiAgICAgICAgLy9iZyBjYW52YXM6IHVzZWQgZm9yIG5vbiBjaGFuZ2luZyBzdHVmZlxuICAgICAgICB0aGlzLmJnY2FudmFzID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLmJnY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmJnY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIHRoaXMuYmdjYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuYmdjYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbnZhcy5nZXRDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjYW52YXMubG9jYWxOYW1lICE9IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkVsZW1lbnQgc3VwcGxpZWQgZm9yIExHcmFwaENhbnZhcyBtdXN0IGJlIGEgPGNhbnZhcz4gZWxlbWVudCwgeW91IHBhc3NlZCBhIFwiICtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBDYW52YXNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdHggPSAodGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKTtcbiAgICAgICAgaWYgKGN0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIWNhbnZhcy53ZWJnbF9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgY2FudmFzIHNlZW1zIHRvIGJlIFdlYkdMLCBlbmFibGluZyBXZWJHTCByZW5kZXJlclwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlV2ViR0woKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaW5wdXQ6ICAobW92ZSBhbmQgdXAgY291bGQgYmUgdW5iaW5kZWQpXG4gICAgICAgIHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayA9IHRoaXMucHJvY2Vzc01vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VzZXVwX2NhbGxiYWNrID0gdGhpcy5wcm9jZXNzTW91c2VVcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmICghc2tpcF9ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vdXNlZCBpbiBzb21lIGV2ZW50cyB0byBjYXB0dXJlIHRoZW1cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLl9kb05vdGhpbmcgPSBmdW5jdGlvbiBkb05vdGhpbmcoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuX2RvUmV0dXJuVHJ1ZSA9IGZ1bmN0aW9uIGRvTm90aGluZyhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGJpbmRzIG1vdXNlLCBrZXlib2FyZCwgdG91Y2ggYW5kIGRyYWcgZXZlbnRzIHRvIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIGJpbmRFdmVudHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNfYmluZGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJMR3JhcGhDYW52YXM6IGV2ZW50cyBhbHJlYWR5IGJpbmRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHJlZl93aW5kb3cuZG9jdW1lbnQ7IC8vaGFjayB1c2VkIHdoZW4gbW92aW5nIGNhbnZhcyBiZXR3ZWVuIHdpbmRvd3NcblxuICAgICAgICB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFjayA9IHRoaXMucHJvY2Vzc01vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdG91Y2hfY2FsbGJhY2sgPSB0aGlzLnRvdWNoSGFuZGxlci5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX21vdXNlZG93bl9jYWxsYmFjaywgdHJ1ZSk7IC8vZG93biBkbyBub3QgbmVlZCB0byBzdG9yZSB0aGUgYmluZGVkXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCB0aGlzLl9tb3VzZXdoZWVsX2NhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCB0aGlzLl9kb05vdGhpbmcpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiRE9NTW91c2VTY3JvbGxcIixcbiAgICAgICAgICAgIHRoaXMuX21vdXNld2hlZWxfY2FsbGJhY2ssXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vdG91Y2ggZXZlbnRzXG4gICAgICAgIC8vaWYoICd0b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaF9jYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vS2V5Ym9hcmQgKioqKioqKioqKioqKioqKioqXG4gICAgICAgIHRoaXMuX2tleV9jYWxsYmFjayA9IHRoaXMucHJvY2Vzc0tleS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlfY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fa2V5X2NhbGxiYWNrLCB0cnVlKTsgLy9pbiBkb2N1bWVudCwgb3RoZXJ3aXNlIGl0IGRvZXNuJ3QgZmlyZSBrZXl1cFxuXG4gICAgICAgIC8vRHJvcHBpbmcgU3R1ZmYgb3ZlciBub2RlcyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgdGhpcy5fb25kcm9wX2NhbGxiYWNrID0gdGhpcy5wcm9jZXNzRHJvcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5fZG9Ob3RoaW5nLCBmYWxzZSk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCB0aGlzLl9kb05vdGhpbmcsIGZhbHNlKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuX29uZHJvcF9jYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCB0aGlzLl9kb1JldHVyblRydWUsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9ldmVudHNfYmluZGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdW5iaW5kcyBtb3VzZSBldmVudHMgZnJvbSB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCB1bmJpbmRFdmVudHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNfYmluZGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJMR3JhcGhDYW52YXM6IG5vIGV2ZW50cyBiaW5kZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHJlZl93aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJtb3VzZXdoZWVsXCIsXG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsX2NhbGxiYWNrXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsX2NhbGxiYWNrXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleV9jYWxsYmFjayk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlfY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5fZG9Ob3RoaW5nKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5fb25kcm9wX2NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCB0aGlzLl9kb1JldHVyblRydWUpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrICk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2sgKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrICk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLl90b3VjaF9jYWxsYmFjayApO1xuXG4gICAgICAgIHRoaXMuX21vdXNlZG93bl9jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuX21vdXNld2hlZWxfY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXlfY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbmRyb3BfY2FsbGJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50c19iaW5kZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLmdldEZpbGVFeHRlbnNpb24gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIHF1ZXN0aW9uID0gdXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICBpZiAocXVlc3Rpb24gIT0gLTEpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHIoMCwgcXVlc3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb2ludCA9IHVybC5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgIGlmIChwb2ludCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC5zdWJzdHIocG9pbnQgKyAxKS50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGFsbG93cyB0byByZW5kZXIgdGhlIGNhbnZhcyB1c2luZyBXZWJHTCBpbnN0ZWFkIG9mIENhbnZhczJEXG4gICAgICogdGhpcyBpcyB1c2VmdWwgaWYgeW91IHBsYW50IHRvIHJlbmRlciAzRCBvYmplY3RzIGluc2lkZSB5b3VyIG5vZGVzLCBpdCB1c2VzIGxpdGVnbC5qcyBmb3Igd2ViZ2wgYW5kIGNhbnZhczJEdG9XZWJHTCB0byBlbXVsYXRlIHRoZSBDYW52YXMyRCBjYWxscyBpbiB3ZWJHTFxuICAgICAqIEBtZXRob2QgZW5hYmxlV2ViR0xcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5lbmFibGVXZWJHTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIEdMID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwibGl0ZWdsLmpzIG11c3QgYmUgaW5jbHVkZWQgdG8gdXNlIGEgV2ViR0wgY2FudmFzXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVXZWJHTENhbnZhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcIndlYmdsQ2FudmFzLmpzIG11c3QgYmUgaW5jbHVkZWQgdG8gdXNlIHRoaXMgZmVhdHVyZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IHRoaXMuY3R4ID0gZW5hYmxlV2ViR0xDYW52YXModGhpcy5jYW52YXMpO1xuICAgICAgICB0aGlzLmN0eC53ZWJnbCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmdjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgdGhpcy5iZ2N0eCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuY2FudmFzLndlYmdsX2VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8qXG5cdEdMLmNyZWF0ZSh7IGNhbnZhczogdGhpcy5iZ2NhbnZhcyB9KTtcblx0dGhpcy5iZ2N0eCA9IGVuYWJsZVdlYkdMQ2FudmFzKCB0aGlzLmJnY2FudmFzICk7XG5cdHdpbmRvdy5nbCA9IHRoaXMuZ2w7XG5cdCovXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1hcmtzIGFzIGRpcnR5IHRoZSBjYW52YXMsIHRoaXMgd2F5IGl0IHdpbGwgYmUgcmVuZGVyZWQgYWdhaW5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBMR3JhcGhDYW52YXNcbiAgICAgKiBAbWV0aG9kIHNldERpcnR5XG4gICAgICogQHBhcmFtIHtib29sfSBmZ2NhbnZhcyBpZiB0aGUgZm9yZWdyb3VuZCBjYW52YXMgaXMgZGlydHkgKHRoZSBvbmUgY29udGFpbmluZyB0aGUgbm9kZXMpXG4gICAgICogQHBhcmFtIHtib29sfSBiZ2NhbnZhcyBpZiB0aGUgYmFja2dyb3VuZCBjYW52YXMgaXMgZGlydHkgKHRoZSBvbmUgY29udGFpbmluZyB0aGUgd2lyZXMpXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uKGZnY2FudmFzLCBiZ2NhbnZhcykge1xuICAgICAgICBpZiAoZmdjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmdjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXR0YWNoIHRoZSBjYW52YXMgaW4gYSBwb3B1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDYW52YXNXaW5kb3dcbiAgICAgKiBAcmV0dXJuIHt3aW5kb3d9IHJldHVybnMgdGhlIHdpbmRvdyB3aGVyZSB0aGUgY2FudmFzIGlzIGF0dGFjaGVkICh0aGUgRE9NIHJvb3Qgbm9kZSlcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldENhbnZhc1dpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50O1xuICAgICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHN0YXJ0cyByZW5kZXJpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGNhbnZhcyB3aGVuIG5lZWRlZFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzdGFydFJlbmRlcmluZ1xuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc3RhcnRSZW5kZXJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfcmVuZGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy9hbHJlYWR5IHJlbmRlcmluZ1xuXG4gICAgICAgIHRoaXMuaXNfcmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyRnJhbWUuY2FsbCh0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJGcmFtZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXVzZV9yZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19yZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZyYW1lLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHN0b3BzIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiB0aGUgY2FudmFzICh0byBzYXZlIHJlc291cmNlcylcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3RvcFJlbmRlcmluZ1xuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc3RvcFJlbmRlcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzX3JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAvKlxuXHRpZih0aGlzLnJlbmRlcmluZ190aW1lcl9pZClcblx0e1xuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy5yZW5kZXJpbmdfdGltZXJfaWQpO1xuXHRcdHRoaXMucmVuZGVyaW5nX3RpbWVyX2lkID0gbnVsbDtcblx0fVxuXHQqL1xuICAgIH07XG5cbiAgICAvKiBMaXRlR3JhcGhDYW52YXMgaW5wdXQgKi9cblxuXHQvL3VzZWQgdG8gYmxvY2sgZnV0dXJlIG1vdXNlIGV2ZW50cyAoYmVjYXVzZSBvZiBpbSBndWkpXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuYmxvY2tDbGljayA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHRoaXMuYmxvY2tfY2xpY2sgPSB0cnVlO1xuXHRcdHRoaXMubGFzdF9tb3VzZWNsaWNrID0gMDtcblx0fVxuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuXG5cdFx0aWYoIHRoaXMuc2V0X2NhbnZhc19kaXJ0eV9vbl9tb3VzZV9ldmVudCApXG5cdFx0XHR0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cdFx0XG5cdFx0aWYgKCF0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkanVzdE1vdXNlRXZlbnQoZSk7XG5cbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSB0aGlzLmdldENhbnZhc1dpbmRvdygpO1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSByZWZfd2luZG93LmRvY3VtZW50O1xuICAgICAgICBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcyA9IHRoaXM7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHZhciB4ID0gZS5sb2NhbFg7XG5cdFx0dmFyIHkgPSBlLmxvY2FsWTtcblx0XHQvL2NvbnNvbGUubG9nKHksdGhpcy52aWV3cG9ydCk7XG5cblx0XHR0aGlzLmRzLnZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydDtcblx0XHR2YXIgaXNfaW5zaWRlID0gIXRoaXMudmlld3BvcnQgfHwgKCB0aGlzLnZpZXdwb3J0ICYmIHggPj0gdGhpcy52aWV3cG9ydFswXSAmJiB4IDwgKHRoaXMudmlld3BvcnRbMF0gKyB0aGlzLnZpZXdwb3J0WzJdKSAmJiB5ID49IHRoaXMudmlld3BvcnRbMV0gJiYgeSA8ICh0aGlzLnZpZXdwb3J0WzFdICsgdGhpcy52aWV3cG9ydFszXSkgKTtcblxuICAgICAgICAvL21vdmUgbW91c2UgbW92ZSBldmVudCB0byB0aGUgd2luZG93IGluIGNhc2UgaXQgZHJhZ3Mgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG5cdFx0aWYoIXRoaXMub3B0aW9ucy5za2lwX2V2ZW50cylcblx0XHR7XG5cdFx0XHR0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayk7XG5cdFx0XHRyZWZfd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjaywgdHJ1ZSApOyAvL2NhdGNoIGZvciB0aGUgZW50aXJlIHdpbmRvd1xuXHRcdFx0cmVmX3dpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIm1vdXNldXBcIiwgdGhpcy5fbW91c2V1cF9jYWxsYmFjaywgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGlmKCFpc19pbnNpZGUpXG5cdFx0XHRyZXR1cm47XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyggZS5jYW52YXNYLCBlLmNhbnZhc1ksIHRoaXMudmlzaWJsZV9ub2RlcywgNSApO1xuICAgICAgICB2YXIgc2tpcF9kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB2YXIgc2tpcF9hY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIG5vdyA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBpc19kb3VibGVfY2xpY2sgPSBub3cgLSB0aGlzLmxhc3RfbW91c2VjbGljayA8IDMwMDtcblx0XHR0aGlzLm1vdXNlWzBdID0gZS5sb2NhbFg7XG5cdFx0dGhpcy5tb3VzZVsxXSA9IGUubG9jYWxZO1xuICAgICAgICB0aGlzLmdyYXBoX21vdXNlWzBdID0gZS5jYW52YXNYO1xuICAgICAgICB0aGlzLmdyYXBoX21vdXNlWzFdID0gZS5jYW52YXNZO1xuXHRcdHRoaXMubGFzdF9jbGlja19wb3NpdGlvbiA9IFt0aGlzLm1vdXNlWzBdLHRoaXMubW91c2VbMV1dO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLmZvY3VzKCk7XG5cbiAgICAgICAgTGl0ZUdyYXBoLmNsb3NlQWxsQ29udGV4dE1lbnVzKHJlZl93aW5kb3cpO1xuXG4gICAgICAgIGlmICh0aGlzLm9uTW91c2UpXG5cdFx0e1xuICAgICAgICAgICAgaWYgKHRoaXMub25Nb3VzZShlKSA9PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0Ly9sZWZ0IGJ1dHRvbiBtb3VzZVxuICAgICAgICBpZiAoZS53aGljaCA9PSAxKVxuXHRcdHtcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpXG5cdFx0XHR7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdID0gZS5jYW52YXNYO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdID0gZS5jYW52YXNZO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzJdID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVszXSA9IDE7XG4gICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xpY2tpbmdfY2FudmFzX2JnID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vd2hlbiBjbGlja2VkIG9uIHRvcCBvZiBhIG5vZGVcbiAgICAgICAgICAgIC8vYW5kIGl0IGlzIG5vdCBpbnRlcmFjdGl2ZVxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgdGhpcy5hbGxvd19pbnRlcmFjdGlvbiAmJiAhc2tpcF9hY3Rpb24gJiYgIXRoaXMucmVhZF9vbmx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxpdmVfbW9kZSAmJiAhbm9kZS5mbGFncy5waW5uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5icmluZ1RvRnJvbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgfSAvL2lmIGl0IHdhc24ndCBzZWxlY3RlZD9cblxuICAgICAgICAgICAgICAgIC8vbm90IGRyYWdnaW5nIG1vdXNlIHRvIGNvbm5lY3QgdHdvIHNsb3RzXG4gICAgICAgICAgICAgICAgaWYgKCAhdGhpcy5jb25uZWN0aW5nX25vZGUgJiYgIW5vZGUuZmxhZ3MuY29sbGFwc2VkICYmICF0aGlzLmxpdmVfbW9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9TZWFyY2ggZm9yIGNvcm5lciBmb3IgcmVzaXplXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICFza2lwX2FjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZXNpemFibGUgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdICsgbm9kZS5zaXplWzBdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSArIG5vZGUuc2l6ZVsxXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1x0XHRcdFx0XHRcdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemluZ19ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwic2UtcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwX2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlYXJjaCBmb3Igb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX3BvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyhmYWxzZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3MgPSBub2RlLmdldENvbm5lY3Rpb25Qb3MoIGZhbHNlLCBpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfc2xvdCA9IGk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0T3V0cHV0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZG91YmxlX2NsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25PdXRwdXREYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uT3V0cHV0RGJsQ2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbk91dHB1dENsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25PdXRwdXRDbGljayhpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlYXJjaCBmb3IgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBub2RlLmlucHV0cy5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19wb3MgPSBub2RlLmdldENvbm5lY3Rpb25Qb3ModHJ1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2RvdWJsZV9jbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uSW5wdXREYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uSW5wdXREYmxDbGljayhpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uSW5wdXRDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uSW5wdXRDbGljayhpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5saW5rICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdOyAvL2JlZm9yZSBkaXNjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0SW5wdXQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dfcmVjb25uZWN0X2xpbmtzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc2hpZnRLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUgPSB0aGlzLmdyYXBoLl9ub2Rlc19ieV9pZFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby5vcmlnaW5faWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLm9yaWdpbl9zbG90O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0ID0gdGhpcy5jb25uZWN0aW5nX25vZGUub3V0cHV0c1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3MgPSB0aGlzLmNvbm5lY3Rpbmdfbm9kZS5nZXRDb25uZWN0aW9uUG9zKCBmYWxzZSwgdGhpcy5jb25uZWN0aW5nX3Nsb3QgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy9ub3QgcmVzaXppbmdcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2l0IHdhc24ndCBjbGlja2VkIG9uIHRoZSBsaW5rcyBib3hlc1xuICAgICAgICAgICAgICAgIGlmICghc2tpcF9hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrX2RyYWdfbm9kZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBwb3MgPSBbZS5jYW52YXNYIC0gbm9kZS5wb3NbMF0sIGUuY2FudmFzWSAtIG5vZGUucG9zWzFdXTtcblxuICAgICAgICAgICAgICAgICAgICAvL3dpZGdldHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMucHJvY2Vzc05vZGVXaWRnZXRzKCBub2RlLCB0aGlzLmdyYXBoX21vdXNlLCBlICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2RyYWdfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0ID0gW25vZGUsIHdpZGdldF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2RvdWJsZSBjbGlja2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZG91YmxlX2NsaWNrICYmIHRoaXMuc2VsZWN0ZWRfbm9kZXNbbm9kZS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZG91YmxlIGNsaWNrIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uRGJsQ2xpY2soIGUsIHBvcywgdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTm9kZURibENsaWNrZWQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja19kcmFnX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBkbyBub3QgY2FwdHVyZSBtb3VzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUub25Nb3VzZURvd24gJiYgbm9kZS5vbk1vdXNlRG93biggZSwgcG9zLCB0aGlzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja19kcmFnX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly9vcGVuIHN1YmdyYXBoIGJ1dHRvblxuXHRcdFx0XHRcdFx0aWYobm9kZS5zdWJncmFwaCAmJiAhbm9kZS5za2lwX3N1YmdyYXBoX2J1dHRvbilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhbm9kZS5mbGFncy5jb2xsYXBzZWQgJiYgcG9zWzBdID4gbm9kZS5zaXplWzBdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICYmIHBvc1sxXSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGF0Lm9wZW5TdWJncmFwaChub2RlLnN1YmdyYXBoKTtcblx0XHRcdFx0XHRcdFx0XHR9LCAxMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMubGl2ZV9tb2RlKSB7XG5cdFx0XHRcdFx0XHRcdGNsaWNraW5nX2NhbnZhc19iZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2RyYWdfbm9kZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrX2RyYWdfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dfZHJhZ25vZGVzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTm9kZVNlbGVjdGVkKG5vZGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy9jbGlja2VkIG91dHNpZGUgb2Ygbm9kZXNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vc2VhcmNoIGZvciBsaW5rIGNvbm5lY3RvclxuXHRcdFx0XHRpZighdGhpcy5yZWFkX29ubHkpIFxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aXNpYmxlX2xpbmtzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGluayA9IHRoaXMudmlzaWJsZV9saW5rc1tpXTtcblx0XHRcdFx0XHRcdHZhciBjZW50ZXIgPSBsaW5rLl9wb3M7XG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdCFjZW50ZXIgfHxcblx0XHRcdFx0XHRcdFx0ZS5jYW52YXNYIDwgY2VudGVyWzBdIC0gNCB8fFxuXHRcdFx0XHRcdFx0XHRlLmNhbnZhc1ggPiBjZW50ZXJbMF0gKyA0IHx8XG5cdFx0XHRcdFx0XHRcdGUuY2FudmFzWSA8IGNlbnRlclsxXSAtIDQgfHxcblx0XHRcdFx0XHRcdFx0ZS5jYW52YXNZID4gY2VudGVyWzFdICsgNFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9saW5rIGNsaWNrZWRcblx0XHRcdFx0XHRcdHRoaXMuc2hvd0xpbmtNZW51KGxpbmssIGUpO1xuXHRcdFx0XHRcdFx0dGhpcy5vdmVyX2xpbmtfY2VudGVyID0gbnVsbDsgLy9jbGVhciB0b29sdGlwXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwID0gdGhpcy5ncmFwaC5nZXRHcm91cE9uUG9zKCBlLmNhbnZhc1gsIGUuY2FudmFzWSApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXBfcmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ncm91cCAmJiAhdGhpcy5yZWFkX29ubHkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gZGlzdGFuY2UoIFtlLmNhbnZhc1gsIGUuY2FudmFzWV0sIFsgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMF0gKyB0aGlzLnNlbGVjdGVkX2dyb3VwLnNpemVbMF0sIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzFdICsgdGhpcy5zZWxlY3RlZF9ncm91cC5zaXplWzFdIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgKiB0aGlzLmRzLnNjYWxlIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXBfcmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5yZWNvbXB1dGVJbnNpZGVOb2RlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzX2RvdWJsZV9jbGljayAmJiAhdGhpcy5yZWFkX29ubHkgJiYgdGhpcy5hbGxvd19zZWFyY2hib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoQm94KGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsaWNraW5nX2NhbnZhc19iZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2tpcF9hY3Rpb24gJiYgY2xpY2tpbmdfY2FudmFzX2JnICYmIHRoaXMuYWxsb3dfZHJhZ2NhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDIpIHtcbiAgICAgICAgICAgIC8vbWlkZGxlIGJ1dHRvblxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMykge1xuICAgICAgICAgICAgLy9yaWdodCBidXR0b25cblx0XHRcdGlmKCF0aGlzLnJlYWRfb25seSlcblx0ICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29udGV4dE1lbnUobm9kZSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE9cbiAgICAgICAgLy9pZih0aGlzLm5vZGVfc2VsZWN0ZWQgIT0gcHJldl9zZWxlY3RlZClcbiAgICAgICAgLy9cdHRoaXMub25Ob2RlU2VsZWN0aW9uQ2hhbmdlKHRoaXMubm9kZV9zZWxlY3RlZCk7XG5cbiAgICAgICAgdGhpcy5sYXN0X21vdXNlWzBdID0gZS5sb2NhbFg7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVsxXSA9IGUubG9jYWxZO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VjbGljayA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLypcblx0aWYoICh0aGlzLmRpcnR5X2NhbnZhcyB8fCB0aGlzLmRpcnR5X2JnY2FudmFzKSAmJiB0aGlzLnJlbmRlcmluZ190aW1lcl9pZCA9PSBudWxsKVxuXHRcdHRoaXMuZHJhdygpO1xuXHQqL1xuXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgLy90aGlzIGlzIHRvIGVuc3VyZSB0byBkZWZvY3VzKGJsdXIpIGlmIGEgdGV4dCBpbnB1dCBlbGVtZW50IGlzIG9uIGZvY3VzXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFyZWZfd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHxcbiAgICAgICAgICAgIChyZWZfd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPVxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIiAmJlxuICAgICAgICAgICAgICAgIHJlZl93aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9XG4gICAgICAgICAgICAgICAgICAgIFwidGV4dGFyZWFcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5vbk1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBtb3VzZSBtb3ZlIGV2ZW50IGhhcyB0byBiZSBwcm9jZXNzZWRcbiAgICAgKiBAbWV0aG9kIHByb2Nlc3NNb3VzZU1vdmVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5hdXRvcmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG5cblx0XHRpZiggdGhpcy5zZXRfY2FudmFzX2RpcnR5X29uX21vdXNlX2V2ZW50IClcblx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzID0gdGhpcztcbiAgICAgICAgdGhpcy5hZGp1c3RNb3VzZUV2ZW50KGUpO1xuICAgICAgICB2YXIgbW91c2UgPSBbZS5sb2NhbFgsIGUubG9jYWxZXTtcblx0XHR0aGlzLm1vdXNlWzBdID0gbW91c2VbMF07XG5cdFx0dGhpcy5tb3VzZVsxXSA9IG1vdXNlWzFdO1xuICAgICAgICB2YXIgZGVsdGEgPSBbXG4gICAgICAgICAgICBtb3VzZVswXSAtIHRoaXMubGFzdF9tb3VzZVswXSxcbiAgICAgICAgICAgIG1vdXNlWzFdIC0gdGhpcy5sYXN0X21vdXNlWzFdXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZSA9IG1vdXNlO1xuICAgICAgICB0aGlzLmdyYXBoX21vdXNlWzBdID0gZS5jYW52YXNYO1xuICAgICAgICB0aGlzLmdyYXBoX21vdXNlWzFdID0gZS5jYW52YXNZO1xuXG5cdFx0aWYodGhpcy5ibG9ja19jbGljaylcblx0XHR7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG4gICAgICAgIGUuZHJhZ2dpbmcgPSB0aGlzLmxhc3RfbW91c2VfZHJhZ2dpbmc7XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZV93aWRnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05vZGVXaWRnZXRzKFxuICAgICAgICAgICAgICAgIHRoaXMubm9kZV93aWRnZXRbMF0sXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaF9tb3VzZSxcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgIHRoaXMubm9kZV93aWRnZXRbMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUpXG5cdFx0e1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMl0gPSBlLmNhbnZhc1ggLSB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVswXTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzNdID0gZS5jYW52YXNZIC0gdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMV07XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgIH0gXG5cdFx0ZWxzZSBpZiAodGhpcy5zZWxlY3RlZF9ncm91cCAmJiAhdGhpcy5yZWFkX29ubHkpXG5cdFx0e1xuICAgICAgICAgICAgLy9tb3ZpbmcvcmVzaXppbmcgYSBncm91cFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfZ3JvdXBfcmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnNpemUgPSBbXG4gICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCAtIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1kgLSB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1sxXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBkZWx0YVswXSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRheSA9IGRlbHRhWzFdIC8gdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLm1vdmUoZGVsdGF4LCBkZWx0YXksIGUuY3RybEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfZ3JvdXAuX25vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZ19jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZHMub2Zmc2V0WzBdICs9IGRlbHRhWzBdIC8gdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZHMub2Zmc2V0WzFdICs9IGRlbHRhWzFdIC8gdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gJiYgIXRoaXMucmVhZF9vbmx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX25vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZ2V0IG5vZGUgb3ZlclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyhlLmNhbnZhc1gsZS5jYW52YXNZLHRoaXMudmlzaWJsZV9ub2Rlcyk7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIG1vdXNlb3ZlciBmbGFnXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuZ3JhcGguX25vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoLl9ub2Rlc1tpXS5tb3VzZU92ZXIgJiYgbm9kZSAhPSB0aGlzLmdyYXBoLl9ub2Rlc1tpXSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9tb3VzZSBsZWF2ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLl9ub2Rlc1tpXS5tb3VzZU92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZV9vdmVyICYmIHRoaXMubm9kZV9vdmVyLm9uTW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX292ZXIub25Nb3VzZUxlYXZlKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9vdmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9tb3VzZSBvdmVyIGEgbm9kZVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcblxuXHRcdFx0XHRpZihub2RlLnJlZHJhd19vbl9tb3VzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy90aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUubW91c2VPdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbW91c2UgZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb3VzZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfb3ZlciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbk1vdXNlRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pbiBjYXNlIHRoZSBub2RlIHdhbnRzIHRvIGRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUub25Nb3VzZU1vdmUoIGUsIFtlLmNhbnZhc1ggLSBub2RlLnBvc1swXSwgZS5jYW52YXNZIC0gbm9kZS5wb3NbMV1dLCB0aGlzICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBkcmFnZ2luZyBhIGxpbmtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuX2hpZ2hsaWdodF9pbnB1dCB8fCBbMCwgMF07IC8vdG8gc3RvcmUgdGhlIG91dHB1dCBvZiBpc092ZXJOb2RlSW5wdXRcblxuICAgICAgICAgICAgICAgICAgICAvL29uIHRvcCBvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc092ZXJOb2RlQm94KG5vZGUsIGUuY2FudmFzWCwgZS5jYW52YXNZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9tb3VzZSBvbiB0b3Agb2YgdGhlIGNvcm5lciBib3gsIGRvbid0IGtub3cgd2hhdCB0byBkb1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBJIGhhdmUgYSBzbG90IGJlbG93IGRlIG1vdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuaXNPdmVyTm9kZUlucHV0KCBub2RlLCBlLmNhbnZhc1gsIGUuY2FudmFzWSwgcG9zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCAhPSAtMSAmJiBub2RlLmlucHV0c1tzbG90XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90X3R5cGUgPSBub2RlLmlucHV0c1tzbG90XS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggTGl0ZUdyYXBoLmlzVmFsaWRDb25uZWN0aW9uKCB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnR5cGUsIHNsb3RfdHlwZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodF9pbnB1dF9zbG90ID0gbm9kZS5pbnB1dHNbc2xvdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodF9pbnB1dF9zbG90ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vU2VhcmNoIGZvciBjb3JuZXJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1swXSArIG5vZGUuc2l6ZVswXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gKyBub2RlLnNpemVbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwic2UtcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcImNyb3NzaGFpclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy9ub3Qgb3ZlciBhIG5vZGVcblxuICAgICAgICAgICAgICAgIC8vc2VhcmNoIGZvciBsaW5rIGNvbm5lY3RvclxuXHRcdFx0XHR2YXIgb3Zlcl9saW5rID0gbnVsbDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpc2libGVfbGlua3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHR2YXIgbGluayA9IHRoaXMudmlzaWJsZV9saW5rc1tpXTtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gbGluay5fcG9zO1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdCFjZW50ZXIgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWCA8IGNlbnRlclswXSAtIDQgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWCA+IGNlbnRlclswXSArIDQgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWSA8IGNlbnRlclsxXSAtIDQgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWSA+IGNlbnRlclsxXSArIDRcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvdmVyX2xpbmsgPSBsaW5rO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCBvdmVyX2xpbmsgIT0gdGhpcy5vdmVyX2xpbmtfY2VudGVyIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMub3Zlcl9saW5rX2NlbnRlciA9IG92ZXJfbGluaztcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmNhbnZhcykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL2VuZFxuXG5cdFx0XHQvL3NlbmQgZXZlbnQgdG8gbm9kZSBpZiBjYXB0dXJpbmcgaW5wdXQgKHVzZWQgd2l0aCB3aWRnZXRzIHRoYXQgYWxsb3cgZHJhZyBvdXRzaWRlIG9mIHRoZSBhcmVhIG9mIHRoZSBub2RlKVxuICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0ICYmIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQgIT0gbm9kZSAmJiB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0Lm9uTW91c2VNb3ZlICkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQub25Nb3VzZU1vdmUoZSxbZS5jYW52YXNYIC0gdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5wb3NbMF0sZS5jYW52YXNZIC0gdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5wb3NbMV1dLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly9ub2RlIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVfZHJhZ2dlZCAmJiAhdGhpcy5saXZlX21vZGUpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcImRyYWdnaW4hXCIsdGhpcy5zZWxlY3RlZF9ub2Rlcyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5zZWxlY3RlZF9ub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbi5wb3NbMF0gKz0gZGVsdGFbMF0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBuLnBvc1sxXSArPSBkZWx0YVsxXSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNpemluZ19ub2RlICYmICF0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBtb3VzZSB0byBub2RlIHNwYWNlXG5cdFx0XHRcdHZhciBkZXNpcmVkX3NpemUgPSBbIGUuY2FudmFzWCAtIHRoaXMucmVzaXppbmdfbm9kZS5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucmVzaXppbmdfbm9kZS5wb3NbMV0gXTtcblx0XHRcdFx0dmFyIG1pbl9zaXplID0gdGhpcy5yZXNpemluZ19ub2RlLmNvbXB1dGVTaXplKCk7XG5cdFx0XHRcdGRlc2lyZWRfc2l6ZVswXSA9IE1hdGgubWF4KCBtaW5fc2l6ZVswXSwgZGVzaXJlZF9zaXplWzBdICk7XG5cdFx0XHRcdGRlc2lyZWRfc2l6ZVsxXSA9IE1hdGgubWF4KCBtaW5fc2l6ZVsxXSwgZGVzaXJlZF9zaXplWzFdICk7XG5cdFx0XHRcdHRoaXMucmVzaXppbmdfbm9kZS5zZXRTaXplKCBkZXNpcmVkX3NpemUgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwic2UtcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgbW91c2UgdXAgZXZlbnQgaGFzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAqIEBtZXRob2QgcHJvY2Vzc01vdXNlVXBcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdGlmKCB0aGlzLnNldF9jYW52YXNfZGlydHlfb25fbW91c2VfZXZlbnQgKVxuXHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5ncmFwaClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgd2luZG93ID0gdGhpcy5nZXRDYW52YXNXaW5kb3coKTtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgICAgICBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcyA9IHRoaXM7XG5cbiAgICAgICAgLy9yZXN0b3JlIHRoZSBtb3VzZW1vdmUgZXZlbnQgYmFjayB0byB0aGUgY2FudmFzXG5cdFx0aWYoIXRoaXMub3B0aW9ucy5za2lwX2V2ZW50cylcblx0XHR7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5fbW91c2Vtb3ZlX2NhbGxiYWNrLHRydWUpO1xuXHRcdFx0dGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayx0cnVlKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX21vdXNldXBfY2FsbGJhY2ssIHRydWUpO1xuXHRcdH1cblxuICAgICAgICB0aGlzLmFkanVzdE1vdXNlRXZlbnQoZSk7XG4gICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICBlLmNsaWNrX3RpbWUgPSBub3cgLSB0aGlzLmxhc3RfbW91c2VjbGljaztcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlX2RyYWdnaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5sYXN0X2NsaWNrX3Bvc2l0aW9uID0gbnVsbDtcblxuXHRcdGlmKHRoaXMuYmxvY2tfY2xpY2spXG5cdFx0e1xuXHRcdFx0Y29uc29sZS5sb2coXCJmb29cIik7XG5cdFx0XHR0aGlzLmJsb2NrX2NsaWNrID0gZmFsc2U7IC8vdXNlZCB0byBhdm9pZCBzZW5kaW5nIHR3aWNlIGEgY2xpY2sgaW4gYSBpbW1lZGlhdGUgYnV0dG9uXG5cdFx0fVxuXG4gICAgICAgIGlmIChlLndoaWNoID09IDEpIHtcblxuXHRcdFx0aWYoIHRoaXMubm9kZV93aWRnZXQgKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnByb2Nlc3NOb2RlV2lkZ2V0cyggdGhpcy5ub2RlX3dpZGdldFswXSwgdGhpcy5ncmFwaF9tb3VzZSwgZSApO1xuXHRcdFx0fVxuXG4gICAgICAgICAgICAvL2xlZnQgYnV0dG9uXG4gICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZnggPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1swXSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmeSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzFdIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5tb3ZlKGRpZmZ4LCBkaWZmeSwgZS5jdHJsS2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1swXSA9IE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzBdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1sxXSA9IE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzFdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ncm91cC5fbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwX3Jlc2l6aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZV9ib3VuZGluZyA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGxOb2RlcygpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgYm91bmRpbmcgYW5kIGZsaXAgaWYgbGVmdCB0byByaWdodFxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IE1hdGguYWJzKHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBNYXRoLmFicyh0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVszXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydHggPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMl0gPCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVswXSAtIHdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnR5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzNdIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMV0gLSBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMF0gPSBzdGFydHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdID0gc3RhcnR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsyXSA9IHc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzNdID0gaDtcblxuICAgICAgICAgICAgICAgICAgICAvL3Rlc3QgYWdhaW5zdCBhbGwgbm9kZXMgKG5vdCB2aXNpYmxlIGJlY2F1c2UgdGhlIHJlY3RhbmdsZSBtYXliZSBzdGFydCBvdXRzaWRlXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b19zZWxlY3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZ2V0Qm91bmRpbmcobm9kZV9ib3VuZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW92ZXJsYXBCb3VuZGluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfYm91bmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9vdXQgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9fc2VsZWN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvX3NlbGVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZXModG9fc2VsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9kcmFnZ2luZyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZU9uUG9zKFxuICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX25vZGVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vbm9kZSBiZWxvdyBtb3VzZVxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQudHlwZSA9PSBMaXRlR3JhcGguRVZFTlQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNPdmVyTm9kZUJveChub2RlLCBlLmNhbnZhc1gsIGUuY2FudmFzWSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfbm9kZS5jb25uZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLkVWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zbG90IGJlbG93IG1vdXNlPyBjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuaXNPdmVyTm9kZUlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUuY29ubmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vdCBvbiB0b3Agb2YgYW4gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmdldElucHV0SW5mbygwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2F1dG8gY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dC50eXBlID09IExpdGVHcmFwaC5FVkVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfbm9kZS5jb25uZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLkVWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlucHV0LmxpbmsgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLmlzVmFsaWRDb25uZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudHlwZSAmJiB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfbm9kZS5jb25uZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfc2xvdCA9IC0xO1xuICAgICAgICAgICAgfSAvL25vdCBkcmFnZ2luZyBjb25uZWN0aW9uXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJlc2l6aW5nX25vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZ3JhcGguYWZ0ZXJDaGFuZ2UodGhpcy5yZXNpemluZ19ub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6aW5nX25vZGUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5vZGVfZHJhZ2dlZCkge1xuICAgICAgICAgICAgICAgIC8vbm9kZSBiZWluZyBkcmFnZ2VkP1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlX2RyYWdnZWQ7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBub2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGUuY2xpY2tfdGltZSA8IDMwMCAmJlxuICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZSggZS5jYW52YXNYLCBlLmNhbnZhc1ksIG5vZGUucG9zWzBdLCBub2RlLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCwgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hULCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkLnBvc1swXSA9IE1hdGgucm91bmQodGhpcy5ub2RlX2RyYWdnZWQucG9zWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMV0gPSBNYXRoLnJvdW5kKHRoaXMubm9kZV9kcmFnZ2VkLnBvc1sxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGguY29uZmlnLmFsaWduX3RvX2dyaWQgfHwgdGhpcy5hbGlnbl90b19ncmlkICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZC5hbGlnblRvR3JpZCgpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0aWYoIHRoaXMub25Ob2RlTW92ZWQgKVxuXHRcdFx0XHRcdHRoaXMub25Ob2RlTW92ZWQoIHRoaXMubm9kZV9kcmFnZ2VkICk7XG5cdFx0XHRcdHRoaXMuZ3JhcGguYWZ0ZXJDaGFuZ2UodGhpcy5ub2RlX2RyYWdnZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkID0gbnVsbDtcbiAgICAgICAgICAgIH0gLy9ubyBub2RlIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZ2V0IG5vZGUgb3ZlclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlT25Qb3MoXG4gICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfbm9kZXNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlICYmIGUuY2xpY2tfdGltZSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0QWxsTm9kZXMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19jYW52YXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVfb3ZlciAmJiB0aGlzLm5vZGVfb3Zlci5vbk1vdXNlVXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX292ZXIub25Nb3VzZVVwKCBlLCBbIGUuY2FudmFzWCAtIHRoaXMubm9kZV9vdmVyLnBvc1swXSwgZS5jYW52YXNZIC0gdGhpcy5ub2RlX292ZXIucG9zWzFdIF0sIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQub25Nb3VzZVVwXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQub25Nb3VzZVVwKGUsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCAtIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQucG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZIC0gdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5wb3NbMV1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMikge1xuICAgICAgICAgICAgLy9taWRkbGUgYnV0dG9uXG4gICAgICAgICAgICAvL3RyYWNlKFwibWlkZGxlXCIpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19jYW52YXMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDMpIHtcbiAgICAgICAgICAgIC8vcmlnaHQgYnV0dG9uXG4gICAgICAgICAgICAvL3RyYWNlKFwicmlnaHRcIik7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcblx0aWYoKHRoaXMuZGlydHlfY2FudmFzIHx8IHRoaXMuZGlydHlfYmdjYW52YXMpICYmIHRoaXMucmVuZGVyaW5nX3RpbWVyX2lkID09IG51bGwpXG5cdFx0dGhpcy5kcmF3KCk7XG5cdCovXG5cbiAgICAgICAgdGhpcy5ncmFwaC5jaGFuZ2UoKTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBtb3VzZSB3aGVlbCBldmVudCBoYXMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICogQG1ldGhvZCBwcm9jZXNzTW91c2VXaGVlbFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NNb3VzZVdoZWVsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGggfHwgIXRoaXMuYWxsb3dfZHJhZ2NhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gZS53aGVlbERlbHRhWSAhPSBudWxsID8gZS53aGVlbERlbHRhWSA6IGUuZGV0YWlsICogLTYwO1xuXG4gICAgICAgIHRoaXMuYWRqdXN0TW91c2VFdmVudChlKTtcblxuXHRcdHZhciB4ID0gZS5sb2NhbFg7XG5cdFx0dmFyIHkgPSBlLmxvY2FsWTtcblx0XHR2YXIgaXNfaW5zaWRlID0gIXRoaXMudmlld3BvcnQgfHwgKCB0aGlzLnZpZXdwb3J0ICYmIHggPj0gdGhpcy52aWV3cG9ydFswXSAmJiB4IDwgKHRoaXMudmlld3BvcnRbMF0gKyB0aGlzLnZpZXdwb3J0WzJdKSAmJiB5ID49IHRoaXMudmlld3BvcnRbMV0gJiYgeSA8ICh0aGlzLnZpZXdwb3J0WzFdICsgdGhpcy52aWV3cG9ydFszXSkgKTtcblx0XHRpZighaXNfaW5zaWRlKVxuXHRcdFx0cmV0dXJuO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZHMuc2NhbGU7XG5cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgc2NhbGUgKj0gMS4xO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgc2NhbGUgKj0gMSAvIDEuMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcy5zZXRab29tKCBzY2FsZSwgWyBlLmxvY2FsWCwgZS5sb2NhbFkgXSApO1xuICAgICAgICB0aGlzLmRzLmNoYW5nZVNjYWxlKHNjYWxlLCBbZS5sb2NhbFgsIGUubG9jYWxZXSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaC5jaGFuZ2UoKTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gcHJldmVudCBkZWZhdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdHJ1ZSBpZiBhIHBvc2l0aW9uIChpbiBncmFwaCBzcGFjZSkgaXMgb24gdG9wIG9mIGEgbm9kZSBsaXR0bGUgY29ybmVyIGJveFxuICAgICAqIEBtZXRob2QgaXNPdmVyTm9kZUJveFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmlzT3Zlck5vZGVCb3ggPSBmdW5jdGlvbihub2RlLCBjYW52YXN4LCBjYW52YXN5KSB7XG4gICAgICAgIHZhciB0aXRsZV9oZWlnaHQgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgIGNhbnZhc3gsXG4gICAgICAgICAgICAgICAgY2FudmFzeSxcbiAgICAgICAgICAgICAgICBub2RlLnBvc1swXSArIDIsXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gKyAyIC0gdGl0bGVfaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAtIDQsXG4gICAgICAgICAgICAgICAgdGl0bGVfaGVpZ2h0IC0gNFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0cnVlIGlmIGEgcG9zaXRpb24gKGluIGdyYXBoIHNwYWNlKSBpcyBvbiB0b3Agb2YgYSBub2RlIGlucHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGlzT3Zlck5vZGVJbnB1dFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmlzT3Zlck5vZGVJbnB1dCA9IGZ1bmN0aW9uKFxuICAgICAgICBub2RlLFxuICAgICAgICBjYW52YXN4LFxuICAgICAgICBjYW52YXN5LFxuICAgICAgICBzbG90X3Bvc1xuICAgICkge1xuICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGkpO1xuICAgICAgICAgICAgICAgIHZhciBpc19pbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX2luc2lkZSA9IGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1swXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAyMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX2luc2lkZSA9IGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1swXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90X3Bvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdF9wb3NbMF0gPSBsaW5rX3Bvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RfcG9zWzFdID0gbGlua19wb3NbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcHJvY2VzcyBhIGtleSBldmVudFxuICAgICAqIEBtZXRob2QgcHJvY2Vzc0tleVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NLZXkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJsb2NrX2RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhlKTsgLy9kZWJ1Z1xuXG4gICAgICAgIGlmIChlLnRhcmdldC5sb2NhbE5hbWUgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09IFwia2V5ZG93blwiKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgICAgICAgICAgLy9lc2NcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmxvY2tfZGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2VsZWN0IGFsbCBDb250cm9sIEFcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gNjUgJiYgZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlcygpO1xuICAgICAgICAgICAgICAgIGJsb2NrX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5jb2RlID09IFwiS2V5Q1wiICYmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIC8vY29weVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29weVRvQ2xpcGJvYXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PSBcIktleVZcIiAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvL3Bhc3RlXG4gICAgICAgICAgICAgICAgdGhpcy5wYXN0ZUZyb21DbGlwYm9hcmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kZWxldGUgb3IgYmFja3NwYWNlXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDQ2IHx8IGUua2V5Q29kZSA9PSA4KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJpbnB1dFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmxvY2FsTmFtZSAhPSBcInRleHRhcmVhXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVTZWxlY3RlZE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jb2xsYXBzZVxuICAgICAgICAgICAgLy8uLi5cblxuICAgICAgICAgICAgLy9UT0RPXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlc1tpXS5vbktleURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV0ub25LZXlEb3duKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBcImtleXVwXCIpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlc1tpXS5vbktleVVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX25vZGVzW2ldLm9uS2V5VXAoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyYXBoLmNoYW5nZSgpO1xuXG4gICAgICAgIGlmIChibG9ja19kZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29weVRvQ2xpcGJvYXJkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbGlwYm9hcmRfaW5mbyA9IHtcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIGxpbmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgc2VsZWN0ZWRfbm9kZXNfYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLl9yZWxhdGl2ZV9pZCA9IGluZGV4O1xuICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZXNfYXJyYXkucHVzaChub2RlKTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkX25vZGVzX2FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdGVkX25vZGVzX2FycmF5W2ldO1xuXHRcdFx0dmFyIGNsb25lZCA9IG5vZGUuY2xvbmUoKTtcblx0XHRcdGlmKCFjbG9uZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnNvbGUud2FybihcIm5vZGUgdHlwZSBub3QgZm91bmQ6IFwiICsgbm9kZS50eXBlICk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuICAgICAgICAgICAgY2xpcGJvYXJkX2luZm8ubm9kZXMucHVzaChjbG9uZWQuc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzICYmIG5vZGUuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQgfHwgaW5wdXQubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaC5saW5rc1tpbnB1dC5saW5rXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8ub3JpZ2luX2lkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0X25vZGUgfHwgIXRoaXMuc2VsZWN0ZWRfbm9kZXNbdGFyZ2V0X25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ltcHJvdmUgdGhpcyBieSBhbGxvd2luZyBjb25uZWN0aW9ucyB0byBub24tc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IC8vbm90IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNsaXBib2FyZF9pbmZvLmxpbmtzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUuX3JlbGF0aXZlX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLm9yaWdpbl9zbG90LCAvL2osXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9yZWxhdGl2ZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby50YXJnZXRfc2xvdFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICBcImxpdGVncmFwaGVkaXRvcl9jbGlwYm9hcmRcIixcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGNsaXBib2FyZF9pbmZvKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnBhc3RlRnJvbUNsaXBib2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibGl0ZWdyYXBoZWRpdG9yX2NsaXBib2FyZFwiKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXHRcdHRoaXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG5cbiAgICAgICAgLy9jcmVhdGUgbm9kZXNcbiAgICAgICAgdmFyIGNsaXBib2FyZF9pbmZvID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcGJvYXJkX2luZm8ubm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlX2RhdGEgPSBjbGlwYm9hcmRfaW5mby5ub2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUobm9kZV9kYXRhLnR5cGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNvbmZpZ3VyZShub2RlX2RhdGEpO1xuICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdICs9IDU7XG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gKz0gNTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jcmVhdGUgbGlua3NcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwYm9hcmRfaW5mby5saW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IGNsaXBib2FyZF9pbmZvLmxpbmtzW2ldO1xuICAgICAgICAgICAgdmFyIG9yaWdpbl9ub2RlID0gbm9kZXNbbGlua19pbmZvWzBdXTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IG5vZGVzW2xpbmtfaW5mb1syXV07XG5cdFx0XHRpZiggb3JpZ2luX25vZGUgJiYgdGFyZ2V0X25vZGUgKVxuXHQgICAgICAgICAgICBvcmlnaW5fbm9kZS5jb25uZWN0KGxpbmtfaW5mb1sxXSwgdGFyZ2V0X25vZGUsIGxpbmtfaW5mb1szXSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIldhcm5pbmcsIG5vZGVzIG1pc3Npbmcgb24gcGFzdGluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZXMobm9kZXMpO1xuXG5cdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwcm9jZXNzIGEgaXRlbSBkcm9wIGV2ZW50IG9uIHRvcCB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBwcm9jZXNzRHJvcFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NEcm9wID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuYWRqdXN0TW91c2VFdmVudChlKTtcblx0XHR2YXIgeCA9IGUubG9jYWxYO1xuXHRcdHZhciB5ID0gZS5sb2NhbFk7XG5cdFx0dmFyIGlzX2luc2lkZSA9ICF0aGlzLnZpZXdwb3J0IHx8ICggdGhpcy52aWV3cG9ydCAmJiB4ID49IHRoaXMudmlld3BvcnRbMF0gJiYgeCA8ICh0aGlzLnZpZXdwb3J0WzBdICsgdGhpcy52aWV3cG9ydFsyXSkgJiYgeSA+PSB0aGlzLnZpZXdwb3J0WzFdICYmIHkgPCAodGhpcy52aWV3cG9ydFsxXSArIHRoaXMudmlld3BvcnRbM10pICk7XG5cdFx0aWYoIWlzX2luc2lkZSlcblx0XHRcdHJldHVybjtcblxuICAgICAgICB2YXIgcG9zID0gW2UuY2FudmFzWCwgZS5jYW52YXNZXTtcblxuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaCA/IHRoaXMuZ3JhcGguZ2V0Tm9kZU9uUG9zKHBvc1swXSwgcG9zWzFdKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB2YXIgciA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkRyb3BJdGVtKSB7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMub25Ecm9wSXRlbShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRHJvcEl0ZW0oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vbkRyb3BGaWxlIHx8IG5vZGUub25Ecm9wRGF0YSkge1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgICAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBMR3JhcGhDYW52YXMuZ2V0RmlsZUV4dGVuc2lvbihmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZmlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25Ecm9wRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbkRyb3BGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25Ecm9wRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9wcmVwYXJlIHJlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25Ecm9wRGF0YShkYXRhLCBmaWxlbmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlYWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWxlLnR5cGUuc3BsaXQoXCIvXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJ0ZXh0XCIgfHwgdHlwZSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLm9uRHJvcEl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcEl0ZW0oZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbkRyb3BJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbkRyb3BJdGVtKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy9jYWxsZWQgaWYgdGhlIGdyYXBoIGRvZXNuJ3QgaGF2ZSBhIGRlZmF1bHQgZHJvcCBpdGVtIGJlaGF2aW91clxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2hlY2tEcm9wSXRlbSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1swXTtcbiAgICAgICAgICAgIHZhciBleHQgPSBMR3JhcGhDYW52YXMuZ2V0RmlsZUV4dGVuc2lvbihmaWxlLm5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbm9kZXR5cGUgPSBMaXRlR3JhcGgubm9kZV90eXBlc19ieV9maWxlX2V4dGVuc2lvbltleHRdO1xuICAgICAgICAgICAgaWYgKG5vZGV0eXBlKSB7XG5cdFx0XHRcdHRoaXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShub2RldHlwZS50eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlLnBvcyA9IFtlLmNhbnZhc1gsIGUuY2FudmFzWV07XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub25Ecm9wRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9uRHJvcEZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0XHR0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTm9kZURibENsaWNrZWQgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmICh0aGlzLm9uU2hvd05vZGVQYW5lbCkge1xuICAgICAgICAgICAgdGhpcy5vblNob3dOb2RlUGFuZWwobik7XG4gICAgICAgIH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5zaG93U2hvd05vZGVQYW5lbChuKTtcblx0XHR9XG5cbiAgICAgICAgaWYgKHRoaXMub25Ob2RlRGJsQ2xpY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vZGVEYmxDbGlja2VkKG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTm9kZVNlbGVjdGVkID0gZnVuY3Rpb24obm9kZSwgZSkge1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSwgZSAmJiBlLnNoaWZ0S2V5KTtcbiAgICAgICAgaWYgKHRoaXMub25Ob2RlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0ZWQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VsZWN0cyBhIGdpdmVuIG5vZGUgKG9yIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKVxuICAgICAqIEBtZXRob2Qgc2VsZWN0Tm9kZVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNlbGVjdE5vZGUgPSBmdW5jdGlvbihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgYWRkX3RvX2N1cnJlbnRfc2VsZWN0aW9uXG4gICAgKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGxOb2RlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2Rlcyhbbm9kZV0sIGFkZF90b19jdXJyZW50X3NlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VsZWN0cyBzZXZlcmFsIG5vZGVzIChvciBhZGRzIHRoZW0gdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKVxuICAgICAqIEBtZXRob2Qgc2VsZWN0Tm9kZXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZWxlY3ROb2RlcyA9IGZ1bmN0aW9uKCBub2RlcywgYWRkX3RvX2N1cnJlbnRfc2VsZWN0aW9uIClcblx0e1xuICAgICAgICBpZiAoIWFkZF90b19jdXJyZW50X3NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbE5vZGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNfc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFub2RlLmlzX3NlbGVjdGVkICYmIG5vZGUub25TZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25TZWxlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5pc19zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdID0gbm9kZTtcblxuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW25vZGUuaW5wdXRzW2pdLmxpbmtdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLm91dHB1dHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IG5vZGUub3V0cHV0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5saW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGlua3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW291dC5saW5rc1trXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHRpZihcdHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgKVxuXHRcdFx0dGhpcy5vblNlbGVjdGlvbkNoYW5nZSggdGhpcy5zZWxlY3RlZF9ub2RlcyApO1xuXG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQG1ldGhvZCBkZXNlbGVjdE5vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kZXNlbGVjdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5pc19zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm9uRGVzZWxlY3RlZCkge1xuICAgICAgICAgICAgbm9kZS5vbkRlc2VsZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlzX3NlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMub25Ob2RlRGVzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vZGVEZXNlbGVjdGVkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW1vdmUgaGlnaGxpZ2h0ZWRcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3Nbbm9kZS5pbnB1dHNbaV0ubGlua107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdXQubGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXQubGlua3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW291dC5saW5rc1tqXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyBhbGwgbm9kZXMgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGRlc2VsZWN0QWxsTm9kZXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kZXNlbGVjdEFsbE5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmICghbm9kZS5pc19zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub25EZXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkRlc2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNfc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLm9uTm9kZURlc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5vbk5vZGVEZXNlbGVjdGVkKG5vZGUpO1xuXHRcdFx0fVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50X25vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzID0ge307XG5cdFx0aWYoXHR0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlIClcblx0XHRcdHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoIHRoaXMuc2VsZWN0ZWRfbm9kZXMgKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVsZXRlcyBhbGwgbm9kZXMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGZyb20gdGhlIGdyYXBoXG4gICAgICogQG1ldGhvZCBkZWxldGVTZWxlY3RlZE5vZGVzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZGVsZXRlU2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3RlZF9ub2Rlc1tpXTtcblxuXHRcdFx0aWYobm9kZS5ibG9ja19kZWxldGUpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL2F1dG9jb25uZWN0IHdoZW4gcG9zc2libGUgKHZlcnkgYmFzaWMsIG9ubHkgdGFrZXMgaW50byBhY2NvdW50IGZpcnN0IGlucHV0LW91dHB1dClcblx0XHRcdGlmKG5vZGUuaW5wdXRzICYmIG5vZGUuaW5wdXRzLmxlbmd0aCAmJiBub2RlLm91dHB1dHMgJiYgbm9kZS5vdXRwdXRzLmxlbmd0aCAmJiBMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24oIG5vZGUuaW5wdXRzWzBdLnR5cGUsIG5vZGUub3V0cHV0c1swXS50eXBlICkgJiYgbm9kZS5pbnB1dHNbMF0ubGluayAmJiBub2RlLm91dHB1dHNbMF0ubGlua3MgJiYgbm9kZS5vdXRwdXRzWzBdLmxpbmtzLmxlbmd0aCApIFxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaW5wdXRfbGluayA9IG5vZGUuZ3JhcGgubGlua3NbIG5vZGUuaW5wdXRzWzBdLmxpbmsgXTtcblx0XHRcdFx0dmFyIG91dHB1dF9saW5rID0gbm9kZS5ncmFwaC5saW5rc1sgbm9kZS5vdXRwdXRzWzBdLmxpbmtzWzBdIF07XG5cdFx0XHRcdHZhciBpbnB1dF9ub2RlID0gbm9kZS5nZXRJbnB1dE5vZGUoMCk7XG5cdFx0XHRcdHZhciBvdXRwdXRfbm9kZSA9IG5vZGUuZ2V0T3V0cHV0Tm9kZXMoMClbMF07XG5cdFx0XHRcdGlmKGlucHV0X25vZGUgJiYgb3V0cHV0X25vZGUpXG5cdFx0XHRcdFx0aW5wdXRfbm9kZS5jb25uZWN0KCBpbnB1dF9saW5rLm9yaWdpbl9zbG90LCBvdXRwdXRfbm9kZSwgb3V0cHV0X2xpbmsudGFyZ2V0X3Nsb3QgKTtcblx0XHRcdH1cbiAgICAgICAgICAgIHRoaXMuZ3JhcGgucmVtb3ZlKG5vZGUpO1xuXHRcdFx0aWYgKHRoaXMub25Ob2RlRGVzZWxlY3RlZCkge1xuXHRcdFx0XHR0aGlzLm9uTm9kZURlc2VsZWN0ZWQobm9kZSk7XG5cdFx0XHR9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRfbm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3MgPSB7fTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKTtcblx0XHR0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNlbnRlcnMgdGhlIGNhbWVyYSBvbiBhIGdpdmVuIG5vZGVcbiAgICAgKiBAbWV0aG9kIGNlbnRlck9uTm9kZVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNlbnRlck9uTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5kcy5vZmZzZXRbMF0gPVxuICAgICAgICAgICAgLW5vZGUucG9zWzBdIC1cbiAgICAgICAgICAgIG5vZGUuc2l6ZVswXSAqIDAuNSArXG4gICAgICAgICAgICAodGhpcy5jYW52YXMud2lkdGggKiAwLjUpIC8gdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgdGhpcy5kcy5vZmZzZXRbMV0gPVxuICAgICAgICAgICAgLW5vZGUucG9zWzFdIC1cbiAgICAgICAgICAgIG5vZGUuc2l6ZVsxXSAqIDAuNSArXG4gICAgICAgICAgICAodGhpcy5jYW52YXMuaGVpZ2h0ICogMC41KSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZHMgc29tZSB1c2VmdWwgcHJvcGVydGllcyB0byBhIG1vdXNlIGV2ZW50LCBsaWtlIHRoZSBwb3NpdGlvbiBpbiBncmFwaCBjb29yZGluYXRlc1xuICAgICAqIEBtZXRob2QgYWRqdXN0TW91c2VFdmVudFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmFkanVzdE1vdXNlRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGUubG9jYWxYID0gZS5jbGllbnRYIC0gYi5sZWZ0O1xuICAgICAgICAgICAgZS5sb2NhbFkgPSBlLmNsaWVudFkgLSBiLnRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUubG9jYWxYID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgZS5sb2NhbFkgPSBlLmNsaWVudFk7XG4gICAgICAgIH1cblxuICAgICAgICBlLmRlbHRhWCA9IGUubG9jYWxYIC0gdGhpcy5sYXN0X21vdXNlX3Bvc2l0aW9uWzBdO1xuICAgICAgICBlLmRlbHRhWSA9IGUubG9jYWxZIC0gdGhpcy5sYXN0X21vdXNlX3Bvc2l0aW9uWzFdO1xuXG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9wb3NpdGlvblswXSA9IGUubG9jYWxYO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VfcG9zaXRpb25bMV0gPSBlLmxvY2FsWTtcblxuICAgICAgICBlLmNhbnZhc1ggPSBlLmxvY2FsWCAvIHRoaXMuZHMuc2NhbGUgLSB0aGlzLmRzLm9mZnNldFswXTtcbiAgICAgICAgZS5jYW52YXNZID0gZS5sb2NhbFkgLyB0aGlzLmRzLnNjYWxlIC0gdGhpcy5kcy5vZmZzZXRbMV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIGdyYXBoIChkZWZhdWx0IGlzIDEpLCB5b3UgY2FuIHBhc3MgYWxzbyBhIHBsYWNlIHVzZWQgdG8gcGl2b3QgdGhlIHpvb21cbiAgICAgKiBAbWV0aG9kIHNldFpvb21cbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24odmFsdWUsIHpvb21pbmdfY2VudGVyKSB7XG4gICAgICAgIHRoaXMuZHMuY2hhbmdlU2NhbGUodmFsdWUsIHpvb21pbmdfY2VudGVyKTtcbiAgICAgICAgLypcblx0aWYoIXpvb21pbmdfY2VudGVyICYmIHRoaXMuY2FudmFzKVxuXHRcdHpvb21pbmdfY2VudGVyID0gW3RoaXMuY2FudmFzLndpZHRoICogMC41LHRoaXMuY2FudmFzLmhlaWdodCAqIDAuNV07XG5cblx0dmFyIGNlbnRlciA9IHRoaXMuY29udmVydE9mZnNldFRvQ2FudmFzKCB6b29taW5nX2NlbnRlciApO1xuXG5cdHRoaXMuZHMuc2NhbGUgPSB2YWx1ZTtcblxuXHRpZih0aGlzLnNjYWxlID4gdGhpcy5tYXhfem9vbSlcblx0XHR0aGlzLnNjYWxlID0gdGhpcy5tYXhfem9vbTtcblx0ZWxzZSBpZih0aGlzLnNjYWxlIDwgdGhpcy5taW5fem9vbSlcblx0XHR0aGlzLnNjYWxlID0gdGhpcy5taW5fem9vbTtcblxuXHR2YXIgbmV3X2NlbnRlciA9IHRoaXMuY29udmVydE9mZnNldFRvQ2FudmFzKCB6b29taW5nX2NlbnRlciApO1xuXHR2YXIgZGVsdGFfb2Zmc2V0ID0gW25ld19jZW50ZXJbMF0gLSBjZW50ZXJbMF0sIG5ld19jZW50ZXJbMV0gLSBjZW50ZXJbMV1dO1xuXG5cdHRoaXMub2Zmc2V0WzBdICs9IGRlbHRhX29mZnNldFswXTtcblx0dGhpcy5vZmZzZXRbMV0gKz0gZGVsdGFfb2Zmc2V0WzFdO1xuXHQqL1xuXG4gICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgY29vcmRpbmF0ZSBmcm9tIGdyYXBoIGNvb3JkaW5hdGVzIHRvIGNhbnZhczJEIGNvb3JkaW5hdGVzXG4gICAgICogQG1ldGhvZCBjb252ZXJ0T2Zmc2V0VG9DYW52YXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb252ZXJ0T2Zmc2V0VG9DYW52YXMgPSBmdW5jdGlvbihwb3MsIG91dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcy5jb252ZXJ0T2Zmc2V0VG9DYW52YXMocG9zLCBvdXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIGNvb3JkaW5hdGUgZnJvbSBDYW52YXMyRCBjb29yZGluYXRlcyB0byBncmFwaCBzcGFjZVxuICAgICAqIEBtZXRob2QgY29udmVydENhbnZhc1RvT2Zmc2V0XG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29udmVydENhbnZhc1RvT2Zmc2V0ID0gZnVuY3Rpb24ocG9zLCBvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHMuY29udmVydENhbnZhc1RvT2Zmc2V0KHBvcywgb3V0KTtcbiAgICB9O1xuXG4gICAgLy9jb252ZXJ0cyBldmVudCBjb29yZGluYXRlcyBmcm9tIGNhbnZhczJEIHRvIGdyYXBoIGNvb3JkaW5hdGVzXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb252ZXJ0RXZlbnRUb0NhbnZhc09mZnNldCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydENhbnZhc1RvT2Zmc2V0KFtcbiAgICAgICAgICAgIGUuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgICAgIGUuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgICAgIF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBicmluZ3MgYSBub2RlIHRvIGZyb250IChhYm92ZSBhbGwgb3RoZXIgbm9kZXMpXG4gICAgICogQG1ldGhvZCBicmluZ1RvRnJvbnRcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5icmluZ1RvRnJvbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5ncmFwaC5fbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGguX25vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VuZHMgYSBub2RlIHRvIHRoZSBiYWNrIChiZWxvdyBhbGwgb3RoZXIgbm9kZXMpXG4gICAgICogQG1ldGhvZCBzZW5kVG9CYWNrXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2VuZFRvQmFjayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmdyYXBoLl9ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmdyYXBoLl9ub2Rlcy51bnNoaWZ0KG5vZGUpO1xuICAgIH07XG5cbiAgICAvKiBJbnRlcmFjdGlvbiAqL1xuXG4gICAgLyogTEdyYXBoQ2FudmFzIHJlbmRlciAqL1xuICAgIHZhciB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyB3aGljaCBub2RlcyBhcmUgdmlzaWJsZSAoaW5zaWRlIHRoZSBjYW1lcmEgYXJlYSlcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVWaXNpYmxlTm9kZXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb21wdXRlVmlzaWJsZU5vZGVzID0gZnVuY3Rpb24obm9kZXMsIG91dCkge1xuICAgICAgICB2YXIgdmlzaWJsZV9ub2RlcyA9IG91dCB8fCBbXTtcbiAgICAgICAgdmlzaWJsZV9ub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcblxuICAgICAgICAgICAgLy9za2lwIHJlbmRlcmluZyBub2RlcyBpbiBsaXZlIG1vZGVcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdmVfbW9kZSAmJiAhbi5vbkRyYXdCYWNrZ3JvdW5kICYmICFuLm9uRHJhd0ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvdmVybGFwQm91bmRpbmcodGhpcy52aXNpYmxlX2FyZWEsIG4uZ2V0Qm91bmRpbmcodGVtcCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vb3V0IG9mIHRoZSB2aXNpYmxlIGFyZWFcblxuICAgICAgICAgICAgdmlzaWJsZV9ub2Rlcy5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlX25vZGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJzIHRoZSB3aG9sZSBjYW52YXMgY29udGVudCwgYnkgcmVuZGVyaW5nIGluIHR3byBzZXBhcmF0ZWQgY2FudmFzLCBvbmUgY29udGFpbmluZyB0aGUgYmFja2dyb3VuZCBncmlkIGFuZCB0aGUgY29ubmVjdGlvbnMsIGFuZCBvbmUgY29udGFpbmluZyB0aGUgbm9kZXMpXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGZvcmNlX2NhbnZhcywgZm9yY2VfYmdjYW52YXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcyB8fCB0aGlzLmNhbnZhcy53aWR0aCA9PSAwIHx8IHRoaXMuY2FudmFzLmhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZwcyBjb3VudGluZ1xuICAgICAgICB2YXIgbm93ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJfdGltZSA9IChub3cgLSB0aGlzLmxhc3RfZHJhd190aW1lKSAqIDAuMDAxO1xuICAgICAgICB0aGlzLmxhc3RfZHJhd190aW1lID0gbm93O1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmRzLmNvbXB1dGVWaXNpYmxlQXJlYSh0aGlzLnZpZXdwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgfHxcbiAgICAgICAgICAgIGZvcmNlX2JnY2FudmFzIHx8XG4gICAgICAgICAgICB0aGlzLmFsd2F5c19yZW5kZXJfYmFja2dyb3VuZCB8fFxuICAgICAgICAgICAgKHRoaXMuZ3JhcGggJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLl9sYXN0X3RyaWdnZXJfdGltZSAmJlxuICAgICAgICAgICAgICAgIG5vdyAtIHRoaXMuZ3JhcGguX2xhc3RfdHJpZ2dlcl90aW1lIDwgMTAwMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrQ2FudmFzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kaXJ0eV9jYW52YXMgfHwgZm9yY2VfY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdGcm9udENhbnZhcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcHMgPSB0aGlzLnJlbmRlcl90aW1lID8gMS4wIC8gdGhpcy5yZW5kZXJfdGltZSA6IDA7XG4gICAgICAgIHRoaXMuZnJhbWUgKz0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIGZyb250IGNhbnZhcyAodGhlIG9uZSBjb250YWluaW5nIGFsbCB0aGUgbm9kZXMpXG4gICAgICogQG1ldGhvZCBkcmF3RnJvbnRDYW52YXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3RnJvbnRDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuYmdjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXMgdXNpbmcgd2ViZ2wuLi5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKCBjdHguc3RhcnQyRCAmJiAhdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgICAgIGN0eC5zdGFydDJEKCk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2xpcCBkaXJ0eSBhcmVhIGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlIHdvcmsgaW4gZnVsbCBjYW52YXNcblx0XHR2YXIgYXJlYSA9IHRoaXMudmlld3BvcnQgfHwgdGhpcy5kaXJ0eV9hcmVhO1xuICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KCBhcmVhWzBdLGFyZWFbMV0sYXJlYVsyXSxhcmVhWzNdICk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICAvL2NhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY2xlYXJfYmFja2dyb3VuZCkge1xuXHRcdFx0aWYoYXJlYSlcblx0ICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCggYXJlYVswXSxhcmVhWzFdLGFyZWFbMl0sYXJlYVszXSApO1xuXHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2RyYXcgYmcgY2FudmFzXG4gICAgICAgIGlmICh0aGlzLmJnY2FudmFzID09IHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrQ2FudmFzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKCB0aGlzLmJnY2FudmFzLCAwLCAwICk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlcmluZ1xuICAgICAgICBpZiAodGhpcy5vblJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5vblJlbmRlcihjYW52YXMsIGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2luZm8gd2lkZ2V0XG4gICAgICAgIGlmICh0aGlzLnNob3dfaW5mbykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJJbmZvKGN0eCwgYXJlYSA/IGFyZWFbMF0gOiAwLCBhcmVhID8gYXJlYVsxXSA6IDAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICAvL2FwcGx5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHMudG9DYW52YXNDb250ZXh0KGN0eCk7XG5cbiAgICAgICAgICAgIC8vZHJhdyBub2Rlc1xuICAgICAgICAgICAgdmFyIGRyYXduX25vZGVzID0gMDtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlX25vZGVzID0gdGhpcy5jb21wdXRlVmlzaWJsZU5vZGVzKFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX25vZGVzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2libGVfbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZpc2libGVfbm9kZXNbaV07XG5cbiAgICAgICAgICAgICAgICAvL3RyYW5zZm9ybSBjb29yZHMgc3lzdGVtXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKG5vZGUucG9zWzBdLCBub2RlLnBvc1sxXSk7XG5cbiAgICAgICAgICAgICAgICAvL0RyYXdcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdOb2RlKG5vZGUsIGN0eCk7XG4gICAgICAgICAgICAgICAgZHJhd25fbm9kZXMgKz0gMTtcblxuICAgICAgICAgICAgICAgIC8vUmVzdG9yZVxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vb24gdG9wIChkZWJ1ZylcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9leGVjdXRpb25fb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdFeGVjdXRpb25PcmRlcihjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Nvbm5lY3Rpb25zIG9udG9wP1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGguY29uZmlnLmxpbmtzX29udG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDb25uZWN0aW9ucyhjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jdXJyZW50IGNvbm5lY3Rpb24gKHRoZSBvbmUgYmVpbmcgZHJhZ2dlZCBieSB0aGUgbW91c2UpXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX3BvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuY29ubmVjdGlvbnNfd2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfY29sb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRVZFTlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2NvbG9yID0gTGl0ZUdyYXBoLkVWRU5UX0xJTktfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfY29sb3IgPSBMaXRlR3JhcGguQ09OTkVDVElOR19MSU5LX0NPTE9SO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vdGhlIGNvbm5lY3Rpb24gYmVpbmcgZHJhZ2dlZCBieSB0aGUgbW91c2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpbmsoXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3BvcyxcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuZ3JhcGhfbW91c2VbMF0sIHRoaXMuZ3JhcGhfbW91c2VbMV1dLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbGlua19jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dC5kaXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNvbm5lY3Rpbmdfbm9kZS5ob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBMaXRlR3JhcGguRE9XTlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTGl0ZUdyYXBoLlJJR0hUKSxcbiAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLkNFTlRFUlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnR5cGUgPT09IExpdGVHcmFwaC5FVkVOVCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnNoYXBlID09PSBMaXRlR3JhcGguQk9YX1NIQVBFXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Bvc1swXSAtIDYgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdIC0gNSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29ubmVjdGluZ19vdXRwdXQuc2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuY29ubmVjdGluZ19wb3NbMF0gKyA4LCB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmNvbm5lY3RpbmdfcG9zWzBdIC0gNCwgdGhpcy5jb25uZWN0aW5nX3Bvc1sxXSArIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuY29ubmVjdGluZ19wb3NbMF0gLSA0LCB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdIC0gNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Bvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZjYzAwXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodF9pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuX2hpZ2hsaWdodF9pbnB1dF9zbG90LnNoYXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLl9oaWdobGlnaHRfaW5wdXRbMF0gKyA4LCB0aGlzLl9oaWdobGlnaHRfaW5wdXRbMV0gKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLl9oaWdobGlnaHRfaW5wdXRbMF0gLSA0LCB0aGlzLl9oaWdobGlnaHRfaW5wdXRbMV0gKyA2ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5faGlnaGxpZ2h0X2lucHV0WzBdIC0gNCwgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdIC0gNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodF9pbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cdFx0XHQvL3RoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNGRkZcIjtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbM11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHQvL29uIHRvcCBvZiBsaW5rIGNlbnRlclxuXHRcdFx0aWYodGhpcy5vdmVyX2xpbmtfY2VudGVyICYmIHRoaXMucmVuZGVyX2xpbmtfdG9vbHRpcClcblx0XHRcdFx0dGhpcy5kcmF3TGlua1Rvb2x0aXAoIGN0eCwgdGhpcy5vdmVyX2xpbmtfY2VudGVyICk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGlmKHRoaXMub25EcmF3TGlua1Rvb2x0aXApIC8vdG8gcmVtb3ZlXG5cdFx0XHRcdFx0dGhpcy5vbkRyYXdMaW5rVG9vbHRpcChjdHgsbnVsbCk7XG5cblx0XHRcdC8vY3VzdG9tIGluZm9cbiAgICAgICAgICAgIGlmICh0aGlzLm9uRHJhd0ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRHJhd0ZvcmVncm91bmQoY3R4LCB0aGlzLnZpc2libGVfcmVjdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuXHRcdC8vZHJhd3MgcGFuZWwgaW4gdGhlIGNvcm5lciBcblx0XHRpZiAodGhpcy5fZ3JhcGhfc3RhY2sgJiYgdGhpcy5fZ3JhcGhfc3RhY2subGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmRyYXdTdWJncmFwaFBhbmVsKCBjdHggKTtcblx0XHR9XG5cblxuICAgICAgICBpZiAodGhpcy5vbkRyYXdPdmVybGF5KSB7XG4gICAgICAgICAgICB0aGlzLm9uRHJhd092ZXJsYXkoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN0eC5maW5pc2gyRCkge1xuICAgICAgICAgICAgLy90aGlzIGlzIGEgZnVuY3Rpb24gSSB1c2UgaW4gd2ViZ2wgcmVuZGVyZXJcbiAgICAgICAgICAgIGN0eC5maW5pc2gyRCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSBwYW5lbCBpbiB0aGUgY29ybmVyIHRoYXQgc2hvd3Mgc3ViZ3JhcGggcHJvcGVydGllc1xuICAgICAqIEBtZXRob2QgZHJhd1N1YmdyYXBoUGFuZWxcbiAgICAgKiovXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd1N1YmdyYXBoUGFuZWwgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgc3ViZ3JhcGggPSB0aGlzLmdyYXBoO1xuXHRcdHZhciBzdWJub2RlID0gc3ViZ3JhcGguX3N1YmdyYXBoX25vZGU7XG5cdFx0aWYoIXN1Ym5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc29sZS53YXJuKFwic3ViZ3JhcGggd2l0aG91dCBzdWJub2RlXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBudW0gPSBzdWJub2RlLmlucHV0cyA/IHN1Ym5vZGUuaW5wdXRzLmxlbmd0aCA6IDA7XG5cdFx0dmFyIHcgPSAzMDA7XG5cdFx0dmFyIGggPSBNYXRoLmZsb29yKExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICogMS42KTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiMxMTFcIjtcblx0XHRjdHguZ2xvYmFsQWxwaGEgPSAwLjg7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yb3VuZFJlY3QoMTAsMTAsdywgKG51bSArIDEpICogaCArIDUwLDggKTtcblx0XHRjdHguZmlsbCgpO1xuXHRcdGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gXCIjODg4XCI7XG5cdFx0Y3R4LmZvbnQgPSBcIjE0cHggQXJpYWxcIjtcblx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0Y3R4LmZpbGxUZXh0KCBcIkdyYXBoIElucHV0c1wiLCAyMCwgMzQgKTtcblx0XHR2YXIgcG9zID0gdGhpcy5tb3VzZTtcblxuXHRcdGlmKCB0aGlzLmRyYXdCdXR0b24oIHcgLSAyMCwgMjAsMjAsMjAsIFwiWFwiLCBcIiMxNTE1MTVcIiApIClcblx0XHR7XG5cdFx0XHR0aGlzLmNsb3NlU3ViZ3JhcGgoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgeSA9IDUwO1xuXHRcdGN0eC5mb250ID0gXCIyMHB4IEFyaWFsXCI7XG5cdFx0aWYoc3Vibm9kZS5pbnB1dHMpXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN1Ym5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKVxuXHRcdHtcblx0XHRcdHZhciBpbnB1dCA9IHN1Ym5vZGUuaW5wdXRzW2ldO1xuXHRcdFx0aWYoaW5wdXQubm90X3N1YmdyYXBoX2lucHV0KVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly9pbnB1dCBidXR0b24gY2xpY2tlZFxuXHRcdFx0aWYoIHRoaXMuZHJhd0J1dHRvbiggMjAseSsyLHcgLSAyMCwgaCAtIDIgKSApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB0eXBlID0gc3Vibm9kZS5jb25zdHJ1Y3Rvci5pbnB1dF9ub2RlX3R5cGUgfHwgXCJncmFwaC9pbnB1dFwiO1xuXHRcdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuXHRcdFx0XHR2YXIgbmV3bm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKCB0eXBlICk7XG5cdFx0XHRcdGlmKG5ld25vZGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdWJncmFwaC5hZGQoIG5ld25vZGUgKTtcblx0XHRcdFx0XHR0aGlzLmJsb2NrX2NsaWNrID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5sYXN0X2NsaWNrX3Bvc2l0aW9uID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdE5vZGVzKFtuZXdub2RlXSk7XG5cdFx0XHRcdFx0dGhpcy5ub2RlX2RyYWdnZWQgPSBuZXdub2RlO1xuXHRcdFx0XHRcdHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gZmFsc2U7XG5cdFx0XHRcdFx0bmV3bm9kZS5zZXRQcm9wZXJ0eShcIm5hbWVcIixpbnB1dC5uYW1lKTtcblx0XHRcdFx0XHRuZXdub2RlLnNldFByb3BlcnR5KFwidHlwZVwiLGlucHV0LnR5cGUpO1xuXHRcdFx0XHRcdHRoaXMubm9kZV9kcmFnZ2VkLnBvc1swXSA9IHRoaXMuZ3JhcGhfbW91c2VbMF0gLSA1O1xuXHRcdFx0XHRcdHRoaXMubm9kZV9kcmFnZ2VkLnBvc1sxXSA9IHRoaXMuZ3JhcGhfbW91c2VbMV0gLSA1O1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcImdyYXBoIGlucHV0IG5vZGUgbm90IGZvdW5kOlwiLHR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gXCIjOUM5XCI7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguYXJjKHcgLSAxNix5ICsgaCAqIDAuNSw1LDAsMipNYXRoLlBJKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcblx0XHRcdGN0eC5maWxsVGV4dCggaW5wdXQubmFtZSwgNTAsIHkgKyBoKjAuNzUgKTtcblx0XHRcdHZhciB0dyA9IGN0eC5tZWFzdXJlVGV4dCggaW5wdXQubmFtZSApO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzc3N1wiO1xuXHRcdFx0Y3R4LmZpbGxUZXh0KCBpbnB1dC50eXBlLCA1MCArIHR3LndpZHRoICsgMTAsIHkgKyBoKjAuNzUgKTtcblxuXHRcdFx0eSArPSBoO1xuXHRcdH1cblxuXHRcdC8vYWRkICsgYnV0dG9uXG5cdFx0aWYoIHRoaXMuZHJhd0J1dHRvbiggMjAseSsyLHcgLSAyMCwgaCAtIDIsIFwiK1wiLCBcIiMxNTE1MTVcIiwgXCIjMjIyXCIgKSApXG5cdFx0e1xuXHRcdFx0dGhpcy5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nKCBzdWJub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0Ly9EcmF3cyBhIGJ1dHRvbiBpbnRvIHRoZSBjYW52YXMgb3ZlcmxheSBhbmQgY29tcHV0ZXMgaWYgaXQgd2FzIGNsaWNrZWQgdXNpbmcgdGhlIGltbWVkaWF0ZSBndWkgcGFyYWRpZ21cblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3QnV0dG9uID0gZnVuY3Rpb24oIHgseSx3LGgsIHRleHQsIGJnY29sb3IsIGhvdmVyY29sb3IsIHRleHRjb2xvciApXG5cdHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jdHg7XG5cdFx0Ymdjb2xvciA9IGJnY29sb3IgfHwgTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9DT0xPUjtcblx0XHRob3ZlcmNvbG9yID0gaG92ZXJjb2xvciB8fCBcIiM1NTVcIjtcblx0XHR0ZXh0Y29sb3IgPSB0ZXh0Y29sb3IgfHwgTGl0ZUdyYXBoLk5PREVfVEVYVF9DT0xPUjtcblxuXHRcdHZhciBwb3MgPSB0aGlzLm1vdXNlO1xuXHRcdHZhciBob3ZlciA9IExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblx0XHRwb3MgPSB0aGlzLmxhc3RfY2xpY2tfcG9zaXRpb247XG5cdFx0dmFyIGNsaWNrZWQgPSBwb3MgJiYgTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKCBwb3NbMF0sIHBvc1sxXSwgeCx5LHcsaCApO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGhvdmVyID8gaG92ZXJjb2xvciA6IGJnY29sb3I7XG5cdFx0aWYoY2xpY2tlZClcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJvdW5kUmVjdCh4LHksdyxoLDQgKTtcblx0XHRjdHguZmlsbCgpO1xuXG5cdFx0aWYodGV4dCAhPSBudWxsKVxuXHRcdHtcblx0XHRcdGlmKHRleHQuY29uc3RydWN0b3IgPT0gU3RyaW5nKVxuXHRcdFx0e1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dGNvbG9yO1xuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0Y3R4LmZvbnQgPSAoKGggKiAwLjY1KXwwKSArIFwicHggQXJpYWxcIjtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KCB0ZXh0LCB4ICsgdyAqIDAuNSx5ICsgaCAqIDAuNzUgKTtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciB3YXNfY2xpY2tlZCA9IGNsaWNrZWQgJiYgIXRoaXMuYmxvY2tfY2xpY2s7XG5cdFx0aWYoY2xpY2tlZClcblx0XHRcdHRoaXMuYmxvY2tDbGljaygpO1xuXHRcdHJldHVybiB3YXNfY2xpY2tlZDtcblx0fVxuXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuaXNBcmVhQ2xpY2tlZCA9IGZ1bmN0aW9uKCB4LHksdyxoLCBob2xkX2NsaWNrIClcblx0e1xuXHRcdHZhciBwb3MgPSB0aGlzLm1vdXNlO1xuXHRcdHZhciBob3ZlciA9IExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblx0XHRwb3MgPSB0aGlzLmxhc3RfY2xpY2tfcG9zaXRpb247XG5cdFx0dmFyIGNsaWNrZWQgPSBwb3MgJiYgTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKCBwb3NbMF0sIHBvc1sxXSwgeCx5LHcsaCApO1xuXHRcdHZhciB3YXNfY2xpY2tlZCA9IGNsaWNrZWQgJiYgIXRoaXMuYmxvY2tfY2xpY2s7XG5cdFx0aWYoY2xpY2tlZCAmJiBob2xkX2NsaWNrKVxuXHRcdFx0dGhpcy5ibG9ja0NsaWNrKCk7XG5cdFx0cmV0dXJuIHdhc19jbGlja2VkO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBzb21lIHVzZWZ1bCBzdGF0cyBpbiB0aGUgY29ybmVyIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIHJlbmRlckluZm9cbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5yZW5kZXJJbmZvID0gZnVuY3Rpb24oY3R4LCB4LCB5KSB7XG4gICAgICAgIHggPSB4IHx8IDEwO1xuICAgICAgICB5ID0geSB8fCB0aGlzLmNhbnZhcy5oZWlnaHQgLSA4MDtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICAgIGN0eC5mb250ID0gXCIxMHB4IEFyaWFsXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM4ODhcIjtcblx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoIFwiVDogXCIgKyB0aGlzLmdyYXBoLmdsb2JhbHRpbWUudG9GaXhlZCgyKSArIFwic1wiLCA1LCAxMyAqIDEgKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIkk6IFwiICsgdGhpcy5ncmFwaC5pdGVyYXRpb24sIDUsIDEzICogMiApO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiTjogXCIgKyB0aGlzLmdyYXBoLl9ub2Rlcy5sZW5ndGggKyBcIiBbXCIgKyB0aGlzLnZpc2libGVfbm9kZXMubGVuZ3RoICsgXCJdXCIsIDUsIDEzICogMyApO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiVjogXCIgKyB0aGlzLmdyYXBoLl92ZXJzaW9uLCA1LCAxMyAqIDQpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiRlBTOlwiICsgdGhpcy5mcHMudG9GaXhlZCgyKSwgNSwgMTMgKiA1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIk5vIGdyYXBoIHNlbGVjdGVkXCIsIDUsIDEzICogMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIGJhY2sgY2FudmFzICh0aGUgb25lIGNvbnRhaW5pbmcgdGhlIGJhY2tncm91bmQgYW5kIHRoZSBjb25uZWN0aW9ucylcbiAgICAgKiBAbWV0aG9kIGRyYXdCYWNrQ2FudmFzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0JhY2tDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuYmdjYW52YXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCAhPSB0aGlzLmNhbnZhcy53aWR0aCB8fFxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCAhPSB0aGlzLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYmdjdHgpIHtcbiAgICAgICAgICAgIHRoaXMuYmdjdHggPSB0aGlzLmJnY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5iZ2N0eDtcbiAgICAgICAgaWYgKGN0eC5zdGFydCkge1xuICAgICAgICAgICAgY3R4LnN0YXJ0KCk7XG4gICAgICAgIH1cblxuXHRcdHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQgfHwgWzAsMCxjdHguY2FudmFzLndpZHRoLGN0eC5jYW52YXMuaGVpZ2h0XTtcblxuICAgICAgICAvL2NsZWFyXG4gICAgICAgIGlmICh0aGlzLmNsZWFyX2JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoIHZpZXdwb3J0WzBdLCB2aWV3cG9ydFsxXSwgdmlld3BvcnRbMl0sIHZpZXdwb3J0WzNdICk7XG4gICAgICAgIH1cblxuXHRcdC8vc2hvdyBzdWJncmFwaCBzdGFjayBoZWFkZXJcbiAgICAgICAgaWYgKHRoaXMuX2dyYXBoX3N0YWNrICYmIHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfZ3JhcGggPSB0aGlzLl9ncmFwaF9zdGFja1t0aGlzLl9ncmFwaF9zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBzdWJncmFwaF9ub2RlID0gdGhpcy5ncmFwaC5fc3ViZ3JhcGhfbm9kZTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN1YmdyYXBoX25vZGUuYmdjb2xvcjtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxMDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KDEsIDEsIGNhbnZhcy53aWR0aCAtIDIsIGNhbnZhcy5oZWlnaHQgLSAyKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjQwcHggQXJpYWxcIjtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN1YmdyYXBoX25vZGUuYmdjb2xvciB8fCBcIiNBQUFcIjtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgKz1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhfc3RhY2tbaV0uX3N1YmdyYXBoX25vZGUuZ2V0VGl0bGUoKSArIFwiID4+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgIHRpdGxlICsgc3ViZ3JhcGhfbm9kZS5nZXRUaXRsZSgpLFxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICA0MFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmdfYWxyZWFkeV9wYWludGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9uUmVuZGVyQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgYmdfYWxyZWFkeV9wYWludGVkID0gdGhpcy5vblJlbmRlckJhY2tncm91bmQoY2FudmFzLCBjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXNldCBpbiBjYXNlIG9mIGVycm9yXG4gICAgICAgIGlmICggIXRoaXMudmlld3BvcnQgKVxuXHRcdHtcblx0ICAgICAgICBjdHgucmVzdG9yZSgpO1xuXHRcdCAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdH1cbiAgICAgICAgdGhpcy52aXNpYmxlX2xpbmtzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vYXBwbHkgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5kcy50b0NhbnZhc0NvbnRleHQoY3R4KTtcblxuICAgICAgICAgICAgLy9yZW5kZXIgQkdcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRfaW1hZ2UgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmRzLnNjYWxlID4gMC41ICYmXG4gICAgICAgICAgICAgICAgIWJnX2FscmVhZHlfcGFpbnRlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuem9vbV9tb2RpZnlfYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID1cbiAgICAgICAgICAgICAgICAgICAgICAgICgxLjAgLSAwLjUgLyB0aGlzLmRzLnNjYWxlKSAqIHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9iZ19pbWcgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdfaW1nLm5hbWUgIT0gdGhpcy5iYWNrZ3JvdW5kX2ltYWdlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JnX2ltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZ19pbWcubmFtZSA9IHRoaXMuYmFja2dyb3VuZF9pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdfaW1nLnNyYyA9IHRoaXMuYmFja2dyb3VuZF9pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZ19pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRyYXcodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXR0ZXJuID09IG51bGwgJiYgdGhpcy5fYmdfaW1nLndpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5fYmdfaW1nLCBcInJlcGVhdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybl9pbWcgPSB0aGlzLl9iZ19pbWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbM11cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9ncm91cHNcbiAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoLl9ncm91cHMubGVuZ3RoICYmICF0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0dyb3VwcyhjYW52YXMsIGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9uRHJhd0JhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRHJhd0JhY2tncm91bmQoY3R4LCB0aGlzLnZpc2libGVfYXJlYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vbkJhY2tncm91bmRSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAvL0xFR0FDWVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiV0FSTklORyEgb25CYWNrZ3JvdW5kUmVuZGVyIGRlcHJlY2F0ZWQsIG5vdyBpcyBuYW1lZCBvbkRyYXdCYWNrZ3JvdW5kIFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQmFja2dyb3VuZFJlbmRlciA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vREVCVUc6IHNob3cgY2xpcHBpbmcgYXJlYVxuICAgICAgICAgICAgLy9jdHguZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgIC8vY3R4LmZpbGxSZWN0KCB0aGlzLnZpc2libGVfYXJlYVswXSArIDEwLCB0aGlzLnZpc2libGVfYXJlYVsxXSArIDEwLCB0aGlzLnZpc2libGVfYXJlYVsyXSAtIDIwLCB0aGlzLnZpc2libGVfYXJlYVszXSAtIDIwKTtcblxuICAgICAgICAgICAgLy9iZ1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyX2NhbnZhc19ib3JkZXIpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiMyMzVcIjtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJfY29ubmVjdGlvbnNfc2hhZG93cykge1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiIzAwMFwiO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSA2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMCwwLDAsMClcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kcmF3IGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBpZiAoIXRoaXMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29ubmVjdGlvbnMoY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cbiAgICAgICAgICAgIC8vcmVzdG9yZSBzdGF0ZVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdHguZmluaXNoKSB7XG4gICAgICAgICAgICBjdHguZmluaXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTsgLy90byBmb3JjZSB0byByZXBhaW50IHRoZSBmcm9udCBjYW52YXMgd2l0aCB0aGUgYmdjYW52YXNcbiAgICB9O1xuXG4gICAgdmFyIHRlbXBfdmVjMiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyB0aGUgZ2l2ZW4gbm9kZSBpbnNpZGUgdGhlIGNhbnZhc1xuICAgICAqIEBtZXRob2QgZHJhd05vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3Tm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGN0eCkge1xuICAgICAgICB2YXIgZ2xvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRfbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gbm9kZS5jb2xvciB8fCBub2RlLmNvbnN0cnVjdG9yLmNvbG9yIHx8IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQ09MT1I7XG4gICAgICAgIHZhciBiZ2NvbG9yID0gbm9kZS5iZ2NvbG9yIHx8IG5vZGUuY29uc3RydWN0b3IuYmdjb2xvciB8fCBMaXRlR3JhcGguTk9ERV9ERUZBVUxUX0JHQ09MT1I7XG5cbiAgICAgICAgLy9zaGFkb3cgYW5kIGdsb3dcbiAgICAgICAgaWYgKG5vZGUubW91c2VPdmVyKSB7XG4gICAgICAgICAgICBnbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb3dfcXVhbGl0eSA9IHRoaXMuZHMuc2NhbGUgPCAwLjY7IC8vem9vbWVkIG91dFxuXG4gICAgICAgIC8vb25seSByZW5kZXIgaWYgaXQgZm9yY2VzIGl0IHRvIGRvIGl0XG4gICAgICAgIGlmICh0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vbkRyYXdGb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUub25EcmF3Rm9yZWdyb3VuZChjdHgsIHRoaXMsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRpdG9yX2FscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGVkaXRvcl9hbHBoYTtcblxuICAgICAgICBpZiAodGhpcy5yZW5kZXJfc2hhZG93cyAmJiAhbG93X3F1YWxpdHkpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IExpdGVHcmFwaC5ERUZBVUxUX1NIQURPV19DT0xPUjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMiAqIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDIgKiB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAzICogdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3VzdG9tIGRyYXcgY29sbGFwc2VkIG1ldGhvZCAoZHJhdyBhZnRlciBzaGFkb3dzIGJlY2F1c2UgdGhleSBhcmUgYWZmZWN0ZWQpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUuZmxhZ3MuY29sbGFwc2VkICYmXG4gICAgICAgICAgICBub2RlLm9uRHJhd0NvbGxhcHNlZCAmJlxuICAgICAgICAgICAgbm9kZS5vbkRyYXdDb2xsYXBzZWQoY3R4LCB0aGlzKSA9PSB0cnVlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jbGlwIGlmIHJlcXVpcmVkIChtYXNrKVxuICAgICAgICB2YXIgc2hhcGUgPSBub2RlLl9zaGFwZSB8fCBMaXRlR3JhcGguQk9YX1NIQVBFO1xuICAgICAgICB2YXIgc2l6ZSA9IHRlbXBfdmVjMjtcbiAgICAgICAgdGVtcF92ZWMyLnNldChub2RlLnNpemUpO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IG5vZGUuaG9yaXpvbnRhbDsgLy8gfHwgbm9kZS5mbGFncy5ob3Jpem9udGFsO1xuXG4gICAgICAgIGlmIChub2RlLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmlubmVyX3RleHRfZm9udDtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IG5vZGUuZ2V0VGl0bGUgPyBub2RlLmdldFRpdGxlKCkgOiBub2RlLnRpdGxlO1xuICAgICAgICAgICAgaWYgKHRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9jb2xsYXBzZWRfd2lkdGggPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zaXplWzBdLFxuICAgICAgICAgICAgICAgICAgICBjdHgubWVhc3VyZVRleHQodGl0bGUpLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAqIDJcbiAgICAgICAgICAgICAgICApOyAvL0xpdGVHcmFwaC5OT0RFX0NPTExBUFNFRF9XSURUSDtcbiAgICAgICAgICAgICAgICBzaXplWzBdID0gbm9kZS5fY29sbGFwc2VkX3dpZHRoO1xuICAgICAgICAgICAgICAgIHNpemVbMV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuY2xpcF9hcmVhKSB7XG4gICAgICAgICAgICAvL1N0YXJ0IGNsaXBwaW5nXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHNoYXBlID09IExpdGVHcmFwaC5CT1hfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCgwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLlJPVU5EX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCgwLCAwLCBzaXplWzBdLCBzaXplWzFdLCAxMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09IExpdGVHcmFwaC5DSVJDTEVfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzFdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9kcmF3IHNoYXBlXG4gICAgICAgIGlmIChub2RlLmhhc19lcnJvcnMpIHtcbiAgICAgICAgICAgIGJnY29sb3IgPSBcInJlZFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd05vZGVTaGFwZShcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBiZ2NvbG9yLFxuICAgICAgICAgICAgbm9kZS5pc19zZWxlY3RlZCxcbiAgICAgICAgICAgIG5vZGUubW91c2VPdmVyXG4gICAgICAgICk7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcblxuICAgICAgICAvL2RyYXcgZm9yZWdyb3VuZFxuICAgICAgICBpZiAobm9kZS5vbkRyYXdGb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICBub2RlLm9uRHJhd0ZvcmVncm91bmQoY3R4LCB0aGlzLCB0aGlzLmNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2Nvbm5lY3Rpb24gc2xvdHNcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IGhvcml6b250YWwgPyBcImNlbnRlclwiIDogXCJsZWZ0XCI7XG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5pbm5lcl90ZXh0X2ZvbnQ7XG5cbiAgICAgICAgdmFyIHJlbmRlcl90ZXh0ID0gIWxvd19xdWFsaXR5O1xuXG4gICAgICAgIHZhciBvdXRfc2xvdCA9IHRoaXMuY29ubmVjdGluZ19vdXRwdXQ7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgIHZhciBtYXhfeSA9IDA7XG4gICAgICAgIHZhciBzbG90X3BvcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7IC8vdG8gcmV1c2VcblxuICAgICAgICAvL3JlbmRlciBpbnB1dHMgYW5kIG91dHB1dHNcbiAgICAgICAgaWYgKCFub2RlLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgLy9pbnB1dCBjb25uZWN0aW9uIHNsb3RzXG4gICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbm9kZS5pbnB1dHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZSBvcGFjaXR5IG9mIGluY29tcGF0aWJsZSBzbG90cyB3aGVuIGRyYWdnaW5nIGEgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY29ubmVjdGluZ19ub2RlICYmICFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24oIHNsb3QudHlwZSAsIG91dF9zbG90LnR5cGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC40ICogZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmxpbmsgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2xvdC5jb2xvcl9vbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3IuaW5wdXRfb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNsb3QuY29sb3Jfb2ZmIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRfY29ubmVjdGlvbl9jb2xvci5pbnB1dF9vZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyh0cnVlLCBpLCBzbG90X3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIHBvc1swXSAtPSBub2RlLnBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC09IG5vZGUucG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4X3kgPCBwb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4X3kgPSBwb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LnR5cGUgPT09IExpdGVHcmFwaC5FVkVOVCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkJPWF9TSEFQRVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc1swXSAtIDUgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc1sxXSAtIDggKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLSA2ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLSA1ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb3NbMF0gKyA4LCBwb3NbMV0gKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb3NbMF0gLSA0LCBwb3NbMV0gKyA2ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zWzBdIC0gNCwgcG9zWzFdIC0gNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZihsb3dfcXVhbGl0eSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdIC0gNCwgcG9zWzFdIC0gNCwgOCwgOCApOyAvL2Zhc3RlclxuXHRcdFx0XHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHBvc1swXSwgcG9zWzFdLCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgICAgICAgICAvL3JlbmRlciBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJfdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzbG90LmxhYmVsICE9IG51bGwgPyBzbG90LmxhYmVsIDogc2xvdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gTGl0ZUdyYXBoLk5PREVfVEVYVF9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCB8fCBzbG90LmRpciA9PSBMaXRlR3JhcGguVVApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHBvc1swXSwgcG9zWzFdIC0gMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NbMF0gKyAxMCwgcG9zWzFdICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL291dHB1dCBjb25uZWN0aW9uIHNsb3RzXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX25vZGUpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjQgKiBlZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBob3Jpem9udGFsID8gXCJjZW50ZXJcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUub3V0cHV0c1tpXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKGZhbHNlLCBpLCBzbG90X3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIHBvc1swXSAtPSBub2RlLnBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC09IG5vZGUucG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4X3kgPCBwb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4X3kgPSBwb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5saW5rcyAmJiBzbG90LmxpbmtzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2xvdC5jb2xvcl9vbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3Iub3V0cHV0X29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzbG90LmNvbG9yX29mZiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3Iub3V0cHV0X29mZjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAvL2N0eC5yZWN0KCBub2RlLnNpemVbMF0gLSAxNCxpKjE0LDEwLDEwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LnR5cGUgPT09IExpdGVHcmFwaC5FVkVOVCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkJPWF9TSEFQRVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc1swXSAtIDUgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc1sxXSAtIDggKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLSA2ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLSA1ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb3NbMF0gKyA4LCBwb3NbMV0gKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb3NbMF0gLSA0LCBwb3NbMV0gKyA2ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zWzBdIC0gNCwgcG9zWzFdIC0gNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZihsb3dfcXVhbGl0eSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdIC0gNCwgcG9zWzFdIC0gNCwgOCwgOCApO1xuXHRcdFx0XHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHBvc1swXSwgcG9zWzFdLCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3RyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgLy9pZihzbG90Lm5vZGVfaWQgIT0gbnVsbCAmJiBzbG90LnNsb3QgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIC8vXHRjdHguZmlsbFN0eWxlID0gXCIjRjg1XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZihzbG90LmxpbmtzICE9IG51bGwgJiYgc2xvdC5saW5rcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0aWYoIWxvd19xdWFsaXR5KVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAvL3JlbmRlciBvdXRwdXQgbmFtZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyX3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc2xvdC5sYWJlbCAhPSBudWxsID8gc2xvdC5sYWJlbCA6IHNsb3QubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IExpdGVHcmFwaC5OT0RFX1RFWFRfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwgfHwgc2xvdC5kaXIgPT0gTGl0ZUdyYXBoLkRPV04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHBvc1swXSwgcG9zWzFdIC0gOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHBvc1swXSAtIDEwLCBwb3NbMV0gKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgICAgIGlmIChub2RlLndpZGdldHMpIHtcblx0XHRcdFx0dmFyIHdpZGdldHNfeSA9IG1heF95O1xuICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsIHx8IG5vZGUud2lkZ2V0c191cCkge1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzX3kgPSAyO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0aWYoIG5vZGUud2lkZ2V0c19zdGFydF95ICE9IG51bGwgKVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzX3kgPSBub2RlLndpZGdldHNfc3RhcnRfeTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdOb2RlV2lkZ2V0cyhcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0c195LFxuICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV93aWRnZXQgJiYgdGhpcy5ub2RlX3dpZGdldFswXSA9PSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubm9kZV93aWRnZXRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJfY29sbGFwc2VkX3Nsb3RzKSB7XG4gICAgICAgICAgICAvL2lmIGNvbGxhcHNlZFxuICAgICAgICAgICAgdmFyIGlucHV0X3Nsb3QgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG91dHB1dF9zbG90ID0gbnVsbDtcblxuICAgICAgICAgICAgLy9nZXQgZmlyc3QgY29ubmVjdGVkIHNsb3QgdG8gcmVuZGVyXG4gICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbm9kZS5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmxpbmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2xvdCA9IHNsb3Q7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbG90LmxpbmtzIHx8ICFzbG90LmxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3Nsb3QgPSBzbG90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlucHV0X3Nsb3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKiAtMC41OyAvL2NlbnRlclxuICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBub2RlLl9jb2xsYXBzZWRfd2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAtTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNjg2XCI7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc2xvdC50eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkJPWF9TSEFQRVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCh4IC0gNyArIDAuNSwgeSAtIDQsIDE0LCA4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyA4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgLTQsIHkgLSA0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgLTQsIHkgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3V0cHV0X3Nsb3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG5vZGUuX2NvbGxhcHNlZF93aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAqIC0wLjU7IC8vY2VudGVyXG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG5vZGUuX2NvbGxhcHNlZF93aWR0aCAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2ODZcIjtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc2xvdC50eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkJPWF9TSEFQRVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCh4IC0gNyArIDAuNSwgeSAtIDQsIDE0LCA4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyA2LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gNiwgeSAtIDQpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSA2LCB5ICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIDQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAvL2N0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmNsaXBfYXJlYSkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgICB9O1xuXG5cdC8vdXNlZCBieSB0aGlzLm92ZXJfbGlua19jZW50ZXJcblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3TGlua1Rvb2x0aXAgPSBmdW5jdGlvbiggY3R4LCBsaW5rIClcblx0e1xuXHRcdHZhciBwb3MgPSBsaW5rLl9wb3M7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyggcG9zWzBdLCBwb3NbMV0sIDMsIDAsIE1hdGguUEkgKiAyICk7XG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmKGxpbmsuZGF0YSA9PSBudWxsKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYodGhpcy5vbkRyYXdMaW5rVG9vbHRpcClcblx0XHRcdGlmKCB0aGlzLm9uRHJhd0xpbmtUb29sdGlwKGN0eCxsaW5rLHRoaXMpID09IHRydWUgKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgZGF0YSA9IGxpbmsuZGF0YTtcblx0XHR2YXIgdGV4dCA9IG51bGw7XG5cblx0XHRpZiggZGF0YS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyIClcblx0XHRcdHRleHQgPSBkYXRhLnRvRml4ZWQoMik7XG5cdFx0ZWxzZSBpZiggZGF0YS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIClcblx0XHRcdHRleHQgPSBcIlxcXCJcIiArIGRhdGEgKyBcIlxcXCJcIjtcblx0XHRlbHNlIGlmKCBkYXRhLmNvbnN0cnVjdG9yID09PSBCb29sZWFuIClcblx0XHRcdHRleHQgPSBTdHJpbmcoZGF0YSk7XG5cdFx0ZWxzZSBpZiAoZGF0YS50b1Rvb2xUaXApXG5cdFx0XHR0ZXh0ID0gZGF0YS50b1Rvb2xUaXAoKTtcblx0XHRlbHNlXG5cdFx0XHR0ZXh0ID0gXCJbXCIgKyBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgKyBcIl1cIjtcblxuXHRcdGlmKHRleHQgPT0gbnVsbClcblx0XHRcdHJldHVybjtcblx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoMCwzMCk7IC8vYXZvaWQgd2VpcmRcblxuXHRcdGN0eC5mb250ID0gXCIxNHB4IENvdXJpZXIgTmV3XCI7XG5cdFx0dmFyIGluZm8gPSBjdHgubWVhc3VyZVRleHQodGV4dCk7XG5cdFx0dmFyIHcgPSBpbmZvLndpZHRoICsgMjA7XG5cdFx0dmFyIGggPSAyNDtcblx0XHRjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG5cdFx0Y3R4LnNoYWRvd09mZnNldFggPSAyO1xuXHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gMjtcblx0XHRjdHguc2hhZG93Qmx1ciA9IDM7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzQ1NFwiO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucm91bmRSZWN0KCBwb3NbMF0gLSB3KjAuNSwgcG9zWzFdIC0gMTUgLSBoLCB3LCBoLDMsIDMpO1xuXHRcdGN0eC5tb3ZlVG8oIHBvc1swXSAtIDEwLCBwb3NbMV0gLSAxNSApO1xuXHRcdGN0eC5saW5lVG8oIHBvc1swXSArIDEwLCBwb3NbMV0gLSAxNSApO1xuXHRcdGN0eC5saW5lVG8oIHBvc1swXSwgcG9zWzFdIC0gNSApO1xuXHRcdGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcblx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRjdHguZmlsbFN0eWxlID0gXCIjQ0VDXCI7XG5cdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHBvc1swXSwgcG9zWzFdIC0gMTUgLSBoICogMC4zKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIHNoYXBlIG9mIHRoZSBnaXZlbiBub2RlIGluIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIGRyYXdOb2RlU2hhcGVcbiAgICAgKiovXG4gICAgdmFyIHRtcF9hcmVhID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd05vZGVTaGFwZSA9IGZ1bmN0aW9uKFxuICAgICAgICBub2RlLFxuICAgICAgICBjdHgsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGZnY29sb3IsXG4gICAgICAgIGJnY29sb3IsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICBtb3VzZV9vdmVyXG4gICAgKSB7XG4gICAgICAgIC8vYmcgcmVjdFxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmZ2NvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdjb2xvcjtcblxuICAgICAgICB2YXIgdGl0bGVfaGVpZ2h0ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICB2YXIgbG93X3F1YWxpdHkgPSB0aGlzLmRzLnNjYWxlIDwgMC41O1xuXG4gICAgICAgIC8vcmVuZGVyIG5vZGUgYXJlYSBkZXBlbmRpbmcgb24gc2hhcGVcbiAgICAgICAgdmFyIHNoYXBlID1cbiAgICAgICAgICAgIG5vZGUuX3NoYXBlIHx8IG5vZGUuY29uc3RydWN0b3Iuc2hhcGUgfHwgTGl0ZUdyYXBoLlJPVU5EX1NIQVBFO1xuXG4gICAgICAgIHZhciB0aXRsZV9tb2RlID0gbm9kZS5jb25zdHJ1Y3Rvci50aXRsZV9tb2RlO1xuXG4gICAgICAgIHZhciByZW5kZXJfdGl0bGUgPSB0cnVlO1xuICAgICAgICBpZiAodGl0bGVfbW9kZSA9PSBMaXRlR3JhcGguVFJBTlNQQVJFTlRfVElUTEUpIHtcbiAgICAgICAgICAgIHJlbmRlcl90aXRsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRpdGxlX21vZGUgPT0gTGl0ZUdyYXBoLkFVVE9ISURFX1RJVExFICYmIG1vdXNlX292ZXIpIHtcbiAgICAgICAgICAgIHJlbmRlcl90aXRsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJlYSA9IHRtcF9hcmVhO1xuICAgICAgICBhcmVhWzBdID0gMDsgLy94XG4gICAgICAgIGFyZWFbMV0gPSByZW5kZXJfdGl0bGUgPyAtdGl0bGVfaGVpZ2h0IDogMDsgLy95XG4gICAgICAgIGFyZWFbMl0gPSBzaXplWzBdICsgMTsgLy93XG4gICAgICAgIGFyZWFbM10gPSByZW5kZXJfdGl0bGUgPyBzaXplWzFdICsgdGl0bGVfaGVpZ2h0IDogc2l6ZVsxXTsgLy9oXG5cbiAgICAgICAgdmFyIG9sZF9hbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcblxuICAgICAgICAvL2Z1bGwgbm9kZSBzaGFwZVxuICAgICAgICAvL2lmKG5vZGUuZmxhZ3MuY29sbGFwc2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSB8fCBsb3dfcXVhbGl0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChhcmVhWzBdLCBhcmVhWzFdLCBhcmVhWzJdLCBhcmVhWzNdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc2hhcGUgPT0gTGl0ZUdyYXBoLlJPVU5EX1NIQVBFIHx8XG4gICAgICAgICAgICAgICAgc2hhcGUgPT0gTGl0ZUdyYXBoLkNBUkRfU0hBUEVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoXG4gICAgICAgICAgICAgICAgICAgIGFyZWFbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFyZWFbMV0sXG4gICAgICAgICAgICAgICAgICAgIGFyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIGFyZWFbM10sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm91bmRfcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRSA/IDAgOiB0aGlzLnJvdW5kX3JhZGl1c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09IExpdGVHcmFwaC5DSVJDTEVfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzFdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG5cdFx0XHQvL3NlcGFyYXRvclxuXHRcdFx0aWYoIW5vZGUuZmxhZ3MuY29sbGFwc2VkKVxuXHRcdFx0e1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwwLDAsMC4yKVwiO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgLTEsIGFyZWFbMl0sIDIpO1xuXHRcdFx0fVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcblxuICAgICAgICBpZiAobm9kZS5vbkRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBub2RlLm9uRHJhd0JhY2tncm91bmQoY3R4LCB0aGlzLCB0aGlzLmNhbnZhcywgdGhpcy5ncmFwaF9tb3VzZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aXRsZSBiZyAocmVtZW1iZXIsIGl0IGlzIHJlbmRlcmVkIEFCT1ZFIHRoZSBub2RlKVxuICAgICAgICBpZiAocmVuZGVyX3RpdGxlIHx8IHRpdGxlX21vZGUgPT0gTGl0ZUdyYXBoLlRSQU5TUEFSRU5UX1RJVExFKSB7XG4gICAgICAgICAgICAvL3RpdGxlIGJhclxuICAgICAgICAgICAgaWYgKG5vZGUub25EcmF3VGl0bGVCYXIpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRHJhd1RpdGxlQmFyKCBjdHgsIHRpdGxlX2hlaWdodCwgc2l6ZSwgdGhpcy5kcy5zY2FsZSwgZmdjb2xvciApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICB0aXRsZV9tb2RlICE9IExpdGVHcmFwaC5UUkFOU1BBUkVOVF9USVRMRSAmJlxuICAgICAgICAgICAgICAgIChub2RlLmNvbnN0cnVjdG9yLnRpdGxlX2NvbG9yIHx8IHRoaXMucmVuZGVyX3RpdGxlX2NvbG9yZWQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVfY29sb3IgPSBub2RlLmNvbnN0cnVjdG9yLnRpdGxlX2NvbG9yIHx8IGZnY29sb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gTGl0ZUdyYXBoLkRFRkFVTFRfU0hBRE9XX0NPTE9SO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vKiBncmFkaWVudCB0ZXN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlX2dyYWRpZW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JhZCA9IExHcmFwaENhbnZhcy5ncmFkaWVudHNbdGl0bGVfY29sb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWQgPSBMR3JhcGhDYW52YXMuZ3JhZGllbnRzWyB0aXRsZV9jb2xvciBdID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDQwMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgwLCB0aXRsZV9jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlX2NvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY3R4Lmdsb2JhbEFscGhhID0gMC41ICogb2xkX2FscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSB8fCBsb3dfcXVhbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCgwLCAtdGl0bGVfaGVpZ2h0LCBzaXplWzBdICsgMSwgdGl0bGVfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAgc2hhcGUgPT0gTGl0ZUdyYXBoLlJPVU5EX1NIQVBFIHx8IHNoYXBlID09IExpdGVHcmFwaC5DQVJEX1NIQVBFICkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC10aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplWzBdICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm91bmRfcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5mbGFncy5jb2xsYXBzZWQgPyB0aGlzLnJvdW5kX3JhZGl1cyA6IDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdGl0bGUgYm94XG4gICAgICAgICAgICB2YXIgYm94X3NpemUgPSAxMDtcbiAgICAgICAgICAgIGlmIChub2RlLm9uRHJhd1RpdGxlQm94KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkRyYXdUaXRsZUJveChjdHgsIHRpdGxlX2hlaWdodCwgc2l6ZSwgdGhpcy5kcy5zY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSB8fFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5DSVJDTEVfU0hBUEUgfHxcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAqIC0wLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hfc2l6ZSAqIDAuNSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbm9kZS5ib3hjb2xvciB8fCBMaXRlR3JhcGguTk9ERV9ERUZBVUxUX0JPWENPTE9SO1xuXHRcdFx0XHRpZihsb3dfcXVhbGl0eSlcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoIHRpdGxlX2hlaWdodCAqIDAuNSAtIGJveF9zaXplICowLjUsIHRpdGxlX2hlaWdodCAqIC0wLjUgLSBib3hfc2l6ZSAqMC41LCBib3hfc2l6ZSAsIGJveF9zaXplICApO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmFyYyhcblx0XHRcdFx0XHRcdHRpdGxlX2hlaWdodCAqIDAuNSxcblx0XHRcdFx0XHRcdHRpdGxlX2hlaWdodCAqIC0wLjUsXG5cdFx0XHRcdFx0XHRib3hfc2l6ZSAqIDAuNSxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRNYXRoLlBJICogMlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG93X3F1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRpdGxlX2hlaWdodCAtIGJveF9zaXplKSAqIDAuNSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGl0bGVfaGVpZ2h0ICsgYm94X3NpemUpICogLTAuNSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hfc2l6ZSArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hfc2l6ZSArIDJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5vZGUuYm94Y29sb3IgfHwgTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9CT1hDT0xPUjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgICAgICh0aXRsZV9oZWlnaHQgLSBib3hfc2l6ZSkgKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICh0aXRsZV9oZWlnaHQgKyBib3hfc2l6ZSkgKiAtMC41LFxuICAgICAgICAgICAgICAgICAgICBib3hfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYm94X3NpemVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb2xkX2FscGhhO1xuXG4gICAgICAgICAgICAvL3RpdGxlIHRleHRcbiAgICAgICAgICAgIGlmIChub2RlLm9uRHJhd1RpdGxlVGV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25EcmF3VGl0bGVUZXh0KFxuICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcy5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aXRsZV90ZXh0X2ZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbG93X3F1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMudGl0bGVfdGV4dF9mb250O1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IFN0cmluZyhub2RlLmdldFRpdGxlKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBMaXRlR3JhcGguTk9ERV9TRUxFQ1RFRF9USVRMRV9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29uc3RydWN0b3IudGl0bGVfdGV4dF9jb2xvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV90aXRsZV9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KHRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZS5zdWJzdHIoMCwyMCksIC8vYXZvaWQgdXJscyB0b28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCwvLyArIG1lYXN1cmUud2lkdGggKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfVEVYVF9ZIC0gdGl0bGVfaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9USVRMRV9URVhUX1kgLSB0aXRsZV9oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8vc3ViZ3JhcGggYm94XG5cdFx0XHRpZiAoIW5vZGUuZmxhZ3MuY29sbGFwc2VkICYmIG5vZGUuc3ViZ3JhcGggJiYgIW5vZGUuc2tpcF9zdWJncmFwaF9idXR0b24pIHtcblx0XHRcdFx0dmFyIHcgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG5cdFx0XHRcdHZhciB4ID0gbm9kZS5zaXplWzBdIC0gdztcblx0XHRcdFx0dmFyIG92ZXIgPSBMaXRlR3JhcGguaXNJbnNpZGVSZWN0YW5nbGUoIHRoaXMuZ3JhcGhfbW91c2VbMF0gLSBub2RlLnBvc1swXSwgdGhpcy5ncmFwaF9tb3VzZVsxXSAtIG5vZGUucG9zWzFdLCB4KzIsIC13KzIsIHctNCwgdy00ICk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBvdmVyID8gXCIjODg4XCIgOiBcIiM1NTVcIjtcblx0XHRcdFx0aWYoIHNoYXBlID09IExpdGVHcmFwaC5CT1hfU0hBUEUgfHwgbG93X3F1YWxpdHkpXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHgrMiwgLXcrMiwgdy00LCB3LTQpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LnJvdW5kUmVjdCh4KzIsIC13KzIsIHctNCwgdy00LDQpO1xuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzMzM1wiO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oeCArIHcgKiAwLjIsIC13ICogMC42KTtcblx0XHRcdFx0Y3R4LmxpbmVUbyh4ICsgdyAqIDAuOCwgLXcgKiAwLjYpO1xuXHRcdFx0XHRjdHgubGluZVRvKHggKyB3ICogMC41LCAtdyAqIDAuMyk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vY3VzdG9tIHRpdGxlIHJlbmRlclxuICAgICAgICAgICAgaWYgKG5vZGUub25EcmF3VGl0bGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRHJhd1RpdGxlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlciBzZWxlY3Rpb24gbWFya2VyXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKG5vZGUub25Cb3VuZGluZykge1xuICAgICAgICAgICAgICAgIG5vZGUub25Cb3VuZGluZyhhcmVhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpdGxlX21vZGUgPT0gTGl0ZUdyYXBoLlRSQU5TUEFSRU5UX1RJVExFKSB7XG4gICAgICAgICAgICAgICAgYXJlYVsxXSAtPSB0aXRsZV9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYXJlYVszXSArPSB0aXRsZV9oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVswXSxcbiAgICAgICAgICAgICAgICAgICAgLTYgKyBhcmVhWzFdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIDEyICsgYXJlYVszXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSB8fFxuICAgICAgICAgICAgICAgIChzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRSAmJiBub2RlLmZsYWdzLmNvbGxhcHNlZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVswXSxcbiAgICAgICAgICAgICAgICAgICAgLTYgKyBhcmVhWzFdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIDEyICsgYXJlYVszXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3VuZF9yYWRpdXMgKiAyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkNBUkRfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgICAgICAgICAtNiArIGFyZWFbMF0sXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgMTIgKyBhcmVhWzJdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbM10sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm91bmRfcmFkaXVzICogMixcbiAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09IExpdGVHcmFwaC5DSVJDTEVfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzFdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41ICsgNixcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gTGl0ZUdyYXBoLk5PREVfQk9YX09VVExJTkVfQ09MT1I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmZ2NvbG9yO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWFyZ2luX2FyZWEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHZhciBsaW5rX2JvdW5kaW5nID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB2YXIgdGVtcEEgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIHZhciB0ZW1wQiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBldmVyeSBjb25uZWN0aW9uIHZpc2libGUgaW4gdGhlIGNhbnZhc1xuICAgICAqIE9QVElNSVpFIFRISVM6IHByZS1jYXRjaCBjb25uZWN0aW9ucyBwb3NpdGlvbiBpbnN0ZWFkIG9mIHJlY29tcHV0aW5nIHRoZW0gZXZlcnkgdGltZVxuICAgICAqIEBtZXRob2QgZHJhd0Nvbm5lY3Rpb25zXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb25zID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdmlzaWJsZV9hcmVhID0gdGhpcy52aXNpYmxlX2FyZWE7XG4gICAgICAgIG1hcmdpbl9hcmVhWzBdID0gdmlzaWJsZV9hcmVhWzBdIC0gMjA7XG4gICAgICAgIG1hcmdpbl9hcmVhWzFdID0gdmlzaWJsZV9hcmVhWzFdIC0gMjA7XG4gICAgICAgIG1hcmdpbl9hcmVhWzJdID0gdmlzaWJsZV9hcmVhWzJdICsgNDA7XG4gICAgICAgIG1hcmdpbl9hcmVhWzNdID0gdmlzaWJsZV9hcmVhWzNdICsgNDA7XG5cbiAgICAgICAgLy9kcmF3IGNvbm5lY3Rpb25zXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICAvL2ZvciBldmVyeSBub2RlXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBuID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgbiA8IGw7ICsrbikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgICAgICAgIC8vZm9yIGV2ZXJ5IGlucHV0ICh3ZSByZW5kZXIganVzdCBpbnB1dHMgYmVjYXVzZSBpdCBpcyBlYXNpZXIgYXMgZXZlcnkgc2xvdCBjYW4gb25seSBoYXZlIG9uZSBpbnB1dClcbiAgICAgICAgICAgIGlmICghbm9kZS5pbnB1dHMgfHwgIW5vZGUuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5saW5rID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5rX2lkID0gaW5wdXQubGluaztcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vZmluZCBsaW5rIGluZm9cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGluay5vcmlnaW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydF9ub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGFydF9ub2RlX3Nsb3QgPSBsaW5rLm9yaWdpbl9zbG90O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF9ub2RlX3Nsb3Rwb3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydF9ub2RlX3Nsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZS5wb3NbMF0gKyAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGUucG9zWzFdICsgMTBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFydF9ub2RlX3Nsb3Rwb3MgPSBzdGFydF9ub2RlLmdldENvbm5lY3Rpb25Qb3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGVfc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbmRfbm9kZV9zbG90cG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGksIHRlbXBCKTtcblxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBsaW5rIGJvdW5kaW5nXG4gICAgICAgICAgICAgICAgbGlua19ib3VuZGluZ1swXSA9IHN0YXJ0X25vZGVfc2xvdHBvc1swXTtcbiAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzFdID0gc3RhcnRfbm9kZV9zbG90cG9zWzFdO1xuICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMl0gPSBlbmRfbm9kZV9zbG90cG9zWzBdIC0gc3RhcnRfbm9kZV9zbG90cG9zWzBdO1xuICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbM10gPSBlbmRfbm9kZV9zbG90cG9zWzFdIC0gc3RhcnRfbm9kZV9zbG90cG9zWzFdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rX2JvdW5kaW5nWzJdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzBdICs9IGxpbmtfYm91bmRpbmdbMl07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMl0gPSBNYXRoLmFicyhsaW5rX2JvdW5kaW5nWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtfYm91bmRpbmdbM10gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMV0gKz0gbGlua19ib3VuZGluZ1szXTtcbiAgICAgICAgICAgICAgICAgICAgbGlua19ib3VuZGluZ1szXSA9IE1hdGguYWJzKGxpbmtfYm91bmRpbmdbM10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vc2tpcCBsaW5rcyBvdXRzaWRlIG9mIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcEJvdW5kaW5nKGxpbmtfYm91bmRpbmcsIG1hcmdpbl9hcmVhKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfc2xvdCA9IHN0YXJ0X25vZGUub3V0cHV0c1tzdGFydF9ub2RlX3Nsb3RdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfc2xvdCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRfc2xvdCB8fCAhZW5kX3Nsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGFydF9kaXIgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydF9zbG90LmRpciB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RhcnRfbm9kZS5ob3Jpem9udGFsID8gTGl0ZUdyYXBoLkRPV04gOiBMaXRlR3JhcGguUklHSFQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfZGlyID1cbiAgICAgICAgICAgICAgICAgICAgZW5kX3Nsb3QuZGlyIHx8XG4gICAgICAgICAgICAgICAgICAgIChub2RlLmhvcml6b250YWwgPyBMaXRlR3JhcGguVVAgOiBMaXRlR3JhcGguTEVGVCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpbmsoXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zLFxuICAgICAgICAgICAgICAgICAgICBlbmRfbm9kZV9zbG90cG9zLFxuICAgICAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vZXZlbnQgdHJpZ2dlcmVkIHJlbmRlcmVkIG9uIHRvcFxuICAgICAgICAgICAgICAgIGlmIChsaW5rICYmIGxpbmsuX2xhc3RfdGltZSAmJiBub3cgLSBsaW5rLl9sYXN0X3RpbWUgPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gMi4wIC0gKG5vdyAtIGxpbmsuX2xhc3RfdGltZSkgKiAwLjAwMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdG1wICogZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX25vZGVfc2xvdHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9kaXJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBhIGxpbmsgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICogQG1ldGhvZCByZW5kZXJMaW5rXG4gICAgICogQHBhcmFtIHt2ZWMyfSBhIHN0YXJ0IHBvc1xuICAgICAqIEBwYXJhbSB7dmVjMn0gYiBlbmQgcG9zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpbmsgdGhlIGxpbmsgb2JqZWN0IHdpdGggYWxsIHRoZSBsaW5rIGluZm9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBfYm9yZGVyIGlnbm9yZSB0aGUgc2hhZG93IG9mIHRoZSBsaW5rXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbG93IHNob3cgZmxvdyBhbmltYXRpb24gKGZvciBldmVudHMpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIHRoZSBjb2xvciBmb3IgdGhlIGxpbmtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfZGlyIHRoZSBkaXJlY3Rpb24gZW51bVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRfZGlyIHRoZSBkaXJlY3Rpb24gZW51bVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1fc3VibGluZXMgbnVtYmVyIG9mIHN1YmxpbmVzICh1c2VmdWwgdG8gcmVwcmVzZW50IHZlYzMgb3IgcmdiKVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnJlbmRlckxpbmsgPSBmdW5jdGlvbihcbiAgICAgICAgY3R4LFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBsaW5rLFxuICAgICAgICBza2lwX2JvcmRlcixcbiAgICAgICAgZmxvdyxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgZW5kX2RpcixcbiAgICAgICAgbnVtX3N1YmxpbmVzXG4gICAgKSB7XG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVfbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hvb3NlIGNvbG9yXG4gICAgICAgIGlmICghY29sb3IgJiYgbGluaykge1xuICAgICAgICAgICAgY29sb3IgPSBsaW5rLmNvbG9yIHx8IExHcmFwaENhbnZhcy5saW5rX3R5cGVfY29sb3JzW2xpbmsudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmRlZmF1bHRfbGlua19jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluayAhPSBudWxsICYmIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3NbbGluay5pZF0pIHtcbiAgICAgICAgICAgIGNvbG9yID0gXCIjRkZGXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9kaXIgPSBzdGFydF9kaXIgfHwgTGl0ZUdyYXBoLlJJR0hUO1xuICAgICAgICBlbmRfZGlyID0gZW5kX2RpciB8fCBMaXRlR3JhcGguTEVGVDtcblxuICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGEsIGIpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcl9jb25uZWN0aW9uc19ib3JkZXIgJiYgdGhpcy5kcy5zY2FsZSA+IDAuNikge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuY29ubmVjdGlvbnNfd2lkdGggKyA0O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgbnVtX3N1YmxpbmVzID0gbnVtX3N1YmxpbmVzIHx8IDE7XG4gICAgICAgIGlmIChudW1fc3VibGluZXMgPiAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9iZWdpbiBsaW5lIHNoYXBlXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fc3VibGluZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldHkgPSAoaSAtIChudW1fc3VibGluZXMgLSAxKSAqIDAuNSkgKiA1O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rc19yZW5kZXJfbW9kZSA9PSBMaXRlR3JhcGguU1BMSU5FX0xJTkspIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGFbMF0sIGFbMV0gKyBvZmZzZXR5KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfb2Zmc2V0X3ggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF9vZmZzZXRfeSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGVuZF9vZmZzZXRfeCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGVuZF9vZmZzZXRfeSA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGFydF9kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF94ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3ggPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF95ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRfeSA9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZW5kX2Rpcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0X3kgPSBkaXN0ICogLTAuMjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeSA9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBhWzBdICsgc3RhcnRfb2Zmc2V0X3gsXG4gICAgICAgICAgICAgICAgICAgIGFbMV0gKyBzdGFydF9vZmZzZXRfeSArIG9mZnNldHksXG4gICAgICAgICAgICAgICAgICAgIGJbMF0gKyBlbmRfb2Zmc2V0X3gsXG4gICAgICAgICAgICAgICAgICAgIGJbMV0gKyBlbmRfb2Zmc2V0X3kgKyBvZmZzZXR5LFxuICAgICAgICAgICAgICAgICAgICBiWzBdLFxuICAgICAgICAgICAgICAgICAgICBiWzFdICsgb2Zmc2V0eVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlua3NfcmVuZGVyX21vZGUgPT0gTGl0ZUdyYXBoLkxJTkVBUl9MSU5LKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhhWzBdLCBhWzFdICsgb2Zmc2V0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X29mZnNldF94ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfb2Zmc2V0X3kgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfb2Zmc2V0X3ggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfb2Zmc2V0X3kgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRfZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkxFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRfeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3kgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3kgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZW5kX2Rpcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0X3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF95ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGwgPSAxNTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgICAgICBhWzBdICsgc3RhcnRfb2Zmc2V0X3ggKiBsLFxuICAgICAgICAgICAgICAgICAgICBhWzFdICsgc3RhcnRfb2Zmc2V0X3kgKiBsICsgb2Zmc2V0eVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICAgICAgYlswXSArIGVuZF9vZmZzZXRfeCAqIGwsXG4gICAgICAgICAgICAgICAgICAgIGJbMV0gKyBlbmRfb2Zmc2V0X3kgKiBsICsgb2Zmc2V0eVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiWzBdLCBiWzFdICsgb2Zmc2V0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlua3NfcmVuZGVyX21vZGUgPT0gTGl0ZUdyYXBoLlNUUkFJR0hUX0xJTkspIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF94ID0gYVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfeSA9IGFbMV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZF94ID0gYlswXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kX3kgPSBiWzFdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydF9kaXIgPT0gTGl0ZUdyYXBoLlJJR0hUKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X3ggKz0gMTA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfeSArPSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZF9kaXIgPT0gTGl0ZUdyYXBoLkxFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX3ggLT0gMTA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX3kgLT0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3RhcnRfeCwgc3RhcnRfeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygoc3RhcnRfeCArIGVuZF94KSAqIDAuNSwgc3RhcnRfeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygoc3RhcnRfeCArIGVuZF94KSAqIDAuNSwgZW5kX3kpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZW5kX3gsIGVuZF95KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IC8vdW5rbm93blxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXJpbmcgdGhlIG91dGxpbmUgb2YgdGhlIGNvbm5lY3Rpb24gY2FuIGJlIGEgbGl0dGxlIGJpdCBzbG93XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25zX2JvcmRlciAmJlxuICAgICAgICAgICAgdGhpcy5kcy5zY2FsZSA+IDAuNiAmJlxuICAgICAgICAgICAgIXNraXBfYm9yZGVyXG4gICAgICAgICkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDAuNSlcIjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgLy9lbmQgbGluZSBzaGFwZVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoYSwgYiwgMC41LCBzdGFydF9kaXIsIGVuZF9kaXIpO1xuICAgICAgICBpZiAobGluayAmJiBsaW5rLl9wb3MpIHtcbiAgICAgICAgICAgIGxpbmsuX3Bvc1swXSA9IHBvc1swXTtcbiAgICAgICAgICAgIGxpbmsuX3Bvc1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVuZGVyIGFycm93IGluIHRoZSBtaWRkbGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5kcy5zY2FsZSA+PSAwLjYgJiZcbiAgICAgICAgICAgIHRoaXMuaGlnaHF1YWxpdHlfcmVuZGVyICYmXG4gICAgICAgICAgICBlbmRfZGlyICE9IExpdGVHcmFwaC5DRU5URVJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvL3JlbmRlciBhcnJvd1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25fYXJyb3dzKSB7XG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIHR3byBwb2ludHMgaW4gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgcG9zQSA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC4yNSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zQiA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC4yNixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zQyA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC43NSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zRCA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC43NixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0aGVtIHNvIHRoZSBhcnJvdyBwb2ludHMgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIHZhciBhbmdsZUEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZUIgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9jdXJ2ZWRfY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVBID0gLU1hdGguYXRhbjIocG9zQlswXSAtIHBvc0FbMF0sIHBvc0JbMV0gLSBwb3NBWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVCID0gLU1hdGguYXRhbjIocG9zRFswXSAtIHBvc0NbMF0sIHBvc0RbMV0gLSBwb3NDWzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZUIgPSBhbmdsZUEgPSBiWzFdID4gYVsxXSA/IDAgOiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vcmVuZGVyIGFycm93XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvc0FbMF0sIHBvc0FbMV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGVBKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygtNSwgLTMpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgKzcpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oKzUsIC0zKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvc0NbMF0sIHBvc0NbMV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGVCKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygtNSwgLTMpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgKzcpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oKzUsIC0zKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY2lyY2xlXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKHBvc1swXSwgcG9zWzFdLCA1LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXIgZmxvd2luZyBwb2ludHNcbiAgICAgICAgaWYgKGZsb3cpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAoTGl0ZUdyYXBoLmdldFRpbWUoKSAqIDAuMDAxICsgaSAqIDAuMikgJSAxO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgICAgIGYsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMocG9zWzBdLCBwb3NbMV0sIDUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vcmV0dXJucyB0aGUgbGluayBjZW50ZXIgcG9pbnQgYmFzZWQgb24gY3VydmF0dXJlXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb21wdXRlQ29ubmVjdGlvblBvaW50ID0gZnVuY3Rpb24oXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIHQsXG4gICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgZW5kX2RpclxuICAgICkge1xuICAgICAgICBzdGFydF9kaXIgPSBzdGFydF9kaXIgfHwgTGl0ZUdyYXBoLlJJR0hUO1xuICAgICAgICBlbmRfZGlyID0gZW5kX2RpciB8fCBMaXRlR3JhcGguTEVGVDtcblxuICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGEsIGIpO1xuICAgICAgICB2YXIgcDAgPSBhO1xuICAgICAgICB2YXIgcDEgPSBbYVswXSwgYVsxXV07XG4gICAgICAgIHZhciBwMiA9IFtiWzBdLCBiWzFdXTtcbiAgICAgICAgdmFyIHAzID0gYjtcblxuICAgICAgICBzd2l0Y2ggKHN0YXJ0X2Rpcikge1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICBwMVswXSArPSBkaXN0ICogLTAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5SSUdIVDpcbiAgICAgICAgICAgICAgICBwMVswXSArPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgIHAxWzFdICs9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgcDFbMV0gKz0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlbmRfZGlyKSB7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgIHAyWzBdICs9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgIHAyWzBdICs9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguVVA6XG4gICAgICAgICAgICAgICAgcDJbMV0gKz0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICBwMlsxXSArPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjMSA9ICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICAgICAgdmFyIGMyID0gMyAqICgoMSAtIHQpICogKDEgLSB0KSkgKiB0O1xuICAgICAgICB2YXIgYzMgPSAzICogKDEgLSB0KSAqICh0ICogdCk7XG4gICAgICAgIHZhciBjNCA9IHQgKiB0ICogdDtcblxuICAgICAgICB2YXIgeCA9IGMxICogcDBbMF0gKyBjMiAqIHAxWzBdICsgYzMgKiBwMlswXSArIGM0ICogcDNbMF07XG4gICAgICAgIHZhciB5ID0gYzEgKiBwMFsxXSArIGMyICogcDFbMV0gKyBjMyAqIHAyWzFdICsgYzQgKiBwM1sxXTtcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3RXhlY3V0aW9uT3JkZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjI1O1xuXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNzU7XG5cbiAgICAgICAgdmFyIHZpc2libGVfbm9kZXMgPSB0aGlzLnZpc2libGVfbm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaWJsZV9ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB2aXNpYmxlX25vZGVzW2ldO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICBub2RlLnBvc1swXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCxcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCxcbiAgICAgICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsXG4gICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG5vZGUub3JkZXIgPT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1swXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCxcbiAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNGRkZcIjtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICBub2RlLm9yZGVyLFxuICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogLTAuNSxcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSAtIDZcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIHdpZGdldHMgc3RvcmVkIGluc2lkZSBhIG5vZGVcbiAgICAgKiBAbWV0aG9kIGRyYXdOb2RlV2lkZ2V0c1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdOb2RlV2lkZ2V0cyA9IGZ1bmN0aW9uKFxuICAgICAgICBub2RlLFxuICAgICAgICBwb3NZLFxuICAgICAgICBjdHgsXG4gICAgICAgIGFjdGl2ZV93aWRnZXRcbiAgICApIHtcbiAgICAgICAgaWYgKCFub2RlLndpZGdldHMgfHwgIW5vZGUud2lkZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IG5vZGUuc2l6ZVswXTtcbiAgICAgICAgdmFyIHdpZGdldHMgPSBub2RlLndpZGdldHM7XG4gICAgICAgIHBvc1kgKz0gMjtcbiAgICAgICAgdmFyIEggPSBMaXRlR3JhcGguTk9ERV9XSURHRVRfSEVJR0hUO1xuICAgICAgICB2YXIgc2hvd190ZXh0ID0gdGhpcy5kcy5zY2FsZSA+IDAuNTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgIHZhciBvdXRsaW5lX2NvbG9yID0gTGl0ZUdyYXBoLldJREdFVF9PVVRMSU5FX0NPTE9SO1xuICAgICAgICB2YXIgYmFja2dyb3VuZF9jb2xvciA9IExpdGVHcmFwaC5XSURHRVRfQkdDT0xPUjtcbiAgICAgICAgdmFyIHRleHRfY29sb3IgPSBMaXRlR3JhcGguV0lER0VUX1RFWFRfQ09MT1I7XG5cdFx0dmFyIHNlY29uZGFyeV90ZXh0X2NvbG9yID0gTGl0ZUdyYXBoLldJREdFVF9TRUNPTkRBUllfVEVYVF9DT0xPUjtcbiAgICAgICAgdmFyIG1hcmdpbiA9IDE1O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHcgPSB3aWRnZXRzW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSBwb3NZO1xuICAgICAgICAgICAgaWYgKHcueSkge1xuICAgICAgICAgICAgICAgIHkgPSB3Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3Lmxhc3RfeSA9IHk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdXRsaW5lX2NvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzIyMlwiO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0Ly9jdHgubGluZVdpZHRoID0gMjtcblx0XHRcdGlmKHcuZGlzYWJsZWQpXG5cdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSAqPSAwLjU7XG5cdFx0XHR2YXIgd2lkZ2V0X3dpZHRoID0gdy53aWR0aCB8fCB3aWR0aDtcblxuICAgICAgICAgICAgc3dpdGNoICh3LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh3LmNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcuY2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgpO1xuXHRcdFx0XHRcdGlmKHNob3dfdGV4dCAmJiAhdy5kaXNhYmxlZClcblx0ICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCggbWFyZ2luLCB5LCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQody5uYW1lLCB3aWRnZXRfd2lkdGggKiAwLjUsIHkgKyBIICogMC43KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9nZ2xlXCI6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3V0bGluZV9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dfdGV4dClcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KG1hcmdpbiwgcG9zWSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCwgSCAqIDAuNSk7XG5cdFx0XHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KG1hcmdpbiwgcG9zWSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCApO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGlmKHNob3dfdGV4dCAmJiAhdy5kaXNhYmxlZClcblx0ICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB3LnZhbHVlID8gXCIjODlBXCIgOiBcIiMzMzNcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCB5ICsgSCAqIDAuNSwgSCAqIDAuMzYsIDAsIE1hdGguUEkgKiAyICk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWNvbmRhcnlfdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3Lm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh3Lm5hbWUsIG1hcmdpbiAqIDIsIHkgKyBIICogMC43KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB3LnZhbHVlID8gdGV4dF9jb2xvciA6IHNlY29uZGFyeV90ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdy5vcHRpb25zLm9uIHx8IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdy5vcHRpb25zLm9mZiB8fCBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0X3dpZHRoIC0gNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIEggKiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNsaWRlclwiOlxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KG1hcmdpbiwgeSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHcub3B0aW9ucy5tYXggLSB3Lm9wdGlvbnMubWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnZhbHVlID0gKHcudmFsdWUgLSB3Lm9wdGlvbnMubWluKSAvIHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYWN0aXZlX3dpZGdldCA9PSB3ID8gXCIjODlBXCIgOiBcIiM2NzhcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KG1hcmdpbiwgeSwgbnZhbHVlICogKHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIpLCBIKTtcblx0XHRcdFx0XHRpZihzaG93X3RleHQgJiYgIXcuZGlzYWJsZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QobWFyZ2luLCB5LCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcubWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyX252YWx1ZSA9ICh3Lm1hcmtlciAtIHcub3B0aW9ucy5taW4pIC8gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUE5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoIG1hcmdpbiArIG1hcmtlcl9udmFsdWUgKiAod2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiksIHksIDIsIEggKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcubmFtZSArIFwiICBcIiArIE51bWJlcih3LnZhbHVlKS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldF93aWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICsgSCAqIDAuN1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbWJvXCI6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3V0bGluZV9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRpZihzaG93X3RleHQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgsIEggKiAwLjUpO1xuXHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEggKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dfdGV4dCkge1xuXHRcdFx0XHRcdFx0aWYoIXcuZGlzYWJsZWQpXG5cdFx0ICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dF9jb2xvcjtcblx0XHRcdFx0XHRcdGlmKCF3LmRpc2FibGVkKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8obWFyZ2luICsgMTYsIHBvc1kgKyA1KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhtYXJnaW4gKyA2LCBwb3NZICsgSCAqIDAuNSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8obWFyZ2luICsgMTYsIHBvc1kgKyBIIC0gNSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyh3aWRnZXRfd2lkdGggLSBtYXJnaW4gLSAxNiwgcG9zWSArIDUpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKHdpZGdldF93aWR0aCAtIG1hcmdpbiAtIDYsIHBvc1kgKyBIICogMC41KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh3aWRnZXRfd2lkdGggLSBtYXJnaW4gLSAxNiwgcG9zWSArIEggLSA1KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWNvbmRhcnlfdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh3Lm5hbWUsIG1hcmdpbiAqIDIgKyA1LCB5ICsgSCAqIDAuNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAody50eXBlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlcih3LnZhbHVlKS50b0ZpeGVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5vcHRpb25zLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB3Lm9wdGlvbnMucHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIgLSAyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIEggKiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIHYgPSB3LnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRpZiggdy5vcHRpb25zLnZhbHVlcyApXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdy5vcHRpb25zLnZhbHVlcztcblx0XHRcdFx0XHRcdFx0XHRpZiggdmFsdWVzLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbiApXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXMgPSB2YWx1ZXMoKTtcblx0XHRcdFx0XHRcdFx0XHRpZih2YWx1ZXMgJiYgdmFsdWVzLmNvbnN0cnVjdG9yICE9PSBBcnJheSlcblx0XHRcdFx0XHRcdFx0XHRcdHYgPSB2YWx1ZXNbIHcudmFsdWUgXTtcblx0XHRcdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiAtIDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICsgSCAqIDAuN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3V0bGluZV9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dfdGV4dClcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KG1hcmdpbiwgcG9zWSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCwgSCAqIDAuNSk7XG5cdFx0XHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KCBtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEggKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpIHtcblx0XHRcdFx0XHRcdGlmKCF3LmRpc2FibGVkKVxuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG4gICAgXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHgucmVjdChtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgpO1xuXHRcdFx0XHRcdFx0Y3R4LmNsaXAoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlY29uZGFyeV90ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHcubmFtZSwgbWFyZ2luICogMiwgeSArIEggKiAwLjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFN0cmluZyh3LnZhbHVlKS5zdWJzdHIoMCwzMCksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIHkgKyBIICogMC43KTsgLy8zMCBjaGFycyBtYXhcblx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcuZHJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdy5kcmF3KGN0eCwgbm9kZSwgd2lkZ2V0X3dpZHRoLCB5LCBIKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc1kgKz0gKHcuY29tcHV0ZVNpemUgPyB3LmNvbXB1dGVTaXplKHdpZGdldF93aWR0aClbMV0gOiBIKSArIDQ7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmVkaXRvcl9hbHBoYTtcblxuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwcm9jZXNzIGFuIGV2ZW50IG9uIHdpZGdldHNcbiAgICAgKiBAbWV0aG9kIHByb2Nlc3NOb2RlV2lkZ2V0c1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NOb2RlV2lkZ2V0cyA9IGZ1bmN0aW9uKFxuICAgICAgICBub2RlLFxuICAgICAgICBwb3MsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBhY3RpdmVfd2lkZ2V0XG4gICAgKSB7XG4gICAgICAgIGlmICghbm9kZS53aWRnZXRzIHx8ICFub2RlLndpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gcG9zWzBdIC0gbm9kZS5wb3NbMF07XG4gICAgICAgIHZhciB5ID0gcG9zWzFdIC0gbm9kZS5wb3NbMV07XG4gICAgICAgIHZhciB3aWR0aCA9IG5vZGUuc2l6ZVswXTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLndpZGdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB3ID0gbm9kZS53aWRnZXRzW2ldO1xuXHRcdFx0aWYoIXcgfHwgdy5kaXNhYmxlZClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgd2lkZ2V0X2hlaWdodCA9IHcuY29tcHV0ZVNpemUgPyB3LmNvbXB1dGVTaXplKHdpZHRoKVsxXSA6IExpdGVHcmFwaC5OT0RFX1dJREdFVF9IRUlHSFQ7XG5cdFx0XHR2YXIgd2lkZ2V0X3dpZHRoID0gdy53aWR0aCB8fCB3aWR0aDtcblx0XHRcdC8vb3V0c2lkZVxuXHRcdFx0aWYgKCB3ICE9IGFjdGl2ZV93aWRnZXQgJiYgXG5cdFx0XHRcdCh4IDwgNiB8fCB4ID4gd2lkZ2V0X3dpZHRoIC0gMTIgfHwgeSA8IHcubGFzdF95IHx8IHkgPiB3Lmxhc3RfeSArIHdpZGdldF9oZWlnaHQgfHwgdy5sYXN0X3kgPT09IHVuZGVmaW5lZCkgKSBcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciBvbGRfdmFsdWUgPSB3LnZhbHVlO1xuXG4gICAgICAgICAgICAvL2lmICggdyA9PSBhY3RpdmVfd2lkZ2V0IHx8ICh4ID4gNiAmJiB4IDwgd2lkZ2V0X3dpZHRoIC0gMTIgJiYgeSA+IHcubGFzdF95ICYmIHkgPCB3Lmxhc3RfeSArIHdpZGdldF9oZWlnaHQpICkge1xuXHRcdFx0Ly9pbnNpZGUgd2lkZ2V0XG5cdFx0XHRzd2l0Y2ggKHcudHlwZSkge1xuXHRcdFx0XHRjYXNlIFwiYnV0dG9uXCI6XG5cdFx0XHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2Vkb3duXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3LmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5jYWxsYmFjayh3LCB0aGF0LCBub2RlLCBwb3MsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3LmNsaWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJzbGlkZXJcIjpcblx0XHRcdFx0XHR2YXIgcmFuZ2UgPSB3Lm9wdGlvbnMubWF4IC0gdy5vcHRpb25zLm1pbjtcblx0XHRcdFx0XHR2YXIgbnZhbHVlID0gTWF0aC5jbGFtcCgoeCAtIDE1KSAvICh3aWRnZXRfd2lkdGggLSAzMCksIDAsIDEpO1xuXHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWluICsgKHcub3B0aW9ucy5tYXggLSB3Lm9wdGlvbnMubWluKSAqIG52YWx1ZTtcblx0XHRcdFx0XHRpZiAody5jYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0aW5uZXJfdmFsdWVfY2hhbmdlKHcsIHcudmFsdWUpO1xuXHRcdFx0XHRcdFx0fSwgMjApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJudW1iZXJcIjpcblx0XHRcdFx0Y2FzZSBcImNvbWJvXCI6XG5cdFx0XHRcdFx0dmFyIG9sZF92YWx1ZSA9IHcudmFsdWU7XG5cdFx0XHRcdFx0aWYgKGV2ZW50LnR5cGUgPT0gXCJtb3VzZW1vdmVcIiAmJiB3LnR5cGUgPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0dy52YWx1ZSArPSBldmVudC5kZWx0YVggKiAwLjEgKiAody5vcHRpb25zLnN0ZXAgfHwgMSk7XG5cdFx0XHRcdFx0XHRpZiAoIHcub3B0aW9ucy5taW4gIT0gbnVsbCAmJiB3LnZhbHVlIDwgdy5vcHRpb25zLm1pbiApIHtcblx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IHcub3B0aW9ucy5taW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHcub3B0aW9ucy5tYXggIT0gbnVsbCAmJiB3LnZhbHVlID4gdy5vcHRpb25zLm1heCApIHtcblx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IHcub3B0aW9ucy5tYXg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09IFwibW91c2Vkb3duXCIpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB3Lm9wdGlvbnMudmFsdWVzO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlcyAmJiB2YWx1ZXMuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcyA9IHcub3B0aW9ucy52YWx1ZXModywgbm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzX2xpc3QgPSBudWxsO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiggdy50eXBlICE9IFwibnVtYmVyXCIpXG5cdFx0XHRcdFx0XHRcdHZhbHVlc19saXN0ID0gdmFsdWVzLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IHZhbHVlcyA6IE9iamVjdC5rZXlzKHZhbHVlcyk7XG5cblx0XHRcdFx0XHRcdHZhciBkZWx0YSA9IHggPCA0MCA/IC0xIDogeCA+IHdpZGdldF93aWR0aCAtIDQwID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRpZiAody50eXBlID09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdFx0dy52YWx1ZSArPSBkZWx0YSAqIDAuMSAqICh3Lm9wdGlvbnMuc3RlcCB8fCAxKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWluICE9IG51bGwgJiYgdy52YWx1ZSA8IHcub3B0aW9ucy5taW4gKSB7XG5cdFx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IHcub3B0aW9ucy5taW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWF4ICE9IG51bGwgJiYgdy52YWx1ZSA+IHcub3B0aW9ucy5tYXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IHcub3B0aW9ucy5tYXg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVsdGEpIHsgLy9jbGlja2VkIGluIGFycm93LCB1c2VkIGZvciBjb21ib3MgXG5cdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxhc3RfbW91c2VjbGljayA9IDA7IC8vYXZvaWRzIGRvYmwgY2xpY2sgZXZlbnRcblx0XHRcdFx0XHRcdFx0aWYodmFsdWVzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSB2YWx1ZXNfbGlzdC5pbmRleE9mKCBTdHJpbmcoIHcudmFsdWUgKSApICsgZGVsdGE7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IHZhbHVlc19saXN0LmluZGV4T2YoIHcudmFsdWUgKSArIGRlbHRhO1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5kZXggPj0gdmFsdWVzX2xpc3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSB2YWx1ZXNfbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChpbmRleCA8IDApIHtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoIHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKVxuXHRcdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy9jb21ibyBjbGlja2VkIFxuXHRcdFx0XHRcdFx0XHR2YXIgdGV4dF92YWx1ZXMgPSB2YWx1ZXMgIT0gdmFsdWVzX2xpc3QgPyBPYmplY3QudmFsdWVzKHZhbHVlcykgOiB2YWx1ZXM7XG5cdFx0XHRcdFx0XHRcdHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudSh0ZXh0X3ZhbHVlcywge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2NhbGU6IE1hdGgubWF4KDEsIHRoaXMuZHMuc2NhbGUpLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lOiBcImRhcmtcIixcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLmJpbmQodylcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdHJlZl93aW5kb3cpO1xuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYsIG9wdGlvbiwgZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZih2YWx1ZXMgIT0gdmFsdWVzX2xpc3QpXG5cdFx0XHRcdFx0XHRcdFx0XHR2ID0gdGV4dF92YWx1ZXMuaW5kZXhPZih2KTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdjtcblx0XHRcdFx0XHRcdFx0XHRpbm5lcl92YWx1ZV9jaGFuZ2UodGhpcywgdik7XG5cdFx0XHRcdFx0XHRcdFx0dGhhdC5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gLy9lbmQgbW91c2Vkb3duXG5cdFx0XHRcdFx0ZWxzZSBpZihldmVudC50eXBlID09IFwibW91c2V1cFwiICYmIHcudHlwZSA9PSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBkZWx0YSA9IHggPCA0MCA/IC0xIDogeCA+IHdpZGdldF93aWR0aCAtIDQwID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQuY2xpY2tfdGltZSA8IDIwMCAmJiBkZWx0YSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvbXB0KFwiVmFsdWVcIix3LnZhbHVlLGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSBOdW1iZXIodik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbm5lcl92YWx1ZV9jaGFuZ2UodGhpcywgdGhpcy52YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fS5iaW5kKHcpLFxuXHRcdFx0XHRcdFx0XHRcdGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiggb2xkX3ZhbHVlICE9IHcudmFsdWUgKVxuXHRcdFx0XHRcdFx0c2V0VGltZW91dChcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJfdmFsdWVfY2hhbmdlKHRoaXMsIHRoaXMudmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9LmJpbmQodyksXG5cdFx0XHRcdFx0XHRcdDIwXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInRvZ2dsZVwiOlxuXHRcdFx0XHRcdGlmIChldmVudC50eXBlID09IFwibW91c2Vkb3duXCIpIHtcblx0XHRcdFx0XHRcdHcudmFsdWUgPSAhdy52YWx1ZTtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlubmVyX3ZhbHVlX2NoYW5nZSh3LCB3LnZhbHVlKTtcblx0XHRcdFx0XHRcdH0sIDIwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdFx0Y2FzZSBcInRleHRcIjpcblx0XHRcdFx0XHRpZiAoZXZlbnQudHlwZSA9PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByb21wdChcIlZhbHVlXCIsdy52YWx1ZSxmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHY7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJfdmFsdWVfY2hhbmdlKHRoaXMsIHYpO1xuXHRcdFx0XHRcdFx0XHR9LmJpbmQodyksXG5cdFx0XHRcdFx0XHRcdGV2ZW50LHcub3B0aW9ucyA/IHcub3B0aW9ucy5tdWx0aWxpbmUgOiBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZiAody5tb3VzZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB3Lm1vdXNlKGV2ZW50LCBbeCwgeV0sIG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH0gLy9lbmQgc3dpdGNoXG5cblx0XHRcdC8vdmFsdWUgY2hhbmdlZFxuXHRcdFx0aWYoIG9sZF92YWx1ZSAhPSB3LnZhbHVlIClcblx0XHRcdHtcblx0XHRcdFx0aWYobm9kZS5vbldpZGdldENoYW5nZWQpXG5cdFx0XHRcdFx0bm9kZS5vbldpZGdldENoYW5nZWQoIHcubmFtZSx3LnZhbHVlLG9sZF92YWx1ZSx3ICk7XG4gICAgICAgICAgICAgICAgbm9kZS5ncmFwaC5fdmVyc2lvbisrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdztcbiAgICAgICAgfS8vZW5kIGZvclxuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX3ZhbHVlX2NoYW5nZSh3aWRnZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB3aWRnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICggd2lkZ2V0Lm9wdGlvbnMgJiYgd2lkZ2V0Lm9wdGlvbnMucHJvcGVydHkgJiYgbm9kZS5wcm9wZXJ0aWVzW3dpZGdldC5vcHRpb25zLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0UHJvcGVydHkoIHdpZGdldC5vcHRpb25zLnByb3BlcnR5LCB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZGdldC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHdpZGdldC5jYWxsYmFjayh3aWRnZXQudmFsdWUsIHRoYXQsIG5vZGUsIHBvcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIGV2ZXJ5IGdyb3VwIGFyZWEgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgKiBAbWV0aG9kIGRyYXdHcm91cHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3R3JvdXBzID0gZnVuY3Rpb24oY2FudmFzLCBjdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncmFwaC5fZ3JvdXBzO1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNSAqIHRoaXMuZWRpdG9yX2FscGhhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG5cbiAgICAgICAgICAgIGlmICghb3ZlcmxhcEJvdW5kaW5nKHRoaXMudmlzaWJsZV9hcmVhLCBncm91cC5fYm91bmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vb3V0IG9mIHRoZSB2aXNpYmxlIGFyZWFcblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyb3VwLmNvbG9yIHx8IFwiIzMzNVwiO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ3JvdXAuY29sb3IgfHwgXCIjMzM1XCI7XG4gICAgICAgICAgICB2YXIgcG9zID0gZ3JvdXAuX3BvcztcbiAgICAgICAgICAgIHZhciBzaXplID0gZ3JvdXAuX3NpemU7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjI1ICogdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gKyAwLjUsIHBvc1sxXSArIDAuNSwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zWzBdICsgc2l6ZVswXSwgcG9zWzFdICsgc2l6ZVsxXSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSArIHNpemVbMF0gLSAxMCwgcG9zWzFdICsgc2l6ZVsxXSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSArIHNpemVbMF0sIHBvc1sxXSArIHNpemVbMV0gLSAxMCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICB2YXIgZm9udF9zaXplID1cbiAgICAgICAgICAgICAgICBncm91cC5mb250X3NpemUgfHwgTGl0ZUdyYXBoLkRFRkFVTFRfR1JPVVBfRk9OVF9TSVpFO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250X3NpemUgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZ3JvdXAudGl0bGUsIHBvc1swXSArIDQsIHBvc1sxXSArIGZvbnRfc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmFkanVzdE5vZGVzU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbm9kZXNbaV0uc2l6ZSA9IG5vZGVzW2ldLmNvbXB1dGVTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVzaXplcyB0aGUgY2FudmFzIHRvIGEgZ2l2ZW4gc2l6ZSwgaWYgbm8gc2l6ZSBpcyBwYXNzZWQsIHRoZW4gaXQgdHJpZXMgdG8gZmlsbCB0aGUgcGFyZW50Tm9kZVxuICAgICAqIEBtZXRob2QgcmVzaXplXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmNhbnZhcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2lkdGggPSBwYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLndpZHRoID09IHdpZHRoICYmIHRoaXMuY2FudmFzLmhlaWdodCA9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5iZ2NhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICB0aGlzLmJnY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3dpdGNoZXMgdG8gbGl2ZSBtb2RlIChub2RlIHNoYXBlcyBhcmUgbm90IHJlbmRlcmVkLCBvbmx5IHRoZSBjb250ZW50KVxuICAgICAqIHRoaXMgZmVhdHVyZSB3YXMgZGVzaWduZWQgd2hlbiBncmFwaHMgd2hlcmUgbWVhbnQgdG8gY3JlYXRlIHVzZXIgaW50ZXJmYWNlc1xuICAgICAqIEBtZXRob2Qgc3dpdGNoTGl2ZU1vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zd2l0Y2hMaXZlTW9kZSA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVfbW9kZSA9ICF0aGlzLmxpdmVfbW9kZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmxpdmVfbW9kZSA/IDEuMSA6IDAuOTtcbiAgICAgICAgaWYgKHRoaXMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JfYWxwaGEgPSAwLjE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5lZGl0b3JfYWxwaGEgKj0gZGVsdGE7XG4gICAgICAgICAgICBzZWxmLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMSAmJiBzZWxmLmVkaXRvcl9hbHBoYSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHQpO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXZlX21vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDEgJiYgc2VsZi5lZGl0b3JfYWxwaGEgPiAwLjk5KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0KTtcbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvcl9hbHBoYSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLm9uTm9kZVNlbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuOyAvL2Rpc2FibGVkXG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUudG91Y2hIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy9hbGVydChcImZvb1wiKTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcbiAgICAgICAgICAgIHR5cGUgPSBcIlwiO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJtb3VzZWRvd25cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJtb3VzZW1vdmVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICAgICAgICAgIHR5cGUgPSBcIm1vdXNldXBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbml0TW91c2VFdmVudCh0eXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUsIHZpZXcsIGNsaWNrQ291bnQsXG4gICAgICAgIC8vICAgICAgICAgICBzY3JlZW5YLCBzY3JlZW5ZLCBjbGllbnRYLCBjbGllbnRZLCBjdHJsS2V5LFxuICAgICAgICAvLyAgICAgICAgICAgYWx0S2V5LCBzaGlmdEtleSwgbWV0YUtleSwgYnV0dG9uLCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICB2YXIgd2luZG93ID0gdGhpcy5nZXRDYW52YXNXaW5kb3coKTtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gICAgICAgIHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICB3aW5kb3csXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZmlyc3Quc2NyZWVuWCxcbiAgICAgICAgICAgIGZpcnN0LnNjcmVlblksXG4gICAgICAgICAgICBmaXJzdC5jbGllbnRYLFxuICAgICAgICAgICAgZmlyc3QuY2xpZW50WSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMCAvKmxlZnQqLyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICAvKiBDT05URVhUIE1FTlUgKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBMR3JhcGhDYW52YXMub25Hcm91cEFkZCA9IGZ1bmN0aW9uKGluZm8sIGVudHJ5LCBtb3VzZV9ldmVudCkge1xuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBMaXRlR3JhcGguTEdyYXBoR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAucG9zID0gY2FudmFzLmNvbnZlcnRFdmVudFRvQ2FudmFzT2Zmc2V0KG1vdXNlX2V2ZW50KTtcbiAgICAgICAgY2FudmFzLmdyYXBoLmFkZChncm91cCk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVBZGQgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucywgZSwgcHJldl9tZW51LCBjYWxsYmFjaykge1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBjYW52YXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBncmFwaCA9IGNhbnZhcy5ncmFwaDtcbiAgICAgICAgaWYgKCFncmFwaClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9vbk1lbnVBZGRlZChiYXNlX2NhdGVnb3J5ICxwcmV2X21lbnUpe1xuICAgIFxuICAgICAgICAgICAgdmFyIGNhdGVnb3JpZXMgID0gTGl0ZUdyYXBoLmdldE5vZGVUeXBlc0NhdGVnb3JpZXMoY2FudmFzLmZpbHRlciB8fCBncmFwaC5maWx0ZXIpLmZpbHRlcihmdW5jdGlvbihjYXRlZ29yeSl7cmV0dXJuIGNhdGVnb3J5LnN0YXJ0c1dpdGgoYmFzZV9jYXRlZ29yeSl9KTtcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgXG4gICAgICAgICAgICBjYXRlZ29yaWVzLm1hcChmdW5jdGlvbihjYXRlZ29yeSl7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCFjYXRlZ29yeSkgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICBcbiAgICAgICAgICAgICAgICB2YXIgYmFzZV9jYXRlZ29yeV9yZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGJhc2VfY2F0ZWdvcnkgKyAnKScpO1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeV9uYW1lID0gY2F0ZWdvcnkucmVwbGFjZShiYXNlX2NhdGVnb3J5X3JlZ2V4LFwiXCIpLnNwbGl0KCcvJylbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5X3BhdGggPSBiYXNlX2NhdGVnb3J5ICA9PT0gJycgPyBjYXRlZ29yeV9uYW1lICsgJy8nIDogYmFzZV9jYXRlZ29yeSArIGNhdGVnb3J5X25hbWUgKyAnLyc7XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjYXRlZ29yeV9uYW1lO1xuICAgICAgICAgICAgICAgIGlmKG5hbWUuaW5kZXhPZihcIjo6XCIpICE9IC0xKSAvL2luIGNhc2UgaXQgaGFzIGEgbmFtZXNwYWNlIGxpa2UgXCJzaGFkZXI6Om1hdGgvcmFuZFwiIGl0IGhpZGVzIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoXCI6OlwiKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uKGVudHJ5KXtyZXR1cm4gZW50cnkudmFsdWUgPT09IGNhdGVnb3J5X3BhdGh9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IHZhbHVlOiBjYXRlZ29yeV9wYXRoLCBjb250ZW50OiBuYW1lLCBoYXNfc3VibWVudTogdHJ1ZSwgY2FsbGJhY2sgOiBmdW5jdGlvbih2YWx1ZSwgZXZlbnQsIG1vdXNlRXZlbnQsIGNvbnRleHRNZW51KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyX29uTWVudUFkZGVkKHZhbHVlLnZhbHVlLCBjb250ZXh0TWVudSlcbiAgICAgICAgICAgICAgICAgICAgfX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgdmFyIG5vZGVzID0gTGl0ZUdyYXBoLmdldE5vZGVUeXBlc0luQ2F0ZWdvcnkoYmFzZV9jYXRlZ29yeS5zbGljZSgwLCAtMSksIGNhbnZhcy5maWx0ZXIgfHwgZ3JhcGguZmlsdGVyICk7XG4gICAgICAgICAgICBub2Rlcy5tYXAoZnVuY3Rpb24obm9kZSl7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc2tpcF9saXN0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0geyB2YWx1ZTogbm9kZS50eXBlLCBjb250ZW50OiBub2RlLnRpdGxlLCBoYXNfc3VibWVudTogZmFsc2UgLCBjYWxsYmFjayA6IGZ1bmN0aW9uKHZhbHVlLCBldmVudCwgbW91c2VFdmVudCwgY29udGV4dE1lbnUpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdF9ldmVudCA9IGNvbnRleHRNZW51LmdldEZpcnN0RXZlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUodmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvcyA9IGNhbnZhcy5jb252ZXJ0RXZlbnRUb0NhbnZhc09mZnNldChmaXJzdF9ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmdyYXBoLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgXG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUoIGVudHJpZXMsIHsgZXZlbnQ6IGUsIHBhcmVudE1lbnU6IHByZXZfbWVudSB9LCByZWZfd2luZG93ICk7XG4gICAgXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaW5uZXJfb25NZW51QWRkZWQoJycscHJldl9tZW51KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Q29sbGFwc2VBbGwgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVFZGl0ID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIExHcmFwaENhbnZhcy5zaG93TWVudU5vZGVPcHRpb25hbElucHV0cyA9IGZ1bmN0aW9uKFxuICAgICAgICB2LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBlLFxuICAgICAgICBwcmV2X21lbnUsXG4gICAgICAgIG5vZGVcbiAgICApIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBjYW52YXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBub2RlLm9wdGlvbmFsX2lucHV0cztcbiAgICAgICAgaWYgKG5vZGUub25HZXRJbnB1dHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBub2RlLm9uR2V0SW5wdXRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBlbnRyeVswXTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnlbMl0gJiYgZW50cnlbMl0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBlbnRyeVsyXS5sYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IGNvbnRlbnQ6IGxhYmVsLCB2YWx1ZTogZW50cnkgfTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnlbMV0gPT0gTGl0ZUdyYXBoLkFDVElPTikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNsYXNzTmFtZSA9IFwiZXZlbnRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25NZW51Tm9kZUlucHV0cykge1xuICAgICAgICAgICAgZW50cmllcyA9IHRoaXMub25NZW51Tm9kZUlucHV0cyhlbnRyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwibm8gaW5wdXQgZW50cmllc1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZfd2luZG93XG4gICAgICAgICk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBlLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdi5jYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsIHYsIGUsIHByZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi52YWx1ZSkge1xuXHRcdFx0XHRub2RlLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkSW5wdXQodi52YWx1ZVswXSwgdi52YWx1ZVsxXSwgdi52YWx1ZVsyXSk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcblx0XHRcdFx0bm9kZS5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxPdXRwdXRzID0gZnVuY3Rpb24oXG4gICAgICAgIHYsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGUsXG4gICAgICAgIHByZXZfbWVudSxcbiAgICAgICAgbm9kZVxuICAgICkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9uYWxfb3V0cHV0cztcbiAgICAgICAgaWYgKG5vZGUub25HZXRPdXRwdXRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbm9kZS5vbkdldE91dHB1dHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc2VwYXJhdG9yP1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5mbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmZsYWdzLnNraXBfcmVwZWF0ZWRfb3V0cHV0cyAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmZpbmRPdXRwdXRTbG90KGVudHJ5WzBdKSAhPSAtMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IC8vc2tpcCB0aGUgb25lcyBhbHJlYWR5IG9uXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZW50cnlbMF07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzJdICYmIGVudHJ5WzJdLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZW50cnlbMl0ubGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0geyBjb250ZW50OiBsYWJlbCwgdmFsdWU6IGVudHJ5IH07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzFdID09IExpdGVHcmFwaC5FVkVOVCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNsYXNzTmFtZSA9IFwiZXZlbnRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25NZW51Tm9kZU91dHB1dHMpIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSB0aGlzLm9uTWVudU5vZGVPdXRwdXRzKGVudHJpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lbnUgPSBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KFxuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRNZW51OiBwcmV2X21lbnUsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZl93aW5kb3dcbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYsIGUsIHByZXYpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2LmNhbGxiYWNrLmNhbGwodGhhdCwgbm9kZSwgdiwgZSwgcHJldik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdi52YWx1ZVsxXTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy9zdWJtZW51IHdoeT9cbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgY29udGVudDogaSwgdmFsdWU6IHZhbHVlW2ldIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KGVudHJpZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZW51OiBwcmV2X21lbnUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkT3V0cHV0KHYudmFsdWVbMF0sIHYudmFsdWVbMV0sIHYudmFsdWVbMl0pO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uU2hvd01lbnVOb2RlUHJvcGVydGllcyA9IGZ1bmN0aW9uKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZSxcbiAgICAgICAgcHJldl9tZW51LFxuICAgICAgICBub2RlXG4gICAgKSB7XG4gICAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBjYW52YXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUucHJvcGVydGllc1tpXSAhPT0gdW5kZWZpbmVkID8gbm9kZS5wcm9wZXJ0aWVzW2ldIDogXCIgXCI7XG5cdFx0XHRpZiggdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgKVxuXHRcdFx0XHR2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdHZhciBpbmZvID0gbm9kZS5nZXRQcm9wZXJ0eUluZm8oaSk7XG5cdFx0XHRpZihpbmZvLnR5cGUgPT0gXCJlbnVtXCIgfHwgaW5mby50eXBlID09IFwiY29tYm9cIilcblx0XHRcdFx0dmFsdWUgPSBMR3JhcGhDYW52YXMuZ2V0UHJvcGVydHlQcmludGFibGVWYWx1ZSggdmFsdWUsIGluZm8udmFsdWVzICk7XG5cbiAgICAgICAgICAgIC8vdmFsdWUgY291bGQgY29udGFpbiBpbnZhbGlkIGh0bWwgY2hhcmFjdGVycywgY2xlYW4gdGhhdFxuICAgICAgICAgICAgdmFsdWUgPSBMR3JhcGhDYW52YXMuZGVjb2RlSFRNTCh2YWx1ZSk7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6XG4gICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J3Byb3BlcnR5X25hbWUnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgKGluZm8ubGFiZWwgPyBpbmZvLmxhYmVsIDogaSkgK1xuICAgICAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J3Byb3BlcnR5X3ZhbHVlJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgIGFsbG93X2h0bWw6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZl93aW5kb3dcbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYsIG9wdGlvbnMsIGUsIHByZXYpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNhbnZhcy5zaG93RWRpdFByb3BlcnR5VmFsdWUobm9kZSwgdi52YWx1ZSwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbcmVjdC5sZWZ0LCByZWN0LnRvcF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMuZGVjb2RlSFRNTCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGUuaW5uZXJUZXh0ID0gc3RyO1xuICAgICAgICByZXR1cm4gZS5pbm5lckhUTUw7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vblJlc2l6ZU5vZGUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZSwgbWVudSwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNpemUgPSBub2RlLmNvbXB1dGVTaXplKCk7XG4gICAgICAgIGlmIChub2RlLm9uUmVzaXplKVxuICAgICAgICAgICAgbm9kZS5vblJlc2l6ZShub2RlLnNpemUpO1xuICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNob3dMaW5rTWVudSA9IGZ1bmN0aW9uKGxpbmssIGUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHRcdGNvbnNvbGUubG9nKGxpbmspO1xuXHRcdHZhciBvcHRpb25zID0gW1wiQWRkIE5vZGVcIixudWxsLFwiRGVsZXRlXCJdO1xuICAgICAgICB2YXIgbWVudSA9IG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUob3B0aW9ucywge1xuICAgICAgICAgICAgZXZlbnQ6IGUsXG5cdFx0XHR0aXRsZTogbGluay5kYXRhICE9IG51bGwgPyBsaW5rLmRhdGEuY29uc3RydWN0b3IubmFtZSA6IG51bGwsXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZFxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYsb3B0aW9ucyxlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQWRkIE5vZGVcIjpcblx0XHRcdFx0XHRMR3JhcGhDYW52YXMub25NZW51QWRkKG51bGwsIG51bGwsIGUsIG1lbnUsIGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJub2RlIGF1dG9jb25uZWN0XCIpO1xuXHRcdFx0XHRcdFx0dmFyIG5vZGVfbGVmdCA9IHRoYXQuZ3JhcGguZ2V0Tm9kZUJ5SWQoIGxpbmsub3JpZ2luX2lkICk7XG5cdFx0XHRcdFx0XHR2YXIgbm9kZV9yaWdodCA9IHRoYXQuZ3JhcGguZ2V0Tm9kZUJ5SWQoIGxpbmsudGFyZ2V0X2lkICk7XG5cdFx0XHRcdFx0XHRpZighbm9kZS5pbnB1dHMgfHwgIW5vZGUuaW5wdXRzLmxlbmd0aCB8fCAhbm9kZS5vdXRwdXRzIHx8ICFub2RlLm91dHB1dHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRpZiggbm9kZV9sZWZ0Lm91dHB1dHNbIGxpbmsub3JpZ2luX3Nsb3QgXS50eXBlID09IG5vZGUuaW5wdXRzWzBdLnR5cGUgJiYgbm9kZS5vdXRwdXRzWzBdLnR5cGUgPT0gbm9kZV9yaWdodC5pbnB1dHNbMF0udHlwZSApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG5vZGVfbGVmdC5jb25uZWN0KCBsaW5rLm9yaWdpbl9zbG90LCBub2RlLCAwICk7XG5cdFx0XHRcdFx0XHRcdG5vZGUuY29ubmVjdCggMCwgbm9kZV9yaWdodCwgbGluay50YXJnZXRfc2xvdCApO1xuXHRcdFx0XHRcdFx0XHRub2RlLnBvc1swXSAtPSBub2RlLnNpemVbMF0gKiAwLjU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRlbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdyYXBoLnJlbW92ZUxpbmsobGluay5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vblNob3dQcm9wZXJ0eUVkaXRvciA9IGZ1bmN0aW9uKGl0ZW0sIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGlucHV0X2h0bWwgPSBcIlwiO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBpdGVtLnByb3BlcnR5IHx8IFwidGl0bGVcIjtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZVtwcm9wZXJ0eV07XG5cbiAgICAgICAgdmFyIGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcImdyYXBoZGlhbG9nXCI7XG4gICAgICAgIGRpYWxvZy5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+PGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0JyBjbGFzcz0ndmFsdWUnLz48YnV0dG9uPk9LPC9idXR0b24+XCI7XG5cdFx0Ly9kaWFsb2cuaW5uZXJIVE1MID0gXCI8c3BhbiBjbGFzcz0nbmFtZSc+PC9zcGFuPjx0ZXh0YXJlYSBhdXRvZm9jdXMgY2xhc3M9J3ZhbHVlJz48L3RleHRhcmVhPjxidXR0b24+T0s8L2J1dHRvbj5cIjtcbiAgICAgICAgdmFyIHRpdGxlID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgdGl0bGUuaW5uZXJUZXh0ID0gcHJvcGVydHk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLnZhbHVlXCIpO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSAhPSAxMyAmJiBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5uZXIoKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyYXBoY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBncmFwaGNhbnZhcy5jYW52YXM7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXR4ID0gLTIwO1xuICAgICAgICB2YXIgb2Zmc2V0eSA9IC0yMDtcbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIG9mZnNldHggLT0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgb2Zmc2V0eSAtPSByZWN0LnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBldmVudC5jbGllbnRYICsgb2Zmc2V0eCArIFwicHhcIjtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSBldmVudC5jbGllbnRZICsgb2Zmc2V0eSArIFwicHhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gY2FudmFzLndpZHRoICogMC41ICsgb2Zmc2V0eCArIFwicHhcIjtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSBjYW52YXMuaGVpZ2h0ICogMC41ICsgb2Zmc2V0eSArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidXR0b24gPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpbm5lcik7XG4gICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXIoKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShpbnB1dC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PSBcIk51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEJvb2xlYW4odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChkaWFsb2cucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvbXB0ID0gZnVuY3Rpb24odGl0bGUsIHZhbHVlLCBjYWxsYmFjaywgZXZlbnQsIG11bHRpbGluZSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBpbnB1dF9odG1sID0gXCJcIjtcbiAgICAgICAgdGl0bGUgPSB0aXRsZSB8fCBcIlwiO1xuXG4gICAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaWFsb2cuY2xhc3NOYW1lID0gXCJncmFwaGRpYWxvZyByb3VuZGVkXCI7XG5cdFx0aWYobXVsdGlsaW5lKVxuXHQgICAgICAgIGRpYWxvZy5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+IDx0ZXh0YXJlYSBhdXRvZm9jdXMgY2xhc3M9J3ZhbHVlJz48L3RleHRhcmVhPjxidXR0b24gY2xhc3M9J3JvdW5kZWQnPk9LPC9idXR0b24+XCI7XG5cdFx0ZWxzZVxuXHQgICAgICAgIGRpYWxvZy5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+IDxpbnB1dCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcgY2xhc3M9J3ZhbHVlJy8+PGJ1dHRvbiBjbGFzcz0ncm91bmRlZCc+T0s8L2J1dHRvbj5cIjtcbiAgICAgICAgZGlhbG9nLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LnByb21wdF9ib3ggPSBudWxsO1xuICAgICAgICAgICAgaWYgKGRpYWxvZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5kcy5zY2FsZSA+IDEpIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgdGhpcy5kcy5zY2FsZSArIFwiKVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoYXQucHJvbXB0X2JveCkge1xuICAgICAgICAgICAgdGhhdC5wcm9tcHRfYm94LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5wcm9tcHRfYm94ID0gZGlhbG9nO1xuXG4gICAgICAgIHZhciBmaXJzdCA9IG51bGw7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcblxuICAgICAgICB2YXIgbmFtZV9lbGVtZW50ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgbmFtZV9lbGVtZW50LmlubmVyVGV4dCA9IHRpdGxlO1xuICAgICAgICB2YXIgdmFsdWVfZWxlbWVudCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLnZhbHVlXCIpO1xuICAgICAgICB2YWx1ZV9lbGVtZW50LnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdmFsdWVfZWxlbWVudDtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAgICAgICAgIC8vRVNDXG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMyAmJiBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGJ1dHRvbiA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHkodHJ1ZSk7XG4gICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdyYXBoY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBncmFwaGNhbnZhcy5jYW52YXM7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXR4ID0gLTIwO1xuICAgICAgICB2YXIgb2Zmc2V0eSA9IC0yMDtcbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIG9mZnNldHggLT0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgb2Zmc2V0eSAtPSByZWN0LnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBldmVudC5jbGllbnRYICsgb2Zmc2V0eCArIFwicHhcIjtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSBldmVudC5jbGllbnRZICsgb2Zmc2V0eSArIFwicHhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gY2FudmFzLndpZHRoICogMC41ICsgb2Zmc2V0eCArIFwicHhcIjtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSBjYW52YXMuaGVpZ2h0ICogMC41ICsgb2Zmc2V0eSArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICB9LCAxMCk7XG5cbiAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCA9IC0xO1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd1NlYXJjaEJveCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGlucHV0X2h0bWwgPSBcIlwiO1xuICAgICAgICB2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IGdyYXBoY2FudmFzLmNhbnZhcztcbiAgICAgICAgdmFyIHJvb3RfZG9jdW1lbnQgPSBjYW52YXMub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICAgICAgICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGlhbG9nLmNsYXNzTmFtZSA9IFwibGl0ZWdyYXBoIGxpdGVzZWFyY2hib3ggZ3JhcGhkaWFsb2cgcm91bmRlZFwiO1xuICAgICAgICBkaWFsb2cuaW5uZXJIVE1MID1cbiAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J25hbWUnPlNlYXJjaDwvc3Bhbj4gPGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0JyBjbGFzcz0ndmFsdWUgcm91bmRlZCcvPjxkaXYgY2xhc3M9J2hlbHBlcic+PC9kaXY+XCI7XG4gICAgICAgIGRpYWxvZy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5zZWFyY2hfYm94ID0gbnVsbDtcbiAgICAgICAgICAgIHJvb3RfZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuXHRcdFx0cm9vdF9kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIjtcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmNhbnZhcy5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMjApOyAvL2ltcG9ydGFudCwgaWYgY2FudmFzIGxvc2VzIGZvY3VzIGtleXMgd29udCBiZSBjYXB0dXJlZFxuICAgICAgICAgICAgaWYgKGRpYWxvZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGltZW91dF9jbG9zZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuZHMuc2NhbGUgPiAxKSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZShcIiArIHRoaXMuZHMuc2NhbGUgKyBcIilcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dF9jbG9zZSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0X2Nsb3NlKTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0X2Nsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB0aW1lb3V0X2Nsb3NlID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGF0LnNlYXJjaF9ib3gpIHtcbiAgICAgICAgICAgIHRoYXQuc2VhcmNoX2JveC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuc2VhcmNoX2JveCA9IGRpYWxvZztcblxuICAgICAgICB2YXIgaGVscGVyID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCIuaGVscGVyXCIpO1xuXG4gICAgICAgIHZhciBmaXJzdCA9IG51bGw7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcblxuICAgICAgICB2YXIgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDM4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVVBcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2VsZWN0aW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAvL0RPV05cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRVNDXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHNlbGVjdGVkLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdChmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlZnJlc2hIZWxwZXIsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cdFx0aWYoIHJvb3RfZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgKVxuXHQgICAgICAgIHJvb3RfZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcblx0XHRlbHNlXG5cdFx0e1xuXHRcdCAgICByb290X2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcblx0XHRcdHJvb3RfZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0fVxuXG4gICAgICAgIC8vY29tcHV0ZSBiZXN0IHBvc2l0aW9uXG4gICAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gKCBldmVudCA/IGV2ZW50LmNsaWVudFggOiAocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAqIDAuNSkgKSAtIDgwO1xuICAgICAgICB2YXIgdG9wID0gKCBldmVudCA/IGV2ZW50LmNsaWVudFkgOiAocmVjdC50b3AgKyByZWN0LmhlaWdodCAqIDAuNSkgKSAtIDIwO1xuICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG5cblx0XHQvL1RvIGF2b2lkIG91dCBvZiBzY3JlZW4gcHJvYmxlbXNcblx0XHRpZihldmVudC5sYXllclkgPiAocmVjdC5oZWlnaHQgLSAyMDApKSBcbiAgICAgICAgICAgIGhlbHBlci5zdHlsZS5tYXhIZWlnaHQgPSAocmVjdC5oZWlnaHQgLSBldmVudC5sYXllclkgLSAyMCkgKyBcInB4XCI7XG5cblx0XHQvKlxuICAgICAgICB2YXIgb2Zmc2V0eCA9IC0yMDtcbiAgICAgICAgdmFyIG9mZnNldHkgPSAtMjA7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICBvZmZzZXR4IC09IHJlY3QubGVmdDtcbiAgICAgICAgICAgIG9mZnNldHkgLT0gcmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gZXZlbnQuY2xpZW50WCArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gZXZlbnQuY2xpZW50WSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGNhbnZhcy53aWR0aCAqIDAuNSArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gY2FudmFzLmhlaWdodCAqIDAuNSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcblx0XHQqL1xuXG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0KG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub25TZWFyY2hCb3hTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vblNlYXJjaEJveFNlbGVjdGlvbihuYW1lLCBldmVudCwgZ3JhcGhjYW52YXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IExpdGVHcmFwaC5zZWFyY2hib3hfZXh0cmFzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGV4dHJhLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRcdGdyYXBoY2FudmFzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBncmFwaGNhbnZhcy5jb252ZXJ0RXZlbnRUb0NhbnZhc09mZnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLmdyYXBoLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYSAmJiBleHRyYS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGF0YS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYS5kYXRhLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRQcm9wZXJ0eSggaSwgZXh0cmEuZGF0YS5wcm9wZXJ0aWVzW2ldICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmRhdGEuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnB1dHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGV4dHJhLmRhdGEuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkT3V0cHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZGF0YS5pbnB1dHNbaV1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5kYXRhLmlucHV0c1tpXVsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5kYXRhLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGV4dHJhLmRhdGEub3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZE91dHB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmRhdGEub3V0cHV0c1tpXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmRhdGEub3V0cHV0c1tpXVsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5kYXRhLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50aXRsZSA9IGV4dHJhLmRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGF0YS5qc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb25maWd1cmUoZXh0cmEuZGF0YS5qc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRcdFx0Z3JhcGhjYW52YXMuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VTZWxlY3Rpb24oZm9yd2FyZCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgPyBoZWxwZXIuY2hpbGROb2Rlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IGhlbHBlci5jaGlsZE5vZGVzW2hlbHBlci5jaGlsZE5vZGVzLmxlbmd0aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdGVkLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWQucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICBzZWxlY3RlZC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiZW5kXCIsIGJlaGF2aW9yOiBcInNtb290aFwifSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWZyZXNoSGVscGVyKCkge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc3RyID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICBmaXJzdCA9IG51bGw7XG4gICAgICAgICAgICBoZWxwZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhhdC5vblNlYXJjaEJveCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhhdC5vblNlYXJjaEJveChoZWxwZXIsIHN0ciwgZ3JhcGhjYW52YXMpO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVzdWx0KGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBmaWx0ZXIgPSBncmFwaGNhbnZhcy5maWx0ZXIgfHwgZ3JhcGhjYW52YXMuZ3JhcGguZmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgLy9leHRyYXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIExpdGVHcmFwaC5zZWFyY2hib3hfZXh0cmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IExpdGVHcmFwaC5zZWFyY2hib3hfZXh0cmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGVzYy50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdFx0dmFyIGN0b3IgPSBMaXRlR3JhcGgucmVnaXN0ZXJlZF9ub2RlX3R5cGVzWyBleHRyYS50eXBlIF07XG5cdFx0XHRcdFx0aWYoIGN0b3IgJiYgY3Rvci5maWx0ZXIgIT0gZmlsdGVyIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBhZGRSZXN1bHQoIGV4dHJhLmRlc2MsIFwic2VhcmNoYm94X2V4dHJhXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBMR3JhcGhDYW52YXMuc2VhcmNoX2xpbWl0ICE9PSAtMSAmJiBjKysgPiBMR3JhcGhDYW52YXMuc2VhcmNoX2xpbWl0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblx0XHRcdFx0dmFyIGZpbHRlcmVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbHRlcikgeyAvL2ZpbHRlciBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlcyApOyAvL3R5cGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGtleXMuZmlsdGVyKCBpbm5lcl90ZXN0X2ZpbHRlciApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBMaXRlR3JhcGgucmVnaXN0ZXJlZF9ub2RlX3R5cGVzKSB7XG5cdFx0XHRcdFx0XHRpZiggaW5uZXJfdGVzdF9maWx0ZXIoaSkgKVxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRhZGRSZXN1bHQoZmlsdGVyZWRbaV0pO1xuXHRcdFx0XHRcdGlmICggTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCAhPT0gLTEgJiYgYysrID4gTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGlubmVyX3Rlc3RfZmlsdGVyKCB0eXBlIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBjdG9yID0gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1sgdHlwZSBdO1xuXHRcdFx0XHRcdGlmKGZpbHRlciAmJiBjdG9yLmZpbHRlciAhPSBmaWx0ZXIgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHJldHVybiB0eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpICE9PSAtMTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRSZXN1bHQodHlwZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlbHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWxwLmlubmVyVGV4dCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgaGVscC5kYXRhc2V0W1widHlwZVwiXSA9IGVzY2FwZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBoZWxwLmNsYXNzTmFtZSA9IFwibGl0ZWdyYXBoIGxpdGUtc2VhcmNoLWl0ZW1cIjtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHAuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWxwLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh1bmVzY2FwZSh0aGlzLmRhdGFzZXRbXCJ0eXBlXCJdKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGVscGVyLmFwcGVuZENoaWxkKGhlbHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zaG93RWRpdFByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiggbm9kZSwgcHJvcGVydHksIG9wdGlvbnMgKSB7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGluZm8gPSBub2RlLmdldFByb3BlcnR5SW5mbyhwcm9wZXJ0eSk7XG5cdFx0dmFyIHR5cGUgPSBpbmZvLnR5cGU7XG5cbiAgICAgICAgdmFyIGlucHV0X2h0bWwgPSBcIlwiO1xuXG4gICAgICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJhcnJheVwiIHx8IHR5cGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaW5wdXRfaHRtbCA9IFwiPGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0JyBjbGFzcz0ndmFsdWUnLz5cIjtcbiAgICAgICAgfSBlbHNlIGlmICggKHR5cGUgPT0gXCJlbnVtXCIgfHwgdHlwZSA9PSBcImNvbWJvXCIpICYmIGluZm8udmFsdWVzKSB7XG4gICAgICAgICAgICBpbnB1dF9odG1sID0gXCI8c2VsZWN0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0JyBjbGFzcz0ndmFsdWUnPlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBpbmZvLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gaTtcblx0XHRcdFx0aWYoIGluZm8udmFsdWVzLmNvbnN0cnVjdG9yID09PSBBcnJheSApXG5cdFx0XHRcdFx0diA9IGluZm8udmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgaW5wdXRfaHRtbCArPVxuICAgICAgICAgICAgICAgICAgICBcIjxvcHRpb24gdmFsdWU9J1wiICtcbiAgICAgICAgICAgICAgICAgICAgdiArXG4gICAgICAgICAgICAgICAgICAgIFwiJyBcIiArXG4gICAgICAgICAgICAgICAgICAgICh2ID09IG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPyBcInNlbGVjdGVkXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiPlwiICtcbiAgICAgICAgICAgICAgICAgICAgaW5mby52YWx1ZXNbaV0gK1xuICAgICAgICAgICAgICAgICAgICBcIjwvb3B0aW9uPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRfaHRtbCArPSBcIjwvc2VsZWN0PlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGlucHV0X2h0bWwgPVxuICAgICAgICAgICAgICAgIFwiPGlucHV0IGF1dG9mb2N1cyB0eXBlPSdjaGVja2JveCcgY2xhc3M9J3ZhbHVlJyBcIiArXG4gICAgICAgICAgICAgICAgKG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPyBcImNoZWNrZWRcIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICBcIi8+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVEaWFsb2coXG4gICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSduYW1lJz5cIiArXG4gICAgICAgICAgICAgICAgKGluZm8ubGFiZWwgPyBpbmZvLmxhYmVsIDogcHJvcGVydHkpICtcbiAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIiArXG4gICAgICAgICAgICAgICAgaW5wdXRfaHRtbCArXG4gICAgICAgICAgICAgICAgXCI8YnV0dG9uPk9LPC9idXR0b24+XCIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCh0eXBlID09IFwiZW51bVwiIHx8IHR5cGUgPT0gXCJjb21ib1wiKSAmJiBpbmZvLnZhbHVlcykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3RcIik7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy92YXIgaW5kZXggPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAvL3NldFZhbHVlKCBlLm9wdGlvbnNbZS5zZWxlY3RlZEluZGV4XS52YWx1ZSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKCEhaW5wdXQuY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cblx0XHRcdFx0dmFyIHYgPSBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldICE9PSB1bmRlZmluZWQgPyBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldIDogXCJcIjtcblx0XHRcdFx0aWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlICE9IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5uZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1dHRvbiA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGlubmVyKTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcigpIHtcbiAgICAgICAgICAgIHNldFZhbHVlKGlucHV0LnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG5cblx0XHRcdGlmKGluZm8gJiYgaW5mby52YWx1ZXMgJiYgaW5mby52YWx1ZXMuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBpbmZvLnZhbHVlc1t2YWx1ZV0gIT0gdW5kZWZpbmVkIClcblx0XHRcdFx0dmFsdWUgPSBpbmZvLnZhbHVlc1t2YWx1ZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiIHx8IHR5cGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobm9kZS5ncmFwaCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm9uUHJvcGVydHlDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vblByb3BlcnR5Q2hhbmdlZChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXHRcdFx0aWYob3B0aW9ucy5vbmNsb3NlKVxuXHRcdFx0XHRvcHRpb25zLm9uY2xvc2UoKTtcbiAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG5cdFx0cmV0dXJuIGRpYWxvZztcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVEaWFsb2cgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaWFsb2cuY2xhc3NOYW1lID0gXCJncmFwaGRpYWxvZ1wiO1xuICAgICAgICBkaWFsb2cuaW5uZXJIVE1MID0gaHRtbDtcblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb2Zmc2V0eCA9IC0yMDtcbiAgICAgICAgdmFyIG9mZnNldHkgPSAtMjA7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICBvZmZzZXR4IC09IHJlY3QubGVmdDtcbiAgICAgICAgICAgIG9mZnNldHkgLT0gcmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgICAgICAgb2Zmc2V0eCArPSBvcHRpb25zLnBvc2l0aW9uWzBdO1xuICAgICAgICAgICAgb2Zmc2V0eSArPSBvcHRpb25zLnBvc2l0aW9uWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXZlbnQpIHtcbiAgICAgICAgICAgIG9mZnNldHggKz0gb3B0aW9ucy5ldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgb2Zmc2V0eSArPSBvcHRpb25zLmV2ZW50LmNsaWVudFk7XG4gICAgICAgIH0gLy9jZW50ZXJlZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldHggKz0gdGhpcy5jYW52YXMud2lkdGggKiAwLjU7XG4gICAgICAgICAgICBvZmZzZXR5ICs9IHRoaXMuY2FudmFzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gb2Zmc2V0eCArIFwicHhcIjtcbiAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IG9mZnNldHkgKyBcInB4XCI7XG5cbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXG4gICAgICAgIGRpYWxvZy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgIH07XG5cblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVQYW5lbCA9IGZ1bmN0aW9uKHRpdGxlLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgcmVmX3dpbmRvdyA9IG9wdGlvbnMud2luZG93IHx8IHdpbmRvdztcblx0XHR2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0cm9vdC5jbGFzc05hbWUgPSBcImxpdGVncmFwaCBkaWFsb2dcIjtcblx0XHRyb290LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nZGlhbG9nLWhlYWRlcic+PHNwYW4gY2xhc3M9J2RpYWxvZy10aXRsZSc+PC9zcGFuPjwvZGl2PjxkaXYgY2xhc3M9J2RpYWxvZy1jb250ZW50Jz48L2Rpdj48ZGl2IGNsYXNzPSdkaWFsb2ctZm9vdGVyJz48L2Rpdj5cIjtcblx0XHRyb290LmhlYWRlciA9IHJvb3QucXVlcnlTZWxlY3RvcihcIi5kaWFsb2ctaGVhZGVyXCIpO1xuXG5cdFx0aWYob3B0aW9ucy53aWR0aClcblx0XHRcdHJvb3Quc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgKG9wdGlvbnMud2lkdGguY29uc3RydWN0b3IgPT09IE51bWJlciA/IFwicHhcIiA6IFwiXCIpO1xuXHRcdGlmKG9wdGlvbnMuaGVpZ2h0KVxuXHRcdFx0cm9vdC5zdHlsZS5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCArIChvcHRpb25zLmhlaWdodC5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyID8gXCJweFwiIDogXCJcIik7XG5cdFx0aWYob3B0aW9ucy5jbG9zYWJsZSlcblx0XHR7XG5cdFx0XHR2YXIgY2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblx0XHRcdGNsb3NlLmlubmVySFRNTCA9IFwiJiMxMDAwNTtcIjtcblx0XHRcdGNsb3NlLmNsYXNzTGlzdC5hZGQoXCJjbG9zZVwiKTtcblx0XHRcdGNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJvb3QuY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdFx0cm9vdC5oZWFkZXIuYXBwZW5kQ2hpbGQoY2xvc2UpO1xuXHRcdH1cblx0XHRyb290LnRpdGxlX2VsZW1lbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLXRpdGxlXCIpO1xuXHRcdHJvb3QudGl0bGVfZWxlbWVudC5pbm5lclRleHQgPSB0aXRsZTtcblx0XHRyb290LmNvbnRlbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLWNvbnRlbnRcIik7XG5cdFx0cm9vdC5mb290ZXIgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLWZvb3RlclwiKTtcblxuXHRcdHJvb3QuY2xvc2UgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYodGhpcy5wYXJlbnROb2RlKVxuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0cm9vdC5jbGVhciA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIjtcblx0XHR9XG5cblx0XHRyb290LmFkZEhUTUwgPSBmdW5jdGlvbihjb2RlLCBjbGFzc25hbWUsIG9uX2Zvb3Rlcilcblx0XHR7XG5cdFx0XHR2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRpZihjbGFzc25hbWUpXG5cdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gY2xhc3NuYW1lO1xuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSBjb2RlO1xuXHRcdFx0aWYob25fZm9vdGVyKVxuXHRcdFx0XHRyb290LmZvb3Rlci5hcHBlbmRDaGlsZChlbGVtKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cm9vdC5jb250ZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG5cdFx0cm9vdC5hZGRCdXR0b24gPSBmdW5jdGlvbiggbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMgKVxuXHRcdHtcblx0XHRcdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblx0XHRcdGVsZW0uaW5uZXJUZXh0ID0gbmFtZTtcblx0XHRcdGVsZW0ub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoXCJidG5cIik7XG5cdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGNhbGxiYWNrKTtcblx0XHRcdHJvb3QuZm9vdGVyLmFwcGVuZENoaWxkKGVsZW0pO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG5cdFx0cm9vdC5hZGRTZXBhcmF0b3IgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBcInNlcGFyYXRvclwiO1xuXHRcdFx0cm9vdC5jb250ZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuXHRcdH1cblxuXHRcdHJvb3QuYWRkV2lkZ2V0ID0gZnVuY3Rpb24oIHR5cGUsIG5hbWUsIHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayApXG5cdFx0e1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHR2YXIgc3RyX3ZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZih0eXBlID09IFwibnVtYmVyXCIpXG5cdFx0XHRcdHN0cl92YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMyk7XG5cblx0XHRcdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdGVsZW0uY2xhc3NOYW1lID0gXCJwcm9wZXJ0eVwiO1xuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSdwcm9wZXJ0eV9uYW1lJz48L3NwYW4+PHNwYW4gY2xhc3M9J3Byb3BlcnR5X3ZhbHVlJz48L3NwYW4+XCI7XG5cdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIucHJvcGVydHlfbmFtZVwiKS5pbm5lclRleHQgPSBvcHRpb25zLmxhYmVsIHx8IG5hbWU7XG5cdFx0XHR2YXIgdmFsdWVfZWxlbWVudCA9IGVsZW0ucXVlcnlTZWxlY3RvcihcIi5wcm9wZXJ0eV92YWx1ZVwiKTtcblx0XHRcdHZhbHVlX2VsZW1lbnQuaW5uZXJUZXh0ID0gc3RyX3ZhbHVlO1xuXHRcdFx0ZWxlbS5kYXRhc2V0W1wicHJvcGVydHlcIl0gPSBuYW1lO1xuXHRcdFx0ZWxlbS5kYXRhc2V0W1widHlwZVwiXSA9IG9wdGlvbnMudHlwZSB8fCB0eXBlO1xuXHRcdFx0ZWxlbS5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdGVsZW0udmFsdWUgPSB2YWx1ZTtcblxuXHRcdFx0Ly9pZiggdHlwZSA9PSBcImNvZGVcIiApXG5cdFx0XHQvL1x0ZWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXsgaW5uZXJfc2hvd0NvZGVQYWQoIG5vZGUsIHRoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdICk7IH0pO1xuXHRcdFx0aWYgKHR5cGUgPT0gXCJib29sZWFuXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW0uY2xhc3NMaXN0LmFkZChcImJvb2xlYW5cIik7XG5cdFx0XHRcdGlmKHZhbHVlKVxuXHRcdFx0XHRcdGVsZW0uY2xhc3NMaXN0LmFkZChcImJvb2wtb25cIik7XG5cdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7IFxuXHRcdFx0XHRcdC8vdmFyIHYgPSBub2RlLnByb3BlcnRpZXNbdGhpcy5kYXRhc2V0W1wicHJvcGVydHlcIl1dOyBcblx0XHRcdFx0XHQvL25vZGUuc2V0UHJvcGVydHkodGhpcy5kYXRhc2V0W1wicHJvcGVydHlcIl0sIXYpOyB0aGlzLmlubmVyVGV4dCA9IHYgPyBcInRydWVcIiA6IFwiZmFsc2VcIjsgXG5cdFx0XHRcdFx0dmFyIHByb3BuYW1lID0gdGhpcy5kYXRhc2V0W1wicHJvcGVydHlcIl07XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9ICF0aGlzLnZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuY2xhc3NMaXN0LnRvZ2dsZShcImJvb2wtb25cIik7XG5cdFx0XHRcdFx0dGhpcy5xdWVyeVNlbGVjdG9yKFwiLnByb3BlcnR5X3ZhbHVlXCIpLmlubmVyVGV4dCA9IHRoaXMudmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcblx0XHRcdFx0XHRpbm5lckNoYW5nZShwcm9wbmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlID09IFwibnVtYmVyXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHZhbHVlX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIsdHJ1ZSk7XG5cdFx0XHRcdHZhbHVlX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZSl7IFxuXHRcdFx0XHRcdGlmKGUuY29kZSA9PSBcIkVudGVyXCIpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dmFsdWVfZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbigpeyBcblx0XHRcdFx0XHR2YXIgdiA9IHRoaXMuaW5uZXJUZXh0O1xuXHRcdFx0XHRcdHZhciBwcm9wbmFtZSA9IHRoaXMucGFyZW50Tm9kZS5kYXRhc2V0W1wicHJvcGVydHlcIl07XG5cdFx0XHRcdFx0dmFyIHByb3B0eXBlID0gdGhpcy5wYXJlbnROb2RlLmRhdGFzZXRbXCJ0eXBlXCJdO1xuXHRcdFx0XHRcdGlmKCBwcm9wdHlwZSA9PSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdFx0diA9IE51bWJlcih2KTtcblx0XHRcdFx0XHRpbm5lckNoYW5nZShwcm9wbmFtZSwgdik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZSA9PSBcImVudW1cIiB8fCB0eXBlID09IFwiY29tYm9cIikge1xuXHRcdFx0XHR2YXIgc3RyX3ZhbHVlID0gTEdyYXBoQ2FudmFzLmdldFByb3BlcnR5UHJpbnRhYmxlVmFsdWUoIHZhbHVlLCBvcHRpb25zLnZhbHVlcyApO1xuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LmlubmVyVGV4dCA9IHN0cl92YWx1ZTtcblxuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCl7IFxuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBvcHRpb25zLnZhbHVlcyB8fCBbXTtcblx0XHRcdFx0XHR2YXIgcHJvcG5hbWUgPSB0aGlzLnBhcmVudE5vZGUuZGF0YXNldFtcInByb3BlcnR5XCJdO1xuXHRcdFx0XHRcdHZhciBlbGVtX3RoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudSh2YWx1ZXMse1xuXHRcdFx0XHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZTogXCJkYXJrXCIsXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0cmVmX3dpbmRvdyk7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBvcHRpb24sIGV2ZW50KSB7XG5cdFx0XHRcdFx0XHQvL25vZGUuc2V0UHJvcGVydHkocHJvcG5hbWUsdik7IFxuXHRcdFx0XHRcdFx0Ly9ncmFwaGNhbnZhcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZWxlbV90aGF0LmlubmVyVGV4dCA9IHY7XG5cdFx0XHRcdFx0XHRpbm5lckNoYW5nZShwcm9wbmFtZSx2KTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHRyb290LmNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG5cblx0XHRcdGZ1bmN0aW9uIGlubmVyQ2hhbmdlKG5hbWUsIHZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNoYW5nZVwiLG5hbWUsdmFsdWUpO1xuXHRcdFx0XHQvL3RoYXQuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0aWYob3B0aW9ucy5jYWxsYmFjaylcblx0XHRcdFx0XHRvcHRpb25zLmNhbGxiYWNrKG5hbWUsdmFsdWUpO1xuXHRcdFx0XHRpZihjYWxsYmFjaylcblx0XHRcdFx0XHRjYWxsYmFjayhuYW1lLHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH07XG5cblx0TEdyYXBoQ2FudmFzLmdldFByb3BlcnR5UHJpbnRhYmxlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdmFsdWVzKVxuXHR7XG5cdFx0aWYoIXZhbHVlcylcblx0XHRcdHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG5cdFx0aWYodmFsdWVzLmNvbnN0cnVjdG9yID09PSBBcnJheSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHZhbHVlKTtcdFx0XHRcblx0XHR9XG5cblx0XHRpZih2YWx1ZXMuY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHR7XG5cdFx0XHR2YXIgZGVzY192YWx1ZSA9IFwiXCI7XG5cdFx0XHRmb3IodmFyIGsgaW4gdmFsdWVzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZih2YWx1ZXNba10gIT0gdmFsdWUpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdGRlc2NfdmFsdWUgPSBrO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBTdHJpbmcodmFsdWUpICsgXCIgKFwiK2Rlc2NfdmFsdWUrXCIpXCI7XG5cdFx0fVxuXHR9XG5cblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zaG93U2hvd05vZGVQYW5lbCA9IGZ1bmN0aW9uKCBub2RlIClcblx0e1xuXHRcdHdpbmRvdy5TRUxFQ1RFRF9OT0RFID0gbm9kZTtcblx0XHR2YXIgcGFuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI25vZGUtcGFuZWxcIik7XG5cdFx0aWYocGFuZWwpXG5cdFx0XHRwYW5lbC5jbG9zZSgpO1xuXHRcdHZhciByZWZfd2luZG93ID0gdGhpcy5nZXRDYW52YXNXaW5kb3coKTtcblx0XHRwYW5lbCA9IHRoaXMuY3JlYXRlUGFuZWwobm9kZS50aXRsZSB8fCBcIlwiLHtjbG9zYWJsZTogdHJ1ZSwgd2luZG93OiByZWZfd2luZG93IH0pO1xuXHRcdHBhbmVsLmlkID0gXCJub2RlLXBhbmVsXCI7XG5cdFx0cGFuZWwubm9kZSA9IG5vZGU7XG5cdFx0cGFuZWwuY2xhc3NMaXN0LmFkZChcInNldHRpbmdzXCIpO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZ3JhcGhjYW52YXMgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gaW5uZXJfcmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0cGFuZWwuY29udGVudC5pbm5lckhUTUwgPSBcIlwiOyAvL2NsZWFyXG5cdFx0XHRwYW5lbC5hZGRIVE1MKFwiPHNwYW4gY2xhc3M9J25vZGVfdHlwZSc+XCIrbm9kZS50eXBlK1wiPC9zcGFuPjxzcGFuIGNsYXNzPSdub2RlX2Rlc2MnPlwiKyhub2RlLmNvbnN0cnVjdG9yLmRlc2MgfHwgXCJcIikrXCI8L3NwYW4+PHNwYW4gY2xhc3M9J3NlcGFyYXRvcic+PC9zcGFuPlwiKTtcblxuXHRcdFx0cGFuZWwuYWRkSFRNTChcIjxoMz5Qcm9wZXJ0aWVzPC9oMz5cIik7XG5cblx0XHRcdGZvcih2YXIgaSBpbiBub2RlLnByb3BlcnRpZXMpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG5vZGUucHJvcGVydGllc1tpXTtcblx0XHRcdFx0dmFyIGluZm8gPSBub2RlLmdldFByb3BlcnR5SW5mbyhpKTtcblx0XHRcdFx0dmFyIHR5cGUgPSBpbmZvLnR5cGUgfHwgXCJzdHJpbmdcIjtcblxuXHRcdFx0XHQvL2luIGNhc2UgdGhlIHVzZXIgd2FudHMgY29udHJvbCBvdmVyIHRoZSBzaWRlIHBhbmVsIHdpZGdldFxuXHRcdFx0XHRpZiggbm9kZS5vbkFkZFByb3BlcnR5VG9QYW5lbCAmJiBub2RlLm9uQWRkUHJvcGVydHlUb1BhbmVsKGkscGFuZWwpIClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRwYW5lbC5hZGRXaWRnZXQoIGluZm8ud2lkZ2V0IHx8IGluZm8udHlwZSwgaSwgdmFsdWUsIGluZm8sIGZ1bmN0aW9uKG5hbWUsdmFsdWUpe1xuXHRcdFx0XHRcdGdyYXBoY2FudmFzLmdyYXBoLmJlZm9yZUNoYW5nZShub2RlKTtcblx0XHRcdFx0XHRub2RlLnNldFByb3BlcnR5KG5hbWUsdmFsdWUpO1xuXHRcdFx0XHRcdGdyYXBoY2FudmFzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG5cdFx0XHRcdFx0Z3JhcGhjYW52YXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHBhbmVsLmFkZFNlcGFyYXRvcigpO1xuXG5cdFx0XHRpZihub2RlLm9uU2hvd0N1c3RvbVBhbmVsSW5mbylcblx0XHRcdFx0bm9kZS5vblNob3dDdXN0b21QYW5lbEluZm8ocGFuZWwpO1xuXG5cdFx0XHQvKlxuXHRcdFx0cGFuZWwuYWRkSFRNTChcIjxoMz5Db25uZWN0aW9uczwvaDM+XCIpO1xuXHRcdFx0dmFyIGNvbm5lY3Rpb25fY29udGFpbmVycyA9IHBhbmVsLmFkZEhUTUwoXCI8ZGl2IGNsYXNzPSdpbnB1dHMgY29ubmVjdGlvbnNfc2lkZSc+PC9kaXY+PGRpdiBjbGFzcz0nb3V0cHV0cyBjb25uZWN0aW9uc19zaWRlJz48L2Rpdj5cIixcImNvbm5lY3Rpb25zXCIpO1xuXHRcdFx0dmFyIGlucHV0cyA9IGNvbm5lY3Rpb25fY29udGFpbmVycy5xdWVyeVNlbGVjdG9yKFwiLmlucHV0c1wiKTtcblx0XHRcdHZhciBvdXRwdXRzID0gY29ubmVjdGlvbl9jb250YWluZXJzLnF1ZXJ5U2VsZWN0b3IoXCIub3V0cHV0c1wiKTtcblx0XHRcdCovXG5cblx0XHRcdHBhbmVsLmFkZEJ1dHRvbihcIkRlbGV0ZVwiLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlmKG5vZGUuYmxvY2tfZGVsZXRlKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0bm9kZS5ncmFwaC5yZW1vdmUobm9kZSk7XG5cdFx0XHRcdHBhbmVsLmNsb3NlKCk7XG5cdFx0XHR9KS5jbGFzc0xpc3QuYWRkKFwiZGVsZXRlXCIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlubmVyX3Nob3dDb2RlUGFkKCBub2RlLCBwcm9wbmFtZSApXG5cdFx0e1xuXHRcdFx0cGFuZWwuc3R5bGUudG9wID0gXCJjYWxjKCA1MCUgLSAyNTBweClcIjtcblx0XHRcdHBhbmVsLnN0eWxlLmxlZnQgPSBcImNhbGMoIDUwJSAtIDQwMHB4KVwiO1xuXHRcdFx0cGFuZWwuc3R5bGUud2lkdGggPSBcIjgwMHB4XCI7XG5cdFx0XHRwYW5lbC5zdHlsZS5oZWlnaHQgPSBcIjUwMHB4XCI7XG5cblx0XHRcdGlmKHdpbmRvdy5Db2RlRmxhc2spIC8vZGlzYWJsZWQgZm9yIG5vd1xuXHRcdFx0e1xuXHRcdFx0XHRwYW5lbC5jb250ZW50LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nY29kZSc+PC9kaXY+XCI7XG5cdFx0XHRcdHZhciBmbGFzayA9IG5ldyBDb2RlRmxhc2soIFwiZGl2LmNvZGVcIiwgeyBsYW5ndWFnZTogJ2pzJyB9KTtcblx0XHRcdFx0Zmxhc2sudXBkYXRlQ29kZShub2RlLnByb3BlcnRpZXNbcHJvcG5hbWVdKTtcblx0XHRcdFx0Zmxhc2sub25VcGRhdGUoIGZ1bmN0aW9uKGNvZGUpIHtcblx0XHRcdFx0XHRub2RlLnNldFByb3BlcnR5KHByb3BuYW1lLCBjb2RlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHBhbmVsLmNvbnRlbnQuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWEgY2xhc3M9J2NvZGUnPjwvdGV4dGFyZWE+XCI7XG5cdFx0XHRcdHZhciB0ZXh0YXJlYSA9IHBhbmVsLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpO1xuXHRcdFx0XHR0ZXh0YXJlYS52YWx1ZSA9IG5vZGUucHJvcGVydGllc1twcm9wbmFtZV07XG5cdFx0XHRcdHRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coZSk7XG5cdFx0XHRcdFx0aWYoZS5jb2RlID09IFwiRW50ZXJcIiAmJiBlLmN0cmxLZXkgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQXNzaWduZWRcIik7XG5cdFx0XHRcdFx0XHRub2RlLnNldFByb3BlcnR5KHByb3BuYW1lLCB0ZXh0YXJlYS52YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCJjYWxjKDEwMCUgLSA0MHB4KVwiO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFzc2lnbiA9IHRoYXQuY3JlYXRlQnV0dG9uKCBcIkFzc2lnblwiLCBudWxsLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRub2RlLnNldFByb3BlcnR5KHByb3BuYW1lLCB0ZXh0YXJlYS52YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHBhbmVsLmNvbnRlbnQuYXBwZW5kQ2hpbGQoYXNzaWduKTtcblx0XHRcdHZhciBidXR0b24gPSB0aGF0LmNyZWF0ZUJ1dHRvbiggXCJDbG9zZVwiLCBudWxsLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRwYW5lbC5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuXHRcdFx0XHRpbm5lcl9yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHRcdGJ1dHRvbi5zdHlsZS5mbG9hdCA9IFwicmlnaHRcIjtcblx0XHRcdHBhbmVsLmNvbnRlbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblx0XHR9XG5cblx0XHRpbm5lcl9yZWZyZXNoKCk7XG5cblx0XHR0aGlzLmNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKCBwYW5lbCApO1xuXHR9XG5cdFxuXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLnNob3dTdWJncmFwaFByb3BlcnRpZXNEaWFsb2cgPSBmdW5jdGlvbihub2RlKVxuXHR7XG5cdFx0Y29uc29sZS5sb2coXCJzaG93aW5nIHN1YmdyYXBoIHByb3BlcnRpZXMgZGlhbG9nXCIpO1xuXG5cdFx0dmFyIG9sZF9wYW5lbCA9IHRoaXMuY2FudmFzLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcIi5zdWJncmFwaF9kaWFsb2dcIik7XG5cdFx0aWYob2xkX3BhbmVsKVxuXHRcdFx0b2xkX3BhbmVsLmNsb3NlKCk7XG5cblx0XHR2YXIgcGFuZWwgPSB0aGlzLmNyZWF0ZVBhbmVsKFwiU3ViZ3JhcGggSW5wdXRzXCIse2Nsb3NhYmxlOnRydWUsIHdpZHRoOiA1MDB9KTtcblx0XHRwYW5lbC5ub2RlID0gbm9kZTtcblx0XHRwYW5lbC5jbGFzc0xpc3QuYWRkKFwic3ViZ3JhcGhfZGlhbG9nXCIpO1xuXG5cdFx0ZnVuY3Rpb24gaW5uZXJfcmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0cGFuZWwuY2xlYXIoKTtcblxuXHRcdFx0Ly9zaG93IGN1cnJlbnRzXG5cdFx0XHRpZihub2RlLmlucHV0cylcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaV07XG5cdFx0XHRcdFx0aWYoaW5wdXQubm90X3N1YmdyYXBoX2lucHV0KVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0dmFyIGh0bWwgPSBcIjxidXR0b24+JiMxMDAwNTs8L2J1dHRvbj4gPHNwYW4gY2xhc3M9J2J1bGxldF9pY29uJz48L3NwYW4+PHNwYW4gY2xhc3M9J25hbWUnPjwvc3Bhbj48c3BhbiBjbGFzcz0ndHlwZSc+PC9zcGFuPlwiO1xuXHRcdFx0XHRcdHZhciBlbGVtID0gcGFuZWwuYWRkSFRNTChodG1sLFwic3ViZ3JhcGhfcHJvcGVydHlcIik7XG5cdFx0XHRcdFx0ZWxlbS5kYXRhc2V0W1wibmFtZVwiXSA9IGlucHV0Lm5hbWU7XG5cdFx0XHRcdFx0ZWxlbS5kYXRhc2V0W1wic2xvdFwiXSA9IGk7XG5cdFx0XHRcdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIikuaW5uZXJUZXh0ID0gaW5wdXQubmFtZTtcblx0XHRcdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIudHlwZVwiKS5pbm5lclRleHQgPSBpbnB1dC50eXBlO1xuXHRcdFx0XHRcdGVsZW0ucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRcdG5vZGUucmVtb3ZlSW5wdXQoIE51bWJlciggdGhpcy5wYXJlbnROb2RlLmRhdGFzZXRbXCJzbG90XCJdICkgKTtcblx0XHRcdFx0XHRcdGlubmVyX3JlZnJlc2goKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vYWRkIGV4dHJhXG5cdFx0dmFyIGh0bWwgPSBcIiArIDxzcGFuIGNsYXNzPSdsYWJlbCc+TmFtZTwvc3Bhbj48aW5wdXQgY2xhc3M9J25hbWUnLz48c3BhbiBjbGFzcz0nbGFiZWwnPlR5cGU8L3NwYW4+PGlucHV0IGNsYXNzPSd0eXBlJz48L2lucHV0PjxidXR0b24+KzwvYnV0dG9uPlwiO1xuXHRcdHZhciBlbGVtID0gcGFuZWwuYWRkSFRNTChodG1sLFwic3ViZ3JhcGhfcHJvcGVydHkgZXh0cmFcIiwgdHJ1ZSk7XG5cdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBlbGVtID0gdGhpcy5wYXJlbnROb2RlO1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKS52YWx1ZTtcblx0XHRcdHZhciB0eXBlID0gZWxlbS5xdWVyeVNlbGVjdG9yKFwiLnR5cGVcIikudmFsdWU7XG5cdFx0XHRpZighbmFtZSB8fCBub2RlLmZpbmRJbnB1dFNsb3QobmFtZSkgIT0gLTEpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdG5vZGUuYWRkSW5wdXQobmFtZSx0eXBlKTtcblx0XHRcdGVsZW0ucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpLnZhbHVlID0gXCJcIjtcblx0XHRcdGVsZW0ucXVlcnlTZWxlY3RvcihcIi50eXBlXCIpLnZhbHVlID0gXCJcIjtcblx0XHRcdGlubmVyX3JlZnJlc2goKTtcblx0XHR9KTtcblxuXHRcdGlubmVyX3JlZnJlc2goKTtcblx0ICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFuZWwpO1xuXHRcdHJldHVybiBwYW5lbDtcblx0fVxuXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2hlY2tQYW5lbHMgPSBmdW5jdGlvbigpXG5cdHtcblx0XHRpZighdGhpcy5jYW52YXMpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHBhbmVscyA9IHRoaXMuY2FudmFzLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChcIi5saXRlZ3JhcGguZGlhbG9nXCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwYW5lbHMubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHBhbmVsID0gcGFuZWxzW2ldO1xuXHRcdFx0aWYoICFwYW5lbC5ub2RlIClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiggIXBhbmVsLm5vZGUuZ3JhcGggfHwgcGFuZWwuZ3JhcGggIT0gdGhpcy5ncmFwaCApXG5cdFx0XHRcdHBhbmVsLmNsb3NlKCk7XG5cdFx0fVxuXHR9XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZUNvbGxhcHNlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcblx0XHRub2RlLmdyYXBoLmJlZm9yZUNoYW5nZShub2RlKTtcbiAgICAgICAgbm9kZS5jb2xsYXBzZSgpO1xuXHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2Uobm9kZSk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUGluID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgbm9kZS5waW4oKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVNb2RlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShcbiAgICAgICAgICAgIFtcIkFsd2F5c1wiLCBcIk9uIEV2ZW50XCIsIFwiT24gVHJpZ2dlclwiLCBcIk5ldmVyXCJdLFxuICAgICAgICAgICAgeyBldmVudDogZSwgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsIHBhcmVudE1lbnU6IG1lbnUsIG5vZGU6IG5vZGUgfVxuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodikge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk9uIEV2ZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW9kZSA9IExpdGVHcmFwaC5PTl9FVkVOVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk9uIFRyaWdnZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlID0gTGl0ZUdyYXBoLk9OX1RSSUdHRVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJOZXZlclwiOlxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGUgPSBMaXRlR3JhcGguTkVWRVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBbHdheXNcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGUgPSBMaXRlR3JhcGguQUxXQVlTO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVDb2xvcnMgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZSwgbWVudSwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IFwibm8gbm9kZSBmb3IgY29sb3JcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBjb250ZW50OlxuICAgICAgICAgICAgICAgIFwiPHNwYW4gc3R5bGU9J2Rpc3BsYXk6IGJsb2NrOyBwYWRkaW5nLWxlZnQ6IDRweDsnPk5vIGNvbG9yPC9zcGFuPlwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gTEdyYXBoQ2FudmFzLm5vZGVfY29sb3JzKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgICAgICAgY29udGVudDpcbiAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBzdHlsZT0nZGlzcGxheTogYmxvY2s7IGNvbG9yOiAjOTk5OyBwYWRkaW5nLWxlZnQ6IDRweDsgYm9yZGVyLWxlZnQ6IDhweCBzb2xpZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLmNvbG9yICtcbiAgICAgICAgICAgICAgICAgICAgXCI7IGJhY2tncm91bmQtY29sb3I6XCIgK1xuICAgICAgICAgICAgICAgICAgICBjb2xvci5iZ2NvbG9yICtcbiAgICAgICAgICAgICAgICAgICAgXCInPlwiICtcbiAgICAgICAgICAgICAgICAgICAgaSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUodmFsdWVzLCB7XG4gICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgcGFyZW50TWVudTogbWVudSxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IHYudmFsdWUgPyBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnNbdi52YWx1ZV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IExpdGVHcmFwaC5MR3JhcGhHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbG9yID0gY29sb3IuZ3JvdXBjb2xvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbG9yID0gY29sb3IuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYmdjb2xvciA9IGNvbG9yLmJnY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5jb2xvcjtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5iZ2NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVTaGFwZXMgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZSwgbWVudSwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IFwibm8gbm9kZSBwYXNzZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUoTGl0ZUdyYXBoLlZBTElEX1NIQVBFUywge1xuICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgIHBhcmVudE1lbnU6IG1lbnUsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodikge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXHRcdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2Uobm9kZSk7XG4gICAgICAgICAgICBub2RlLnNoYXBlID0gdjtcblx0XHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2Uobm9kZSk7XG4gICAgICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZVJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJubyBub2RlIHBhc3NlZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUucmVtb3ZhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblx0XHR2YXIgZ3JhcGggPSBub2RlLmdyYXBoO1xuXHRcdGdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICBncmFwaC5yZW1vdmUobm9kZSk7XG5cdFx0Z3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVUb1N1YmdyYXBoID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcblx0XHR2YXIgZ3JhcGggPSBub2RlLmdyYXBoO1xuXHRcdHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuXHRcdGlmKCFncmFwaGNhbnZhcykgLy8/P1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIG5vZGVzX2xpc3QgPSBPYmplY3QudmFsdWVzKCBncmFwaGNhbnZhcy5zZWxlY3RlZF9ub2RlcyB8fCB7fSApO1xuXHRcdGlmKCAhbm9kZXNfbGlzdC5sZW5ndGggKVxuXHRcdFx0bm9kZXNfbGlzdCA9IFsgbm9kZSBdO1xuXG5cdFx0dmFyIHN1YmdyYXBoX25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcImdyYXBoL3N1YmdyYXBoXCIpO1xuXHRcdHN1YmdyYXBoX25vZGUucG9zID0gbm9kZS5wb3MuY29uY2F0KCk7XG5cdFx0Z3JhcGguYWRkKHN1YmdyYXBoX25vZGUpO1xuXG5cdFx0c3ViZ3JhcGhfbm9kZS5idWlsZEZyb21Ob2Rlcyggbm9kZXNfbGlzdCApO1xuXG5cdFx0Z3JhcGhjYW52YXMuZGVzZWxlY3RBbGxOb2RlcygpO1xuICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZUNsb25lID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY2xvbmFibGUgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3bm9kZSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgaWYgKCFuZXdub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3bm9kZS5wb3MgPSBbbm9kZS5wb3NbMF0gKyA1LCBub2RlLnBvc1sxXSArIDVdO1xuXG5cdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgbm9kZS5ncmFwaC5hZGQobmV3bm9kZSk7XG5cdFx0bm9kZS5ncmFwaC5hZnRlckNoYW5nZSgpO1xuXG4gICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5ub2RlX2NvbG9ycyA9IHtcbiAgICAgICAgcmVkOiB7IGNvbG9yOiBcIiMzMjJcIiwgYmdjb2xvcjogXCIjNTMzXCIsIGdyb3VwY29sb3I6IFwiI0E4OFwiIH0sXG4gICAgICAgIGJyb3duOiB7IGNvbG9yOiBcIiMzMzI5MjJcIiwgYmdjb2xvcjogXCIjNTkzOTMwXCIsIGdyb3VwY29sb3I6IFwiI2IwNjYzNFwiIH0sXG4gICAgICAgIGdyZWVuOiB7IGNvbG9yOiBcIiMyMzJcIiwgYmdjb2xvcjogXCIjMzUzXCIsIGdyb3VwY29sb3I6IFwiIzhBOFwiIH0sXG4gICAgICAgIGJsdWU6IHsgY29sb3I6IFwiIzIyM1wiLCBiZ2NvbG9yOiBcIiMzMzVcIiwgZ3JvdXBjb2xvcjogXCIjODhBXCIgfSxcbiAgICAgICAgcGFsZV9ibHVlOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIjMmEzNjNiXCIsXG4gICAgICAgICAgICBiZ2NvbG9yOiBcIiMzZjUxNTlcIixcbiAgICAgICAgICAgIGdyb3VwY29sb3I6IFwiIzNmNzg5ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGN5YW46IHsgY29sb3I6IFwiIzIzM1wiLCBiZ2NvbG9yOiBcIiMzNTVcIiwgZ3JvdXBjb2xvcjogXCIjOEFBXCIgfSxcbiAgICAgICAgcHVycGxlOiB7IGNvbG9yOiBcIiMzMjNcIiwgYmdjb2xvcjogXCIjNTM1XCIsIGdyb3VwY29sb3I6IFwiI2ExMzA5YlwiIH0sXG4gICAgICAgIHllbGxvdzogeyBjb2xvcjogXCIjNDMyXCIsIGJnY29sb3I6IFwiIzY1M1wiLCBncm91cGNvbG9yOiBcIiNiNThiMmFcIiB9LFxuICAgICAgICBibGFjazogeyBjb2xvcjogXCIjMjIyXCIsIGJnY29sb3I6IFwiIzAwMFwiLCBncm91cGNvbG9yOiBcIiM0NDRcIiB9XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZ2V0Q2FudmFzTWVudU9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5nZXRNZW51T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMuZ2V0TWVudU9wdGlvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIkFkZCBOb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudUFkZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyBjb250ZW50OiBcIkFkZCBHcm91cFwiLCBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uR3JvdXBBZGQgfVxuICAgICAgICAgICAgICAgIC8ve2NvbnRlbnQ6XCJDb2xsYXBzZSBBbGxcIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVDb2xsYXBzZUFsbCB9XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZ3JhcGhfc3RhY2sgJiYgdGhpcy5fZ3JhcGhfc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ2xvc2Ugc3ViZ3JhcGhcIixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMuY2xvc2VTdWJncmFwaC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nZXRFeHRyYU1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhTWVudU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jb25jYXQoZXh0cmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIC8vY2FsbGVkIGJ5IHByb2Nlc3NDb250ZXh0TWVudSB0byBleHRyYWN0IHRoZSBtZW51IGxpc3RcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldE5vZGVNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBudWxsO1xuXG4gICAgICAgIGlmIChub2RlLmdldE1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbm9kZS5nZXRNZW51T3B0aW9ucyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIklucHV0c1wiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxJbnB1dHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJPdXRwdXRzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5zaG93TWVudU5vZGVPcHRpb25hbE91dHB1dHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25TaG93TWVudU5vZGVQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJUaXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uU2hvd1Byb3BlcnR5RWRpdG9yXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiTW9kZVwiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlTW9kZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlJlc2l6ZVwiLCBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLnJlc2l6YWJsZSkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExHcmFwaENhbnZhcy5vblJlc2l6ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJDb2xsYXBzZVwiLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVDb2xsYXBzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyBjb250ZW50OiBcIlBpblwiLCBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVQaW4gfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ29sb3JzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVDb2xvcnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJTaGFwZXNcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Tm9kZVNoYXBlc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLm9uR2V0SW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gbm9kZS5vbkdldElucHV0cygpO1xuICAgICAgICAgICAgaWYgKGlucHV0cyAmJiBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUub25HZXRPdXRwdXRzKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0cyA9IG5vZGUub25HZXRPdXRwdXRzKCk7XG4gICAgICAgICAgICBpZiAob3V0cHV0cyAmJiBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMV0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmdldEV4dHJhTWVudU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBleHRyYSA9IG5vZGUuZ2V0RXh0cmFNZW51T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgIGV4dHJhLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGV4dHJhLmNvbmNhdChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmNsb25hYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIkNsb25lXCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ2xvbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblx0XHRpZigwKSAvL1RPRE9cblx0XHRvcHRpb25zLnB1c2goe1xuXHRcdFx0Y29udGVudDogXCJUbyBTdWJncmFwaFwiLFxuXHRcdFx0Y2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlVG9TdWJncmFwaFxuXHRcdH0pO1xuXG5cdFx0b3B0aW9ucy5wdXNoKG51bGwsIHtcblx0XHRcdGNvbnRlbnQ6IFwiUmVtb3ZlXCIsXG5cdFx0XHRkaXNhYmxlZDogIShub2RlLnJlbW92YWJsZSAhPT0gZmFsc2UgJiYgIW5vZGUuYmxvY2tfZGVsZXRlICksXG5cdFx0XHRjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVSZW1vdmVcblx0XHR9KTtcblxuICAgICAgICBpZiAobm9kZS5ncmFwaCAmJiBub2RlLmdyYXBoLm9uR2V0Tm9kZU1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICBub2RlLmdyYXBoLm9uR2V0Tm9kZU1lbnVPcHRpb25zKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZ2V0R3JvdXBNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIG8gPSBbXG4gICAgICAgICAgICB7IGNvbnRlbnQ6IFwiVGl0bGVcIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vblNob3dQcm9wZXJ0eUVkaXRvciB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ29sb3JcIixcbiAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVDb2xvcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudDogXCJGb250IHNpemVcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJmb250X3NpemVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIk51bWJlclwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25TaG93UHJvcGVydHlFZGl0b3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgeyBjb250ZW50OiBcIlJlbW92ZVwiLCBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVSZW1vdmUgfVxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NDb250ZXh0TWVudSA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcblxuICAgICAgICB2YXIgbWVudV9pbmZvID0gbnVsbDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfb3B0aW9uX2NsaWNrZWQsXG4gICAgICAgICAgICBleHRyYTogbm9kZVxuICAgICAgICB9O1xuXG5cdFx0aWYobm9kZSlcblx0XHRcdG9wdGlvbnMudGl0bGUgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgLy9jaGVjayBpZiBtb3VzZSBpcyBpbiBpbnB1dFxuICAgICAgICB2YXIgc2xvdCA9IG51bGw7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBzbG90ID0gbm9kZS5nZXRTbG90SW5Qb3NpdGlvbihldmVudC5jYW52YXNYLCBldmVudC5jYW52YXNZKTtcbiAgICAgICAgICAgIExHcmFwaENhbnZhcy5hY3RpdmVfbm9kZSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgLy9vbiBzbG90XG4gICAgICAgICAgICBtZW51X2luZm8gPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmdldFNsb3RNZW51T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG1lbnVfaW5mbyA9IG5vZGUuZ2V0U2xvdE1lbnVPcHRpb25zKHNsb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNsb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5vdXRwdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5vdXRwdXQubGlua3MgJiZcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5vdXRwdXQubGlua3MubGVuZ3RoXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbnVfaW5mby5wdXNoKHsgY29udGVudDogXCJEaXNjb25uZWN0IExpbmtzXCIsIHNsb3Q6IHNsb3QgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfc2xvdCA9IHNsb3QuaW5wdXQgfHwgc2xvdC5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgbWVudV9pbmZvLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIF9zbG90LmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkNhbm5vdCByZW1vdmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvbnRlbnQ6IFwiUmVtb3ZlIFNsb3RcIiwgc2xvdDogc2xvdCB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtZW51X2luZm8ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgX3Nsb3QubmFtZUxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkNhbm5vdCByZW5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvbnRlbnQ6IFwiUmVuYW1lIFNsb3RcIiwgc2xvdDogc2xvdCB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPVxuICAgICAgICAgICAgICAgIChzbG90LmlucHV0ID8gc2xvdC5pbnB1dC50eXBlIDogc2xvdC5vdXRwdXQudHlwZSkgfHwgXCIqXCI7XG4gICAgICAgICAgICBpZiAoc2xvdC5pbnB1dCAmJiBzbG90LmlucHV0LnR5cGUgPT0gTGl0ZUdyYXBoLkFDVElPTikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBcIkFjdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsb3Qub3V0cHV0ICYmIHNsb3Qub3V0cHV0LnR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IFwiRXZlbnRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9vbiBub2RlXG4gICAgICAgICAgICAgICAgbWVudV9pbmZvID0gdGhpcy5nZXROb2RlTWVudU9wdGlvbnMobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lbnVfaW5mbyA9IHRoaXMuZ2V0Q2FudmFzTWVudU9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyYXBoLmdldEdyb3VwT25Qb3MoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbnZhc1lcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAvL29uIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIG1lbnVfaW5mby5wdXNoKG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiRWRpdCBHcm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtZW51OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiR3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5nZXRHcm91cE1lbnVPcHRpb25zKGdyb3VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3Nob3cgbWVudVxuICAgICAgICBpZiAoIW1lbnVfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lbnUgPSBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KG1lbnVfaW5mbywgb3B0aW9ucywgcmVmX3dpbmRvdyk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb3B0aW9uX2NsaWNrZWQodiwgb3B0aW9ucywgZSkge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi5jb250ZW50ID09IFwiUmVtb3ZlIFNsb3RcIikge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdi5zbG90O1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlSW5wdXQoaW5mby5zbG90KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZm8ub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlT3V0cHV0KGluZm8uc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodi5jb250ZW50ID09IFwiRGlzY29ubmVjdCBMaW5rc1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB2LnNsb3Q7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdE91dHB1dChpbmZvLnNsb3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5mby5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3RJbnB1dChpbmZvLnNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYuY29udGVudCA9PSBcIlJlbmFtZSBTbG90XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHYuc2xvdDtcbiAgICAgICAgICAgICAgICB2YXIgc2xvdF9pbmZvID0gaW5mby5pbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IG5vZGUuZ2V0SW5wdXRJbmZvKGluZm8uc2xvdClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlLmdldE91dHB1dEluZm8oaW5mby5zbG90KTtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhhdC5jcmVhdGVEaWFsb2coXG4gICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J25hbWUnPk5hbWU8L3NwYW4+PGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0Jy8+PGJ1dHRvbj5PSzwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCAmJiBzbG90X2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBzbG90X2luZm8ubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RfaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90X2luZm8ubGFiZWwgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pZih2LmNhbGxiYWNrKVxuICAgICAgICAgICAgLy9cdHJldHVybiB2LmNhbGxiYWNrLmNhbGwodGhhdCwgbm9kZSwgb3B0aW9ucywgZSwgbWVudSwgdGhhdCwgZXZlbnQgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL0FQSSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy9saWtlIHJlY3QgYnV0IHJvdW5kZWQgY29ybmVyc1xuICAgIGlmICh0eXBlb2Yod2luZG93KSAhPSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgJiYgIXdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnJvdW5kUmVjdCkge1xuICAgICAgICB3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QgPSBmdW5jdGlvbihcblx0XHR4LFxuXHRcdHksXG5cdFx0dyxcblx0XHRoLFxuXHRcdHJhZGl1cyxcblx0XHRyYWRpdXNfbG93XG5cdCkge1xuXHRcdHZhciB0b3BfbGVmdF9yYWRpdXMgPSAwO1xuXHRcdHZhciB0b3BfcmlnaHRfcmFkaXVzID0gMDtcblx0XHR2YXIgYm90dG9tX2xlZnRfcmFkaXVzID0gMDtcblx0XHR2YXIgYm90dG9tX3JpZ2h0X3JhZGl1cyA9IDA7XG5cblx0XHRpZiAoIHJhZGl1cyA9PT0gMCApXG5cdFx0e1xuXHRcdFx0dGhpcy5yZWN0KHgseSx3LGgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHJhZGl1c19sb3cgPT09IHVuZGVmaW5lZClcblx0XHRcdHJhZGl1c19sb3cgPSByYWRpdXM7XG5cblx0XHQvL21ha2UgaXQgY29tcGF0aWJsZSB3aXRoIG9mZmljaWFsIG9uZVxuXHRcdGlmKHJhZGl1cyAhPSBudWxsICYmIHJhZGl1cy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXG5cdFx0e1xuXHRcdFx0aWYocmFkaXVzLmxlbmd0aCA9PSAxKVxuXHRcdFx0XHR0b3BfbGVmdF9yYWRpdXMgPSB0b3BfcmlnaHRfcmFkaXVzID0gYm90dG9tX2xlZnRfcmFkaXVzID0gYm90dG9tX3JpZ2h0X3JhZGl1cyA9IHJhZGl1c1swXTtcblx0XHRcdGVsc2UgaWYocmFkaXVzLmxlbmd0aCA9PSAyKVxuXHRcdFx0e1xuXHRcdFx0XHR0b3BfbGVmdF9yYWRpdXMgPSBib3R0b21fcmlnaHRfcmFkaXVzID0gcmFkaXVzWzBdO1xuXHRcdFx0XHR0b3BfcmlnaHRfcmFkaXVzID0gYm90dG9tX2xlZnRfcmFkaXVzID0gcmFkaXVzWzFdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihyYWRpdXMubGVuZ3RoID09IDQpXG5cdFx0XHR7XG5cdFx0XHRcdHRvcF9sZWZ0X3JhZGl1cyA9IHJhZGl1c1swXTtcblx0XHRcdFx0dG9wX3JpZ2h0X3JhZGl1cyA9IHJhZGl1c1sxXTtcblx0XHRcdFx0Ym90dG9tX2xlZnRfcmFkaXVzID0gcmFkaXVzWzJdO1xuXHRcdFx0XHRib3R0b21fcmlnaHRfcmFkaXVzID0gcmFkaXVzWzNdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgLy9vbGQgdXNpbmcgbnVtYmVyc1xuXHRcdHtcblx0XHRcdHRvcF9sZWZ0X3JhZGl1cyA9IHJhZGl1cyB8fCAwO1xuXHRcdFx0dG9wX3JpZ2h0X3JhZGl1cyA9IHJhZGl1cyB8fCAwO1xuXHRcdFx0Ym90dG9tX2xlZnRfcmFkaXVzID0gcmFkaXVzX2xvdyB8fCAwO1xuXHRcdFx0Ym90dG9tX3JpZ2h0X3JhZGl1cyA9IHJhZGl1c19sb3cgfHwgMDtcblx0XHR9XG5cblx0XHQvL3RvcCByaWdodFxuXHRcdHRoaXMubW92ZVRvKHggKyB0b3BfbGVmdF9yYWRpdXMsIHkpO1xuXHRcdHRoaXMubGluZVRvKHggKyB3IC0gdG9wX3JpZ2h0X3JhZGl1cywgeSk7XG5cdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3LCB5LCB4ICsgdywgeSArIHRvcF9yaWdodF9yYWRpdXMpO1xuXG5cdFx0Ly9ib3R0b20gcmlnaHRcblx0XHR0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSBib3R0b21fcmlnaHRfcmFkaXVzKTtcblx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHR4ICsgdyxcblx0XHRcdHkgKyBoLFxuXHRcdFx0eCArIHcgLSBib3R0b21fcmlnaHRfcmFkaXVzLFxuXHRcdFx0eSArIGhcblx0XHQpO1xuXG5cdFx0Ly9ib3R0b20gbGVmdFxuXHRcdHRoaXMubGluZVRvKHggKyBib3R0b21fcmlnaHRfcmFkaXVzLCB5ICsgaCk7XG5cdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIGJvdHRvbV9sZWZ0X3JhZGl1cyk7XG5cblx0XHQvL3RvcCBsZWZ0XG5cdFx0dGhpcy5saW5lVG8oeCwgeSArIGJvdHRvbV9sZWZ0X3JhZGl1cyk7XG5cdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BfbGVmdF9yYWRpdXMsIHkpO1xuXHR9O1xuXHR9Ly9pZlxuXG4gICAgZnVuY3Rpb24gY29tcGFyZU9iamVjdHMoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGEpIHtcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIExpdGVHcmFwaC5jb21wYXJlT2JqZWN0cyA9IGNvbXBhcmVPYmplY3RzO1xuXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKGJbMF0gLSBhWzBdKSAqIChiWzBdIC0gYVswXSkgKyAoYlsxXSAtIGFbMV0pICogKGJbMV0gLSBhWzFdKVxuICAgICAgICApO1xuICAgIH1cbiAgICBMaXRlR3JhcGguZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuICAgIGZ1bmN0aW9uIGNvbG9yVG9TdHJpbmcoYykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJyZ2JhKFwiICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoY1swXSAqIDI1NSkudG9GaXhlZCgpICtcbiAgICAgICAgICAgIFwiLFwiICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoY1sxXSAqIDI1NSkudG9GaXhlZCgpICtcbiAgICAgICAgICAgIFwiLFwiICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoY1syXSAqIDI1NSkudG9GaXhlZCgpICtcbiAgICAgICAgICAgIFwiLFwiICtcbiAgICAgICAgICAgIChjLmxlbmd0aCA9PSA0ID8gY1szXS50b0ZpeGVkKDIpIDogXCIxLjBcIikgK1xuICAgICAgICAgICAgXCIpXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLmNvbG9yVG9TdHJpbmcgPSBjb2xvclRvU3RyaW5nO1xuXG4gICAgZnVuY3Rpb24gaXNJbnNpZGVSZWN0YW5nbGUoeCwgeSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0IDwgeCAmJiBsZWZ0ICsgd2lkdGggPiB4ICYmIHRvcCA8IHkgJiYgdG9wICsgaGVpZ2h0ID4geSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBMaXRlR3JhcGguaXNJbnNpZGVSZWN0YW5nbGUgPSBpc0luc2lkZVJlY3RhbmdsZTtcblxuICAgIC8vW21pbngsbWlueSxtYXh4LG1heHldXG4gICAgZnVuY3Rpb24gZ3Jvd0JvdW5kaW5nKGJvdW5kaW5nLCB4LCB5KSB7XG4gICAgICAgIGlmICh4IDwgYm91bmRpbmdbMF0pIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWzBdID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ID4gYm91bmRpbmdbMl0pIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWzJdID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgYm91bmRpbmdbMV0pIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWzFdID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID4gYm91bmRpbmdbM10pIHtcbiAgICAgICAgICAgIGJvdW5kaW5nWzNdID0geTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBMaXRlR3JhcGguZ3Jvd0JvdW5kaW5nID0gZ3Jvd0JvdW5kaW5nO1xuXG4gICAgLy9wb2ludCBpbnNpZGUgYm91bmRpbmcgYm94XG4gICAgZnVuY3Rpb24gaXNJbnNpZGVCb3VuZGluZyhwLCBiYikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBwWzBdIDwgYmJbMF1bMF0gfHxcbiAgICAgICAgICAgIHBbMV0gPCBiYlswXVsxXSB8fFxuICAgICAgICAgICAgcFswXSA+IGJiWzFdWzBdIHx8XG4gICAgICAgICAgICBwWzFdID4gYmJbMV1bMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIExpdGVHcmFwaC5pc0luc2lkZUJvdW5kaW5nID0gaXNJbnNpZGVCb3VuZGluZztcblxuICAgIC8vYm91bmRpbmcgb3ZlcmxhcCwgZm9ybWF0OiBbIHN0YXJ0eCwgc3RhcnR5LCB3aWR0aCwgaGVpZ2h0IF1cbiAgICBmdW5jdGlvbiBvdmVybGFwQm91bmRpbmcoYSwgYikge1xuICAgICAgICB2YXIgQV9lbmRfeCA9IGFbMF0gKyBhWzJdO1xuICAgICAgICB2YXIgQV9lbmRfeSA9IGFbMV0gKyBhWzNdO1xuICAgICAgICB2YXIgQl9lbmRfeCA9IGJbMF0gKyBiWzJdO1xuICAgICAgICB2YXIgQl9lbmRfeSA9IGJbMV0gKyBiWzNdO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGFbMF0gPiBCX2VuZF94IHx8XG4gICAgICAgICAgICBhWzFdID4gQl9lbmRfeSB8fFxuICAgICAgICAgICAgQV9lbmRfeCA8IGJbMF0gfHxcbiAgICAgICAgICAgIEFfZW5kX3kgPCBiWzFdXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBMaXRlR3JhcGgub3ZlcmxhcEJvdW5kaW5nID0gb3ZlcmxhcEJvdW5kaW5nO1xuXG4gICAgLy9Db252ZXJ0IGEgaGV4IHZhbHVlIHRvIGl0cyBkZWNpbWFsIHZhbHVlIC0gdGhlIGlucHV0dGVkIGhleCBtdXN0IGJlIGluIHRoZVxuICAgIC8vXHRmb3JtYXQgb2YgYSBoZXggdHJpcGxldCAtIHRoZSBraW5kIHdlIHVzZSBmb3IgSFRNTCBjb2xvdXJzLiBUaGUgZnVuY3Rpb25cbiAgICAvL1x0d2lsbCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aHJlZSB2YWx1ZXMuXG4gICAgZnVuY3Rpb24gaGV4Mm51bShoZXgpIHtcbiAgICAgICAgaWYgKGhleC5jaGFyQXQoMCkgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGhleCA9IGhleC5zbGljZSgxKTtcbiAgICAgICAgfSAvL1JlbW92ZSB0aGUgJyMnIGNoYXIgLSBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICAgIGhleCA9IGhleC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgaGV4X2FscGhhYmV0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgdmFyIGludDEsIGludDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSArPSAyKSB7XG4gICAgICAgICAgICBpbnQxID0gaGV4X2FscGhhYmV0cy5pbmRleE9mKGhleC5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgaW50MiA9IGhleF9hbHBoYWJldHMuaW5kZXhPZihoZXguY2hhckF0KGkgKyAxKSk7XG4gICAgICAgICAgICB2YWx1ZVtrXSA9IGludDEgKiAxNiArIGludDI7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIExpdGVHcmFwaC5oZXgybnVtID0gaGV4Mm51bTtcblxuICAgIC8vR2l2ZSBhIGFycmF5IHdpdGggdGhyZWUgdmFsdWVzIGFzIHRoZSBhcmd1bWVudCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuXG4gICAgLy9cdHRoZSBjb3JyZXNwb25kaW5nIGhleCB0cmlwbGV0LlxuICAgIGZ1bmN0aW9uIG51bTJoZXgodHJpcGxldCkge1xuICAgICAgICB2YXIgaGV4X2FscGhhYmV0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgICAgICB2YXIgaGV4ID0gXCIjXCI7XG4gICAgICAgIHZhciBpbnQxLCBpbnQyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgaW50MSA9IHRyaXBsZXRbaV0gLyAxNjtcbiAgICAgICAgICAgIGludDIgPSB0cmlwbGV0W2ldICUgMTY7XG5cbiAgICAgICAgICAgIGhleCArPSBoZXhfYWxwaGFiZXRzLmNoYXJBdChpbnQxKSArIGhleF9hbHBoYWJldHMuY2hhckF0KGludDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgfVxuXG4gICAgTGl0ZUdyYXBoLm51bTJoZXggPSBudW0yaGV4O1xuXG4gICAgLyogTGl0ZUdyYXBoIEdVSSBlbGVtZW50cyB1c2VkIGZvciBjYW52YXMgZWRpdGluZyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogQ29udGV4dE1lbnUgZnJvbSBMaXRlR1VJXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ29udGV4dE1lbnVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgKGFsbG93cyBvYmplY3QgeyB0aXRsZTogXCJOaWNlIHRleHRcIiwgY2FsbGJhY2s6IGZ1bmN0aW9uIC4uLiB9KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFtvcHRpb25hbF0gU29tZSBvcHRpb25zOlxcXG4gICAgICogLSB0aXRsZTogdGl0bGUgdG8gc2hvdyBvbiB0b3Agb2YgdGhlIG1lbnVcbiAgICAgKiAtIGNhbGxiYWNrOiBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gb3B0aW9uIGlzIGNsaWNrZWQsIGl0IHJlY2VpdmVzIHRoZSBpdGVtIGluZm9ybWF0aW9uXG4gICAgICogLSBpZ25vcmVfaXRlbV9jYWxsYmFja3M6IGlnbm9yZXMgdGhlIGNhbGxiYWNrIGluc2lkZSB0aGUgaXRlbSwgaXQganVzdCBjYWxscyB0aGUgb3B0aW9ucy5jYWxsYmFja1xuICAgICAqIC0gZXZlbnQ6IHlvdSBjYW4gcGFzcyBhIE1vdXNlRXZlbnQsIHRoaXMgd2F5IHRoZSBDb250ZXh0TWVudSBhcHBlYXJzIGluIHRoYXQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb250ZXh0TWVudSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAvL3RvIGxpbmsgYSBtZW51IHdpdGggaXRzIHBhcmVudFxuICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnRNZW51LmNvbnN0cnVjdG9yICE9PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJwYXJlbnRNZW51IG11c3QgYmUgb2YgY2xhc3MgQ29udGV4dE1lbnUsIGlnbm9yaW5nIGl0XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50TWVudSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWVudSA9IG9wdGlvbnMucGFyZW50TWVudTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1lbnUubG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmN1cnJlbnRfc3VibWVudSA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRcdHZhciBldmVudENsYXNzID0gbnVsbDtcblx0XHRpZihvcHRpb25zLmV2ZW50KSAvL3VzZSBzdHJpbmdzIGJlY2F1c2UgY29tcGFyaW5nIGNsYXNzZXMgYmV0d2VlbiB3aW5kb3dzIGRvZXNudCB3b3JrXG5cdFx0XHRldmVudENsYXNzID0gb3B0aW9ucy5ldmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAoIGV2ZW50Q2xhc3MgIT09IFwiTW91c2VFdmVudFwiICYmXG4gICAgICAgICAgICBldmVudENsYXNzICE9PSBcIkN1c3RvbUV2ZW50XCIgJiZcblx0XHRcdGV2ZW50Q2xhc3MgIT09IFwiUG9pbnRlckV2ZW50XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXZlbnQgcGFzc2VkIHRvIENvbnRleHRNZW51IGlzIG5vdCBvZiB0eXBlIE1vdXNlRXZlbnQgb3IgQ3VzdG9tRXZlbnQuIElnbm9yaW5nIGl0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHJvb3QuY2xhc3NOYW1lID0gXCJsaXRlZ3JhcGggbGl0ZWNvbnRleHRtZW51IGxpdGVtZW51YmFyLXBhbmVsXCI7XG4gICAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcm9vdC5jbGFzc05hbWUgKz0gXCIgXCIgKyBvcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByb290LnN0eWxlLm1pbldpZHRoID0gMTAwO1xuICAgICAgICByb290LnN0eWxlLm1pbkhlaWdodCA9IDEwMDtcbiAgICAgICAgcm9vdC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByb290LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgICAgfSwgMTAwKTsgLy9kZWxheSBzbyB0aGUgbW91c2UgdXAgZXZlbnQgaXMgbm90IGNhdWdodCBieSB0aGlzIGVsZW1lbnRcblxuICAgICAgICAvL3RoaXMgcHJldmVudHMgdGhlIGRlZmF1bHQgY29udGV4dCBicm93c2VyIG1lbnUgdG8gb3BlbiBpbiBjYXNlIHRoaXMgbWVudSB3YXMgY3JlYXRlZCB3aGVuIHByZXNzaW5nIHJpZ2h0IGJ1dHRvblxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcIm1vdXNldXBcIixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcImNvbnRleHRtZW51XCIsXG4gICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yaWdodCBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uX21vdXNlX3doZWVsKGUpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBwYXJzZUludChyb290LnN0eWxlLnRvcCk7XG4gICAgICAgICAgICByb290LnN0eWxlLnRvcCA9XG4gICAgICAgICAgICAgICAgKHBvcyArIGUuZGVsdGFZICogb3B0aW9ucy5zY3JvbGxfc3BlZWQpLnRvRml4ZWQoKSArIFwicHhcIjtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnNjcm9sbF9zcGVlZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zY3JvbGxfc3BlZWQgPSAwLjE7XG4gICAgICAgIH1cblxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBvbl9tb3VzZV93aGVlbCwgdHJ1ZSk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgb25fbW91c2Vfd2hlZWwsIHRydWUpO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImxpdGVtZW51LXRpdGxlXCI7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMudGl0bGU7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnRyaWVzXG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdmFsdWVzLmNvbnN0cnVjdG9yID09IEFycmF5ID8gdmFsdWVzW2ldIDogaTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgbmFtZS5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuY29udGVudCA9PT0gdW5kZWZpbmVkID8gU3RyaW5nKG5hbWUpIDogbmFtZS5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtKG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jbG9zZSBvbiBsZWF2ZVxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGF0LmxvY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdC5jbG9zaW5nX3RpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJvb3QuY2xvc2luZ190aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmNsb3NpbmdfdGltZXIgPSBzZXRUaW1lb3V0KHRoYXQuY2xvc2UuYmluZCh0aGF0LCBlKSwgNTAwKTtcbiAgICAgICAgICAgIC8vdGhhdC5jbG9zZShlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAocm9vdC5jbG9zaW5nX3RpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJvb3QuY2xvc2luZ190aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vaW5zZXJ0IGJlZm9yZSBjaGVja2luZyBwb3NpdGlvblxuICAgICAgICB2YXIgcm9vdF9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudCkge1xuICAgICAgICAgICAgcm9vdF9kb2N1bWVudCA9IG9wdGlvbnMuZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvb3RfZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJvb3RfZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuXG5cdFx0aWYoIHJvb3RfZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgKVxuXHQgICAgICAgIHJvb3RfZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdCk7XG5cdFx0ZWxzZVxuXHRcdCAgICByb290X2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdCk7XG5cbiAgICAgICAgLy9jb21wdXRlIGJlc3QgcG9zaXRpb25cbiAgICAgICAgdmFyIGxlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICAgICAgdmFyIHRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50KSB7XG4gICAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5ldmVudC5jbGllbnRYIC0gMTA7XG4gICAgICAgICAgICB0b3AgPSBvcHRpb25zLmV2ZW50LmNsaWVudFkgLSAxMDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgdG9wIC09IDIwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBvcHRpb25zLnBhcmVudE1lbnUucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJvZHlfcmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcm9vdF9yZWN0ID0gcm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdGlmKGJvZHlfcmVjdC5oZWlnaHQgPT0gMClcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcImRvY3VtZW50LmJvZHkgaGVpZ2h0IGlzIDAuIFRoYXQgaXMgZGFuZ2Vyb3VzLCBzZXQgaHRtbCxib2R5IHsgaGVpZ2h0OiAxMDAlOyB9XCIpO1xuXG4gICAgICAgICAgICBpZiAoYm9keV9yZWN0LndpZHRoICYmIGxlZnQgPiBib2R5X3JlY3Qud2lkdGggLSByb290X3JlY3Qud2lkdGggLSAxMCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBib2R5X3JlY3Qud2lkdGggLSByb290X3JlY3Qud2lkdGggLSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib2R5X3JlY3QuaGVpZ2h0ICYmIHRvcCA+IGJvZHlfcmVjdC5oZWlnaHQgLSByb290X3JlY3QuaGVpZ2h0IC0gMTApIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBib2R5X3JlY3QuaGVpZ2h0IC0gcm9vdF9yZWN0LmhlaWdodCAtIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgcm9vdC5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGUpIHtcbiAgICAgICAgICAgIHJvb3Quc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZShcIiArIG9wdGlvbnMuc2NhbGUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJsaXRlbWVudS1lbnRyeSBzdWJtZW51XCI7XG5cbiAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzZXBhcmF0b3JcIik7XG4gICAgICAgICAgICAvL2VsZW1lbnQuaW5uZXJIVE1MID0gXCI8aHIvPlwiXG4gICAgICAgICAgICAvL2NvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB2YWx1ZSAmJiB2YWx1ZS50aXRsZSA/IHZhbHVlLnRpdGxlIDogbmFtZTtcbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdWJtZW51IHx8IHZhbHVlLmhhc19zdWJtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImhhc19zdWJtZW51XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRhdGFzZXRbXCJ2YWx1ZVwiXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbmNsaWNrX2NhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YXNldFtcInZhbHVlXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIHZhbHVlLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW5uZXJfb25jbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b29wZW4pIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgaW5uZXJfb3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9vdmVyKGUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5oYXNfc3VibWVudSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgaXQgaXMgYSBzdWJtZW51LCBhdXRvb3BlbiBsaWtlIHRoZSBpdGVtIHdhcyBjbGlja2VkXG4gICAgICAgICAgICBpbm5lcl9vbmNsaWNrLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL21lbnUgb3B0aW9uIGNsaWNrZWRcbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb25jbGljayhlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGNsb3NlX3BhcmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGF0LmN1cnJlbnRfc3VibWVudSkge1xuICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudF9zdWJtZW51LmNsb3NlKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2dsb2JhbCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG9wdGlvbnMuY2FsbGJhY2suY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm9kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VfcGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZXNcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgIW9wdGlvbnMuaWdub3JlX2l0ZW1fY2FsbGJhY2tzICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmRpc2FibGVkICE9PSB0cnVlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaXRlbSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHZhbHVlLmNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmV4dHJhXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZV9wYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLnN1Ym1lbnUub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJDb250ZXh0TWVudSBzdWJtZW51IG5lZWRzIG9wdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWVudSA9IG5ldyB0aGF0LmNvbnN0cnVjdG9yKHZhbHVlLnN1Ym1lbnUub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHZhbHVlLnN1Ym1lbnUuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1lbnU6IHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVfaXRlbV9jYWxsYmFja3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3VibWVudS5pZ25vcmVfaXRlbV9jYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdmFsdWUuc3VibWVudS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB2YWx1ZS5zdWJtZW51LmV4dHJhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b29wZW46IG9wdGlvbnMuYXV0b29wZW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsb3NlX3BhcmVudCAmJiAhdGhhdC5sb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGUsIGlnbm9yZV9wYXJlbnRfbWVudSkge1xuICAgICAgICBpZiAodGhpcy5yb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50TWVudSAmJiAhaWdub3JlX3BhcmVudF9tZW51KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE1lbnUubG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmN1cnJlbnRfc3VibWVudSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGUgJiZcbiAgICAgICAgICAgICAgICAhQ29udGV4dE1lbnUuaXNDdXJzb3JPdmVyRWxlbWVudChlLCB0aGlzLnBhcmVudE1lbnUucm9vdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIENvbnRleHRNZW51LnRyaWdnZXIodGhpcy5wYXJlbnRNZW51LnJvb3QsIFwibW91c2VsZWF2ZVwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50X3N1Ym1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9zdWJtZW51LmNsb3NlKGUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucm9vdC5jbG9zaW5nX3RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yb290LmNsb3NpbmdfdGltZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vdGhpcyBjb2RlIGlzIHVzZWQgdG8gdHJpZ2dlciBldmVudHMgZWFzaWx5ICh1c2VkIGluIHRoZSBjb250ZXh0IG1lbnUgbW91c2VsZWF2ZVxuICAgIENvbnRleHRNZW51LnRyaWdnZXIgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudF9uYW1lLCBwYXJhbXMsIG9yaWdpbikge1xuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudF9uYW1lLCB0cnVlLCB0cnVlLCBwYXJhbXMpOyAvL2NhbkJ1YmJsZSwgY2FuY2VsYWJsZSwgZGV0YWlsXG4gICAgICAgIGV2dC5zcmNFbGVtZW50ID0gb3JpZ2luO1xuICAgICAgICBpZiAoZWxlbWVudC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Ll9fZXZlbnRzKSB7XG4gICAgICAgICAgICBlbGVtZW50Ll9fZXZlbnRzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICAvL2Vsc2Ugbm90aGluZyBzZWVtcyBiaW5kZWQgaGVyZSBzbyBub3RoaW5nIHRvIGRvXG4gICAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIC8vcmV0dXJucyB0aGUgdG9wIG1vc3QgbWVudVxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5nZXRUb3BNZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50TWVudSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJlbnRNZW51LmdldFRvcE1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmdldEZpcnN0RXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBhcmVudE1lbnUuZ2V0Rmlyc3RFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZXZlbnQ7XG4gICAgfTtcblxuICAgIENvbnRleHRNZW51LmlzQ3Vyc29yT3ZlckVsZW1lbnQgPSBmdW5jdGlvbihldmVudCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgbGVmdCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIHZhciB0b3AgPSBldmVudC5jbGllbnRZO1xuICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRvcCA+IHJlY3QudG9wICYmXG4gICAgICAgICAgICB0b3AgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0ICYmXG4gICAgICAgICAgICBsZWZ0ID4gcmVjdC5sZWZ0ICYmXG4gICAgICAgICAgICBsZWZ0IDwgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLkNvbnRleHRNZW51ID0gQ29udGV4dE1lbnU7XG5cbiAgICBMaXRlR3JhcGguY2xvc2VBbGxDb250ZXh0TWVudXMgPSBmdW5jdGlvbihyZWZfd2luZG93KSB7XG4gICAgICAgIHJlZl93aW5kb3cgPSByZWZfd2luZG93IHx8IHdpbmRvdztcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSByZWZfd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGl0ZWNvbnRleHRtZW51XCIpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbaV0uY2xvc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0uY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0W2ldLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXN1bHRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5leHRlbmRDbGFzcyA9IGZ1bmN0aW9uKHRhcmdldCwgb3JpZ2luKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3JpZ2luKSB7XG4gICAgICAgICAgICAvL2NvcHkgY2xhc3MgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W2ldID0gb3JpZ2luW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yaWdpbi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIC8vY29weSBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvcmlnaW4ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy9vbmx5IGVudW1lcmFibGVcbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbi5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hdm9pZCBvdmVyd3JpdGluZyBleGlzdGluZyBvbmVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY29weSBnZXR0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbi5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhpKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKGkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZVtpXSA9IG9yaWdpbi5wcm90b3R5cGVbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9hbmQgc2V0dGVyc1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblx0Ly91c2VkIGJ5IHNvbWUgd2lkZ2V0cyB0byByZW5kZXIgYSBjdXJ2ZSBlZGl0b3Jcblx0ZnVuY3Rpb24gQ3VydmVFZGl0b3IoIHBvaW50cyApXG5cdHtcblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cztcblx0XHR0aGlzLnNlbGVjdGVkID0gLTE7XG5cdFx0dGhpcy5uZWFyZXN0ID0gLTE7XG5cdFx0dGhpcy5zaXplID0gbnVsbDsgLy9zdG9yZXMgbGFzdCBzaXplIHVzZWRcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLm1hcmdpbiA9IDU7XG5cdH1cblxuXHRDdXJ2ZUVkaXRvci5zYW1wbGVDdXJ2ZSA9IGZ1bmN0aW9uKGYscG9pbnRzKVxuXHR7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybjtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHZhciBwbiA9IHBvaW50c1tpKzFdO1xuXHRcdFx0aWYocG5bMF0gPCBmKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHZhciByID0gKHBuWzBdIC0gcFswXSk7XG5cdFx0XHRpZiggTWF0aC5hYnMocikgPCAwLjAwMDAxIClcblx0XHRcdFx0cmV0dXJuIHBbMV07XG5cdFx0XHR2YXIgbG9jYWxfZiA9IChmIC0gcFswXSkgLyByO1xuXHRcdFx0cmV0dXJuIHBbMV0gKiAoMS4wIC0gbG9jYWxfZikgKyBwblsxXSAqIGxvY2FsX2Y7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiggY3R4LCBzaXplLCBncmFwaGNhbnZhcywgYmFja2dyb3VuZF9jb2xvciwgbGluZV9jb2xvciwgaW5hY3RpdmUgKVxuXHR7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGlmKCFwb2ludHMpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblx0XHR2YXIgdyA9IHNpemVbMF0gLSB0aGlzLm1hcmdpbiAqIDI7XG5cdFx0dmFyIGggPSBzaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXG5cdFx0bGluZV9jb2xvciA9IGxpbmVfY29sb3IgfHwgXCIjNjY2XCI7XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC50cmFuc2xhdGUodGhpcy5tYXJnaW4sdGhpcy5tYXJnaW4pO1xuXG5cdFx0aWYoYmFja2dyb3VuZF9jb2xvcilcblx0XHR7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gXCIjMTExXCI7XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwwLHcsaCk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gXCIjMjIyXCI7XG5cdFx0XHRjdHguZmlsbFJlY3QodyowLjUsMCwxLGgpO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCIjMzMzXCI7XG5cdFx0XHRjdHguc3Ryb2tlUmVjdCgwLDAsdyxoKTtcblx0XHR9XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZV9jb2xvcjtcblx0XHRpZihpbmFjdGl2ZSlcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IDAuNTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdGN0eC5saW5lVG8oIHBbMF0gKiB3LCAoMS4wIC0gcFsxXSkgKiBoICk7XG5cdFx0fVxuXHRcdGN0eC5zdHJva2UoKTtcblx0XHRjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdGlmKCFpbmFjdGl2ZSlcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBwID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3RlZCA9PSBpID8gXCIjRkZGXCIgOiAodGhpcy5uZWFyZXN0ID09IGkgPyBcIiNERERcIiA6IFwiI0FBQVwiKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKCBwWzBdICogdywgKDEuMCAtIHBbMV0pICogaCwgMiwgMCwgTWF0aC5QSSAqIDIgKTtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG5cblx0Ly9sb2NhbHBvcyBpcyBtb3VzZSBpbiBjdXJ2ZSBlZGl0b3Igc3BhY2Vcblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oIGxvY2FscG9zLCBncmFwaGNhbnZhcyApXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybjtcblx0XHRpZiggbG9jYWxwb3NbMV0gPCAwIClcblx0XHRcdHJldHVybjtcblxuXHRcdC8vdGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG5cdFx0dmFyIHcgPSB0aGlzLnNpemVbMF0gLSB0aGlzLm1hcmdpbiAqIDI7XG5cdFx0dmFyIGggPSB0aGlzLnNpemVbMV0gLSB0aGlzLm1hcmdpbiAqIDI7XG5cdFx0dmFyIHggPSBsb2NhbHBvc1swXSAtIHRoaXMubWFyZ2luO1xuXHRcdHZhciB5ID0gbG9jYWxwb3NbMV0gLSB0aGlzLm1hcmdpbjtcblx0XHR2YXIgcG9zID0gW3gseV07XG5cdFx0dmFyIG1heF9kaXN0ID0gMzAgLyBncmFwaGNhbnZhcy5kcy5zY2FsZTtcblx0XHQvL3NlYXJjaCBjbG9zZXIgb25lXG5cdFx0dGhpcy5zZWxlY3RlZCA9IHRoaXMuZ2V0Q2xvc2VyUG9pbnQocG9zLCBtYXhfZGlzdCk7XG5cdFx0Ly9jcmVhdGUgb25lXG5cdFx0aWYodGhpcy5zZWxlY3RlZCA9PSAtMSlcblx0XHR7XG5cdFx0XHR2YXIgcG9pbnQgPSBbeCAvIHcsIDEgLSB5IC8gaF07XG5cdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRwb2ludHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuXHRcdFx0dGhpcy5zZWxlY3RlZCA9IHBvaW50cy5pbmRleE9mKHBvaW50KTtcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRpZih0aGlzLnNlbGVjdGVkICE9IC0xKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRDdXJ2ZUVkaXRvci5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiggbG9jYWxwb3MsIGdyYXBoY2FudmFzIClcblx0e1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRpZighcG9pbnRzKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBzID0gdGhpcy5zZWxlY3RlZDtcblx0XHRpZihzIDwgMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgeCA9IChsb2NhbHBvc1swXSAtIHRoaXMubWFyZ2luKSAvICh0aGlzLnNpemVbMF0gLSB0aGlzLm1hcmdpbiAqIDIgKTtcblx0XHR2YXIgeSA9IChsb2NhbHBvc1sxXSAtIHRoaXMubWFyZ2luKSAvICh0aGlzLnNpemVbMV0gLSB0aGlzLm1hcmdpbiAqIDIgKTtcblx0XHR2YXIgY3VydmVwb3MgPSBbKGxvY2FscG9zWzBdIC0gdGhpcy5tYXJnaW4pLChsb2NhbHBvc1sxXSAtIHRoaXMubWFyZ2luKV07XG5cdFx0dmFyIG1heF9kaXN0ID0gMzAgLyBncmFwaGNhbnZhcy5kcy5zY2FsZTtcblx0XHR0aGlzLl9uZWFyZXN0ID0gdGhpcy5nZXRDbG9zZXJQb2ludChjdXJ2ZXBvcywgbWF4X2Rpc3QpO1xuXHRcdHZhciBwb2ludCA9IHBvaW50c1tzXTtcblx0XHRpZihwb2ludClcblx0XHR7XG5cdFx0XHR2YXIgaXNfZWRnZV9wb2ludCA9IHMgPT0gMCB8fCBzID09IHBvaW50cy5sZW5ndGggLSAxO1xuXHRcdFx0aWYoICFpc19lZGdlX3BvaW50ICYmIChsb2NhbHBvc1swXSA8IC0xMCB8fCBsb2NhbHBvc1swXSA+IHRoaXMuc2l6ZVswXSArIDEwIHx8IGxvY2FscG9zWzFdIDwgLTEwIHx8IGxvY2FscG9zWzFdID4gdGhpcy5zaXplWzFdICsgMTApIClcblx0XHRcdHtcblx0XHRcdFx0cG9pbnRzLnNwbGljZShzLDEpO1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkID0gLTE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCAhaXNfZWRnZV9wb2ludCApIC8vbm90IGVkZ2VzXG5cdFx0XHRcdHBvaW50WzBdID0gTWF0aC5jbGFtcCh4LDAsMSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHBvaW50WzBdID0gcyA9PSAwID8gMCA6IDE7XG5cdFx0XHRwb2ludFsxXSA9IDEuMCAtIE1hdGguY2xhbXAoeSwwLDEpO1xuXHRcdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcblx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBwb2ludHMuaW5kZXhPZihwb2ludCk7XG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRDdXJ2ZUVkaXRvci5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24oIGxvY2FscG9zLCBncmFwaGNhbnZhcyApXG5cdHtcblx0XHR0aGlzLnNlbGVjdGVkID0gLTE7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLmdldENsb3NlclBvaW50ID0gZnVuY3Rpb24ocG9zLCBtYXhfZGlzdClcblx0e1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRpZighcG9pbnRzKVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdG1heF9kaXN0ID0gbWF4X2Rpc3QgfHwgMzA7XG5cdFx0dmFyIHcgPSAodGhpcy5zaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyKTtcblx0XHR2YXIgaCA9ICh0aGlzLnNpemVbMV0gLSB0aGlzLm1hcmdpbiAqIDIpO1xuXHRcdHZhciBudW0gPSBwb2ludHMubGVuZ3RoO1xuXHRcdHZhciBwMiA9IFswLDBdO1xuXHRcdHZhciBtaW5fZGlzdCA9IDEwMDAwMDA7XG5cdFx0dmFyIGNsb3Nlc3QgPSAtMTtcblx0XHR2YXIgbGFzdF92YWxpZCA9IC0xO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBudW07ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHAyWzBdID0gcFswXSAqIHc7XG5cdFx0XHRwMlsxXSA9ICgxLjAgLSBwWzFdKSAqIGg7XG5cdFx0XHRpZihwMlswXSA8IHBvc1swXSlcblx0XHRcdFx0bGFzdF92YWxpZCA9IGk7XG5cdFx0XHR2YXIgZGlzdCA9IHZlYzIuZGlzdGFuY2UocG9zLHAyKTtcblx0XHRcdGlmKGRpc3QgPiBtaW5fZGlzdCB8fCBkaXN0ID4gbWF4X2Rpc3QpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0Y2xvc2VzdCA9IGk7XG5cdFx0XHRtaW5fZGlzdCA9IGRpc3Q7XG5cdFx0fVxuXHRcdHJldHVybiBjbG9zZXN0O1xuXHR9XG5cblx0TGl0ZUdyYXBoLkN1cnZlRWRpdG9yID0gQ3VydmVFZGl0b3I7XG5cbiAgICAvL3VzZWQgdG8gY3JlYXRlIG5vZGVzIGZyb20gd3JhcHBpbmcgZnVuY3Rpb25zXG4gICAgTGl0ZUdyYXBoLmdldFBhcmFtZXRlck5hbWVzID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICByZXR1cm4gKGZ1bmMgKyBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1svXVsvXS4qJC9nbSwgXCJcIikgLy8gc3RyaXAgc2luZ2xlLWxpbmUgY29tbWVudHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csIFwiXCIpIC8vIHN0cmlwIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAucmVwbGFjZSgvWy9dWypdW14vKl0qWypdWy9dL2csIFwiXCIpIC8vIHN0cmlwIG11bHRpLWxpbmUgY29tbWVudHMgIC8qKi9cbiAgICAgICAgICAgIC5zcGxpdChcIil7XCIsIDEpWzBdXG4gICAgICAgICAgICAucmVwbGFjZSgvXlteKF0qWyhdLywgXCJcIikgLy8gZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgLnJlcGxhY2UoLz1bXixdKy9nLCBcIlwiKSAvLyBzdHJpcCBhbnkgRVM2IGRlZmF1bHRzXG4gICAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pOyAvLyBzcGxpdCAmIGZpbHRlciBbXCJcIl1cbiAgICB9O1xuXG4gICAgTWF0aC5jbGFtcCA9IGZ1bmN0aW9uKHYsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiB2ID8gYSA6IGIgPCB2ID8gYiA6IHY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgIXdpbmRvd1tcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiXSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICB9O1xuICAgIH1cbn0pKHRoaXMpO1xuXG5pZiAodHlwZW9mIGV4cG9ydHMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuTGl0ZUdyYXBoID0gdGhpcy5MaXRlR3JhcGg7XG59XG5cbi8vYmFzaWMgbm9kZXNcbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcblxuICAgIC8vQ29uc3RhbnRcbiAgICBmdW5jdGlvbiBUaW1lKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImluIG1zXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImluIHNlY1wiLCBcIm51bWJlclwiKTtcbiAgICB9XG5cbiAgICBUaW1lLnRpdGxlID0gXCJUaW1lXCI7XG4gICAgVGltZS5kZXNjID0gXCJUaW1lXCI7XG5cbiAgICBUaW1lLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuZ3JhcGguZ2xvYmFsdGltZSAqIDEwMDApO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5ncmFwaC5nbG9iYWx0aW1lKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy90aW1lXCIsIFRpbWUpO1xuXG4gICAgLy9TdWJncmFwaDogYSBub2RlIHRoYXQgY29udGFpbnMgYSBncmFwaFxuICAgIGZ1bmN0aW9uIFN1YmdyYXBoKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDgwXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBlbmFibGVkOiB0cnVlIH07XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgLy9jcmVhdGUgaW5uZXIgZ3JhcGhcbiAgICAgICAgdGhpcy5zdWJncmFwaCA9IG5ldyBMaXRlR3JhcGguTEdyYXBoKCk7XG4gICAgICAgIHRoaXMuc3ViZ3JhcGguX3N1YmdyYXBoX25vZGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLl9pc19zdWJncmFwaCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5zdWJncmFwaC5vblRyaWdnZXIgPSB0aGlzLm9uU3ViZ3JhcGhUcmlnZ2VyLmJpbmQodGhpcyk7XG5cblx0XHQvL25vZGVzIGlucHV0IG5vZGUgYWRkZWQgaW5zaWRlXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25JbnB1dEFkZGVkID0gdGhpcy5vblN1YmdyYXBoTmV3SW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbklucHV0UmVuYW1lZCA9IHRoaXMub25TdWJncmFwaFJlbmFtZWRJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uSW5wdXRUeXBlQ2hhbmdlZCA9IHRoaXMub25TdWJncmFwaFR5cGVDaGFuZ2VJbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uSW5wdXRSZW1vdmVkID0gdGhpcy5vblN1YmdyYXBoUmVtb3ZlZElucHV0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbk91dHB1dEFkZGVkID0gdGhpcy5vblN1YmdyYXBoTmV3T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25PdXRwdXRSZW5hbWVkID0gdGhpcy5vblN1YmdyYXBoUmVuYW1lZE91dHB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uT3V0cHV0VHlwZUNoYW5nZWQgPSB0aGlzLm9uU3ViZ3JhcGhUeXBlQ2hhbmdlT3V0cHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25PdXRwdXRSZW1vdmVkID0gdGhpcy5vblN1YmdyYXBoUmVtb3ZlZE91dHB1dC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIFN1YmdyYXBoLnRpdGxlID0gXCJTdWJncmFwaFwiO1xuICAgIFN1YmdyYXBoLmRlc2MgPSBcIkdyYXBoIGluc2lkZSBhIG5vZGVcIjtcbiAgICBTdWJncmFwaC50aXRsZV9jb2xvciA9IFwiIzMzNFwiO1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbW1wiZW5hYmxlZFwiLCBcImJvb2xlYW5cIl1dO1xuICAgIH07XG5cblx0LypcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25EcmF3VGl0bGUgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNTU1XCI7XG4gICAgICAgIHZhciB3ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICB2YXIgeCA9IHRoaXMuc2l6ZVswXSAtIHc7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCAtdywgdywgdyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMzMzNcIjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHggKyB3ICogMC4yLCAtdyAqIDAuNik7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcgKiAwLjgsIC13ICogMC42KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAqIDAuNSwgLXcgKiAwLjMpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH07XG5cdCovXG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25EYmxDbGljayA9IGZ1bmN0aW9uKGUsIHBvcywgZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZ3JhcGhjYW52YXMub3BlblN1YmdyYXBoKHRoYXQuc3ViZ3JhcGgpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfTtcblxuXHQvKlxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIHBvcywgZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMuZmxhZ3MuY29sbGFwc2VkICYmXG4gICAgICAgICAgICBwb3NbMF0gPiB0aGlzLnNpemVbMF0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgJiZcbiAgICAgICAgICAgIHBvc1sxXSA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLm9wZW5TdWJncmFwaCh0aGF0LnN1YmdyYXBoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH07XG5cdCovXG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25BY3Rpb24oYWN0aW9uLCBwYXJhbSk7XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJlbmFibGVkXCIpO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zZW5kIGlucHV0cyB0byBzdWJncmFwaCBnbG9iYWwgaW5wdXRzXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViZ3JhcGguc2V0SW5wdXREYXRhKGlucHV0Lm5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vZXhlY3V0ZVxuICAgICAgICB0aGlzLnN1YmdyYXBoLnJ1blN0ZXAoKTtcblxuICAgICAgICAvL3NlbmQgc3ViZ3JhcGggZ2xvYmFsIG91dHB1dHMgdG8gb3V0cHV0c1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdWJncmFwaC5nZXRPdXRwdXREYXRhKG91dHB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5zZW5kRXZlbnRUb0FsbE5vZGVzID0gZnVuY3Rpb24oZXZlbnRuYW1lLCBwYXJhbSwgbW9kZSkge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmdyYXBoLnNlbmRFdmVudFRvQWxsTm9kZXMoZXZlbnRuYW1lLCBwYXJhbSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdFN1YmdyYXBoLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4LCBncmFwaGNhbnZhcywgY2FudmFzLCBwb3MpXG5cdHtcblx0XHRpZih0aGlzLmZsYWdzLmNvbGxhcHNlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciB5ID0gdGhpcy5zaXplWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41O1xuXG5cdFx0Ly9idXR0b25cblx0XHR2YXIgb3ZlciA9IExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZShwb3NbMF0scG9zWzFdLHRoaXMucG9zWzBdLHRoaXMucG9zWzFdICsgeSx0aGlzLnNpemVbMF0sTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUKTtcblx0XHRjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiIzU1NVwiIDogXCIjMjIyXCI7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGlmICh0aGlzLl9zaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFKVxuXHRcdFx0Y3R4LnJlY3QoMCwgeSwgdGhpcy5zaXplWzBdKzEsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCk7XG5cdFx0ZWxzZVxuXHRcdFx0Y3R4LnJvdW5kUmVjdCggMCwgeSwgdGhpcy5zaXplWzBdKzEsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCwgMCwgOCk7XG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdC8vYnV0dG9uXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0Y3R4LmZvbnQgPSBcIjI0cHggQXJpYWxcIjtcblx0XHRjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiI0RERFwiIDogXCIjOTk5XCI7XG5cdFx0Y3R4LmZpbGxUZXh0KCBcIitcIiwgdGhpcy5zaXplWzBdICogMC41LCB5ICsgMjQgKTtcblx0fVxuXG5cdFN1YmdyYXBoLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGxvY2FscG9zLCBncmFwaGNhbnZhcylcblx0e1xuXHRcdHZhciB5ID0gdGhpcy5zaXplWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41O1xuXHRcdGlmKGxvY2FscG9zWzFdID4geSlcblx0XHR7XG5cdFx0XHRncmFwaGNhbnZhcy5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nKHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdFN1YmdyYXBoLnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHZhciBudW1faW5wdXRzID0gdGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggOiAwO1xuXHRcdHZhciBudW1fb3V0cHV0cyA9IHRoaXMub3V0cHV0cyA/IHRoaXMub3V0cHV0cy5sZW5ndGggOiAwO1xuXHRcdHJldHVybiBbIDIwMCwgTWF0aC5tYXgobnVtX2lucHV0cyxudW1fb3V0cHV0cykgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCBdO1xuXHR9XG5cbiAgICAvLyoqKiogSU5QVVRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhUcmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kT3V0cHV0U2xvdChldmVudCk7XG4gICAgICAgIGlmIChzbG90ICE9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTbG90KHNsb3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoTmV3SW5wdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgLy9hZGQgaW5wdXQgdG8gdGhlIG5vZGVcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQobmFtZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhSZW5hbWVkSW5wdXQgPSBmdW5jdGlvbihvbGRuYW1lLCBuYW1lKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KG9sZG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5nZXRJbnB1dEluZm8oc2xvdCk7XG4gICAgICAgIGluZm8ubmFtZSA9IG5hbWU7XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoVHlwZUNoYW5nZUlucHV0ID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChuYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKHNsb3QpO1xuICAgICAgICBpbmZvLnR5cGUgPSB0eXBlO1xuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFJlbW92ZWRJbnB1dCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRJbnB1dFNsb3QobmFtZSk7XG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVJbnB1dChzbG90KTtcbiAgICB9O1xuXG4gICAgLy8qKioqIE9VVFBVVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaE5ld091dHB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQobmFtZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhSZW5hbWVkT3V0cHV0ID0gZnVuY3Rpb24ob2xkbmFtZSwgbmFtZSkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qob2xkbmFtZSk7XG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLmdldE91dHB1dEluZm8oc2xvdCk7XG4gICAgICAgIGluZm8ubmFtZSA9IG5hbWU7XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoVHlwZUNoYW5nZU91dHB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5nZXRPdXRwdXRJbmZvKHNsb3QpO1xuICAgICAgICBpbmZvLnR5cGUgPSB0eXBlO1xuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFJlbW92ZWRPdXRwdXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlT3V0cHV0KHNsb3QpO1xuICAgIH07XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5nZXRFeHRyYU1lbnVPcHRpb25zID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiT3BlblwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhjYW52YXMub3BlblN1YmdyYXBoKHRoYXQuc3ViZ3JhcGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBzaXplWzFdICs9IDIwO1xuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gTGl0ZUdyYXBoLkxHcmFwaE5vZGUucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgICAgICBkYXRhLnN1YmdyYXBoID0gdGhpcy5zdWJncmFwaC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICAvL25vIG5lZWQgdG8gZGVmaW5lIG5vZGUuY29uZmlndXJlLCB0aGUgZGVmYXVsdCBtZXRob2QgZGV0ZWN0cyBub2RlLnN1YmdyYXBoIGFuZCBwYXNzZXMgdGhlIG9iamVjdCB0byBub2RlLnN1YmdyYXBoLmNvbmZpZ3VyZSgpXG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZSh0aGlzLnR5cGUpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgIGRlbGV0ZSBkYXRhW1wiaWRcIl07XG4gICAgICAgIGRlbGV0ZSBkYXRhW1wiaW5wdXRzXCJdO1xuICAgICAgICBkZWxldGUgZGF0YVtcIm91dHB1dHNcIl07XG4gICAgICAgIG5vZGUuY29uZmlndXJlKGRhdGEpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG5cdFN1YmdyYXBoLnByb3RvdHlwZS5idWlsZEZyb21Ob2RlcyA9IGZ1bmN0aW9uKG5vZGVzKVxuXHR7XG5cdFx0Ly9jbGVhciBhbGw/XG5cdFx0Ly9UT0RPXG5cblx0XHQvL25vZGVzIHRoYXQgY29ubmVjdCBkYXRhIGJldHdlZW4gcGFyZW50IGdyYXBoIGFuZCBzdWJncmFwaFxuXHRcdHZhciBzdWJncmFwaF9pbnB1dHMgPSBbXTtcblx0XHR2YXIgc3ViZ3JhcGhfb3V0cHV0cyA9IFtdO1xuXG5cdFx0Ly9tYXJrIGlubmVyIG5vZGVzXG5cdFx0dmFyIGlkcyA9IHt9O1xuXHRcdHZhciBtaW5feCA9IDA7XG5cdFx0dmFyIG1heF94ID0gMDtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlkc1sgbm9kZS5pZCBdID0gbm9kZTtcblx0XHRcdG1pbl94ID0gTWF0aC5taW4oIG5vZGUucG9zWzBdLCBtaW5feCApO1xuXHRcdFx0bWF4X3ggPSBNYXRoLm1heCggbm9kZS5wb3NbMF0sIG1pbl94ICk7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBsYXN0X2lucHV0X3kgPSAwO1xuXHRcdHZhciBsYXN0X291dHB1dF95ID0gMDtcblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0Ly9jaGVjayBpbnB1dHNcblx0XHRcdGlmKCBub2RlLmlucHV0cyApXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBub2RlLmlucHV0cy5sZW5ndGg7ICsrailcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2pdO1xuXHRcdFx0XHRcdGlmKCAhaW5wdXQgfHwgIWlucHV0LmxpbmsgKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0dmFyIGxpbmsgPSBub2RlLmdyYXBoLmxpbmtzWyBpbnB1dC5saW5rIF07XG5cdFx0XHRcdFx0aWYoIWxpbmspXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiggaWRzWyBsaW5rLm9yaWdpbl9pZCBdIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdC8vdGhpcy5hZGRJbnB1dChpbnB1dC5uYW1lLGxpbmsudHlwZSk7XG5cdFx0XHRcdFx0dGhpcy5zdWJncmFwaC5hZGRJbnB1dChpbnB1dC5uYW1lLGxpbmsudHlwZSk7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHR2YXIgaW5wdXRfbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwiZ3JhcGgvaW5wdXRcIik7XG5cdFx0XHRcdFx0dGhpcy5zdWJncmFwaC5hZGQoIGlucHV0X25vZGUgKTtcblx0XHRcdFx0XHRpbnB1dF9ub2RlLnBvcyA9IFttaW5feCAtIDIwMCwgbGFzdF9pbnB1dF95IF07XG5cdFx0XHRcdFx0bGFzdF9pbnB1dF95ICs9IDEwMDtcblx0XHRcdFx0XHQqL1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vY2hlY2sgb3V0cHV0c1xuXHRcdFx0aWYoIG5vZGUub3V0cHV0cyApXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBub2RlLm91dHB1dHMubGVuZ3RoOyArK2opXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgb3V0cHV0ID0gbm9kZS5vdXRwdXRzW2pdO1xuXHRcdFx0XHRcdGlmKCAhb3V0cHV0IHx8ICFvdXRwdXQubGlua3MgfHwgIW91dHB1dC5saW5rcy5sZW5ndGggKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0dmFyIGlzX2V4dGVybmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0Zm9yKHZhciBrID0gMDsgayA8IG91dHB1dC5saW5rcy5sZW5ndGg7ICsraylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgbGluayA9IG5vZGUuZ3JhcGgubGlua3NbIG91dHB1dC5saW5rc1trXSBdO1xuXHRcdFx0XHRcdFx0aWYoIWxpbmspXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aWYoIGlkc1sgbGluay50YXJnZXRfaWQgXSApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aXNfZXh0ZXJuYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCFpc19leHRlcm5hbClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdC8vdGhpcy5hZGRPdXRwdXQob3V0cHV0Lm5hbWUsb3V0cHV0LnR5cGUpO1xuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0dmFyIG91dHB1dF9ub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJncmFwaC9vdXRwdXRcIik7XG5cdFx0XHRcdFx0dGhpcy5zdWJncmFwaC5hZGQoIG91dHB1dF9ub2RlICk7XG5cdFx0XHRcdFx0b3V0cHV0X25vZGUucG9zID0gW21heF94ICsgNTAsIGxhc3Rfb3V0cHV0X3kgXTtcblx0XHRcdFx0XHRsYXN0X291dHB1dF95ICs9IDEwMDtcblx0XHRcdFx0XHQqL1xuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9kZXRlY3QgaW5wdXRzIGFuZCBvdXRwdXRzXG5cdFx0XHQvL3NwbGl0IGV2ZXJ5IGNvbm5lY3Rpb24gaW4gdHdvIGRhdGFfY29ubmVjdGlvbiBub2Rlc1xuXHRcdFx0Ly9rZWVwIHRyYWNrIG9mIGludGVybmFsIGNvbm5lY3Rpb25zXG5cdFx0XHQvL2Nvbm5lY3QgZXh0ZXJuYWwgY29ubmVjdGlvbnNcblxuXHRcdC8vY2xvbmUgbm9kZXMgaW5zaWRlIHN1YmdyYXBoIGFuZCB0cnkgdG8gcmVjb25uZWN0IHRoZW1cblxuXHRcdC8vY29ubmVjdCBlZGdlIHN1YmdyYXBoIG5vZGVzIHRvIGV4dGFybmFsIGNvbm5lY3Rpb25zIG5vZGVzXG5cdH1cblxuICAgIExpdGVHcmFwaC5TdWJncmFwaCA9IFN1YmdyYXBoO1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGgvc3ViZ3JhcGhcIiwgU3ViZ3JhcGgpO1xuXG4gICAgLy9JbnB1dCBmb3IgYSBzdWJncmFwaFxuICAgIGZ1bmN0aW9uIEdyYXBoSW5wdXQoKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xuXG4gICAgICAgIHRoaXMubmFtZV9pbl9ncmFwaCA9IFwiXCI7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdG5hbWU6IFwiXCIsXG5cdFx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFx0dmFsdWU6IDBcblx0XHR9OyBcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5uYW1lX3dpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFxuICAgICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgICBcIk5hbWVcIixcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5uYW1lLFxuICAgICAgICAgICAgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoYXQuc2V0UHJvcGVydHkoXCJuYW1lXCIsdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudHlwZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcbiAgICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgICAgXCJUeXBlXCIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudHlwZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dGhhdC5zZXRQcm9wZXJ0eShcInR5cGVcIix2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnZhbHVlX3dpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFxuICAgICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICAgIFwiVmFsdWVcIixcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNldFByb3BlcnR5KFwidmFsdWVcIix2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTgwLCA5MF07XG4gICAgfVxuXG4gICAgR3JhcGhJbnB1dC50aXRsZSA9IFwiSW5wdXRcIjtcbiAgICBHcmFwaElucHV0LmRlc2MgPSBcIklucHV0IG9mIHRoZSBncmFwaFwiO1xuXG5cdEdyYXBoSW5wdXQucHJvdG90eXBlLm9uQ29uZmlndXJlID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0dGhpcy51cGRhdGVUeXBlKCk7XG5cdH1cblxuXHQvL2Vuc3VyZXMgdGhlIHR5cGUgaW4gdGhlIG5vZGUgb3V0cHV0IGFuZCB0aGUgdHlwZSBpbiB0aGUgYXNzb2NpYXRlZCBncmFwaCBpbnB1dCBhcmUgdGhlIHNhbWVcblx0R3JhcGhJbnB1dC5wcm90b3R5cGUudXBkYXRlVHlwZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XG5cdFx0dGhpcy50eXBlX3dpZGdldC52YWx1ZSA9IHR5cGU7XG5cblx0XHQvL3VwZGF0ZSBvdXRwdXRcblx0XHRpZih0aGlzLm91dHB1dHNbMF0udHlwZSAhPSB0eXBlKVxuXHRcdHtcblx0ICAgICAgICBpZiAoIUxpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbih0aGlzLm91dHB1dHNbMF0udHlwZSx0eXBlKSlcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0T3V0cHV0KDApO1xuXHRcdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSB0eXBlO1xuXHRcdH1cblxuXHRcdC8vdXBkYXRlIHdpZGdldFxuXHRcdGlmKHR5cGUgPT0gXCJudW1iZXJcIilcblx0XHR7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC50eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gMDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlID09IFwiYm9vbGVhblwiKVxuXHRcdHtcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnR5cGUgPSBcInRvZ2dsZVwiO1xuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudmFsdWUgPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGUgPT0gXCJzdHJpbmdcIilcblx0XHR7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC50eXBlID0gXCJ0ZXh0XCI7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC52YWx1ZSA9IFwiXCI7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC50eXBlID0gbnVsbDtcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gdGhpcy52YWx1ZV93aWRnZXQudmFsdWU7XG5cblx0XHQvL3VwZGF0ZSBncmFwaFxuXHRcdGlmICh0aGlzLmdyYXBoICYmIHRoaXMubmFtZV9pbl9ncmFwaCkge1xuXHRcdFx0dGhpcy5ncmFwaC5jaGFuZ2VJbnB1dFR5cGUodGhpcy5uYW1lX2luX2dyYXBoLCB0eXBlKTtcblx0XHR9XG5cdH1cblxuXHQvL3RoaXMgaXMgZXhlY3V0ZWQgQUZURVIgdGhlIHByb3BlcnR5IGhhcyBjaGFuZ2VkXG5cdEdyYXBoSW5wdXQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2KVxuXHR7XG5cdFx0aWYoIG5hbWUgPT0gXCJuYW1lXCIgKVxuXHRcdHtcblx0XHRcdGlmICh2ID09IFwiXCIgfHwgdiA9PSB0aGlzLm5hbWVfaW5fZ3JhcGggfHwgdiA9PSBcImVuYWJsZWRcIikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmdyYXBoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5uYW1lX2luX2dyYXBoKSB7XG5cdFx0XHRcdFx0Ly9hbHJlYWR5IGFkZGVkXG5cdFx0XHRcdFx0dGhpcy5ncmFwaC5yZW5hbWVJbnB1dCggdGhpcy5uYW1lX2luX2dyYXBoLCB2ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5ncmFwaC5hZGRJbnB1dCggdiwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL3doYXQgaWYgbm90PyFcblx0XHRcdHRoaXMubmFtZV93aWRnZXQudmFsdWUgPSB2O1xuXHRcdFx0dGhpcy5uYW1lX2luX2dyYXBoID0gdjtcblx0XHR9XG5cdFx0ZWxzZSBpZiggbmFtZSA9PSBcInR5cGVcIiApXG5cdFx0e1xuXHRcdFx0dGhpcy51cGRhdGVUeXBlKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYoIG5hbWUgPT0gXCJ2YWx1ZVwiIClcblx0XHR7XG5cdFx0fVxuXHR9XG5cbiAgICBHcmFwaElucHV0LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9O1xuXG4gICAgR3JhcGhJbnB1dC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMudHlwZSA9PSBMaXRlR3JhcGguRVZFTlQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMCwgcGFyYW0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoSW5wdXQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcGVydGllcy5uYW1lO1xuICAgICAgICAvL3JlYWQgZnJvbSBnbG9iYWwgaW5wdXRcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyYXBoLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gZGF0YS52YWx1ZSA6IHRoaXMucHJvcGVydGllcy52YWx1ZSApO1xuICAgIH07XG5cbiAgICBHcmFwaElucHV0LnByb3RvdHlwZS5vblJlbW92ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZV9pbl9ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVJbnB1dCh0aGlzLm5hbWVfaW5fZ3JhcGgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5HcmFwaElucHV0ID0gR3JhcGhJbnB1dDtcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoL2lucHV0XCIsIEdyYXBoSW5wdXQpO1xuXG4gICAgLy9PdXRwdXQgZm9yIGEgc3ViZ3JhcGhcbiAgICBmdW5jdGlvbiBHcmFwaE91dHB1dCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcIlwiKTtcblxuICAgICAgICB0aGlzLm5hbWVfaW5fZ3JhcGggPSBcIlwiO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Lm5hbWVfaW5fZ3JhcGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT0gXCJcIiB8fCB2ID09IHRoYXQubmFtZV9pbl9ncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm5hbWVfaW5fZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ3JhcGgucmVuYW1lT3V0cHV0KHRoYXQubmFtZV9pbl9ncmFwaCwgdik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ncmFwaC5hZGRPdXRwdXQodiwgdGhhdC5wcm9wZXJ0aWVzLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGF0Lm5hbWVfd2lkZ2V0LnZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB0aGF0Lm5hbWVfaW5fZ3JhcGggPSB2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvcGVydGllcywgXCJ0eXBlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5wdXRzWzBdLnR5cGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT0gXCJhY3Rpb25cIiB8fCB2ID09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gTGl0ZUdyYXBoLkFDVElPTjtcbiAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIUxpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbih0aGF0LmlucHV0c1swXS50eXBlLHYpKVxuXHRcdFx0XHRcdHRoYXQuZGlzY29ubmVjdElucHV0KDApO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5wdXRzWzBdLnR5cGUgPSB2O1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm5hbWVfaW5fZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ3JhcGguY2hhbmdlT3V0cHV0VHlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubmFtZV9pbl9ncmFwaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaW5wdXRzWzBdLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhhdC50eXBlX3dpZGdldC52YWx1ZSA9IHYgfHwgXCJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubmFtZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcIk5hbWVcIix0aGlzLnByb3BlcnRpZXMubmFtZSxcIm5hbWVcIik7XG4gICAgICAgIHRoaXMudHlwZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcIlR5cGVcIix0aGlzLnByb3BlcnRpZXMudHlwZSxcInR5cGVcIik7XG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxODAsIDYwXTtcbiAgICB9XG5cbiAgICBHcmFwaE91dHB1dC50aXRsZSA9IFwiT3V0cHV0XCI7XG4gICAgR3JhcGhPdXRwdXQuZGVzYyA9IFwiT3V0cHV0IG9mIHRoZSBncmFwaFwiO1xuXG4gICAgR3JhcGhPdXRwdXQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB0aGlzLmdyYXBoLnNldE91dHB1dERhdGEodGhpcy5wcm9wZXJ0aWVzLm5hbWUsIHRoaXMuX3ZhbHVlKTtcbiAgICB9O1xuXG4gICAgR3JhcGhPdXRwdXQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnR5cGUgPT0gTGl0ZUdyYXBoLkFDVElPTikge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC50cmlnZ2VyKHRoaXMucHJvcGVydGllcy5uYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhPdXRwdXQucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5uYW1lX2luX2dyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLnJlbW92ZU91dHB1dCh0aGlzLm5hbWVfaW5fZ3JhcGgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoT3V0cHV0LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLkdyYXBoT3V0cHV0ID0gR3JhcGhPdXRwdXQ7XG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaC9vdXRwdXRcIiwgR3JhcGhPdXRwdXQpO1xuXG4gICAgLy9Db25zdGFudFxuICAgIGZ1bmN0aW9uIENvbnN0YW50TnVtYmVyKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZhbHVlXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidmFsdWVcIiwgMS4wKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwidmFsdWVcIiwxLFwidmFsdWVcIik7XG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxODAsIDMwXTtcbiAgICB9XG5cbiAgICBDb25zdGFudE51bWJlci50aXRsZSA9IFwiQ29uc3QgTnVtYmVyXCI7XG4gICAgQ29uc3RhbnROdW1iZXIuZGVzYyA9IFwiQ29uc3RhbnQgbnVtYmVyXCI7XG5cbiAgICBDb25zdGFudE51bWJlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBwYXJzZUZsb2F0KHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdKSk7XG4gICAgfTtcblxuICAgIENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcblxuXHRDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2KVxuXHR7XG5cdFx0dGhpcy5zZXRQcm9wZXJ0eShcInZhbHVlXCIsdik7XG5cdH1cblxuICAgIENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vc2hvdyB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICB0aGlzLm91dHB1dHNbMF0ubGFiZWwgPSB0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXS50b0ZpeGVkKDMpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2NvbnN0XCIsIENvbnN0YW50TnVtYmVyKTtcblxuICAgIGZ1bmN0aW9uIENvbnN0YW50Qm9vbGVhbigpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidmFsdWVcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0b2dnbGVcIixcInZhbHVlXCIsdHJ1ZSxcInZhbHVlXCIpO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCAzMF07XG4gICAgfVxuXG4gICAgQ29uc3RhbnRCb29sZWFuLnRpdGxlID0gXCJDb25zdCBCb29sZWFuXCI7XG4gICAgQ29uc3RhbnRCb29sZWFuLmRlc2MgPSBcIkNvbnN0YW50IGJvb2xlYW5cIjtcbiAgICBDb25zdGFudEJvb2xlYW4ucHJvdG90eXBlLmdldFRpdGxlID0gQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLmdldFRpdGxlO1xuXG4gICAgQ29uc3RhbnRCb29sZWFuLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdKTtcbiAgICB9O1xuXG5cdENvbnN0YW50Qm9vbGVhbi5wcm90b3R5cGUuc2V0VmFsdWUgPSBDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWU7XG5cblx0Q29uc3RhbnRCb29sZWFuLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbW1widG9nZ2xlXCIsIExpdGVHcmFwaC5BQ1RJT05dXTtcblx0fTtcblxuXHRDb25zdGFudEJvb2xlYW4ucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKVxuXHR7XG5cdFx0dGhpcy5zZXRWYWx1ZSggIXRoaXMucHJvcGVydGllcy52YWx1ZSApO1xuXHR9XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2Jvb2xlYW5cIiwgQ29uc3RhbnRCb29sZWFuKTtcblxuICAgIGZ1bmN0aW9uIENvbnN0YW50U3RyaW5nKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwidmFsdWVcIixcIlwiLFwidmFsdWVcIik7ICAvL2xpbmsgdG8gcHJvcGVydHkgdmFsdWVcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE4MCwgMzBdO1xuICAgIH1cblxuICAgIENvbnN0YW50U3RyaW5nLnRpdGxlID0gXCJDb25zdCBTdHJpbmdcIjtcbiAgICBDb25zdGFudFN0cmluZy5kZXNjID0gXCJDb25zdGFudCBzdHJpbmdcIjtcblxuICAgIENvbnN0YW50U3RyaW5nLnByb3RvdHlwZS5nZXRUaXRsZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5nZXRUaXRsZTtcblxuICAgIENvbnN0YW50U3RyaW5nLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdKTtcbiAgICB9O1xuXG5cdENvbnN0YW50U3RyaW5nLnByb3RvdHlwZS5zZXRWYWx1ZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5zZXRWYWx1ZTtcblxuXHRDb25zdGFudFN0cmluZy5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGZpbGUpXG5cdHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpXG5cdFx0e1xuXHRcdFx0dGhhdC5zZXRQcm9wZXJ0eShcInZhbHVlXCIsZS50YXJnZXQucmVzdWx0KTtcblx0XHR9XG5cdFx0cmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG5cdH1cblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvc3RyaW5nXCIsIENvbnN0YW50U3RyaW5nKTtcblxuICAgIGZ1bmN0aW9uIENvbnN0YW50T2JqZWN0KCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9ialwiLCBcIm9iamVjdFwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzEyMCwgMzBdO1xuXHRcdHRoaXMuX29iamVjdCA9IHt9O1xuICAgIH1cblxuICAgIENvbnN0YW50T2JqZWN0LnRpdGxlID0gXCJDb25zdCBPYmplY3RcIjtcbiAgICBDb25zdGFudE9iamVjdC5kZXNjID0gXCJDb25zdGFudCBPYmplY3RcIjtcblxuICAgIENvbnN0YW50T2JqZWN0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX29iamVjdCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImJhc2ljL29iamVjdFwiLCBDb25zdGFudE9iamVjdCApO1xuXG4gICAgZnVuY3Rpb24gQ29uc3RhbnRGaWxlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidXJsXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInVybFwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInR5cGVcIiwgXCJ0ZXh0XCIpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwidXJsXCIsXCJcIixcInVybFwiKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgQ29uc3RhbnRGaWxlLnRpdGxlID0gXCJDb25zdCBGaWxlXCI7XG4gICAgQ29uc3RhbnRGaWxlLmRlc2MgPSBcIkZldGNoZXMgYSBmaWxlIGZyb20gYW4gdXJsXCI7XG4gICAgQ29uc3RhbnRGaWxlW1wiQHR5cGVcIl0gPSB7IHR5cGU6IFwiZW51bVwiLCB2YWx1ZXM6IFtcInRleHRcIixcImFycmF5YnVmZmVyXCIsXCJibG9iXCIsXCJqc29uXCJdIH07XG5cbiAgICBDb25zdGFudEZpbGUucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ1cmxcIilcblx0XHR7XG5cdFx0XHRpZiggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PSBcIlwiKVxuXHRcdFx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5mZXRjaEZpbGUodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG4gICAgQ29uc3RhbnRGaWxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdXJsID0gdGhpcy5nZXRJbnB1dERhdGEoMCkgfHwgdGhpcy5wcm9wZXJ0aWVzLnVybDtcblx0XHRpZih1cmwgJiYgKHVybCAhPSB0aGlzLl91cmwgfHwgdGhpcy5fdHlwZSAhPSB0aGlzLnByb3BlcnRpZXMudHlwZSkpXG5cdFx0XHR0aGlzLmZldGNoRmlsZSh1cmwpO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fZGF0YSApO1xuICAgIH07XG5cblx0Q29uc3RhbnRGaWxlLnByb3RvdHlwZS5zZXRWYWx1ZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5zZXRWYWx1ZTtcblxuICAgIENvbnN0YW50RmlsZS5wcm90b3R5cGUuZmV0Y2hGaWxlID0gZnVuY3Rpb24odXJsKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdGlmKCF1cmwgfHwgdXJsLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpXG5cdFx0e1xuXHRcdFx0dGhhdC5fZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl91cmwgPSB1cmw7XG5cdFx0dGhpcy5fdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xuICAgICAgICBpZiAodXJsLnN1YnN0cigwLCA0KSA9PSBcImh0dHBcIiAmJiBMaXRlR3JhcGgucHJveHkpIHtcbiAgICAgICAgICAgIHVybCA9IExpdGVHcmFwaC5wcm94eSArIHVybC5zdWJzdHIodXJsLmluZGV4T2YoXCI6XCIpICsgMyk7XG4gICAgICAgIH1cblx0XHRmZXRjaCh1cmwpXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdGlmKCFyZXNwb25zZS5vaylcblx0XHRcdFx0IHRocm93IG5ldyBFcnJvcihcIkZpbGUgbm90IGZvdW5kXCIpO1xuXG5cdFx0XHRpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXHRcdFx0ZWxzZSBpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcInRleHRcIilcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblx0XHRcdGVsc2UgaWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJqc29uXCIpXG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdFx0XHRlbHNlIGlmKHRoYXQucHJvcGVydGllcy50eXBlID09IFwiYmxvYlwiKVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuXHRcdH0pXG5cdFx0LnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0dGhhdC5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjQUVBXCI7XG5cdFx0fSlcblx0XHQuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdHRoYXQuX2RhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwicmVkXCI7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiZXJyb3IgZmV0Y2hpbmcgZmlsZTpcIix1cmwpO1xuXHRcdH0pO1xuICAgIH07XG5cblx0Q29uc3RhbnRGaWxlLnByb3RvdHlwZS5vbkRyb3BGaWxlID0gZnVuY3Rpb24oZmlsZSlcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR0aGlzLl91cmwgPSBmaWxlLm5hbWU7XG5cdFx0dGhpcy5fdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xuXHRcdHRoaXMucHJvcGVydGllcy51cmwgPSBmaWxlLm5hbWU7XG5cdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpXG5cdFx0e1xuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0FFQVwiO1xuXHRcdFx0dmFyIHYgPSBlLnRhcmdldC5yZXN1bHQ7XG5cdFx0XHRpZiggdGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJqc29uXCIgKVxuXHRcdFx0XHR2ID0gSlNPTi5wYXJzZSh2KTtcblx0XHRcdHRoYXQuX2RhdGEgPSB2O1xuXHRcdH1cblx0XHRpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG5cdFx0ZWxzZSBpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcInRleHRcIiB8fCB0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcImpzb25cIilcblx0XHRcdHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuXHRcdGVsc2UgaWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJibG9iXCIpXG5cdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhmaWxlKTtcblx0fVxuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9maWxlXCIsIENvbnN0YW50RmlsZSk7XG5cblx0Ly90byBzdG9yZSBqc29uIG9iamVjdHNcbiAgICBmdW5jdGlvbiBDb25zdGFudERhdGEoKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidmFsdWVcIiwgXCJcIik7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJqc29uXCIsXCJcIixcInZhbHVlXCIpO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCAzMF07XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICBDb25zdGFudERhdGEudGl0bGUgPSBcIkNvbnN0IERhdGFcIjtcbiAgICBDb25zdGFudERhdGEuZGVzYyA9IFwiQ29uc3RhbnQgRGF0YVwiO1xuXG4gICAgQ29uc3RhbnREYXRhLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FFQVwiO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnN0YW50RGF0YS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92YWx1ZSk7XG4gICAgfTtcblxuXHRDb25zdGFudERhdGEucHJvdG90eXBlLnNldFZhbHVlID0gQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLnNldFZhbHVlO1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9kYXRhXCIsIENvbnN0YW50RGF0YSk7XG5cblx0Ly90byBzdG9yZSBqc29uIG9iamVjdHNcbiAgICBmdW5jdGlvbiBDb25zdGFudEFycmF5KCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImFycmF5XCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImxlbmd0aFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiW11cIik7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJhcnJheVwiLHRoaXMucHJvcGVydGllcy52YWx1ZSxcInZhbHVlXCIpO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCA1MF07XG4gICAgfVxuXG4gICAgQ29uc3RhbnRBcnJheS50aXRsZSA9IFwiQ29uc3QgQXJyYXlcIjtcbiAgICBDb25zdGFudEFycmF5LmRlc2MgPSBcIkNvbnN0YW50IEFycmF5XCI7XG5cbiAgICBDb25zdGFudEFycmF5LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG5cdFx0XHRpZih2YWx1ZVswXSAhPSBcIltcIilcblx0ICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBKU09OLnBhcnNlKFwiW1wiICsgdmFsdWUgKyBcIl1cIik7XG5cdFx0XHRlbHNlXG5cdCAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUVBXCI7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc3RhbnRBcnJheS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYodiAmJiB2Lmxlbmd0aCkgLy9jbG9uZVxuXHRcdHtcblx0XHRcdGlmKCF0aGlzLl92YWx1ZSlcblx0XHRcdFx0dGhpcy5fdmFsdWUgPSBuZXcgQXJyYXkoKTtcblx0XHRcdHRoaXMuX3ZhbHVlLmxlbmd0aCA9IHYubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyArK2kpXG5cdFx0XHRcdHRoaXMuX3ZhbHVlW2ldID0gdltpXTtcblx0XHR9XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZhbHVlICk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3ZhbHVlID8gKCB0aGlzLl92YWx1ZS5sZW5ndGggfHwgMCkgOiAwICk7XG4gICAgfTtcblxuXHRDb25zdGFudEFycmF5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5zZXRWYWx1ZTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvYXJyYXlcIiwgQ29uc3RhbnRBcnJheSk7XG5cblx0ZnVuY3Rpb24gU2V0QXJyYXkoKVxuXHR7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhcnJcIiwgXCJhcnJheVwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImFyclwiLCBcImFycmF5XCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgaW5kZXg6IDAgfTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwiaVwiLHRoaXMucHJvcGVydGllcy5pbmRleCxcImluZGV4XCIpO1xuXHR9XG5cbiAgICBTZXRBcnJheS50aXRsZSA9IFwiU2V0IEFycmF5XCI7XG4gICAgU2V0QXJyYXkuZGVzYyA9IFwiU2V0cyBpbmRleCBvZiBhcnJheVwiO1xuXG4gICAgU2V0QXJyYXkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYoIWFycilcblx0XHRcdHJldHVybjtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZih2ID09PSB1bmRlZmluZWQgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmKHRoaXMucHJvcGVydGllcy5pbmRleClcblx0XHRcdGFyclsgTWF0aC5mbG9vcih0aGlzLnByb3BlcnRpZXMuaW5kZXgpIF0gPSB2O1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLGFycik7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvc2V0X2FycmF5XCIsIFNldEFycmF5ICk7XG5cbiAgICBmdW5jdGlvbiBBcnJheUVsZW1lbnQoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhcnJheVwiLCBcImFycmF5LHRhYmxlLHN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluZGV4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZhbHVlXCIsIFwiXCIpO1xuXHRcdHRoaXMuYWRkUHJvcGVydHkoXCJpbmRleFwiLDApO1xuICAgIH1cblxuICAgIEFycmF5RWxlbWVudC50aXRsZSA9IFwiQXJyYXlbaV1cIjtcbiAgICBBcnJheUVsZW1lbnQuZGVzYyA9IFwiUmV0dXJucyBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXlcIjtcblxuICAgIEFycmF5RWxlbWVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZihpbmRleCA9PSBudWxsKVxuXHRcdFx0aW5kZXggPSB0aGlzLnByb3BlcnRpZXMuaW5kZXg7XG5cdFx0aWYoYXJyYXkgPT0gbnVsbCB8fCBpbmRleCA9PSBudWxsIClcblx0XHRcdHJldHVybjtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGFycmF5W01hdGguZmxvb3IoTnVtYmVyKGluZGV4KSldICk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvYXJyYXlbXVwiLCBBcnJheUVsZW1lbnQpO1xuXG4gICAgZnVuY3Rpb24gVGFibGVFbGVtZW50KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidGFibGVcIiwgXCJ0YWJsZVwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInJvd1wiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNvbFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIlwiKTtcblx0XHR0aGlzLmFkZFByb3BlcnR5KFwicm93XCIsMCk7XG5cdFx0dGhpcy5hZGRQcm9wZXJ0eShcImNvbHVtblwiLDApO1xuICAgIH1cblxuICAgIFRhYmxlRWxlbWVudC50aXRsZSA9IFwiVGFibGVbcm93XVtjb2xdXCI7XG4gICAgVGFibGVFbGVtZW50LmRlc2MgPSBcIlJldHVybnMgYW4gZWxlbWVudCBmcm9tIGEgdGFibGVcIjtcblxuICAgIFRhYmxlRWxlbWVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHRpZihyb3cgPT0gbnVsbClcblx0XHRcdHJvdyA9IHRoaXMucHJvcGVydGllcy5yb3c7XG5cdFx0aWYoY29sID09IG51bGwpXG5cdFx0XHRjb2wgPSB0aGlzLnByb3BlcnRpZXMuY29sdW1uO1xuXHRcdGlmKHRhYmxlID09IG51bGwgfHwgcm93ID09IG51bGwgfHwgY29sID09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHJvdyA9IHRhYmxlW01hdGguZmxvb3IoTnVtYmVyKHJvdykpXTtcblx0XHRpZihyb3cpXG5cdCAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHJvd1tNYXRoLmZsb29yKE51bWJlcihjb2wpKV0gKTtcblx0XHRlbHNlXG5cdCAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIG51bGwgKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy90YWJsZVtdW11cIiwgVGFibGVFbGVtZW50KTtcblxuICAgIGZ1bmN0aW9uIE9iamVjdFByb3BlcnR5KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwib2JqXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwicHJvcC5cIixcIlwiLHRoaXMuc2V0VmFsdWUuYmluZCh0aGlzKSApO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCAzMF07XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICBPYmplY3RQcm9wZXJ0eS50aXRsZSA9IFwiT2JqZWN0IHByb3BlcnR5XCI7XG4gICAgT2JqZWN0UHJvcGVydHkuZGVzYyA9IFwiT3V0cHV0cyB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0XCI7XG5cbiAgICBPYmplY3RQcm9wZXJ0eS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHY7XG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdjtcbiAgICB9O1xuXG4gICAgT2JqZWN0UHJvcGVydHkucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaW4uXCIgKyB0aGlzLnByb3BlcnRpZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcblxuICAgIE9iamVjdFByb3BlcnR5LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgfTtcblxuICAgIE9iamVjdFByb3BlcnR5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGFbdGhpcy5wcm9wZXJ0aWVzLnZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9vYmplY3RfcHJvcGVydHlcIiwgT2JqZWN0UHJvcGVydHkpO1xuXG4gICAgZnVuY3Rpb24gT2JqZWN0S2V5cygpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm9ialwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJrZXlzXCIsIFwiYXJyYXlcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDMwXTtcbiAgICB9XG5cbiAgICBPYmplY3RLZXlzLnRpdGxlID0gXCJPYmplY3Qga2V5c1wiO1xuICAgIE9iamVjdEtleXMuZGVzYyA9IFwiT3V0cHV0cyBhbiBhcnJheSB3aXRoIHRoZSBrZXlzIG9mIGFuIG9iamVjdFwiO1xuXG4gICAgT2JqZWN0S2V5cy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBPYmplY3Qua2V5cyhkYXRhKSApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvb2JqZWN0X2tleXNcIiwgT2JqZWN0S2V5cyk7XG5cblxuXHRmdW5jdGlvbiBTZXRPYmplY3QoKVxuXHR7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvYmpcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2YWx1ZVwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvYmpcIiwgXCJcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBwcm9wZXJ0eTogXCJcIiB9O1xuICAgICAgICB0aGlzLm5hbWVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJwcm9wLlwiLHRoaXMucHJvcGVydGllcy5wcm9wZXJ0eSxcInByb3BlcnR5XCIpO1xuXHR9XG5cbiAgICBTZXRPYmplY3QudGl0bGUgPSBcIlNldCBPYmplY3RcIjtcbiAgICBTZXRPYmplY3QuZGVzYyA9IFwiQWRkcyBwcm9wZXJ0aWVzcnR5IHRvIG9iamVjdFwiO1xuXG4gICAgU2V0T2JqZWN0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmKCFvYmopXG5cdFx0XHRyZXR1cm47XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYodiA9PT0gdW5kZWZpbmVkIClcblx0XHRcdHJldHVybjtcblx0XHRpZih0aGlzLnByb3BlcnRpZXMucHJvcGVydHkpXG5cdFx0XHRvYmpbIHRoaXMucHJvcGVydGllcy5wcm9wZXJ0eSBdID0gdjtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxvYmopO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3NldF9vYmplY3RcIiwgU2V0T2JqZWN0ICk7XG5cblxuICAgIGZ1bmN0aW9uIE1lcmdlT2JqZWN0cygpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIlwiKTtcblx0XHR0aGlzLl9yZXN1bHQgPSB7fTtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcImNsZWFyXCIsXCJcIixmdW5jdGlvbigpe1xuXHRcdFx0dGhhdC5fcmVzdWx0ID0ge307XG5cdFx0fSk7XG5cdFx0dGhpcy5zaXplID0gdGhpcy5jb21wdXRlU2l6ZSgpO1xuICAgIH1cblxuICAgIE1lcmdlT2JqZWN0cy50aXRsZSA9IFwiTWVyZ2UgT2JqZWN0c1wiO1xuICAgIE1lcmdlT2JqZWN0cy5kZXNjID0gXCJDcmVhdGVzIGFuIG9iamVjdCBjb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBvdGhlcnNcIjtcblxuICAgIE1lcmdlT2JqZWN0cy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0dmFyIEMgPSB0aGlzLl9yZXN1bHQ7XG5cdFx0aWYoQSlcblx0XHRcdGZvcih2YXIgaSBpbiBBKVxuXHRcdFx0XHRDW2ldID0gQVtpXTtcblx0XHRpZihCKVxuXHRcdFx0Zm9yKHZhciBpIGluIEIpXG5cdFx0XHRcdENbaV0gPSBCW2ldO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLEMpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL21lcmdlX29iamVjdHNcIiwgTWVyZ2VPYmplY3RzICk7XG5cbiAgICAvL1N0b3JlIGFzIHZhcmlhYmxlXG4gICAgZnVuY3Rpb24gVmFyaWFibGUoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2MCwgMzBdO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgdmFybmFtZTogXCJteW5hbWVcIiwgY29udGFpbmVyOiBWYXJpYWJsZS5MSVRFR1JBUEggfTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgVmFyaWFibGUudGl0bGUgPSBcIlZhcmlhYmxlXCI7XG4gICAgVmFyaWFibGUuZGVzYyA9IFwic3RvcmUvcmVhZCB2YXJpYWJsZSB2YWx1ZVwiO1xuXG5cdFZhcmlhYmxlLkxJVEVHUkFQSCA9IDA7IC8vYmV0d2VlbiBhbGwgZ3JhcGhzXG5cdFZhcmlhYmxlLkdSQVBIID0gMTtcdC8vb25seSBpbnNpZGUgdGhpcyBncmFwaFxuXHRWYXJpYWJsZS5HTE9CQUxTQ09QRSA9IDI7XHQvL2F0dGFjaGVkIHRvIFdpbmRvd1xuXG4gICAgVmFyaWFibGVbXCJAY29udGFpbmVyXCJdID0geyB0eXBlOiBcImVudW1cIiwgdmFsdWVzOiB7XCJsaXRlZ3JhcGhcIjpWYXJpYWJsZS5MSVRFR1JBUEgsIFwiZ3JhcGhcIjpWYXJpYWJsZS5HUkFQSCxcImdsb2JhbFwiOiBWYXJpYWJsZS5HTE9CQUxTQ09QRX0gfTtcblxuICAgIFZhcmlhYmxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcblxuXHRcdGlmKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgwKSlcblx0XHR7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0XHRjb250YWluZXJbIHRoaXMucHJvcGVydGllcy52YXJuYW1lIF0gPSB0aGlzLnZhbHVlO1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMudmFsdWUgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIGNvbnRhaW5lclsgdGhpcy5wcm9wZXJ0aWVzLnZhcm5hbWUgXSApO1xuICAgIH07XG5cblx0VmFyaWFibGUucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHN3aXRjaCh0aGlzLnByb3BlcnRpZXMuY29udGFpbmVyKVxuXHRcdHtcblx0XHRcdGNhc2UgVmFyaWFibGUuR1JBUEg6XG5cdFx0XHRcdGlmKHRoaXMuZ3JhcGgpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ3JhcGgudmFycztcblx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVmFyaWFibGUuR0xPQkFMU0NPUEU6XG5cdFx0XHRcdHJldHVybiBnbG9iYWw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBWYXJpYWJsZS5MSVRFR1JBUEg6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gTGl0ZUdyYXBoLkdsb2JhbHM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG4gICAgVmFyaWFibGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudmFybmFtZTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy92YXJpYWJsZVwiLCBWYXJpYWJsZSk7XG5cbiAgICBmdW5jdGlvbiBsZW5ndGgodikge1xuICAgICAgICBpZih2ICYmIHYubGVuZ3RoICE9IG51bGwpXG5cdFx0XHRyZXR1cm4gTnVtYmVyKHYubGVuZ3RoKTtcblx0XHRyZXR1cm4gMDtcbiAgICB9XG5cbiAgICBMaXRlR3JhcGgud3JhcEZ1bmN0aW9uQXNOb2RlKFxuICAgICAgICBcImJhc2ljL2xlbmd0aFwiLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIFtcIlwiXSxcbiAgICAgICAgXCJudW1iZXJcIlxuICAgICk7XG5cblx0ZnVuY3Rpb24gRG93bmxvYWREYXRhKCkge1xuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImRhdGFcIiwgMCApO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiZG93bmxvYWRcIiwgTGl0ZUdyYXBoLkFDVElPTiApO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZmlsZW5hbWU6IFwiZGF0YS5qc29uXCIgfTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsXCJEb3dubG9hZFwiLFwiXCIsIGZ1bmN0aW9uKHYpe1xuXHRcdFx0aWYoIXRoYXQudmFsdWUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHRoYXQuZG93bmxvYWRBc0ZpbGUoKTtcblx0XHR9KTtcbiAgICB9XG5cbiAgICBEb3dubG9hZERhdGEudGl0bGUgPSBcIkRvd25sb2FkXCI7XG4gICAgRG93bmxvYWREYXRhLmRlc2MgPSBcIkRvd25sb2FkIHNvbWUgZGF0YVwiO1xuXG5cdERvd25sb2FkRGF0YS5wcm90b3R5cGUuZG93bmxvYWRBc0ZpbGUgPSBmdW5jdGlvbigpXG5cdHtcblx0XHRpZih0aGlzLnZhbHVlID09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgc3RyID0gbnVsbDtcblx0XHRpZih0aGlzLnZhbHVlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXG5cdFx0XHRzdHIgPSB0aGlzLnZhbHVlO1xuXHRcdGVsc2Vcblx0XHRcdHN0ciA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuXG5cdFx0dmFyIGZpbGUgPSBuZXcgQmxvYihbc3RyXSk7XG5cdFx0dmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGZpbGUgKTtcblx0XHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCB0aGlzLnByb3BlcnRpZXMuZmlsZW5hbWUgKTtcblx0XHRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRlbGVtZW50LmNsaWNrKCk7XG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpeyBVUkwucmV2b2tlT2JqZWN0VVJMKCB1cmwgKTsgfSwgMTAwMCo2MCApOyAvL3dhaXQgb25lIG1pbnV0ZSB0byByZXZva2UgdXJsXG5cdH1cblxuICAgIERvd25sb2FkRGF0YS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7IHRoYXQuZG93bmxvYWRBc0ZpbGUoKTsgfSwgMTAwKTsgLy9kZWZlcnJlZCB0byBhdm9pZCBibG9ja2luZyB0aGUgcmVuZGVyZXIgd2l0aCB0aGUgcG9wdXBcblx0fVxuXG4gICAgRG93bmxvYWREYXRhLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzWzBdKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRG93bmxvYWREYXRhLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvZG93bmxvYWRcIiwgRG93bmxvYWREYXRhKTtcblxuXG5cbiAgICAvL1dhdGNoIGEgdmFsdWUgaW4gdGhlIGVkaXRvclxuICAgIGZ1bmN0aW9uIFdhdGNoKCkge1xuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZhbHVlXCIsIDAsIHsgbGFiZWw6IFwiXCIgfSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgIH1cblxuICAgIFdhdGNoLnRpdGxlID0gXCJXYXRjaFwiO1xuICAgIFdhdGNoLmRlc2MgPSBcIlNob3cgdmFsdWUgb2YgaW5wdXRcIjtcblxuICAgIFdhdGNoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzWzBdKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2F0Y2gucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzWzBdLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG5cbiAgICBXYXRjaC50b1N0cmluZyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKG8uY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG8udG9GaXhlZCgzKTtcbiAgICAgICAgfSBlbHNlIGlmIChvLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IFwiW1wiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFdhdGNoLnRvU3RyaW5nKG9baV0pICsgKGkgKyAxICE9IG8ubGVuZ3RoID8gXCIsXCIgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciArPSBcIl1cIjtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG8pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdhdGNoLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vc2hvdyB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICB0aGlzLmlucHV0c1swXS5sYWJlbCA9IFdhdGNoLnRvU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3dhdGNoXCIsIFdhdGNoKTtcblxuICAgIC8vaW4gY2FzZSBvbmUgdHlwZSBkb2VzbnQgbWF0Y2ggb3RoZXIgdHlwZSBidXQgeW91IHdhbnQgdG8gY29ubmVjdCB0aGVtIGFueXdheVxuICAgIGZ1bmN0aW9uIENhc3QoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCAwKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgMCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs0MCwgMzBdO1xuICAgIH1cblxuICAgIENhc3QudGl0bGUgPSBcIkNhc3RcIjtcbiAgICBDYXN0LmRlc2MgPSBcIkFsbG93cyB0byBjb25uZWN0IGRpZmZlcmVudCB0eXBlc1wiO1xuXG4gICAgQ2FzdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmdldElucHV0RGF0YSgwKSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvY2FzdFwiLCBDYXN0KTtcblxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcbiAgICBmdW5jdGlvbiBDb25zb2xlKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBMaXRlR3JhcGguT05fRVZFTlQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibXNnXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwibG9nXCIsIExpdGVHcmFwaC5FVkVOVCk7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJtc2dcIiwgMCk7XG4gICAgfVxuXG4gICAgQ29uc29sZS50aXRsZSA9IFwiQ29uc29sZVwiO1xuICAgIENvbnNvbGUuZGVzYyA9IFwiU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGNvbnNvbGVcIjtcblxuICAgIENvbnNvbGUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAoYWN0aW9uID09IFwibG9nXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhcmFtKTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gXCJ3YXJuXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihwYXJhbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc29sZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKG1zZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1zZyA9IG1zZztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIH07XG5cbiAgICBDb25zb2xlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1wibG9nXCIsIExpdGVHcmFwaC5BQ1RJT05dLFxuICAgICAgICAgICAgW1wid2FyblwiLCBMaXRlR3JhcGguQUNUSU9OXSxcbiAgICAgICAgICAgIFtcImVycm9yXCIsIExpdGVHcmFwaC5BQ1RJT05dXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvY29uc29sZVwiLCBDb25zb2xlKTtcblxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcbiAgICBmdW5jdGlvbiBBbGVydCgpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gTGl0ZUdyYXBoLk9OX0VWRU5UO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibXNnXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIiwgXCJUZXh0XCIsIFwiXCIsIFwibXNnXCIpO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMjAwLCAzMF07XG4gICAgfVxuXG4gICAgQWxlcnQudGl0bGUgPSBcIkFsZXJ0XCI7XG4gICAgQWxlcnQuZGVzYyA9IFwiU2hvdyBhbiBhbGVydCB3aW5kb3dcIjtcbiAgICBBbGVydC5jb2xvciA9IFwiIzUxMFwiO1xuXG4gICAgQWxlcnQucHJvdG90eXBlLm9uQ29uZmlndXJlID0gZnVuY3Rpb24obykge1xuICAgICAgICB0aGlzLndpZGdldC52YWx1ZSA9IG8ucHJvcGVydGllcy5tc2c7XG4gICAgfTtcblxuICAgIEFsZXJ0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcbiAgICAgICAgdmFyIG1zZyA9IHRoaXMucHJvcGVydGllcy5tc2c7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhbGVydChtc2cpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvYWxlcnRcIiwgQWxlcnQpO1xuXG4gICAgLy9FeGVjaXRlcyBzaW1wbGUgY29kZVxuICAgIGZ1bmN0aW9uIE5vZGVTY3JpcHQoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2MCwgMzBdO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib25FeGVjdXRlXCIsIFwicmV0dXJuIEE7XCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiXCIpO1xuXG4gICAgICAgIHRoaXMuX2Z1bmMgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9XG5cbiAgICBOb2RlU2NyaXB0LnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKG8ucHJvcGVydGllcy5vbkV4ZWN1dGUgJiYgTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMpXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVDb2RlKG8ucHJvcGVydGllcy5vbkV4ZWN1dGUpO1xuXHRcdGVsc2Vcblx0XHRcdGNvbnNvbGUud2FybihcIlNjcmlwdCBub3QgY29tcGlsZWQsIExpdGVHcmFwaC5hbGxvd19zY3JpcHRzIGlzIGZhbHNlXCIpO1xuICAgIH07XG5cbiAgICBOb2RlU2NyaXB0LnRpdGxlID0gXCJTY3JpcHRcIjtcbiAgICBOb2RlU2NyaXB0LmRlc2MgPSBcImV4ZWN1dGVzIGEgY29kZSAobWF4IDEwMCBjaGFyYWN0ZXJzKVwiO1xuXG4gICAgTm9kZVNjcmlwdC53aWRnZXRzX2luZm8gPSB7XG4gICAgICAgIG9uRXhlY3V0ZTogeyB0eXBlOiBcImNvZGVcIiB9XG4gICAgfTtcblxuICAgIE5vZGVTY3JpcHQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJvbkV4ZWN1dGVcIiAmJiBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cylcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZUNvZGUodmFsdWUpO1xuXHRcdGVsc2Vcblx0XHRcdGNvbnNvbGUud2FybihcIlNjcmlwdCBub3QgY29tcGlsZWQsIExpdGVHcmFwaC5hbGxvd19zY3JpcHRzIGlzIGZhbHNlXCIpO1xuICAgIH07XG5cbiAgICBOb2RlU2NyaXB0LnByb3RvdHlwZS5jb21waWxlQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgdGhpcy5fZnVuYyA9IG51bGw7XG4gICAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDI1Nikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU2NyaXB0IHRvbyBsb25nLCBtYXggMjU2IGNoYXJzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvZGVfbG93ID0gY29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGZvcmJpZGRlbl93b3JkcyA9IFtcbiAgICAgICAgICAgICAgICBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICAgIFwiYm9keVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICBcImV2YWxcIixcbiAgICAgICAgICAgICAgICBcIm5vZGVzY3JpcHRcIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgIF07IC8vYmFkIHNlY3VyaXR5IHNvbHV0aW9uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmJpZGRlbl93b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlX2xvdy5pbmRleE9mKGZvcmJpZGRlbl93b3Jkc1tpXSkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBzY3JpcHRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bmMgPSBuZXcgRnVuY3Rpb24oXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEQVRBXCIsIFwibm9kZVwiLCBjb2RlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIHNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTm9kZVNjcmlwdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuICAgICAgICAgICAgdmFyIEMgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9mdW5jKEEsIEIsIEMsIHRoaXMuZGF0YSwgdGhpcykpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBzY3JpcHRcIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTm9kZVNjcmlwdC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbW1wiQ1wiLCBcIlwiXV07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvc2NyaXB0XCIsIE5vZGVTY3JpcHQpO1xufSkodGhpcyk7XG5cbi8vZXZlbnQgcmVsYXRlZCBub2Rlc1xyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICAvL1Nob3cgdmFsdWUgaW5zaWRlIHRoZSBkZWJ1ZyBjb25zb2xlXHJcbiAgICBmdW5jdGlvbiBMb2dFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZXZlbnRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICB9XHJcblxyXG4gICAgTG9nRXZlbnQudGl0bGUgPSBcIkxvZyBFdmVudFwiO1xyXG4gICAgTG9nRXZlbnQuZGVzYyA9IFwiTG9nIGV2ZW50IGluIGNvbnNvbGVcIjtcclxuXHJcbiAgICBMb2dFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYWN0aW9uLCBwYXJhbSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL2xvZ1wiLCBMb2dFdmVudCk7XHJcblxyXG4gICAgLy9jb252ZXJ0IHRvIEV2ZW50IGlmIHRoZSB2YWx1ZSBpcyB0cnVlXHJcbiAgICBmdW5jdGlvbiBUcmlnZ2VyRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImlmXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidHJ1ZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiY2hhbmdlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmYWxzZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBvbmx5X29uX2NoYW5nZTogdHJ1ZSB9O1xyXG5cdFx0dGhpcy5wcmV2ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBUcmlnZ2VyRXZlbnQudGl0bGUgPSBcIlRyaWdnZXJFdmVudFwiO1xyXG4gICAgVHJpZ2dlckV2ZW50LmRlc2MgPSBcIlRyaWdnZXJzIGV2ZW50IGlmIGlucHV0IGV2YWx1YXRlcyB0byB0cnVlXCI7XHJcblxyXG4gICAgVHJpZ2dlckV2ZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcblx0XHR2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIGNoYW5nZWQgPSAodiAhPSB0aGlzLnByZXYpO1xyXG5cdFx0aWYodGhpcy5wcmV2ID09PSAwKVxyXG5cdFx0XHRjaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR2YXIgbXVzdF9yZXNlbmQgPSAoY2hhbmdlZCAmJiB0aGlzLnByb3BlcnRpZXMub25seV9vbl9jaGFuZ2UpIHx8ICghY2hhbmdlZCAmJiAhdGhpcy5wcm9wZXJ0aWVzLm9ubHlfb25fY2hhbmdlKTtcclxuXHRcdGlmKHYgJiYgbXVzdF9yZXNlbmQgKVxyXG5cdCAgICAgICAgdGhpcy50cmlnZ2VyU2xvdCgwLCBwYXJhbSk7XHJcblx0XHRpZighdiAmJiBtdXN0X3Jlc2VuZClcclxuXHQgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMiwgcGFyYW0pO1xyXG5cdFx0aWYoY2hhbmdlZClcclxuXHQgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMSwgcGFyYW0pO1xyXG5cdFx0dGhpcy5wcmV2ID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvdHJpZ2dlclwiLCBUcmlnZ2VyRXZlbnQpO1xyXG5cclxuICAgIC8vU2VxdWVuY2VyIGZvciBldmVudHNcclxuICAgIGZ1bmN0aW9uIFNlcXVlbmNlcigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbMTIwLCAzMF07XHJcbiAgICAgICAgdGhpcy5mbGFncyA9IHsgaG9yaXpvbnRhbDogdHJ1ZSwgcmVuZGVyX2JveDogZmFsc2UgfTtcclxuICAgIH1cclxuXHJcbiAgICBTZXF1ZW5jZXIudGl0bGUgPSBcIlNlcXVlbmNlclwiO1xyXG4gICAgU2VxdWVuY2VyLmRlc2MgPSBcIlRyaWdnZXIgZXZlbnRzIHdoZW4gYW4gZXZlbnQgYXJyaXZlc1wiO1xyXG5cclxuICAgIFNlcXVlbmNlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgU2VxdWVuY2VyLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJTbG90KGksIHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvc2VxdWVuY2VyXCIsIFNlcXVlbmNlcik7XHJcblxyXG4gICAgLy9GaWx0ZXIgZXZlbnRzXHJcbiAgICBmdW5jdGlvbiBGaWx0ZXJFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZXZlbnRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJldmVudFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZXF1YWxfdG86IFwiXCIsXHJcbiAgICAgICAgICAgIGhhc19wcm9wZXJ0eTogXCJcIixcclxuICAgICAgICAgICAgcHJvcGVydHlfZXF1YWxfdG86IFwiXCJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIEZpbHRlckV2ZW50LnRpdGxlID0gXCJGaWx0ZXIgRXZlbnRcIjtcclxuICAgIEZpbHRlckV2ZW50LmRlc2MgPSBcIkJsb2NrcyBldmVudHMgdGhhdCBkbyBub3QgbWF0Y2ggdGhlIGZpbHRlclwiO1xyXG5cclxuICAgIEZpbHRlckV2ZW50LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICBpZiAocGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmVxdWFsX3RvICYmIHRoaXMucHJvcGVydGllcy5lcXVhbF90byAhPSBwYXJhbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmhhc19wcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHBhcmFtW3RoaXMucHJvcGVydGllcy5oYXNfcHJvcGVydHldO1xyXG4gICAgICAgICAgICBpZiAocHJvcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wcm9wZXJ0eV9lcXVhbF90byAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnByb3BlcnR5X2VxdWFsX3RvICE9IHByb3BcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMCwgcGFyYW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9maWx0ZXJcIiwgRmlsdGVyRXZlbnQpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBFdmVudEJyYW5jaCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNvbmRcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidHJ1ZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZmFsc2VcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbMTIwLCA2MF07XHJcblx0XHR0aGlzLl92YWx1ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIEV2ZW50QnJhbmNoLnRpdGxlID0gXCJCcmFuY2hcIjtcclxuICAgIEV2ZW50QnJhbmNoLmRlc2MgPSBcIklmIGNvbmRpdGlvbiBpcyB0cnVlLCBvdXRwdXRzIHRyaWdnZXJzIHRydWUsIG90aGVyd2lzZSBmYWxzZVwiO1xyXG5cclxuICAgIEV2ZW50QnJhbmNoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuX3ZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0fVxyXG5cclxuICAgIEV2ZW50QnJhbmNoLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuXHRcdHRoaXMudHJpZ2dlclNsb3QodGhpcy5fdmFsdWUgPyAwIDogMSk7XHJcblx0fVxyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL2JyYW5jaFwiLCBFdmVudEJyYW5jaCk7XHJcblxyXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxyXG4gICAgZnVuY3Rpb24gRXZlbnRDb3VudGVyKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbmNcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImRlY1wiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwicmVzZXRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJjaGFuZ2VcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm51bVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLm51bSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgRXZlbnRDb3VudGVyLnRpdGxlID0gXCJDb3VudGVyXCI7XHJcbiAgICBFdmVudENvdW50ZXIuZGVzYyA9IFwiQ291bnRzIGV2ZW50c1wiO1xyXG5cclxuICAgIEV2ZW50Q291bnRlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLm51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVudENvdW50ZXIucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5udW07XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PSBcImluY1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtICs9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gXCJkZWNcIikge1xyXG4gICAgICAgICAgICB0aGlzLm51bSAtPSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwicmVzZXRcIikge1xyXG4gICAgICAgICAgICB0aGlzLm51bSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm51bSAhPSB2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCB0aGlzLm51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBFdmVudENvdW50ZXIucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjIwcHggQXJpYWxcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5udW0sIHRoaXMuc2l6ZVswXSAqIDAuNSwgdGhpcy5zaXplWzFdICogMC41KTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlbnRDb3VudGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5udW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9jb3VudGVyXCIsIEV2ZW50Q291bnRlcik7XHJcblxyXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxyXG4gICAgZnVuY3Rpb24gRGVsYXlFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidGltZV9pbl9tc1wiLCAxMDAwKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZXZlbnRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvbl90aW1lXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBEZWxheUV2ZW50LnRpdGxlID0gXCJEZWxheVwiO1xyXG4gICAgRGVsYXlFdmVudC5kZXNjID0gXCJEZWxheXMgb25lIGV2ZW50XCI7XHJcblxyXG4gICAgRGVsYXlFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLnByb3BlcnRpZXMudGltZV9pbl9tcztcclxuICAgICAgICBpZiAodGltZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihudWxsLCBwYXJhbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKFt0aW1lLCBwYXJhbV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRGVsYXlFdmVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGR0ID0gdGhpcy5ncmFwaC5lbGFwc2VkX3RpbWUgKiAxMDAwOyAvL2luIG1zXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnRpbWVfaW5fbXMgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuICAgICAgICAgICAgYWN0aW9uWzBdIC09IGR0O1xyXG4gICAgICAgICAgICBpZiAoYWN0aW9uWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlXHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAtLWk7XHJcblxyXG4gICAgICAgICAgICAvL3RyaWdnZXJcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG51bGwsIGFjdGlvblsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBEZWxheUV2ZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiZXZlbnRcIiwgTGl0ZUdyYXBoLkFDVElPTl0sIFtcInRpbWVfaW5fbXNcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9kZWxheVwiLCBEZWxheUV2ZW50KTtcclxuXHJcbiAgICAvL1Nob3cgdmFsdWUgaW5zaWRlIHRoZSBkZWJ1ZyBjb25zb2xlXHJcbiAgICBmdW5jdGlvbiBUaW1lckV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJpbnRlcnZhbFwiLCAxMDAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiZXZlbnRcIiwgXCJ0aWNrXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib25fdGlja1wiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0X2ludGVydmFsID0gMTAwMDtcclxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIFRpbWVyRXZlbnQudGl0bGUgPSBcIlRpbWVyXCI7XHJcbiAgICBUaW1lckV2ZW50LmRlc2MgPSBcIlNlbmRzIGFuIGV2ZW50IGV2ZXJ5IE4gbWlsbGlzZWNvbmRzXCI7XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIFRpbWVyRXZlbnQucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGltZXI6IFwiICsgdGhpcy5sYXN0X2ludGVydmFsLnRvU3RyaW5nKCkgKyBcIm1zXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIFRpbWVyRXZlbnQub25fY29sb3IgPSBcIiNBQUFcIjtcclxuICAgIFRpbWVyRXZlbnQub2ZmX2NvbG9yID0gXCIjMjIyXCI7XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSB0aGlzLnRyaWdnZXJlZFxyXG4gICAgICAgICAgICA/IFRpbWVyRXZlbnQub25fY29sb3JcclxuICAgICAgICAgICAgOiBUaW1lckV2ZW50Lm9mZl9jb2xvcjtcclxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZHQgPSB0aGlzLmdyYXBoLmVsYXBzZWRfdGltZSAqIDEwMDA7IC8vaW4gbXNcclxuXHJcbiAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLnRpbWUgPT0gMDtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgIHRoaXMubGFzdF9pbnRlcnZhbCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAxLFxyXG4gICAgICAgICAgICB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImludGVydmFsXCIpIHwgMFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgIXRyaWdnZXIgJiZcclxuICAgICAgICAgICAgKHRoaXMudGltZSA8IHRoaXMubGFzdF9pbnRlcnZhbCB8fCBpc05hTih0aGlzLmxhc3RfaW50ZXJ2YWwpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoID4gMSAmJiB0aGlzLmlucHV0c1sxXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50aW1lID0gdGhpcy50aW1lICUgdGhpcy5sYXN0X2ludGVydmFsO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX3RpY2tcIiwgdGhpcy5wcm9wZXJ0aWVzLmV2ZW50KTtcclxuICAgICAgICBpZiAodGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoID4gMSAmJiB0aGlzLmlucHV0c1sxXSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiaW50ZXJ2YWxcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcInRpY2tcIiwgXCJib29sZWFuXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvdGltZXJcIiwgVGltZXJFdmVudCk7XHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YVN0b3JlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkYXRhXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhc3NpZ25cIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJkYXRhXCIsIFwiXCIpO1xyXG5cdFx0dGhpcy5fbGFzdF92YWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGRhdGE6IG51bGwsIHNlcmlhbGl6ZTogdHJ1ZSB9O1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcInN0b3JlXCIsXCJcIixmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGF0LnByb3BlcnRpZXMuZGF0YSA9IHRoYXQuX2xhc3RfdmFsdWU7XHJcblx0XHR9KTtcclxuICAgIH1cclxuXHJcbiAgICBEYXRhU3RvcmUudGl0bGUgPSBcIkRhdGEgU3RvcmVcIjtcclxuICAgIERhdGFTdG9yZS5kZXNjID0gXCJTdG9yZXMgZGF0YSBhbmQgb25seSBjaGFuZ2VzIHdoZW4gZXZlbnQgaXMgcmVjZWl2ZWRcIjtcclxuXHJcblx0RGF0YVN0b3JlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dGhpcy5fbGFzdF92YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy5kYXRhICk7XHJcblx0fVxyXG5cclxuICAgIERhdGFTdG9yZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMuZGF0YSA9IHRoaXMuX2xhc3RfdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuXHREYXRhU3RvcmUucHJvdG90eXBlLm9uU2VyaWFsaXplID0gZnVuY3Rpb24obylcclxuXHR7XHJcblx0XHRpZihvLmRhdGEgPT0gbnVsbClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLnNlcmlhbGl6ZSA9PSBmYWxzZSB8fCAoby5kYXRhLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgJiYgby5kYXRhLmNvbnN0cnVjdG9yICE9PSBOdW1iZXIgJiYgby5kYXRhLmNvbnN0cnVjdG9yICE9PSBCb29sZWFuICYmIG8uZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgby5kYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgKSlcclxuXHRcdFx0by5kYXRhID0gbnVsbDtcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9kYXRhX3N0b3JlXCIsIERhdGFTdG9yZSk7XHJcbn0pKHRoaXMpO1xyXG5cbi8vd2lkZ2V0c1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xuXG4gICAgLyogQnV0dG9uICoqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBXaWRnZXRCdXR0b24oKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInRleHRcIiwgXCJjbGljayBtZVwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZvbnRfc2l6ZVwiLCAzMCk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtZXNzYWdlXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTY0LCA4NF07XG4gICAgICAgIHRoaXMuY2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIFdpZGdldEJ1dHRvbi50aXRsZSA9IFwiQnV0dG9uXCI7XG4gICAgV2lkZ2V0QnV0dG9uLmRlc2MgPSBcIlRyaWdnZXJzIGFuIGV2ZW50XCI7XG5cbiAgICBXaWRnZXRCdXR0b24uZm9udCA9IFwiQXJpYWxcIjtcbiAgICBXaWRnZXRCdXR0b24ucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmdpbiA9IDEwO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBtYXJnaW4gKyAxLFxuICAgICAgICAgICAgbWFyZ2luICsgMSxcbiAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAtIG1hcmdpbiAqIDIsXG4gICAgICAgICAgICB0aGlzLnNpemVbMV0gLSBtYXJnaW4gKiAyXG4gICAgICAgICk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUZcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbWFyZ2luIC0gMSxcbiAgICAgICAgICAgIG1hcmdpbiAtIDEsXG4gICAgICAgICAgICB0aGlzLnNpemVbMF0gLSBtYXJnaW4gKiAyLFxuICAgICAgICAgICAgdGhpcy5zaXplWzFdIC0gbWFyZ2luICogMlxuICAgICAgICApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jbGlja2VkXG4gICAgICAgICAgICA/IFwid2hpdGVcIlxuICAgICAgICAgICAgOiB0aGlzLm1vdXNlT3ZlclxuICAgICAgICAgICAgPyBcIiM2NjhcIlxuICAgICAgICAgICAgOiBcIiMzMzRcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgdGhpcy5zaXplWzBdIC0gbWFyZ2luICogMixcbiAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAtIG1hcmdpbiAqIDJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnRleHQgfHwgdGhpcy5wcm9wZXJ0aWVzLnRleHQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBmb250X3NpemUgPSB0aGlzLnByb3BlcnRpZXMuZm9udF9zaXplIHx8IDMwO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jbGlja2VkID8gXCJibGFja1wiIDogXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250X3NpemUgKyBcInB4IFwiICsgV2lkZ2V0QnV0dG9uLmZvbnQ7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnRleHQsXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAqIDAuNSArIGZvbnRfc2l6ZSAqIDAuM1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRCdXR0b24ucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgbG9jYWxfcG9zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsX3Bvc1swXSA+IDEgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1sxXSA+IDEgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1swXSA8IHRoaXMuc2l6ZVswXSAtIDIgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1sxXSA8IHRoaXMuc2l6ZVsxXSAtIDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdCgwLCB0aGlzLnByb3BlcnRpZXMubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRCdXR0b24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5jbGlja2VkKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0QnV0dG9uLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuY2xpY2tlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9idXR0b25cIiwgV2lkZ2V0QnV0dG9uKTtcblxuICAgIGZ1bmN0aW9uIFdpZGdldFRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcImJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJlXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBmb250OiBcIlwiLCB2YWx1ZTogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE2MCwgNDRdO1xuICAgIH1cblxuICAgIFdpZGdldFRvZ2dsZS50aXRsZSA9IFwiVG9nZ2xlXCI7XG4gICAgV2lkZ2V0VG9nZ2xlLmRlc2MgPSBcIlRvZ2dsZXMgYmV0d2VlbiB0cnVlIG9yIGZhbHNlXCI7XG5cbiAgICBXaWRnZXRUb2dnbGUucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZVsxXSAqIDAuNTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IDAuMjU7XG4gICAgICAgIHZhciBoID0gdGhpcy5zaXplWzFdICogMC44O1xuICAgICAgICBjdHguZm9udCA9IHRoaXMucHJvcGVydGllcy5mb250IHx8IChzaXplICogMC44KS50b0ZpeGVkKDApICsgXCJweCBBcmlhbFwiO1xuICAgICAgICB2YXIgdyA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRpdGxlKS53aWR0aDtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zaXplWzBdIC0gKHcgKyBzaXplKSkgKiAwLjU7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FBQVwiO1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgaCAtIHNpemUsIHNpemUsIHNpemUpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnByb3BlcnRpZXMudmFsdWUgPyBcIiNBRUZcIiA6IFwiIzAwMFwiO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICB4ICsgc2l6ZSAqIG1hcmdpbixcbiAgICAgICAgICAgIGggLSBzaXplICsgc2l6ZSAqIG1hcmdpbixcbiAgICAgICAgICAgIHNpemUgKiAoMSAtIG1hcmdpbiAqIDIpLFxuICAgICAgICAgICAgc2l6ZSAqICgxIC0gbWFyZ2luICogMilcbiAgICAgICAgKTtcblxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGl0bGUsIHNpemUgKiAxLjIgKyB4LCBoICogMC44NSk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9O1xuXG4gICAgV2lkZ2V0VG9nZ2xlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPSAhdGhpcy5wcm9wZXJ0aWVzLnZhbHVlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJlXCIsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldFRvZ2dsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldFRvZ2dsZS5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBsb2NhbF9wb3MpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbG9jYWxfcG9zWzBdID4gMSAmJlxuICAgICAgICAgICAgbG9jYWxfcG9zWzFdID4gMSAmJlxuICAgICAgICAgICAgbG9jYWxfcG9zWzBdIDwgdGhpcy5zaXplWzBdIC0gMiAmJlxuICAgICAgICAgICAgbG9jYWxfcG9zWzFdIDwgdGhpcy5zaXplWzFdIC0gMlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9ICF0aGlzLnByb3BlcnRpZXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJlXCIsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC90b2dnbGVcIiwgV2lkZ2V0VG9nZ2xlKTtcblxuICAgIC8qIE51bWJlciAqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0TnVtYmVyKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCA2MF07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgbWluOiAtMTAwMCwgbWF4OiAxMDAwLCB2YWx1ZTogMSwgc3RlcDogMSB9O1xuICAgICAgICB0aGlzLm9sZF95ID0gLTE7XG4gICAgICAgIHRoaXMuX3JlbWFpbmRlciA9IDA7XG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IDA7XG4gICAgICAgIHRoaXMubW91c2VfY2FwdHVyZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBXaWRnZXROdW1iZXIudGl0bGUgPSBcIk51bWJlclwiO1xuICAgIFdpZGdldE51bWJlci5kZXNjID0gXCJXaWRnZXQgdG8gc2VsZWN0IG51bWJlciB2YWx1ZVwiO1xuXG4gICAgV2lkZ2V0TnVtYmVyLnBpeGVsc190aHJlc2hvbGQgPSAxMDtcbiAgICBXaWRnZXROdW1iZXIubWFya2Vyc19jb2xvciA9IFwiIzY2NlwiO1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5zaXplWzBdICogMC41O1xuICAgICAgICB2YXIgaCA9IHRoaXMuc2l6ZVsxXTtcbiAgICAgICAgaWYgKGggPiAzMCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFdpZGdldE51bWJlci5tYXJrZXJzX2NvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCBoICogMC4xKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGggKiAwLjEsIGggKiAwLjIpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaCAqIC0wLjEsIGggKiAwLjIpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgaCAqIDAuOSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBoICogMC4xLCBoICogMC44KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGggKiAtMC4xLCBoICogMC44KTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IChoICogMC43KS50b0ZpeGVkKDEpICsgXCJweCBBcmlhbFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSAoaCAqIDAuOCkudG9GaXhlZCgxKSArIFwicHggQXJpYWxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBjdHguZm9udCA9IChoICogMC43KS50b0ZpeGVkKDEpICsgXCJweCBBcmlhbFwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjRUVFXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZS50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbiksXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgaCAqIDAuNzVcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldE51bWJlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdCA9ICh0aGlzLnByb3BlcnRpZXMuc3RlcCArIFwiXCIpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gdC5sZW5ndGggPiAxID8gdFsxXS5sZW5ndGggOiAwO1xuICAgIH07XG5cbiAgICBXaWRnZXROdW1iZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgcG9zKSB7XG4gICAgICAgIGlmIChwb3NbMV0gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9sZF95ID0gZS5jYW52YXNZO1xuICAgICAgICB0aGlzLmNhcHR1cmVJbnB1dCh0cnVlKTtcbiAgICAgICAgdGhpcy5tb3VzZV9jYXB0dXJlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFdpZGdldE51bWJlci5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZV9jYXB0dXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5vbGRfeSAtIGUuY2FudmFzWTtcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGRlbHRhICo9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkpIHtcbiAgICAgICAgICAgIGRlbHRhICo9IDAuMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9sZF95ID0gZS5jYW52YXNZO1xuXG4gICAgICAgIHZhciBzdGVwcyA9IHRoaXMuX3JlbWFpbmRlciArIGRlbHRhIC8gV2lkZ2V0TnVtYmVyLnBpeGVsc190aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuX3JlbWFpbmRlciA9IHN0ZXBzICUgMTtcbiAgICAgICAgc3RlcHMgPSBzdGVwcyB8IDA7XG5cbiAgICAgICAgdmFyIHYgPSBNYXRoLmNsYW1wKFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICsgc3RlcHMgKiB0aGlzLnByb3BlcnRpZXMuc3RlcCxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW4sXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHY7XG4gICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlLCBwb3MpIHtcbiAgICAgICAgaWYgKGUuY2xpY2tfdGltZSA8IDIwMCkge1xuICAgICAgICAgICAgdmFyIHN0ZXBzID0gcG9zWzFdID4gdGhpcy5zaXplWzFdICogMC41ID8gLTEgOiAxO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gTWF0aC5jbGFtcChcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgKyBzdGVwcyAqIHRoaXMucHJvcGVydGllcy5zdGVwLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW4sXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1heFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb3VzZV9jYXB0dXJlZCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZV9jYXB0dXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L251bWJlclwiLCBXaWRnZXROdW1iZXIpO1xuXG5cbiAgICAvKiBDb21ibyAqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0Q29tYm8oKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwic3RyaW5nXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImNoYW5nZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDYwXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB2YWx1ZTogXCJBXCIsIHZhbHVlczpcIkE7QjtDXCIgfTtcbiAgICAgICAgdGhpcy5vbGRfeSA9IC0xO1xuICAgICAgICB0aGlzLm1vdXNlX2NhcHR1cmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fdmFsdWVzID0gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlcy5zcGxpdChcIjtcIik7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuXHRcdHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwiXCIsIHRoaXMucHJvcGVydGllcy52YWx1ZSwgZnVuY3Rpb24odil7XG5cdFx0XHR0aGF0LnByb3BlcnRpZXMudmFsdWUgPSB2O1xuICAgICAgICAgICAgdGhhdC50cmlnZ2VyU2xvdCgxLCB2KTtcblx0XHR9LCB7IHByb3BlcnR5OiBcInZhbHVlXCIsIHZhbHVlczogdGhpcy5fdmFsdWVzIH0gKTtcbiAgICB9XG5cbiAgICBXaWRnZXRDb21iby50aXRsZSA9IFwiQ29tYm9cIjtcbiAgICBXaWRnZXRDb21iby5kZXNjID0gXCJXaWRnZXQgdG8gc2VsZWN0IGZyb20gYSBsaXN0XCI7XG5cbiAgICBXaWRnZXRDb21iby5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICk7XG4gICAgfTtcblxuICAgIFdpZGdldENvbWJvLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYobmFtZSA9PSBcInZhbHVlc1wiKVxuXHRcdHtcblx0XHRcdHRoaXMuX3ZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiO1wiKTtcblx0XHRcdHRoaXMud2lkZ2V0Lm9wdGlvbnMudmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuXHRcdH1cblx0XHRlbHNlIGlmKG5hbWUgPT0gXCJ2YWx1ZVwiKVxuXHRcdHtcblx0XHRcdHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvY29tYm9cIiwgV2lkZ2V0Q29tYm8pO1xuXG5cbiAgICAvKiBLbm9iICoqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBXaWRnZXRLbm9iKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzY0LCA4NF07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMSxcbiAgICAgICAgICAgIHZhbHVlOiAwLjUsXG4gICAgICAgICAgICBjb2xvcjogXCIjN0FGXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IDJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgIH1cblxuICAgIFdpZGdldEtub2IudGl0bGUgPSBcIktub2JcIjtcbiAgICBXaWRnZXRLbm9iLmRlc2MgPSBcIkNpcmN1bGFyIGNvbnRyb2xsZXJcIjtcbiAgICBXaWRnZXRLbm9iLnNpemUgPSBbODAsIDEwMF07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPVxuICAgICAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMudmFsdWUgLSB0aGlzLnByb3BlcnRpZXMubWluKSAvXG4gICAgICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5tYXggLSB0aGlzLnByb3BlcnRpZXMubWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZW50ZXJfeCA9IHRoaXMuc2l6ZVswXSAqIDAuNTtcbiAgICAgICAgdmFyIGNlbnRlcl95ID0gdGhpcy5zaXplWzFdICogMC41O1xuICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4odGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pICogMC41IC0gNTtcbiAgICAgICAgdmFyIHcgPSBNYXRoLmZsb29yKHJhZGl1cyAqIDAuMDUpO1xuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyX3gsIGNlbnRlcl95KTtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJICogMC43NSk7XG5cbiAgICAgICAgLy9iZ1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLDAuNSlcIjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDEuNSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgLy92YWx1ZVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5hcmMoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHJhZGl1cyAtIDQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC5QSSAqIDEuNSAqIE1hdGgubWF4KDAuMDEsIHRoaXMudmFsdWUpXG4gICAgICAgICk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy9jdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vaW5uZXJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKGNlbnRlcl94LCBjZW50ZXJfeSwgcmFkaXVzICogMC43NSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIC8vbWluaWJhbGxcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubW91c2VPdmVyID8gXCJ3aGl0ZVwiIDogdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMudmFsdWUgKiBNYXRoLlBJICogMS41ICsgTWF0aC5QSSAqIDAuNzU7XG4gICAgICAgIGN0eC5hcmMoXG4gICAgICAgICAgICBjZW50ZXJfeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyAqIDAuNjUsXG4gICAgICAgICAgICBjZW50ZXJfeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyAqIDAuNjUsXG4gICAgICAgICAgICByYWRpdXMgKiAwLjA1LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIC8vdGV4dFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5tb3VzZU92ZXIgPyBcIndoaXRlXCIgOiBcIiNBQUFcIjtcbiAgICAgICAgY3R4LmZvbnQgPSBNYXRoLmZsb29yKHJhZGl1cyAqIDAuNSkgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUudG9GaXhlZCh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uKSxcbiAgICAgICAgICAgIGNlbnRlcl94LFxuICAgICAgICAgICAgY2VudGVyX3kgKyByYWRpdXMgKiAwLjE1XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFdpZGdldEtub2IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IExpdGVHcmFwaC5jb2xvclRvU3RyaW5nKFtcbiAgICAgICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZVxuICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0S25vYi5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuY2VudGVyID0gW3RoaXMuc2l6ZVswXSAqIDAuNSwgdGhpcy5zaXplWzFdICogMC41ICsgMjBdO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMuc2l6ZVswXSAqIDAuNTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZS5jYW52YXNZIC0gdGhpcy5wb3NbMV0gPCAyMCB8fFxuICAgICAgICAgICAgTGl0ZUdyYXBoLmRpc3RhbmNlKFxuICAgICAgICAgICAgICAgIFtlLmNhbnZhc1gsIGUuY2FudmFzWV0sXG4gICAgICAgICAgICAgICAgW3RoaXMucG9zWzBdICsgdGhpcy5jZW50ZXJbMF0sIHRoaXMucG9zWzFdICsgdGhpcy5jZW50ZXJbMV1dXG4gICAgICAgICAgICApID4gdGhpcy5yYWRpdXNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbGRtb3VzZSA9IFtlLmNhbnZhc1ggLSB0aGlzLnBvc1swXSwgZS5jYW52YXNZIC0gdGhpcy5wb3NbMV1dO1xuICAgICAgICB0aGlzLmNhcHR1cmVJbnB1dCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFdpZGdldEtub2IucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMub2xkbW91c2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gW2UuY2FudmFzWCAtIHRoaXMucG9zWzBdLCBlLmNhbnZhc1kgLSB0aGlzLnBvc1sxXV07XG5cbiAgICAgICAgdmFyIHYgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2IC09IChtWzFdIC0gdGhpcy5vbGRtb3VzZVsxXSkgKiAwLjAxO1xuICAgICAgICBpZiAodiA+IDEuMCkge1xuICAgICAgICAgICAgdiA9IDEuMDtcbiAgICAgICAgfSBlbHNlIGlmICh2IDwgMC4wKSB7XG4gICAgICAgICAgICB2ID0gMC4wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2O1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPVxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbiArXG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW4pICogdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5vbGRtb3VzZSA9IG07XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldEtub2IucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkbW91c2UpIHtcbiAgICAgICAgICAgIHRoaXMub2xkbW91c2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdpZGdldEtub2IucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJtaW5cIiB8fCBuYW1lID09IFwibWF4XCIgfHwgbmFtZSA9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vYmxvY2tcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9rbm9iXCIsIFdpZGdldEtub2IpO1xuXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxuICAgIGZ1bmN0aW9uIFdpZGdldFNsaWRlckdVSSgpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjUsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgICB0ZXh0OiBcIlZcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDQwXTtcbiAgICAgICAgdGhpcy5zbGlkZXIgPSB0aGlzLmFkZFdpZGdldChcbiAgICAgICAgICAgIFwic2xpZGVyXCIsXG4gICAgICAgICAgICBcIlZcIixcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnByb3BlcnRpZXMudmFsdWUgPSB2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgIH1cblxuICAgIFdpZGdldFNsaWRlckdVSS50aXRsZSA9IFwiSW5uZXIgU2xpZGVyXCI7XG5cbiAgICBXaWRnZXRTbGlkZXJHVUkucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdpZGdldFNsaWRlckdVSS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9pbnRlcm5hbF9zbGlkZXJcIiwgV2lkZ2V0U2xpZGVyR1VJKTtcblxuICAgIC8vV2lkZ2V0IEggU0xJREVSXG4gICAgZnVuY3Rpb24gV2lkZ2V0SFNsaWRlcigpIHtcbiAgICAgICAgdGhpcy5zaXplID0gWzE2MCwgMjZdO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBjb2xvcjogXCIjN0FGXCIsIG1pbjogMCwgbWF4OiAxLCB2YWx1ZTogMC41IH07XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICB9XG5cbiAgICBXaWRnZXRIU2xpZGVyLnRpdGxlID0gXCJILlNsaWRlclwiO1xuICAgIFdpZGdldEhTbGlkZXIuZGVzYyA9IFwiTGluZWFyIHNsaWRlciBjb250cm9sbGVyXCI7XG5cbiAgICBXaWRnZXRIU2xpZGVyLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID1cbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnZhbHVlIC0gdGhpcy5wcm9wZXJ0aWVzLm1pbikgL1xuICAgICAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMubWF4IC0gdGhpcy5wcm9wZXJ0aWVzLm1pbik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2JvcmRlclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuICAgICAgICBjdHguZmlsbFJlY3QoMiwgMiwgdGhpcy5zaXplWzBdIC0gNCwgdGhpcy5zaXplWzFdIC0gNCk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMucHJvcGVydGllcy5jb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCg0LCA0LCAodGhpcy5zaXplWzBdIC0gOCkgKiB0aGlzLnZhbHVlLCB0aGlzLnNpemVbMV0gLSA4KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluICtcbiAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMubWF4IC0gdGhpcy5wcm9wZXJ0aWVzLm1pbikgKiB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IExpdGVHcmFwaC5jb2xvclRvU3RyaW5nKFtcbiAgICAgICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZVxuICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmNhbnZhc1kgLSB0aGlzLnBvc1sxXSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2xkbW91c2UgPSBbZS5jYW52YXNYIC0gdGhpcy5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdXTtcbiAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBXaWRnZXRIU2xpZGVyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9sZG1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IFtlLmNhbnZhc1ggLSB0aGlzLnBvc1swXSwgZS5jYW52YXNZIC0gdGhpcy5wb3NbMV1dO1xuXG4gICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIGRlbHRhID0gbVswXSAtIHRoaXMub2xkbW91c2VbMF07XG4gICAgICAgIHYgKz0gZGVsdGEgLyB0aGlzLnNpemVbMF07XG4gICAgICAgIGlmICh2ID4gMS4wKSB7XG4gICAgICAgICAgICB2ID0gMS4wO1xuICAgICAgICB9IGVsc2UgaWYgKHYgPCAwLjApIHtcbiAgICAgICAgICAgIHYgPSAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbHVlID0gdjtcblxuICAgICAgICB0aGlzLm9sZG1vdXNlID0gbTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm9sZG1vdXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBXaWRnZXRIU2xpZGVyLnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vdGhpcy5vbGRtb3VzZSA9IG51bGw7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L2hzbGlkZXJcIiwgV2lkZ2V0SFNsaWRlcik7XG5cbiAgICBmdW5jdGlvbiBXaWRnZXRQcm9ncmVzcygpIHtcbiAgICAgICAgdGhpcy5zaXplID0gWzE2MCwgMjZdO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IG1pbjogMCwgbWF4OiAxLCB2YWx1ZTogMCwgY29sb3I6IFwiI0FBRlwiIH07XG4gICAgfVxuXG4gICAgV2lkZ2V0UHJvZ3Jlc3MudGl0bGUgPSBcIlByb2dyZXNzXCI7XG4gICAgV2lkZ2V0UHJvZ3Jlc3MuZGVzYyA9IFwiU2hvd3MgZGF0YSBpbiBsaW5lYXIgcHJvZ3Jlc3NcIjtcblxuICAgIFdpZGdldFByb2dyZXNzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXSA9IHY7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2lkZ2V0UHJvZ3Jlc3MucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgLy9ib3JkZXJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG4gICAgICAgIHZhciB2ID1cbiAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMudmFsdWUgLSB0aGlzLnByb3BlcnRpZXMubWluKSAvXG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW4pO1xuICAgICAgICB2ID0gTWF0aC5taW4oMSwgdik7XG4gICAgICAgIHYgPSBNYXRoLm1heCgwLCB2KTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDIsIDIsICh0aGlzLnNpemVbMF0gLSA0KSAqIHYsIHRoaXMuc2l6ZVsxXSAtIDQpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9wcm9ncmVzc1wiLCBXaWRnZXRQcm9ncmVzcyk7XG5cbiAgICBmdW5jdGlvbiBXaWRnZXRUZXh0KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0cyhcIlwiLCAwKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgdmFsdWU6IFwiLi4uXCIsXG4gICAgICAgICAgICBmb250OiBcIkFyaWFsXCIsXG4gICAgICAgICAgICBmb250c2l6ZTogMTgsXG4gICAgICAgICAgICBjb2xvcjogXCIjQUFBXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsZWZ0XCIsXG4gICAgICAgICAgICBnbG93U2l6ZTogMCxcbiAgICAgICAgICAgIGRlY2ltYWxzOiAxXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgV2lkZ2V0VGV4dC50aXRsZSA9IFwiVGV4dFwiO1xuICAgIFdpZGdldFRleHQuZGVzYyA9IFwiU2hvd3MgdGhlIGlucHV0IHZhbHVlXCI7XG4gICAgV2lkZ2V0VGV4dC53aWRnZXRzID0gW1xuICAgICAgICB7IG5hbWU6IFwicmVzaXplXCIsIHRleHQ6IFwiUmVzaXplIGJveFwiLCB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgIHsgbmFtZTogXCJsZWRfdGV4dFwiLCB0ZXh0OiBcIkxFRFwiLCB0eXBlOiBcIm1pbmlidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwibm9ybWFsX3RleHRcIiwgdGV4dDogXCJOb3JtYWxcIiwgdHlwZTogXCJtaW5pYnV0dG9uXCIgfVxuICAgIF07XG5cbiAgICBXaWRnZXRUZXh0LnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vY3R4LmZpbGxTdHlsZT1cIiMwMDBcIjtcbiAgICAgICAgLy9jdHguZmlsbFJlY3QoMCwwLDEwMCw2MCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnByb3BlcnRpZXNbXCJjb2xvclwiXTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzW1wiZ2xvd1NpemVcIl0pIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMucHJvcGVydGllcy5jb2xvcjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5wcm9wZXJ0aWVzW1wiZ2xvd1NpemVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9udHNpemUgPSB0aGlzLnByb3BlcnRpZXNbXCJmb250c2l6ZVwiXTtcblxuICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy5wcm9wZXJ0aWVzW1wiYWxpZ25cIl07XG4gICAgICAgIGN0eC5mb250ID0gZm9udHNpemUudG9TdHJpbmcoKSArIFwicHggXCIgKyB0aGlzLnByb3BlcnRpZXNbXCJmb250XCJdO1xuICAgICAgICB0aGlzLnN0ciA9XG4gICAgICAgICAgICB0eXBlb2YgdiA9PSBcIm51bWJlclwiID8gdi50b0ZpeGVkKHRoaXMucHJvcGVydGllc1tcImRlY2ltYWxzXCJdKSA6IHY7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0ciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLnN0ci5zcGxpdChcIlxcXFxuXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJhbGlnblwiXSA9PSBcImxlZnRcIiA/IDE1IDogdGhpcy5zaXplWzBdIC0gMTUsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRzaXplICogLTAuMTUgKyBmb250c2l6ZSAqIChwYXJzZUludChpKSArIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgdGhpcy5sYXN0X2N0eCA9IGN0eDtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIH07XG5cbiAgICBXaWRnZXRUZXh0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0VGV4dC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0X2N0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zdHIuc3BsaXQoXCJcXFxcblwiKTtcbiAgICAgICAgdGhpcy5sYXN0X2N0eC5mb250ID1cbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcImZvbnRzaXplXCJdICsgXCJweCBcIiArIHRoaXMucHJvcGVydGllc1tcImZvbnRcIl07XG4gICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmxhc3RfY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aDtcbiAgICAgICAgICAgIGlmIChtYXggPCB3KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVbMF0gPSBtYXggKyAyMDtcbiAgICAgICAgdGhpcy5zaXplWzFdID0gNCArIGxpbmVzLmxlbmd0aCAqIHRoaXMucHJvcGVydGllc1tcImZvbnRzaXplXCJdO1xuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldFRleHQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RyID0gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZS50b0ZpeGVkKDMpIDogdmFsdWU7XG4gICAgICAgIC8vdGhpcy5yZXNpemUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L3RleHRcIiwgV2lkZ2V0VGV4dCk7XG5cbiAgICBmdW5jdGlvbiBXaWRnZXRQYW5lbCgpIHtcbiAgICAgICAgdGhpcy5zaXplID0gWzIwMCwgMTAwXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICAgICAgYmdjb2xvclRvcDogXCIjZjBmMGYwXCIsXG4gICAgICAgICAgICBiZ2NvbG9yQm90dG9tOiBcIiNlMGUwZTBcIixcbiAgICAgICAgICAgIHNoYWRvd1NpemU6IDIsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBXaWRnZXRQYW5lbC50aXRsZSA9IFwiUGFuZWxcIjtcbiAgICBXaWRnZXRQYW5lbC5kZXNjID0gXCJOb24gaW50ZXJhY3RpdmUgcGFuZWxcIjtcbiAgICBXaWRnZXRQYW5lbC53aWRnZXRzID0gW3sgbmFtZTogXCJ1cGRhdGVcIiwgdGV4dDogXCJVcGRhdGVcIiwgdHlwZTogXCJidXR0b25cIiB9XTtcblxuICAgIFdpZGdldFBhbmVsLnByb3RvdHlwZS5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJiZ2NvbG9yVG9wXCJdID09IFwiXCIgfHxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcImJnY29sb3JCb3R0b21cIl0gPT0gXCJcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubGluZWFyZ3JhZGllbnQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saW5lYXJncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCB0aGlzLnNpemVbMV0pO1xuICAgICAgICB0aGlzLmxpbmVhcmdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCB0aGlzLnByb3BlcnRpZXNbXCJiZ2NvbG9yVG9wXCJdKTtcbiAgICAgICAgdGhpcy5saW5lYXJncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgdGhpcy5wcm9wZXJ0aWVzW1wiYmdjb2xvckJvdHRvbVwiXSk7XG4gICAgfTtcblxuICAgIFdpZGdldFBhbmVsLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGluZWFyZ3JhZGllbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpbmVhcmdyYWRpZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzW1wiYm9yZGVyQ29sb3JcIl07XG4gICAgICAgIC8vY3R4LmZpbGxTdHlsZSA9IFwiI2ViZWJlYlwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5saW5lYXJncmFkaWVudDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzW1wic2hhZG93U2l6ZVwiXSkge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMucHJvcGVydGllc1tcInNoYWRvd1NpemVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnNpemVbMF0gLSAxLFxuICAgICAgICAgICAgdGhpcy5zaXplWzFdIC0gMSxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcInNoYWRvd1NpemVcIl1cbiAgICAgICAgKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L3BhbmVsXCIsIFdpZGdldFBhbmVsKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lcGFkSW5wdXQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJsZWZ0X3hfYXhpc1wiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImxlZnRfeV9heGlzXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiYnV0dG9uX3ByZXNzZWRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGdhbWVwYWRfaW5kZXg6IDAsIHRocmVzaG9sZDogMC4xIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2xlZnRfYXhpcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgdGhpcy5fcmlnaHRfYXhpcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzX2J1dHRvbnMgPSBuZXcgVWludDhBcnJheSgxNyk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudF9idXR0b25zID0gbmV3IFVpbnQ4QXJyYXkoMTcpO1xyXG4gICAgfVxyXG5cclxuICAgIEdhbWVwYWRJbnB1dC50aXRsZSA9IFwiR2FtZXBhZFwiO1xyXG4gICAgR2FtZXBhZElucHV0LmRlc2MgPSBcImdldHMgdGhlIGlucHV0IG9mIHRoZSBnYW1lcGFkXCI7XHJcblxyXG4gICAgR2FtZXBhZElucHV0LkNFTlRFUiA9IDA7XHJcbiAgICBHYW1lcGFkSW5wdXQuTEVGVCA9IDE7XHJcbiAgICBHYW1lcGFkSW5wdXQuUklHSFQgPSAyO1xyXG4gICAgR2FtZXBhZElucHV0LlVQID0gNDtcclxuICAgIEdhbWVwYWRJbnB1dC5ET1dOID0gODtcclxuXHJcbiAgICBHYW1lcGFkSW5wdXQuemVybyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICBHYW1lcGFkSW5wdXQuYnV0dG9ucyA9IFtcclxuICAgICAgICBcImFcIixcclxuICAgICAgICBcImJcIixcclxuICAgICAgICBcInhcIixcclxuICAgICAgICBcInlcIixcclxuICAgICAgICBcImxiXCIsXHJcbiAgICAgICAgXCJyYlwiLFxyXG4gICAgICAgIFwibHRcIixcclxuICAgICAgICBcInJ0XCIsXHJcbiAgICAgICAgXCJiYWNrXCIsXHJcbiAgICAgICAgXCJzdGFydFwiLFxyXG4gICAgICAgIFwibHNcIixcclxuICAgICAgICBcInJzXCIsXHJcbiAgICAgICAgXCJob21lXCJcclxuICAgIF07XHJcblxyXG4gICAgR2FtZXBhZElucHV0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2dldCBnYW1lcGFkXHJcbiAgICAgICAgdmFyIGdhbWVwYWQgPSB0aGlzLmdldEdhbWVwYWQoKTtcclxuICAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5wcm9wZXJ0aWVzLnRocmVzaG9sZCB8fCAwLjA7XHJcblxyXG4gICAgICAgIGlmIChnYW1lcGFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZnRfYXhpc1swXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcImx4XCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJseFwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVmdF9heGlzWzFdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wibHlcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcImx5XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9yaWdodF9heGlzWzBdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wicnhcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcInJ4XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9yaWdodF9heGlzWzFdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wicnlcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcInJ5XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2Vyc1swXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcImx0cmlnZ2VyXCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJsdHJpZ2dlclwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcnNbMV0gPVxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FtZXBhZC54Ym94LmF4ZXNbXCJydHJpZ2dlclwiXSkgPiB0aHJlc2hvbGRcclxuICAgICAgICAgICAgICAgICAgICA/IGdhbWVwYWQueGJveC5heGVzW1wicnRyaWdnZXJcIl1cclxuICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQubGlua3MgfHwgIW91dHB1dC5saW5rcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX2xlZnRfYXhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX3JpZ2h0X2F4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRfeF9heGlzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fbGVmdF9heGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0X3lfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX2xlZnRfYXhpc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfeF9heGlzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fcmlnaHRfYXhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfeV9heGlzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fcmlnaHRfYXhpc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJpZ2dlcl9sZWZ0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fdHJpZ2dlcnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRyaWdnZXJfcmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLl90cmlnZ2Vyc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYV9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImFcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYl9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImJcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwieF9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInhcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwieV9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInlcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGJfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJsYlwiXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyYl9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInJiXCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxzX2J1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5idXR0b25zW1wibHNcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnNfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJyc1wiXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoYXRfbGVmdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5oYXRtYXAgJiBHYW1lcGFkSW5wdXQuTEVGVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X3JpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmhhdG1hcCAmIEdhbWVwYWRJbnB1dC5SSUdIVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X3VwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmhhdG1hcCAmIEdhbWVwYWRJbnB1dC5VUDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X2Rvd25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guaGF0bWFwICYgR2FtZXBhZElucHV0LkRPV047XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhhdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5oYXRtYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0X2J1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5idXR0b25zW1wic3RhcnRcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmFja19idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImJhY2tcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYnV0dG9uX3ByZXNzZWRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCB0aGlzLl9jdXJyZW50X2J1dHRvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsralxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50X2J1dHRvbnNbal0gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX3ByZXZpb3VzX2J1dHRvbnNbal1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lcGFkSW5wdXQuYnV0dG9uc1tqXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIG5vIGdhbWVwYWQgaXMgY29ubmVjdGVkLCBvdXRwdXQgMFxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJ1dHRvbl9wcmVzc2VkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IEdhbWVwYWRJbnB1dC56ZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHRHYW1lcGFkSW5wdXQubWFwcGluZyA9IHthOjAsYjoxLHg6Mix5OjMsbGI6NCxyYjo1LGx0OjYscnQ6NyxiYWNrOjgsc3RhcnQ6OSxsczoxMCxyczoxMSB9O1xyXG5cdEdhbWVwYWRJbnB1dC5tYXBwaW5nX2FycmF5ID0gW1wiYVwiLFwiYlwiLFwieFwiLFwieVwiLFwibGJcIixcInJiXCIsXCJsdFwiLFwicnRcIixcImJhY2tcIixcInN0YXJ0XCIsXCJsc1wiLFwicnNcIl07XHJcblxyXG4gICAgR2FtZXBhZElucHV0LnByb3RvdHlwZS5nZXRHYW1lcGFkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGdldEdhbWVwYWRzID1cclxuICAgICAgICAgICAgbmF2aWdhdG9yLmdldEdhbWVwYWRzIHx8XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcyB8fFxyXG4gICAgICAgICAgICBuYXZpZ2F0b3IubW96R2V0R2FtZXBhZHM7XHJcbiAgICAgICAgaWYgKCFnZXRHYW1lcGFkcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdhbWVwYWRzID0gZ2V0R2FtZXBhZHMuY2FsbChuYXZpZ2F0b3IpO1xyXG4gICAgICAgIHZhciBnYW1lcGFkID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNfYnV0dG9ucy5zZXQodGhpcy5fY3VycmVudF9idXR0b25zKTtcclxuXHJcbiAgICAgICAgLy9waWNrIHRoZSBmaXJzdCBjb25uZWN0ZWRcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wcm9wZXJ0aWVzLmdhbWVwYWRfaW5kZXg7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFnYW1lcGFkc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2FtZXBhZCA9IGdhbWVwYWRzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy94Ym94IGNvbnRyb2xsZXIgbWFwcGluZ1xyXG4gICAgICAgICAgICB2YXIgeGJveCA9IHRoaXMueGJveF9tYXBwaW5nO1xyXG4gICAgICAgICAgICBpZiAoIXhib3gpIHtcclxuICAgICAgICAgICAgICAgIHhib3ggPSB0aGlzLnhib3hfbWFwcGluZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBheGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBoYXQ6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGF0bWFwOiBHYW1lcGFkSW5wdXQuQ0VOVEVSXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4Ym94LmF4ZXNbXCJseFwiXSA9IGdhbWVwYWQuYXhlc1swXTtcclxuICAgICAgICAgICAgeGJveC5heGVzW1wibHlcIl0gPSBnYW1lcGFkLmF4ZXNbMV07XHJcbiAgICAgICAgICAgIHhib3guYXhlc1tcInJ4XCJdID0gZ2FtZXBhZC5heGVzWzJdO1xyXG4gICAgICAgICAgICB4Ym94LmF4ZXNbXCJyeVwiXSA9IGdhbWVwYWQuYXhlc1szXTtcclxuICAgICAgICAgICAgeGJveC5heGVzW1wibHRyaWdnZXJcIl0gPSBnYW1lcGFkLmJ1dHRvbnNbNl0udmFsdWU7XHJcbiAgICAgICAgICAgIHhib3guYXhlc1tcInJ0cmlnZ2VyXCJdID0gZ2FtZXBhZC5idXR0b25zWzddLnZhbHVlO1xyXG4gICAgICAgICAgICB4Ym94LmhhdCA9IFwiXCI7XHJcbiAgICAgICAgICAgIHhib3guaGF0bWFwID0gR2FtZXBhZElucHV0LkNFTlRFUjtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2FtZXBhZC5idXR0b25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50X2J1dHRvbnNbal0gPSBnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZDtcclxuXHJcblx0XHRcdFx0aWYoaiA8IDEyKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHhib3guYnV0dG9uc1sgR2FtZXBhZElucHV0Lm1hcHBpbmdfYXJyYXlbal0gXSA9IGdhbWVwYWQuYnV0dG9uc1tqXS5wcmVzc2VkO1xyXG5cdFx0XHRcdFx0aWYoZ2FtZXBhZC5idXR0b25zW2pdLndhc19wcmVzc2VkKVxyXG5cdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoIEdhbWVwYWRJbnB1dC5tYXBwaW5nX2FycmF5W2pdICsgXCJfYnV0dG9uX2V2ZW50XCIgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSAvL21hcHBpbmcgb2YgWEJPWFxyXG5cdFx0XHRcdFx0c3dpdGNoICggaiApIC8vSSB1c2UgYSBzd2l0Y2ggdG8gZW5zdXJlIHRoYXQgYSBwbGF5ZXIgd2l0aCBhbm90aGVyIGdhbWVwYWQgY291bGQgcGxheVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRjYXNlIDEyOlxyXG5cdFx0XHRcdFx0XHRcdGlmIChnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXQgKz0gXCJ1cFwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXRtYXAgfD0gR2FtZXBhZElucHV0LlVQO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAxMzpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZ2FtZXBhZC5idXR0b25zW2pdLnByZXNzZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHhib3guaGF0ICs9IFwiZG93blwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXRtYXAgfD0gR2FtZXBhZElucHV0LkRPV047XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE0OlxyXG5cdFx0XHRcdFx0XHRcdGlmIChnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXQgKz0gXCJsZWZ0XCI7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdG1hcCB8PSBHYW1lcGFkSW5wdXQuTEVGVDtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgMTU6XHJcblx0XHRcdFx0XHRcdFx0aWYgKGdhbWVwYWQuYnV0dG9uc1tqXS5wcmVzc2VkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdCArPSBcInJpZ2h0XCI7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdG1hcCB8PSBHYW1lcGFkSW5wdXQuUklHSFQ7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE2OlxyXG5cdFx0XHRcdFx0XHRcdHhib3guYnV0dG9uc1tcImhvbWVcIl0gPSBnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZDtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnYW1lcGFkLnhib3ggPSB4Ym94O1xyXG4gICAgICAgICAgICByZXR1cm4gZ2FtZXBhZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3JlbmRlciBnYW1lcGFkIHN0YXRlP1xyXG4gICAgICAgIHZhciBsYSA9IHRoaXMuX2xlZnRfYXhpcztcclxuICAgICAgICB2YXIgcmEgPSB0aGlzLl9yaWdodF9heGlzO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzg4QVwiO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KFxyXG4gICAgICAgICAgICAobGFbMF0gKyAxKSAqIDAuNSAqIHRoaXMuc2l6ZVswXSAtIDQsXHJcbiAgICAgICAgICAgIChsYVsxXSArIDEpICogMC41ICogdGhpcy5zaXplWzFdIC0gNCxcclxuICAgICAgICAgICAgOCxcclxuICAgICAgICAgICAgOFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjOEE4XCI7XHJcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoXHJcbiAgICAgICAgICAgIChyYVswXSArIDEpICogMC41ICogdGhpcy5zaXplWzBdIC0gNCxcclxuICAgICAgICAgICAgKHJhWzFdICsgMSkgKiAwLjUgKiB0aGlzLnNpemVbMV0gLSA0LFxyXG4gICAgICAgICAgICA4LFxyXG4gICAgICAgICAgICA4XHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuc2l6ZVsxXSAvIHRoaXMuX2N1cnJlbnRfYnV0dG9ucy5sZW5ndGg7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FFQlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY3VycmVudF9idXR0b25zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50X2J1dHRvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCBoICogaSwgNiwgaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wibGVmdF9heGlzXCIsIFwidmVjMlwiXSxcclxuICAgICAgICAgICAgW1wicmlnaHRfYXhpc1wiLCBcInZlYzJcIl0sXHJcbiAgICAgICAgICAgIFtcImxlZnRfeF9heGlzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJsZWZ0X3lfYXhpc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmlnaHRfeF9heGlzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJyaWdodF95X2F4aXNcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInRyaWdnZXJfbGVmdFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1widHJpZ2dlcl9yaWdodFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYV9idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImJfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ4X2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wieV9idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImxiX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmJfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJsc19idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJzX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wic3RhcnRfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJiYWNrX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYV9idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcImJfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJ4X2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wieV9idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcImxiX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wicmJfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJsc19idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcInJzX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wic3RhcnRfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJiYWNrX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wiaGF0X2xlZnRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImhhdF9yaWdodFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiaGF0X3VwXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJoYXRfZG93blwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiaGF0XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJidXR0b25fcHJlc3NlZFwiLCBMaXRlR3JhcGguRVZFTlRdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJpbnB1dC9nYW1lcGFkXCIsIEdhbWVwYWRJbnB1dCk7XHJcbn0pKHRoaXMpO1xyXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cclxuICAgIC8vQ29udmVydGVyXHJcbiAgICBmdW5jdGlvbiBDb252ZXJ0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiXCIpO1xyXG5cdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIENvbnZlcnRlci50aXRsZSA9IFwiQ29udmVydGVyXCI7XHJcbiAgICBDb252ZXJ0ZXIuZGVzYyA9IFwidHlwZSBBIHRvIHR5cGUgQlwiO1xyXG5cclxuICAgIENvbnZlcnRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIW91dHB1dC5saW5rcyB8fCAhb3V0cHV0LmxpbmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdi5sZW5ndGggPyB2WzBdIDogcGFyc2VGbG9hdCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZlYzJcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVjM1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWM0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG91dHB1dC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVjMlwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWMzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZlYzRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgdi5sZW5ndGggJiYgaiA8IHJlc3VsdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbal0gPSB2W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gcGFyc2VGbG9hdCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBDb252ZXJ0ZXIucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcIm51bWJlclwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1widmVjMlwiLCBcInZlYzJcIl0sXHJcbiAgICAgICAgICAgIFtcInZlYzNcIiwgXCJ2ZWMzXCJdLFxyXG4gICAgICAgICAgICBbXCJ2ZWM0XCIsIFwidmVjNFwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9jb252ZXJ0ZXJcIiwgQ29udmVydGVyKTtcclxuXHJcbiAgICAvL0J5cGFzc1xyXG4gICAgZnVuY3Rpb24gQnlwYXNzKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBCeXBhc3MudGl0bGUgPSBcIkJ5cGFzc1wiO1xyXG4gICAgQnlwYXNzLmRlc2MgPSBcInJlbW92ZXMgdGhlIHR5cGVcIjtcclxuXHJcbiAgICBCeXBhc3MucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvYnlwYXNzXCIsIEJ5cGFzcyk7XHJcblxyXG4gICAgZnVuY3Rpb24gVG9OdW1iZXIoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIFRvTnVtYmVyLnRpdGxlID0gXCJ0byBOdW1iZXJcIjtcclxuICAgIFRvTnVtYmVyLmRlc2MgPSBcIkNhc3QgdG8gbnVtYmVyXCI7XHJcblxyXG4gICAgVG9OdW1iZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIE51bWJlcih2KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC90b19udW1iZXJcIiwgVG9OdW1iZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGhSYW5nZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIiwgeyBsb2NrZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIiwgeyBsb2NrZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJjbGFtcGVkXCIsIFwibnVtYmVyXCIsIHsgbG9ja2VkOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiaW5cIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImluX21pblwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiaW5fbWF4XCIsIDEpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJvdXRfbWluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJvdXRfbWF4XCIsIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnNpemUgPSBbMTIwLCA1MF07XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFJhbmdlLnRpdGxlID0gXCJSYW5nZVwiO1xyXG4gICAgTWF0aFJhbmdlLmRlc2MgPSBcIkNvbnZlcnQgYSBudW1iZXIgZnJvbSBvbmUgcmFuZ2UgdG8gYW5vdGhlclwiO1xyXG5cclxuICAgIE1hdGhSYW5nZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9sYXN0X3YgfHwgMCkudG9GaXhlZCgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhSYW5nZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tpbnB1dC5uYW1lXSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB2ID0gdGhpcy5wcm9wZXJ0aWVzW1wiaW5cIl07XHJcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsIHx8IHYuY29uc3RydWN0b3IgIT09IE51bWJlcikge1xyXG4gICAgICAgICAgICB2ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbl9taW4gPSB0aGlzLnByb3BlcnRpZXMuaW5fbWluO1xyXG4gICAgICAgIHZhciBpbl9tYXggPSB0aGlzLnByb3BlcnRpZXMuaW5fbWF4O1xyXG4gICAgICAgIHZhciBvdXRfbWluID0gdGhpcy5wcm9wZXJ0aWVzLm91dF9taW47XHJcbiAgICAgICAgdmFyIG91dF9tYXggPSB0aGlzLnByb3BlcnRpZXMub3V0X21heDtcclxuXHRcdC8qXHJcblx0XHRpZiggaW5fbWluID4gaW5fbWF4IClcclxuXHRcdHtcclxuXHRcdFx0aW5fbWluID0gaW5fbWF4O1xyXG5cdFx0XHRpbl9tYXggPSB0aGlzLnByb3BlcnRpZXMuaW5fbWluO1xyXG5cdFx0fVxyXG5cdFx0aWYoIG91dF9taW4gPiBvdXRfbWF4IClcclxuXHRcdHtcclxuXHRcdFx0b3V0X21pbiA9IG91dF9tYXg7XHJcblx0XHRcdG91dF9tYXggPSB0aGlzLnByb3BlcnRpZXMub3V0X21pbjtcclxuXHRcdH1cclxuXHRcdCovXHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RfdiA9ICgodiAtIGluX21pbikgLyAoaW5fbWF4IC0gaW5fbWluKSkgKiAob3V0X21heCAtIG91dF9taW4pICsgb3V0X21pbjtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fbGFzdF92KTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgTWF0aC5jbGFtcCggdGhpcy5fbGFzdF92LCBvdXRfbWluLCBvdXRfbWF4ICkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoUmFuZ2UucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICAvL3Nob3cgdGhlIGN1cnJlbnQgdmFsdWVcclxuICAgICAgICBpZiAodGhpcy5fbGFzdF92KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9IHRoaXMuX2xhc3Rfdi50b0ZpeGVkKDMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9IFwiP1wiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTWF0aFJhbmdlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcImluX21pblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiaW5fbWF4XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJvdXRfbWluXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJvdXRfbWF4XCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3JhbmdlXCIsIE1hdGhSYW5nZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aFJhbmQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtYXhcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFJhbmQudGl0bGUgPSBcIlJhbmRcIjtcclxuICAgIE1hdGhSYW5kLmRlc2MgPSBcIlJhbmRvbSBudW1iZXJcIjtcclxuXHJcbiAgICBNYXRoUmFuZC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tpbnB1dC5uYW1lXSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtaW4gPSB0aGlzLnByb3BlcnRpZXMubWluO1xyXG4gICAgICAgIHZhciBtYXggPSB0aGlzLnByb3BlcnRpZXMubWF4O1xyXG4gICAgICAgIHRoaXMuX2xhc3RfdiA9IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fbGFzdF92KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aFJhbmQucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICAvL3Nob3cgdGhlIGN1cnJlbnQgdmFsdWVcclxuICAgICAgICB0aGlzLm91dHB1dHNbMF0ubGFiZWwgPSAodGhpcy5fbGFzdF92IHx8IDApLnRvRml4ZWQoMyk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhSYW5kLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wibWluXCIsIFwibnVtYmVyXCJdLCBbXCJtYXhcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvcmFuZFwiLCBNYXRoUmFuZCk7XHJcblxyXG4gICAgLy9iYXNpYyBjb250aW51b3VzIG5vaXNlXHJcbiAgICBmdW5jdGlvbiBNYXRoTm9pc2UoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtaW5cIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1heFwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwic21vb3RoXCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzZWVkXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJvY3RhdmVzXCIsIDEpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJwZXJzaXN0ZW5jZVwiLCAwLjgpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzcGVlZFwiLCAxKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbOTAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoTm9pc2UudGl0bGUgPSBcIk5vaXNlXCI7XHJcbiAgICBNYXRoTm9pc2UuZGVzYyA9IFwiUmFuZG9tIG51bWJlciB3aXRoIHRlbXBvcmFsIGNvbnRpbnVpdHlcIjtcclxuICAgIE1hdGhOb2lzZS5kYXRhID0gbnVsbDtcclxuXHJcbiAgICBNYXRoTm9pc2UuZ2V0VmFsdWUgPSBmdW5jdGlvbihmLCBzbW9vdGgpIHtcclxuICAgICAgICBpZiAoIU1hdGhOb2lzZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIE1hdGhOb2lzZS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxMDI0KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoTm9pc2UuZGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgTWF0aE5vaXNlLmRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGYgPSBmICUgMTAyNDtcclxuICAgICAgICBpZiAoZiA8IDApIHtcclxuICAgICAgICAgICAgZiArPSAxMDI0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZl9taW4gPSBNYXRoLmZsb29yKGYpO1xyXG4gICAgICAgIHZhciBmID0gZiAtIGZfbWluO1xyXG4gICAgICAgIHZhciByMSA9IE1hdGhOb2lzZS5kYXRhW2ZfbWluXTtcclxuICAgICAgICB2YXIgcjIgPSBNYXRoTm9pc2UuZGF0YVtmX21pbiA9PSAxMDIzID8gMCA6IGZfbWluICsgMV07XHJcbiAgICAgICAgaWYgKHNtb290aCkge1xyXG4gICAgICAgICAgICBmID0gZiAqIGYgKiBmICogKGYgKiAoZiAqIDYuMCAtIDE1LjApICsgMTAuMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByMSAqICgxIC0gZikgKyByMiAqIGY7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhOb2lzZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldElucHV0RGF0YSgwKSB8fCAwO1xyXG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSB0aGlzLnByb3BlcnRpZXMub2N0YXZlcyB8fCAxO1xyXG5cdFx0dmFyIHIgPSAwO1xyXG5cdFx0dmFyIGFtcCA9IDE7XHJcblx0XHR2YXIgc2VlZCA9IHRoaXMucHJvcGVydGllcy5zZWVkIHx8IDA7XHJcblx0XHRmICs9IHNlZWQ7XHJcblx0XHR2YXIgc3BlZWQgPSB0aGlzLnByb3BlcnRpZXMuc3BlZWQgfHwgMTtcclxuXHRcdHZhciB0b3RhbF9hbXAgPSAwO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0ciArPSBNYXRoTm9pc2UuZ2V0VmFsdWUoZiAqICgxK2kpICogc3BlZWQsIHRoaXMucHJvcGVydGllcy5zbW9vdGgpICogYW1wO1xyXG5cdFx0XHR0b3RhbF9hbXAgKz0gYW1wO1xyXG5cdFx0XHRhbXAgKj0gdGhpcy5wcm9wZXJ0aWVzLnBlcnNpc3RlbmNlO1xyXG5cdFx0XHRpZihhbXAgPCAwLjAwMSlcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdHIgLz0gdG90YWxfYW1wO1xyXG4gICAgICAgIHZhciBtaW4gPSB0aGlzLnByb3BlcnRpZXMubWluO1xyXG4gICAgICAgIHZhciBtYXggPSB0aGlzLnByb3BlcnRpZXMubWF4O1xyXG4gICAgICAgIHRoaXMuX2xhc3RfdiA9IHIgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fbGFzdF92KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aE5vaXNlLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgLy9zaG93IHRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgICAgdGhpcy5vdXRwdXRzWzBdLmxhYmVsID0gKHRoaXMuX2xhc3RfdiB8fCAwKS50b0ZpeGVkKDMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvbm9pc2VcIiwgTWF0aE5vaXNlKTtcclxuXHJcbiAgICAvL2dlbmVyYXRlcyBzcGlrZXMgZXZlcnkgcmFuZG9tIHRpbWVcclxuICAgIGZ1bmN0aW9uIE1hdGhTcGlrZXMoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1pbl90aW1lXCIsIDEpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtYXhfdGltZVwiLCAyKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiZHVyYXRpb25cIiwgMC4yKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbOTAsIDMwXTtcclxuICAgICAgICB0aGlzLl9yZW1haW5pbmdfdGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fYmxpbmtfdGltZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFNwaWtlcy50aXRsZSA9IFwiU3Bpa2VzXCI7XHJcbiAgICBNYXRoU3Bpa2VzLmRlc2MgPSBcInNwaWtlIGV2ZXJ5IHJhbmRvbSB0aW1lXCI7XHJcblxyXG4gICAgTWF0aFNwaWtlcy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGR0ID0gdGhpcy5ncmFwaC5lbGFwc2VkX3RpbWU7IC8vaW4gc2Vjc1xyXG5cclxuICAgICAgICB0aGlzLl9yZW1haW5pbmdfdGltZSAtPSBkdDtcclxuICAgICAgICB0aGlzLl9ibGlua190aW1lIC09IGR0O1xyXG5cclxuICAgICAgICB2YXIgdiA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JsaW5rX3RpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gdGhpcy5fYmxpbmtfdGltZSAvIHRoaXMucHJvcGVydGllcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdiA9IDEgLyAoTWF0aC5wb3coZiAqIDggLSA0LCA0KSArIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZ190aW1lIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1haW5pbmdfdGltZSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICpcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heF90aW1lIC0gdGhpcy5wcm9wZXJ0aWVzLm1pbl90aW1lKSArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3RpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2JsaW5rX3RpbWUgPSB0aGlzLnByb3BlcnRpZXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNGRkZcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjMDAwXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3NwaWtlc1wiLCBNYXRoU3Bpa2VzKTtcclxuXHJcbiAgICAvL01hdGggY2xhbXBcclxuICAgIGZ1bmN0aW9uIE1hdGhDbGFtcCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1pblwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWF4XCIsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhDbGFtcC50aXRsZSA9IFwiQ2xhbXBcIjtcclxuICAgIE1hdGhDbGFtcC5kZXNjID0gXCJDbGFtcCBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFwiO1xyXG4gICAgLy9NYXRoQ2xhbXAuZmlsdGVyID0gXCJzaGFkZXJcIjtcclxuXHJcbiAgICBNYXRoQ2xhbXAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHYgPSBNYXRoLm1heCh0aGlzLnByb3BlcnRpZXMubWluLCB2KTtcclxuICAgICAgICB2ID0gTWF0aC5taW4odGhpcy5wcm9wZXJ0aWVzLm1heCwgdik7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoQ2xhbXAucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbihsYW5nKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMCkpIHtcclxuICAgICAgICAgICAgY29kZSArPVxyXG4gICAgICAgICAgICAgICAgXCJjbGFtcCh7ezB9fSxcIiArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluICtcclxuICAgICAgICAgICAgICAgIFwiLFwiICtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXggK1xyXG4gICAgICAgICAgICAgICAgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvY2xhbXBcIiwgTWF0aENsYW1wKTtcclxuXHJcbiAgICAvL01hdGggQUJTXHJcbiAgICBmdW5jdGlvbiBNYXRoTGVycCgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGY6IDAuNSB9O1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoTGVycC50aXRsZSA9IFwiTGVycFwiO1xyXG4gICAgTWF0aExlcnAuZGVzYyA9IFwiTGluZWFyIEludGVycG9sYXRpb25cIjtcclxuXHJcbiAgICBNYXRoTGVycC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYxID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYxID09IG51bGwpIHtcclxuICAgICAgICAgICAgdjEgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdjIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAodjIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2MiA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZiA9IHRoaXMucHJvcGVydGllcy5mO1xyXG5cclxuICAgICAgICB2YXIgX2YgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICBpZiAoX2YgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBmID0gX2Y7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdjEgKiAoMSAtIGYpICsgdjIgKiBmKTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aExlcnAucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJmXCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2xlcnBcIiwgTWF0aExlcnApO1xyXG5cclxuICAgIC8vTWF0aCBBQlNcclxuICAgIGZ1bmN0aW9uIE1hdGhBYnMoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhBYnMudGl0bGUgPSBcIkFic1wiO1xyXG4gICAgTWF0aEFicy5kZXNjID0gXCJBYnNvbHV0ZVwiO1xyXG5cclxuICAgIE1hdGhBYnMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBNYXRoLmFicyh2KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9hYnNcIiwgTWF0aEFicyk7XHJcblxyXG4gICAgLy9NYXRoIEZsb29yXHJcbiAgICBmdW5jdGlvbiBNYXRoRmxvb3IoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhGbG9vci50aXRsZSA9IFwiRmxvb3JcIjtcclxuICAgIE1hdGhGbG9vci5kZXNjID0gXCJGbG9vciBudW1iZXIgdG8gcmVtb3ZlIGZyYWN0aW9uYWwgcGFydFwiO1xyXG5cclxuICAgIE1hdGhGbG9vci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIE1hdGguZmxvb3IodikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvZmxvb3JcIiwgTWF0aEZsb29yKTtcclxuXHJcbiAgICAvL01hdGggZnJhY1xyXG4gICAgZnVuY3Rpb24gTWF0aEZyYWMoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhGcmFjLnRpdGxlID0gXCJGcmFjXCI7XHJcbiAgICBNYXRoRnJhYy5kZXNjID0gXCJSZXR1cm5zIGZyYWN0aW9uYWwgcGFydFwiO1xyXG5cclxuICAgIE1hdGhGcmFjLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdiAlIDEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvZnJhY1wiLCBNYXRoRnJhYyk7XHJcblxyXG4gICAgLy9NYXRoIEZsb29yXHJcbiAgICBmdW5jdGlvbiBNYXRoU21vb3RoU3RlcCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBBOiAwLCBCOiAxIH07XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFNtb290aFN0ZXAudGl0bGUgPSBcIlNtb290aHN0ZXBcIjtcclxuICAgIE1hdGhTbW9vdGhTdGVwLmRlc2MgPSBcIlNtb290aHN0ZXBcIjtcclxuXHJcbiAgICBNYXRoU21vb3RoU3RlcC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlZGdlMCA9IHRoaXMucHJvcGVydGllcy5BO1xyXG4gICAgICAgIHZhciBlZGdlMSA9IHRoaXMucHJvcGVydGllcy5CO1xyXG5cclxuICAgICAgICAvLyBTY2FsZSwgYmlhcyBhbmQgc2F0dXJhdGUgeCB0byAwLi4xIHJhbmdlXHJcbiAgICAgICAgdiA9IE1hdGguY2xhbXAoKHYgLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKTtcclxuICAgICAgICAvLyBFdmFsdWF0ZSBwb2x5bm9taWFsXHJcbiAgICAgICAgdiA9IHYgKiB2ICogKDMgLSAyICogdik7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3Ntb290aHN0ZXBcIiwgTWF0aFNtb290aFN0ZXApO1xyXG5cclxuICAgIC8vTWF0aCBzY2FsZVxyXG4gICAgZnVuY3Rpb24gTWF0aFNjYWxlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiLCB7IGxhYmVsOiBcIlwiIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIsIHsgbGFiZWw6IFwiXCIgfSk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZhY3RvclwiLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoU2NhbGUudGl0bGUgPSBcIlNjYWxlXCI7XHJcbiAgICBNYXRoU2NhbGUuZGVzYyA9IFwidiAqIGZhY3RvclwiO1xyXG5cclxuICAgIE1hdGhTY2FsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZhbHVlICogdGhpcy5wcm9wZXJ0aWVzLmZhY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvc2NhbGVcIiwgTWF0aFNjYWxlKTtcclxuXHJcblx0Ly9HYXRlXHJcblx0ZnVuY3Rpb24gR2F0ZSgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ2XCIsXCJib29sZWFuXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIpO1xyXG5cdH1cclxuXHJcblx0R2F0ZS50aXRsZSA9IFwiR2F0ZVwiO1xyXG5cdEdhdGUuZGVzYyA9IFwiaWYgdiBpcyB0cnVlLCB0aGVuIG91dHB1dHMgQSwgb3RoZXJ3aXNlIEJcIjtcclxuXHJcblx0R2F0ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuZ2V0SW5wdXREYXRhKCB2ID8gMSA6IDIgKSk7XHJcblx0fTtcclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2dhdGVcIiwgR2F0ZSk7XHJcblxyXG5cclxuICAgIC8vTWF0aCBBdmVyYWdlXHJcbiAgICBmdW5jdGlvbiBNYXRoQXZlcmFnZUZpbHRlcigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInNhbXBsZXNcIiwgMTApO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMTApO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhBdmVyYWdlRmlsdGVyLnRpdGxlID0gXCJBdmVyYWdlXCI7XHJcbiAgICBNYXRoQXZlcmFnZUZpbHRlci5kZXNjID0gXCJBdmVyYWdlIEZpbHRlclwiO1xyXG5cclxuICAgIE1hdGhBdmVyYWdlRmlsdGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdiA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbnVtX3NhbXBsZXMgPSB0aGlzLl92YWx1ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICB0aGlzLl92YWx1ZXNbdGhpcy5fY3VycmVudCAlIG51bV9zYW1wbGVzXSA9IHY7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCArPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50ID4gbnVtX3NhbXBsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXZyID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9zYW1wbGVzOyArK2kpIHtcclxuICAgICAgICAgICAgYXZyICs9IHRoaXMuX3ZhbHVlc1tpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBhdnIgLyBudW1fc2FtcGxlcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhBdmVyYWdlRmlsdGVyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcy5zYW1wbGVzID0gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuX3ZhbHVlcztcclxuXHJcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnByb3BlcnRpZXMuc2FtcGxlcyk7XHJcbiAgICAgICAgaWYgKG9sZC5sZW5ndGggPD0gdGhpcy5fdmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuc2V0KG9sZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnNldChvbGQuc3ViYXJyYXkoMCwgdGhpcy5fdmFsdWVzLmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2F2ZXJhZ2VcIiwgTWF0aEF2ZXJhZ2VGaWx0ZXIpO1xyXG5cclxuICAgIC8vTWF0aFxyXG4gICAgZnVuY3Rpb24gTWF0aFRlbmRUbygpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZhY3RvclwiLCAwLjEpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoVGVuZFRvLnRpdGxlID0gXCJUZW5kVG9cIjtcclxuICAgIE1hdGhUZW5kVG8uZGVzYyA9IFwibW92ZXMgdGhlIG91dHB1dCB2YWx1ZSBhbHdheXMgY2xvc2VyIHRvIHRoZSBpbnB1dFwiO1xyXG5cclxuICAgIE1hdGhUZW5kVG8ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLnByb3BlcnRpZXMuZmFjdG9yO1xyXG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3ZhbHVlICogKDEgLSBmKSArIHYgKiBmO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvdGVuZFRvXCIsIE1hdGhUZW5kVG8pO1xyXG5cclxuICAgIC8vTWF0aCBvcGVyYXRpb25cclxuICAgIGZ1bmN0aW9uIE1hdGhPcGVyYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJudW1iZXIsYXJyYXksb2JqZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiPVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQVwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQlwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiT1BcIiwgXCIrXCIsIFwiZW51bVwiLCB7IHZhbHVlczogTWF0aE9wZXJhdGlvbi52YWx1ZXMgfSk7XHJcblx0XHR0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBICsgQjsgfTtcclxuXHRcdHRoaXMuX3Jlc3VsdCA9IFtdOyAvL29ubHkgdXNlZCBmb3IgYXJyYXlzXHJcbiAgICB9XHJcblxyXG4gICAgTWF0aE9wZXJhdGlvbi52YWx1ZXMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCIsIFwiJVwiLCBcIl5cIiwgXCJtYXhcIiwgXCJtaW5cIl07XHJcblxyXG5cdE1hdGhPcGVyYXRpb24udGl0bGUgPSBcIk9wZXJhdGlvblwiO1xyXG4gICAgTWF0aE9wZXJhdGlvbi5kZXNjID0gXCJFYXN5IG1hdGggb3BlcmF0b3JzXCI7XHJcbiAgICBNYXRoT3BlcmF0aW9uW1wiQE9QXCJdID0ge1xyXG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxyXG4gICAgICAgIHRpdGxlOiBcIm9wZXJhdGlvblwiLFxyXG4gICAgICAgIHZhbHVlczogTWF0aE9wZXJhdGlvbi52YWx1ZXNcclxuICAgIH07XHJcbiAgICBNYXRoT3BlcmF0aW9uLnNpemUgPSBbMTAwLCA2MF07XHJcblxyXG4gICAgTWF0aE9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5PUCA9PSBcIm1heFwiIHx8IHRoaXMucHJvcGVydGllcy5PUCA9PSBcIm1pblwiKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLk9QICsgXCIoQSxCKVwiO1xyXG4gICAgICAgIHJldHVybiBcIkEgXCIgKyB0aGlzLnByb3BlcnRpZXMuT1AgKyBcIiBCXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXSA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpXHJcblx0e1xyXG5cdFx0aWYgKG5hbWUgIT0gXCJPUFwiKVxyXG5cdFx0XHRyZXR1cm47XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BlcnRpZXMuT1ApIHtcclxuICAgICAgICAgICAgY2FzZSBcIitcIjogdGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSArIEI7IH07IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiLVwiOiB0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBIC0gQjsgfTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJYXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6IHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIEEgKiBCOyB9OyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIi9cIjogdGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSAvIEI7IH07IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiJVwiOiB0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBICUgQjsgfTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJeXCI6IHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIE1hdGgucG93KEEsIEIpOyB9OyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1heFwiOiB0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSxCKSB7IHJldHVybiBNYXRoLm1heChBLCBCKTsgfTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtaW5cIjogdGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gTWF0aC5taW4oQSwgQik7IH07IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiBcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJVbmtub3duIG9wZXJhdGlvbjogXCIgKyB0aGlzLnByb3BlcnRpZXMuT1ApO1xyXG5cdFx0XHRcdHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBKSB7IHJldHVybiBBOyB9O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG4gICAgTWF0aE9wZXJhdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICggQSAhPSBudWxsICkge1xyXG5cdFx0XHRpZiggQS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyIClcclxuXHQgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJBXCJdID0gQTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBBID0gdGhpcy5wcm9wZXJ0aWVzW1wiQVwiXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChCICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiQlwiXSA9IEI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQiA9IHRoaXMucHJvcGVydGllc1tcIkJcIl07XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdHZhciByZXN1bHQ7XHJcblx0XHRpZihBLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpXHJcblx0XHR7XHJcblx0ICAgICAgICByZXN1bHQgPSAwO1xyXG5cdFx0XHRyZXN1bHQgPSB0aGlzLl9mdW5jKEEsQik7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKEEuY29uc3RydWN0b3IgPT09IEFycmF5KVxyXG5cdFx0e1xyXG5cdFx0XHRyZXN1bHQgPSB0aGlzLl9yZXN1bHQ7XHJcblx0XHRcdHJlc3VsdC5sZW5ndGggPSBBLmxlbmd0aDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IEEubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fZnVuYyhBW2ldLEIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHRyZXN1bHQgPSB7fTtcclxuXHRcdFx0Zm9yKHZhciBpIGluIEEpXHJcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fZnVuYyhBW2ldLEIpO1xyXG5cdFx0fVxyXG5cdCAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aE9wZXJhdGlvbi5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguZm9udCA9IFwiNDBweCBBcmlhbFwiO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2NjZcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5PUCxcclxuICAgICAgICAgICAgdGhpcy5zaXplWzBdICogMC41LFxyXG4gICAgICAgICAgICAodGhpcy5zaXplWzFdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUKSAqIDAuNVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvb3BlcmF0aW9uXCIsIE1hdGhPcGVyYXRpb24pO1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC9vcGVyYXRpb25cIiwgXCJNQVhcIiwge1xyXG4gICAgICAgIHByb3BlcnRpZXM6IHtPUDpcIm1heFwifSxcclxuICAgICAgICB0aXRsZTogXCJNQVgoKVwiXHJcbiAgICB9KTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvb3BlcmF0aW9uXCIsIFwiTUlOXCIsIHtcclxuICAgICAgICBwcm9wZXJ0aWVzOiB7T1A6XCJtaW5cIn0sXHJcbiAgICAgICAgdGl0bGU6IFwiTUlOKClcIlxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vTWF0aCBjb21wYXJlXHJcbiAgICBmdW5jdGlvbiBNYXRoQ29tcGFyZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIkE9PUJcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiQSE9QlwiLCBcImJvb2xlYW5cIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIkFcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIkJcIiwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aENvbXBhcmUudGl0bGUgPSBcIkNvbXBhcmVcIjtcclxuICAgIE1hdGhDb21wYXJlLmRlc2MgPSBcImNvbXBhcmVzIGJldHdlZW4gdHdvIHZhbHVlc1wiO1xyXG5cclxuICAgIE1hdGhDb21wYXJlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKEEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJBXCJdID0gQTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBBID0gdGhpcy5wcm9wZXJ0aWVzW1wiQVwiXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChCICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiQlwiXSA9IEI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQiA9IHRoaXMucHJvcGVydGllc1tcIkJcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgaWYgKCFvdXRwdXQubGlua3MgfHwgIW91dHB1dC5saW5rcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkE9PUJcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEEgPT0gQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBIT1CXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBICE9IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQT5CXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBID4gQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBPEJcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEEgPCBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkE8PUJcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEEgPD0gQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBPj1CXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBID49IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhDb21wYXJlLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJBPT1CXCIsIFwiYm9vbGVhblwiXSxcclxuICAgICAgICAgICAgW1wiQSE9QlwiLCBcImJvb2xlYW5cIl0sXHJcbiAgICAgICAgICAgIFtcIkE+QlwiLCBcImJvb2xlYW5cIl0sXHJcbiAgICAgICAgICAgIFtcIkE8QlwiLCBcImJvb2xlYW5cIl0sXHJcbiAgICAgICAgICAgIFtcIkE+PUJcIiwgXCJib29sZWFuXCJdLFxyXG4gICAgICAgICAgICBbXCJBPD1CXCIsIFwiYm9vbGVhblwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9jb21wYXJlXCIsIE1hdGhDb21wYXJlKTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIj09XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiQT09QlwiLCBcImJvb2xlYW5cIl1dLFxyXG4gICAgICAgIHRpdGxlOiBcIkE9PUJcIlxyXG4gICAgfSk7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIiE9XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiQSE9QlwiLCBcImJvb2xlYW5cIl1dLFxyXG4gICAgICAgIHRpdGxlOiBcIkEhPUJcIlxyXG4gICAgfSk7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIj5cIiwge1xyXG4gICAgICAgIG91dHB1dHM6IFtbXCJBPkJcIiwgXCJib29sZWFuXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJBPkJcIlxyXG4gICAgfSk7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIjxcIiwge1xyXG4gICAgICAgIG91dHB1dHM6IFtbXCJBPEJcIiwgXCJib29sZWFuXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJBPEJcIlxyXG4gICAgfSk7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIj49XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiQT49QlwiLCBcImJvb2xlYW5cIl1dLFxyXG4gICAgICAgIHRpdGxlOiBcIkE+PUJcIlxyXG4gICAgfSk7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIjw9XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiQTw9QlwiLCBcImJvb2xlYW5cIl1dLFxyXG4gICAgICAgIHRpdGxlOiBcIkE8PUJcIlxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aENvbmRpdGlvbigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZmFsc2VcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJBXCIsIDEpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJCXCIsIDEpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJPUFwiLCBcIj5cIiwgXCJlbnVtXCIsIHsgdmFsdWVzOiBNYXRoQ29uZGl0aW9uLnZhbHVlcyB9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcIkNvbmQuXCIsdGhpcy5wcm9wZXJ0aWVzLk9QLHsgcHJvcGVydHk6IFwiT1BcIiwgdmFsdWVzOiBNYXRoQ29uZGl0aW9uLnZhbHVlcyB9ICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgNjBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhDb25kaXRpb24udmFsdWVzID0gW1wiPlwiLCBcIjxcIiwgXCI9PVwiLCBcIiE9XCIsIFwiPD1cIiwgXCI+PVwiLCBcInx8XCIsIFwiJiZcIiBdO1xyXG4gICAgTWF0aENvbmRpdGlvbltcIkBPUFwiXSA9IHtcclxuICAgICAgICB0eXBlOiBcImVudW1cIixcclxuICAgICAgICB0aXRsZTogXCJvcGVyYXRpb25cIixcclxuICAgICAgICB2YWx1ZXM6IE1hdGhDb25kaXRpb24udmFsdWVzXHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhDb25kaXRpb24udGl0bGUgPSBcIkNvbmRpdGlvblwiO1xyXG4gICAgTWF0aENvbmRpdGlvbi5kZXNjID0gXCJldmFsdWF0ZXMgY29uZGl0aW9uIGJldHdlZW4gQSBhbmQgQlwiO1xyXG5cclxuICAgIE1hdGhDb25kaXRpb24ucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiQSBcIiArIHRoaXMucHJvcGVydGllcy5PUCArIFwiIEJcIjtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aENvbmRpdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoQSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIEEgPSB0aGlzLnByb3BlcnRpZXMuQTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuQSA9IEE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChCID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgQiA9IHRoaXMucHJvcGVydGllcy5CO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5CID0gQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wZXJ0aWVzLk9QKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBID4gQjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSA8IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIj09XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBID09IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIiE9XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBICE9IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIjw9XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBIDw9IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIj49XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBID49IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInx8XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBIHx8IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIiYmXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBICYmIEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXN1bHQpO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCAhcmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2NvbmRpdGlvblwiLCBNYXRoQ29uZGl0aW9uKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aEJyYW5jaCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNvbmRcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidHJ1ZVwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZhbHNlXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgNjBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhCcmFuY2gudGl0bGUgPSBcIkJyYW5jaFwiO1xyXG4gICAgTWF0aEJyYW5jaC5kZXNjID0gXCJJZiBjb25kaXRpb24gaXMgdHJ1ZSwgb3V0cHV0cyBJTiBpbiB0cnVlLCBvdGhlcndpc2UgaW4gZmFsc2VcIjtcclxuXHJcbiAgICBNYXRoQnJhbmNoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgViA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciBjb25kID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblxyXG5cdFx0aWYoY29uZClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIFYpO1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMSwgbnVsbCk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBudWxsKTtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIFYpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvYnJhbmNoXCIsIE1hdGhCcmFuY2gpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoQWNjdW11bGF0ZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5jXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidG90YWxcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImluY3JlbWVudFwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidmFsdWVcIiwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aEFjY3VtdWxhdGUudGl0bGUgPSBcIkFjY3VtdWxhdGVcIjtcclxuICAgIE1hdGhBY2N1bXVsYXRlLmRlc2MgPSBcIkluY3JlbWVudHMgYSB2YWx1ZSBldmVyeSB0aW1lXCI7XHJcblxyXG4gICAgTWF0aEFjY3VtdWxhdGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMudmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbmMgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoaW5jICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSArPSBpbmM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICs9IHRoaXMucHJvcGVydGllcy5pbmNyZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvYWNjdW11bGF0ZVwiLCBNYXRoQWNjdW11bGF0ZSk7XHJcblxyXG4gICAgLy9NYXRoIFRyaWdvbm9tZXRyeVxyXG4gICAgZnVuY3Rpb24gTWF0aFRyaWdvbm9tZXRyeSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwidlwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInNpblwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImFtcGxpdHVkZVwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib2Zmc2V0XCIsIDApO1xyXG4gICAgICAgIHRoaXMuYmdJbWFnZVVybCA9IFwibm9kZXMvaW1ncy9pY29uLXNpbi5wbmdcIjtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoVHJpZ29ub21ldHJ5LnRpdGxlID0gXCJUcmlnb25vbWV0cnlcIjtcclxuICAgIE1hdGhUcmlnb25vbWV0cnkuZGVzYyA9IFwiU2luIENvcyBUYW5cIjtcclxuICAgIC8vTWF0aFRyaWdvbm9tZXRyeS5maWx0ZXIgPSBcInNoYWRlclwiO1xyXG5cclxuICAgIE1hdGhUcmlnb25vbWV0cnkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFtcGxpdHVkZSA9IHRoaXMucHJvcGVydGllc1tcImFtcGxpdHVkZVwiXTtcclxuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChcImFtcGxpdHVkZVwiKTtcclxuICAgICAgICBpZiAoc2xvdCAhPSAtMSkge1xyXG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSB0aGlzLmdldElucHV0RGF0YShzbG90KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucHJvcGVydGllc1tcIm9mZnNldFwiXTtcclxuICAgICAgICBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KFwib2Zmc2V0XCIpO1xyXG4gICAgICAgIGlmIChzbG90ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0SW5wdXREYXRhKHNsb3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNpblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5zaW4odik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29zXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmNvcyh2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0YW5cIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgudGFuKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFzaW5cIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYXNpbih2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhY29zXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmFjb3Modik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXRhblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5hdGFuKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCBhbXBsaXR1ZGUgKiB2YWx1ZSArIG9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoVHJpZ29ub21ldHJ5LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1widlwiLCBcIm51bWJlclwiXSwgW1wiYW1wbGl0dWRlXCIsIFwibnVtYmVyXCJdLCBbXCJvZmZzZXRcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoVHJpZ29ub21ldHJ5LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJzaW5cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImNvc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1widGFuXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJhc2luXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJhY29zXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJhdGFuXCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3RyaWdvbm9tZXRyeVwiLCBNYXRoVHJpZ29ub21ldHJ5KTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvdHJpZ29ub21ldHJ5XCIsIFwiU0lOKClcIiwge1xyXG4gICAgICAgIG91dHB1dHM6IFtbXCJzaW5cIiwgXCJudW1iZXJcIl1dLFxyXG4gICAgICAgIHRpdGxlOiBcIlNJTigpXCJcclxuICAgIH0pO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL3RyaWdvbm9tZXRyeVwiLCBcIkNPUygpXCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiY29zXCIsIFwibnVtYmVyXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJDT1MoKVwiXHJcbiAgICB9KTtcclxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC90cmlnb25vbWV0cnlcIiwgXCJUQU4oKVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogW1tcInRhblwiLCBcIm51bWJlclwiXV0sXHJcbiAgICAgICAgdGl0bGU6IFwiVEFOKClcIlxyXG4gICAgfSk7XHJcblxyXG4gICAgLy9tYXRoIGxpYnJhcnkgZm9yIHNhZmUgbWF0aCBvcGVyYXRpb25zIHdpdGhvdXQgZXZhbFxyXG4gICAgZnVuY3Rpb24gTWF0aEZvcm11bGEoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInhcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInlcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB4OiAxLjAsIHk6IDEuMCwgZm9ybXVsYTogXCJ4K3lcIiB9O1xyXG4gICAgICAgIHRoaXMuY29kZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcclxuICAgICAgICAgICAgXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgIFwiRih4LHkpXCIsXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5mb3JtdWxhLFxyXG4gICAgICAgICAgICBmdW5jdGlvbih2LCBjYW52YXMsIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5mb3JtdWxhID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQoXCJ0b2dnbGVcIiwgXCJhbGxvd1wiLCBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cywgZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cyA9IHY7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZnVuYyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aEZvcm11bGEudGl0bGUgPSBcIkZvcm11bGFcIjtcclxuICAgIE1hdGhGb3JtdWxhLmRlc2MgPSBcIkNvbXB1dGUgZm9ybXVsYVwiO1xyXG4gICAgTWF0aEZvcm11bGEuc2l6ZSA9IFsxNjAsIDEwMF07XHJcblxyXG4gICAgTWF0aEF2ZXJhZ2VGaWx0ZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImZvcm11bGFcIikge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVfd2lkZ2V0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoRm9ybXVsYS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFMaXRlR3JhcGguYWxsb3dfc2NyaXB0cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJ4XCJdID0geDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4ID0gdGhpcy5wcm9wZXJ0aWVzW1wieFwiXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wieVwiXSA9IHk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeSA9IHRoaXMucHJvcGVydGllc1tcInlcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZiA9IHRoaXMucHJvcGVydGllc1tcImZvcm11bGFcIl07XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Z1bmMgfHwgdGhpcy5fZnVuY19jb2RlICE9IHRoaXMucHJvcGVydGllcy5mb3JtdWxhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mdW5jID0gbmV3IEZ1bmN0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwieFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwieVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVElNRVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicmV0dXJuIFwiICsgdGhpcy5wcm9wZXJ0aWVzLmZvcm11bGFcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mdW5jX2NvZGUgPSB0aGlzLnByb3BlcnRpZXMuZm9ybXVsYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2Z1bmMoeCwgeSwgdGhpcy5ncmFwaC5nbG9iYWx0aW1lKTtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IG51bGw7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoRm9ybXVsYS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZnVuY19jb2RlIHx8IFwiRm9ybXVsYVwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoRm9ybXVsYS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBmID0gdGhpcy5wcm9wZXJ0aWVzW1wiZm9ybXVsYVwiXTtcclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzWzBdLmxhYmVsID0gZjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9mb3JtdWxhXCIsIE1hdGhGb3JtdWxhKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMyVG9YWSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwidmVjMlwiLCBcInZlYzJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieVwiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWMyVG9YWS50aXRsZSA9IFwiVmVjMi0+WFlcIjtcclxuICAgIE1hdGgzRFZlYzJUb1hZLmRlc2MgPSBcInZlY3RvciAyIHRvIGNvbXBvbmVudHNcIjtcclxuXHJcbiAgICBNYXRoM0RWZWMyVG9YWS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2WzBdKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdlsxXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzItdG8teHlcIiwgTWF0aDNEVmVjMlRvWFkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFhZVG9WZWMyKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXRzKFtbXCJ4XCIsIFwibnVtYmVyXCJdLCBbXCJ5XCIsIFwibnVtYmVyXCJdXSk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2ZWMyXCIsIFwidmVjMlwiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RYWVRvVmVjMi50aXRsZSA9IFwiWFktPlZlYzJcIjtcclxuICAgIE1hdGgzRFhZVG9WZWMyLmRlc2MgPSBcImNvbXBvbmVudHMgdG8gdmVjdG9yMlwiO1xyXG5cclxuICAgIE1hdGgzRFhZVG9WZWMyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgeCA9IHRoaXMucHJvcGVydGllcy54O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgeSA9IHRoaXMucHJvcGVydGllcy55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgIGRhdGFbMF0gPSB4O1xyXG4gICAgICAgIGRhdGFbMV0gPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3h5LXRvLXZlYzJcIiwgTWF0aDNEWFlUb1ZlYzIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzNUb1hZWigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwidmVjM1wiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInpcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjM1RvWFlaLnRpdGxlID0gXCJWZWMzLT5YWVpcIjtcclxuICAgIE1hdGgzRFZlYzNUb1hZWi5kZXNjID0gXCJ2ZWN0b3IgMyB0byBjb21wb25lbnRzXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjM1RvWFlaLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZbMF0pO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB2WzFdKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMiwgdlsyXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzMtdG8teHl6XCIsIE1hdGgzRFZlYzNUb1hZWik7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEWFlaVG9WZWMzKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXRzKFtbXCJ4XCIsIFwibnVtYmVyXCJdLCBbXCJ5XCIsIFwibnVtYmVyXCJdLCBbXCJ6XCIsIFwibnVtYmVyXCJdXSk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2ZWMzXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RYWVpUb1ZlYzMudGl0bGUgPSBcIlhZWi0+VmVjM1wiO1xyXG4gICAgTWF0aDNEWFlaVG9WZWMzLmRlc2MgPSBcImNvbXBvbmVudHMgdG8gdmVjdG9yM1wiO1xyXG5cclxuICAgIE1hdGgzRFhZWlRvVmVjMy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHggPSB0aGlzLnByb3BlcnRpZXMueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXMueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHogPSB0aGlzLnByb3BlcnRpZXMuejtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBkYXRhWzBdID0geDtcclxuICAgICAgICBkYXRhWzFdID0geTtcclxuICAgICAgICBkYXRhWzJdID0gejtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC94eXotdG8tdmVjM1wiLCBNYXRoM0RYWVpUb1ZlYzMpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzRUb1hZWlcoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZlYzRcIiwgXCJ2ZWM0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInlcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ6XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwid1wiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWM0VG9YWVpXLnRpdGxlID0gXCJWZWM0LT5YWVpXXCI7XHJcbiAgICBNYXRoM0RWZWM0VG9YWVpXLmRlc2MgPSBcInZlY3RvciA0IHRvIGNvbXBvbmVudHNcIjtcclxuXHJcbiAgICBNYXRoM0RWZWM0VG9YWVpXLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZbMF0pO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB2WzFdKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMiwgdlsyXSk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDMsIHZbM10pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWM0LXRvLXh5endcIiwgTWF0aDNEVmVjNFRvWFlaVyk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEWFlaV1RvVmVjNCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0cyhbXHJcbiAgICAgICAgICAgIFtcInhcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInlcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInpcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIndcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICBdKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZlYzRcIiwgXCJ2ZWM0XCIpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgeDogMCwgeTogMCwgejogMCwgdzogMCB9O1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFhZWldUb1ZlYzQudGl0bGUgPSBcIlhZWlctPlZlYzRcIjtcclxuICAgIE1hdGgzRFhZWldUb1ZlYzQuZGVzYyA9IFwiY29tcG9uZW50cyB0byB2ZWN0b3I0XCI7XHJcblxyXG4gICAgTWF0aDNEWFlaV1RvVmVjNC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHggPSB0aGlzLnByb3BlcnRpZXMueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXMueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHogPSB0aGlzLnByb3BlcnRpZXMuejtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldElucHV0RGF0YSgzKTtcclxuICAgICAgICBpZiAodyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHcgPSB0aGlzLnByb3BlcnRpZXMudztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBkYXRhWzBdID0geDtcclxuICAgICAgICBkYXRhWzFdID0geTtcclxuICAgICAgICBkYXRhWzJdID0gejtcclxuICAgICAgICBkYXRhWzNdID0gdztcclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC94eXp3LXRvLXZlYzRcIiwgTWF0aDNEWFlaV1RvVmVjNCk7XHJcblxyXG59KSh0aGlzKTtcclxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIE1hdGgzRE1hdDQoKVxyXG5cdHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiVFwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlJcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJTXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm1hdDRcIiwgXCJtYXQ0XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRcIlRcIjpbMCwwLDBdLFxyXG5cdFx0XHRcIlJcIjpbMCwwLDBdLFxyXG5cdFx0XHRcIlNcIjpbMSwxLDFdLFxyXG5cdFx0XHRSX2luX2RlZ3JlZXM6IHRydWVcclxuXHRcdH07XHJcblx0XHR0aGlzLl9yZXN1bHQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TWF0aDNETWF0NC50aXRsZSA9IFwibWF0NFwiO1xyXG5cdE1hdGgzRE1hdDQudGVtcF9xdWF0ID0gbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMV0pO1xyXG5cdE1hdGgzRE1hdDQudGVtcF9tYXQ0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblx0TWF0aDNETWF0NC50ZW1wX3ZlYzMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG5cclxuXHRNYXRoM0RNYXQ0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKVxyXG5cdHtcclxuXHRcdHRoaXMuX211c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdE1hdGgzRE1hdDQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgTSA9IHRoaXMuX3Jlc3VsdDtcclxuXHRcdHZhciBRID0gTWF0aDNETWF0NC50ZW1wX3F1YXQ7XHJcblx0XHR2YXIgdGVtcF9tYXQ0ID0gTWF0aDNETWF0NC50ZW1wX21hdDQ7XHJcblx0XHR2YXIgdGVtcF92ZWMzID0gTWF0aDNETWF0NC50ZW1wX3ZlYzM7XHJcblxyXG5cdFx0dmFyIFQgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHZhciBSID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHR2YXIgUyA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG5cclxuXHRcdGlmKCB0aGlzLl9tdXN0X3VwZGF0ZSB8fCBUIHx8IFIgfHwgUyApXHJcblx0XHR7XHJcblx0XHRcdFQgPSBUIHx8IHRoaXMucHJvcGVydGllcy5UO1xyXG5cdFx0XHRSID0gUiB8fCB0aGlzLnByb3BlcnRpZXMuUjtcclxuXHRcdFx0UyA9IFMgfHwgdGhpcy5wcm9wZXJ0aWVzLlM7XHJcblx0XHRcdG1hdDQuaWRlbnRpdHkoIE0gKTtcclxuXHRcdFx0bWF0NC50cmFuc2xhdGUoIE0sIE0sIFQgKTtcclxuXHRcdFx0aWYodGhpcy5wcm9wZXJ0aWVzLlJfaW5fZGVncmVlcylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRlbXBfdmVjMy5zZXQoIFIgKTtcclxuXHRcdFx0XHR2ZWMzLnNjYWxlKHRlbXBfdmVjMyx0ZW1wX3ZlYzMsREVHMlJBRCk7XHJcblx0XHRcdFx0cXVhdC5mcm9tRXVsZXIoIFEsIHRlbXBfdmVjMyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRxdWF0LmZyb21FdWxlciggUSwgUiApO1xyXG5cdFx0XHRtYXQ0LmZyb21RdWF0KCB0ZW1wX21hdDQsIFEgKTtcclxuXHRcdFx0bWF0NC5tdWx0aXBseSggTSwgTSwgdGVtcF9tYXQ0ICk7XHJcblx0XHRcdG1hdDQuc2NhbGUoIE0sIE0sIFMgKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgTSk7XHRcdFxyXG5cdH1cclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9tYXQ0XCIsIE1hdGgzRE1hdDQpO1xyXG5cclxuICAgIC8vTWF0aCAzRCBvcGVyYXRpb25cclxuICAgIGZ1bmN0aW9uIE1hdGgzRE9wZXJhdGlvbigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlcix2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwibnVtYmVyLHZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCI9XCIsIFwibnVtYmVyLHZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIk9QXCIsIFwiK1wiLCBcImVudW1cIiwgeyB2YWx1ZXM6IE1hdGgzRE9wZXJhdGlvbi52YWx1ZXMgfSk7XHJcblx0XHR0aGlzLl9yZXN1bHQgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRE9wZXJhdGlvbi52YWx1ZXMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCIsIFwiJVwiLCBcIl5cIiwgXCJtYXhcIiwgXCJtaW5cIixcImRvdFwiLFwiY3Jvc3NcIl07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoM2Qvb3BlcmF0aW9uXCIsIFwiQ1JPU1MoKVwiLCB7XHJcbiAgICAgICAgcHJvcGVydGllczoge1wiT1BcIjpcImNyb3NzXCJ9LFxyXG4gICAgICAgIHRpdGxlOiBcIkNST1NTKClcIlxyXG4gICAgfSk7XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoM2Qvb3BlcmF0aW9uXCIsIFwiRE9UKClcIiwge1xyXG4gICAgICAgIHByb3BlcnRpZXM6IHtcIk9QXCI6XCJkb3RcIn0sXHJcbiAgICAgICAgdGl0bGU6IFwiRE9UKClcIlxyXG4gICAgfSk7XHJcblxyXG5cdE1hdGgzRE9wZXJhdGlvbi50aXRsZSA9IFwiT3BlcmF0aW9uXCI7XHJcbiAgICBNYXRoM0RPcGVyYXRpb24uZGVzYyA9IFwiRWFzeSBtYXRoIDNEIG9wZXJhdG9yc1wiO1xyXG4gICAgTWF0aDNET3BlcmF0aW9uW1wiQE9QXCJdID0ge1xyXG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxyXG4gICAgICAgIHRpdGxlOiBcIm9wZXJhdGlvblwiLFxyXG4gICAgICAgIHZhbHVlczogTWF0aDNET3BlcmF0aW9uLnZhbHVlc1xyXG4gICAgfTtcclxuICAgIE1hdGgzRE9wZXJhdGlvbi5zaXplID0gWzEwMCwgNjBdO1xyXG5cclxuICAgIE1hdGgzRE9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5PUCA9PSBcIm1heFwiIHx8IHRoaXMucHJvcGVydGllcy5PUCA9PSBcIm1pblwiIClcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJvcGVydGllcy5PUCArIFwiKEEsQilcIjtcclxuICAgICAgICByZXR1cm4gXCJBIFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QICsgXCIgQlwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoM0RPcGVyYXRpb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKEEgPT0gbnVsbCB8fCBCID09IG51bGwpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKEEuY29uc3RydWN0b3IgPT09IE51bWJlcilcclxuXHRcdFx0QSA9IFtBLEEsQV07XHJcblx0XHRpZihCLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpXHJcblx0XHRcdEIgPSBbQixCLEJdO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcmVzdWx0O1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wZXJ0aWVzLk9QKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2ZWMzLmFkZChyZXN1bHQsQSxCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiLVwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmVjMy5zdWIocmVzdWx0LEEsQik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIipcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZlYzMubXVsKHJlc3VsdCxBLEIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2ZWMzLmRpdihyZXN1bHQsQSxCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiJVwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gQVswXSVCWzBdO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gQVsxXSVCWzFdO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzJdID0gQVsyXSVCWzJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJeXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSBNYXRoLnBvdyhBWzBdLEJbMF0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5wb3coQVsxXSxCWzFdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsyXSA9IE1hdGgucG93KEFbMl0sQlsyXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1heFwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gTWF0aC5tYXgoQVswXSxCWzBdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IE1hdGgubWF4KEFbMV0sQlsxXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMl0gPSBNYXRoLm1heChBWzJdLEJbMl0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtaW5cIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IE1hdGgubWluKEFbMF0sQlswXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBNYXRoLm1pbihBWzFdLEJbMV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzJdID0gTWF0aC5taW4oQVsyXSxCWzJdKTtcclxuICAgICAgICAgICAgY2FzZSBcImRvdFwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmVjMy5kb3QoQSxCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY3Jvc3NcIjpcclxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3MocmVzdWx0LEEsQik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gb3BlcmF0aW9uOiBcIiArIHRoaXMucHJvcGVydGllcy5PUCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoM0RPcGVyYXRpb24ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjQwcHggQXJpYWxcIjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNjY2XCI7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuT1AsXHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAqIDAuNSxcclxuICAgICAgICAgICAgKHRoaXMuc2l6ZVsxXSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCkgKiAwLjVcclxuICAgICAgICApO1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2Qvb3BlcmF0aW9uXCIsIE1hdGgzRE9wZXJhdGlvbik7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEVmVjM1NjYWxlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImZcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgZjogMSB9O1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFZlYzNTY2FsZS50aXRsZSA9IFwidmVjM19zY2FsZVwiO1xyXG4gICAgTWF0aDNEVmVjM1NjYWxlLmRlc2MgPSBcInNjYWxlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcIjtcclxuXHJcbiAgICBNYXRoM0RWZWMzU2NhbGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKGYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmID0gdGhpcy5wcm9wZXJ0aWVzLmY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgZGF0YVswXSA9IHZbMF0gKiBmO1xyXG4gICAgICAgIGRhdGFbMV0gPSB2WzFdICogZjtcclxuICAgICAgICBkYXRhWzJdID0gdlsyXSAqIGY7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLXNjYWxlXCIsIE1hdGgzRFZlYzNTY2FsZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEVmVjM0xlbmd0aCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFZlYzNMZW5ndGgudGl0bGUgPSBcInZlYzNfbGVuZ3RoXCI7XHJcbiAgICBNYXRoM0RWZWMzTGVuZ3RoLmRlc2MgPSBcInJldHVybnMgdGhlIG1vZHVsZSBvZiBhIHZlY3RvclwiO1xyXG5cclxuICAgIE1hdGgzRFZlYzNMZW5ndGgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXSk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRpc3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLWxlbmd0aFwiLCBNYXRoM0RWZWMzTGVuZ3RoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzTm9ybWFsaXplKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFZlYzNOb3JtYWxpemUudGl0bGUgPSBcInZlYzNfbm9ybWFsaXplXCI7XHJcbiAgICBNYXRoM0RWZWMzTm9ybWFsaXplLmRlc2MgPSBcInJldHVybnMgdGhlIHZlY3RvciBub3JtYWxpemVkXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjM05vcm1hbGl6ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSArIHZbMl0gKiB2WzJdKTtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgZGF0YVswXSA9IHZbMF0gLyBkaXN0O1xyXG4gICAgICAgIGRhdGFbMV0gPSB2WzFdIC8gZGlzdDtcclxuICAgICAgICBkYXRhWzJdID0gdlsyXSAvIGRpc3Q7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvdmVjMy1ub3JtYWxpemVcIiwgTWF0aDNEVmVjM05vcm1hbGl6ZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEVmVjM0xlcnAoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZlwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgZjogMC41IH07XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjM0xlcnAudGl0bGUgPSBcInZlYzNfbGVycFwiO1xyXG4gICAgTWF0aDNEVmVjM0xlcnAuZGVzYyA9IFwicmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHZlY3RvclwiO1xyXG5cclxuICAgIE1hdGgzRFZlYzNMZXJwLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmIChBID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChCID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZlwiKTtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgIGRhdGFbMF0gPSBBWzBdICogKDEgLSBmKSArIEJbMF0gKiBmO1xyXG4gICAgICAgIGRhdGFbMV0gPSBBWzFdICogKDEgLSBmKSArIEJbMV0gKiBmO1xyXG4gICAgICAgIGRhdGFbMl0gPSBBWzJdICogKDEgLSBmKSArIEJbMl0gKiBmO1xyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzMtbGVycFwiLCBNYXRoM0RWZWMzTGVycCk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEVmVjM0RvdCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFZlYzNEb3QudGl0bGUgPSBcInZlYzNfZG90XCI7XHJcbiAgICBNYXRoM0RWZWMzRG90LmRlc2MgPSBcInJldHVybnMgdGhlIGRvdCBwcm9kdWN0XCI7XHJcblxyXG4gICAgTWF0aDNEVmVjM0RvdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoQSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoQiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkb3QgPSBBWzBdICogQlswXSArIEFbMV0gKiBCWzFdICsgQVsyXSAqIEJbMl07XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRvdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzMtZG90XCIsIE1hdGgzRFZlYzNEb3QpO1xyXG5cclxuICAgIC8vaWYgZ2xNYXRyaXggaXMgaW5zdGFsbGVkLi4uXHJcbiAgICBpZiAoZ2xvYmFsLmdsTWF0cml4KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aDNEUXVhdGVybmlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJxdWF0XCIsIFwicXVhdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB4OiAwLCB5OiAwLCB6OiAwLCB3OiAxLCBub3JtYWxpemU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gcXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGgzRFF1YXRlcm5pb24udGl0bGUgPSBcIlF1YXRlcm5pb25cIjtcclxuICAgICAgICBNYXRoM0RRdWF0ZXJuaW9uLmRlc2MgPSBcInF1YXRlcm5pb25cIjtcclxuXHJcbiAgICAgICAgTWF0aDNEUXVhdGVybmlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlWzBdID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ4XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVsxXSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwieVwiKTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVbMl0gPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInpcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlWzNdID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ3XCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm5vcm1hbGl6ZSkge1xyXG4gICAgICAgICAgICAgICAgcXVhdC5ub3JtYWxpemUodGhpcy5fdmFsdWUsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIE1hdGgzRFF1YXRlcm5pb24ucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBbXCJ4XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICAgICAgW1wieVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgICAgIFtcInpcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgICAgICBbXCJ3XCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvcXVhdGVybmlvblwiLCBNYXRoM0RRdWF0ZXJuaW9uKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aDNEUm90YXRpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXRzKFtbXCJkZWdyZWVzXCIsIFwibnVtYmVyXCJdLCBbXCJheGlzXCIsIFwidmVjM1wiXV0pO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcInF1YXRcIiwgXCJxdWF0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGFuZ2xlOiA5MC4wLCBheGlzOiB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCkgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gcXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGgzRFJvdGF0aW9uLnRpdGxlID0gXCJSb3RhdGlvblwiO1xyXG4gICAgICAgIE1hdGgzRFJvdGF0aW9uLmRlc2MgPSBcInF1YXRlcm5pb24gcm90YXRpb25cIjtcclxuXHJcbiAgICAgICAgTWF0aDNEUm90YXRpb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKGFuZ2xlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFuZ2xlID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgIGlmIChheGlzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGF4aXMgPSB0aGlzLnByb3BlcnRpZXMuYXhpcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIFIgPSBxdWF0LnNldEF4aXNBbmdsZSh0aGlzLl92YWx1ZSwgYXhpcywgYW5nbGUgKiAwLjAxNzQ1MzI5MjUpO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgUik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2Qvcm90YXRpb25cIiwgTWF0aDNEUm90YXRpb24pO1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aEV1bGVyVG9RdWF0KCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiZXVsZXJcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcInF1YXRcIiwgXCJxdWF0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGV1bGVyOlswLDAsMF0sIHVzZV95YXdfcGl0Y2hfcm9sbDogZmFsc2UgfTtcclxuXHRcdFx0dGhpcy5fZGVncyA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gcXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGhFdWxlclRvUXVhdC50aXRsZSA9IFwiRXVsZXItPlF1YXRcIjtcclxuICAgICAgICBNYXRoRXVsZXJUb1F1YXQuZGVzYyA9IFwiQ29udmVydHMgZXVsZXIgYW5nbGVzIChpbiBkZWdyZWVzKSB0byBxdWF0ZXJuaW9uXCI7XHJcblxyXG4gICAgICAgIE1hdGhFdWxlclRvUXVhdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBldWxlciA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAoZXVsZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXVsZXIgPSB0aGlzLnByb3BlcnRpZXMuZXVsZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0dmVjMy5zY2FsZSggdGhpcy5fZGVncywgZXVsZXIsIERFRzJSQUQgKTtcclxuXHRcdFx0aWYodGhpcy5wcm9wZXJ0aWVzLnVzZV95YXdfcGl0Y2hfcm9sbClcclxuXHRcdFx0XHR0aGlzLl9kZWdzID0gW3RoaXMuX2RlZ3NbMl0sdGhpcy5fZGVnc1swXSx0aGlzLl9kZWdzWzFdXTtcclxuICAgICAgICAgICAgdmFyIFIgPSBxdWF0LmZyb21FdWxlcih0aGlzLl92YWx1ZSwgdGhpcy5fZGVncyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBSKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9ldWxlcl90b19xdWF0XCIsIE1hdGhFdWxlclRvUXVhdCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGhRdWF0VG9FdWxlcigpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChbXCJxdWF0XCIsIFwicXVhdFwiXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZXVsZXJcIiwgXCJ2ZWMzXCIpO1xyXG5cdFx0XHR0aGlzLl92YWx1ZSA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoUXVhdFRvRXVsZXIudGl0bGUgPSBcIkV1bGVyLT5RdWF0XCI7XHJcbiAgICAgICAgTWF0aFF1YXRUb0V1bGVyLmRlc2MgPSBcIkNvbnZlcnRzIHJvdFgscm90WSxyb3RaIGluIGRlZ3JlZXMgdG8gcXVhdFwiO1xyXG5cclxuICAgICAgICBNYXRoUXVhdFRvRXVsZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0XHRpZighcSlcclxuXHRcdFx0XHRyZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBSID0gcXVhdC50b0V1bGVyKHRoaXMuX3ZhbHVlLCBxKTtcclxuXHRcdFx0dmVjMy5zY2FsZSggdGhpcy5fdmFsdWUsIHRoaXMuX3ZhbHVlLCBERUcyUkFEICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvcXVhdF90b19ldWxlclwiLCBNYXRoUXVhdFRvRXVsZXIpO1xyXG5cclxuXHJcbiAgICAgICAgLy9NYXRoM0Qgcm90YXRlIHZlYzNcclxuICAgICAgICBmdW5jdGlvbiBNYXRoM0RSb3RhdGVWZWMzKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0cyhbW1widmVjM1wiLCBcInZlYzNcIl0sIFtcInF1YXRcIiwgXCJxdWF0XCJdXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicmVzdWx0XCIsIFwidmVjM1wiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB2ZWM6IFswLCAwLCAxXSB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aDNEUm90YXRlVmVjMy50aXRsZSA9IFwiUm90LiBWZWMzXCI7XHJcbiAgICAgICAgTWF0aDNEUm90YXRlVmVjMy5kZXNjID0gXCJyb3RhdGUgYSBwb2ludFwiO1xyXG5cclxuICAgICAgICBNYXRoM0RSb3RhdGVWZWMzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZlYyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAodmVjID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZlYyA9IHRoaXMucHJvcGVydGllcy52ZWM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHF1YXQgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgaWYgKHF1YXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKHZlYyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybVF1YXQodmVjMy5jcmVhdGUoKSwgdmVjLCBxdWF0KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3JvdGF0ZV92ZWMzXCIsIE1hdGgzRFJvdGF0ZVZlYzMpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBNYXRoM0RNdWx0UXVhdCgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1tcIkFcIiwgXCJxdWF0XCJdLCBbXCJCXCIsIFwicXVhdFwiXV0pO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcIkEqQlwiLCBcInF1YXRcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHF1YXQuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoM0RNdWx0UXVhdC50aXRsZSA9IFwiTXVsdC4gUXVhdFwiO1xyXG4gICAgICAgIE1hdGgzRE11bHRRdWF0LmRlc2MgPSBcInJvdGF0ZSBxdWF0ZXJuaW9uXCI7XHJcblxyXG4gICAgICAgIE1hdGgzRE11bHRRdWF0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKEEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgIGlmIChCID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIFIgPSBxdWF0Lm11bHRpcGx5KHRoaXMuX3ZhbHVlLCBBLCBCKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIFIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL211bHQtcXVhdFwiLCBNYXRoM0RNdWx0UXVhdCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGgzRFF1YXRTbGVycCgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1xyXG4gICAgICAgICAgICAgICAgW1wiQVwiLCBcInF1YXRcIl0sXHJcbiAgICAgICAgICAgICAgICBbXCJCXCIsIFwicXVhdFwiXSxcclxuICAgICAgICAgICAgICAgIFtcImZhY3RvclwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJzbGVycFwiLCBcInF1YXRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJmYWN0b3JcIiwgMC41KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gcXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGgzRFF1YXRTbGVycC50aXRsZSA9IFwiUXVhdCBTbGVycFwiO1xyXG4gICAgICAgIE1hdGgzRFF1YXRTbGVycC5kZXNjID0gXCJxdWF0ZXJuaW9uIHNwaGVyaWNhbCBpbnRlcnBvbGF0aW9uXCI7XHJcblxyXG4gICAgICAgIE1hdGgzRFF1YXRTbGVycC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmIChBID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICBpZiAoQiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IHRoaXMucHJvcGVydGllcy5mYWN0b3I7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldElucHV0RGF0YSgyKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIFIgPSBxdWF0LnNsZXJwKHRoaXMuX3ZhbHVlLCBBLCBCLCBmYWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgUik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvcXVhdC1zbGVycFwiLCBNYXRoM0RRdWF0U2xlcnApO1xyXG5cclxuXHJcbiAgICAgICAgLy9NYXRoM0Qgcm90YXRlIHZlYzNcclxuICAgICAgICBmdW5jdGlvbiBNYXRoM0RSZW1hcFJhbmdlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwidmVjM1wiLCBcInZlYzNcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicmVtYXBcIiwgXCJ2ZWMzXCIpO1xyXG5cdFx0XHR0aGlzLmFkZE91dHB1dChcImNsYW1wZWRcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGNsYW1wOiB0cnVlLCByYW5nZV9taW46IFstMSwgLTEsIDBdLCByYW5nZV9tYXg6IFsxLCAxLCAwXSwgdGFyZ2V0X21pbjogWy0xLC0xLDBdLCB0YXJnZXRfbWF4OlsxLDEsMF0gfTtcclxuXHRcdFx0dGhpcy5fdmFsdWUgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0XHR0aGlzLl9jbGFtcGVkID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGgzRFJlbWFwUmFuZ2UudGl0bGUgPSBcIlJlbWFwIFJhbmdlXCI7XHJcbiAgICAgICAgTWF0aDNEUmVtYXBSYW5nZS5kZXNjID0gXCJyZW1hcCBhIDNEIHJhbmdlXCI7XHJcblxyXG4gICAgICAgIE1hdGgzRFJlbWFwUmFuZ2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmVjID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRcdGlmKHZlYylcclxuXHRcdFx0XHR0aGlzLl92YWx1ZS5zZXQodmVjKTtcclxuXHRcdFx0dmFyIHJhbmdlX21pbiA9IHRoaXMucHJvcGVydGllcy5yYW5nZV9taW47XHJcblx0XHRcdHZhciByYW5nZV9tYXggPSB0aGlzLnByb3BlcnRpZXMucmFuZ2VfbWF4O1xyXG5cdFx0XHR2YXIgdGFyZ2V0X21pbiA9IHRoaXMucHJvcGVydGllcy50YXJnZXRfbWluO1xyXG5cdFx0XHR2YXIgdGFyZ2V0X21heCA9IHRoaXMucHJvcGVydGllcy50YXJnZXRfbWF4O1xyXG5cclxuXHRcdFx0Ly9zd2FwIHRvIGF2b2lkIGVycm9yc1xyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZihyYW5nZV9taW4gPiByYW5nZV9tYXgpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRyYW5nZV9taW4gPSByYW5nZV9tYXg7XHJcblx0XHRcdFx0cmFuZ2VfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhbmdlX21pbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYodGFyZ2V0X21pbiA+IHRhcmdldF9tYXgpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0YXJnZXRfbWluID0gdGFyZ2V0X21heDtcclxuXHRcdFx0XHR0YXJnZXRfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLnRhcmdldF9taW47XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCAzOyArK2kpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgciA9IHJhbmdlX21heFtpXSAtIHJhbmdlX21pbltpXTtcclxuXHRcdFx0XHR0aGlzLl9jbGFtcGVkW2ldID0gTWF0aC5jbGFtcCggdGhpcy5fdmFsdWVbaV0sIHJhbmdlX21pbltpXSwgcmFuZ2VfbWF4W2ldICk7XHJcblx0XHRcdFx0aWYociA9PSAwKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlW2ldID0gKHRhcmdldF9taW5baV0gKyB0YXJnZXRfbWF4W2ldKSAqIDAuNTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIG4gPSAodGhpcy5fdmFsdWVbaV0gLSByYW5nZV9taW5baV0pIC8gcjtcclxuXHRcdFx0XHRpZih0aGlzLnByb3BlcnRpZXMuY2xhbXApXHJcblx0XHRcdFx0XHRuID0gTWF0aC5jbGFtcChuLDAsMSk7XHJcblx0XHRcdFx0dmFyIHQgPSB0YXJnZXRfbWF4W2ldIC0gdGFyZ2V0X21pbltpXTtcclxuXHRcdFx0XHR0aGlzLl92YWx1ZVtpXSA9IHRhcmdldF9taW5baV0gKyBuICogdDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5fdmFsdWUpO1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMSx0aGlzLl9jbGFtcGVkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9yZW1hcF9yYW5nZVwiLCBNYXRoM0RSZW1hcFJhbmdlKTtcclxuXHJcblxyXG5cclxuICAgIH0gLy9nbE1hdHJpeFxyXG5cdGVsc2VcclxuXHRcdGNvbnNvbGUud2FybihcIk5vIGdsbWF0cml4IGZvdW5kLCBzb21lIE1hdGgzRCBub2RlcyBtYXkgbm90IHdvcmtcIik7XHJcblxyXG59KSh0aGlzKTtcclxuXG4vL2Jhc2ljIG5vZGVzXHJcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKGEpIHtcclxuXHRcdGlmKGEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxyXG5cdFx0e1xyXG5cdFx0XHR0cnlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYXRjaCAoZXJyKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cmV0dXJuIFN0cmluZyhhKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG4gICAgICAgIHJldHVybiBTdHJpbmcoYSk7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcInN0cmluZy90b1N0cmluZ1wiLCB0b1N0cmluZywgW1wiXCJdLCBcIlN0cmluZ1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSA9PSBiO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvY29tcGFyZVwiLFxyXG4gICAgICAgIGNvbXBhcmUsXHJcbiAgICAgICAgW1wic3RyaW5nXCIsIFwic3RyaW5nXCJdLFxyXG4gICAgICAgIFwiYm9vbGVhblwiXHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbmNhdGVuYXRlKGEsIGIpIHtcclxuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSArIGI7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcclxuICAgICAgICBcInN0cmluZy9jb25jYXRlbmF0ZVwiLFxyXG4gICAgICAgIGNvbmNhdGVuYXRlLFxyXG4gICAgICAgIFtcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICBcInN0cmluZ1wiXHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcclxuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhLmluZGV4T2YoYikgIT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcclxuICAgICAgICBcInN0cmluZy9jb250YWluc1wiLFxyXG4gICAgICAgIGNvbnRhaW5zLFxyXG4gICAgICAgIFtcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICBcImJvb2xlYW5cIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiB0b1VwcGVyQ2FzZShhKSB7XHJcbiAgICAgICAgaWYgKGEgIT0gbnVsbCAmJiBhLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcclxuICAgICAgICBcInN0cmluZy90b1VwcGVyQ2FzZVwiLFxyXG4gICAgICAgIHRvVXBwZXJDYXNlLFxyXG4gICAgICAgIFtcInN0cmluZ1wiXSxcclxuICAgICAgICBcInN0cmluZ1wiXHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0ciwgc2VwYXJhdG9yKSB7XHJcblx0XHRpZihzZXBhcmF0b3IgPT0gbnVsbClcclxuXHRcdFx0c2VwYXJhdG9yID0gdGhpcy5wcm9wZXJ0aWVzLnNlcGFyYXRvcjtcclxuICAgICAgICBpZiAoc3RyID09IG51bGwgKVxyXG5cdCAgICAgICAgcmV0dXJuIFtdO1xyXG5cdFx0aWYoIHN0ci5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIClcclxuXHRcdFx0cmV0dXJuIHN0ci5zcGxpdChzZXBhcmF0b3IgfHwgXCIgXCIpO1xyXG5cdFx0ZWxzZSBpZiggc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheSApXHJcblx0XHR7XHJcblx0XHRcdHZhciByID0gW107XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0cltpXSA9IHN0cltpXS5zcGxpdChzZXBhcmF0b3IgfHwgXCIgXCIpO1xyXG5cdFx0XHRyZXR1cm4gcjtcclxuXHRcdH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBMaXRlR3JhcGgud3JhcEZ1bmN0aW9uQXNOb2RlKFxyXG4gICAgICAgIFwic3RyaW5nL3NwbGl0XCIsXHJcbiAgICAgICAgc3BsaXQsXHJcbiAgICAgICAgW1wic3RyaW5nLGFycmF5XCIsIFwic3RyaW5nXCJdLFxyXG4gICAgICAgIFwiYXJyYXlcIixcclxuXHRcdHsgc2VwYXJhdG9yOiBcIixcIiB9XHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRvRml4ZWQoYSkge1xyXG4gICAgICAgIGlmIChhICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRvRml4ZWQodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvdG9GaXhlZFwiLFxyXG4gICAgICAgIHRvRml4ZWQsXHJcbiAgICAgICAgW1wibnVtYmVyXCJdLFxyXG4gICAgICAgIFwic3RyaW5nXCIsXHJcbiAgICAgICAgeyBwcmVjaXNpb246IDAgfVxyXG4gICAgKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gU3RyaW5nVG9UYWJsZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidGFibGVcIiwgXCJ0YWJsZVwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInJvd3NcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzZXBhcmF0b3JcIiwgXCIsXCIpO1xyXG5cdFx0dGhpcy5fdGFibGUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIFN0cmluZ1RvVGFibGUudGl0bGUgPSBcInRvVGFibGVcIjtcclxuICAgIFN0cmluZ1RvVGFibGUuZGVzYyA9IFwiU3BsaXRzIGEgc3RyaW5nIHRvIHRhYmxlXCI7XHJcblxyXG4gICAgU3RyaW5nVG9UYWJsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighaW5wdXQpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHZhciBzZXBhcmF0b3IgPSB0aGlzLnByb3BlcnRpZXMuc2VwYXJhdG9yIHx8IFwiLFwiO1xyXG5cdFx0aWYoaW5wdXQgIT0gdGhpcy5fc3RyIHx8IHNlcGFyYXRvciAhPSB0aGlzLl9sYXN0X3NlcGFyYXRvciApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuX2xhc3Rfc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xyXG5cdFx0XHR0aGlzLl9zdHIgPSBpbnB1dDtcclxuXHRcdFx0dGhpcy5fdGFibGUgPSBpbnB1dC5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24oYSl7IHJldHVybiBhLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpfSk7XHJcblx0XHR9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RhYmxlICk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3RhYmxlID8gdGhpcy5fdGFibGUubGVuZ3RoIDogMCApO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInN0cmluZy90b1RhYmxlXCIsIFN0cmluZ1RvVGFibGUpO1xyXG5cclxufSkodGhpcyk7XHJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzZWxcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJEXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gMDtcbiAgICB9XG5cbiAgICBTZWxlY3Rvci50aXRsZSA9IFwiU2VsZWN0b3JcIjtcbiAgICBTZWxlY3Rvci5kZXNjID0gXCJzZWxlY3RzIGFuIG91dHB1dFwiO1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FGQlwiO1xuICAgICAgICB2YXIgeSA9ICh0aGlzLnNlbGVjdGVkICsgMSkgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCArIDY7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyg1MCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oNTAsIHkgKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCk7XG4gICAgICAgIGN0eC5saW5lVG8oMzQsIHkgKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoc2VsID09IG51bGwgfHwgc2VsLmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpXG4gICAgICAgICAgICBzZWwgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsID0gTWF0aC5yb3VuZChzZWwpICUgKHRoaXMuaW5wdXRzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKHNlbCArIDEpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbW1wiRVwiLCAwXSwgW1wiRlwiLCAwXSwgW1wiR1wiLCAwXSwgW1wiSFwiLCAwXV07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibG9naWMvc2VsZWN0b3JcIiwgU2VsZWN0b3IpO1xuXG4gICAgZnVuY3Rpb24gU2VxdWVuY2UoKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHNlcXVlbmNlOiBcIkEsQixDXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluZGV4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VxXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcblxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMuc2VxdWVuY2Uuc3BsaXQoXCIsXCIpO1xuICAgIH1cblxuICAgIFNlcXVlbmNlLnRpdGxlID0gXCJTZXF1ZW5jZVwiO1xuICAgIFNlcXVlbmNlLmRlc2MgPSBcInNlbGVjdCBvbmUgZWxlbWVudCBmcm9tIGEgc2VxdWVuY2UgZnJvbSBhIHN0cmluZ1wiO1xuXG4gICAgU2VxdWVuY2UucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzZXF1ZW5jZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZXF1ZW5jZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXEgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKHNlcSAmJiBzZXEgIT0gdGhpcy5jdXJyZW50X3NlcXVlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHNlcS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfc2VxdWVuY2UgPSBzZXE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4ID0gTWF0aC5yb3VuZChpbmRleCkgJSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMudmFsdWVzW2luZGV4XSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibG9naWMvc2VxdWVuY2VcIiwgU2VxdWVuY2UpO1xufSkodGhpcyk7XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcblxuICAgIGZ1bmN0aW9uIEdyYXBoaWNzUGxvdCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJOdW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwiTnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQ1wiLCBcIk51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkRcIiwgXCJOdW1iZXJcIik7XG5cbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbW10sIFtdLCBbXSwgW11dO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHNjYWxlOiAyIH07XG4gICAgfVxuXG4gICAgR3JhcGhpY3NQbG90LnRpdGxlID0gXCJQbG90XCI7XG4gICAgR3JhcGhpY3NQbG90LmRlc2MgPSBcIlBsb3RzIGRhdGEgb3ZlciB0aW1lXCI7XG4gICAgR3JhcGhpY3NQbG90LmNvbG9ycyA9IFtcIiNGRkZcIiwgXCIjRjk5XCIsIFwiIzlGOVwiLCBcIiM5OUZcIl07XG5cbiAgICBHcmFwaGljc1Bsb3QucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzW2ldO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godik7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IHNpemVbMF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHcmFwaGljc1Bsb3QucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcblxuICAgICAgICB2YXIgc2NhbGUgPSAoMC41ICogc2l6ZVsxXSkgLyB0aGlzLnByb3BlcnRpZXMuc2NhbGU7XG4gICAgICAgIHZhciBjb2xvcnMgPSBHcmFwaGljc1Bsb3QuY29sb3JzO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc2l6ZVsxXSAqIDAuNTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjNTU1XCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCBvZmZzZXQpO1xuICAgICAgICBjdHgubGluZVRvKHNpemVbMF0sIG9mZnNldCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dHNbaV0gfHwgIXRoaXMuaW5wdXRzW2ldLmxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbMF0gKiBzY2FsZSAqIC0xICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgTWF0aC5jbGFtcCh2LCAwLCBzaXplWzFdKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB2YWx1ZXMubGVuZ3RoICYmIGogPCBzaXplWzBdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbal0gKiBzY2FsZSAqIC0xICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGosIE1hdGguY2xhbXAodiwgMCwgc2l6ZVsxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9wbG90XCIsIEdyYXBoaWNzUGxvdCk7XG5cbiAgICBmdW5jdGlvbiBHcmFwaGljc0ltYWdlKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZyYW1lXCIsIFwiaW1hZ2VcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgdXJsOiBcIlwiIH07XG4gICAgfVxuXG4gICAgR3JhcGhpY3NJbWFnZS50aXRsZSA9IFwiSW1hZ2VcIjtcbiAgICBHcmFwaGljc0ltYWdlLmRlc2MgPSBcIkltYWdlIGxvYWRlclwiO1xuICAgIEdyYXBoaWNzSW1hZ2Uud2lkZ2V0cyA9IFt7IG5hbWU6IFwibG9hZFwiLCB0ZXh0OiBcIkxvYWRcIiwgdHlwZTogXCJidXR0b25cIiB9XTtcblxuICAgIEdyYXBoaWNzSW1hZ2Uuc3VwcG9ydGVkX2V4dGVuc2lvbnMgPSBbXCJqcGdcIiwgXCJqcGVnXCIsIFwicG5nXCIsIFwiZ2lmXCJdO1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25BZGRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzW1widXJsXCJdICE9IFwiXCIgJiYgdGhpcy5pbWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2UodGhpcy5wcm9wZXJ0aWVzW1widXJsXCJdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHcmFwaGljc0ltYWdlLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmltZyAmJiB0aGlzLnNpemVbMF0gPiA1ICYmIHRoaXMuc2l6ZVsxXSA+IDUgJiYgdGhpcy5pbWcud2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHcmFwaGljc0ltYWdlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmltZykge1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiIzAwMFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmltZyAmJiB0aGlzLmltZy53aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuaW1nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbWcgJiYgdGhpcy5pbWcuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuaW1nLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ1cmxcIiAmJiB2YWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodXJsID09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW1nID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblxuICAgICAgICBpZiAodXJsLnN1YnN0cigwLCA0KSA9PSBcImh0dHBcIiAmJiBMaXRlR3JhcGgucHJveHkpIHtcbiAgICAgICAgICAgIHVybCA9IExpdGVHcmFwaC5wcm94eSArIHVybC5zdWJzdHIodXJsLmluZGV4T2YoXCI6XCIpICsgMyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltZy5zcmMgPSB1cmw7XG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNGOTVcIjtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coIFwiSW1hZ2UgbG9hZGVkLCBzaXplOiBcIiArIHRoYXQuaW1nLndpZHRoICsgXCJ4XCIgKyB0aGF0LmltZy5oZWlnaHQgKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiIzlGOVwiO1xuICAgICAgICAgICAgdGhhdC5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJlcnJvciBsb2FkaW5nIHRoZSBpbWFnZTpcIiArIHVybCk7XG5cdFx0fVxuICAgIH07XG5cbiAgICBHcmFwaGljc0ltYWdlLnByb3RvdHlwZS5vbldpZGdldCA9IGZ1bmN0aW9uKGUsIHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0Lm5hbWUgPT0gXCJsb2FkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEltYWdlKHRoaXMucHJvcGVydGllc1tcInVybFwiXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fdXJsKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX3VybCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnVybCA9IHRoaXMuX3VybDtcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2UodGhpcy5fdXJsLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgIHRoYXQuc2l6ZVsxXSA9IChpbWcuaGVpZ2h0IC8gaW1nLndpZHRoKSAqIHRoYXQuc2l6ZVswXTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvaW1hZ2VcIiwgR3JhcGhpY3NJbWFnZSk7XG5cbiAgICBmdW5jdGlvbiBDb2xvclBhbGV0dGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJmXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIkNvbG9yXCIsIFwiY29sb3JcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGNvbG9yQTogXCIjNDQ0NDQ0XCIsXG4gICAgICAgICAgICBjb2xvckI6IFwiIzQ0QUFGRlwiLFxuICAgICAgICAgICAgY29sb3JDOiBcIiM0NEZGQUFcIixcbiAgICAgICAgICAgIGNvbG9yRDogXCIjRkZGRkZGXCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBDb2xvclBhbGV0dGUudGl0bGUgPSBcIlBhbGV0dGVcIjtcbiAgICBDb2xvclBhbGV0dGUuZGVzYyA9IFwiR2VuZXJhdGVzIGEgY29sb3JcIjtcblxuICAgIENvbG9yUGFsZXR0ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jb2xvckEgIT0gbnVsbCkge1xuICAgICAgICAgICAgYy5wdXNoKGhleDJudW0odGhpcy5wcm9wZXJ0aWVzLmNvbG9yQSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY29sb3JCICE9IG51bGwpIHtcbiAgICAgICAgICAgIGMucHVzaChoZXgybnVtKHRoaXMucHJvcGVydGllcy5jb2xvckIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmNvbG9yQyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjLnB1c2goaGV4Mm51bSh0aGlzLnByb3BlcnRpZXMuY29sb3JDKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jb2xvckQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYy5wdXNoKGhleDJudW0odGhpcy5wcm9wZXJ0aWVzLmNvbG9yRCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgZiA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiA+IDEuMCkge1xuICAgICAgICAgICAgZiA9IDEuMDtcbiAgICAgICAgfSBlbHNlIGlmIChmIDwgMC4wKSB7XG4gICAgICAgICAgICBmID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbMCwgMCwgMF07XG4gICAgICAgIGlmIChmID09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoZiA9PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjW2MubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gKGMubGVuZ3RoIC0gMSkgKiBmO1xuICAgICAgICAgICAgdmFyIGMxID0gY1tNYXRoLmZsb29yKHBvcyldO1xuICAgICAgICAgICAgdmFyIGMyID0gY1tNYXRoLmZsb29yKHBvcykgKyAxXTtcbiAgICAgICAgICAgIHZhciB0ID0gcG9zIC0gTWF0aC5mbG9vcihwb3MpO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gYzFbMF0gKiAoMSAtIHQpICsgYzJbMF0gKiB0O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gYzFbMV0gKiAoMSAtIHQpICsgYzJbMV0gKiB0O1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gYzFbMl0gKiAoMSAtIHQpICsgYzJbMl0gKiB0O1xuICAgICAgICB9XG5cbiAgICAgICAgLypcblx0Y1swXSA9IDEuMCAtIE1hdGguYWJzKCBNYXRoLnNpbiggMC4xICogcmVNb2R1bGFyLmdldFRpbWUoKSAqIE1hdGguUEkpICk7XG5cdGNbMV0gPSBNYXRoLmFicyggTWF0aC5zaW4oIDAuMDcgKiByZU1vZHVsYXIuZ2V0VGltZSgpICogTWF0aC5QSSkgKTtcblx0Y1syXSA9IE1hdGguYWJzKCBNYXRoLnNpbiggMC4wMSAqIHJlTW9kdWxhci5nZXRUaW1lKCkgKiBNYXRoLlBJKSApO1xuXHQqL1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldIC89IDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBjb2xvclRvU3RyaW5nKHJlc3VsdCk7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXN1bHQpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImNvbG9yL3BhbGV0dGVcIiwgQ29sb3JQYWxldHRlKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlRnJhbWUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgXCJpbWFnZSxjYW52YXNcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsyMDAsIDIwMF07XG4gICAgfVxuXG4gICAgSW1hZ2VGcmFtZS50aXRsZSA9IFwiRnJhbWVcIjtcbiAgICBJbWFnZUZyYW1lLmRlc2MgPSBcIkZyYW1lIHZpZXdlcmV3XCI7XG4gICAgSW1hZ2VGcmFtZS53aWRnZXRzID0gW1xuICAgICAgICB7IG5hbWU6IFwicmVzaXplXCIsIHRleHQ6IFwiUmVzaXplIGJveFwiLCB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgIHsgbmFtZTogXCJ2aWV3XCIsIHRleHQ6IFwiVmlldyBJbWFnZVwiLCB0eXBlOiBcImJ1dHRvblwiIH1cbiAgICBdO1xuXG4gICAgSW1hZ2VGcmFtZS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mcmFtZSAmJiAhdGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5mcmFtZSwgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlRnJhbWUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIEltYWdlRnJhbWUucHJvdG90eXBlLm9uV2lkZ2V0ID0gZnVuY3Rpb24oZSwgd2lkZ2V0KSB7XG4gICAgICAgIGlmICh3aWRnZXQubmFtZSA9PSBcInJlc2l6ZVwiICYmIHRoaXMuZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZnJhbWUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5mcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICghd2lkdGggJiYgdGhpcy5mcmFtZS52aWRlb1dpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuZnJhbWUudmlkZW9XaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmZyYW1lLnZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aWRnZXQubmFtZSA9PSBcInZpZXdcIikge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VGcmFtZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3ZhciBzdHIgPSB0aGlzLmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgIGlmIChzaG93RWxlbWVudCAmJiB0aGlzLmZyYW1lKSB7XG4gICAgICAgICAgICBzaG93RWxlbWVudCh0aGlzLmZyYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2ZyYW1lXCIsIEltYWdlRnJhbWUpO1xuXG4gICAgZnVuY3Rpb24gSW1hZ2VGYWRlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0cyhbXG4gICAgICAgICAgICBbXCJpbWcxXCIsIFwiaW1hZ2VcIl0sXG4gICAgICAgICAgICBbXCJpbWcyXCIsIFwiaW1hZ2VcIl0sXG4gICAgICAgICAgICBbXCJmYWRlXCIsIFwibnVtYmVyXCJdXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGZhZGU6IDAuNSwgd2lkdGg6IDUxMiwgaGVpZ2h0OiA1MTIgfTtcbiAgICB9XG5cbiAgICBJbWFnZUZhZGUudGl0bGUgPSBcIkltYWdlIGZhZGVcIjtcbiAgICBJbWFnZUZhZGUuZGVzYyA9IFwiRmFkZXMgYmV0d2VlbiBpbWFnZXNcIjtcbiAgICBJbWFnZUZhZGUud2lkZ2V0cyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInJlc2l6ZUFcIiwgdGV4dDogXCJSZXNpemUgdG8gQVwiLCB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgIHsgbmFtZTogXCJyZXNpemVCXCIsIHRleHQ6IFwiUmVzaXplIHRvIEJcIiwgdHlwZTogXCJidXR0b25cIiB9XG4gICAgXTtcblxuICAgIEltYWdlRmFkZS5wcm90b3R5cGUub25BZGRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLnByb3BlcnRpZXNbXCJ3aWR0aFwiXSwgdGhpcy5wcm9wZXJ0aWVzW1wiaGVpZ2h0XCJdKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VGYWRlLnByb3RvdHlwZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMucHJvcGVydGllc1tcIndpZHRoXCJdO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLnByb3BlcnRpZXNbXCJoZWlnaHRcIl07XG4gICAgfTtcblxuICAgIEltYWdlRmFkZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG5cbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKEEgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShBLCAwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmYWRlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG4gICAgICAgIGlmIChmYWRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGZhZGUgPSB0aGlzLnByb3BlcnRpZXNbXCJmYWRlXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiZmFkZVwiXSA9IGZhZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBmYWRlO1xuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuICAgICAgICBpZiAoQiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKEIsIDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5jYW52YXMpO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2ltYWdlZmFkZVwiLCBJbWFnZUZhZGUpO1xuXG4gICAgZnVuY3Rpb24gSW1hZ2VDcm9wKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwiaW1hZ2VcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiaW1hZ2VcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgd2lkdGg6IDI1NiwgaGVpZ2h0OiAyNTYsIHg6IDAsIHk6IDAsIHNjYWxlOiAxLjAgfTtcbiAgICAgICAgdGhpcy5zaXplID0gWzUwLCAyMF07XG4gICAgfVxuXG4gICAgSW1hZ2VDcm9wLnRpdGxlID0gXCJDcm9wXCI7XG4gICAgSW1hZ2VDcm9wLmRlc2MgPSBcIkNyb3AgSW1hZ2VcIjtcblxuICAgIEltYWdlQ3JvcC5wcm90b3R5cGUub25BZGRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgIH07XG5cbiAgICBJbWFnZUNyb3AucHJvdG90eXBlLmNyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5wcm9wZXJ0aWVzW1wid2lkdGhcIl07XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMucHJvcGVydGllc1tcImhlaWdodFwiXTtcbiAgICB9O1xuXG4gICAgSW1hZ2VDcm9wLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dC53aWR0aCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAtdGhpcy5wcm9wZXJ0aWVzW1wieFwiXSxcbiAgICAgICAgICAgICAgICAtdGhpcy5wcm9wZXJ0aWVzW1wieVwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dC53aWR0aCAqIHRoaXMucHJvcGVydGllc1tcInNjYWxlXCJdLFxuICAgICAgICAgICAgICAgIGlucHV0LmhlaWdodCAqIHRoaXMucHJvcGVydGllc1tcInNjYWxlXCJdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZUNyb3AucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVswXSxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVbMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VDcm9wLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChuYW1lID09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzW25hbWVdID09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gc2NhbGVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9jcm9wSW1hZ2VcIiwgSW1hZ2VDcm9wKTtcblxuICAgIC8vQ0FOVkFTIHN0dWZmXG5cbiAgICBmdW5jdGlvbiBDYW52YXNOb2RlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiY2xlYXJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHdpZHRoOiA1MTIsIGhlaWdodDogNTEyLCBhdXRvY2xlYXI6IHRydWUgfTtcblxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIH1cblxuICAgIENhbnZhc05vZGUudGl0bGUgPSBcIkNhbnZhc1wiO1xuICAgIENhbnZhc05vZGUuZGVzYyA9IFwiQ2FudmFzIHRvIHJlbmRlciBzdHVmZlwiO1xuXG4gICAgQ2FudmFzTm9kZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgdmFyIHcgPSB0aGlzLnByb3BlcnRpZXMud2lkdGggfCAwO1xuICAgICAgICB2YXIgaCA9IHRoaXMucHJvcGVydGllcy5oZWlnaHQgfCAwO1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9IHcpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbnZhcy5oZWlnaHQgIT0gaCkge1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmF1dG9jbGVhcikge1xuICAgICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGNhbnZhcyk7XG4gICAgfTtcblxuICAgIENhbnZhc05vZGUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAoYWN0aW9uID09IFwiY2xlYXJcIikge1xuICAgICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvY2FudmFzXCIsIENhbnZhc05vZGUpO1xuXG4gICAgZnVuY3Rpb24gRHJhd0ltYWdlTm9kZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNhbnZhc1wiLCBcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImltZ1wiLCBcImltYWdlLGNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInhcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ5XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAsIG9wYWNpdHk6IDEgfTtcbiAgICB9XG5cbiAgICBEcmF3SW1hZ2VOb2RlLnRpdGxlID0gXCJEcmF3SW1hZ2VcIjtcbiAgICBEcmF3SW1hZ2VOb2RlLmRlc2MgPSBcIkRyYXdzIGltYWdlIGludG8gYSBjYW52YXNcIjtcblxuICAgIERyYXdJbWFnZU5vZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1nID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJpbWdcIik7XG4gICAgICAgIGlmICghaW1nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwieFwiKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInlcIik7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgeCwgeSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvZHJhd0ltYWdlXCIsIERyYXdJbWFnZU5vZGUpO1xuXG4gICAgZnVuY3Rpb24gRHJhd1JlY3RhbmdsZU5vZGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjYW52YXNcIiwgXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwieVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIndcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJoXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHc6IDEwLFxuICAgICAgICAgICAgaDogMTAsXG4gICAgICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIERyYXdSZWN0YW5nbGVOb2RlLnRpdGxlID0gXCJEcmF3UmVjdGFuZ2xlXCI7XG4gICAgRHJhd1JlY3RhbmdsZU5vZGUuZGVzYyA9IFwiRHJhd3MgcmVjdGFuZ2xlIGluIGNhbnZhc1wiO1xuXG4gICAgRHJhd1JlY3RhbmdsZU5vZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwieFwiKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInlcIik7XG4gICAgICAgIHZhciB3ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ3XCIpO1xuICAgICAgICB2YXIgaCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiaFwiKTtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9kcmF3UmVjdGFuZ2xlXCIsIERyYXdSZWN0YW5nbGVOb2RlKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlVmlkZW8oKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ0XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dHMoW1tcImZyYW1lXCIsIFwiaW1hZ2VcIl0sIFtcInRcIiwgXCJudW1iZXJcIl0sIFtcImRcIiwgXCJudW1iZXJcIl1dKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB1cmw6IFwiXCIsIHVzZV9wcm94eTogdHJ1ZSB9O1xuICAgIH1cblxuICAgIEltYWdlVmlkZW8udGl0bGUgPSBcIlZpZGVvXCI7XG4gICAgSW1hZ2VWaWRlby5kZXNjID0gXCJWaWRlbyBwbGF5YmFja1wiO1xuICAgIEltYWdlVmlkZW8ud2lkZ2V0cyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInBsYXlcIiwgdGV4dDogXCJQTEFZXCIsIHR5cGU6IFwibWluaWJ1dHRvblwiIH0sXG4gICAgICAgIHsgbmFtZTogXCJzdG9wXCIsIHRleHQ6IFwiU1RPUFwiLCB0eXBlOiBcIm1pbmlidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwiZGVtb1wiLCB0ZXh0OiBcIkRlbW8gdmlkZW9cIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwibXV0ZVwiLCB0ZXh0OiBcIk11dGUgdmlkZW9cIiwgdHlwZTogXCJidXR0b25cIiB9XG4gICAgXTtcblxuICAgIEltYWdlVmlkZW8ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcy51cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMudXJsICE9IHRoaXMuX3ZpZGVvX3VybCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkVmlkZW8odGhpcy5wcm9wZXJ0aWVzLnVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvIHx8IHRoaXMuX3ZpZGVvLndpZHRoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh0ICYmIHQgPj0gMCAmJiB0IDw9IDEuMCkge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8uY3VycmVudFRpbWUgPSB0ICogdGhpcy5fdmlkZW8uZHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLl92aWRlby5wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlkZW8uZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmlkZW8pO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fdmlkZW8uY3VycmVudFRpbWUpO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMiwgdGhpcy5fdmlkZW8uZHVyYXRpb24pO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfTtcblxuICAgIEltYWdlVmlkZW8ucHJvdG90eXBlLmxvYWRWaWRlbyA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB0aGlzLl92aWRlb191cmwgPSB1cmw7XG5cblx0XHR2YXIgcG9zID0gdXJsLnN1YnN0cigwLDEwKS5pbmRleE9mKFwiOlwiKTtcblx0XHR2YXIgcHJvdG9jb2wgPSBcIlwiO1xuXHRcdGlmKHBvcyAhPSAtMSlcblx0XHRcdHByb3RvY29sID0gdXJsLnN1YnN0cigwLHBvcyk7XG5cblx0XHR2YXIgaG9zdCA9IFwiXCI7XG5cdFx0aWYocHJvdG9jb2wpXG5cdFx0e1xuXHRcdFx0aG9zdCA9IHVybC5zdWJzdHIoMCx1cmwuaW5kZXhPZihcIi9cIixwcm90b2NvbC5sZW5ndGggKyAzKSk7XG5cdFx0XHRob3N0ID0gaG9zdC5zdWJzdHIocHJvdG9jb2wubGVuZ3RoKzMpO1xuXHRcdH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudXNlX3Byb3h5ICYmXG4gICAgICAgICAgICBwcm90b2NvbCAmJlxuICAgICAgICAgICAgTGl0ZUdyYXBoLnByb3h5ICYmXG5cdFx0XHRob3N0ICE9IGxvY2F0aW9uLmhvc3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB1cmwgPSBMaXRlR3JhcGgucHJveHkgKyB1cmwuc3Vic3RyKHVybC5pbmRleE9mKFwiOlwiKSArIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgIHRoaXMuX3ZpZGVvLnNyYyA9IHVybDtcbiAgICAgICAgdGhpcy5fdmlkZW8udHlwZSA9IFwidHlwZT12aWRlby9tcDRcIjtcblxuICAgICAgICB0aGlzLl92aWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvL29ubG9hZFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJEdXJhdGlvbjogXCIgKyB0aGlzLmR1cmF0aW9uICsgXCIgc2Vjb25kc1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2l6ZTogXCIgKyB0aGlzLnZpZGVvV2lkdGggKyBcIixcIiArIHRoaXMudmlkZW9IZWlnaHQpO1xuICAgICAgICAgICAgdGhhdC5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudmlkZW9IZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy9vbmxvYWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmlkZW8gbG9hZGluZy4uLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyB2aWRlbzogXCIgKyB0aGlzLnNyYyk7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5lcnJvci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5lcnJvci5NRURJQV9FUlJfQUJPUlRFRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3Ugc3RvcHBlZCB0aGUgdmlkZW8uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5lcnJvci5NRURJQV9FUlJfTkVUV09SSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOZXR3b3JrIGVycm9yIC0gcGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmVycm9yLk1FRElBX0VSUl9ERUNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVmlkZW8gaXMgYnJva2VuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmVycm9yLk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTb3JyeSwgeW91ciBicm93c2VyIGNhbid0IHBsYXkgdGhpcyB2aWRlby5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3ZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZpZGVvIEVuZGVkLlwiKTtcbiAgICAgICAgICAgIHRoaXMucGxheSgpOyAvL2xvb3BcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudmlkZW8pO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAobmFtZSA9PSBcInVybFwiICYmIHZhbHVlICE9IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZFZpZGVvKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl92aWRlbyAmJiB0aGlzLl92aWRlby52aWRlb1dpZHRoICkgeyAvL2lzIGxvYWRlZFxuICAgICAgICAgICAgdGhpcy5fdmlkZW8ucGxheSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlVmlkZW8ucHJvdG90eXBlLnBsYXlQYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ZpZGVvLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgdGhpcy5fdmlkZW8uY3VycmVudFRpbWUgPSAwO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyBwYXVzZWRcIik7XG4gICAgICAgIHRoaXMuX3ZpZGVvLnBhdXNlKCk7XG4gICAgfTtcblxuICAgIEltYWdlVmlkZW8ucHJvdG90eXBlLm9uV2lkZ2V0ID0gZnVuY3Rpb24oZSwgd2lkZ2V0KSB7XG4gICAgICAgIC8qXG5cdGlmKHdpZGdldC5uYW1lID09IFwiZGVtb1wiKVxuXHR7XG5cdFx0dGhpcy5sb2FkVmlkZW8oKTtcblx0fVxuXHRlbHNlIGlmKHdpZGdldC5uYW1lID09IFwicGxheVwiKVxuXHR7XG5cdFx0aWYodGhpcy5fdmlkZW8pXG5cdFx0XHR0aGlzLnBsYXlQYXVzZSgpO1xuXHR9XG5cdGlmKHdpZGdldC5uYW1lID09IFwic3RvcFwiKVxuXHR7XG5cdFx0dGhpcy5zdG9wKCk7XG5cdH1cblx0ZWxzZSBpZih3aWRnZXQubmFtZSA9PSBcIm11dGVcIilcblx0e1xuXHRcdGlmKHRoaXMuX3ZpZGVvKVxuXHRcdFx0dGhpcy5fdmlkZW8ubXV0ZWQgPSAhdGhpcy5fdmlkZW8ubXV0ZWQ7XG5cdH1cblx0Ki9cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy92aWRlb1wiLCBJbWFnZVZpZGVvKTtcblxuICAgIC8vIFRleHR1cmUgV2ViY2FtICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgZnVuY3Rpb24gSW1hZ2VXZWJjYW0oKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiV2ViY2FtXCIsIFwiaW1hZ2VcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgZmlsdGVyRmFjaW5nTW9kZTogZmFsc2UsIGZhY2luZ01vZGU6IFwidXNlclwiIH07XG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgIH1cblxuICAgIEltYWdlV2ViY2FtLnRpdGxlID0gXCJXZWJjYW1cIjtcbiAgICBJbWFnZVdlYmNhbS5kZXNjID0gXCJXZWJjYW0gaW1hZ2VcIjtcbiAgICBJbWFnZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IGZhbHNlO1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9wZW5TdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldFVzZXJNZWRpYSgpIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLCB1c2UgY2hyb21lIGFuZCBlbmFibGUgV2ViUlRDIGZyb20gYWJvdXQ6Ly9mbGFncycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIC8vIE5vdCBzaG93aW5nIHZlbmRvciBwcmVmaXhlcy5cbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgdmlkZW86ICF0aGlzLnByb3BlcnRpZXMuZmlsdGVyRmFjaW5nTW9kZSA/IHRydWUgOiB7IGZhY2luZ01vZGU6IHRoaXMucHJvcGVydGllcy5mYWNpbmdNb2RlIH1cbiAgICAgICAgfTtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICAgICAgICAgICAgLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgICAgIC50aGVuKHRoaXMuc3RyZWFtUmVhZHkuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5jYXRjaChvbkZhaWxTb0hhcmQpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gb25GYWlsU29IYXJkKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2ViY2FtIHJlamVjdGVkXCIsIGUpO1xuICAgICAgICAgICAgdGhhdC5fd2ViY2FtX3N0cmVhbSA9IGZhbHNlO1xuICAgICAgICAgICAgSW1hZ2VXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcInJlZFwiO1xuICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFwic3RyZWFtX2Vycm9yXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5jbG9zZVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fd2ViY2FtX3N0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuX3dlYmNhbV9zdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICAgICAgICBpZiAodHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrc1tpXS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSW1hZ2VXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3dlYmNhbV9zdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcInN0cmVhbV9jbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJmYWNpbmdNb2RlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5mYWNpbmdNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdlYmNhbS5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLnN0cmVhbVJlYWR5ID0gZnVuY3Rpb24obG9jYWxNZWRpYVN0cmVhbSkge1xuICAgICAgICB0aGlzLl93ZWJjYW1fc3RyZWFtID0gbG9jYWxNZWRpYVN0cmVhbTtcbiAgICAgICAgLy90aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJncmVlblwiO1xuXG4gICAgICAgIHZhciB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgICAgICAgIHZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZGVvLnNyY09iamVjdCA9IGxvY2FsTWVkaWFTdHJlYW07XG4gICAgICAgICAgICB0aGlzLl92aWRlbyA9IHZpZGVvO1xuICAgICAgICAgICAgLy9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCB2aWRlbyApOyAvL2RlYnVnXG4gICAgICAgICAgICAvL3doZW4gdmlkZW8gaW5mbyBpcyBsb2FkZWQgKHNpemUgYW5kIHNvKVxuICAgICAgICAgICAgdmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFkeSB0byBnby4gRG8gc29tZSBzdHVmZi5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICBJbWFnZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKFwic3RyZWFtX3JlYWR5XCIsIHZpZGVvKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fd2ViY2FtX3N0cmVhbSA9PSBudWxsICYmICF0aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvIHx8ICF0aGlzLl92aWRlby52aWRlb1dpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92aWRlby5mcmFtZSA9ICsrdGhpcy5mcmFtZTtcbiAgICAgICAgdGhpcy5fdmlkZW8ud2lkdGggPSB0aGlzLl92aWRlby52aWRlb1dpZHRoO1xuICAgICAgICB0aGlzLl92aWRlby5oZWlnaHQgPSB0aGlzLl92aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZpZGVvKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRwdXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMub3V0cHV0c1tpXS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCB0aGlzLl92aWRlby52aWRlb1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9IZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdlYmNhbS5wcm90b3R5cGUuZ2V0RXh0cmFNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKGdyYXBoY2FudmFzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHR4dCA9ICF0aGF0LnByb3BlcnRpZXMuc2hvdyA/IFwiU2hvdyBGcmFtZVwiIDogXCJIaWRlIEZyYW1lXCI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdHh0LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wcm9wZXJ0aWVzLnNob3cgPSAhdGhhdC5wcm9wZXJ0aWVzLnNob3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBJbWFnZVdlYmNhbS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmZsYWdzLmNvbGxhcHNlZCB8fFxuICAgICAgICAgICAgdGhpcy5zaXplWzFdIDw9IDIwIHx8XG4gICAgICAgICAgICAhdGhpcy5wcm9wZXJ0aWVzLnNob3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlciB0byBncmFwaCBjYW52YXNcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl92aWRlbywgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBJbWFnZVdlYmNhbS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbXCJ3aWR0aFwiLCBcIm51bWJlclwiXSxcbiAgICAgICAgICAgIFtcImhlaWdodFwiLCBcIm51bWJlclwiXSxcbiAgICAgICAgICAgIFtcInN0cmVhbV9yZWFkeVwiLCBMaXRlR3JhcGguRVZFTlRdLFxuICAgICAgICAgICAgW1wic3RyZWFtX2Nsb3NlZFwiLCBMaXRlR3JhcGguRVZFTlRdLFxuICAgICAgICAgICAgW1wic3RyZWFtX2Vycm9yXCIsIExpdGVHcmFwaC5FVkVOVF1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy93ZWJjYW1cIiwgSW1hZ2VXZWJjYW0pO1xufSkodGhpcyk7XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcblx0dmFyIExHcmFwaENhbnZhcyA9IGdsb2JhbC5MR3JhcGhDYW52YXM7XG5cbiAgICAvL1dvcmtzIHdpdGggTGl0ZWdsLmpzIHRvIGNyZWF0ZSBXZWJHTCBub2Rlc1xuICAgIGdsb2JhbC5MR3JhcGhUZXh0dXJlID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgR0wgPT0gXCJ1bmRlZmluZWRcIilcblx0XHRyZXR1cm47XG5cblx0TEdyYXBoQ2FudmFzLmxpbmtfdHlwZV9jb2xvcnNbXCJUZXh0dXJlXCJdID0gXCIjOTg3XCI7XG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZSgpIHtcblx0XHR0aGlzLmFkZE91dHB1dChcInRleFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJuYW1lXCIsIFwic3RyaW5nXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgbmFtZTogXCJcIiwgZmlsdGVyOiB0cnVlIH07XG5cdFx0dGhpcy5zaXplID0gW1xuXHRcdFx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemUsXG5cdFx0XHRMR3JhcGhUZXh0dXJlLmltYWdlX3ByZXZpZXdfc2l6ZVxuXHRcdF07XG5cdH1cblxuXHRnbG9iYWwuTEdyYXBoVGV4dHVyZSA9IExHcmFwaFRleHR1cmU7XG5cblx0TEdyYXBoVGV4dHVyZS50aXRsZSA9IFwiVGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlLmRlc2MgPSBcIlRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZS53aWRnZXRzX2luZm8gPSB7XG5cdFx0bmFtZTogeyB3aWRnZXQ6IFwidGV4dHVyZVwiIH0sXG5cdFx0ZmlsdGVyOiB7IHdpZGdldDogXCJjaGVja2JveFwiIH1cblx0fTtcblxuXHQvL1JFUExBQ0UgVEhJUyBUTyBJTlRFR1JBVEUgV0lUSCBZT1VSIEZSQU1FV09SS1xuXHRMR3JhcGhUZXh0dXJlLmxvYWRUZXh0dXJlQ2FsbGJhY2sgPSBudWxsOyAvL2Z1bmN0aW9uIGluIGNoYXJnZSBvZiBsb2FkaW5nIHRleHR1cmVzIHdoZW4gbm90IHByZXNlbnQgaW4gdGhlIGNvbnRhaW5lclxuXHRMR3JhcGhUZXh0dXJlLmltYWdlX3ByZXZpZXdfc2l6ZSA9IDI1NjtcblxuXHQvL2ZsYWdzIHRvIGNob29zZSBvdXRwdXQgdGV4dHVyZSB0eXBlXG5cdExHcmFwaFRleHR1cmUuVU5ERUZJTkVEID0gMDsgLy9ub3Qgc3BlY2lmaWVkXG5cdExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIID0gMTsgLy9kbyBub3QgYXBwbHkgRlggKGxpa2UgZGlzYWJsZSBidXQgcGFzc2luZyB0aGUgaW4gdG8gdGhlIG91dClcblx0TEdyYXBoVGV4dHVyZS5DT1BZID0gMjsgLy9jcmVhdGUgbmV3IHRleHR1cmUgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBvcmlnaW4gdGV4dHVyZVxuXHRMR3JhcGhUZXh0dXJlLkxPVyA9IDM7IC8vY3JlYXRlIG5ldyB0ZXh0dXJlIHdpdGggbG93IHByZWNpc2lvbiAoYnl0ZSlcblx0TEdyYXBoVGV4dHVyZS5ISUdIID0gNDsgLy9jcmVhdGUgbmV3IHRleHR1cmUgd2l0aCBoaWdoIHByZWNpc2lvbiAoaGFsZi1mbG9hdClcblx0TEdyYXBoVGV4dHVyZS5SRVVTRSA9IDU7IC8vcmV1c2UgaW5wdXQgdGV4dHVyZVxuXHRMR3JhcGhUZXh0dXJlLkRFRkFVTFQgPSAyOyAvL3VzZSB0aGUgZGVmYXVsdFxuXG5cdExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgPSB7XG5cdFx0XCJ1bmRlZmluZWRcIjogTEdyYXBoVGV4dHVyZS5VTkRFRklORUQsXG5cdFx0XCJwYXNzIHRocm91Z2hcIjogTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gsXG5cdFx0Y29weTogTEdyYXBoVGV4dHVyZS5DT1BZLFxuXHRcdGxvdzogTEdyYXBoVGV4dHVyZS5MT1csXG5cdFx0aGlnaDogTEdyYXBoVGV4dHVyZS5ISUdILFxuXHRcdHJldXNlOiBMR3JhcGhUZXh0dXJlLlJFVVNFLFxuXHRcdGRlZmF1bHQ6IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHR9O1xuXG5cdC8vcmV0dXJucyB0aGUgY29udGFpbmVyIHdoZXJlIGFsbCB0aGUgbG9hZGVkIHRleHR1cmVzIGFyZSBzdG9yZWQgKG92ZXJ3cml0ZSBpZiB5b3UgaGF2ZSBhIFJlc291cmNlcyBNYW5hZ2VyKVxuXHRMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVzQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdsLnRleHR1cmVzO1xuXHR9O1xuXG5cdC8vcHJvY2VzcyB0aGUgbG9hZGluZyBvZiBhIHRleHR1cmUgKG92ZXJ3cml0ZSBpdCBpZiB5b3UgaGF2ZSBhIFJlc291cmNlcyBNYW5hZ2VyKVxuXHRMR3JhcGhUZXh0dXJlLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHZhciB1cmwgPSBuYW1lO1xuXHRcdGlmICh1cmwuc3Vic3RyKDAsIDcpID09IFwiaHR0cDovL1wiKSB7XG5cdFx0XHRpZiAoTGl0ZUdyYXBoLnByb3h5KSB7XG5cdFx0XHRcdC8vcHJveHkgZXh0ZXJuYWwgZmlsZXNcblx0XHRcdFx0dXJsID0gTGl0ZUdyYXBoLnByb3h5ICsgdXJsLnN1YnN0cig3KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29udGFpbmVyID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlc0NvbnRhaW5lcigpO1xuXHRcdHZhciB0ZXggPSAoY29udGFpbmVyW25hbWVdID0gR0wuVGV4dHVyZS5mcm9tVVJMKHVybCwgb3B0aW9ucykpO1xuXHRcdHJldHVybiB0ZXg7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLmdldFRleHR1cmVzQ29udGFpbmVyKCk7XG5cblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0dGhyb3cgXCJDYW5ub3QgbG9hZCB0ZXh0dXJlLCBjb250YWluZXIgb2YgdGV4dHVyZXMgbm90IGZvdW5kXCI7XG5cdFx0fVxuXG5cdFx0dmFyIHRleCA9IGNvbnRhaW5lcltuYW1lXTtcblx0XHRpZiAoIXRleCAmJiBuYW1lICYmIG5hbWVbMF0gIT0gXCI6XCIpIHtcblx0XHRcdHJldHVybiB0aGlzLmxvYWRUZXh0dXJlKG5hbWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0ZXg7XG5cdH07XG5cblx0Ly91c2VkIHRvIGNvbXB1dGUgdGhlIGFwcHJvcGlhdGUgb3V0cHV0IHRleHR1cmVcblx0TEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlID0gZnVuY3Rpb24ob3JpZ2luLCB0YXJnZXQsIG1vZGUpIHtcblx0XHRpZiAoIW9yaWdpbikge1xuXHRcdFx0dGhyb3cgXCJMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUgZXhwZWN0cyBhIHJlZmVyZW5jZSB0ZXh0dXJlXCI7XG5cdFx0fVxuXG5cdFx0dmFyIHRleF90eXBlID0gbnVsbDtcblxuXHRcdHN3aXRjaCAobW9kZSkge1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLkxPVzpcblx0XHRcdFx0dGV4X3R5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgTEdyYXBoVGV4dHVyZS5ISUdIOlxuXHRcdFx0XHR0ZXhfdHlwZSA9IGdsLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIExHcmFwaFRleHR1cmUuUkVVU0U6XG5cdFx0XHRcdHJldHVybiBvcmlnaW47XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLkNPUFk6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0ZXhfdHlwZSA9IG9yaWdpbiA/IG9yaWdpbi50eXBlIDogZ2wuVU5TSUdORURfQllURTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0IXRhcmdldCB8fFxuXHRcdFx0dGFyZ2V0LndpZHRoICE9IG9yaWdpbi53aWR0aCB8fFxuXHRcdFx0dGFyZ2V0LmhlaWdodCAhPSBvcmlnaW4uaGVpZ2h0IHx8XG5cdFx0XHR0YXJnZXQudHlwZSAhPSB0ZXhfdHlwZSB8fFxuXHRcdFx0dGFyZ2V0LmZvcm1hdCAhPSBvcmlnaW4uZm9ybWF0IFxuXHRcdCkge1xuXHRcdFx0dGFyZ2V0ID0gbmV3IEdMLlRleHR1cmUob3JpZ2luLndpZHRoLCBvcmlnaW4uaGVpZ2h0LCB7XG5cdFx0XHRcdHR5cGU6IHRleF90eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IG9yaWdpbi5mb3JtYXQsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUgPSBmdW5jdGlvbihwcmVjaXNpb24sIHJlZl90ZXh0dXJlKSB7XG5cdFx0dmFyIHR5cGUgPSByZWZfdGV4dHVyZSA/IHJlZl90ZXh0dXJlLnR5cGUgOiBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdHN3aXRjaCAocHJlY2lzaW9uKSB7XG5cdFx0XHRjYXNlIExHcmFwaFRleHR1cmUuSElHSDpcblx0XHRcdFx0dHlwZSA9IGdsLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIExHcmFwaFRleHR1cmUuTE9XOlxuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHQvL25vIGRlZmF1bHRcblx0XHR9XG5cdFx0cmV0dXJuIHR5cGU7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5nZXRXaGl0ZVRleHR1cmUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fd2hpdGVfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3doaXRlX3RleHR1cmU7XG5cdFx0fVxuXHRcdHZhciB0ZXh0dXJlID0gKHRoaXMuX3doaXRlX3RleHR1cmUgPSBHTC5UZXh0dXJlLmZyb21NZW1vcnkoXG5cdFx0XHQxLFxuXHRcdFx0MSxcblx0XHRcdFsyNTUsIDI1NSwgMjU1LCAyNTVdLFxuXHRcdFx0eyBmb3JtYXQ6IGdsLlJHQkEsIHdyYXA6IGdsLlJFUEVBVCwgZmlsdGVyOiBnbC5ORUFSRVNUIH1cblx0XHQpKTtcblx0XHRyZXR1cm4gdGV4dHVyZTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLmdldE5vaXNlVGV4dHVyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9ub2lzZV90ZXh0dXJlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbm9pc2VfdGV4dHVyZTtcblx0XHR9XG5cblx0XHR2YXIgbm9pc2UgPSBuZXcgVWludDhBcnJheSg1MTIgKiA1MTIgKiA0KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDUxMiAqIDUxMiAqIDQ7ICsraSkge1xuXHRcdFx0bm9pc2VbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1O1xuXHRcdH1cblxuXHRcdHZhciB0ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tTWVtb3J5KDUxMiwgNTEyLCBub2lzZSwge1xuXHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0d3JhcDogZ2wuUkVQRUFULFxuXHRcdFx0ZmlsdGVyOiBnbC5ORUFSRVNUXG5cdFx0fSk7XG5cdFx0dGhpcy5fbm9pc2VfdGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGRhdGEsIGZpbGVuYW1lLCBmaWxlKSB7XG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHR0aGlzLl9kcm9wX3RleHR1cmUgPSBudWxsO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLm5hbWUgPSBcIlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdGV4dHVyZSA9IG51bGw7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR0ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tVVJMKGRhdGEpO1xuXHRcdFx0fSBlbHNlIGlmIChmaWxlbmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCIuZGRzXCIpICE9IC0xKSB7XG5cdFx0XHRcdHRleHR1cmUgPSBHTC5UZXh0dXJlLmZyb21ERFNJbk1lbW9yeShkYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoW2ZpbGVdKTtcblx0XHRcdFx0dmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRcdHRleHR1cmUgPSBHTC5UZXh0dXJlLmZyb21VUkwodXJsKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZHJvcF90ZXh0dXJlID0gdGV4dHVyZTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5uYW1lID0gZmlsZW5hbWU7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRpZiAoIXRoaXMuX2Ryb3BfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyZXR1cm4gW1xuXHRcdFx0e1xuXHRcdFx0XHRjb250ZW50OiBcIkNsZWFyXCIsXG5cdFx0XHRcdGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGF0Ll9kcm9wX3RleHR1cmUgPSBudWxsO1xuXHRcdFx0XHRcdHRoYXQucHJvcGVydGllcy5uYW1lID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IG51bGw7XG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkpIHtcblx0XHRcdHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdH1cblxuXHRcdGlmICghdGV4ICYmIHRoaXMuX2Ryb3BfdGV4dHVyZSkge1xuXHRcdFx0dGV4ID0gdGhpcy5fZHJvcF90ZXh0dXJlO1xuXHRcdH1cblxuXHRcdGlmICghdGV4ICYmIHRoaXMucHJvcGVydGllcy5uYW1lKSB7XG5cdFx0XHR0ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmUodGhpcy5wcm9wZXJ0aWVzLm5hbWUpO1xuXHRcdH1cblxuXHRcdGlmICghdGV4KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIG51bGwgKTtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMSwgXCJcIiApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xhc3RfdGV4ID0gdGV4O1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5maWx0ZXIgPT09IGZhbHNlKSB7XG5cdFx0XHR0ZXguc2V0UGFyYW1ldGVyKGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleC5zZXRQYXJhbWV0ZXIoZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGV4ICk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAxLCB0ZXguZnVsbHBhdGggfHwgdGV4LmZpbGVuYW1lICk7XG5cblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcblx0XHRcdGlmICghb3V0cHV0KSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHYgPSBudWxsO1xuXHRcdFx0aWYgKG91dHB1dC5uYW1lID09IFwid2lkdGhcIikge1xuXHRcdFx0XHR2ID0gdGV4LndpZHRoO1xuXHRcdFx0fSBlbHNlIGlmIChvdXRwdXQubmFtZSA9PSBcImhlaWdodFwiKSB7XG5cdFx0XHRcdHYgPSB0ZXguaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChvdXRwdXQubmFtZSA9PSBcImFzcGVjdFwiKSB7XG5cdFx0XHRcdHYgPSB0ZXgud2lkdGggLyB0ZXguaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKGksIHYpO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLnByb3RvdHlwZS5vblJlc291cmNlUmVuYW1lZCA9IGZ1bmN0aW9uKFxuXHRcdG9sZF9uYW1lLFxuXHRcdG5ld19uYW1lXG5cdCkge1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMubmFtZSA9PSBvbGRfbmFtZSkge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLm5hbWUgPSBuZXdfbmFtZTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCB8fCB0aGlzLnNpemVbMV0gPD0gMjApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fZHJvcF90ZXh0dXJlICYmIGN0eC53ZWJnbCkge1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShcblx0XHRcdFx0dGhpcy5fZHJvcF90ZXh0dXJlLFxuXHRcdFx0XHQwLFxuXHRcdFx0XHQwLFxuXHRcdFx0XHR0aGlzLnNpemVbMF0sXG5cdFx0XHRcdHRoaXMuc2l6ZVsxXVxuXHRcdFx0KTtcblx0XHRcdC8vdGhpcy5fZHJvcF90ZXh0dXJlLnJlbmRlclF1YWQodGhpcy5wb3NbMF0sdGhpcy5wb3NbMV0sdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9EaWZmZXJlbnQgdGV4dHVyZT8gdGhlbiBnZXQgaXQgZnJvbSB0aGUgR1BVXG5cdFx0aWYgKHRoaXMuX2xhc3RfcHJldmlld190ZXggIT0gdGhpcy5fbGFzdF90ZXgpIHtcblx0XHRcdGlmIChjdHgud2ViZ2wpIHtcblx0XHRcdFx0dGhpcy5fY2FudmFzID0gdGhpcy5fbGFzdF90ZXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGV4X2NhbnZhcyA9IExHcmFwaFRleHR1cmUuZ2VuZXJhdGVMb3dSZXNUZXh0dXJlUHJldmlldyhcblx0XHRcdFx0XHR0aGlzLl9sYXN0X3RleFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoIXRleF9jYW52YXMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9sYXN0X3ByZXZpZXdfdGV4ID0gdGhpcy5fbGFzdF90ZXg7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcyA9IGNsb25lQ2FudmFzKHRleF9jYW52YXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9yZW5kZXIgdG8gZ3JhcGggY2FudmFzXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRpZiAoIWN0eC53ZWJnbCkge1xuXHRcdFx0Ly9yZXZlcnNlIGltYWdlXG5cdFx0XHRjdHgudHJhbnNsYXRlKDAsIHRoaXMuc2l6ZVsxXSk7XG5cdFx0XHRjdHguc2NhbGUoMSwgLTEpO1xuXHRcdH1cblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX2NhbnZhcywgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0Ly92ZXJ5IHNsb3csIHVzZWQgYXQgeW91ciBvd24gcmlza1xuXHRMR3JhcGhUZXh0dXJlLmdlbmVyYXRlTG93UmVzVGV4dHVyZVByZXZpZXcgPSBmdW5jdGlvbih0ZXgpIHtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHNpemUgPSBMR3JhcGhUZXh0dXJlLmltYWdlX3ByZXZpZXdfc2l6ZTtcblx0XHR2YXIgdGVtcF90ZXggPSB0ZXg7XG5cblx0XHRpZiAodGV4LmZvcm1hdCA9PSBnbC5ERVBUSF9DT01QT05FTlQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gLy9jYW5ub3QgZ2VuZXJhdGUgZnJvbSBkZXB0aFxuXG5cdFx0Ly9HZW5lcmF0ZSBsb3ctbGV2ZWwgdmVyc2lvbiBpbiB0aGUgR1BVIHRvIHNwZWVkIHVwXG5cdFx0aWYgKHRleC53aWR0aCA+IHNpemUgfHwgdGV4LmhlaWdodCA+IHNpemUpIHtcblx0XHRcdHRlbXBfdGV4ID0gdGhpcy5fcHJldmlld190ZW1wX3RleDtcblx0XHRcdGlmICghdGhpcy5fcHJldmlld190ZW1wX3RleCkge1xuXHRcdFx0XHR0ZW1wX3RleCA9IG5ldyBHTC5UZXh0dXJlKHNpemUsIHNpemUsIHtcblx0XHRcdFx0XHRtaW5GaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX3ByZXZpZXdfdGVtcF90ZXggPSB0ZW1wX3RleDtcblx0XHRcdH1cblxuXHRcdFx0Ly9jb3B5XG5cdFx0XHR0ZXguY29weVRvKHRlbXBfdGV4KTtcblx0XHRcdHRleCA9IHRlbXBfdGV4O1xuXHRcdH1cblxuXHRcdC8vY3JlYXRlIGludGVybWVkaWF0ZSBjYW52YXMgd2l0aCBsb3dxdWFsaXR5IHZlcnNpb25cblx0XHR2YXIgdGV4X2NhbnZhcyA9IHRoaXMuX3ByZXZpZXdfY2FudmFzO1xuXHRcdGlmICghdGV4X2NhbnZhcykge1xuXHRcdFx0dGV4X2NhbnZhcyA9IGNyZWF0ZUNhbnZhcyhzaXplLCBzaXplKTtcblx0XHRcdHRoaXMuX3ByZXZpZXdfY2FudmFzID0gdGV4X2NhbnZhcztcblx0XHR9XG5cblx0XHRpZiAodGVtcF90ZXgpIHtcblx0XHRcdHRlbXBfdGV4LnRvQ2FudmFzKHRleF9jYW52YXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGV4X2NhbnZhcztcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLnByb3RvdHlwZS5nZXRSZXNvdXJjZXMgPSBmdW5jdGlvbihyZXMpIHtcblx0XHRpZih0aGlzLnByb3BlcnRpZXMubmFtZSlcblx0XHRcdHJlc1t0aGlzLnByb3BlcnRpZXMubmFtZV0gPSBHTC5UZXh0dXJlO1xuXHRcdHJldHVybiByZXM7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImluXCIsIFwiVGV4dHVyZVwiXV07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcIndpZHRoXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiaGVpZ2h0XCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiYXNwZWN0XCIsIFwibnVtYmVyXCJdXG5cdFx0XTtcblx0fTtcblxuXHQvL3VzZWQgdG8gcmVwbGFjZSBzaGFkZXIgY29kZVxuXHRMR3JhcGhUZXh0dXJlLnJlcGxhY2VDb2RlID0gZnVuY3Rpb24oIGNvZGUsIGNvbnRleHQgKVxuXHR7XG5cdFx0cmV0dXJuIGNvZGUucmVwbGFjZSgvXFx7XFx7W2EtekEtWjAtOV9dKlxcfVxcfS9nLCBmdW5jdGlvbih2KXtcblx0XHRcdHYgPSB2LnJlcGxhY2UoIC9bXFx7XFx9XS9nLCBcIlwiICk7XG5cdFx0XHRyZXR1cm4gY29udGV4dFt2XSB8fCBcIlwiO1xuXHRcdH0pO1xuXHR9XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3RleHR1cmVcIiwgTEdyYXBoVGV4dHVyZSk7XG5cblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlUHJldmlldygpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBmbGlwWTogZmFsc2UgfTtcblx0XHR0aGlzLnNpemUgPSBbXG5cdFx0XHRMR3JhcGhUZXh0dXJlLmltYWdlX3ByZXZpZXdfc2l6ZSxcblx0XHRcdExHcmFwaFRleHR1cmUuaW1hZ2VfcHJldmlld19zaXplXG5cdFx0XTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVQcmV2aWV3LnRpdGxlID0gXCJQcmV2aWV3XCI7XG5cdExHcmFwaFRleHR1cmVQcmV2aWV3LmRlc2MgPSBcIlNob3cgYSB0ZXh0dXJlIGluIHRoZSBncmFwaCBjYW52YXNcIjtcblx0TEdyYXBoVGV4dHVyZVByZXZpZXcuYWxsb3dfcHJldmlldyA9IGZhbHNlO1xuXG5cdExHcmFwaFRleHR1cmVQcmV2aWV3LnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCFjdHgud2ViZ2wgJiYgIUxHcmFwaFRleHR1cmVQcmV2aWV3LmFsbG93X3ByZXZpZXcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vbm90IHdvcmtpbmcgd2VsbFxuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRleF9jYW52YXMgPSBudWxsO1xuXG5cdFx0aWYgKCF0ZXguaGFuZGxlICYmIGN0eC53ZWJnbCkge1xuXHRcdFx0dGV4X2NhbnZhcyA9IHRleDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGV4X2NhbnZhcyA9IExHcmFwaFRleHR1cmUuZ2VuZXJhdGVMb3dSZXNUZXh0dXJlUHJldmlldyh0ZXgpO1xuXHRcdH1cblxuXHRcdC8vcmVuZGVyIHRvIGdyYXBoIGNhbnZhc1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5mbGlwWSkge1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCB0aGlzLnNpemVbMV0pO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIC0xKTtcblx0XHR9XG5cdFx0Y3R4LmRyYXdJbWFnZSh0ZXhfY2FudmFzLCAwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvcHJldmlld1wiLCBMR3JhcGhUZXh0dXJlUHJldmlldyk7XG5cblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVTYXZlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcInRleFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJuYW1lXCIsIFwic3RyaW5nXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgbmFtZTogXCJcIiwgZ2VuZXJhdGVfbWlwbWFwczogZmFsc2UgfTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVTYXZlLnRpdGxlID0gXCJTYXZlXCI7XG5cdExHcmFwaFRleHR1cmVTYXZlLmRlc2MgPSBcIlNhdmUgYSB0ZXh0dXJlIGluIHRoZSByZXBvc2l0b3J5XCI7XG5cblx0TEdyYXBoVGV4dHVyZVNhdmUucHJvdG90eXBlLmdldFByZXZpZXdUZXh0dXJlID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3RleHR1cmU7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlU2F2ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHRleC5zZXRQYXJhbWV0ZXIoIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgKTtcblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKHRleC50ZXh0dXJlX3R5cGUpO1xuXHRcdFx0dGV4LnVuYmluZCgwKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLm5hbWUpIHtcblx0XHRcdC8vZm9yIGNhc2VzIHdoZXJlIHdlIHdhbnQgdG8gcGVyZm9ybSBzb21ldGhpbmcgd2hlbiBzdG9yaW5nIGl0XG5cdFx0XHRpZiAoTEdyYXBoVGV4dHVyZS5zdG9yZVRleHR1cmUpIHtcblx0XHRcdFx0TEdyYXBoVGV4dHVyZS5zdG9yZVRleHR1cmUodGhpcy5wcm9wZXJ0aWVzLm5hbWUsIHRleCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgY29udGFpbmVyID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlc0NvbnRhaW5lcigpO1xuXHRcdFx0XHRjb250YWluZXJbdGhpcy5wcm9wZXJ0aWVzLm5hbWVdID0gdGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3RleHR1cmUgPSB0ZXg7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMucHJvcGVydGllcy5uYW1lKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvc2F2ZVwiLCBMR3JhcGhUZXh0dXJlU2F2ZSk7XG5cblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZU9wZXJhdGlvbigpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVCXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwidmFsdWVcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmhlbHAgPSBcIjxwPnBpeGVsY29kZSBtdXN0IGJlIHZlYzMsIHV2Y29kZSBtdXN0IGJlIHZlYzIsIGlzIG9wdGlvbmFsPC9wPlxcXG5cdFx0PHA+PHN0cm9uZz51djo8L3N0cm9uZz4gdGV4LiBjb29yZHM8L3A+PHA+PHN0cm9uZz5jb2xvcjo8L3N0cm9uZz4gdGV4dHVyZSA8c3Ryb25nPmNvbG9yQjo8L3N0cm9uZz4gdGV4dHVyZUI8L3A+PHA+PHN0cm9uZz50aW1lOjwvc3Ryb25nPiBzY2VuZSB0aW1lIDxzdHJvbmc+dmFsdWU6PC9zdHJvbmc+IGlucHV0IHZhbHVlPC9wPjxwPkZvciBtdWx0aWxpbmUgeW91IG11c3QgdHlwZTogcmVzdWx0ID0gLi4uPC9wPlwiO1xuXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0dmFsdWU6IDEsXG5cdFx0XHRwaXhlbGNvZGU6IFwiY29sb3IgKyBjb2xvckIgKiB2YWx1ZVwiLFxuXHRcdFx0dXZjb2RlOiBcIlwiLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXG5cdFx0dGhpcy5oYXNfZXJyb3IgPSBmYWxzZTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ud2lkZ2V0c19pbmZvID0ge1xuXHRcdHV2Y29kZTogeyB3aWRnZXQ6IFwiY29kZVwiIH0sXG5cdFx0cGl4ZWxjb2RlOiB7IHdpZGdldDogXCJjb2RlXCIgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi50aXRsZSA9IFwiT3BlcmF0aW9uXCI7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24uZGVzYyA9IFwiVGV4dHVyZSBzaGFkZXIgb3BlcmF0aW9uXCI7XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcmVzZXRzID0ge307XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0RXh0cmFNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKFxuXHRcdGdyYXBoY2FudmFzXG5cdCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgdHh0ID0gIXRoYXQucHJvcGVydGllcy5zaG93ID8gXCJTaG93IFRleHR1cmVcIiA6IFwiSGlkZSBUZXh0dXJlXCI7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0Y29udGVudDogdHh0LFxuXHRcdFx0XHRjYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5wcm9wZXJ0aWVzLnNob3cgPSAhdGhhdC5wcm9wZXJ0aWVzLnNob3c7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0dGhpcy5oYXNfZXJyb3IgPSBmYWxzZTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoXG5cdFx0XHR0aGlzLmZsYWdzLmNvbGxhcHNlZCB8fFxuXHRcdFx0dGhpcy5zaXplWzFdIDw9IDIwIHx8XG5cdFx0XHQhdGhpcy5wcm9wZXJ0aWVzLnNob3dcblx0XHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3RleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vb25seSB3b3JrcyBpZiB1c2luZyBhIHdlYmdsIHJlbmRlcmVyXG5cdFx0aWYgKHRoaXMuX3RleC5nbCAhPSBjdHgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL3JlbmRlciB0byBncmFwaCBjYW52YXNcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5fdGV4LCAwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGV4QiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXG5cdFx0aWYgKCF0aGlzLnByb3BlcnRpZXMudXZjb2RlICYmICF0aGlzLnByb3BlcnRpZXMucGl4ZWxjb2RlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHdpZHRoID0gNTEyO1xuXHRcdHZhciBoZWlnaHQgPSA1MTI7XG5cdFx0aWYgKHRleCkge1xuXHRcdFx0d2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSB0ZXguaGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAodGV4Qikge1xuXHRcdFx0d2lkdGggPSB0ZXhCLndpZHRoO1xuXHRcdFx0aGVpZ2h0ID0gdGV4Qi5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0aWYoIXRleEIpXG5cdFx0XHR0ZXhCID0gR0wuVGV4dHVyZS5nZXRXaGl0ZVRleHR1cmUoKTtcblxuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiwgdGV4ICk7XG5cblx0XHRpZiAoIXRleCAmJiAhdGhpcy5fdGV4KSB7XG5cdFx0XHR0aGlzLl90ZXggPSBuZXcgR0wuVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCB7IHR5cGU6IHR5cGUsIGZvcm1hdDogZ2wuUkdCQSwgZmlsdGVyOiBnbC5MSU5FQVIgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZSggdGV4IHx8IHRoaXMuX3RleCwgdGhpcy5fdGV4LCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uICk7XG5cdFx0fVxuXG5cdFx0dmFyIHV2Y29kZSA9IFwiXCI7XG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy51dmNvZGUpIHtcblx0XHRcdHV2Y29kZSA9IFwidXYgPSBcIiArIHRoaXMucHJvcGVydGllcy51dmNvZGU7XG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnV2Y29kZS5pbmRleE9mKFwiO1wiKSAhPSAtMSkge1xuXHRcdFx0XHQvL3RoZXJlIGFyZSBsaW5lIGJyZWFrcywgbWVhbnMgbXVsdGlsaW5lIGNvZGVcblx0XHRcdFx0dXZjb2RlID0gdGhpcy5wcm9wZXJ0aWVzLnV2Y29kZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgcGl4ZWxjb2RlID0gXCJcIjtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnBpeGVsY29kZSkge1xuXHRcdFx0cGl4ZWxjb2RlID0gXCJyZXN1bHQgPSBcIiArIHRoaXMucHJvcGVydGllcy5waXhlbGNvZGU7XG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnBpeGVsY29kZS5pbmRleE9mKFwiO1wiKSAhPSAtMSkge1xuXHRcdFx0XHQvL3RoZXJlIGFyZSBsaW5lIGJyZWFrcywgbWVhbnMgbXVsdGlsaW5lIGNvZGVcblx0XHRcdFx0cGl4ZWxjb2RlID0gdGhpcy5wcm9wZXJ0aWVzLnBpeGVsY29kZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuXG5cdFx0aWYgKCAhdGhpcy5oYXNfZXJyb3IgJiYgKCFzaGFkZXIgfHwgdGhpcy5fc2hhZGVyX2NvZGUgIT0gdXZjb2RlICsgXCJ8XCIgKyBwaXhlbGNvZGUpICkge1xuXG5cdFx0XHR2YXIgZmluYWxfcGl4ZWxfY29kZSA9IExHcmFwaFRleHR1cmUucmVwbGFjZUNvZGUoIExHcmFwaFRleHR1cmVPcGVyYXRpb24ucGl4ZWxfc2hhZGVyLCB7IFVWX0NPREU6dXZjb2RlLCBQSVhFTF9DT0RFOnBpeGVsY29kZSB9KTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2hhZGVyID0gbmV3IEdMLlNoYWRlciggU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBmaW5hbF9waXhlbF9jb2RlICk7XG5cdFx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiMwMEZGMDBcIjtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiRXJyb3IgY29tcGlsaW5nIHNoYWRlcjogXCIsIGVyciwgZmluYWxfcGl4ZWxfY29kZSApO1xuXHRcdFx0XHRHTC5TaGFkZXIuZHVtcEVycm9yVG9Db25zb2xlKGVycixTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsIGZpbmFsX3BpeGVsX2NvZGUpO1xuXHRcdFx0XHR0aGlzLmJveGNvbG9yID0gXCIjRkYwMDAwXCI7XG5cdFx0XHRcdHRoaXMuaGFzX2Vycm9yID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2hhZGVyID0gc2hhZGVyO1xuXHRcdFx0dGhpcy5fc2hhZGVyX2NvZGUgPSB1dmNvZGUgKyBcInxcIiArIHBpeGVsY29kZTtcblx0XHR9XG5cblx0XHRpZighdGhpcy5fc2hhZGVyKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0aWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcblx0XHR9XG5cblx0XHR2YXIgdGltZSA9IHRoaXMuZ3JhcGguZ2V0VGltZSgpO1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdGlmICh0ZXgpIHtcblx0XHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGV4Qikge1xuXHRcdFx0XHR0ZXhCLmJpbmQoMSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdFx0c2hhZGVyXG5cdFx0XHRcdC51bmlmb3Jtcyh7XG5cdFx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHRcdHVfdGV4dHVyZUI6IDEsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdHRleFNpemU6IFt3aWR0aCwgaGVpZ2h0LDEvd2lkdGgsMS9oZWlnaHRdLFxuXHRcdFx0XHRcdHRpbWU6IHRpbWVcblx0XHRcdFx0fSlcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjNCB0ZXhTaXplO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB2YWx1ZTtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWMyIHV2ID0gdl9jb29yZDtcXG5cXFxuXHRcdFx0e3tVVl9DT0RFfX07XFxuXFxcblx0XHRcdHZlYzQgY29sb3I0ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYpO1xcblxcXG5cdFx0XHR2ZWMzIGNvbG9yID0gY29sb3I0LnJnYjtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvcjRCID0gdGV4dHVyZTJEKHVfdGV4dHVyZUIsIHV2KTtcXG5cXFxuXHRcdFx0dmVjMyBjb2xvckIgPSBjb2xvcjRCLnJnYjtcXG5cXFxuXHRcdFx0dmVjMyByZXN1bHQgPSBjb2xvcjtcXG5cXFxuXHRcdFx0ZmxvYXQgYWxwaGEgPSAxLjA7XFxuXFxcblx0XHRcdHt7UElYRUxfQ09ERX19O1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgYWxwaGEpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldCA9IGZ1bmN0aW9uICggbmFtZSwgY29kZSApXG5cdHtcblx0XHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByZXNldHNbbmFtZV0gPSBjb2RlO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIlwiLFwiXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiYnlwYXNzXCIsXCJjb2xvclwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImFkZFwiLFwiY29sb3IgKyBjb2xvckIgKiB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcInN1YnN0cmFjdFwiLFwiKGNvbG9yIC0gY29sb3JCKSAqIHZhbHVlXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwibWF0ZVwiLFwibWl4KCBjb2xvciwgY29sb3JCLCBjb2xvcjRCLmEgKiB2YWx1ZSlcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJpbnZlcnRcIixcInZlYzMoMS4wKSAtIGNvbG9yXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwibXVsdGlwbHlcIixcImNvbG9yICogY29sb3JCICogdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJkaXZpZGVcIixcIihjb2xvciAvIGNvbG9yQikgLyB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImRpZmZlcmVuY2VcIixcImFicyhjb2xvciAtIGNvbG9yQikgKiB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIm1heFwiLFwibWF4KGNvbG9yLCBjb2xvckIpICogdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJtaW5cIixcIm1pbihjb2xvciwgY29sb3JCKSAqIHZhbHVlXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiZGlzcGxhY2VcIixcInRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgKGNvbG9yQi54eSAtIHZlYzIoMC41KSkgKiB2YWx1ZSkueHl6XCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiZ3JheXNjYWxlXCIsXCJ2ZWMzKGNvbG9yLnggKyBjb2xvci55ICsgY29sb3IueikgKiB2YWx1ZSAvIDMuMFwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcInNhdHVyYXRpb25cIixcIm1peCggdmVjMyhjb2xvci54ICsgY29sb3IueSArIGNvbG9yLnopIC8gMy4wLCBjb2xvciwgdmFsdWUgKVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIm5vcm1hbG1hcFwiLFwiXFxuXFxcblx0XHRmbG9hdCB6MCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMigtdGV4U2l6ZS56LCAtdGV4U2l6ZS53KSApLng7XFxuXFxcblx0XHRmbG9hdCB6MSA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMigwLjAsIC10ZXhTaXplLncpICkueDtcXG5cXFxuXHRcdGZsb2F0IHoyID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKHRleFNpemUueiwgLXRleFNpemUudykgKS54O1xcblxcXG5cdFx0ZmxvYXQgejMgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoLXRleFNpemUueiwgMC4wKSApLng7XFxuXFxcblx0XHRmbG9hdCB6NCA9IGNvbG9yLng7XFxuXFxcblx0XHRmbG9hdCB6NSA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMih0ZXhTaXplLnosIDAuMCkgKS54O1xcblxcXG5cdFx0ZmxvYXQgejYgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoLXRleFNpemUueiwgdGV4U2l6ZS53KSApLng7XFxuXFxcblx0XHRmbG9hdCB6NyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMigwLjAsIHRleFNpemUudykgKS54O1xcblxcXG5cdFx0ZmxvYXQgejggPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIodGV4U2l6ZS56LCB0ZXhTaXplLncpICkueDtcXG5cXFxuXHRcdHZlYzMgbm9ybWFsID0gdmVjMyggejIgKyAyLjAqejQgKyB6NyAtIHowIC0gMi4wKnozIC0gejUsIHo1ICsgMi4wKno2ICsgejcgLXowIC0gMi4wKnoxIC0gejIsIDEuMCApO1xcblxcXG5cdFx0bm9ybWFsLnh5ICo9IHZhbHVlO1xcblxcXG5cdFx0cmVzdWx0Lnh5eiA9IG5vcm1hbGl6ZShub3JtYWwpICogMC41ICsgdmVjMygwLjUpO1xcblxcXG5cdFwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcInRocmVzaG9sZFwiLFwidmVjMyhjb2xvci54ID4gY29sb3JCLnggKiB2YWx1ZSA/IDEuMCA6IDAuMCxjb2xvci55ID4gY29sb3JCLnkgKiB2YWx1ZSA/IDEuMCA6IDAuMCxjb2xvci56ID4gY29sb3JCLnogKiB2YWx1ZSA/IDEuMCA6IDAuMClcIik7XG5cblx0Ly93ZWJnbHN0dWRpbyBzdHVmZi4uLlxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByb3RvdHlwZS5vbkluc3BlY3QgPSBmdW5jdGlvbih3aWRnZXRzKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHdpZGdldHMuYWRkQ29tYm8oXCJQcmVzZXRzXCIsXCJcIix7IHZhbHVlczogT2JqZWN0LmtleXMoTEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcmVzZXRzKSwgY2FsbGJhY2s6IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGNvZGUgPSBMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByZXNldHNbdl07XG5cdFx0XHRpZighY29kZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhhdC5zZXRQcm9wZXJ0eShcInBpeGVsY29kZVwiLGNvZGUpO1xuXHRcdFx0dGhhdC50aXRsZSA9IHY7XG5cdFx0XHR3aWRnZXRzLnJlZnJlc2goKTtcblx0XHR9fSk7XG5cdH1cblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvb3BlcmF0aW9uXCIsIExHcmFwaFRleHR1cmVPcGVyYXRpb24pO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVTaGFkZXIoKSB7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGNvZGU6IFwiXCIsXG5cdFx0XHR1X3ZhbHVlOiAxLFxuXHRcdFx0dV9jb2xvcjogWzEsMSwxLDFdLFxuXHRcdFx0d2lkdGg6IDUxMixcblx0XHRcdGhlaWdodDogNTEyLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXG5cdFx0dGhpcy5wcm9wZXJ0aWVzLmNvZGUgPSBMR3JhcGhUZXh0dXJlU2hhZGVyLnBpeGVsX3NoYWRlcjtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgdV92YWx1ZTogMSwgdV9jb2xvcjogdmVjNC5jcmVhdGUoKSwgaW5fdGV4dHVyZTogMCwgdGV4U2l6ZTogdmVjNC5jcmVhdGUoKSwgdGltZTogMCB9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVNoYWRlci50aXRsZSA9IFwiU2hhZGVyXCI7XG5cdExHcmFwaFRleHR1cmVTaGFkZXIuZGVzYyA9IFwiVGV4dHVyZSBzaGFkZXJcIjtcblx0TEdyYXBoVGV4dHVyZVNoYWRlci53aWRnZXRzX2luZm8gPSB7XG5cdFx0Y29kZTogeyB0eXBlOiBcImNvZGVcIiwgbGFuZzogXCJnbHNsXCIgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVNoYWRlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihcblx0XHRuYW1lLFxuXHRcdHZhbHVlXG5cdCkge1xuXHRcdGlmIChuYW1lICE9IFwiY29kZVwiKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKCk7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL3VwZGF0ZSBjb25uZWN0aW9uc1xuXHRcdHZhciB1bmlmb3JtcyA9IHNoYWRlci51bmlmb3JtSW5mbztcblxuXHRcdC8vcmVtb3ZlIGRlcHJlY2F0ZWQgc2xvdHNcblx0XHRpZiAodGhpcy5pbnB1dHMpIHtcblx0XHRcdHZhciBhbHJlYWR5ID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRJbnB1dEluZm8oaSk7XG5cdFx0XHRcdGlmICghaW5mbykge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHVuaWZvcm1zW2luZm8ubmFtZV0gJiYgIWFscmVhZHlbaW5mby5uYW1lXSkge1xuXHRcdFx0XHRcdGFscmVhZHlbaW5mby5uYW1lXSA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZW1vdmVJbnB1dChpKTtcblx0XHRcdFx0aS0tO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vdXBkYXRlIGV4aXN0aW5nIG9uZXNcblx0XHRmb3IgKHZhciBpIGluIHVuaWZvcm1zKSB7XG5cdFx0XHR2YXIgaW5mbyA9IHNoYWRlci51bmlmb3JtSW5mb1tpXTtcblx0XHRcdGlmIChpbmZvLmxvYyA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gLy9pcyBhbiBhdHRyaWJ1dGUsIG5vdCBhIHVuaWZvcm1cblx0XHRcdGlmIChpID09IFwidGltZVwiKSB7XG5cdFx0XHRcdC8vZGVmYXVsdCBvbmVcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdGlmICh0aGlzLl9zaGFkZXIuc2FtcGxlcnNbaV0pIHtcblx0XHRcdFx0dHlwZSA9IFwidGV4dHVyZVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3dpdGNoIChpbmZvLnNpemUpIHtcblx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdHR5cGUgPSBcInZlYzJcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdHR5cGUgPSBcInZlYzNcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdHR5cGUgPSBcInZlYzRcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgOTpcblx0XHRcdFx0XHRcdHR5cGUgPSBcIm1hdDNcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMTY6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJtYXQ0XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNsb3QgPSB0aGlzLmZpbmRJbnB1dFNsb3QoaSk7XG5cdFx0XHRpZiAoc2xvdCA9PSAtMSkge1xuXHRcdFx0XHR0aGlzLmFkZElucHV0KGksIHR5cGUpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlucHV0X2luZm8gPSB0aGlzLmdldElucHV0SW5mbyhzbG90KTtcblx0XHRcdGlmICghaW5wdXRfaW5mbykge1xuXHRcdFx0XHR0aGlzLmFkZElucHV0KGksIHR5cGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlucHV0X2luZm8udHlwZSA9PSB0eXBlKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZW1vdmVJbnB1dChzbG90LCB0eXBlKTtcblx0XHRcdFx0dGhpcy5hZGRJbnB1dChpLCB0eXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVNoYWRlci5wcm90b3R5cGUuZ2V0U2hhZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly9yZXBsdWdcblx0XHRpZiAodGhpcy5fc2hhZGVyICYmIHRoaXMuX3NoYWRlcl9jb2RlID09IHRoaXMucHJvcGVydGllcy5jb2RlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc2hhZGVyO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYWRlcl9jb2RlID0gdGhpcy5wcm9wZXJ0aWVzLmNvZGU7XG5cdFx0dGhpcy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCB0aGlzLnByb3BlcnRpZXMuY29kZSApO1xuXHRcdGlmICghdGhpcy5fc2hhZGVyKSB7XG5cdFx0XHR0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJveGNvbG9yID0gXCJncmVlblwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2hhZGVyO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXIoKTtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhfc2xvdCA9IDA7XG5cdFx0dmFyIGluX3RleCA9IG51bGw7XG5cblx0XHQvL3NldCB1bmlmb3Jtc1xuXHRcdGlmKHRoaXMuaW5wdXRzKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRJbnB1dEluZm8oaSk7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuY29uc3RydWN0b3IgPT09IEdMLlRleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5iaW5kKHRleF9zbG90KTtcblx0XHRcdFx0aWYgKCFpbl90ZXgpIHtcblx0XHRcdFx0XHRpbl90ZXggPSBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEgPSB0ZXhfc2xvdDtcblx0XHRcdFx0dGV4X3Nsb3QrKztcblx0XHRcdH1cblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKGluZm8ubmFtZSwgZGF0YSk7IC8vZGF0YSBpcyB0ZXhfc2xvdFxuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiwgaW5fdGV4ICk7XG5cblx0XHQvL3JlbmRlciB0byB0ZXh0dXJlXG5cdFx0dmFyIHcgPSB0aGlzLnByb3BlcnRpZXMud2lkdGggfCAwO1xuXHRcdHZhciBoID0gdGhpcy5wcm9wZXJ0aWVzLmhlaWdodCB8IDA7XG5cdFx0aWYgKHcgPT0gMCkge1xuXHRcdFx0dyA9IGluX3RleCA/IGluX3RleC53aWR0aCA6IGdsLmNhbnZhcy53aWR0aDtcblx0XHR9XG5cdFx0aWYgKGggPT0gMCkge1xuXHRcdFx0aCA9IGluX3RleCA/IGluX3RleC5oZWlnaHQgOiBnbC5jYW52YXMuaGVpZ2h0O1xuXHRcdH1cblx0XHR1bmlmb3Jtcy50ZXhTaXplWzBdID0gdztcblx0XHR1bmlmb3Jtcy50ZXhTaXplWzFdID0gaDtcblx0XHR1bmlmb3Jtcy50ZXhTaXplWzJdID0gMS93O1xuXHRcdHVuaWZvcm1zLnRleFNpemVbM10gPSAxL2g7XG5cdFx0dW5pZm9ybXMudGltZSA9IHRoaXMuZ3JhcGguZ2V0VGltZSgpO1xuXHRcdHVuaWZvcm1zLnVfdmFsdWUgPSB0aGlzLnByb3BlcnRpZXMudV92YWx1ZTtcblx0XHR1bmlmb3Jtcy51X2NvbG9yLnNldCggdGhpcy5wcm9wZXJ0aWVzLnVfY29sb3IgKTtcblxuXHRcdGlmICggIXRoaXMuX3RleCB8fCB0aGlzLl90ZXgudHlwZSAhPSB0eXBlIHx8ICB0aGlzLl90ZXgud2lkdGggIT0gdyB8fCB0aGlzLl90ZXguaGVpZ2h0ICE9IGggKSB7XG5cdFx0XHR0aGlzLl90ZXggPSBuZXcgR0wuVGV4dHVyZSh3LCBoLCB7ICB0eXBlOiB0eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH0pO1xuXHRcdH1cblx0XHR2YXIgdGV4ID0gdGhpcy5fdGV4O1xuXHRcdHRleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVNoYWRlci5waXhlbF9zaGFkZXIgPVxuXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxudW5pZm9ybSBmbG9hdCB0aW1lOyAvL3RpbWUgaW4gc2Vjb25kc1xcblxcXG51bmlmb3JtIHZlYzQgdGV4U2l6ZTsgLy90ZXggcmVzb2x1dGlvblxcblxcXG51bmlmb3JtIGZsb2F0IHVfdmFsdWU7XFxuXFxcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcblxcblxcXG52b2lkIG1haW4oKSB7XFxuXFxcblx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0dmVjMyBjb2xvciA9IHZlYzMoMC4wKTtcXG5cXFxuXHQvL3lvdXIgY29kZSBoZXJlXFxuXFxcblx0Y29sb3IueHk9dXY7XFxuXFxuXFxcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvc2hhZGVyXCIsIExHcmFwaFRleHR1cmVTaGFkZXIpO1xuXG5cdC8vIFRleHR1cmUgU2NhbGUgT2Zmc2V0XG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0KCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcInNjYWxlXCIsIFwidmVjMlwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwib2Zmc2V0XCIsIFwidmVjMlwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0b2Zmc2V0OiB2ZWMyLmZyb21WYWx1ZXMoMCwgMCksXG5cdFx0XHRzY2FsZTogdmVjMi5mcm9tVmFsdWVzKDEsIDEpLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LnRpdGxlID0gXCJTY2FsZS9PZmZzZXRcIjtcblx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LmRlc2MgPSBcIkFwcGxpZXMgYW4gc2NhbGluZyBhbmQgb2Zmc2V0aW5nXCI7XG5cblx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgfHwgIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRleC53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdGV4LmhlaWdodDtcblx0XHR2YXIgdHlwZSA9ICB0aGlzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cgPyBnbC5VTlNJR05FRF9CWVRFIDogZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdGlmICh0aGlzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5ERUZBVUxUKSB7XG5cdFx0XHR0eXBlID0gdGV4LnR5cGU7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuX3RleCB8fFxuXHRcdFx0dGhpcy5fdGV4LndpZHRoICE9IHdpZHRoIHx8XG5cdFx0XHR0aGlzLl90ZXguaGVpZ2h0ICE9IGhlaWdodCB8fFxuXHRcdFx0dGhpcy5fdGV4LnR5cGUgIT0gdHlwZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUod2lkdGgsIGhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuXG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoc2NhbGUpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5zY2FsZVswXSA9IHNjYWxlWzBdO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnNjYWxlWzFdID0gc2NhbGVbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNjYWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMub2Zmc2V0WzBdID0gb2Zmc2V0WzBdO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLm9mZnNldFsxXSA9IG9mZnNldFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5wcm9wZXJ0aWVzLm9mZnNldDtcblx0XHR9XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRcdGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblx0XHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdFx0c2hhZGVyXG5cdFx0XHRcdC51bmlmb3Jtcyh7XG5cdFx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHRcdHVfc2NhbGU6IHNjYWxlLFxuXHRcdFx0XHRcdHVfb2Zmc2V0OiBvZmZzZXRcblx0XHRcdFx0fSlcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlU2NhbGVPZmZzZXQucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfc2NhbGU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0XHRcdHV2ID0gdXYgLyB1X3NjYWxlIC0gdV9vZmZzZXQ7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2KTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxuXHRcdFwidGV4dHVyZS9zY2FsZU9mZnNldFwiLFxuXHRcdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldFxuXHQpO1xuXG5cdC8vIFdhcnAgKGRpc3RvcnQgYSB0ZXh0dXJlKSAqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVdhcnAoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwid2FycFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcImZhY3RvclwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0ZmFjdG9yOiAwLjAxLFxuXHRcdFx0c2NhbGU6IFsxLDFdLFxuXHRcdFx0b2Zmc2V0OiBbMCwwXSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMuX3VuaWZvcm1zID0geyBcblx0XHRcdHVfdGV4dHVyZTogMCwgXG5cdFx0XHR1X3RleHR1cmVCOiAxLCBcblx0XHRcdHVfZmFjdG9yOiAxLCBcblx0XHRcdHVfc2NhbGU6IHZlYzIuY3JlYXRlKCksXG5cdFx0XHR1X29mZnNldDogdmVjMi5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlV2FycC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXYXJwLnRpdGxlID0gXCJXYXJwXCI7XG5cdExHcmFwaFRleHR1cmVXYXJwLmRlc2MgPSBcIlRleHR1cmUgd2FycCBvcGVyYXRpb25cIjtcblxuXHRMR3JhcGhUZXh0dXJlV2FycC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRleEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblxuXHRcdHZhciB3aWR0aCA9IDUxMjtcblx0XHR2YXIgaGVpZ2h0ID0gNTEyO1xuXHRcdHZhciB0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAodGV4KSB7XG5cdFx0XHR3aWR0aCA9IHRleC53aWR0aDtcblx0XHRcdGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cdFx0XHR0eXBlID0gdGV4LnR5cGU7XG5cdFx0fSBlbHNlIGlmICh0ZXhCKSB7XG5cdFx0XHR3aWR0aCA9IHRleEIud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSB0ZXhCLmhlaWdodDtcblx0XHRcdHR5cGUgPSB0ZXhCLnR5cGU7XG5cdFx0fVxuXG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RleCkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUod2lkdGgsIGhlaWdodCwge1xuXHRcdFx0XHR0eXBlOlxuXHRcdFx0XHRcdHRoaXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLkxPV1xuXHRcdFx0XHRcdFx0PyBnbC5VTlNJR05FRF9CWVRFXG5cdFx0XHRcdFx0XHQ6IGdsLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVCxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcblx0XHRcdFx0dGV4IHx8IHRoaXMuX3RleCxcblx0XHRcdFx0dGhpcy5fdGV4LFxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLl9zaGFkZXI7XG5cblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlV2FycC5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGZhY3RvciA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXHRcdGlmIChmYWN0b3IgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmZhY3RvciA9IGZhY3Rvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmFjdG9yID0gcGFyc2VGbG9hdCh0aGlzLnByb3BlcnRpZXMuZmFjdG9yKTtcblx0XHR9XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9mYWN0b3IgPSBmYWN0b3I7XG5cdFx0dW5pZm9ybXMudV9zY2FsZS5zZXQoIHRoaXMucHJvcGVydGllcy5zY2FsZSApO1xuXHRcdHVuaWZvcm1zLnVfb2Zmc2V0LnNldCggdGhpcy5wcm9wZXJ0aWVzLm9mZnNldCApO1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdGlmICh0ZXgpIHtcblx0XHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGV4Qikge1xuXHRcdFx0XHR0ZXhCLmJpbmQoMSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdFx0c2hhZGVyXG5cdFx0XHRcdC51bmlmb3JtcyggdW5pZm9ybXMgKVxuXHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXYXJwLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mYWN0b3I7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9zY2FsZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWMyIHV2ID0gdl9jb29yZDtcXG5cXFxuXHRcdFx0dXYgKz0gKCB0ZXh0dXJlMkQodV90ZXh0dXJlQiwgdXYpLnJnIC0gdmVjMigwLjUpKSAqIHVfZmFjdG9yICogdV9zY2FsZSArIHVfb2Zmc2V0O1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1dik7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvd2FycFwiLCBMR3JhcGhUZXh0dXJlV2FycCk7XG5cblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblx0Ly8gVGV4dHVyZSB0byBWaWV3cG9ydCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0YWRkaXRpdmU6IGZhbHNlLFxuXHRcdFx0YW50aWFsaWFzaW5nOiBmYWxzZSxcblx0XHRcdGZpbHRlcjogdHJ1ZSxcblx0XHRcdGRpc2FibGVfYWxwaGE6IGZhbHNlLFxuXHRcdFx0Z2FtbWE6IDEuMCxcblx0XHRcdHZpZXdwb3J0OiBbMCwwLDEsMV1cblx0XHR9O1xuXHRcdHRoaXMuc2l6ZVswXSA9IDEzMDtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0LnRpdGxlID0gXCJ0byBWaWV3cG9ydFwiO1xuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5kZXNjID0gXCJUZXh0dXJlIHRvIHZpZXdwb3J0XCI7XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX3ByZXZfdmlld3BvcnQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG5cdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0LnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oIGN0eCApXG5cdHtcblx0XHRpZiAoIHRoaXMuZmxhZ3MuY29sbGFwc2VkIHx8IHRoaXMuc2l6ZVsxXSA8PSA0MCApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguZHJhd0ltYWdlKCBjdHggPT0gZ2wgPyB0ZXggOiBnbC5jYW52YXMsIDEwLDMwLCB0aGlzLnNpemVbMF0gLTIwLCB0aGlzLnNpemVbMV0gLTQwKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmRpc2FibGVfYWxwaGEpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy5hZGRpdGl2ZSkge1xuXHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR2YXIgZ2FtbWEgPSB0aGlzLnByb3BlcnRpZXMuZ2FtbWEgfHwgMS4wO1xuXHRcdGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcblx0XHRcdGdhbW1hID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0fVxuXG5cdFx0dGV4LnNldFBhcmFtZXRlcihcblx0XHRcdGdsLlRFWFRVUkVfTUFHX0ZJTFRFUixcblx0XHRcdHRoaXMucHJvcGVydGllcy5maWx0ZXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUXG5cdFx0KTtcblxuXHRcdHZhciBvbGRfdmlld3BvcnQgPSBMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fcHJldl92aWV3cG9ydDtcblx0XHRvbGRfdmlld3BvcnQuc2V0KCBnbC52aWV3cG9ydF9kYXRhICk7XG5cdFx0dmFyIG5ld192aWV3ID0gdGhpcy5wcm9wZXJ0aWVzLnZpZXdwb3J0O1xuXHRcdGdsLnZpZXdwb3J0KCBvbGRfdmlld3BvcnRbMF0gKyBvbGRfdmlld3BvcnRbMl0gKiBuZXdfdmlld1swXSwgb2xkX3ZpZXdwb3J0WzFdICsgb2xkX3ZpZXdwb3J0WzNdICogbmV3X3ZpZXdbMV0sIG9sZF92aWV3cG9ydFsyXSAqIG5ld192aWV3WzJdLCBvbGRfdmlld3BvcnRbM10gKiBuZXdfdmlld1szXSApO1xuXHRcdHZhciB2aWV3cG9ydCA9IGdsLmdldFZpZXdwb3J0KCk7IC8vZ2wuZ2V0UGFyYW1ldGVyKGdsLlZJRVdQT1JUKTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuYW50aWFsaWFzaW5nKSB7XG5cdFx0XHRpZiAoIUxHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9zaGFkZXIpIHtcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0LmFhX3BpeGVsX3NoYWRlclxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fc2hhZGVyXG5cdFx0XHRcdC51bmlmb3Jtcyh7XG5cdFx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHRcdHVWaWV3cG9ydFNpemU6IFt0ZXgud2lkdGgsIHRleC5oZWlnaHRdLFxuXHRcdFx0XHRcdHVfaWdhbW1hOiAxIC8gZ2FtbWEsXG5cdFx0XHRcdFx0aW52ZXJzZVZQOiBbMSAvIHRleC53aWR0aCwgMSAvIHRleC5oZWlnaHRdXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZ2FtbWEgIT0gMS4wKSB7XG5cdFx0XHRcdGlmICghTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX2dhbW1hX3NoYWRlcikge1xuXHRcdFx0XHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9nYW1tYV9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdFx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuZ2FtbWFfcGl4ZWxfc2hhZGVyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXgudG9WaWV3cG9ydChMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fZ2FtbWFfc2hhZGVyLCB7XG5cdFx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHRcdHVfaWdhbW1hOiAxIC8gZ2FtbWFcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0ZXgudG9WaWV3cG9ydCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsLnZpZXdwb3J0KCBvbGRfdmlld3BvcnRbMF0sIG9sZF92aWV3cG9ydFsxXSwgb2xkX3ZpZXdwb3J0WzJdLCBvbGRfdmlld3BvcnRbM10gKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImdhbW1hXCIsIFwibnVtYmVyXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5hYV9waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdVZpZXdwb3J0U2l6ZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiBpbnZlcnNlVlA7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaWdhbW1hO1xcblxcXG5cdFx0I2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG5cXFxuXHRcdCNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXG5cXFxuXHRcdCNkZWZpbmUgRlhBQV9TUEFOX01BWCAgICAgOC4wXFxuXFxcblx0XHRcXG5cXFxuXHRcdC8qIGZyb20gbWl0c3VoaWtvL3dlYmdsLW1laW5jcmFmdCBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSAqL1xcblxcXG5cdFx0dmVjNCBhcHBseUZYQUEoc2FtcGxlcjJEIHRleCwgdmVjMiBmcmFnQ29vcmQpXFxuXFxcblx0XHR7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxcblx0XHRcdC8qdmVjMiBpbnZlcnNlVlAgPSB2ZWMyKDEuMCAvIHVWaWV3cG9ydFNpemUueCwgMS4wIC8gdVZpZXdwb3J0U2l6ZS55KTsqL1xcblxcXG5cdFx0XHR2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgcmdiTkUgPSB0ZXh0dXJlMkQodGV4LCAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIC0xLjApKSAqIGludmVyc2VWUCkueHl6O1xcblxcXG5cdFx0XHR2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiBpbnZlcnNlVlApLnh5ejtcXG5cXFxuXHRcdFx0dmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiBpbnZlcnNlVlApLnh5ejtcXG5cXFxuXHRcdFx0dmVjMyByZ2JNICA9IHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAgKiBpbnZlcnNlVlApLnh5ejtcXG5cXFxuXHRcdFx0dmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXFxuXHRcdFx0XFxuXFxcblx0XHRcdHZlYzIgZGlyO1xcblxcXG5cdFx0XHRkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XFxuXFxcblx0XHRcdGRpci55ID0gICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcXG5cXFxuXHRcdFx0XFxuXFxcblx0XHRcdGZsb2F0IGRpclJlZHVjZSA9IG1heCgobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcXG5cXFxuXHRcdFx0XFxuXFxcblx0XHRcdGZsb2F0IHJjcERpck1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xcblxcXG5cdFx0XHRkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSwgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSwgZGlyICogcmNwRGlyTWluKSkgKiBpbnZlcnNlVlA7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHR2ZWMzIHJnYkEgPSAwLjUgKiAodGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArIFxcblxcXG5cdFx0XHRcdHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcblxcXG5cdFx0XHR2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqICh0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAtMC41KS54eXogKyBcXG5cXFxuXHRcdFx0XHR0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHQvL3JldHVybiB2ZWM0KHJnYkEsMS4wKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtYUIgPSBkb3QocmdiQiwgbHVtYSk7XFxuXFxcblx0XHRcdGlmICgobHVtYUIgPCBsdW1hTWluKSB8fCAobHVtYUIgPiBsdW1hTWF4KSlcXG5cXFxuXHRcdFx0XHRjb2xvciA9IHZlYzQocmdiQSwgMS4wKTtcXG5cXFxuXHRcdFx0ZWxzZVxcblxcXG5cdFx0XHRcdGNvbG9yID0gdmVjNChyZ2JCLCAxLjApO1xcblxcXG5cdFx0XHRpZih1X2lnYW1tYSAhPSAxLjApXFxuXFxcblx0XHRcdFx0Y29sb3IueHl6ID0gcG93KCBjb2xvci54eXosIHZlYzModV9pZ2FtbWEpICk7XFxuXFxcblx0XHRcdHJldHVybiBjb2xvcjtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gYXBwbHlGWEFBKCB1X3RleHR1cmUsIHZfY29vcmQgKiB1Vmlld3BvcnRTaXplKSA7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5nYW1tYV9waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaWdhbW1hO1xcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXG5cdFx0XHRjb2xvci54eXogPSBwb3coY29sb3IueHl6LCB2ZWMzKHVfaWdhbW1hKSApO1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUvdG92aWV3cG9ydFwiLFxuXHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0XG5cdCk7XG5cblx0Ly8gVGV4dHVyZSBDb3B5ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVDb3B5KCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0c2l6ZTogMCxcblx0XHRcdGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUNvcHkudGl0bGUgPSBcIkNvcHlcIjtcblx0TEdyYXBoVGV4dHVyZUNvcHkuZGVzYyA9IFwiQ29weSBUZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmVDb3B5LndpZGdldHNfaW5mbyA9IHtcblx0XHRzaXplOiB7XG5cdFx0XHR3aWRnZXQ6IFwiY29tYm9cIixcblx0XHRcdHZhbHVlczogWzAsIDMyLCA2NCwgMTI4LCAyNTYsIDUxMiwgMTAyNCwgMjA0OF1cblx0XHR9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ29weS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4ICYmICF0aGlzLl90ZW1wX3RleHR1cmUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0Ly9jb3B5IHRoZSB0ZXh0dXJlXG5cdFx0aWYgKHRleCkge1xuXHRcdFx0dmFyIHdpZHRoID0gdGV4LndpZHRoO1xuXHRcdFx0dmFyIGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cblx0XHRcdGlmICh0aGlzLnByb3BlcnRpZXMuc2l6ZSAhPSAwKSB7XG5cdFx0XHRcdHdpZHRoID0gdGhpcy5wcm9wZXJ0aWVzLnNpemU7XG5cdFx0XHRcdGhlaWdodCA9IHRoaXMucHJvcGVydGllcy5zaXplO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB0ZXgudHlwZTtcblx0XHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLkxPVykge1xuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5ISUdIKSB7XG5cdFx0XHRcdHR5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0IXRlbXAgfHxcblx0XHRcdFx0dGVtcC53aWR0aCAhPSB3aWR0aCB8fFxuXHRcdFx0XHR0ZW1wLmhlaWdodCAhPSBoZWlnaHQgfHxcblx0XHRcdFx0dGVtcC50eXBlICE9IHR5cGVcblx0XHRcdCkge1xuXHRcdFx0XHR2YXIgbWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmdlbmVyYXRlX21pcG1hcHMgJiZcblx0XHRcdFx0XHRpc1Bvd2VyT2ZUd28od2lkdGgpICYmXG5cdFx0XHRcdFx0aXNQb3dlck9mVHdvKGhlaWdodClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0bWluRmlsdGVyID0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUod2lkdGgsIGhlaWdodCwge1xuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRcdG1pbkZpbHRlcjogbWluRmlsdGVyLFxuXHRcdFx0XHRcdG1hZ0ZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGV4LmNvcHlUbyh0aGlzLl90ZW1wX3RleHR1cmUpO1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmdlbmVyYXRlX21pcG1hcHMpIHtcblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmJpbmQoMCk7XG5cdFx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuX3RlbXBfdGV4dHVyZS50ZXh0dXJlX3R5cGUpO1xuXHRcdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUudW5iaW5kKDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9jb3B5XCIsIExHcmFwaFRleHR1cmVDb3B5KTtcblxuXHQvLyBUZXh0dXJlIERvd25zYW1wbGUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZURvd25zYW1wbGUoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRpdGVyYXRpb25zOiAxLFxuXHRcdFx0Z2VuZXJhdGVfbWlwbWFwczogZmFsc2UsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS50aXRsZSA9IFwiRG93bnNhbXBsZVwiO1xuXHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5kZXNjID0gXCJEb3duc2FtcGxlIFRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUud2lkZ2V0c19pbmZvID0ge1xuXHRcdGl0ZXJhdGlvbnM6IHsgdHlwZTogXCJudW1iZXJcIiwgc3RlcDogMSwgcHJlY2lzaW9uOiAwLCBtaW46IDAgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCAmJiAhdGhpcy5fdGVtcF90ZXh0dXJlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdC8vd2UgZG8gbm90IGFsbG93IGFueSB0ZXh0dXJlIGRpZmZlcmVudCB0aGFuIHRleHR1cmUgMkRcblx0XHRpZiAoIXRleCB8fCB0ZXgudGV4dHVyZV90eXBlICE9PSBHTC5URVhUVVJFXzJEKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5pdGVyYXRpb25zIDwgMSkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVEb3duc2FtcGxlLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLl9zaGFkZXIgPSBzaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgd2lkdGggPSB0ZXgud2lkdGggfCAwO1xuXHRcdHZhciBoZWlnaHQgPSB0ZXguaGVpZ2h0IHwgMDtcblx0XHR2YXIgdHlwZSA9IHRleC50eXBlO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLkxPVykge1xuXHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLkhJR0gpIHtcblx0XHRcdHR5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0fVxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5wcm9wZXJ0aWVzLml0ZXJhdGlvbnMgfHwgMTtcblxuXHRcdHZhciBvcmlnaW4gPSB0ZXg7XG5cdFx0dmFyIHRhcmdldCA9IG51bGw7XG5cblx0XHR2YXIgdGVtcCA9IFtdO1xuXHRcdHZhciBvcHRpb25zID0ge1xuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdGZvcm1hdDogdGV4LmZvcm1hdFxuXHRcdH07XG5cblx0XHR2YXIgb2Zmc2V0ID0gdmVjMi5jcmVhdGUoKTtcblx0XHR2YXIgdW5pZm9ybXMgPSB7XG5cdFx0XHR1X29mZnNldDogb2Zmc2V0XG5cdFx0fTtcblxuXHRcdGlmICh0aGlzLl90ZXh0dXJlKSB7XG5cdFx0XHRHTC5UZXh0dXJlLnJlbGVhc2VUZW1wb3JhcnkodGhpcy5fdGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcblx0XHRcdG9mZnNldFswXSA9IDEgLyB3aWR0aDtcblx0XHRcdG9mZnNldFsxXSA9IDEgLyBoZWlnaHQ7XG5cdFx0XHR3aWR0aCA9IHdpZHRoID4+IDEgfHwgMDtcblx0XHRcdGhlaWdodCA9IGhlaWdodCA+PiAxIHx8IDA7XG5cdFx0XHR0YXJnZXQgPSBHTC5UZXh0dXJlLmdldFRlbXBvcmFyeSh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcblx0XHRcdHRlbXAucHVzaCh0YXJnZXQpO1xuXHRcdFx0b3JpZ2luLnNldFBhcmFtZXRlcihHTC5URVhUVVJFX01BR19GSUxURVIsIEdMLk5FQVJFU1QpO1xuXHRcdFx0b3JpZ2luLmNvcHlUbyh0YXJnZXQsIHNoYWRlciwgdW5pZm9ybXMpO1xuXHRcdFx0aWYgKHdpZHRoID09IDEgJiYgaGVpZ2h0ID09IDEpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IC8vbm90aGluZyBlbHNlIHRvIGRvXG5cdFx0XHRvcmlnaW4gPSB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0Ly9rZWVwIHRoZSBsYXN0IHRleHR1cmUgdXNlZFxuXHRcdHRoaXMuX3RleHR1cmUgPSB0ZW1wLnBvcCgpO1xuXG5cdFx0Ly9mcmVlIHRoZSByZXN0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRHTC5UZXh0dXJlLnJlbGVhc2VUZW1wb3JhcnkodGVtcFtpXSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzKSB7XG5cdFx0XHR0aGlzLl90ZXh0dXJlLmJpbmQoMCk7XG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLl90ZXh0dXJlLnRleHR1cmVfdHlwZSk7XG5cdFx0XHR0aGlzLl90ZXh0dXJlLnVuYmluZCgwKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4dHVyZSk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICk7XFxuXFxcblx0XHRcdGNvbG9yICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB2ZWMyKCB1X29mZnNldC54LCAwLjAgKSApO1xcblxcXG5cdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdmVjMiggMC4wLCB1X29mZnNldC55ICkgKTtcXG5cXFxuXHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHZlYzIoIHVfb2Zmc2V0LngsIHVfb2Zmc2V0LnkgKSApO1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiAwLjI1O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL2Rvd25zYW1wbGVcIixcblx0XHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZVxuXHQpO1xuXG5cblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlUmVzaXplKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0c2l6ZTogWzUxMiw1MTJdLFxuXHRcdFx0Z2VuZXJhdGVfbWlwbWFwczogZmFsc2UsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlUmVzaXplLnRpdGxlID0gXCJSZXNpemVcIjtcblx0TEdyYXBoVGV4dHVyZVJlc2l6ZS5kZXNjID0gXCJSZXNpemUgVGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlUmVzaXplLndpZGdldHNfaW5mbyA9IHtcblx0XHRpdGVyYXRpb25zOiB7IHR5cGU6IFwibnVtYmVyXCIsIHN0ZXA6IDEsIHByZWNpc2lvbjogMCwgbWluOiAwIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVSZXNpemUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCAmJiAhdGhpcy5fdGVtcF90ZXh0dXJlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdC8vd2UgZG8gbm90IGFsbG93IGFueSB0ZXh0dXJlIGRpZmZlcmVudCB0aGFuIHRleHR1cmUgMkRcblx0XHRpZiAoIXRleCB8fCB0ZXgudGV4dHVyZV90eXBlICE9PSBHTC5URVhUVVJFXzJEKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHdpZHRoID0gdGhpcy5wcm9wZXJ0aWVzLnNpemVbMF0gfCAwO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLnByb3BlcnRpZXMuc2l6ZVsxXSB8IDA7XG5cdFx0aWYod2lkdGggPT0gMClcblx0XHRcdHdpZHRoID0gdGV4LndpZHRoO1xuXHRcdGlmKGhlaWdodCA9PSAwKVxuXHRcdFx0aGVpZ2h0ID0gdGV4LmhlaWdodDtcblx0XHR2YXIgdHlwZSA9IHRleC50eXBlO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLkxPVykge1xuXHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLkhJR0gpIHtcblx0XHRcdHR5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0fVxuXG5cdFx0aWYoICF0aGlzLl90ZXh0dXJlIHx8IHRoaXMuX3RleHR1cmUud2lkdGggIT0gd2lkdGggfHwgdGhpcy5fdGV4dHVyZS5oZWlnaHQgIT0gaGVpZ2h0IHx8IHRoaXMuX3RleHR1cmUudHlwZSAhPSB0eXBlIClcblx0XHRcdHRoaXMuX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSggd2lkdGgsIGhlaWdodCwgeyB0eXBlOiB0eXBlIH0gKTtcblxuXHRcdHRleC5jb3B5VG8oIHRoaXMuX3RleHR1cmUgKTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbWlwbWFwcykge1xuXHRcdFx0dGhpcy5fdGV4dHVyZS5iaW5kKDApO1xuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fdGV4dHVyZS50ZXh0dXJlX3R5cGUpO1xuXHRcdFx0dGhpcy5fdGV4dHVyZS51bmJpbmQoMCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleHR1cmUpO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInRleHR1cmUvcmVzaXplXCIsIExHcmFwaFRleHR1cmVSZXNpemUgKTtcblxuXHQvLyBUZXh0dXJlIEF2ZXJhZ2UgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVBdmVyYWdlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcInRleFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJhdmdcIiwgXCJ2ZWM0XCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibHVtXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHVzZV9wcmV2aW91c19mcmFtZTogdHJ1ZSwgLy90byBhdm9pZCBzdGFsbHMgXG5cdFx0XHRoaWdoX3F1YWxpdHk6IGZhbHNlIC8vdG8gdXNlIGFzIG11Y2ggcGl4ZWxzIGFzIHBvc3NpYmxlXG5cdFx0fTtcblxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV9taXBtYXBfb2Zmc2V0OiAwXG5cdFx0fTtcblx0XHR0aGlzLl9sdW1pbmFuY2UgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUF2ZXJhZ2UudGl0bGUgPSBcIkF2ZXJhZ2VcIjtcblx0TEdyYXBoVGV4dHVyZUF2ZXJhZ2UuZGVzYyA9XG5cdFx0XCJDb21wdXRlIGEgcGFydGlhbCBhdmVyYWdlICgzMiByYW5kb20gc2FtcGxlcykgb2YgYSB0ZXh0dXJlIGFuZCBzdG9yZXMgaXQgYXMgYSAxeDEgcGl4ZWwgdGV4dHVyZS5cXG4gSWYgaGlnaF9xdWFsaXR5IGlzIHRydWUsIHRoZW4gaXQgZ2VuZXJhdGVzIHRoZSBtaXBtYXBzIGZpcnN0IGFuZCByZWFkcyBmcm9tIHRoZSBsb3dlciBvbmUuXCI7XG5cblx0TEdyYXBoVGV4dHVyZUF2ZXJhZ2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5wcm9wZXJ0aWVzLnVzZV9wcmV2aW91c19mcmFtZSkge1xuXHRcdFx0dGhpcy51cGRhdGVBdmVyYWdlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHYgPSB0aGlzLl9sdW1pbmFuY2U7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIHYpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgyLCAodlswXSArIHZbMV0gKyB2WzJdKSAvIDMpO1xuXHR9O1xuXG5cdC8vZXhlY3V0ZWQgYmVmb3JlIHJlbmRlcmluZyB0aGUgZnJhbWVcblx0TEdyYXBoVGV4dHVyZUF2ZXJhZ2UucHJvdG90eXBlLm9uUHJlUmVuZGVyRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlQXZlcmFnZSgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnByb3RvdHlwZS51cGRhdGVBdmVyYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgJiZcblx0XHRcdCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDEpICYmXG5cdFx0XHQhdGhpcy5pc091dHB1dENvbm5lY3RlZCgyKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVBdmVyYWdlLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVBdmVyYWdlLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVBdmVyYWdlLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHRcdC8vY3JlYXRlcyAyNTYgcmFuZG9tIG51bWJlcnMgYW5kIHN0b3JlcyB0aGVtIGluIHR3byBtYXQ0XG5cdFx0XHR2YXIgc2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHNhbXBsZXNbaV0gPSBNYXRoLnJhbmRvbSgpOyAvL3Bvb3JseSBkaXN0cmlidXRlZCBzYW1wbGVzXG5cdFx0XHR9XG5cdFx0XHQvL3VwbG9hZCBvbmx5IG9uY2Vcblx0XHRcdExHcmFwaFRleHR1cmVBdmVyYWdlLl9zaGFkZXIudW5pZm9ybXMoe1xuXHRcdFx0XHR1X3NhbXBsZXNfYTogc2FtcGxlcy5zdWJhcnJheSgwLCAxNiksXG5cdFx0XHRcdHVfc2FtcGxlc19iOiBzYW1wbGVzLnN1YmFycmF5KDE2LCAzMilcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdHZhciB0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAodGV4LnR5cGUgIT0gdHlwZSkge1xuXHRcdFx0Ly9mb3JjZSBmbG9hdHMsIGhhbGYgZmxvYXRzIGNhbm5vdCBiZSByZWFkIHdpdGggZ2wucmVhZFBpeGVsc1xuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXHRcdH1cblxuXHRcdGlmICghdGVtcCB8fCB0ZW1wLnR5cGUgIT0gdHlwZSkge1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoMSwgMSwge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdW5pZm9ybXMudV9taXBtYXBfb2Zmc2V0ID0gMDtcblxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5oaWdoX3F1YWxpdHkpXG5cdFx0e1xuXHRcdFx0aWYoICF0aGlzLl90ZW1wX3BvdDJfdGV4dHVyZSB8fCB0aGlzLl90ZW1wX3BvdDJfdGV4dHVyZS50eXBlICE9IHR5cGUgKVxuXHRcdFx0XHR0aGlzLl90ZW1wX3BvdDJfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKDUxMiwgNTEyLCB7XG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdFx0bWluRmlsdGVyOiBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUixcblx0XHRcdFx0XHRtYWdGaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0dGV4LmNvcHlUbyggdGhpcy5fdGVtcF9wb3QyX3RleHR1cmUgKTtcblx0XHRcdHRleCA9IHRoaXMuX3RlbXBfcG90Ml90ZXh0dXJlO1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcChHTC5URVhUVVJFXzJEKTtcblx0XHRcdHRoaXMuX3VuaWZvcm1zLnVfbWlwbWFwX29mZnNldCA9IDk7XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVBdmVyYWdlLl9zaGFkZXI7XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9taXBtYXBfb2Zmc2V0ID0gdGhpcy5wcm9wZXJ0aWVzLm1pcG1hcF9vZmZzZXQ7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoc2hhZGVyLCB1bmlmb3Jtcyk7XG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSB8fCB0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDIpKSB7XG5cdFx0XHR2YXIgcGl4ZWwgPSB0aGlzLl90ZW1wX3RleHR1cmUuZ2V0UGl4ZWxzKCk7XG5cdFx0XHRpZiAocGl4ZWwpIHtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLl9sdW1pbmFuY2U7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdGVtcF90ZXh0dXJlLnR5cGU7XG5cdFx0XHRcdHYuc2V0KHBpeGVsKTtcblx0XHRcdFx0aWYgKHR5cGUgPT0gZ2wuVU5TSUdORURfQllURSkge1xuXHRcdFx0XHRcdHZlYzQuc2NhbGUodiwgdiwgMSAvIDI1NSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0dHlwZSA9PSBHTC5IQUxGX0ZMT0FUIHx8XG5cdFx0XHRcdFx0dHlwZSA9PSBHTC5IQUxGX0ZMT0FUX09FU1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvL25vIGhhbGYgZmxvYXRzIHBvc3NpYmxlLCBoYXJkIHRvIHJlYWQgYmFjayB1bmxlc3MgY29weWVkIHRvIGEgRkxPQVQgdGV4dHVyZSwgc28gdGVtcF90ZXh0dXJlIGlzIGFsd2F5cyBmb3JjZWQgdG8gRkxPQVRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBtYXQ0IHVfc2FtcGxlc19hO1xcblxcXG5cdFx0dW5pZm9ybSBtYXQ0IHVfc2FtcGxlc19iO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X21pcG1hcF9vZmZzZXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcXG5cdFx0XHQvL3JhbmRvbSBhdmVyYWdlXFxuXFxcblx0XHRcdGZvcihpbnQgaSA9IDA7IGkgPCA0OyArK2kpXFxuXFxcblx0XHRcdFx0Zm9yKGludCBqID0gMDsgaiA8IDQ7ICsrailcXG5cXFxuXHRcdFx0XHR7XFxuXFxcblx0XHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2ZWMyKCB1X3NhbXBsZXNfYVtpXVtqXSwgdV9zYW1wbGVzX2JbaV1bal0gKSwgdV9taXBtYXBfb2Zmc2V0ICk7XFxuXFxcblx0XHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2ZWMyKCAxLjAgLSB1X3NhbXBsZXNfYVtpXVtqXSwgMS4wIC0gdV9zYW1wbGVzX2JbaV1bal0gKSwgdV9taXBtYXBfb2Zmc2V0ICk7XFxuXFxcblx0XHRcdFx0fVxcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiAwLjAzMTI1O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2F2ZXJhZ2VcIiwgTEdyYXBoVGV4dHVyZUF2ZXJhZ2UpO1xuXG5cblxuXHQvLyBDb21wdXRlcyBvcGVyYXRpb24gYmV0d2VlbiBwaXhlbHMgKG1heCwgbWluKSAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZU1pbk1heCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJtaW5fdFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJtYXhfdFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJtaW5cIiwgXCJ2ZWM0XCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWF4XCIsIFwidmVjNFwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRtb2RlOiBcIm1heFwiLFxuXHRcdFx0dXNlX3ByZXZpb3VzX2ZyYW1lOiB0cnVlIC8vdG8gYXZvaWQgc3RhbGxzIFxuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMFxuXHRcdH07XG5cblx0XHR0aGlzLl9tYXggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXHRcdHRoaXMuX21pbiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cblx0XHR0aGlzLl90ZXh0dXJlc19jaGFpbiA9IFtdO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC53aWRnZXRzX2luZm8gPSB7XG5cdFx0bW9kZTogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBbXCJtaW5cIixcIm1heFwiLFwiYXZnXCJdIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWluTWF4LnRpdGxlID0gXCJNaW5NYXhcIjtcblx0TEdyYXBoVGV4dHVyZU1pbk1heC5kZXNjID0gXCJDb21wdXRlIHRoZSBzY2VuZSBtaW4gbWF4XCI7XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLnByb3BlcnRpZXMudXNlX3ByZXZpb3VzX2ZyYW1lKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLl9sdW1pbmFuY2UpO1xuXHR9O1xuXG5cdC8vZXhlY3V0ZWQgYmVmb3JlIHJlbmRlcmluZyB0aGUgZnJhbWVcblx0TEdyYXBoVGV4dHVyZU1pbk1heC5wcm90b3R5cGUub25QcmVSZW5kZXJFeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWluTWF4LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApICYmICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDEpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVNaW5NYXguX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZU1pbk1heC5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlTWluTWF4LnBpeGVsX3NoYWRlciApO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdHZhciB0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAodGV4LnR5cGUgIT0gdHlwZSkge1xuXHRcdFx0Ly9mb3JjZSBmbG9hdHMsIGhhbGYgZmxvYXRzIGNhbm5vdCBiZSByZWFkIHdpdGggZ2wucmVhZFBpeGVsc1xuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXHRcdH1cblxuXHRcdHZhciBzaXplID0gNTEyO1xuXG5cdFx0aWYoICF0aGlzLl90ZXh0dXJlc19jaGFpbi5sZW5ndGggfHwgdGhpcy5fdGV4dHVyZXNfY2hhaW5bMF0udHlwZSAhPSB0eXBlIClcblx0XHR7XG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdFx0d2hpbGUoaSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fdGV4dHVyZXNfY2hhaW5baV0gPSBuZXcgR0wuVGV4dHVyZSggc2l6ZSwgc2l6ZSwge1xuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2l6ZSA9IHNpemUgPj4gMjtcblx0XHRcdFx0aSsrO1xuXHRcdFx0XHRpZihzaXplID09IDEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4LmNvcHlUbyggdGhpcy5fdGV4dHVyZXNfY2hhaW5bMF0gKTtcblx0XHR2YXIgcHJldiA9IHRoaXMuX3RleHR1cmVzX2NoYWluWzBdO1xuXHRcdGZvcih2YXIgaSA9IDE7IGkgPD0gdGhpcy5fdGV4dHVyZXNfY2hhaW4ubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHRleCA9IHRoaXMuX3RleHR1cmVzX2NoYWluW2ldO1xuXG5cdFx0XHRwcmV2ID0gdGV4O1x0XHRcdFx0XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVNaW5NYXguX3NoYWRlcjtcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X21pcG1hcF9vZmZzZXQgPSB0aGlzLnByb3BlcnRpZXMubWlwbWFwX29mZnNldDtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXgudG9WaWV3cG9ydChzaGFkZXIsIHVuaWZvcm1zKTtcblx0XHR9KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWluTWF4LnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR1bmlmb3JtIG1hdDQgdV9zYW1wbGVzX2E7XFxuXFxcblx0XHR1bmlmb3JtIG1hdDQgdV9zYW1wbGVzX2I7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfbWlwbWFwX29mZnNldDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxcblx0XHRcdC8vcmFuZG9tIGF2ZXJhZ2VcXG5cXFxuXHRcdFx0Zm9yKGludCBpID0gMDsgaSA8IDQ7ICsraSlcXG5cXFxuXHRcdFx0XHRmb3IoaW50IGogPSAwOyBqIDwgNDsgKytqKVxcblxcXG5cdFx0XHRcdHtcXG5cXFxuXHRcdFx0XHRcdGNvbG9yICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZlYzIoIHVfc2FtcGxlc19hW2ldW2pdLCB1X3NhbXBsZXNfYltpXVtqXSApLCB1X21pcG1hcF9vZmZzZXQgKTtcXG5cXFxuXHRcdFx0XHRcdGNvbG9yICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZlYzIoIDEuMCAtIHVfc2FtcGxlc19hW2ldW2pdLCAxLjAgLSB1X3NhbXBsZXNfYltpXVtqXSApLCB1X21pcG1hcF9vZmZzZXQgKTtcXG5cXFxuXHRcdFx0XHR9XFxuXFxcblx0XHQgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIDAuMDMxMjU7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHQvL0xpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9jbHVzdGVyZWRfb3BlcmF0aW9uXCIsIExHcmFwaFRleHR1cmVDbHVzdGVyZWRPcGVyYXRpb24pO1xuXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcImZhY3RvclwiLCBcIk51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBmYWN0b3I6IDAuNSB9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV90ZXh0dXJlQjogMSxcblx0XHRcdHVfZmFjdG9yOiB0aGlzLnByb3BlcnRpZXMuZmFjdG9yXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC50aXRsZSA9IFwiU21vb3RoXCI7XG5cdExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5kZXNjID0gXCJTbW9vdGggdGV4dHVyZSBvdmVyIHRpbWVcIjtcblxuXHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGgucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGUgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0XG5cdFx0KSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdFx0dHlwZTogdGV4LnR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5ORUFSRVNUXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodGV4LndpZHRoLCB0ZXguaGVpZ2h0LCBvcHRpb25zICk7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUyID0gbmV3IEdMLlRleHR1cmUodGV4LndpZHRoLCB0ZXguaGVpZ2h0LCBvcHRpb25zICk7XG5cdFx0XHR0ZXguY29weVRvKHRoaXMuX3RlbXBfdGV4dHVyZTIpO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wQSA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHR2YXIgdGVtcEIgPSB0aGlzLl90ZW1wX3RleHR1cmUyO1xuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5fc2hhZGVyO1xuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfZmFjdG9yID0gMS4wIC0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJmYWN0b3JcIik7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdHRlbXBBLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRlbXBCLmJpbmQoMSk7XG5cdFx0XHR0ZXgudG9WaWV3cG9ydChzaGFkZXIsIHVuaWZvcm1zKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wQSk7XG5cblx0XHQvL3N3YXBcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSB0ZW1wQjtcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUyID0gdGVtcEE7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ZhY3RvcjtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IG1peCggdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKSwgdGV4dHVyZTJEKCB1X3RleHR1cmVCLCB2X2Nvb3JkICksIHVfZmFjdG9yICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL3RlbXBvcmFsX3Ntb290aFwiLCBMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGggKTtcblxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcImF2Z1wiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJhcnJheVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBzYW1wbGVzOiA2NCwgZnJhbWVzX2ludGVydmFsOiAxIH07XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHR1X3RleHR1cmVCOiAxLFxuXHRcdFx0dV9zYW1wbGVzOiB0aGlzLnByb3BlcnRpZXMuc2FtcGxlcyxcblx0XHRcdHVfaXNhbXBsZXM6IDEvdGhpcy5wcm9wZXJ0aWVzLnNhbXBsZXNcblx0XHR9O1xuXHRcdHRoaXMuZnJhbWUgPSAwO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC50aXRsZSA9IFwiTGluZWFsIEF2ZyBTbW9vdGhcIjtcblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5kZXNjID0gXCJTbW9vdGggdGV4dHVyZSBsaW5lYXJseSBvdmVyIHRpbWVcIjtcblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoW1wiQHNhbXBsZXNcIl0gPSB7IHR5cGU6IFwibnVtYmVyXCIsIG1pbjogMSwgbWF4OiA2NCwgc3RlcDogMSwgcHJlY2lzaW9uOiAxIH07XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5wcm90b3R5cGUuZ2V0UHJldmlld1RleHR1cmUgPSBmdW5jdGlvbigpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fdGVtcF90ZXh0dXJlMjtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4IHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGguX3NoYWRlcl9jb3B5ID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLnBpeGVsX3NoYWRlcl9jb3B5ICk7XG5cdFx0XHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLl9zaGFkZXJfYXZnID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLnBpeGVsX3NoYWRlcl9hdmcgKTtcblx0XHR9XG5cblx0XHR2YXIgc2FtcGxlcyA9IE1hdGguY2xhbXAodGhpcy5wcm9wZXJ0aWVzLnNhbXBsZXMsMCw2NCk7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5mcmFtZTtcblx0XHR2YXIgaW50ZXJ2YWwgPSB0aGlzLnByb3BlcnRpZXMuZnJhbWVzX2ludGVydmFsO1xuXG5cdFx0aWYoIGludGVydmFsID09IDAgfHwgZnJhbWUgJSBpbnRlcnZhbCA9PSAwIClcblx0XHR7XG5cdFx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRcdGlmICggIXRlbXAgfHwgdGVtcC50eXBlICE9IHRleC50eXBlIHx8IHRlbXAud2lkdGggIT0gc2FtcGxlcyApIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0dHlwZTogdGV4LnR5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSggc2FtcGxlcywgMSwgb3B0aW9ucyApO1xuXHRcdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUyID0gbmV3IEdMLlRleHR1cmUoIHNhbXBsZXMsIDEsIG9wdGlvbnMgKTtcblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlX291dCA9IG5ldyBHTC5UZXh0dXJlKCAxLCAxLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ZW1wQSA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRcdHZhciB0ZW1wQiA9IHRoaXMuX3RlbXBfdGV4dHVyZTI7XG5cblx0XHRcdHZhciBzaGFkZXJfY29weSA9IExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGguX3NoYWRlcl9jb3B5O1xuXHRcdFx0dmFyIHNoYWRlcl9hdmcgPSBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLl9zaGFkZXJfYXZnO1xuXHRcdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0XHR1bmlmb3Jtcy51X3NhbXBsZXMgPSBzYW1wbGVzO1xuXHRcdFx0dW5pZm9ybXMudV9pc2FtcGxlcyA9IDEuMCAvIHNhbXBsZXM7XG5cblx0XHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRcdHRlbXBBLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0dGVtcEIuYmluZCgxKTtcblx0XHRcdFx0dGV4LnRvVmlld3BvcnQoIHNoYWRlcl9jb3B5LCB1bmlmb3JtcyApO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZV9vdXQuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0ZW1wQS50b1ZpZXdwb3J0KCBzaGFkZXJfYXZnLCB1bmlmb3JtcyApO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5fdGVtcF90ZXh0dXJlX291dCApO1xuXG5cdFx0XHQvL3N3YXBcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IHRlbXBCO1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlMiA9IHRlbXBBO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlX291dCk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3RlbXBfdGV4dHVyZTIpO1xuXHRcdHRoaXMuZnJhbWUrKztcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLnBpeGVsX3NoYWRlcl9jb3B5ID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaXNhbXBsZXM7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRpZiggdl9jb29yZC54IDw9IHVfaXNhbXBsZXMgKVxcblxcXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2ZWMyKDAuNSkgKTtcXG5cXFxuXHRcdFx0ZWxzZVxcblxcXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlQiwgdl9jb29yZCAtIHZlYzIodV9pc2FtcGxlcywwLjApICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLnBpeGVsX3NoYWRlcl9hdmcgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBpbnQgdV9zYW1wbGVzO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2lzYW1wbGVzO1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXFxuXHRcdFx0Zm9yKGludCBpID0gMDsgaSA8IDY0OyArK2kpXFxuXFxcblx0XHRcdHtcXG5cXFxuXHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdmVjMiggZmxvYXQoaSkqdV9pc2FtcGxlcywwLjApICk7XFxuXFxcblx0XHRcdFx0aWYoaSA9PSAodV9zYW1wbGVzIC0gMSkpXFxuXFxcblx0XHRcdFx0XHRicmVhaztcXG5cXFxuXHRcdFx0fVxcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHVfaXNhbXBsZXM7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInRleHR1cmUvbGluZWFyX2F2Z19zbW9vdGhcIiwgTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aCApO1xuXG5cdC8vIEltYWdlIFRvIFRleHR1cmUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoSW1hZ2VUb1RleHR1cmUoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkltYWdlXCIsIFwiaW1hZ2VcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHt9O1xuXHR9XG5cblx0TEdyYXBoSW1hZ2VUb1RleHR1cmUudGl0bGUgPSBcIkltYWdlIHRvIFRleHR1cmVcIjtcblx0TEdyYXBoSW1hZ2VUb1RleHR1cmUuZGVzYyA9IFwiVXBsb2FkcyBhbiBpbWFnZSB0byB0aGUgR1BVXCI7XG5cdC8vTEdyYXBoSW1hZ2VUb1RleHR1cmUud2lkZ2V0c19pbmZvID0geyBzaXplOiB7IHdpZGdldDpcImNvbWJvXCIsIHZhbHVlczpbMCwzMiw2NCwxMjgsMjU2LDUxMiwxMDI0LDIwNDhdfSB9O1xuXG5cdExHcmFwaEltYWdlVG9UZXh0dXJlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1nID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCFpbWcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgd2lkdGggPSBpbWcudmlkZW9XaWR0aCB8fCBpbWcud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IGltZy52aWRlb0hlaWdodCB8fCBpbWcuaGVpZ2h0O1xuXG5cdFx0Ly90aGlzIGlzIGluIGNhc2Ugd2UgYXJlIHVzaW5nIGEgd2ViZ2wgY2FudmFzIGFscmVhZHksIG5vIG5lZWQgdG8gcmV1cGxvYWQgaXRcblx0XHRpZiAoaW1nLmdsdGV4dHVyZSkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIGltZy5nbHRleHR1cmUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmICghdGVtcCB8fCB0ZW1wLndpZHRoICE9IHdpZHRoIHx8IHRlbXAuaGVpZ2h0ICE9IGhlaWdodCkge1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUod2lkdGgsIGhlaWdodCwge1xuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLnVwbG9hZEltYWdlKGltZyk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcImltYWdlIGNvbWVzIGZyb20gYW4gdW5zYWZlIGxvY2F0aW9uLCBjYW5ub3QgYmUgdXBsb2FkZWQgdG8gd2ViZ2w6IFwiICtcblx0XHRcdFx0XHRlcnJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL2ltYWdlVG9UZXh0dXJlXCIsXG5cdFx0TEdyYXBoSW1hZ2VUb1RleHR1cmVcblx0KTtcblxuXHQvLyBUZXh0dXJlIExVVCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlTFVUKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiTFVUXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiSW50ZW5zaXR5XCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGVuYWJsZWQ6IHRydWUsIGludGVuc2l0eTogMSwgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQsIHRleHR1cmU6IG51bGwgfTtcblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZUxVVC5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlTFVULl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKCBTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsIExHcmFwaFRleHR1cmVMVVQucGl4ZWxfc2hhZGVyICk7XG5cdFx0fVxuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUxVVC53aWRnZXRzX2luZm8gPSB7XG5cdFx0dGV4dHVyZTogeyB3aWRnZXQ6IFwidGV4dHVyZVwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVMVVQudGl0bGUgPSBcIkxVVFwiO1xuXHRMR3JhcGhUZXh0dXJlTFVULmRlc2MgPSBcIkFwcGx5IExVVCB0byBUZXh0dXJlXCI7XG5cblx0TEdyYXBoVGV4dHVyZUxVVC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCB8fCB0aGlzLnByb3BlcnRpZXMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGx1dF90ZXggPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblxuXHRcdGlmICghbHV0X3RleCkge1xuXHRcdFx0bHV0X3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZSh0aGlzLnByb3BlcnRpZXMudGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFsdXRfdGV4KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsdXRfdGV4LmJpbmQoMCk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShcblx0XHRcdGdsLlRFWFRVUkVfMkQsXG5cdFx0XHRnbC5URVhUVVJFX1dSQVBfUyxcblx0XHRcdGdsLkNMQU1QX1RPX0VER0Vcblx0XHQpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoXG5cdFx0XHRnbC5URVhUVVJFXzJELFxuXHRcdFx0Z2wuVEVYVFVSRV9XUkFQX1QsXG5cdFx0XHRnbC5DTEFNUF9UT19FREdFXG5cdFx0KTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuXHRcdHZhciBpbnRlbnNpdHkgPSB0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5O1xuXHRcdGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMikpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHkgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHR9XG5cblx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXG5cdFx0XHR0ZXgsXG5cdFx0XHR0aGlzLl90ZXgsXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXG5cdFx0KTtcblxuXHRcdC8vdmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRsdXRfdGV4LmJpbmQoMSk7XG5cdFx0XHR0ZXgudG9WaWV3cG9ydChMR3JhcGhUZXh0dXJlTFVULl9zaGFkZXIsIHtcblx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHR1X3RleHR1cmVCOiAxLFxuXHRcdFx0XHR1X2Ftb3VudDogaW50ZW5zaXR5XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVMVVQucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9hbW91bnQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0IGxvd3AgdmVjNCB0ZXh0dXJlQ29sb3IgPSBjbGFtcCggdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCksIHZlYzQoMC4wKSwgdmVjNCgxLjApICk7XFxuXFxcblx0XHRcdCBtZWRpdW1wIGZsb2F0IGJsdWVDb2xvciA9IHRleHR1cmVDb2xvci5iICogNjMuMDtcXG5cXFxuXHRcdFx0IG1lZGl1bXAgdmVjMiBxdWFkMTtcXG5cXFxuXHRcdFx0IHF1YWQxLnkgPSBmbG9vcihmbG9vcihibHVlQ29sb3IpIC8gOC4wKTtcXG5cXFxuXHRcdFx0IHF1YWQxLnggPSBmbG9vcihibHVlQ29sb3IpIC0gKHF1YWQxLnkgKiA4LjApO1xcblxcXG5cdFx0XHQgbWVkaXVtcCB2ZWMyIHF1YWQyO1xcblxcXG5cdFx0XHQgcXVhZDIueSA9IGZsb29yKGNlaWwoYmx1ZUNvbG9yKSAvIDguMCk7XFxuXFxcblx0XHRcdCBxdWFkMi54ID0gY2VpbChibHVlQ29sb3IpIC0gKHF1YWQyLnkgKiA4LjApO1xcblxcXG5cdFx0XHQgaGlnaHAgdmVjMiB0ZXhQb3MxO1xcblxcXG5cdFx0XHQgdGV4UG9zMS54ID0gKHF1YWQxLnggKiAwLjEyNSkgKyAwLjUvNTEyLjAgKyAoKDAuMTI1IC0gMS4wLzUxMi4wKSAqIHRleHR1cmVDb2xvci5yKTtcXG5cXFxuXHRcdFx0IHRleFBvczEueSA9IDEuMCAtICgocXVhZDEueSAqIDAuMTI1KSArIDAuNS81MTIuMCArICgoMC4xMjUgLSAxLjAvNTEyLjApICogdGV4dHVyZUNvbG9yLmcpKTtcXG5cXFxuXHRcdFx0IGhpZ2hwIHZlYzIgdGV4UG9zMjtcXG5cXFxuXHRcdFx0IHRleFBvczIueCA9IChxdWFkMi54ICogMC4xMjUpICsgMC41LzUxMi4wICsgKCgwLjEyNSAtIDEuMC81MTIuMCkgKiB0ZXh0dXJlQ29sb3Iucik7XFxuXFxcblx0XHRcdCB0ZXhQb3MyLnkgPSAxLjAgLSAoKHF1YWQyLnkgKiAwLjEyNSkgKyAwLjUvNTEyLjAgKyAoKDAuMTI1IC0gMS4wLzUxMi4wKSAqIHRleHR1cmVDb2xvci5nKSk7XFxuXFxcblx0XHRcdCBsb3dwIHZlYzQgbmV3Q29sb3IxID0gdGV4dHVyZTJEKHVfdGV4dHVyZUIsIHRleFBvczEpO1xcblxcXG5cdFx0XHQgbG93cCB2ZWM0IG5ld0NvbG9yMiA9IHRleHR1cmUyRCh1X3RleHR1cmVCLCB0ZXhQb3MyKTtcXG5cXFxuXHRcdFx0IGxvd3AgdmVjNCBuZXdDb2xvciA9IG1peChuZXdDb2xvcjEsIG5ld0NvbG9yMiwgZnJhY3QoYmx1ZUNvbG9yKSk7XFxuXFxcblx0XHRcdCBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBtaXgoIHRleHR1cmVDb2xvci5yZ2IsIG5ld0NvbG9yLnJnYiwgdV9hbW91bnQpLCB0ZXh0dXJlQ29sb3Iudyk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvTFVUXCIsIExHcmFwaFRleHR1cmVMVVQpO1xuXG5cblx0Ly8gVGV4dHVyZSBMVVQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUVuY29kZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkF0bGFzXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBlbmFibGVkOiB0cnVlLCBudW1fcm93X3N5bWJvbHM6IDQsIHN5bWJvbF9zaXplOiAxNiwgYnJpZ2h0bmVzczogMSwgY29sb3JpemU6IGZhbHNlLCBmaWx0ZXI6IGZhbHNlLCBpbnZlcnQ6IGZhbHNlLCBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVCwgZ2VuZXJhdGVfbWlwbWFwczogZmFsc2UsIHRleHR1cmU6IG51bGwgfTtcblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZUVuY29kZS5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlRW5jb2RlLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKCBTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsIExHcmFwaFRleHR1cmVFbmNvZGUucGl4ZWxfc2hhZGVyICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0dV90ZXh0dXJlQjogMSxcblx0XHRcdFx0dV9yb3dfc2ltYm9sczogNCxcblx0XHRcdFx0dV9zaW1ib2xfc2l6ZTogMTYsXG5cdFx0XHRcdHVfcmVzOiB2ZWMyLmNyZWF0ZSgpXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVFbmNvZGUud2lkZ2V0c19pbmZvID0ge1xuXHRcdHRleHR1cmU6IHsgd2lkZ2V0OiBcInRleHR1cmVcIiB9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlRW5jb2RlLnRpdGxlID0gXCJFbmNvZGVcIjtcblx0TEdyYXBoVGV4dHVyZUVuY29kZS5kZXNjID0gXCJBcHBseSBhIHRleHR1cmUgYXRsYXMgdG8gZW5jb2RlIGEgdGV4dHVyZVwiO1xuXG5cdExHcmFwaFRleHR1cmVFbmNvZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0ggfHwgdGhpcy5wcm9wZXJ0aWVzLmVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzeW1ib2xzX3RleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXG5cdFx0aWYgKCFzeW1ib2xzX3RleCkge1xuXHRcdFx0c3ltYm9sc190ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmUodGhpcy5wcm9wZXJ0aWVzLnRleHR1cmUpO1xuXHRcdH1cblxuXHRcdGlmICghc3ltYm9sc190ZXgpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN5bWJvbHNfdGV4LmJpbmQoMCk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMucHJvcGVydGllcy5maWx0ZXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMucHJvcGVydGllcy5maWx0ZXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfcm93X3NpbWJvbHMgPSBNYXRoLmZsb29yKHRoaXMucHJvcGVydGllcy5udW1fcm93X3N5bWJvbHMpO1xuXHRcdHVuaWZvcm1zLnVfc3ltYm9sX3NpemUgPSB0aGlzLnByb3BlcnRpZXMuc3ltYm9sX3NpemU7XG5cdFx0dW5pZm9ybXMudV9icmlnaHRuZXNzID0gdGhpcy5wcm9wZXJ0aWVzLmJyaWdodG5lc3M7XG5cdFx0dW5pZm9ybXMudV9pbnZlcnQgPSB0aGlzLnByb3BlcnRpZXMuaW52ZXJ0ID8gMSA6IDA7XG5cdFx0dW5pZm9ybXMudV9jb2xvcml6ZSA9IHRoaXMucHJvcGVydGllcy5jb2xvcml6ZSA/IDEgOiAwO1xuXG5cdFx0dGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKCB0ZXgsIHRoaXMuX3RleCwgdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdHVuaWZvcm1zLnVfcmVzWzBdID0gdGhpcy5fdGV4LndpZHRoO1xuXHRcdHVuaWZvcm1zLnVfcmVzWzFdID0gdGhpcy5fdGV4LmhlaWdodDtcblx0XHR0aGlzLl90ZXguYmluZCgwKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3ltYm9sc190ZXguYmluZCgxKTtcblx0XHRcdHRleC50b1ZpZXdwb3J0KExHcmFwaFRleHR1cmVFbmNvZGUuX3NoYWRlciwgdW5pZm9ybXMpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzKSB7XG5cdFx0XHR0aGlzLl90ZXguYmluZCgwKTtcblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuX3RleC50ZXh0dXJlX3R5cGUpO1xuXHRcdFx0dGhpcy5fdGV4LnVuYmluZCgwKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlRW5jb2RlLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfcm93X3NpbWJvbHM7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfc3ltYm9sX3NpemU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzcztcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9pbnZlcnQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfY29sb3JpemU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9yZXM7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMiB0b3RhbF9zeW1ib2xzID0gdV9yZXMgLyB1X3N5bWJvbF9zaXplO1xcblxcXG5cdFx0XHR2ZWMyIHV2ID0gZmxvb3Iodl9jb29yZCAqIHRvdGFsX3N5bWJvbHMpIC8gdG90YWxfc3ltYm9sczsgLy9waXhlbGF0ZSBcXG5cXFxuXHRcdFx0dmVjMiBsb2NhbF91diA9IG1vZCh2X2Nvb3JkICogdV9yZXMsIHVfc3ltYm9sX3NpemUpIC8gdV9zeW1ib2xfc2l6ZTtcXG5cXFxuXHRcdFx0bG93cCB2ZWM0IHRleHR1cmVDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bSA9IGNsYW1wKHVfYnJpZ2h0bmVzcyAqICh0ZXh0dXJlQ29sb3IueCArIHRleHR1cmVDb2xvci55ICsgdGV4dHVyZUNvbG9yLnopLzMuMCwwLjAsMS4wKTtcXG5cXFxuXHRcdFx0aWYoIHVfaW52ZXJ0ID09IDEuMCApIGx1bSA9IDEuMCAtIGx1bTtcXG5cXFxuXHRcdFx0ZmxvYXQgaW5kZXggPSBmbG9vciggbHVtICogKHVfcm93X3NpbWJvbHMgKiB1X3Jvd19zaW1ib2xzIC0gMS4wKSk7XFxuXFxcblx0XHRcdGZsb2F0IGNvbCA9IG1vZCggaW5kZXgsIHVfcm93X3NpbWJvbHMgKTtcXG5cXFxuXHRcdFx0ZmxvYXQgcm93ID0gdV9yb3dfc2ltYm9scyAtIGZsb29yKCBpbmRleCAvIHVfcm93X3NpbWJvbHMgKSAtIDEuMDtcXG5cXFxuXHRcdFx0dmVjMiBzaW1ib2xfdXYgPSAoIHZlYzIoIGNvbCwgcm93ICkgKyBsb2NhbF91diApIC8gdV9yb3dfc2ltYm9scztcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlQiwgc2ltYm9sX3V2ICk7XFxuXFxcblx0XHRcdGlmKHVfY29sb3JpemUgPT0gMS4wKVxcblxcXG5cdFx0XHRcdGNvbG9yICo9IHRleHR1cmVDb2xvcjtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZW5jb2RlXCIsIExHcmFwaFRleHR1cmVFbmNvZGUpO1xuXG5cdC8vIFRleHR1cmUgQ2hhbm5lbHMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUNoYW5uZWxzKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiUlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJHXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIkJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiQVwiLCBcIlRleHR1cmVcIik7XG5cblx0XHQvL3RoaXMucHJvcGVydGllcyA9IHsgdXNlX3NpbmdsZV9jaGFubmVsOiB0cnVlIH07XG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlQ2hhbm5lbHMuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVDaGFubmVscy5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzLnRpdGxlID0gXCJUZXh0dXJlIHRvIENoYW5uZWxzXCI7XG5cdExHcmFwaFRleHR1cmVDaGFubmVscy5kZXNjID0gXCJTcGxpdCB0ZXh0dXJlIGNoYW5uZWxzXCI7XG5cblx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4QSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4QSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fY2hhbm5lbHMpIHtcblx0XHRcdHRoaXMuX2NoYW5uZWxzID0gQXJyYXkoNCk7XG5cdFx0fVxuXG5cdFx0Ly92YXIgZm9ybWF0ID0gdGhpcy5wcm9wZXJ0aWVzLnVzZV9zaW5nbGVfY2hhbm5lbCA/IGdsLkxVTUlOQU5DRSA6IGdsLlJHQkE7IC8vbm90IHN1cHBvcnRlZCBieSBXZWJHTDFcblx0XHR2YXIgZm9ybWF0ID0gZ2wuUkdCO1xuXHRcdHZhciBjb25uZWN0aW9ucyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKGkpKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhdGhpcy5fY2hhbm5lbHNbaV0gfHxcblx0XHRcdFx0XHR0aGlzLl9jaGFubmVsc1tpXS53aWR0aCAhPSB0ZXhBLndpZHRoIHx8XG5cdFx0XHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0uaGVpZ2h0ICE9IHRleEEuaGVpZ2h0IHx8XG5cdFx0XHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0udHlwZSAhPSB0ZXhBLnR5cGUgfHxcblx0XHRcdFx0XHR0aGlzLl9jaGFubmVsc1tpXS5mb3JtYXQgIT0gZm9ybWF0XG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdFx0XHR0ZXhBLndpZHRoLFxuXHRcdFx0XHRcdFx0dGV4QS5oZWlnaHQsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IHRleEEudHlwZSxcblx0XHRcdFx0XHRcdFx0Zm9ybWF0OiBmb3JtYXQsXG5cdFx0XHRcdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25uZWN0aW9ucysrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghY29ubmVjdGlvbnMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUNoYW5uZWxzLl9zaGFkZXI7XG5cdFx0dmFyIG1hc2tzID0gW1xuXHRcdFx0WzEsIDAsIDAsIDBdLFxuXHRcdFx0WzAsIDEsIDAsIDBdLFxuXHRcdFx0WzAsIDAsIDEsIDBdLFxuXHRcdFx0WzAsIDAsIDAsIDFdXG5cdFx0XTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2NoYW5uZWxzW2ldKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jaGFubmVsc1tpXS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRleEEuYmluZCgwKTtcblx0XHRcdFx0c2hhZGVyXG5cdFx0XHRcdFx0LnVuaWZvcm1zKHsgdV90ZXh0dXJlOiAwLCB1X21hc2s6IG1hc2tzW2ldIH0pXG5cdFx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YShpLCB0aGlzLl9jaGFubmVsc1tpXSk7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVDaGFubmVscy5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzQgdV9tYXNrO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHQgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBsZW5ndGgoIHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpICogdV9tYXNrICkpLCAxLjAgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxuXHRcdFwidGV4dHVyZS90ZXh0dXJlQ2hhbm5lbHNcIixcblx0XHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHNcblx0KTtcblxuXHQvLyBUZXh0dXJlIENoYW5uZWxzIHRvIFRleHR1cmUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoQ2hhbm5lbHNUZXh0dXJlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJSXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiR1wiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVCxcblx0XHRcdFI6IDEsXG5cdFx0XHRHOiAxLFxuXHRcdFx0QjogMSxcblx0XHRcdEE6IDFcblx0XHR9O1xuXHRcdHRoaXMuX2NvbG9yID0gdmVjNC5jcmVhdGUoKTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZVI6IDAsXG5cdFx0XHR1X3RleHR1cmVHOiAxLFxuXHRcdFx0dV90ZXh0dXJlQjogMixcblx0XHRcdHVfdGV4dHVyZUE6IDMsXG5cdFx0XHR1X2NvbG9yOiB0aGlzLl9jb2xvclxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhDaGFubmVsc1RleHR1cmUudGl0bGUgPSBcIkNoYW5uZWxzIHRvIFRleHR1cmVcIjtcblx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLmRlc2MgPSBcIlNwbGl0IHRleHR1cmUgY2hhbm5lbHNcIjtcblx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgd2hpdGUgPSBMR3JhcGhUZXh0dXJlLmdldFdoaXRlVGV4dHVyZSgpO1xuXHRcdHZhciB0ZXhSID0gdGhpcy5nZXRJbnB1dERhdGEoMCkgfHwgd2hpdGU7XG5cdFx0dmFyIHRleEcgPSB0aGlzLmdldElucHV0RGF0YSgxKSB8fCB3aGl0ZTtcblx0XHR2YXIgdGV4QiA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpIHx8IHdoaXRlO1xuXHRcdHZhciB0ZXhBID0gdGhpcy5nZXRJbnB1dERhdGEoMykgfHwgd2hpdGU7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRpZiAoIUxHcmFwaENoYW5uZWxzVGV4dHVyZS5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhDaGFubmVsc1RleHR1cmUuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaENoYW5uZWxzVGV4dHVyZS5fc2hhZGVyO1xuXG5cdFx0dmFyIHcgPSBNYXRoLm1heCh0ZXhSLndpZHRoLCB0ZXhHLndpZHRoLCB0ZXhCLndpZHRoLCB0ZXhBLndpZHRoKTtcblx0XHR2YXIgaCA9IE1hdGgubWF4KFxuXHRcdFx0dGV4Ui5oZWlnaHQsXG5cdFx0XHR0ZXhHLmhlaWdodCxcblx0XHRcdHRleEIuaGVpZ2h0LFxuXHRcdFx0dGV4QS5oZWlnaHRcblx0XHQpO1xuXHRcdHZhciB0eXBlID1cblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT0gTEdyYXBoVGV4dHVyZS5ISUdIXG5cdFx0XHRcdD8gTEdyYXBoVGV4dHVyZS5ISUdIX1BSRUNJU0lPTl9GT1JNQVRcblx0XHRcdFx0OiBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuX3RleHR1cmUgfHxcblx0XHRcdHRoaXMuX3RleHR1cmUud2lkdGggIT0gdyB8fFxuXHRcdFx0dGhpcy5fdGV4dHVyZS5oZWlnaHQgIT0gaCB8fFxuXHRcdFx0dGhpcy5fdGV4dHVyZS50eXBlICE9IHR5cGVcblx0XHQpIHtcblx0XHRcdHRoaXMuX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3LCBoLCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBjb2xvciA9IHRoaXMuX2NvbG9yO1xuXHRcdGNvbG9yWzBdID0gdGhpcy5wcm9wZXJ0aWVzLlI7XG5cdFx0Y29sb3JbMV0gPSB0aGlzLnByb3BlcnRpZXMuRztcblx0XHRjb2xvclsyXSA9IHRoaXMucHJvcGVydGllcy5CO1xuXHRcdGNvbG9yWzNdID0gdGhpcy5wcm9wZXJ0aWVzLkE7XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cblx0XHR0aGlzLl90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleFIuYmluZCgwKTtcblx0XHRcdHRleEcuYmluZCgxKTtcblx0XHRcdHRleEIuYmluZCgyKTtcblx0XHRcdHRleEEuYmluZCgzKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhtZXNoKTtcblx0XHR9KTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4dHVyZSk7XG5cdH07XG5cblx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZVI7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVHO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUE7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvciAqIHZlYzQoIFxcXG5cdFx0XHRcdFx0dGV4dHVyZTJEKHVfdGV4dHVyZVIsIHZfY29vcmQpLnIsXFxcblx0XHRcdFx0XHR0ZXh0dXJlMkQodV90ZXh0dXJlRywgdl9jb29yZCkucixcXFxuXHRcdFx0XHRcdHRleHR1cmUyRCh1X3RleHR1cmVCLCB2X2Nvb3JkKS5yLFxcXG5cdFx0XHRcdFx0dGV4dHVyZTJEKHVfdGV4dHVyZUEsIHZfY29vcmQpLnIpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL2NoYW5uZWxzVGV4dHVyZVwiLFxuXHRcdExHcmFwaENoYW5uZWxzVGV4dHVyZVxuXHQpO1xuXG5cdC8vIFRleHR1cmUgQ29sb3IgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUNvbG9yKCkge1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLl90ZXhfY29sb3IgPSB2ZWM0LmNyZWF0ZSgpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGNvbG9yOiB2ZWM0LmNyZWF0ZSgpLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUNvbG9yLnRpdGxlID0gXCJDb2xvclwiO1xuXHRMR3JhcGhUZXh0dXJlQ29sb3IuZGVzYyA9XG5cdFx0XCJHZW5lcmF0ZXMgYSAxeDEgdGV4dHVyZSB3aXRoIGEgY29uc3RhbnQgY29sb3JcIjtcblxuXHRMR3JhcGhUZXh0dXJlQ29sb3Iud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ29sb3IucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgYyA9IHRoaXMucHJvcGVydGllcy5jb2xvcjtcblx0XHRjdHguZmlsbFN0eWxlID1cblx0XHRcdFwicmdiKFwiICtcblx0XHRcdE1hdGguZmxvb3IoTWF0aC5jbGFtcChjWzBdLCAwLCAxKSAqIDI1NSkgK1xuXHRcdFx0XCIsXCIgK1xuXHRcdFx0TWF0aC5mbG9vcihNYXRoLmNsYW1wKGNbMV0sIDAsIDEpICogMjU1KSArXG5cdFx0XHRcIixcIiArXG5cdFx0XHRNYXRoLmZsb29yKE1hdGguY2xhbXAoY1syXSwgMCwgMSkgKiAyNTUpICtcblx0XHRcdFwiKVwiO1xuXHRcdGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IGN0eC5maWxsU3R5bGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVDb2xvci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUgPVxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PSBMR3JhcGhUZXh0dXJlLkhJR0hcblx0XHRcdFx0PyBMR3JhcGhUZXh0dXJlLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVFxuXHRcdFx0XHQ6IGdsLlVOU0lHTkVEX0JZVEU7XG5cblx0XHRpZiAoIXRoaXMuX3RleCB8fCB0aGlzLl90ZXgudHlwZSAhPSB0eXBlKSB7XG5cdFx0XHR0aGlzLl90ZXggPSBuZXcgR0wuVGV4dHVyZSgxLCAxLCB7XG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0bWluRmlsdGVyOiBnbC5ORUFSRVNUXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dmFyIGNvbG9yID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuXG5cdFx0aWYgKHRoaXMuaW5wdXRzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xuXHRcdFx0XHRpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChpbnB1dC5uYW1lKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIlJHQlwiOlxuXHRcdFx0XHRcdGNhc2UgXCJSR0JBXCI6XG5cdFx0XHRcdFx0XHRjb2xvci5zZXQodik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiUlwiOlxuXHRcdFx0XHRcdFx0Y29sb3JbMF0gPSB2O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkdcIjpcblx0XHRcdFx0XHRcdGNvbG9yWzFdID0gdjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJCXCI6XG5cdFx0XHRcdFx0XHRjb2xvclsyXSA9IHY7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiQVwiOlxuXHRcdFx0XHRcdFx0Y29sb3JbM10gPSB2O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodmVjNC5zcXJEaXN0KHRoaXMuX3RleF9jb2xvciwgY29sb3IpID4gMC4wMDEpIHtcblx0XHRcdHRoaXMuX3RleF9jb2xvci5zZXQoY29sb3IpO1xuXHRcdFx0dGhpcy5fdGV4LmZpbGwoY29sb3IpO1xuXHRcdH1cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ29sb3IucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcIlJHQlwiLCBcInZlYzNcIl0sXG5cdFx0XHRbXCJSR0JBXCIsIFwidmVjNFwiXSxcblx0XHRcdFtcIlJcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJHXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiQlwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIkFcIiwgXCJudW1iZXJcIl1cblx0XHRdO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9jb2xvclwiLCBMR3JhcGhUZXh0dXJlQ29sb3IpO1xuXG5cdC8vIFRleHR1cmUgQ2hhbm5lbHMgdG8gVGV4dHVyZSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlR3JhZGllbnQoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIiwgXCJjb2xvclwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiLCBcImNvbG9yXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRhbmdsZTogMCxcblx0XHRcdHNjYWxlOiAxLFxuXHRcdFx0QTogWzAsIDAsIDBdLFxuXHRcdFx0QjogWzEsIDEsIDFdLFxuXHRcdFx0dGV4dHVyZV9zaXplOiAzMlxuXHRcdH07XG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlR3JhZGllbnQuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUdyYWRpZW50Ll9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVHcmFkaWVudC5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X2FuZ2xlOiAwLFxuXHRcdFx0dV9jb2xvckE6IHZlYzMuY3JlYXRlKCksXG5cdFx0XHR1X2NvbG9yQjogdmVjMy5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnQudGl0bGUgPSBcIkdyYWRpZW50XCI7XG5cdExHcmFwaFRleHR1cmVHcmFkaWVudC5kZXNjID0gXCJHZW5lcmF0ZXMgYSBncmFkaWVudFwiO1xuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnRbXCJAQVwiXSA9IHsgdHlwZTogXCJjb2xvclwiIH07XG5cdExHcmFwaFRleHR1cmVHcmFkaWVudFtcIkBCXCJdID0geyB0eXBlOiBcImNvbG9yXCIgfTtcblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50W1wiQHRleHR1cmVfc2l6ZVwiXSA9IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IFszMiwgNjQsIDEyOCwgMjU2LCA1MTJdXG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0dmFyIG1lc2ggPSBHTC5NZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUdyYWRpZW50Ll9zaGFkZXI7XG5cblx0XHR2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghQSkge1xuXHRcdFx0QSA9IHRoaXMucHJvcGVydGllcy5BO1xuXHRcdH1cblx0XHR2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGlmICghQikge1xuXHRcdFx0QiA9IHRoaXMucHJvcGVydGllcy5CO1xuXHRcdH1cblxuXHRcdC8vYW5nbGUgYW5kIHNjYWxlXG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG5cdFx0XHR2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xuXHRcdFx0aWYgKHYgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucHJvcGVydGllc1tpbnB1dC5uYW1lXSA9IHY7XG5cdFx0fVxuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dGhpcy5fdW5pZm9ybXMudV9hbmdsZSA9IHRoaXMucHJvcGVydGllcy5hbmdsZSAqIERFRzJSQUQ7XG5cdFx0dGhpcy5fdW5pZm9ybXMudV9zY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZTtcblx0XHR2ZWMzLmNvcHkodW5pZm9ybXMudV9jb2xvckEsIEEpO1xuXHRcdHZlYzMuY29weSh1bmlmb3Jtcy51X2NvbG9yQiwgQik7XG5cblx0XHR2YXIgc2l6ZSA9IHBhcnNlSW50KHRoaXMucHJvcGVydGllcy50ZXh0dXJlX3NpemUpO1xuXHRcdGlmICghdGhpcy5fdGV4IHx8IHRoaXMuX3RleC53aWR0aCAhPSBzaXplKSB7XG5cdFx0XHR0aGlzLl90ZXggPSBuZXcgR0wuVGV4dHVyZShzaXplLCBzaXplLCB7XG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhtZXNoKTtcblx0XHR9KTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJhbmdsZVwiLCBcIm51bWJlclwiXSwgW1wic2NhbGVcIiwgXCJudW1iZXJcIl1dO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVHcmFkaWVudC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfYW5nbGU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzMgdV9jb2xvckE7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzMgdV9jb2xvckI7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZlYzIgcm90YXRlKHZlYzIgdiwgZmxvYXQgYW5nbGUpXFxuXFxcblx0XHR7XFxuXFxcblx0XHRcdHZlYzIgcmVzdWx0O1xcblxcXG5cdFx0XHRmbG9hdCBfY29zID0gY29zKGFuZ2xlKTtcXG5cXFxuXHRcdFx0ZmxvYXQgX3NpbiA9IHNpbihhbmdsZSk7XFxuXFxcblx0XHRcdHJlc3VsdC54ID0gdi54ICogX2NvcyAtIHYueSAqIF9zaW47XFxuXFxcblx0XHRcdHJlc3VsdC55ID0gdi54ICogX3NpbiArIHYueSAqIF9jb3M7XFxuXFxcblx0XHRcdHJldHVybiByZXN1bHQ7XFxuXFxcblx0XHR9XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdGZsb2F0IGYgPSAocm90YXRlKHVfc2NhbGUgKiAodl9jb29yZCAtIHZlYzIoMC41KSksIHVfYW5nbGUpICsgdmVjMigwLjUpKS54O1xcblxcXG5cdFx0XHR2ZWMzIGNvbG9yID0gbWl4KHVfY29sb3JBLHVfY29sb3JCLGNsYW1wKGYsMC4wLDEuMCkpO1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwxLjApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2dyYWRpZW50XCIsIExHcmFwaFRleHR1cmVHcmFkaWVudCk7XG5cblx0Ly8gVGV4dHVyZSBNaXggKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZU1peCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiQVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJNaXhlclwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZmFjdG9yOiAwLjUsIHNpemVfZnJvbV9iaWdnZXN0OiB0cnVlLCBpbnZlcnQ6IGZhbHNlLCBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVCB9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlQTogMCxcblx0XHRcdHVfdGV4dHVyZUI6IDEsXG5cdFx0XHR1X3RleHR1cmVNaXg6IDIsXG5cdFx0XHR1X21peDogdmVjNC5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlTWl4LnRpdGxlID0gXCJNaXhcIjtcblx0TEdyYXBoVGV4dHVyZU1peC5kZXNjID0gXCJHZW5lcmF0ZXMgYSB0ZXh0dXJlIG1peGluZyB0d28gdGV4dHVyZXNcIjtcblxuXHRMR3JhcGhUZXh0dXJlTWl4LndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1peC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXhBKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGV4QiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGlmICghdGV4QSB8fCAhdGV4Qikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhNaXggPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblxuXHRcdHZhciBmYWN0b3IgPSB0aGlzLmdldElucHV0RGF0YSgzKTtcblxuXHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcblx0XHRcdHRoaXMucHJvcGVydGllcy5zaXplX2Zyb21fYmlnZ2VzdCAmJiB0ZXhCLndpZHRoID4gdGV4QS53aWR0aCA/IHRleEIgOiB0ZXhBLFxuXHRcdFx0dGhpcy5fdGV4LFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxuXHRcdCk7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHR2YXIgc2hhZGVyID0gbnVsbDtcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHRpZiAodGV4TWl4KSB7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWl4Ll9zaGFkZXJfdGV4O1xuXHRcdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdFx0c2hhZGVyID0gTEdyYXBoVGV4dHVyZU1peC5fc2hhZGVyX3RleCA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdExHcmFwaFRleHR1cmVNaXgucGl4ZWxfc2hhZGVyLFxuXHRcdFx0XHRcdHsgTUlYX1RFWDogXCJcIiB9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVNaXguX3NoYWRlcl9mYWN0b3I7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWl4Ll9zaGFkZXJfZmFjdG9yID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0TEdyYXBoVGV4dHVyZU1peC5waXhlbF9zaGFkZXJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHZhciBmID0gZmFjdG9yID09IG51bGwgPyB0aGlzLnByb3BlcnRpZXMuZmFjdG9yIDogZmFjdG9yO1xuXHRcdFx0dW5pZm9ybXMudV9taXguc2V0KFtmLCBmLCBmLCBmXSk7XG5cdFx0fVxuXG5cdFx0dmFyIGludmVydCA9IHRoaXMucHJvcGVydGllcy5pbnZlcnQ7XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4QS5iaW5kKCBpbnZlcnQgPyAxIDogMCApO1xuXHRcdFx0dGV4Qi5iaW5kKCBpbnZlcnQgPyAwIDogMSApO1xuXHRcdFx0aWYgKHRleE1peCkge1xuXHRcdFx0XHR0ZXhNaXguYmluZCgyKTtcblx0XHRcdH1cblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVNaXgucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJmYWN0b3JcIiwgXCJudW1iZXJcIl1dO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVNaXgucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHQjaWZkZWYgTUlYX1RFWFxcblxcXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVNaXg7XFxuXFxcblx0XHQjZWxzZVxcblxcXG5cdFx0XHR1bmlmb3JtIHZlYzQgdV9taXg7XFxuXFxcblx0XHQjZW5kaWZcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHQjaWZkZWYgTUlYX1RFWFxcblxcXG5cdFx0XHQgICB2ZWM0IGYgPSB0ZXh0dXJlMkQodV90ZXh0dXJlTWl4LCB2X2Nvb3JkKTtcXG5cXFxuXHRcdFx0I2Vsc2VcXG5cXFxuXHRcdFx0ICAgdmVjNCBmID0gdV9taXg7XFxuXFxcblx0XHRcdCNlbmRpZlxcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gbWl4KCB0ZXh0dXJlMkQodV90ZXh0dXJlQSwgdl9jb29yZCksIHRleHR1cmUyRCh1X3RleHR1cmVCLCB2X2Nvb3JkKSwgZiApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL21peFwiLCBMR3JhcGhUZXh0dXJlTWl4KTtcblxuXHQvLyBUZXh0dXJlIEVkZ2VzIGRldGVjdGlvbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlRWRnZXMoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleC5cIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJFZGdlc1wiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0aW52ZXJ0OiB0cnVlLFxuXHRcdFx0dGhyZXNob2xkOiBmYWxzZSxcblx0XHRcdGZhY3RvcjogMSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZUVkZ2VzLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVFZGdlcy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlRWRnZXMucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdExHcmFwaFRleHR1cmVFZGdlcy50aXRsZSA9IFwiRWRnZXNcIjtcblx0TEdyYXBoVGV4dHVyZUVkZ2VzLmRlc2MgPSBcIkRldGVjdHMgZWRnZXNcIjtcblxuXHRMR3JhcGhUZXh0dXJlRWRnZXMud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlRWRnZXMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxuXHRcdFx0dGV4LFxuXHRcdFx0dGhpcy5fdGV4LFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxuXHRcdCk7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUVkZ2VzLl9zaGFkZXI7XG5cdFx0dmFyIGludmVydCA9IHRoaXMucHJvcGVydGllcy5pbnZlcnQ7XG5cdFx0dmFyIGZhY3RvciA9IHRoaXMucHJvcGVydGllcy5mYWN0b3I7XG5cdFx0dmFyIHRocmVzaG9sZCA9IHRoaXMucHJvcGVydGllcy50aHJlc2hvbGQgPyAxIDogMDtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X2lzaXplOiBbMSAvIHRleC53aWR0aCwgMSAvIHRleC5oZWlnaHRdLFxuXHRcdFx0XHRcdHVfZmFjdG9yOiBmYWN0b3IsXG5cdFx0XHRcdFx0dV90aHJlc2hvbGQ6IHRocmVzaG9sZCxcblx0XHRcdFx0XHR1X2ludmVydDogaW52ZXJ0ID8gMSA6IDBcblx0XHRcdFx0fSlcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlRWRnZXMucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfaXNpemU7XFxuXFxcblx0XHR1bmlmb3JtIGludCB1X2ludmVydDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mYWN0b3I7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfdGhyZXNob2xkO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzQgY2VudGVyID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcblx0XHRcdHZlYzQgdXAgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9pc2l6ZSAqIHZlYzIoMC4wLDEuMCkgKTtcXG5cXFxuXHRcdFx0dmVjNCBkb3duID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfaXNpemUgKiB2ZWMyKDAuMCwtMS4wKSApO1xcblxcXG5cdFx0XHR2ZWM0IGxlZnQgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9pc2l6ZSAqIHZlYzIoMS4wLDAuMCkgKTtcXG5cXFxuXHRcdFx0dmVjNCByaWdodCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X2lzaXplICogdmVjMigtMS4wLDAuMCkgKTtcXG5cXFxuXHRcdFx0dmVjNCBkaWZmID0gYWJzKGNlbnRlciAtIHVwKSArIGFicyhjZW50ZXIgLSBkb3duKSArIGFicyhjZW50ZXIgLSBsZWZ0KSArIGFicyhjZW50ZXIgLSByaWdodCk7XFxuXFxcblx0XHRcdGRpZmYgKj0gdV9mYWN0b3I7XFxuXFxcblx0XHRcdGlmKHVfaW52ZXJ0ID09IDEpXFxuXFxcblx0XHRcdFx0ZGlmZi54eXogPSB2ZWMzKDEuMCkgLSBkaWZmLnh5ejtcXG5cXFxuXHRcdFx0aWYoIHVfdGhyZXNob2xkID09IDAuMCApXFxuXFxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggZGlmZi54eXosIGNlbnRlci5hICk7XFxuXFxcblx0XHRcdGVsc2VcXG5cXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkaWZmLnggPiAwLjUgPyAxLjAgOiAwLjAsIGRpZmYueSA+IDAuNSA/IDEuMCA6IDAuMCwgZGlmZi56ID4gMC41ID8gMS4wIDogMC4wLCBjZW50ZXIuYSApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2VkZ2VzXCIsIExHcmFwaFRleHR1cmVFZGdlcyk7XG5cblx0Ly8gVGV4dHVyZSBEZXB0aCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkRpc3RhbmNlXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJSYW5nZVwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGRpc3RhbmNlOiAxMDAsXG5cdFx0XHRyYW5nZTogNTAsXG5cdFx0XHRvbmx5X2RlcHRoOiBmYWxzZSxcblx0XHRcdGhpZ2hfcHJlY2lzaW9uOiBmYWxzZVxuXHRcdH07XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHR1X2Rpc3RhbmNlOiAxMDAsXG5cdFx0XHR1X3JhbmdlOiA1MCxcblx0XHRcdHVfY2FtZXJhX3BsYW5lczogbnVsbFxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS50aXRsZSA9IFwiRGVwdGggUmFuZ2VcIjtcblx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UuZGVzYyA9IFwiR2VuZXJhdGVzIGEgdGV4dHVyZSB3aXRoIGEgZGVwdGggcmFuZ2VcIjtcblxuXHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwcmVjaXNpb24gPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuaGlnaF9wcmVjaXNpb24pIHtcblx0XHRcdHByZWNpc2lvbiA9IGdsLmhhbGZfZmxvYXRfZXh0ID8gZ2wuSEFMRl9GTE9BVF9PRVMgOiBnbC5GTE9BVDtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQhdGhpcy5fdGVtcF90ZXh0dXJlIHx8XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUudHlwZSAhPSBwcmVjaXNpb24gfHxcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS53aWR0aCAhPSB0ZXgud2lkdGggfHxcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodFxuXHRcdCkge1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7XG5cdFx0XHRcdHR5cGU6IHByZWNpc2lvbixcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cblx0XHQvL2l0ZXJhdGlvbnNcblx0XHR2YXIgZGlzdGFuY2UgPSB0aGlzLnByb3BlcnRpZXMuZGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgxKSkge1xuXHRcdFx0ZGlzdGFuY2UgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH1cblxuXHRcdHZhciByYW5nZSA9IHRoaXMucHJvcGVydGllcy5yYW5nZTtcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDIpKSB7XG5cdFx0XHRyYW5nZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnJhbmdlID0gcmFuZ2U7XG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMudV9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdHVuaWZvcm1zLnVfcmFuZ2UgPSByYW5nZTtcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRpZiAoIUxHcmFwaFRleHR1cmVEZXB0aFJhbmdlLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHRcdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLl9zaGFkZXJfb25seWRlcHRoID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5waXhlbF9zaGFkZXIsXG5cdFx0XHRcdHsgT05MWV9ERVBUSDogXCJcIiB9XG5cdFx0XHQpO1xuXHRcdH1cblx0XHR2YXIgc2hhZGVyID0gdGhpcy5wcm9wZXJ0aWVzLm9ubHlfZGVwdGhcblx0XHRcdD8gTEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UuX3NoYWRlcl9vbmx5ZGVwdGhcblx0XHRcdDogTEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UuX3NoYWRlcjtcblxuXHRcdC8vTkVBUiBBTkQgRkFSIFBMQU5FU1xuXHRcdHZhciBwbGFuZXMgPSBudWxsO1xuXHRcdGlmICh0ZXgubmVhcl9mYXJfcGxhbmVzKSB7XG5cdFx0XHRwbGFuZXMgPSB0ZXgubmVhcl9mYXJfcGxhbmVzO1xuXHRcdH0gZWxzZSBpZiAod2luZG93LkxTICYmIExTLlJlbmRlcmVyLl9tYWluX2NhbWVyYSkge1xuXHRcdFx0cGxhbmVzID0gTFMuUmVuZGVyZXIuX21haW5fY2FtZXJhLl91bmlmb3Jtcy51X2NhbWVyYV9wbGFuZXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBsYW5lcyA9IFswLjEsIDEwMDBdO1xuXHRcdH0gLy9oYXJkY29kZWRcblx0XHR1bmlmb3Jtcy51X2NhbWVyYV9wbGFuZXMgPSBwbGFuZXM7XG5cblx0XHR0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl90ZW1wX3RleHR1cmUubmVhcl9mYXJfcGxhbmVzID0gcGxhbmVzO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X2NhbWVyYV9wbGFuZXM7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZGlzdGFuY2U7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfcmFuZ2U7XFxuXFxcblx0XHRcXG5cXFxuXHRcdGZsb2F0IExpbmVhckRlcHRoKClcXG5cXFxuXHRcdHtcXG5cXFxuXHRcdFx0ZmxvYXQgek5lYXIgPSB1X2NhbWVyYV9wbGFuZXMueDtcXG5cXFxuXHRcdFx0ZmxvYXQgekZhciA9IHVfY2FtZXJhX3BsYW5lcy55O1xcblxcXG5cdFx0XHRmbG9hdCBkZXB0aCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpLng7XFxuXFxcblx0XHRcdGRlcHRoID0gZGVwdGggKiAyLjAgLSAxLjA7XFxuXFxcblx0XHRcdHJldHVybiB6TmVhciAqIChkZXB0aCArIDEuMCkgLyAoekZhciArIHpOZWFyIC0gZGVwdGggKiAoekZhciAtIHpOZWFyKSk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0ZmxvYXQgZGVwdGggPSBMaW5lYXJEZXB0aCgpO1xcblxcXG5cdFx0XHQjaWZkZWYgT05MWV9ERVBUSFxcblxcXG5cdFx0XHQgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRlcHRoKTtcXG5cXFxuXHRcdFx0I2Vsc2VcXG5cXFxuXHRcdFx0XHRmbG9hdCBkaWZmID0gYWJzKGRlcHRoICogdV9jYW1lcmFfcGxhbmVzLnkgLSB1X2Rpc3RhbmNlKTtcXG5cXFxuXHRcdFx0XHRmbG9hdCBkb2YgPSAxLjA7XFxuXFxcblx0XHRcdFx0aWYoZGlmZiA8PSB1X3JhbmdlKVxcblxcXG5cdFx0XHRcdFx0ZG9mID0gZGlmZiAvIHVfcmFuZ2U7XFxuXFxcblx0XHRcdCAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZG9mKTtcXG5cXFxuXHRcdFx0I2VuZGlmXFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL2RlcHRoX3JhbmdlXCIsIExHcmFwaFRleHR1cmVEZXB0aFJhbmdlICk7XG5cblxuXHQvLyBUZXh0dXJlIERlcHRoICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVCxcblx0XHRcdGludmVydDogZmFsc2Vcblx0XHR9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV9jYW1lcmFfcGxhbmVzOiBudWxsLCAvL2ZpbGxlZCBsYXRlclxuXHRcdFx0dV9pcmVzOiB2ZWMyLmNyZWF0ZSgpXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC50aXRsZSA9IFwiTGluZWFyIERlcHRoXCI7XG5cdExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5kZXNjID0gXCJDcmVhdGVzIGEgY29sb3IgdGV4dHVyZSB3aXRoIGxpbmVhciBkZXB0aFwiO1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCB8fCAodGV4LmZvcm1hdCAhPSBnbC5ERVBUSF9DT01QT05FTlQgJiYgdGV4LmZvcm1hdCAhPSBnbC5ERVBUSF9TVEVOQ0lMKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcHJlY2lzaW9uID0gdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PSBMR3JhcGhUZXh0dXJlLkhJR0ggPyBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQgOiBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0aWYgKCAhdGhpcy5fdGVtcF90ZXh0dXJlIHx8IHRoaXMuX3RlbXBfdGV4dHVyZS50eXBlICE9IHByZWNpc2lvbiB8fCB0aGlzLl90ZW1wX3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8IHRoaXMuX3RlbXBfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodCApIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiBwcmVjaXNpb24sXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9pbnZlcnQgPSB0aGlzLnByb3BlcnRpZXMuaW52ZXJ0ID8gMSA6IDA7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0aWYoIUxHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5fc2hhZGVyKVxuXHRcdFx0TEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKCBHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsIExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5waXhlbF9zaGFkZXIpO1xuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGguX3NoYWRlcjtcblxuXHRcdC8vTkVBUiBBTkQgRkFSIFBMQU5FU1xuXHRcdHZhciBwbGFuZXMgPSBudWxsO1xuXHRcdGlmICh0ZXgubmVhcl9mYXJfcGxhbmVzKSB7XG5cdFx0XHRwbGFuZXMgPSB0ZXgubmVhcl9mYXJfcGxhbmVzO1xuXHRcdH0gZWxzZSBpZiAod2luZG93LkxTICYmIExTLlJlbmRlcmVyLl9tYWluX2NhbWVyYSkge1xuXHRcdFx0cGxhbmVzID0gTFMuUmVuZGVyZXIuX21haW5fY2FtZXJhLl91bmlmb3Jtcy51X2NhbWVyYV9wbGFuZXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBsYW5lcyA9IFswLjEsIDEwMDBdO1xuXHRcdH0gLy9oYXJkY29kZWRcblx0XHR1bmlmb3Jtcy51X2NhbWVyYV9wbGFuZXMgPSBwbGFuZXM7XG5cdFx0Ly91bmlmb3Jtcy51X2lyZXMuc2V0KFsxL3RleC53aWR0aCwgMS90ZXguaGVpZ2h0XSk7XG5cdFx0dW5pZm9ybXMudV9pcmVzLnNldChbMCwwXSk7XG5cblx0XHR0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl90ZW1wX3RleHR1cmUubmVhcl9mYXJfcGxhbmVzID0gcGxhbmVzO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9jYW1lcmFfcGxhbmVzO1xcblxcXG5cdFx0dW5pZm9ybSBpbnQgdV9pbnZlcnQ7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9pcmVzO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdGZsb2F0IHpOZWFyID0gdV9jYW1lcmFfcGxhbmVzLng7XFxuXFxcblx0XHRcdGZsb2F0IHpGYXIgPSB1X2NhbWVyYV9wbGFuZXMueTtcXG5cXFxuXHRcdFx0ZmxvYXQgZGVwdGggPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9pcmVzKjAuNSkueCAqIDIuMCAtIDEuMDtcXG5cXFxuXHRcdFx0ZmxvYXQgZiA9IHpOZWFyICogKGRlcHRoICsgMS4wKSAvICh6RmFyICsgek5lYXIgLSBkZXB0aCAqICh6RmFyIC0gek5lYXIpKTtcXG5cXFxuXHRcdFx0aWYoIHVfaW52ZXJ0ID09IDEgKVxcblxcXG5cdFx0XHRcdGYgPSAxLjAgLSBmO1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoZiksMS4wKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInRleHR1cmUvbGluZWFyX2RlcHRoXCIsIExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aCApO1xuXG5cdC8vIFRleHR1cmUgQmx1ciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQmx1cigpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkl0ZXJhdGlvbnNcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkludGVuc2l0eVwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIkJsdXJyZWRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGludGVuc2l0eTogMSxcblx0XHRcdGl0ZXJhdGlvbnM6IDEsXG5cdFx0XHRwcmVzZXJ2ZV9hc3BlY3Q6IGZhbHNlLFxuXHRcdFx0c2NhbGU6IFsxLCAxXSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVCbHVyLnRpdGxlID0gXCJCbHVyXCI7XG5cdExHcmFwaFRleHR1cmVCbHVyLmRlc2MgPSBcIkJsdXIgYSB0ZXh0dXJlXCI7XG5cblx0TEdyYXBoVGV4dHVyZUJsdXIud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQmx1ci5tYXhfaXRlcmF0aW9ucyA9IDIwO1xuXG5cdExHcmFwaFRleHR1cmVCbHVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl9maW5hbF90ZXh0dXJlO1xuXG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdC8vd2UgbmVlZCB0d28gdGV4dHVyZXMgdG8gZG8gdGhlIGJsdXJyaW5nXG5cdFx0XHQvL3RoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKCB0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHsgdHlwZTogdGV4LnR5cGUsIGZvcm1hdDogZ2wuUkdCQSwgZmlsdGVyOiBnbC5MSU5FQVIgfSk7XG5cdFx0XHR0ZW1wID0gdGhpcy5fZmluYWxfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKFxuXHRcdFx0XHR0ZXgud2lkdGgsXG5cdFx0XHRcdHRleC5oZWlnaHQsXG5cdFx0XHRcdHsgdHlwZTogdGV4LnR5cGUsIGZvcm1hdDogZ2wuUkdCQSwgZmlsdGVyOiBnbC5MSU5FQVIgfVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvL2l0ZXJhdGlvbnNcblx0XHR2YXIgaXRlcmF0aW9ucyA9IHRoaXMucHJvcGVydGllcy5pdGVyYXRpb25zO1xuXHRcdGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcblx0XHRcdGl0ZXJhdGlvbnMgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcblx0XHR9XG5cdFx0aXRlcmF0aW9ucyA9IE1hdGgubWluKFxuXHRcdFx0TWF0aC5mbG9vcihpdGVyYXRpb25zKSxcblx0XHRcdExHcmFwaFRleHR1cmVCbHVyLm1heF9pdGVyYXRpb25zXG5cdFx0KTtcblx0XHRpZiAoaXRlcmF0aW9ucyA9PSAwKSB7XG5cdFx0XHQvL3NraXAgYmx1cnJpbmdcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbnRlbnNpdHkgPSB0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5O1xuXHRcdGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMikpIHtcblx0XHRcdGludGVuc2l0eSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eSA9IGludGVuc2l0eTtcblx0XHR9XG5cblx0XHQvL2JsdXIgc29tZXRpbWVzIG5lZWRzIGFuIGFzcGVjdCBjb3JyZWN0aW9uXG5cdFx0dmFyIGFzcGVjdCA9IExpdGVHcmFwaC5jYW1lcmFfYXNwZWN0O1xuXHRcdGlmICghYXNwZWN0ICYmIHdpbmRvdy5nbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhc3BlY3QgPSBnbC5jYW52YXMuaGVpZ2h0IC8gZ2wuY2FudmFzLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoIWFzcGVjdCkge1xuXHRcdFx0YXNwZWN0ID0gMTtcblx0XHR9XG5cdFx0YXNwZWN0ID0gdGhpcy5wcm9wZXJ0aWVzLnByZXNlcnZlX2FzcGVjdCA/IGFzcGVjdCA6IDE7XG5cblx0XHR2YXIgc2NhbGUgPSB0aGlzLnByb3BlcnRpZXMuc2NhbGUgfHwgWzEsIDFdO1xuXHRcdHRleC5hcHBseUJsdXIoYXNwZWN0ICogc2NhbGVbMF0sIHNjYWxlWzFdLCBpbnRlbnNpdHksIHRlbXApO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG5cdFx0XHR0ZW1wLmFwcGx5Qmx1cihcblx0XHRcdFx0YXNwZWN0ICogc2NhbGVbMF0gKiAoaSArIDEpLFxuXHRcdFx0XHRzY2FsZVsxXSAqIChpICsgMSksXG5cdFx0XHRcdGludGVuc2l0eVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH07XG5cblx0LypcbkxHcmFwaFRleHR1cmVCbHVyLnBpeGVsX3NoYWRlciA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0ICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7XFxuXFxcblx0XHQgICB2ZWM0IGNlbnRlciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIC00LjApICogMC4wNS8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIC0zLjApICogMC4wOS8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIC0yLjApICogMC4xMi8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIC0xLjApICogMC4xNS8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IGNlbnRlciAqIDAuMTYvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiA0LjApICogMC4wNS8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIDMuMCkgKiAwLjA5LzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogMi4wKSAqIDAuMTIvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAxLjApICogMC4xNS8wLjk4O1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdV9pbnRlbnNpdHkgKiBzdW07XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcbiovXG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2JsdXJcIiwgTEdyYXBoVGV4dHVyZUJsdXIpO1xuXG5cdC8vSW5kZXBlbmRlbnQgZ2xvdyBGWFxuXHQvL2Jhc2VkIG9uIGh0dHBzOi8vY2F0bGlrZWNvZGluZy5jb20vdW5pdHkvdHV0b3JpYWxzL2FkdmFuY2VkLXJlbmRlcmluZy9ibG9vbS9cblx0ZnVuY3Rpb24gRlhHbG93KClcblx0e1xuXHRcdHRoaXMuaW50ZW5zaXR5ID0gMC41O1xuXHRcdHRoaXMucGVyc2lzdGVuY2UgPSAwLjY7XG5cdFx0dGhpcy5pdGVyYXRpb25zID0gODtcblx0XHR0aGlzLnRocmVzaG9sZCA9IDAuODtcblx0XHR0aGlzLnNjYWxlID0gMTtcblxuXHRcdHRoaXMuZGlydF90ZXh0dXJlID0gbnVsbDtcblx0XHR0aGlzLmRpcnRfZmFjdG9yID0gMC41O1xuXG5cdFx0dGhpcy5fdGV4dHVyZXMgPSBbXTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfaW50ZW5zaXR5OiAxLFxuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV9nbG93X3RleHR1cmU6IDEsXG5cdFx0XHR1X3RocmVzaG9sZDogMCxcblx0XHRcdHVfdGV4ZWxfc2l6ZTogdmVjMi5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRGWEdsb3cucHJvdG90eXBlLmFwcGx5RlggPSBmdW5jdGlvbiggdGV4LCBvdXRwdXRfdGV4dHVyZSwgZ2xvd190ZXh0dXJlLCBhdmVyYWdlX3RleHR1cmUgKSB7XG5cblx0XHR2YXIgd2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cblx0XHR2YXIgdGV4dHVyZV9pbmZvID0ge1xuXHRcdFx0Zm9ybWF0OiB0ZXguZm9ybWF0LFxuXHRcdFx0dHlwZTogdGV4LnR5cGUsXG5cdFx0XHRtaW5GaWx0ZXI6IEdMLkxJTkVBUixcblx0XHRcdG1hZ0ZpbHRlcjogR0wuTElORUFSLFxuXHRcdFx0d3JhcDogZ2wuQ0xBTVBfVE9fRURHRVxuXHRcdH07XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLl90ZXh0dXJlcztcblxuXHRcdC8vY3V0XG5cdFx0dmFyIHNoYWRlciA9IEZYR2xvdy5fY3V0X3NoYWRlcjtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gRlhHbG93Ll9jdXRfc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRGWEdsb3cuY3V0X3BpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG5cdFx0dW5pZm9ybXMudV90aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZDtcblx0XHR2YXIgY3VycmVudERlc3RpbmF0aW9uID0gKHRleHR1cmVzWzBdID0gR0wuVGV4dHVyZS5nZXRUZW1wb3JhcnkoXG5cdFx0XHR3aWR0aCxcblx0XHRcdGhlaWdodCxcblx0XHRcdHRleHR1cmVfaW5mb1xuXHRcdCkpO1xuXHRcdHRleC5ibGl0KCBjdXJyZW50RGVzdGluYXRpb24sIHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykgKTtcblx0XHR2YXIgY3VycmVudFNvdXJjZSA9IGN1cnJlbnREZXN0aW5hdGlvbjtcblxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5pdGVyYXRpb25zO1xuXHRcdGl0ZXJhdGlvbnMgPSBNYXRoLmNsYW1wKGl0ZXJhdGlvbnMsIDEsIDE2KSB8IDA7XG5cdFx0dmFyIHRleGVsX3NpemUgPSB1bmlmb3Jtcy51X3RleGVsX3NpemU7XG5cdFx0dmFyIGludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG5cdFx0dW5pZm9ybXMudV9pbnRlbnNpdHkgPSAxO1xuXHRcdHVuaWZvcm1zLnVfZGVsdGEgPSB0aGlzLnNjYWxlOyAvLzFcblxuXHRcdC8vZG93bnNjYWxlL3Vwc2NhbGUgc2hhZGVyXG5cdFx0dmFyIHNoYWRlciA9IEZYR2xvdy5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBGWEdsb3cuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0RlhHbG93LnNjYWxlX3BpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDE7XG5cdFx0Ly9kb3duc2NhbGVcblx0XHRmb3IgKDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHRcdFx0d2lkdGggPSB3aWR0aCA+PiAxO1xuXHRcdFx0aWYgKChoZWlnaHQgfCAwKSA+IDEpIHtcblx0XHRcdFx0aGVpZ2h0ID0gaGVpZ2h0ID4+IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAod2lkdGggPCAyKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudERlc3RpbmF0aW9uID0gdGV4dHVyZXNbaV0gPSBHTC5UZXh0dXJlLmdldFRlbXBvcmFyeShcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0dGV4dHVyZV9pbmZvXG5cdFx0XHQpO1xuXHRcdFx0dGV4ZWxfc2l6ZVswXSA9IDEgLyBjdXJyZW50U291cmNlLndpZHRoO1xuXHRcdFx0dGV4ZWxfc2l6ZVsxXSA9IDEgLyBjdXJyZW50U291cmNlLmhlaWdodDtcblx0XHRcdGN1cnJlbnRTb3VyY2UuYmxpdChcblx0XHRcdFx0Y3VycmVudERlc3RpbmF0aW9uLFxuXHRcdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpXG5cdFx0XHQpO1xuXHRcdFx0Y3VycmVudFNvdXJjZSA9IGN1cnJlbnREZXN0aW5hdGlvbjtcblx0XHR9XG5cblx0XHQvL2F2ZXJhZ2Vcblx0XHRpZiAoYXZlcmFnZV90ZXh0dXJlKSB7XG5cdFx0XHR0ZXhlbF9zaXplWzBdID0gMSAvIGN1cnJlbnRTb3VyY2Uud2lkdGg7XG5cdFx0XHR0ZXhlbF9zaXplWzFdID0gMSAvIGN1cnJlbnRTb3VyY2UuaGVpZ2h0O1xuXHRcdFx0dW5pZm9ybXMudV9pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG5cdFx0XHR1bmlmb3Jtcy51X2RlbHRhID0gMTtcblx0XHRcdGN1cnJlbnRTb3VyY2UuYmxpdChhdmVyYWdlX3RleHR1cmUsIHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykpO1xuXHRcdH1cblxuXHRcdC8vdXBzY2FsZSBhbmQgYmxlbmRcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG5cdFx0dW5pZm9ybXMudV9pbnRlbnNpdHkgPSB0aGlzLnBlcnNpc3RlbmNlO1xuXHRcdHVuaWZvcm1zLnVfZGVsdGEgPSAwLjU7XG5cblx0XHQvLyBpLT0yID0+IC0xIHRvIHBvaW50IHRvIGxhc3QgZWxlbWVudCBpbiBhcnJheSwgLTEgdG8gZ28gdG8gdGV4dHVyZSBhYm92ZVxuXHRcdGZvciAoIGkgLT0gMjsgaSA+PSAwOyBpLS0gKSBcblx0XHR7XG5cdFx0XHRjdXJyZW50RGVzdGluYXRpb24gPSB0ZXh0dXJlc1tpXTtcblx0XHRcdHRleHR1cmVzW2ldID0gbnVsbDtcblx0XHRcdHRleGVsX3NpemVbMF0gPSAxIC8gY3VycmVudFNvdXJjZS53aWR0aDtcblx0XHRcdHRleGVsX3NpemVbMV0gPSAxIC8gY3VycmVudFNvdXJjZS5oZWlnaHQ7XG5cdFx0XHRjdXJyZW50U291cmNlLmJsaXQoXG5cdFx0XHRcdGN1cnJlbnREZXN0aW5hdGlvbixcblx0XHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKVxuXHRcdFx0KTtcblx0XHRcdEdMLlRleHR1cmUucmVsZWFzZVRlbXBvcmFyeShjdXJyZW50U291cmNlKTtcblx0XHRcdGN1cnJlbnRTb3VyY2UgPSBjdXJyZW50RGVzdGluYXRpb247XG5cdFx0fVxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG5cdFx0Ly9nbG93XG5cdFx0aWYgKGdsb3dfdGV4dHVyZSkge1xuXHRcdFx0Y3VycmVudFNvdXJjZS5ibGl0KGdsb3dfdGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0Ly9maW5hbCBjb21wb3NpdGlvblxuXHRcdGlmICggb3V0cHV0X3RleHR1cmUgKSB7XG5cdFx0XHR2YXIgZmluYWxfdGV4dHVyZSA9IG91dHB1dF90ZXh0dXJlO1xuXHRcdFx0dmFyIGRpcnRfdGV4dHVyZSA9IHRoaXMuZGlydF90ZXh0dXJlO1xuXHRcdFx0dmFyIGRpcnRfZmFjdG9yID0gdGhpcy5kaXJ0X2ZhY3Rvcjtcblx0XHRcdHVuaWZvcm1zLnVfaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xuXG5cdFx0XHRzaGFkZXIgPSBkaXJ0X3RleHR1cmVcblx0XHRcdFx0PyBGWEdsb3cuX2RpcnRfZmluYWxfc2hhZGVyXG5cdFx0XHRcdDogRlhHbG93Ll9maW5hbF9zaGFkZXI7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRpZiAoZGlydF90ZXh0dXJlKSB7XG5cdFx0XHRcdFx0c2hhZGVyID0gRlhHbG93Ll9kaXJ0X2ZpbmFsX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0XHRGWEdsb3cuZmluYWxfcGl4ZWxfc2hhZGVyLFxuXHRcdFx0XHRcdFx0eyBVU0VfRElSVDogXCJcIiB9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzaGFkZXIgPSBGWEdsb3cuX2ZpbmFsX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0XHRGWEdsb3cuZmluYWxfcGl4ZWxfc2hhZGVyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmaW5hbF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRcdGN1cnJlbnRTb3VyY2UuYmluZCgxKTtcblx0XHRcdFx0aWYgKGRpcnRfdGV4dHVyZSkge1xuXHRcdFx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKFwidV9kaXJ0X2ZhY3RvclwiLCBkaXJ0X2ZhY3Rvcik7XG5cdFx0XHRcdFx0c2hhZGVyLnNldFVuaWZvcm0oXG5cdFx0XHRcdFx0XHRcInVfZGlydF90ZXh0dXJlXCIsXG5cdFx0XHRcdFx0XHRkaXJ0X3RleHR1cmUuYmluZCgyKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2hhZGVyLnRvVmlld3BvcnQodW5pZm9ybXMpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0R0wuVGV4dHVyZS5yZWxlYXNlVGVtcG9yYXJ5KGN1cnJlbnRTb3VyY2UpO1xuXHR9O1xuXG5cdEZYR2xvdy5jdXRfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0dW5pZm9ybSBmbG9hdCB1X3RocmVzaG9sZDtcXG5cXFxuXHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSBtYXgoIHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICkgLSB2ZWM0KCB1X3RocmVzaG9sZCApLCB2ZWM0KDAuMCkgKTtcXG5cXFxuXHR9XCI7XG5cblx0RlhHbG93LnNjYWxlX3BpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdHVuaWZvcm0gdmVjMiB1X3RleGVsX3NpemU7XFxuXFxcblx0dW5pZm9ybSBmbG9hdCB1X2RlbHRhO1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7XFxuXFxcblx0XFxuXFxcblx0dmVjNCBzYW1wbGVCb3godmVjMiB1dikge1xcblxcXG5cdFx0dmVjNCBvID0gdV90ZXhlbF9zaXplLnh5eHkgKiB2ZWMyKC11X2RlbHRhLCB1X2RlbHRhKS54eHl5O1xcblxcXG5cdFx0dmVjNCBzID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHV2ICsgby54eSApICsgdGV4dHVyZTJEKCB1X3RleHR1cmUsIHV2ICsgby56eSkgKyB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdXYgKyBvLnh3KSArIHRleHR1cmUyRCggdV90ZXh0dXJlLCB1diArIG8uencpO1xcblxcXG5cdFx0cmV0dXJuIHMgKiAwLjI1O1xcblxcXG5cdH1cXG5cXFxuXHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB1X2ludGVuc2l0eSAqIHNhbXBsZUJveCggdl9jb29yZCApO1xcblxcXG5cdH1cIjtcblxuXHRGWEdsb3cuZmluYWxfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgdV9nbG93X3RleHR1cmU7XFxuXFxcblx0I2lmZGVmIFVTRV9ESVJUXFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X2RpcnRfdGV4dHVyZTtcXG5cXFxuXHQjZW5kaWZcXG5cXFxuXHR1bmlmb3JtIHZlYzIgdV90ZXhlbF9zaXplO1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9kZWx0YTtcXG5cXFxuXHR1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9kaXJ0X2ZhY3RvcjtcXG5cXFxuXHRcXG5cXFxuXHR2ZWM0IHNhbXBsZUJveCh2ZWMyIHV2KSB7XFxuXFxcblx0XHR2ZWM0IG8gPSB1X3RleGVsX3NpemUueHl4eSAqIHZlYzIoLXVfZGVsdGEsIHVfZGVsdGEpLnh4eXk7XFxuXFxcblx0XHR2ZWM0IHMgPSB0ZXh0dXJlMkQoIHVfZ2xvd190ZXh0dXJlLCB1diArIG8ueHkgKSArIHRleHR1cmUyRCggdV9nbG93X3RleHR1cmUsIHV2ICsgby56eSkgKyB0ZXh0dXJlMkQoIHVfZ2xvd190ZXh0dXJlLCB1diArIG8ueHcpICsgdGV4dHVyZTJEKCB1X2dsb3dfdGV4dHVyZSwgdXYgKyBvLnp3KTtcXG5cXFxuXHRcdHJldHVybiBzICogMC4yNTtcXG5cXFxuXHR9XFxuXFxcblx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0dmVjNCBnbG93ID0gc2FtcGxlQm94KCB2X2Nvb3JkICk7XFxuXFxcblx0XHQjaWZkZWYgVVNFX0RJUlRcXG5cXFxuXHRcdFx0Z2xvdyA9IG1peCggZ2xvdywgZ2xvdyAqIHRleHR1cmUyRCggdV9kaXJ0X3RleHR1cmUsIHZfY29vcmQgKSwgdV9kaXJ0X2ZhY3RvciApO1xcblxcXG5cdFx0I2VuZGlmXFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdl9jb29yZCApICsgdV9pbnRlbnNpdHkgKiBnbG93O1xcblxcXG5cdH1cIjtcblxuXG5cdC8vIFRleHR1cmUgR2xvdyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlR2xvdygpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJkaXJ0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJnbG93XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0aW50ZW5zaXR5OiAxLFxuXHRcdFx0cGVyc2lzdGVuY2U6IDAuOTksXG5cdFx0XHRpdGVyYXRpb25zOiAxNixcblx0XHRcdHRocmVzaG9sZDogMCxcblx0XHRcdHNjYWxlOiAxLFxuXHRcdFx0ZGlydF9mYWN0b3I6IDAuNSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMuZnggPSBuZXcgRlhHbG93KCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlR2xvdy50aXRsZSA9IFwiR2xvd1wiO1xuXHRMR3JhcGhUZXh0dXJlR2xvdy5kZXNjID0gXCJGaWx0ZXJzIGEgdGV4dHVyZSBnaXZpbmcgaXQgYSBnbG93IGVmZmVjdFwiO1xuXG5cdExHcmFwaFRleHR1cmVHbG93LndpZGdldHNfaW5mbyA9IHtcblx0XHRpdGVyYXRpb25zOiB7XG5cdFx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiAxNixcblx0XHRcdHN0ZXA6IDEsXG5cdFx0XHRwcmVjaXNpb246IDBcblx0XHR9LFxuXHRcdHRocmVzaG9sZDoge1xuXHRcdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogMTAsXG5cdFx0XHRzdGVwOiAwLjAxLFxuXHRcdFx0cHJlY2lzaW9uOiAyXG5cdFx0fSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUdsb3cucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdLFxuXHRcdFx0W1widGhyZXNob2xkXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiaW50ZW5zaXR5XCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wicGVyc2lzdGVuY2VcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJpdGVyYXRpb25zXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiZGlydF9mYWN0b3JcIiwgXCJudW1iZXJcIl1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVHbG93LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImF2ZXJhZ2VcIiwgXCJUZXh0dXJlXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlR2xvdy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzQW55T3V0cHV0Q29ubmVjdGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0ggfHxcblx0XHRcdHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZW5hYmxlZFwiKSA9PT0gZmFsc2Vcblx0XHQpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRleC53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdGV4LmhlaWdodDtcblxuXHRcdHZhciBmeCA9IHRoaXMuZng7XG5cdFx0ZngudGhyZXNob2xkID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ0aHJlc2hvbGRcIik7XG5cdFx0ZnguaXRlcmF0aW9ucyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiaXRlcmF0aW9uc1wiKTtcblx0XHRmeC5pbnRlbnNpdHkgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImludGVuc2l0eVwiKTtcblx0XHRmeC5wZXJzaXN0ZW5jZSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwicGVyc2lzdGVuY2VcIik7XG5cdFx0ZnguZGlydF90ZXh0dXJlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0ZnguZGlydF9mYWN0b3IgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImRpcnRfZmFjdG9yXCIpO1xuXHRcdGZ4LnNjYWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlO1xuXG5cdFx0dmFyIHR5cGUgPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlKCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uLCB0ZXggKTtcblxuXHRcdHZhciBhdmVyYWdlX3RleHR1cmUgPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDIpKSB7XG5cdFx0XHRhdmVyYWdlX3RleHR1cmUgPSB0aGlzLl9hdmVyYWdlX3RleHR1cmU7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFhdmVyYWdlX3RleHR1cmUgfHxcblx0XHRcdFx0YXZlcmFnZV90ZXh0dXJlLnR5cGUgIT0gdGV4LnR5cGUgfHxcblx0XHRcdFx0YXZlcmFnZV90ZXh0dXJlLmZvcm1hdCAhPSB0ZXguZm9ybWF0XG5cdFx0XHQpIHtcblx0XHRcdFx0YXZlcmFnZV90ZXh0dXJlID0gdGhpcy5fYXZlcmFnZV90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdFx0MSxcblx0XHRcdFx0XHQxLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiB0ZXguZm9ybWF0LFxuXHRcdFx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGdsb3dfdGV4dHVyZSA9IG51bGw7XG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkpIHtcblx0XHRcdGdsb3dfdGV4dHVyZSA9IHRoaXMuX2dsb3dfdGV4dHVyZTtcblx0XHRcdGlmIChcblx0XHRcdFx0IWdsb3dfdGV4dHVyZSB8fFxuXHRcdFx0XHRnbG93X3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHRcdGdsb3dfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0XHRnbG93X3RleHR1cmUudHlwZSAhPSB0eXBlIHx8XG5cdFx0XHRcdGdsb3dfdGV4dHVyZS5mb3JtYXQgIT0gdGV4LmZvcm1hdFxuXHRcdFx0KSB7XG5cdFx0XHRcdGdsb3dfdGV4dHVyZSA9IHRoaXMuX2dsb3dfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKFxuXHRcdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHRcdHsgdHlwZTogdHlwZSwgZm9ybWF0OiB0ZXguZm9ybWF0LCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGZpbmFsX3RleHR1cmUgPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRmaW5hbF90ZXh0dXJlID0gdGhpcy5fZmluYWxfdGV4dHVyZTtcblx0XHRcdGlmIChcblx0XHRcdFx0IWZpbmFsX3RleHR1cmUgfHxcblx0XHRcdFx0ZmluYWxfdGV4dHVyZS53aWR0aCAhPSB0ZXgud2lkdGggfHxcblx0XHRcdFx0ZmluYWxfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0XHRmaW5hbF90ZXh0dXJlLnR5cGUgIT0gdHlwZSB8fFxuXHRcdFx0XHRmaW5hbF90ZXh0dXJlLmZvcm1hdCAhPSB0ZXguZm9ybWF0XG5cdFx0XHQpIHtcblx0XHRcdFx0ZmluYWxfdGV4dHVyZSA9IHRoaXMuX2ZpbmFsX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0XHR0ZXgud2lkdGgsXG5cdFx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0XHR7IHR5cGU6IHR5cGUsIGZvcm1hdDogdGV4LmZvcm1hdCwgZmlsdGVyOiBnbC5MSU5FQVIgfVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9hcHBseSBGWFxuXHRcdGZ4LmFwcGx5RlgodGV4LCBmaW5hbF90ZXh0dXJlLCBnbG93X3RleHR1cmUsIGF2ZXJhZ2VfdGV4dHVyZSApO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgZmluYWxfdGV4dHVyZSk7XG5cblx0XHRpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSlcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCBhdmVyYWdlX3RleHR1cmUpO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMikpXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMiwgZ2xvd190ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZ2xvd1wiLCBMR3JhcGhUZXh0dXJlR2xvdyk7XG5cblx0Ly8gVGV4dHVyZSBGaWx0ZXIgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIkZpbHRlcmVkXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGludGVuc2l0eTogMSwgcmFkaXVzOiA1IH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIudGl0bGUgPSBcIkt1d2FoYXJhIEZpbHRlclwiO1xuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuZGVzYyA9XG5cdFx0XCJGaWx0ZXJzIGEgdGV4dHVyZSBnaXZpbmcgYW4gYXJ0aXN0aWMgb2lsIGNhbnZhcyBwYWludGluZ1wiO1xuXG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5tYXhfcmFkaXVzID0gMTA7XG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5fc2hhZGVycyA9IFtdO1xuXG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiB0ZXgudHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9pdGVyYXRpb25zXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMucHJvcGVydGllcy5yYWRpdXM7XG5cdFx0cmFkaXVzID0gTWF0aC5taW4oXG5cdFx0XHRNYXRoLmZsb29yKHJhZGl1cyksXG5cdFx0XHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIubWF4X3JhZGl1c1xuXHRcdCk7XG5cdFx0aWYgKHJhZGl1cyA9PSAwKSB7XG5cdFx0XHQvL3NraXAgYmx1cnJpbmdcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbnRlbnNpdHkgPSB0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5O1xuXG5cdFx0Ly9ibHVyIHNvbWV0aW1lcyBuZWVkcyBhbiBhc3BlY3QgY29ycmVjdGlvblxuXHRcdHZhciBhc3BlY3QgPSBMaXRlR3JhcGguY2FtZXJhX2FzcGVjdDtcblx0XHRpZiAoIWFzcGVjdCAmJiB3aW5kb3cuZ2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXNwZWN0ID0gZ2wuY2FudmFzLmhlaWdodCAvIGdsLmNhbnZhcy53aWR0aDtcblx0XHR9XG5cdFx0aWYgKCFhc3BlY3QpIHtcblx0XHRcdGFzcGVjdCA9IDE7XG5cdFx0fVxuXHRcdGFzcGVjdCA9IHRoaXMucHJvcGVydGllcy5wcmVzZXJ2ZV9hc3BlY3QgPyBhc3BlY3QgOiAxO1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuX3NoYWRlcnNbcmFkaXVzXSkge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLl9zaGFkZXJzW3JhZGl1c10gPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5waXhlbF9zaGFkZXIsXG5cdFx0XHRcdHsgUkFESVVTOiByYWRpdXMudG9GaXhlZCgwKSB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuX3NoYWRlcnNbcmFkaXVzXTtcblx0XHR2YXIgbWVzaCA9IEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHRleC5iaW5kKDApO1xuXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X2ludGVuc2l0eTogaW50ZW5zaXR5LFxuXHRcdFx0XHRcdHVfcmVzb2x1dGlvbjogW3RleC53aWR0aCwgdGV4LmhlaWdodF0sXG5cdFx0XHRcdFx0dV9pUmVzb2x1dGlvbjogWzEgLyB0ZXgud2lkdGgsIDEgLyB0ZXguaGVpZ2h0XVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdC8vZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvTXNYU3o0XG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5waXhlbF9zaGFkZXIgPVxuXHRcdFwiXFxuXFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxudmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxudW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTtcXG5cXFxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cXFxudW5pZm9ybSB2ZWMyIHVfaVJlc29sdXRpb247XFxuXFxcbiNpZm5kZWYgUkFESVVTXFxuXFxcblx0I2RlZmluZSBSQURJVVMgN1xcblxcXG4jZW5kaWZcXG5cXFxudm9pZCBtYWluKCkge1xcblxcXG5cXG5cXFxuXHRjb25zdCBpbnQgcmFkaXVzID0gUkFESVVTO1xcblxcXG5cdHZlYzIgZnJhZ0Nvb3JkID0gdl9jb29yZDtcXG5cXFxuXHR2ZWMyIHNyY19zaXplID0gdV9pUmVzb2x1dGlvbjtcXG5cXFxuXHR2ZWMyIHV2ID0gdl9jb29yZDtcXG5cXFxuXHRmbG9hdCBuID0gZmxvYXQoKHJhZGl1cyArIDEpICogKHJhZGl1cyArIDEpKTtcXG5cXFxuXHRpbnQgaTtcXG5cXFxuXHRpbnQgajtcXG5cXFxuXHR2ZWMzIG0wID0gdmVjMygwLjApOyB2ZWMzIG0xID0gdmVjMygwLjApOyB2ZWMzIG0yID0gdmVjMygwLjApOyB2ZWMzIG0zID0gdmVjMygwLjApO1xcblxcXG5cdHZlYzMgczAgPSB2ZWMzKDAuMCk7IHZlYzMgczEgPSB2ZWMzKDAuMCk7IHZlYzMgczIgPSB2ZWMzKDAuMCk7IHZlYzMgczMgPSB2ZWMzKDAuMCk7XFxuXFxcblx0dmVjMyBjO1xcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAtcmFkaXVzOyBqIDw9IDA7ICsraikgIHtcXG5cXFxuXHRcdGZvciAoaW50IGkgPSAtcmFkaXVzOyBpIDw9IDA7ICsraSkgIHtcXG5cXFxuXHRcdFx0YyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMihpLGopICogc3JjX3NpemUpLnJnYjtcXG5cXFxuXHRcdFx0bTAgKz0gYztcXG5cXFxuXHRcdFx0czAgKz0gYyAqIGM7XFxuXFxcblx0XHR9XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAtcmFkaXVzOyBqIDw9IDA7ICsraikgIHtcXG5cXFxuXHRcdGZvciAoaW50IGkgPSAwOyBpIDw9IHJhZGl1czsgKytpKSAge1xcblxcXG5cdFx0XHRjID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKGksaikgKiBzcmNfc2l6ZSkucmdiO1xcblxcXG5cdFx0XHRtMSArPSBjO1xcblxcXG5cdFx0XHRzMSArPSBjICogYztcXG5cXFxuXHRcdH1cXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0Zm9yIChpbnQgaiA9IDA7IGogPD0gcmFkaXVzOyArK2opICB7XFxuXFxcblx0XHRmb3IgKGludCBpID0gMDsgaSA8PSByYWRpdXM7ICsraSkgIHtcXG5cXFxuXHRcdFx0YyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMihpLGopICogc3JjX3NpemUpLnJnYjtcXG5cXFxuXHRcdFx0bTIgKz0gYztcXG5cXFxuXHRcdFx0czIgKz0gYyAqIGM7XFxuXFxcblx0XHR9XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAwOyBqIDw9IHJhZGl1czsgKytqKSAge1xcblxcXG5cdFx0Zm9yIChpbnQgaSA9IC1yYWRpdXM7IGkgPD0gMDsgKytpKSAge1xcblxcXG5cdFx0XHRjID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKGksaikgKiBzcmNfc2l6ZSkucmdiO1xcblxcXG5cdFx0XHRtMyArPSBjO1xcblxcXG5cdFx0XHRzMyArPSBjICogYztcXG5cXFxuXHRcdH1cXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0ZmxvYXQgbWluX3NpZ21hMiA9IDFlKzI7XFxuXFxcblx0bTAgLz0gbjtcXG5cXFxuXHRzMCA9IGFicyhzMCAvIG4gLSBtMCAqIG0wKTtcXG5cXFxuXHRcXG5cXFxuXHRmbG9hdCBzaWdtYTIgPSBzMC5yICsgczAuZyArIHMwLmI7XFxuXFxcblx0aWYgKHNpZ21hMiA8IG1pbl9zaWdtYTIpIHtcXG5cXFxuXHRcdG1pbl9zaWdtYTIgPSBzaWdtYTI7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KG0wLCAxLjApO1xcblxcXG5cdH1cXG5cXFxuXHRcXG5cXFxuXHRtMSAvPSBuO1xcblxcXG5cdHMxID0gYWJzKHMxIC8gbiAtIG0xICogbTEpO1xcblxcXG5cdFxcblxcXG5cdHNpZ21hMiA9IHMxLnIgKyBzMS5nICsgczEuYjtcXG5cXFxuXHRpZiAoc2lnbWEyIDwgbWluX3NpZ21hMikge1xcblxcXG5cdFx0bWluX3NpZ21hMiA9IHNpZ21hMjtcXG5cXFxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQobTEsIDEuMCk7XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdG0yIC89IG47XFxuXFxcblx0czIgPSBhYnMoczIgLyBuIC0gbTIgKiBtMik7XFxuXFxcblx0XFxuXFxcblx0c2lnbWEyID0gczIuciArIHMyLmcgKyBzMi5iO1xcblxcXG5cdGlmIChzaWdtYTIgPCBtaW5fc2lnbWEyKSB7XFxuXFxcblx0XHRtaW5fc2lnbWEyID0gc2lnbWEyO1xcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChtMiwgMS4wKTtcXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0bTMgLz0gbjtcXG5cXFxuXHRzMyA9IGFicyhzMyAvIG4gLSBtMyAqIG0zKTtcXG5cXFxuXHRcXG5cXFxuXHRzaWdtYTIgPSBzMy5yICsgczMuZyArIHMzLmI7XFxuXFxcblx0aWYgKHNpZ21hMiA8IG1pbl9zaWdtYTIpIHtcXG5cXFxuXHRcdG1pbl9zaWdtYTIgPSBzaWdtYTI7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KG0zLCAxLjApO1xcblxcXG5cdH1cXG5cXFxufVxcblxcXG5cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUva3V3YWhhcmFcIixcblx0XHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXJcblx0KTtcblxuXHQvLyBUZXh0dXJlICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlWERvR0ZpbHRlcigpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJGaWx0ZXJlZFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0c2lnbWE6IDEuNCxcblx0XHRcdGs6IDEuNixcblx0XHRcdHA6IDIxLjcsXG5cdFx0XHRlcHNpbG9uOiA3OSxcblx0XHRcdHBoaTogMC4wMTdcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIudGl0bGUgPSBcIlhEb0cgRmlsdGVyXCI7XG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLmRlc2MgPVxuXHRcdFwiRmlsdGVycyBhIHRleHR1cmUgZ2l2aW5nIGFuIGFydGlzdGljIGluayBzdHlsZVwiO1xuXG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLm1heF9yYWRpdXMgPSAxMDtcblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3NoYWRlcnMgPSBbXTtcblxuXHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogdGV4LnR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3hkb2dfc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci5feGRvZ19zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLnhkb2dfcGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3hkb2dfc2hhZGVyO1xuXHRcdHZhciBtZXNoID0gR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cblx0XHR2YXIgc2lnbWEgPSB0aGlzLnByb3BlcnRpZXMuc2lnbWE7XG5cdFx0dmFyIGsgPSB0aGlzLnByb3BlcnRpZXMuaztcblx0XHR2YXIgcCA9IHRoaXMucHJvcGVydGllcy5wO1xuXHRcdHZhciBlcHNpbG9uID0gdGhpcy5wcm9wZXJ0aWVzLmVwc2lsb247XG5cdFx0dmFyIHBoaSA9IHRoaXMucHJvcGVydGllcy5waGk7XG5cdFx0dGV4LmJpbmQoMCk7XG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHNyYzogMCxcblx0XHRcdFx0XHRzaWdtYTogc2lnbWEsXG5cdFx0XHRcdFx0azogayxcblx0XHRcdFx0XHRwOiBwLFxuXHRcdFx0XHRcdGVwc2lsb246IGVwc2lsb24sXG5cdFx0XHRcdFx0cGhpOiBwaGksXG5cdFx0XHRcdFx0Y3ZzV2lkdGg6IHRleC53aWR0aCxcblx0XHRcdFx0XHRjdnNIZWlnaHQ6IHRleC5oZWlnaHRcblx0XHRcdFx0fSlcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHQvL2Zyb20gaHR0cHM6Ly9naXRodWIuY29tL1JheW1vbmRNY0d1aXJlL0dQVS1CYXNlZC1JbWFnZS1Qcm9jZXNzaW5nLVRvb2xzL2Jsb2IvbWFzdGVyL2xpYl93ZWJnbC9zY3JpcHRzL21haW4uanNcblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIueGRvZ19waXhlbF9zaGFkZXIgPVxuXHRcdFwiXFxuXFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgc3JjO1xcblxcblxcXG51bmlmb3JtIGZsb2F0IGN2c0hlaWdodDtcXG5cXFxudW5pZm9ybSBmbG9hdCBjdnNXaWR0aDtcXG5cXG5cXFxudW5pZm9ybSBmbG9hdCBzaWdtYTtcXG5cXFxudW5pZm9ybSBmbG9hdCBrO1xcblxcXG51bmlmb3JtIGZsb2F0IHA7XFxuXFxcbnVuaWZvcm0gZmxvYXQgZXBzaWxvbjtcXG5cXFxudW5pZm9ybSBmbG9hdCBwaGk7XFxuXFxcbnZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcblxcXG5mbG9hdCBjb3NoKGZsb2F0IHZhbClcXG5cXFxue1xcblxcXG5cdGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcblxcXG5cdGZsb2F0IGNvc0ggPSAodG1wICsgMS4wIC8gdG1wKSAvIDIuMDtcXG5cXFxuXHRyZXR1cm4gY29zSDtcXG5cXFxufVxcblxcblxcXG5mbG9hdCB0YW5oKGZsb2F0IHZhbClcXG5cXFxue1xcblxcXG5cdGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcblxcXG5cdGZsb2F0IHRhbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvICh0bXAgKyAxLjAgLyB0bXApO1xcblxcXG5cdHJldHVybiB0YW5IO1xcblxcXG59XFxuXFxuXFxcbmZsb2F0IHNpbmgoZmxvYXQgdmFsKVxcblxcXG57XFxuXFxcblx0ZmxvYXQgdG1wID0gZXhwKHZhbCk7XFxuXFxcblx0ZmxvYXQgc2luSCA9ICh0bXAgLSAxLjAgLyB0bXApIC8gMi4wO1xcblxcXG5cdHJldHVybiBzaW5IO1xcblxcXG59XFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKXtcXG5cXFxuXHR2ZWMzIGRlc3RDb2xvciA9IHZlYzMoMC4wKTtcXG5cXFxuXHRmbG9hdCB0RnJhZyA9IDEuMCAvIGN2c0hlaWdodDtcXG5cXFxuXHRmbG9hdCBzRnJhZyA9IDEuMCAvIGN2c1dpZHRoO1xcblxcXG5cdHZlYzIgRnJhZyA9IHZlYzIoc0ZyYWcsdEZyYWcpO1xcblxcXG5cdHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQuc3Q7XFxuXFxcblx0ZmxvYXQgdHdvU2lnbWFFU3F1YXJlZCA9IDIuMCAqIHNpZ21hICogc2lnbWE7XFxuXFxcblx0ZmxvYXQgdHdvU2lnbWFSU3F1YXJlZCA9IHR3b1NpZ21hRVNxdWFyZWQgKiBrICogaztcXG5cXFxuXHRpbnQgaGFsZldpZHRoID0gaW50KGNlaWwoIDEuMCAqIHNpZ21hICogayApKTtcXG5cXG5cXFxuXHRjb25zdCBpbnQgTUFYX05VTV9JVEVSQVRJT04gPSA5OTk5OTtcXG5cXFxuXHR2ZWMyIHN1bSA9IHZlYzIoMC4wKTtcXG5cXFxuXHR2ZWMyIG5vcm0gPSB2ZWMyKDAuMCk7XFxuXFxuXFxcblx0Zm9yKGludCBjbnQ9MDtjbnQ8TUFYX05VTV9JVEVSQVRJT047Y250Kyspe1xcblxcXG5cdFx0aWYoY250ID4gKDIqaGFsZldpZHRoKzEpKigyKmhhbGZXaWR0aCsxKSl7YnJlYWs7fVxcblxcXG5cdFx0aW50IGkgPSBpbnQoY250IC8gKDIqaGFsZldpZHRoKzEpKSAtIGhhbGZXaWR0aDtcXG5cXFxuXHRcdGludCBqID0gY250IC0gaGFsZldpZHRoIC0gaW50KGNudCAvICgyKmhhbGZXaWR0aCsxKSkgKiAoMipoYWxmV2lkdGgrMSk7XFxuXFxuXFxcblx0XHRmbG9hdCBkID0gbGVuZ3RoKHZlYzIoaSxqKSk7XFxuXFxcblx0XHR2ZWMyIGtlcm5lbCA9IHZlYzIoIGV4cCggLWQgKiBkIC8gdHdvU2lnbWFFU3F1YXJlZCApLCBcXG5cXFxuXHRcdFx0XHRcdFx0XHRleHAoIC1kICogZCAvIHR3b1NpZ21hUlNxdWFyZWQgKSk7XFxuXFxuXFxcblx0XHR2ZWMyIEwgPSB0ZXh0dXJlMkQoc3JjLCAodXYgKyB2ZWMyKGksaikpICogRnJhZykueHg7XFxuXFxuXFxcblx0XHRub3JtICs9IGtlcm5lbDtcXG5cXFxuXHRcdHN1bSArPSBrZXJuZWwgKiBMO1xcblxcXG5cdH1cXG5cXG5cXFxuXHRzdW0gLz0gbm9ybTtcXG5cXG5cXFxuXHRmbG9hdCBIID0gMTAwLjAgKiAoKDEuMCArIHApICogc3VtLnggLSBwICogc3VtLnkpO1xcblxcXG5cdGZsb2F0IGVkZ2UgPSAoIEggPiBlcHNpbG9uICk/IDEuMCA6IDEuMCArIHRhbmgoIHBoaSAqIChIIC0gZXBzaWxvbikpO1xcblxcXG5cdGRlc3RDb2xvciA9IHZlYzMoZWRnZSk7XFxuXFxcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNChkZXN0Q29sb3IsIDEuMCk7XFxuXFxcbn1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUveERvR1wiLCBMR3JhcGhUZXh0dXJlWERvR0ZpbHRlcik7XG5cblx0Ly8gVGV4dHVyZSBXZWJjYW0gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVdlYmNhbSgpIHtcblx0XHR0aGlzLmFkZE91dHB1dChcIldlYmNhbVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB0ZXh0dXJlX25hbWU6IFwiXCIsIGZhY2luZ01vZGU6IFwidXNlclwiIH07XG5cdFx0dGhpcy5ib3hjb2xvciA9IFwiYmxhY2tcIjtcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS50aXRsZSA9IFwiV2ViY2FtXCI7XG5cdExHcmFwaFRleHR1cmVXZWJjYW0uZGVzYyA9IFwiV2ViY2FtIHRleHR1cmVcIjtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub3BlblN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSkge1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnZ2V0VXNlck1lZGlhKCkgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIsIHVzZSBjaHJvbWUgYW5kIGVuYWJsZSBXZWJSVEMgZnJvbSBhYm91dDovL2ZsYWdzJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSB0cnVlO1xuXG5cdFx0Ly8gTm90IHNob3dpbmcgdmVuZG9yIHByZWZpeGVzLlxuXHRcdHZhciBjb25zdHJhaW50cyA9IHtcblx0XHRcdGF1ZGlvOiBmYWxzZSxcblx0XHRcdHZpZGVvOiB7IGZhY2luZ01vZGU6IHRoaXMucHJvcGVydGllcy5mYWNpbmdNb2RlIH1cblx0XHR9O1xuXHRcdG5hdmlnYXRvci5tZWRpYURldmljZXNcblx0XHRcdC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG5cdFx0XHQudGhlbih0aGlzLnN0cmVhbVJlYWR5LmJpbmQodGhpcykpXG5cdFx0XHQuY2F0Y2gob25GYWlsU29IYXJkKTtcblxuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRmdW5jdGlvbiBvbkZhaWxTb0hhcmQoZSkge1xuXHRcdFx0TEdyYXBoVGV4dHVyZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IGZhbHNlO1xuXHRcdFx0Y29uc29sZS5sb2coXCJXZWJjYW0gcmVqZWN0ZWRcIiwgZSk7XG5cdFx0XHR0aGF0Ll93ZWJjYW1fc3RyZWFtID0gZmFsc2U7XG5cdFx0XHR0aGF0LmJveGNvbG9yID0gXCJyZWRcIjtcblx0XHRcdHRoYXQudHJpZ2dlcihcInN0cmVhbV9lcnJvclwiKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUuY2xvc2VTdHJlYW0gPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fd2ViY2FtX3N0cmVhbSkge1xuXHRcdFx0dmFyIHRyYWNrcyA9IHRoaXMuX3dlYmNhbV9zdHJlYW0uZ2V0VHJhY2tzKCk7XG5cdFx0XHRpZiAodHJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHRyYWNrc1tpXS5zdG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdExHcmFwaFRleHR1cmVXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcblx0XHRcdHRoaXMuX3dlYmNhbV9zdHJlYW0gPSBudWxsO1xuXHRcdFx0dGhpcy5fdmlkZW8gPSBudWxsO1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiYmxhY2tcIjtcblx0XHRcdHRoaXMudHJpZ2dlcihcInN0cmVhbV9jbG9zZWRcIik7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLnN0cmVhbVJlYWR5ID0gZnVuY3Rpb24obG9jYWxNZWRpYVN0cmVhbSkge1xuXHRcdHRoaXMuX3dlYmNhbV9zdHJlYW0gPSBsb2NhbE1lZGlhU3RyZWFtO1xuXHRcdC8vdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSBmYWxzZTtcblx0XHR0aGlzLmJveGNvbG9yID0gXCJncmVlblwiO1xuXHRcdHZhciB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuXHRcdGlmICghdmlkZW8pIHtcblx0XHRcdHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHRcdFx0dmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuXHRcdFx0dmlkZW8uc3JjT2JqZWN0ID0gbG9jYWxNZWRpYVN0cmVhbTtcblx0XHRcdHRoaXMuX3ZpZGVvID0gdmlkZW87XG5cdFx0XHQvL2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHZpZGVvICk7IC8vZGVidWdcblx0XHRcdC8vd2hlbiB2aWRlbyBpbmZvIGlzIGxvYWRlZCAoc2l6ZSBhbmQgc28pXG5cdFx0XHR2aWRlby5vbmxvYWRlZG1ldGFkYXRhID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBSZWFkeSB0byBnby4gRG8gc29tZSBzdHVmZi5cblx0XHRcdFx0TEdyYXBoVGV4dHVyZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IHRydWU7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy50cmlnZ2VyKFwic3RyZWFtX3JlYWR5XCIsIHZpZGVvKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKFxuXHRcdG5hbWUsXG5cdFx0dmFsdWVcblx0KSB7XG5cdFx0aWYgKG5hbWUgPT0gXCJmYWNpbmdNb2RlXCIpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5mYWNpbmdNb2RlID0gdmFsdWU7XG5cdFx0XHR0aGlzLmNsb3NlU3RyZWFtKCk7XG5cdFx0XHR0aGlzLm9wZW5TdHJlYW0oKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl93ZWJjYW1fc3RyZWFtKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRyYWNrcyA9IHRoaXMuX3dlYmNhbV9zdHJlYW0uZ2V0VHJhY2tzKCk7XG5cdFx0aWYgKHRyYWNrcy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRyYWNrc1tpXS5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fd2ViY2FtX3N0cmVhbSA9IG51bGw7XG5cdFx0dGhpcy5fdmlkZW8gPSBudWxsO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQgfHwgdGhpcy5zaXplWzFdIDw9IDIwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl92aWRlbykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vcmVuZGVyIHRvIGdyYXBoIGNhbnZhc1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKCFjdHgud2ViZ2wpIHtcblx0XHRcdC8vcmV2ZXJzZSBpbWFnZVxuXHRcdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLl92aWRlbywgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5fdmlkZW9fdGV4dHVyZSkge1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKFxuXHRcdFx0XHRcdHRoaXMuX3ZpZGVvX3RleHR1cmUsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdHRoaXMuc2l6ZVswXSxcblx0XHRcdFx0XHR0aGlzLnNpemVbMV1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fd2ViY2FtX3N0cmVhbSA9PSBudWxsICYmICF0aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbikge1xuXHRcdFx0dGhpcy5vcGVuU3RyZWFtKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl92aWRlbyB8fCAhdGhpcy5fdmlkZW8udmlkZW9XaWR0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRoaXMuX3ZpZGVvLnZpZGVvV2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRoaXMuX3ZpZGVvLnZpZGVvSGVpZ2h0O1xuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl92aWRlb190ZXh0dXJlO1xuXHRcdGlmICghdGVtcCB8fCB0ZW1wLndpZHRoICE9IHdpZHRoIHx8IHRlbXAuaGVpZ2h0ICE9IGhlaWdodCkge1xuXHRcdFx0dGhpcy5fdmlkZW9fdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0IsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl92aWRlb190ZXh0dXJlLnVwbG9hZEltYWdlKHRoaXMuX3ZpZGVvKTtcblx0XHR0aGlzLl92aWRlb190ZXh0dXJlLnZlcnNpb24gPSArK3RoaXMudmVyc2lvbjtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMudGV4dHVyZV9uYW1lKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlc0NvbnRhaW5lcigpO1xuXHRcdFx0Y29udGFpbmVyW3RoaXMucHJvcGVydGllcy50ZXh0dXJlX25hbWVdID0gdGhpcy5fdmlkZW9fdGV4dHVyZTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmlkZW9fdGV4dHVyZSk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGlmICghdGhpcy5vdXRwdXRzW2ldKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoICh0aGlzLm91dHB1dHNbaV0ubmFtZSkge1xuXHRcdFx0XHRjYXNlIFwid2lkdGhcIjpcblx0XHRcdFx0XHR0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9XaWR0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJoZWlnaHRcIjpcblx0XHRcdFx0XHR0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9IZWlnaHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W1wid2lkdGhcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJoZWlnaHRcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJzdHJlYW1fcmVhZHlcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcblx0XHRcdFtcInN0cmVhbV9jbG9zZWRcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcblx0XHRcdFtcInN0cmVhbV9lcnJvclwiLCBMaXRlR3JhcGguRVZFTlRdXG5cdFx0XTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvd2ViY2FtXCIsIExHcmFwaFRleHR1cmVXZWJjYW0pO1xuXG5cdC8vZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3BpdGUvV2FnbmVyXG5cdGZ1bmN0aW9uIExHcmFwaExlbnNGWCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJmXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0ZmFjdG9yOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPV1xuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiAwLCB1X2ZhY3RvcjogMSB9O1xuXHR9XG5cblx0TEdyYXBoTGVuc0ZYLnRpdGxlID0gXCJMZW5zIEZYXCI7XG5cdExHcmFwaExlbnNGWC5kZXNjID0gXCJkaXN0b3J0aW9uIGFuZCBjaHJvbWF0aWMgYWJlcnJhdGlvblwiO1xuXG5cdExHcmFwaExlbnNGWC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaExlbnNGWC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdXTtcblx0fTtcblxuXHRMR3JhcGhMZW5zRlgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAoXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCB8fFxuXHRcdFx0dGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJlbmFibGVkXCIpID09PSBmYWxzZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0dGV4LndpZHRoLFxuXHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHR7IHR5cGU6IHRleC50eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaExlbnNGWC5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhMZW5zRlguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoTGVuc0ZYLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgZmFjdG9yID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYgKGZhY3RvciA9PSBudWxsKSB7XG5cdFx0XHRmYWN0b3IgPSB0aGlzLnByb3BlcnRpZXMuZmFjdG9yO1xuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfZmFjdG9yID0gZmFjdG9yO1xuXG5cdFx0Ly9hcHBseSBzaGFkZXJcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdHRlbXAuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdExHcmFwaExlbnNGWC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZmFjdG9yO1xcblxcXG5cdFx0dmVjMiBiYXJyZWxEaXN0b3J0aW9uKHZlYzIgY29vcmQsIGZsb2F0IGFtdCkge1xcblxcXG5cdFx0XHR2ZWMyIGNjID0gY29vcmQgLSAwLjU7XFxuXFxcblx0XHRcdGZsb2F0IGRpc3QgPSBkb3QoY2MsIGNjKTtcXG5cXFxuXHRcdFx0cmV0dXJuIGNvb3JkICsgY2MgKiBkaXN0ICogYW10O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBzYXQoIGZsb2F0IHQgKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHRyZXR1cm4gY2xhbXAoIHQsIDAuMCwgMS4wICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdGZsb2F0IGxpbnRlcnAoIGZsb2F0IHQgKSB7XFxuXFxcblx0XHRcdHJldHVybiBzYXQoIDEuMCAtIGFicyggMi4wKnQgLSAxLjAgKSApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCByZW1hcCggZmxvYXQgdCwgZmxvYXQgYSwgZmxvYXQgYiApIHtcXG5cXFxuXHRcdFx0cmV0dXJuIHNhdCggKHQgLSBhKSAvIChiIC0gYSkgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0dmVjNCBzcGVjdHJ1bV9vZmZzZXQoIGZsb2F0IHQgKSB7XFxuXFxcblx0XHRcdHZlYzQgcmV0O1xcblxcXG5cdFx0XHRmbG9hdCBsbyA9IHN0ZXAodCwwLjUpO1xcblxcXG5cdFx0XHRmbG9hdCBoaSA9IDEuMC1sbztcXG5cXFxuXHRcdFx0ZmxvYXQgdyA9IGxpbnRlcnAoIHJlbWFwKCB0LCAxLjAvNi4wLCA1LjAvNi4wICkgKTtcXG5cXFxuXHRcdFx0cmV0ID0gdmVjNChsbywxLjAsaGksIDEuKSAqIHZlYzQoMS4wLXcsIHcsIDEuMC13LCAxLik7XFxuXFxcblx0XHRcXG5cXFxuXHRcdFx0cmV0dXJuIHBvdyggcmV0LCB2ZWM0KDEuMC8yLjIpICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdGNvbnN0IGZsb2F0IG1heF9kaXN0b3J0ID0gMi4yO1xcblxcXG5cdFx0Y29uc3QgaW50IG51bV9pdGVyID0gMTI7XFxuXFxcblx0XHRjb25zdCBmbG9hdCByZWNpX251bV9pdGVyX2YgPSAxLjAgLyBmbG9hdChudW1faXRlcik7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpXFxuXFxcblx0XHR7XHRcXG5cXFxuXHRcdFx0dmVjMiB1dj12X2Nvb3JkO1xcblxcXG5cdFx0XHR2ZWM0IHN1bWNvbCA9IHZlYzQoMC4wKTtcXG5cXFxuXHRcdFx0dmVjNCBzdW13ID0gdmVjNCgwLjApO1x0XFxuXFxcblx0XHRcdGZvciAoIGludCBpPTA7IGk8bnVtX2l0ZXI7KytpIClcXG5cXFxuXHRcdFx0e1xcblxcXG5cdFx0XHRcdGZsb2F0IHQgPSBmbG9hdChpKSAqIHJlY2lfbnVtX2l0ZXJfZjtcXG5cXFxuXHRcdFx0XHR2ZWM0IHcgPSBzcGVjdHJ1bV9vZmZzZXQoIHQgKTtcXG5cXFxuXHRcdFx0XHRzdW13ICs9IHc7XFxuXFxcblx0XHRcdFx0c3VtY29sICs9IHcgKiB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgYmFycmVsRGlzdG9ydGlvbih1diwgLjYgKiBtYXhfZGlzdG9ydCp0ICogdV9mYWN0b3IgKSApO1xcblxcXG5cdFx0XHR9XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHN1bWNvbCAvIHN1bXc7XFxuXFxcblx0XHR9XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2xlbnNmeFwiLCBMR3JhcGhMZW5zRlgpO1xuXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUZyb21EYXRhKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5MT1csIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGNoYW5uZWxzOiAxIH07XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUZyb21EYXRhLnRpdGxlID0gXCJEYXRhLT5UZXhcIjtcblx0TEdyYXBoVGV4dHVyZUZyb21EYXRhLmRlc2MgPSBcIkdlbmVyYXRlcyBvciBhcHBsaWVzIGEgY3VydmUgdG8gYSB0ZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmVGcm9tRGF0YS53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVGcm9tRGF0YS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYoIWRhdGEpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgY2hhbm5lbHMgPSB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbHM7XG5cdFx0dmFyIHcgPSB0aGlzLnByb3BlcnRpZXMud2lkdGg7XG5cdFx0dmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0O1xuXHRcdGlmKCF3IHx8ICFoKVxuXHRcdHtcblx0XHRcdHcgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gY2hhbm5lbHMpO1xuXHRcdFx0aCA9IDE7XG5cdFx0fVxuXHRcdHZhciBmb3JtYXQgPSBnbC5SR0JBO1xuXHRcdGlmKCBjaGFubmVscyA9PSAzIClcblx0XHRcdGZvcm1hdCA9IGdsLlJHQjtcblx0XHRlbHNlIGlmKCBjaGFubmVscyA9PSAxIClcblx0XHRcdGZvcm1hdCA9IGdsLkxVTUlOQU5DRTtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdGlmICggIXRlbXAgfHwgdGVtcC53aWR0aCAhPSB3IHx8IHRlbXAuaGVpZ2h0ICE9IGggfHwgdGVtcC50eXBlICE9IHR5cGUgKSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHcsIGgsIHsgdHlwZTogdHlwZSwgZm9ybWF0OiBmb3JtYXQsIGZpbHRlcjogZ2wuTElORUFSIH0gKTtcblx0XHR9XG5cblx0XHR0ZW1wLnVwbG9hZERhdGEoIGRhdGEgKTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH1cblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZnJvbWRhdGFcIiwgTEdyYXBoVGV4dHVyZUZyb21EYXRhKTtcblxuXHQvL2FwcGxpZXMgYSBjdXJ2ZSAob3IgZ2VuZXJhdGVzIG9uZSlcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUN1cnZlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPVywgc3BsaXRfY2hhbm5lbHM6IGZhbHNlIH07XG5cdFx0dGhpcy5fdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KjQpO1xuXHRcdHRoaXMuX3ZhbHVlcy5maWxsKDI1NSk7XG5cdFx0dGhpcy5fY3VydmVfdGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7IHVfdGV4dHVyZTogMCwgdV9jdXJ2ZTogMSwgdV9yYW5nZTogMS4wIH07XG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3BvaW50cyA9IHtcblx0XHRcdFJHQjogW1swLDBdLFsxLDFdXSxcblx0XHRcdFI6IFtbMCwwXSxbMSwxXV0sXG5cdFx0XHRHOiBbWzAsMF0sWzEsMV1dLFxuXHRcdFx0QjogW1swLDBdLFsxLDFdXVxuXHRcdH07XG5cdFx0dGhpcy5jdXJ2ZV9lZGl0b3IgPSBudWxsO1xuXHRcdHRoaXMuYWRkV2lkZ2V0KFwidG9nZ2xlXCIsXCJTcGxpdCBDaGFubmVsc1wiLGZhbHNlLFwic3BsaXRfY2hhbm5lbHNcIik7XG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwiQ2hhbm5lbFwiLFwiUkdCXCIseyB2YWx1ZXM6W1wiUkdCXCIsXCJSXCIsXCJHXCIsXCJCXCJdfSk7XG5cdFx0dGhpcy5jdXJ2ZV9vZmZzZXQgPSA2ODtcblx0XHR0aGlzLnNpemUgPSBbIDI0MCwgMTYwIF07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUudGl0bGUgPSBcIkN1cnZlXCI7XG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5kZXNjID0gXCJHZW5lcmF0ZXMgb3IgYXBwbGllcyBhIGN1cnZlIHRvIGEgdGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlQ3VydmUud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRpZighdGV4KSAvL2dlbmVyYXRlIG9uZSB0ZXh0dXJlLCBub3RoaW5nIGVsc2Vcblx0XHR7XG5cdFx0XHRpZih0aGlzLl9tdXN0X3VwZGF0ZSB8fCAhdGhpcy5fY3VydmVfdGV4dHVyZSApXG5cdFx0XHRcdHRoaXMudXBkYXRlQ3VydmUoKTtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9jdXJ2ZV90ZXh0dXJlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIHRleCApO1xuXHRcdFxuXHRcdC8vYXBwbHkgY3VydmUgdG8gaW5wdXQgdGV4dHVyZVxuXHRcdGlmICggIXRlbXAgfHwgdGVtcC50eXBlICE9IHR5cGUgfHwgdGVtcC53aWR0aCAhPSB0ZXgud2lkdGggfHwgdGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fCB0ZW1wLmZvcm1hdCAhPSB0ZXguZm9ybWF0KVxuXHRcdFx0dGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKCB0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHsgdHlwZTogdHlwZSwgZm9ybWF0OiB0ZXguZm9ybWF0LCBmaWx0ZXI6IGdsLkxJTkVBUiB9ICk7XG5cblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUN1cnZlLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVDdXJ2ZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlQ3VydmUucGl4ZWxfc2hhZGVyICk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fbXVzdF91cGRhdGUgfHwgIXRoaXMuX2N1cnZlX3RleHR1cmUgKVxuXHRcdFx0dGhpcy51cGRhdGVDdXJ2ZSgpO1xuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dmFyIGN1cnZlX3RleHR1cmUgPSB0aGlzLl9jdXJ2ZV90ZXh0dXJlO1xuXG5cdFx0Ly9hcHBseSBzaGFkZXJcblx0XHR0ZW1wLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdGN1cnZlX3RleHR1cmUuYmluZCgxKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhHTC5NZXNoLmdldFNjcmVlblF1YWQoKSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLnNhbXBsZUN1cnZlID0gZnVuY3Rpb24oZixwb2ludHMpXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gcG9pbnRzIHx8IHRoaXMuX3BvaW50cy5SR0I7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybjtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHZhciBwbiA9IHBvaW50c1tpKzFdO1xuXHRcdFx0aWYocG5bMF0gPCBmKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHZhciByID0gKHBuWzBdIC0gcFswXSk7XG5cdFx0XHRpZiggTWF0aC5hYnMocikgPCAwLjAwMDAxIClcblx0XHRcdFx0cmV0dXJuIHBbMV07XG5cdFx0XHR2YXIgbG9jYWxfZiA9IChmIC0gcFswXSkgLyByO1xuXHRcdFx0cmV0dXJuIHBbMV0gKiAoMS4wIC0gbG9jYWxfZikgKyBwblsxXSAqIGxvY2FsX2Y7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS51cGRhdGVDdXJ2ZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG5cdFx0dmFyIG51bSA9IHZhbHVlcy5sZW5ndGggLyA0O1xuXHRcdHZhciBzcGxpdCA9IHRoaXMucHJvcGVydGllcy5zcGxpdF9jaGFubmVscztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpXG5cdFx0e1xuXHRcdFx0aWYoc3BsaXQpXG5cdFx0XHR7XG5cdFx0XHRcdHZhbHVlc1tpKjRdID0gTWF0aC5jbGFtcCggdGhpcy5zYW1wbGVDdXJ2ZShpL251bSx0aGlzLl9wb2ludHMuUikqMjU1LDAsMjU1KTtcblx0XHRcdFx0dmFsdWVzW2kqNCsxXSA9IE1hdGguY2xhbXAoIHRoaXMuc2FtcGxlQ3VydmUoaS9udW0sdGhpcy5fcG9pbnRzLkcpKjI1NSwwLDI1NSk7XG5cdFx0XHRcdHZhbHVlc1tpKjQrMl0gPSBNYXRoLmNsYW1wKCB0aGlzLnNhbXBsZUN1cnZlKGkvbnVtLHRoaXMuX3BvaW50cy5CKSoyNTUsMCwyNTUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMuc2FtcGxlQ3VydmUoaS9udW0pOy8vc2FtcGxlIGN1cnZlXG5cdFx0XHRcdHZhbHVlc1tpKjRdID0gdmFsdWVzW2kqNCsxXSA9IHZhbHVlc1tpKjQrMl0gPSBNYXRoLmNsYW1wKHYqMjU1LDAsMjU1KTtcblx0XHRcdH1cblx0XHRcdHZhbHVlc1tpKjQrM10gPSAyNTU7IC8vYWxwaGEgZml4ZWRcblx0XHR9XG5cdFx0aWYoIXRoaXMuX2N1cnZlX3RleHR1cmUpXG5cdFx0XHR0aGlzLl9jdXJ2ZV90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoMjU2LDEseyBmb3JtYXQ6IGdsLlJHQkEsIG1hZ0ZpbHRlcjogZ2wuTElORUFSLCB3cmFwOiBnbC5DTEFNUF9UT19FREdFIH0pO1xuXHRcdHRoaXMuX2N1cnZlX3RleHR1cmUudXBsb2FkRGF0YSh2YWx1ZXMsbnVsbCx0cnVlKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5wcm90b3R5cGUub25TZXJpYWxpemUgPSBmdW5jdGlvbihvKVxuXHR7XG5cdFx0dmFyIGN1cnZlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSBpbiB0aGlzLl9wb2ludHMpXG5cdFx0XHRjdXJ2ZXNbaV0gPSB0aGlzLl9wb2ludHNbaV0uY29uY2F0KCk7XG5cdFx0by5jdXJ2ZXMgPSBjdXJ2ZXM7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uQ29uZmlndXJlID0gZnVuY3Rpb24obylcblx0e1xuXHRcdHRoaXMuX3BvaW50cyA9IG8uY3VydmVzO1xuXHRcdGlmKHRoaXMuY3VydmVfZWRpdG9yKVxuXHRcdFx0Y3VydmVfZWRpdG9yLnBvaW50cyA9IHRoaXMuX3BvaW50cztcblx0XHR0aGlzLl9tdXN0X3VwZGF0ZSA9IHRydWU7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgbG9jYWxwb3MsIGdyYXBoY2FudmFzKVxuXHR7XG5cdFx0aWYodGhpcy5jdXJ2ZV9lZGl0b3IpXG5cdFx0e1xuXHRcdFx0dmFyIHIgPSB0aGlzLmN1cnZlX2VkaXRvci5vbk1vdXNlRG93bihbbG9jYWxwb3NbMF0sbG9jYWxwb3NbMV0tdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcyk7XG5cdFx0XHRpZihyKVxuXHRcdFx0XHR0aGlzLmNhcHR1cmVJbnB1dCh0cnVlKTtcblx0XHRcdHJldHVybiByO1xuXHRcdH1cblx0fVxuXG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlLCBsb2NhbHBvcywgZ3JhcGhjYW52YXMpXG5cdHtcblx0XHRpZih0aGlzLmN1cnZlX2VkaXRvcilcblx0XHRcdHJldHVybiB0aGlzLmN1cnZlX2VkaXRvci5vbk1vdXNlTW92ZShbbG9jYWxwb3NbMF0sbG9jYWxwb3NbMV0tdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcyk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGUsIGxvY2FscG9zLCBncmFwaGNhbnZhcylcblx0e1xuXHRcdGlmKHRoaXMuY3VydmVfZWRpdG9yKVxuXHRcdFx0cmV0dXJuIHRoaXMuY3VydmVfZWRpdG9yLm9uTW91c2VVcChbbG9jYWxwb3NbMF0sbG9jYWxwb3NbMV0tdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcyk7XG5cdFx0dGhpcy5jYXB0dXJlSW5wdXQoZmFsc2UpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLmNoYW5uZWxfbGluZV9jb2xvcnMgPSB7IFwiUkdCXCI6XCIjNjY2XCIsXCJSXCI6XCIjRjMzXCIsXCJHXCI6XCIjM0YzXCIsXCJCXCI6XCIjMzNGXCIgfTtcblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgsIGdyYXBoY2FudmFzKVxuXHR7XG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRpZighdGhpcy5jdXJ2ZV9lZGl0b3IpXG5cdFx0XHR0aGlzLmN1cnZlX2VkaXRvciA9IG5ldyBMaXRlR3JhcGguQ3VydmVFZGl0b3IodGhpcy5fcG9pbnRzLlIpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LnRyYW5zbGF0ZSgwLHRoaXMuY3VydmVfb2Zmc2V0KTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMud2lkZ2V0c1sxXS52YWx1ZTtcblxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5zcGxpdF9jaGFubmVscylcblx0XHR7XG5cdFx0XHRpZihjaGFubmVsID09IFwiUkdCXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMud2lkZ2V0c1sxXS52YWx1ZSA9IGNoYW5uZWwgPSBcIlJcIjtcblx0XHRcdFx0dGhpcy53aWRnZXRzWzFdLmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnZlX2VkaXRvci5wb2ludHMgPSB0aGlzLl9wb2ludHMuUjtcblx0XHRcdHRoaXMuY3VydmVfZWRpdG9yLmRyYXcoIGN0eCwgW3RoaXMuc2l6ZVswXSx0aGlzLnNpemVbMV0gLSB0aGlzLmN1cnZlX29mZnNldF0sIGdyYXBoY2FudmFzLCBcIiMxMTFcIiwgTEdyYXBoVGV4dHVyZUN1cnZlLmNoYW5uZWxfbGluZV9jb2xvcnMuUiwgdHJ1ZSApO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwibGlnaHRlblwiO1xuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IucG9pbnRzID0gdGhpcy5fcG9pbnRzLkc7XG5cdFx0XHR0aGlzLmN1cnZlX2VkaXRvci5kcmF3KCBjdHgsIFt0aGlzLnNpemVbMF0sdGhpcy5zaXplWzFdIC0gdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcywgbnVsbCwgTEdyYXBoVGV4dHVyZUN1cnZlLmNoYW5uZWxfbGluZV9jb2xvcnMuRywgdHJ1ZSApO1xuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IucG9pbnRzID0gdGhpcy5fcG9pbnRzLkI7XG5cdFx0XHR0aGlzLmN1cnZlX2VkaXRvci5kcmF3KCBjdHgsIFt0aGlzLnNpemVbMF0sdGhpcy5zaXplWzFdIC0gdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcywgbnVsbCwgTEdyYXBoVGV4dHVyZUN1cnZlLmNoYW5uZWxfbGluZV9jb2xvcnMuQiwgdHJ1ZSApO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMud2lkZ2V0c1sxXS52YWx1ZSA9IGNoYW5uZWwgPSBcIlJHQlwiO1xuXHRcdFx0dGhpcy53aWRnZXRzWzFdLmRpc2FibGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLmN1cnZlX2VkaXRvci5wb2ludHMgPSB0aGlzLl9wb2ludHNbY2hhbm5lbF07XG5cdFx0dGhpcy5jdXJ2ZV9lZGl0b3IuZHJhdyggY3R4LCBbdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSAtIHRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMsIHRoaXMucHJvcGVydGllcy5zcGxpdF9jaGFubmVscyA/IG51bGwgOiBcIiMxMTFcIiwgTEdyYXBoVGV4dHVyZUN1cnZlLmNoYW5uZWxfbGluZV9jb2xvcnNbY2hhbm5lbF0gICk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X2N1cnZlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3JhbmdlO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdl9jb29yZCApICogdV9yYW5nZTtcXG5cXFxuXHRcdFx0Y29sb3IueCA9IHRleHR1cmUyRCggdV9jdXJ2ZSwgdmVjMiggY29sb3IueCwgMC41ICkgKS54O1xcblxcXG5cdFx0XHRjb2xvci55ID0gdGV4dHVyZTJEKCB1X2N1cnZlLCB2ZWMyKCBjb2xvci55LCAwLjUgKSApLnk7XFxuXFxcblx0XHRcdGNvbG9yLnogPSB0ZXh0dXJlMkQoIHVfY3VydmUsIHZlYzIoIGNvbG9yLnosIDAuNSApICkuejtcXG5cXFxuXHRcdFx0Ly9jb2xvci53ID0gdGV4dHVyZTJEKCB1X2N1cnZlLCB2ZWMyKCBjb2xvci53LCAwLjUgKSApLnc7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9jdXJ2ZVwiLCBMR3JhcGhUZXh0dXJlQ3VydmUpO1xuXG5cdC8vc2ltcGxlIGV4cG9zaXRpb24sIGJ1dCBwbGFuIHRvIGV4cGFuZCBpdCB0byBzdXBwb3J0IGRpZmZlcmVudCBnYW1tYSBjdXJ2ZXNcblx0ZnVuY3Rpb24gTEdyYXBoRXhwb3NpdGlvbigpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJleHBcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZXhwb3NpdGlvbjogMSwgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPVyB9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0geyB1X3RleHR1cmU6IDAsIHVfZXhwb3NpdGlvbjogMSB9O1xuXHR9XG5cblx0TEdyYXBoRXhwb3NpdGlvbi50aXRsZSA9IFwiRXhwb3NpdGlvblwiO1xuXHRMR3JhcGhFeHBvc2l0aW9uLmRlc2MgPSBcIkNvbnRyb2xzIHRleHR1cmUgZXhwb3NpdGlvblwiO1xuXG5cdExHcmFwaEV4cG9zaXRpb24ud2lkZ2V0c19pbmZvID0ge1xuXHRcdGV4cG9zaXRpb246IHsgd2lkZ2V0OiBcInNsaWRlclwiLCBtaW46IDAsIG1heDogMyB9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhFeHBvc2l0aW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0dGV4LndpZHRoLFxuXHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHR7IHR5cGU6IHRleC50eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaEV4cG9zaXRpb24uX3NoYWRlcjtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoRXhwb3NpdGlvbi5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhFeHBvc2l0aW9uLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgZXhwID0gdGhpcy5wcm9wZXJ0aWVzLmV4cG9zaXRpb247XG5cdFx0dmFyIGV4cF9pbnB1dCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGlmIChleHBfaW5wdXQgIT0gbnVsbCkge1xuXHRcdFx0ZXhwID0gdGhpcy5wcm9wZXJ0aWVzLmV4cG9zaXRpb24gPSBleHBfaW5wdXQ7XG5cdFx0fVxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXG5cdFx0Ly9hcHBseSBzaGFkZXJcblx0XHR0ZW1wLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhHTC5NZXNoLmdldFNjcmVlblF1YWQoKSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH07XG5cblx0TEdyYXBoRXhwb3NpdGlvbi5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZXhwb3NpdGlvbjtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKTtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IueHl6ICogdV9leHBvc2l0aW9uLCBjb2xvci5hICk7XFxuXFxcblx0XHR9XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2V4cG9zaXRpb25cIiwgTEdyYXBoRXhwb3NpdGlvbik7XG5cblx0ZnVuY3Rpb24gTEdyYXBoVG9uZU1hcHBpbmcoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiYXZnXCIsIFwibnVtYmVyLFRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRzY2FsZTogMSxcblx0XHRcdGdhbW1hOiAxLFxuXHRcdFx0YXZlcmFnZV9sdW06IDEsXG5cdFx0XHRsdW1fd2hpdGU6IDEsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuTE9XXG5cdFx0fTtcblxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV9sdW13aGl0ZTI6IDEsXG5cdFx0XHR1X2lnYW1tYTogMSxcblx0XHRcdHVfc2NhbGU6IDEsXG5cdFx0XHR1X2F2ZXJhZ2VfbHVtOiAxXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRvbmVNYXBwaW5nLnRpdGxlID0gXCJUb25lIE1hcHBpbmdcIjtcblx0TEdyYXBoVG9uZU1hcHBpbmcuZGVzYyA9XG5cdFx0XCJBcHBsaWVzIFRvbmUgTWFwcGluZyB0byBjb252ZXJ0IGZyb20gaGlnaCB0byBsb3dcIjtcblxuXHRMR3JhcGhUb25lTWFwcGluZy53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRvbmVNYXBwaW5nLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbW1wiZW5hYmxlZFwiLCBcImJvb2xlYW5cIl1dO1xuXHR9O1xuXG5cdExHcmFwaFRvbmVNYXBwaW5nLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0ggfHxcblx0XHRcdHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZW5hYmxlZFwiKSA9PT0gZmFsc2Vcblx0XHQpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0dGV4LndpZHRoLFxuXHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHR7IHR5cGU6IHRleC50eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGF2ZyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGlmIChhdmcgPT0gbnVsbCkge1xuXHRcdFx0YXZnID0gdGhpcy5wcm9wZXJ0aWVzLmF2ZXJhZ2VfbHVtO1xuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHZhciBzaGFkZXIgPSBudWxsO1xuXG5cdFx0aWYgKGF2Zy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuYXZlcmFnZV9sdW0gPSBhdmc7XG5cdFx0XHR1bmlmb3Jtcy51X2F2ZXJhZ2VfbHVtID0gdGhpcy5wcm9wZXJ0aWVzLmF2ZXJhZ2VfbHVtO1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoVG9uZU1hcHBpbmcuX3NoYWRlcjtcblx0XHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRcdHNoYWRlciA9IExHcmFwaFRvbmVNYXBwaW5nLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUb25lTWFwcGluZy5waXhlbF9zaGFkZXJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGF2Zy5jb25zdHJ1Y3RvciA9PT0gR0wuVGV4dHVyZSkge1xuXHRcdFx0dW5pZm9ybXMudV9hdmVyYWdlX3RleHR1cmUgPSBhdmcuYmluZCgxKTtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRvbmVNYXBwaW5nLl9zaGFkZXJfdGV4dHVyZTtcblx0XHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRcdHNoYWRlciA9IExHcmFwaFRvbmVNYXBwaW5nLl9zaGFkZXJfdGV4dHVyZSA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdExHcmFwaFRvbmVNYXBwaW5nLnBpeGVsX3NoYWRlcixcblx0XHRcdFx0XHR7IEFWR19URVhUVVJFOiBcIlwiIH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy51X2x1bXdoaXRlMiA9XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMubHVtX3doaXRlICogdGhpcy5wcm9wZXJ0aWVzLmx1bV93aGl0ZTtcblx0XHR1bmlmb3Jtcy51X3NjYWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlO1xuXHRcdHVuaWZvcm1zLnVfaWdhbW1hID0gMSAvIHRoaXMucHJvcGVydGllcy5nYW1tYTtcblxuXHRcdC8vYXBwbHkgc2hhZGVyXG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR0ZW1wLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdExHcmFwaFRvbmVNYXBwaW5nLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcXG5cXFxuXHRcdCNpZmRlZiBBVkdfVEVYVFVSRVxcblxcXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X2F2ZXJhZ2VfdGV4dHVyZTtcXG5cXFxuXHRcdCNlbHNlXFxuXFxcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9hdmVyYWdlX2x1bTtcXG5cXFxuXHRcdCNlbmRpZlxcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2x1bXdoaXRlMjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9pZ2FtbWE7XFxuXFxcblx0XHR2ZWMzIFJHQjJ4eVkgKHZlYzMgcmdiKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHQgY29uc3QgbWF0MyBSR0IyWFlaID0gbWF0MygwLjQxMjQsIDAuMzU3NiwgMC4xODA1LFxcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHQgICAwLjIxMjYsIDAuNzE1MiwgMC4wNzIyLFxcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHQgICAwLjAxOTMsIDAuMTE5MiwgMC45NTA1KTtcXG5cXFxuXHRcdFx0dmVjMyBYWVogPSBSR0IyWFlaICogcmdiO1xcblxcXG5cdFx0XHRcXG5cXFxuXHRcdFx0ZmxvYXQgZiA9IChYWVoueCArIFhZWi55ICsgWFlaLnopO1xcblxcXG5cdFx0XHRyZXR1cm4gdmVjMyhYWVoueCAvIGYsXFxuXFxcblx0XHRcdFx0XHRcdFhZWi55IC8gZixcXG5cXFxuXHRcdFx0XHRcdFx0WFlaLnkpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdl9jb29yZCApO1xcblxcXG5cdFx0XHR2ZWMzIHJnYiA9IGNvbG9yLnh5ejtcXG5cXFxuXHRcdFx0ZmxvYXQgYXZlcmFnZV9sdW0gPSAwLjA7XFxuXFxcblx0XHRcdCNpZmRlZiBBVkdfVEVYVFVSRVxcblxcXG5cdFx0XHRcdHZlYzMgcGl4ZWwgPSB0ZXh0dXJlMkQodV9hdmVyYWdlX3RleHR1cmUsdmVjMigwLjUpKS54eXo7XFxuXFxcblx0XHRcdFx0YXZlcmFnZV9sdW0gPSAocGl4ZWwueCArIHBpeGVsLnkgKyBwaXhlbC56KSAvIDMuMDtcXG5cXFxuXHRcdFx0I2Vsc2VcXG5cXFxuXHRcdFx0XHRhdmVyYWdlX2x1bSA9IHVfYXZlcmFnZV9sdW07XFxuXFxcblx0XHRcdCNlbmRpZlxcblxcXG5cdFx0XHQvL0xkIC0gdGhpcyBwYXJ0IG9mIHRoZSBjb2RlIGlzIHRoZSBzYW1lIGZvciBib3RoIHZlcnNpb25zXFxuXFxcblx0XHRcdGZsb2F0IGx1bSA9IGRvdChyZ2IsIHZlYzMoMC4yMTI2LCAwLjcxNTIsIDAuMDcyMikpO1xcblxcXG5cdFx0XHRmbG9hdCBMID0gKHVfc2NhbGUgLyBhdmVyYWdlX2x1bSkgKiBsdW07XFxuXFxcblx0XHRcdGZsb2F0IExkID0gKEwgKiAoMS4wICsgTCAvIHVfbHVtd2hpdGUyKSkgLyAoMS4wICsgTCk7XFxuXFxcblx0XHRcdC8vZmlyc3RcXG5cXFxuXHRcdFx0Ly92ZWMzIHh5WSA9IFJHQjJ4eVkocmdiKTtcXG5cXFxuXHRcdFx0Ly94eVkueiAqPSBMZDtcXG5cXFxuXHRcdFx0Ly9yZ2IgPSB4eVl0b1JHQih4eVkpO1xcblxcXG5cdFx0XHQvL3NlY29uZFxcblxcXG5cdFx0XHRyZ2IgPSAocmdiIC8gbHVtKSAqIExkO1xcblxcXG5cdFx0XHRyZ2IgPSBtYXgocmdiLHZlYzMoMC4wMDEpKTtcXG5cXFxuXHRcdFx0cmdiID0gcG93KCByZ2IsIHZlYzMoIHVfaWdhbW1hICkgKTtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcmdiLCBjb2xvci5hICk7XFxuXFxcblx0XHR9XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3RvbmVtYXBwaW5nXCIsIExHcmFwaFRvbmVNYXBwaW5nKTtcblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlUGVybGluKCkge1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHR3aWR0aDogNTEyLFxuXHRcdFx0aGVpZ2h0OiA1MTIsXG5cdFx0XHRzZWVkOiAwLFxuXHRcdFx0cGVyc2lzdGVuY2U6IDAuMSxcblx0XHRcdG9jdGF2ZXM6IDgsXG5cdFx0XHRzY2FsZTogMSxcblx0XHRcdG9mZnNldDogWzAsIDBdLFxuXHRcdFx0YW1wbGl0dWRlOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHRcdHRoaXMuX2tleSA9IDA7XG5cdFx0dGhpcy5fdGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3BlcnNpc3RlbmNlOiAwLjEsXG5cdFx0XHR1X3NlZWQ6IDAsXG5cdFx0XHR1X29mZnNldDogdmVjMi5jcmVhdGUoKSxcblx0XHRcdHVfc2NhbGU6IDEsXG5cdFx0XHR1X3ZpZXdwb3J0OiB2ZWMyLmNyZWF0ZSgpXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4udGl0bGUgPSBcIlBlcmxpblwiO1xuXHRMR3JhcGhUZXh0dXJlUGVybGluLmRlc2MgPSBcIkdlbmVyYXRlcyBhIHBlcmxpbiBub2lzZSB0ZXh0dXJlXCI7XG5cblx0TEdyYXBoVGV4dHVyZVBlcmxpbi53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfSxcblx0XHR3aWR0aDogeyB0eXBlOiBcIm51bWJlclwiLCBwcmVjaXNpb246IDAsIHN0ZXA6IDEgfSxcblx0XHRoZWlnaHQ6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxIH0sXG5cdFx0b2N0YXZlczogeyB0eXBlOiBcIm51bWJlclwiLCBwcmVjaXNpb246IDAsIHN0ZXA6IDEsIG1pbjogMSwgbWF4OiA1MCB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVBlcmxpbi5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W1wic2VlZFwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcInBlcnNpc3RlbmNlXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wib2N0YXZlc1wiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcInNjYWxlXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiYW1wbGl0dWRlXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wib2Zmc2V0XCIsIFwidmVjMlwiXVxuXHRcdF07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVBlcmxpbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IHRoaXMucHJvcGVydGllcy5oZWlnaHQgfCAwO1xuXHRcdGlmICh3ID09IDApIHtcblx0XHRcdHcgPSBnbC52aWV3cG9ydF9kYXRhWzJdO1xuXHRcdH0gLy8wIG1lYW5zIGRlZmF1bHRcblx0XHRpZiAoaCA9PSAwKSB7XG5cdFx0XHRoID0gZ2wudmlld3BvcnRfZGF0YVszXTtcblx0XHR9IC8vMCBtZWFucyBkZWZhdWx0XG5cdFx0dmFyIHR5cGUgPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24pO1xuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHcgfHxcblx0XHRcdHRlbXAuaGVpZ2h0ICE9IGggfHxcblx0XHRcdHRlbXAudHlwZSAhPSB0eXBlXG5cdFx0KSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHcsIGgsIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0IsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgcGVyc2lzdGVuY2UgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInBlcnNpc3RlbmNlXCIpO1xuXHRcdHZhciBvY3RhdmVzID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJvY3RhdmVzXCIpO1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIm9mZnNldFwiKTtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInNjYWxlXCIpO1xuXHRcdHZhciBhbXBsaXR1ZGUgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImFtcGxpdHVkZVwiKTtcblx0XHR2YXIgc2VlZCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwic2VlZFwiKTtcblxuXHRcdC8vcmV1c2luZyBvbGQgdGV4dHVyZVxuXHRcdHZhciBrZXkgPVxuXHRcdFx0XCJcIiArXG5cdFx0XHR3ICtcblx0XHRcdGggK1xuXHRcdFx0dHlwZSArXG5cdFx0XHRwZXJzaXN0ZW5jZSArXG5cdFx0XHRvY3RhdmVzICtcblx0XHRcdHNjYWxlICtcblx0XHRcdHNlZWQgK1xuXHRcdFx0b2Zmc2V0WzBdICtcblx0XHRcdG9mZnNldFsxXSArXG5cdFx0XHRhbXBsaXR1ZGU7XG5cdFx0aWYgKGtleSA9PSB0aGlzLl9rZXkpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fa2V5ID0ga2V5O1xuXG5cdFx0Ly9nYXRoZXIgdW5pZm9ybXNcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X3BlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG5cdFx0dW5pZm9ybXMudV9vY3RhdmVzID0gb2N0YXZlcztcblx0XHR1bmlmb3Jtcy51X29mZnNldC5zZXQob2Zmc2V0KTtcblx0XHR1bmlmb3Jtcy51X3NjYWxlID0gc2NhbGU7XG5cdFx0dW5pZm9ybXMudV9hbXBsaXR1ZGUgPSBhbXBsaXR1ZGU7XG5cdFx0dW5pZm9ybXMudV9zZWVkID0gc2VlZCAqIDEyODtcblx0XHR1bmlmb3Jtcy51X3ZpZXdwb3J0WzBdID0gdztcblx0XHR1bmlmb3Jtcy51X3ZpZXdwb3J0WzFdID0gaDtcblxuXHRcdC8vcmVuZGVyXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVQZXJsaW4uX3NoYWRlcjtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoVGV4dHVyZVBlcmxpbi5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlUGVybGluLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BlcnNpc3RlbmNlO1xcblxcXG5cdFx0dW5pZm9ybSBpbnQgdV9vY3RhdmVzO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2FtcGxpdHVkZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X3ZpZXdwb3J0O1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3NlZWQ7XFxuXFxcblx0XHQjZGVmaW5lIE1fUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NlxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCByYW5kKHZlYzIgYyl7XHRyZXR1cm4gZnJhY3Qoc2luKGRvdChjLnh5ICx2ZWMyKCAxMi45ODk4ICsgdV9zZWVkLDc4LjIzMyArIHVfc2VlZCkpKSAqIDQzNzU4LjU0NTMpOyB9XFxuXFxcblx0XHRcXG5cXFxuXHRcdGZsb2F0IG5vaXNlKHZlYzIgcCwgZmxvYXQgZnJlcSApe1xcblxcXG5cdFx0XHRmbG9hdCB1bml0ID0gdV92aWV3cG9ydC54L2ZyZXE7XFxuXFxcblx0XHRcdHZlYzIgaWogPSBmbG9vcihwL3VuaXQpO1xcblxcXG5cdFx0XHR2ZWMyIHh5ID0gbW9kKHAsdW5pdCkvdW5pdDtcXG5cXFxuXHRcdFx0Ly94eSA9IDMuKnh5Knh5LTIuKnh5Knh5Knh5O1xcblxcXG5cdFx0XHR4eSA9IC41KigxLi1jb3MoTV9QSSp4eSkpO1xcblxcXG5cdFx0XHRmbG9hdCBhID0gcmFuZCgoaWordmVjMigwLiwwLikpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgYiA9IHJhbmQoKGlqK3ZlYzIoMS4sMC4pKSk7XFxuXFxcblx0XHRcdGZsb2F0IGMgPSByYW5kKChpait2ZWMyKDAuLDEuKSkpO1xcblxcXG5cdFx0XHRmbG9hdCBkID0gcmFuZCgoaWordmVjMigxLiwxLikpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgeDEgPSBtaXgoYSwgYiwgeHkueCk7XFxuXFxcblx0XHRcdGZsb2F0IHgyID0gbWl4KGMsIGQsIHh5LngpO1xcblxcXG5cdFx0XHRyZXR1cm4gbWl4KHgxLCB4MiwgeHkueSk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdGZsb2F0IHBOb2lzZSh2ZWMyIHAsIGludCByZXMpe1xcblxcXG5cdFx0XHRmbG9hdCBwZXJzaXN0YW5jZSA9IHVfcGVyc2lzdGVuY2U7XFxuXFxcblx0XHRcdGZsb2F0IG4gPSAwLjtcXG5cXFxuXHRcdFx0ZmxvYXQgbm9ybUsgPSAwLjtcXG5cXFxuXHRcdFx0ZmxvYXQgZiA9IDQuO1xcblxcXG5cdFx0XHRmbG9hdCBhbXAgPSAxLjA7XFxuXFxcblx0XHRcdGludCBpQ291bnQgPSAwO1xcblxcXG5cdFx0XHRmb3IgKGludCBpID0gMDsgaTw1MDsgaSsrKXtcXG5cXFxuXHRcdFx0XHRuKz1hbXAqbm9pc2UocCwgZik7XFxuXFxcblx0XHRcdFx0Zio9Mi47XFxuXFxcblx0XHRcdFx0bm9ybUsrPWFtcDtcXG5cXFxuXHRcdFx0XHRhbXAqPXBlcnNpc3RhbmNlO1xcblxcXG5cdFx0XHRcdGlmIChpQ291bnQgPj0gcmVzKVxcblxcXG5cdFx0XHRcdFx0YnJlYWs7XFxuXFxcblx0XHRcdFx0aUNvdW50Kys7XFxuXFxcblx0XHRcdH1cXG5cXFxuXHRcdFx0ZmxvYXQgbmYgPSBuL25vcm1LO1xcblxcXG5cdFx0XHRyZXR1cm4gbmYqbmYqbmYqbmY7XFxuXFxcblx0XHR9XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzIgdXYgPSB2X2Nvb3JkICogdV9zY2FsZSAqIHVfdmlld3BvcnQgKyB1X29mZnNldCAqIHVfc2NhbGU7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB2ZWM0KCBwTm9pc2UoIHV2LCB1X29jdGF2ZXMgKSAqIHVfYW1wbGl0dWRlICk7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9wZXJsaW5cIiwgTEdyYXBoVGV4dHVyZVBlcmxpbik7XG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUNhbnZhczJEKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJ2XCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRjb2RlOiBMR3JhcGhUZXh0dXJlQ2FudmFzMkQuZGVmYXVsdF9jb2RlLFxuXHRcdFx0d2lkdGg6IDUxMixcblx0XHRcdGhlaWdodDogNTEyLFxuXHRcdFx0Y2xlYXI6IHRydWUsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVCxcblx0XHRcdHVzZV9odG1sX2NhbnZhczogZmFsc2Vcblx0XHR9O1xuXHRcdHRoaXMuX2Z1bmMgPSBudWxsO1xuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5jb21waWxlQ29kZSgpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELnRpdGxlID0gXCJDYW52YXMyRFwiO1xuXHRMR3JhcGhUZXh0dXJlQ2FudmFzMkQuZGVzYyA9IFwiRXhlY3V0ZXMgQ2FudmFzMkQgY29kZSBpbnNpZGUgYSB0ZXh0dXJlIG9yIHRoZSB2aWV3cG9ydC5cIjtcblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELmhlbHAgPSBcIlNldCB3aWR0aCBhbmQgaGVpZ2h0IHRvIDAgdG8gbWF0Y2ggdmlld3BvcnQgc2l6ZS5cIjtcblxuXHRMR3JhcGhUZXh0dXJlQ2FudmFzMkQuZGVmYXVsdF9jb2RlID0gXCIvL3ZhcnM6IGNhbnZhcyxjdHgsdGltZVxcbmN0eC5maWxsU3R5bGU9J3JlZCc7XFxuY3R4LmZpbGxSZWN0KDAsMCw1MCw1MCk7XFxuXCI7XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9LFxuXHRcdGNvZGU6IHsgdHlwZTogXCJjb2RlXCIgfSxcblx0XHR3aWR0aDogeyB0eXBlOiBcIm51bWJlclwiLCBwcmVjaXNpb246IDAsIHN0ZXA6IDEgfSxcblx0XHRoZWlnaHQ6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ2FudmFzMkQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdGlmIChuYW1lID09IFwiY29kZVwiIClcblx0XHRcdHRoaXMuY29tcGlsZUNvZGUoIHZhbHVlICk7XG5cdH1cblx0XG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC5wcm90b3R5cGUuY29tcGlsZUNvZGUgPSBmdW5jdGlvbiggY29kZSApIHtcblx0XHR0aGlzLl9mdW5jID0gbnVsbDtcblx0XHRpZiggIUxpdGVHcmFwaC5hbGxvd19zY3JpcHRzIClcblx0XHRcdHJldHVybjtcblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9mdW5jID0gbmV3IEZ1bmN0aW9uKCBcImNhbnZhc1wiLCBcImN0eFwiLCBcInRpbWVcIiwgXCJzY3JpcHRcIixcInZcIiwgY29kZSApO1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiIzAwRkYwMFwiO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiI0ZGMDAwMFwiO1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgc2NyaXB0XCIpO1xuXHRcdFx0Y29uc29sZS5lcnJvcihlcnIpO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ2FudmFzMkQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmdW5jID0gdGhpcy5fZnVuYztcblx0XHRpZiAoIWZ1bmMgfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5leGVjdXRlRHJhdyggZnVuYyApO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELnByb3RvdHlwZS5leGVjdXRlRHJhdyA9IGZ1bmN0aW9uKCBmdW5jX2NvbnRleHQgKSB7XG5cblx0XHR2YXIgd2lkdGggPSB0aGlzLnByb3BlcnRpZXMud2lkdGggfHwgZ2wuY2FudmFzLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0IHx8IGdsLmNhbnZhcy5oZWlnaHQ7XG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0dmFyIHR5cGUgPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlKCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uICk7XG5cdFx0aWYgKCF0ZW1wIHx8IHRlbXAud2lkdGggIT0gd2lkdGggfHwgdGVtcC5oZWlnaHQgIT0gaGVpZ2h0IHx8IHRlbXAudHlwZSAhPSB0eXBlICkge1xuXHRcdFx0dGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUixcblx0XHRcdFx0dHlwZTogdHlwZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgdGltZSA9IHRoaXMuZ3JhcGguZ2V0VGltZSgpO1xuXHRcdHZhciBjdHggPSBnbDtcblx0XHR2YXIgY2FudmFzID0gZ2wuY2FudmFzO1xuXHRcdGlmKCB0aGlzLnByb3BlcnRpZXMudXNlX2h0bWxfY2FudmFzIHx8ICFnbG9iYWwuZW5hYmxlV2ViR0xDYW52YXMgKVxuXHRcdHtcblx0XHRcdGlmKCF0aGlzLl9jYW52YXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNhbnZhcyA9IHRoaXMuX2NhbnZhcyA9IGNyZWF0ZUNhbnZhcyh3aWR0aC5oZWlnaHQpO1xuXHRcdFx0XHRjdHggPSB0aGlzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cdFx0XHRcdGN0eCA9IHRoaXMuX2N0eDtcblx0XHRcdH1cblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cblx0XHRpZihjdHggPT0gZ2wpIC8vdXNpbmcgQ2FudmFzMkR0b1dlYkdMXG5cdFx0XHR0ZW1wLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0Z2wuc3RhcnQyRCgpO1xuXHRcdFx0XHRpZihwcm9wZXJ0aWVzLmNsZWFyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Z2wuY2xlYXJDb2xvcigwLDAsMCwwKTtcblx0XHRcdFx0XHRnbC5jbGVhciggZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoZnVuY19jb250ZXh0LmRyYXcpIHtcblx0XHRcdFx0XHRcdGZ1bmNfY29udGV4dC5kcmF3LmNhbGwodGhhdCwgY2FudmFzLCBjdHgsIHRpbWUsIGZ1bmNfY29udGV4dCwgdik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZ1bmNfY29udGV4dC5jYWxsKHRoYXQsIGNhbnZhcywgY3R4LCB0aW1lLCBmdW5jX2NvbnRleHQsdik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoYXQuYm94Y29sb3IgPSBcIiMwMEZGMDBcIjtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0dGhhdC5ib3hjb2xvciA9IFwiI0ZGMDAwMFwiO1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleGVjdXRpbmcgc2NyaXB0XCIpO1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRnbC5maW5pc2gyRCgpO1xuXHRcdFx0fSk7XG5cdFx0ZWxzZSAvL3JlbmRlcmluZyB0byBvZmZzY3JlbiBjYW52YXMgYW5kIHVwbG9hZGluZyB0byB0ZXh0dXJlXG5cdFx0e1xuXHRcdFx0aWYocHJvcGVydGllcy5jbGVhcilcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLDAsY2FudmFzLndpZHRoLGNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoZnVuY19jb250ZXh0LmRyYXcpIHtcblx0XHRcdFx0XHRmdW5jX2NvbnRleHQuZHJhdy5jYWxsKHRoaXMsIGNhbnZhcywgY3R4LCB0aW1lLCBmdW5jX2NvbnRleHQsIHYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZ1bmNfY29udGV4dC5jYWxsKHRoaXMsIGNhbnZhcywgY3R4LCB0aW1lLCBmdW5jX2NvbnRleHQsdik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiIzAwRkYwMFwiO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiNGRjAwMDBcIjtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGV4ZWN1dGluZyBzY3JpcHRcIik7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0XHRcdH1cblx0XHRcdHRlbXAudXBsb2FkSW1hZ2UoIGNhbnZhcyApO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY2FudmFzMkRcIiwgTEdyYXBoVGV4dHVyZUNhbnZhczJEKTtcblxuXHQvLyBUbyBkbyBjaHJvbWEga2V5aW5nICoqKioqKioqKioqKioqKioqXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZU1hdHRlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0a2V5X2NvbG9yOiB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCksXG5cdFx0XHR0aHJlc2hvbGQ6IDAuOCxcblx0XHRcdHNsb3BlOiAwLjIsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlTWF0dGUudGl0bGUgPSBcIk1hdHRlXCI7XG5cdExHcmFwaFRleHR1cmVNYXR0ZS5kZXNjID0gXCJFeHRyYWN0cyBiYWNrZ3JvdW5kXCI7XG5cblx0TEdyYXBoVGV4dHVyZU1hdHRlLndpZGdldHNfaW5mbyA9IHtcblx0XHRrZXlfY29sb3I6IHsgd2lkZ2V0OiBcImNvbG9yXCIgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1hdHRlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcblx0XHRcdHRleCxcblx0XHRcdHRoaXMuX3RleCxcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cblx0XHQpO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdGlmICghdGhpcy5fdW5pZm9ybXMpIHtcblx0XHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHRcdHVfa2V5X2NvbG9yOiB0aGlzLnByb3BlcnRpZXMua2V5X2NvbG9yLFxuXHRcdFx0XHR1X3RocmVzaG9sZDogMSxcblx0XHRcdFx0dV9zbG9wZTogMVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWF0dGUuX3NoYWRlcjtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoVGV4dHVyZU1hdHRlLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVNYXR0ZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMudV9rZXlfY29sb3IgPSB0aGlzLnByb3BlcnRpZXMua2V5X2NvbG9yO1xuXHRcdHVuaWZvcm1zLnVfdGhyZXNob2xkID0gdGhpcy5wcm9wZXJ0aWVzLnRocmVzaG9sZDtcblx0XHR1bmlmb3Jtcy51X3Nsb3BlID0gdGhpcy5wcm9wZXJ0aWVzLnNsb3BlO1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1hdHRlLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMyB1X2tleV9jb2xvcjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV90aHJlc2hvbGQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfc2xvcGU7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMyBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICkueHl6O1xcblxcXG5cdFx0XHRmbG9hdCBkaWZmID0gbGVuZ3RoKCBub3JtYWxpemUoY29sb3IpIC0gbm9ybWFsaXplKHVfa2V5X2NvbG9yKSApO1xcblxcXG5cdFx0XHRmbG9hdCBlZGdlID0gdV90aHJlc2hvbGQgKiAoMS4wIC0gdV9zbG9wZSk7XFxuXFxcblx0XHRcdGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCggZWRnZSwgdV90aHJlc2hvbGQsIGRpZmYpO1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciwgYWxwaGEgKTtcXG5cXFxuXHRcdH1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvbWF0dGVcIiwgTEdyYXBoVGV4dHVyZU1hdHRlKTtcblxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaEN1YmVtYXBUb1RleHR1cmUyRCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJ0ZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJ5YXdcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJ0ZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgeWF3OiAwIH07XG5cdH1cblxuXHRMR3JhcGhDdWJlbWFwVG9UZXh0dXJlMkQudGl0bGUgPSBcIkN1YmVtYXBUb1RleHR1cmUyRFwiO1xuXHRMR3JhcGhDdWJlbWFwVG9UZXh0dXJlMkQuZGVzYyA9IFwiVHJhbnNmb3JtcyBhIENVQkVNQVAgdGV4dHVyZSBpbnRvIGEgVEVYVFVSRTJEIGluIFBvbGFyIFJlcHJlc2VudGF0aW9uXCI7XG5cblx0TEdyYXBoQ3ViZW1hcFRvVGV4dHVyZTJELnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCAhdGV4IHx8IHRleC50ZXh0dXJlX3R5cGUgIT0gR0wuVEVYVFVSRV9DVUJFX01BUCApXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYoIHRoaXMuX2xhc3RfdGV4ICYmICggdGhpcy5fbGFzdF90ZXguaGVpZ2h0ICE9IHRleC5oZWlnaHQgfHwgdGhpcy5fbGFzdF90ZXgudHlwZSAhPSB0ZXgudHlwZSApKVxuXHRcdFx0dGhpcy5fbGFzdF90ZXggPSBudWxsO1xuXHRcdHZhciB5YXcgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInlhd1wiKTtcblx0XHR0aGlzLl9sYXN0X3RleCA9IEdMLlRleHR1cmUuY3ViZW1hcFRvVGV4dHVyZTJEKCB0ZXgsIHRleC5oZWlnaHQsIHRoaXMuX2xhc3RfdGV4LCB0cnVlLCB5YXcgKTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMuX2xhc3RfdGV4ICk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS9jdWJlbWFwVG9UZXh0dXJlMkRcIiwgTEdyYXBoQ3ViZW1hcFRvVGV4dHVyZTJEICk7XG59KSh0aGlzKTtcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG5cclxuICAgIGlmICh0eXBlb2YgR0wgPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdHJldHVybjtcclxuXHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHR2YXIgTEdyYXBoQ2FudmFzID0gZ2xvYmFsLkxHcmFwaENhbnZhcztcclxuXHJcblx0dmFyIFNIQURFUk5PREVTX0NPTE9SID0gXCIjMzQ1XCI7XHJcblxyXG5cdHZhciBMR1NoYWRlcnMgPSBMaXRlR3JhcGguU2hhZGVycyA9IHt9O1xyXG5cclxuXHR2YXIgR0xTTF90eXBlcyA9IExHU2hhZGVycy5HTFNMX3R5cGVzID0gW1wiZmxvYXRcIixcInZlYzJcIixcInZlYzNcIixcInZlYzRcIixcIm1hdDNcIixcIm1hdDRcIixcInNhbXBsZXIyRFwiLFwic2FtcGxlckN1YmVcIl07XHJcblx0dmFyIEdMU0xfdHlwZXNfY29uc3QgPSBMR1NoYWRlcnMuR0xTTF90eXBlc19jb25zdCA9IFtcImZsb2F0XCIsXCJ2ZWMyXCIsXCJ2ZWMzXCIsXCJ2ZWM0XCJdO1xyXG5cclxuXHR2YXIgR0xTTF9mdW5jdGlvbnNfZGVzYyA9IHtcclxuXHRcdFwicmFkaWFuc1wiOiBcIlQgcmFkaWFucyhUIGRlZ3JlZXMpXCIsXHJcblx0XHRcImRlZ3JlZXNcIjogXCJUIGRlZ3JlZXMoVCByYWRpYW5zKVwiLFxyXG5cdFx0XCJzaW5cIjogXCJUIHNpbihUIGFuZ2xlKVwiLFxyXG5cdFx0XCJjb3NcIjogXCJUIGNvcyhUIGFuZ2xlKVwiLFxyXG5cdFx0XCJ0YW5cIjogXCJUIHRhbihUIGFuZ2xlKVwiLFxyXG5cdFx0XCJhc2luXCI6IFwiVCBhc2luKFQgeClcIixcclxuXHRcdFwiYWNvc1wiOiBcIlQgYWNvcyhUIHgpXCIsXHJcblx0XHRcImF0YW5cIjogXCJUIGF0YW4oVCB4KVwiLFxyXG5cdFx0XCJhdGFuMlwiOiBcIlQgYXRhbihUIHgsVCB5KVwiLFxyXG5cdFx0XCJwb3dcIjogXCJUIHBvdyhUIHgsVCB5KVwiLFxyXG5cdFx0XCJleHBcIjogXCJUIGV4cChUIHgpXCIsXHJcblx0XHRcImxvZ1wiOiBcIlQgbG9nKFQgeClcIixcclxuXHRcdFwiZXhwMlwiOiBcIlQgZXhwMihUIHgpXCIsXHJcblx0XHRcImxvZzJcIjogXCJUIGxvZzIoVCB4KVwiLFxyXG5cdFx0XCJzcXJ0XCI6IFwiVCBzcXJ0KFQgeClcIixcclxuXHRcdFwiaW52ZXJzZXNxcnRcIjogXCJUIGludmVyc2VzcXJ0KFQgeClcIixcclxuXHRcdFwiYWJzXCI6IFwiVCBhYnMoVCB4KVwiLFxyXG5cdFx0XCJzaWduXCI6IFwiVCBzaWduKFQgeClcIixcclxuXHRcdFwiZmxvb3JcIjogXCJUIGZsb29yKFQgeClcIixcclxuXHRcdFwicm91bmRcIjogXCJUIHJvdW5kKFQgeClcIixcclxuXHRcdFwiY2VpbFwiOiBcIlQgY2VpbChUIHgpXCIsXHJcblx0XHRcImZyYWN0XCI6IFwiVCBmcmFjdChUIHgpXCIsXHJcblx0XHRcIm1vZFwiOiBcIlQgbW9kKFQgeCxUIHkpXCIsIC8vXCJUIG1vZChUIHgsZmxvYXQgeSlcIlxyXG5cdFx0XCJtaW5cIjogXCJUIG1pbihUIHgsVCB5KVwiLFxyXG5cdFx0XCJtYXhcIjogXCJUIG1heChUIHgsVCB5KVwiLFxyXG5cdFx0XCJjbGFtcFwiOiBcIlQgY2xhbXAoVCB4LFQgbWluVmFsID0gMC4wLFQgbWF4VmFsID0gMS4wKVwiLFxyXG5cdFx0XCJtaXhcIjogXCJUIG1peChUIHgsVCB5LFQgYSlcIiwgLy9cIlQgbWl4KFQgeCxUIHksZmxvYXQgYSlcIlxyXG5cdFx0XCJzdGVwXCI6IFwiVCBzdGVwKFQgZWRnZSwgVCBlZGdlMiwgVCB4KVwiLCAvL1wiVCBzdGVwKGZsb2F0IGVkZ2UsIFQgeClcIlxyXG5cdFx0XCJzbW9vdGhzdGVwXCI6IFwiVCBzbW9vdGhzdGVwKFQgZWRnZSwgVCBlZGdlMiwgVCB4KVwiLCAvL1wiVCBzbW9vdGhzdGVwKGZsb2F0IGVkZ2UsIFQgeClcIlxyXG5cdFx0XCJsZW5ndGhcIjpcImZsb2F0IGxlbmd0aChUIHgpXCIsXHJcblx0XHRcImRpc3RhbmNlXCI6XCJmbG9hdCBkaXN0YW5jZShUIHAwLCBUIHAxKVwiLFxyXG5cdFx0XCJub3JtYWxpemVcIjpcIlQgbm9ybWFsaXplKFQgeClcIixcclxuXHRcdFwiZG90XCI6IFwiZmxvYXQgZG90KFQgeCxUIHkpXCIsXHJcblx0XHRcImNyb3NzXCI6IFwidmVjMyBjcm9zcyh2ZWMzIHgsdmVjMyB5KVwiLFxyXG5cdFx0XCJyZWZsZWN0XCI6IFwidmVjMyByZWZsZWN0KHZlYzMgVix2ZWMzIE4pXCIsXHJcblx0XHRcInJlZnJhY3RcIjogXCJ2ZWMzIHJlZnJhY3QodmVjMyBWLHZlYzMgTiwgZmxvYXQgSU9SKVwiXHJcblx0fTtcclxuXHJcblx0Ly9wYXJzZSB0aGVtXHJcblx0dmFyIEdMU0xfZnVuY3Rpb25zID0ge307XHJcblx0dmFyIEdMU0xfZnVuY3Rpb25zX25hbWUgPSBbXTtcclxuXHRwYXJzZUdMU0xEZXNjcmlwdGlvbnMoKTtcclxuXHJcblx0TEdTaGFkZXJzLkFMTF9UWVBFUyA9IFwiZmxvYXQsdmVjMix2ZWMzLHZlYzRcIjtcclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VHTFNMRGVzY3JpcHRpb25zKClcclxuXHR7XHJcblx0XHRHTFNMX2Z1bmN0aW9uc19uYW1lLmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0Zm9yKHZhciBpIGluIEdMU0xfZnVuY3Rpb25zX2Rlc2MpXHJcblx0XHR7XHJcblx0XHRcdHZhciBvcCA9IEdMU0xfZnVuY3Rpb25zX2Rlc2NbaV07XHJcblx0XHRcdHZhciBpbmRleCA9IG9wLmluZGV4T2YoXCIgXCIpO1xyXG5cdFx0XHR2YXIgcmV0dXJuX3R5cGUgPSBvcC5zdWJzdHIoMCxpbmRleCk7XHJcblx0XHRcdHZhciBpbmRleDIgPSBvcC5pbmRleE9mKFwiKFwiLGluZGV4KTtcclxuXHRcdFx0dmFyIGZ1bmNfbmFtZSA9IG9wLnN1YnN0cihpbmRleCxpbmRleDItaW5kZXgpLnRyaW0oKTtcclxuXHRcdFx0dmFyIHBhcmFtcyA9IG9wLnN1YnN0cihpbmRleDIgKyAxLCBvcC5sZW5ndGggLSBpbmRleDIgLSAyKS5zcGxpdChcIixcIik7XHJcblx0XHRcdGZvcih2YXIgaiBpbiBwYXJhbXMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgcCA9IHBhcmFtc1tqXS5zcGxpdChcIiBcIikuZmlsdGVyKGZ1bmN0aW9uKGEpeyByZXR1cm4gYTsgfSk7XHJcblx0XHRcdFx0cGFyYW1zW2pdID0geyB0eXBlOiBwWzBdLnRyaW0oKSwgbmFtZTogcFsxXS50cmltKCkgfTtcclxuXHRcdFx0XHRpZihwWzJdID09IFwiPVwiKVxyXG5cdFx0XHRcdFx0cGFyYW1zW2pdLnZhbHVlID0gcFszXS50cmltKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0R0xTTF9mdW5jdGlvbnNbaV0gPSB7IHJldHVybl90eXBlOiByZXR1cm5fdHlwZSwgZnVuYzogZnVuY19uYW1lLCBwYXJhbXM6IHBhcmFtcyB9O1xyXG5cdFx0XHRHTFNMX2Z1bmN0aW9uc19uYW1lLnB1c2goIGZ1bmNfbmFtZSApO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCBHTFNMX2Z1bmN0aW9uc1tpXSApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly9jb21tb24gYWN0aW9ucyB0byBhbGwgc2hhZGVyIG5vZGUgY2xhc3Nlc1xyXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyU2hhZGVyTm9kZSggdHlwZSwgbm9kZV9jdG9yIClcclxuXHR7XHJcblx0XHQvL3N0YXRpYyBhdHRyaWJ1dGVzXHJcblx0XHRub2RlX2N0b3IuY29sb3IgPSBTSEFERVJOT0RFU19DT0xPUjtcclxuXHRcdG5vZGVfY3Rvci5maWx0ZXIgPSBcInNoYWRlclwiO1xyXG5cclxuXHRcdC8vY29tbW9uIG1ldGhvZHNcclxuXHRcdG5vZGVfY3Rvci5wcm90b3R5cGUuY2xlYXJEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uKCl7IHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uID0ge307ICB9XHJcblx0XHRub2RlX2N0b3IucHJvdG90eXBlLnByb3BhZ2F0ZURlc3RpbmF0aW9uID0gZnVuY3Rpb24gcHJvcGFnYXRlRGVzdGluYXRpb24oIGRlc3RfbmFtZSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uWyBkZXN0X25hbWUgXSA9IHRydWU7XHJcblx0XHRcdGlmKHRoaXMuaW5wdXRzKVxyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgb3JpZ2luX25vZGUgPSB0aGlzLmdldElucHV0Tm9kZShpKTtcclxuXHRcdFx0XHRpZihvcmlnaW5fbm9kZSlcclxuXHRcdFx0XHRcdG9yaWdpbl9ub2RlLnByb3BhZ2F0ZURlc3RpbmF0aW9uKCBkZXN0X25hbWUgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYoIW5vZGVfY3Rvci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQpXHJcblx0XHRcdG5vZGVfY3Rvci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbigpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHRcdFx0IHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdC8qXHJcblx0XHRpZighbm9kZV9jdG9yLnByb3RvdHlwZS5vbkdldENvZGUpXHJcblx0XHRcdG5vZGVfY3Rvci5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly9jaGVjayBkZXN0aW5hdGlvbiB0byBhdm9pZCBsb25lbHkgbm9kZXNcclxuXHRcdFx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0Ly9ncmFiIGlucHV0cyB3aXRoIHR5cGVzXHJcblx0XHRcdFx0dmFyIGlucHV0cyA9IFtdO1xyXG5cdFx0XHRcdGlmKHRoaXMuaW5wdXRzKVxyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSlcclxuXHRcdFx0XHRcdGlucHV0cy5wdXNoKHsgdHlwZTogdGhpcy5nZXRJbnB1dERhdGEoaSksIG5hbWU6IGdldElucHV0TGlua0lEKHRoaXMsaSkgfSk7XHJcblx0XHRcdFx0dmFyIG91dHB1dHMgPSBbXTtcclxuXHRcdFx0XHRpZih0aGlzLm91dHB1dHMpXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSlcclxuXHRcdFx0XHRcdG91dHB1dHMucHVzaCh7IG5hbWU6IGdldE91dHB1dExpbmtJRCh0aGlzLGkpIH0pO1xyXG5cdFx0XHRcdC8vcGFzcyB0byBjb2RlIGZ1bmNcclxuXHRcdFx0XHR2YXIgcmVzdWx0cyA9IHRoaXMuZXh0cmFjdENvZGUoaW5wdXRzKTtcclxuXHRcdFx0XHQvL2dyYWIgb3V0cHV0LCBwYXNzIHRvIG5leHRcclxuXHRcdFx0XHRpZihyZXN1bHRzKVxyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciByID0gcmVzdWx0c1tpXTtcclxuXHRcdFx0XHRcdGlmKCFyKVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YShpLHIudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0Ki9cclxuXHJcblx0XHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJzaGFkZXI6OlwiICsgdHlwZSwgbm9kZV9jdG9yICk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRTaGFkZXJOb2RlVmFyTmFtZSggbm9kZSwgbmFtZSApXHJcblx0e1xyXG5cdFx0cmV0dXJuIFwiVkFSX1wiICsgKG5hbWUgfHwgXCJURU1QXCIpICsgXCJfXCIgKyBub2RlLmlkO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0SW5wdXRMaW5rSUQoIG5vZGUsIHNsb3QgKVxyXG5cdHtcclxuXHRcdGlmKCFub2RlLmlucHV0cylcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR2YXIgbGluayA9IG5vZGUuZ2V0SW5wdXRMaW5rKCBzbG90ICk7XHJcblx0XHRpZiggIWxpbmsgKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBvcmlnaW5fbm9kZSA9IG5vZGUuZ3JhcGguZ2V0Tm9kZUJ5SWQoIGxpbmsub3JpZ2luX2lkICk7XHJcblx0XHRpZiggIW9yaWdpbl9ub2RlIClcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRpZihvcmlnaW5fbm9kZS5nZXRPdXRwdXRWYXJOYW1lKVxyXG5cdFx0XHRyZXR1cm4gb3JpZ2luX25vZGUuZ2V0T3V0cHV0VmFyTmFtZShsaW5rLm9yaWdpbl9zbG90KTtcclxuXHRcdC8vZ2VuZXJhdGVcclxuXHRcdHJldHVybiBcImxpbmtfXCIgKyBvcmlnaW5fbm9kZS5pZCArIFwiX1wiICsgbGluay5vcmlnaW5fc2xvdDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE91dHB1dExpbmtJRCggbm9kZSwgc2xvdCApXHJcblx0e1xyXG5cdFx0aWYgKCFub2RlLmlzT3V0cHV0Q29ubmVjdGVkKHNsb3QpKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHJldHVybiBcImxpbmtfXCIgKyBub2RlLmlkICsgXCJfXCIgKyBzbG90O1xyXG5cdH1cclxuXHJcblx0TEdTaGFkZXJzLnJlZ2lzdGVyU2hhZGVyTm9kZSA9IHJlZ2lzdGVyU2hhZGVyTm9kZTtcclxuXHRMR1NoYWRlcnMuZ2V0SW5wdXRMaW5rSUQgPSBnZXRJbnB1dExpbmtJRDtcclxuXHRMR1NoYWRlcnMuZ2V0T3V0cHV0TGlua0lEID0gZ2V0T3V0cHV0TGlua0lEO1xyXG5cdExHU2hhZGVycy5nZXRTaGFkZXJOb2RlVmFyTmFtZSA9IGdldFNoYWRlck5vZGVWYXJOYW1lO1xyXG5cdExHU2hhZGVycy5wYXJzZUdMU0xEZXNjcmlwdGlvbnMgPSBwYXJzZUdMU0xEZXNjcmlwdGlvbnM7XHJcblxyXG5cdC8vZ2l2ZW4gYSBjb25zdCBudW1iZXIsIGl0IHRyYW5zZm9ybSBpdCB0byBhIHN0cmluZyB0aGF0IG1hdGNoZXMgYSB0eXBlXHJcblx0dmFyIHZhbHVlVG9HTFNMID0gTGl0ZUdyYXBoLnZhbHVlVG9HTFNMID0gZnVuY3Rpb24gdmFsdWVUb0dMU0woIHYsIHR5cGUsIHByZWNpc2lvbiApXHJcblx0e1xyXG5cdFx0dmFyIG4gPSA1OyAvL251bSBkZWNpbWFsc1xyXG5cdFx0aWYocHJlY2lzaW9uICE9IG51bGwpXHJcblx0XHRcdG4gPSBwcmVjaXNpb247XHJcblx0XHRpZighdHlwZSlcclxuXHRcdHtcclxuXHRcdFx0aWYodi5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKVxyXG5cdFx0XHRcdHR5cGUgPSBcImZsb2F0XCI7XHJcblx0XHRcdGVsc2UgaWYodi5sZW5ndGgpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzd2l0Y2godi5sZW5ndGgpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Y2FzZSAyOiB0eXBlID0gXCJ2ZWMyXCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAzOiB0eXBlID0gXCJ2ZWMzXCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSA0OiB0eXBlID0gXCJ2ZWM0XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSA5OiB0eXBlID0gXCJtYXQzXCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAxNjogdHlwZSA9IFwibWF0NFwiOyBicmVhaztcclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdHRocm93KFwidW5rbm93biB0eXBlIGZvciBnbHNsIHZhbHVlIHNpemVcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aHJvdyhcInVua25vd24gdHlwZSBmb3IgZ2xzbCB2YWx1ZTogXCIgKyB2LmNvbnN0cnVjdG9yKTtcclxuXHRcdH1cclxuXHRcdHN3aXRjaCh0eXBlKVxyXG5cdFx0e1xyXG5cdFx0XHRjYXNlICdmbG9hdCc6IHJldHVybiB2LnRvRml4ZWQobik7IGJyZWFrO1xyXG5cdFx0XHRjYXNlICd2ZWMyJzogcmV0dXJuIFwidmVjMihcIiArIHZbMF0udG9GaXhlZChuKSArIFwiLFwiICsgdlsxXS50b0ZpeGVkKG4pICsgXCIpXCI7IGJyZWFrO1xyXG5cdFx0XHRjYXNlICdjb2xvcjMnOlxyXG5cdFx0XHRjYXNlICd2ZWMzJzogcmV0dXJuIFwidmVjMyhcIiArIHZbMF0udG9GaXhlZChuKSArIFwiLFwiICsgdlsxXS50b0ZpeGVkKG4pICsgXCIsXCIgKyB2WzJdLnRvRml4ZWQobikgKyBcIilcIjsgYnJlYWs7XHJcblx0XHRcdGNhc2UgJ2NvbG9yNCc6XHJcblx0XHRcdGNhc2UgJ3ZlYzQnOiByZXR1cm4gXCJ2ZWM0KFwiICsgdlswXS50b0ZpeGVkKG4pICsgXCIsXCIgKyB2WzFdLnRvRml4ZWQobikgKyBcIixcIiArIHZbMl0udG9GaXhlZChuKSArIFwiLFwiICsgdlszXS50b0ZpeGVkKG4pICsgXCIpXCI7IGJyZWFrO1xyXG5cdFx0XHRjYXNlICdtYXQzJzogcmV0dXJuIFwibWF0MygxLjAsMC4wLDAuMCwwLjAsMS4wLDAuMCwwLjAsMC4wLDEuMClcIjsgYnJlYWs7IC8vbm90IGZ1bGx5IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0Y2FzZSAnbWF0NCc6IHJldHVybiBcIm1hdDQoMS4wLDAuMCwwLjAsMC4wLDAuMCwxLjAsMC4wLDAuMCwwLjAsMC4wLDAuMCwxLjAsMC4wLDAuMCwwLjAsMC4wLDEuMClcIjsgYnJlYWs7Ly9ub3QgZnVsbHkgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93KFwidW5rbm93biBnbHNsIHR5cGUgaW4gdmFsdWVUb0dMU0w6XCIsIHR5cGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBcIlwiO1xyXG5cdH1cclxuXHJcblx0Ly9tYWtlcyBzdXJlIHRoYXQgYSB2YXIgaXMgb2YgYSB0eXBlLCBhbmQgaWYgbm90LCBpdCBjb252ZXJ0cyBpdFxyXG5cdHZhciB2YXJUb1R5cGVHTFNMID0gTGl0ZUdyYXBoLnZhclRvVHlwZUdMU0wgPSBmdW5jdGlvbiB2YXJUb1R5cGVHTFNMKCB2LCBpbnB1dF90eXBlLCBvdXRwdXRfdHlwZSApXHJcblx0e1xyXG5cdFx0aWYoaW5wdXRfdHlwZSA9PSBvdXRwdXRfdHlwZSlcclxuXHRcdFx0cmV0dXJuIHY7XHJcblx0XHRpZih2ID09IG51bGwpXHJcblx0XHRcdHN3aXRjaChvdXRwdXRfdHlwZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNhc2UgXCJmbG9hdFwiOiByZXR1cm4gXCIwLjBcIjtcclxuXHRcdFx0XHRjYXNlIFwidmVjMlwiOiAgcmV0dXJuIFwidmVjMigwLjApXCI7XHJcblx0XHRcdFx0Y2FzZSBcInZlYzNcIjogIHJldHVybiBcInZlYzMoMC4wKVwiO1xyXG5cdFx0XHRcdGNhc2UgXCJ2ZWM0XCI6ICByZXR1cm4gXCJ2ZWM0KDAuMCwwLjAsMC4wLDEuMClcIjtcclxuXHRcdFx0XHRkZWZhdWx0OiAvL251bGxcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0aWYoIW91dHB1dF90eXBlKVxyXG5cdFx0XHR0aHJvdyhcImVycm9yOiBubyBvdXRwdXQgdHlwZSBzcGVjaWZpZWRcIik7XHJcblx0XHRpZihvdXRwdXRfdHlwZSA9PSBcImZsb2F0XCIpXHJcblx0XHR7XHJcblx0XHRcdHN3aXRjaChpbnB1dF90eXBlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly9jYXNlIFwiZmxvYXRcIjpcclxuXHRcdFx0XHRjYXNlIFwidmVjMlwiOlxyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMzXCI6XHJcblx0XHRcdFx0Y2FzZSBcInZlYzRcIjpcclxuXHRcdFx0XHRcdHJldHVybiB2ICsgXCIueFwiO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDogLy9udWxsXHJcblx0XHRcdFx0XHRyZXR1cm4gXCIwLjBcIjtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKG91dHB1dF90eXBlID09IFwidmVjMlwiKVxyXG5cdFx0e1xyXG5cdFx0XHRzd2l0Y2goaW5wdXRfdHlwZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNhc2UgXCJmbG9hdFwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjMihcIit2K1wiKVwiO1xyXG5cdFx0XHRcdC8vY2FzZSBcInZlYzJcIjpcclxuXHRcdFx0XHRjYXNlIFwidmVjM1wiOlxyXG5cdFx0XHRcdGNhc2UgXCJ2ZWM0XCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gdiArIFwiLnh5XCI7XHJcblx0XHRcdFx0ZGVmYXVsdDogLy9udWxsXHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWMyKDAuMClcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihvdXRwdXRfdHlwZSA9PSBcInZlYzNcIilcclxuXHRcdHtcclxuXHRcdFx0c3dpdGNoKGlucHV0X3R5cGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjYXNlIFwiZmxvYXRcIjpcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzMoXCIrditcIilcIjtcclxuXHRcdFx0XHRjYXNlIFwidmVjMlwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjMyhcIiArIHYgKyBcIiwwLjApXCI7XHJcblx0XHRcdFx0Ly9jYXNlIFwidmVjM1wiOlxyXG5cdFx0XHRcdGNhc2UgXCJ2ZWM0XCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gdiArIFwiLnh5elwiO1xyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vbnVsbFxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjMygwLjApXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYob3V0cHV0X3R5cGUgPT0gXCJ2ZWM0XCIpXHJcblx0XHR7XHJcblx0XHRcdHN3aXRjaChpbnB1dF90eXBlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y2FzZSBcImZsb2F0XCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KFwiK3YrXCIpXCI7XHJcblx0XHRcdFx0Y2FzZSBcInZlYzJcIjpcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzQoXCIgKyB2ICsgXCIsMC4wLDEuMClcIjtcclxuXHRcdFx0XHRjYXNlIFwidmVjM1wiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjNChcIiArIHYgKyBcIiwxLjApXCI7XHJcblx0XHRcdFx0ZGVmYXVsdDogLy9udWxsXHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KDAuMCwwLjAsMC4wLDEuMClcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhyb3coXCJ0eXBlIGNhbm5vdCBiZSBjb252ZXJ0ZWRcIik7XHJcblx0fVxyXG5cclxuXHJcblx0Ly91c2VkIHRvIHBsdWcgaW5jb21wYXRpYmxlIHN0dWZmXHJcblx0dmFyIGNvbnZlcnRWYXJUb0dMU0xUeXBlID0gTGl0ZUdyYXBoLmNvbnZlcnRWYXJUb0dMU0xUeXBlID0gZnVuY3Rpb24gY29udmVydFZhclRvR0xTTFR5cGUoIHZhcm5hbWUsIHR5cGUsIHRhcmdldF90eXBlIClcclxuXHR7XHJcblx0XHRpZih0eXBlID09IHRhcmdldF90eXBlKVxyXG5cdFx0XHRyZXR1cm4gdmFybmFtZTtcclxuXHRcdGlmKHR5cGUgPT0gXCJmbG9hdFwiKVxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0X3R5cGUgKyBcIihcIiArIHZhcm5hbWUgKyBcIilcIjtcclxuXHRcdGlmKHRhcmdldF90eXBlID09IFwidmVjMlwiKSAvL3dvcmtzIGZvciB2ZWMyLHZlYzMgYW5kIHZlYzRcclxuXHRcdFx0cmV0dXJuIFwidmVjMihcIiArIHZhcm5hbWUgKyBcIi54eSlcIjtcclxuXHRcdGlmKHRhcmdldF90eXBlID09IFwidmVjM1wiKSAvL3dvcmtzIGZvciB2ZWMyLHZlYzMgYW5kIHZlYzRcclxuXHRcdHtcclxuXHRcdFx0aWYodHlwZSA9PSBcInZlYzJcIilcclxuXHRcdFx0XHRyZXR1cm4gXCJ2ZWMzKFwiICsgdmFybmFtZSArIFwiLDAuMClcIjtcclxuXHRcdFx0aWYodHlwZSA9PSBcInZlYzRcIilcclxuXHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KFwiICsgdmFybmFtZSArIFwiLnh5eilcIjtcclxuXHRcdH1cclxuXHRcdGlmKHRhcmdldF90eXBlID09IFwidmVjNFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRpZih0eXBlID09IFwidmVjMlwiKVxyXG5cdFx0XHRcdHJldHVybiBcInZlYzQoXCIgKyB2YXJuYW1lICsgXCIsMC4wLDAuMClcIjtcclxuXHRcdFx0aWYodGFyZ2V0X3R5cGUgPT0gXCJ2ZWMzXCIpXHJcblx0XHRcdFx0cmV0dXJuIFwidmVjNChcIiArIHZhcm5hbWUgKyBcIiwxLjApXCI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8vdXNlZCB0byBob3N0IGEgc2hhZGVyIGJvZHkgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRmdW5jdGlvbiBMR1NoYWRlckNvbnRleHQoKVxyXG5cdHtcclxuXHRcdC8vdG8gc3RvcmUgdGhlIGNvZGUgdGVtcGxhdGVcclxuXHRcdHRoaXMudnNfdGVtcGxhdGUgPSBcIlwiO1xyXG5cdFx0dGhpcy5mc190ZW1wbGF0ZSA9IFwiXCI7XHJcblxyXG5cdFx0Ly9yZXF1aXJlZCBzbyBub2RlcyBub3cgd2hlcmUgdG8gZmV0Y2ggdGhlIGlucHV0IGRhdGFcclxuXHRcdHRoaXMuYnVmZmVyX25hbWVzID0ge1xyXG5cdFx0XHR1dnM6IFwidl9jb29yZFwiXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZXh0cmEgPSB7fTsgLy90byBzdG9yZSBjdXN0b20gaW5mbyBmcm9tIHRoZSBub2RlcyAobGlrZSBpZiB0aGlzIHNoYWRlciBzdXBwb3J0cyBhIGZlYXR1cmUsIGV0YylcclxuXHJcblx0XHR0aGlzLl9mdW5jdGlvbnMgPSB7fTtcclxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge307XHJcblx0XHR0aGlzLl9jb2RlcGFydHMgPSB7fTtcclxuXHRcdHRoaXMuX3VuaWZvcm1fdmFsdWUgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR0aGlzLl91bmlmb3JtcyA9IHt9O1xyXG5cdFx0dGhpcy5fZnVuY3Rpb25zID0ge307XHJcblx0XHR0aGlzLl9jb2RlcGFydHMgPSB7fTtcclxuXHRcdHRoaXMuX3VuaWZvcm1fdmFsdWUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZXh0cmEgPSB7fTtcclxuXHR9XHJcblxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuYWRkVW5pZm9ybSA9IGZ1bmN0aW9uKCBuYW1lLCB0eXBlLCB2YWx1ZSApXHJcblx0e1xyXG5cdFx0dGhpcy5fdW5pZm9ybXNbIG5hbWUgXSA9IHR5cGU7XHJcblx0XHRpZih2YWx1ZSAhPSBudWxsKVxyXG5cdFx0e1xyXG5cdFx0XHRpZighdGhpcy5fdW5pZm9ybV92YWx1ZSlcclxuXHRcdFx0XHR0aGlzLl91bmlmb3JtX3ZhbHVlID0ge307XHJcblx0XHRcdHRoaXMuX3VuaWZvcm1fdmFsdWVbbmFtZV0gPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuYWRkRnVuY3Rpb24gPSBmdW5jdGlvbiggbmFtZSwgY29kZSApXHJcblx0e1xyXG5cdFx0dGhpcy5fZnVuY3Rpb25zW25hbWVdID0gY29kZTtcclxuXHR9XHJcblxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuYWRkQ29kZSA9IGZ1bmN0aW9uKCBob29rLCBjb2RlLCBkZXN0aW5hdGlvbnMgKVxyXG5cdHtcclxuXHRcdGRlc3RpbmF0aW9ucyA9IGRlc3RpbmF0aW9ucyB8fCB7XCJcIjpcIlwifTtcclxuXHRcdGZvcih2YXIgaSBpbiBkZXN0aW5hdGlvbnMpXHJcblx0XHR7XHJcblx0XHRcdHZhciBoID0gaSA/IGkgKyBcIl9cIiArIGhvb2sgOiBob29rO1xyXG5cdFx0XHRpZighdGhpcy5fY29kZXBhcnRzWyBoIF0pXHJcblx0XHRcdFx0dGhpcy5fY29kZXBhcnRzWyBoIF0gPSBjb2RlICsgXCJcXG5cIjtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRoaXMuX2NvZGVwYXJ0c1sgaCBdICs9IGNvZGUgKyBcIlxcblwiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly90aGUgc3lzdGVtIHdvcmtzIGJ5IGdyYWJiaW5nIGNvZGUgZnJhZ21lbnRzIGZyb20gZXZlcnkgbm9kZSBhbmQgY29uY2F0ZW5hdGluZyB0aGVtIGluIGJsb2NrcyBkZXBlbmRpbmcgb24gd2hlcmUgbXVzdCB0aGV5IGJlIGF0dGFjaGVkXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5jb21wdXRlQ29kZUJsb2NrcyA9IGZ1bmN0aW9uKCBncmFwaCwgZXh0cmFfdW5pZm9ybXMgKVxyXG5cdHtcclxuXHRcdC8vcHJlcGFyZSBjb250ZXh0XHJcblx0XHR0aGlzLmNsZWFyKCk7XHJcblxyXG5cdFx0Ly9ncmFiIG91dHB1dCBub2Rlc1xyXG5cdFx0dmFyIHZlcnRleG91dCA9IGdyYXBoLmZpbmROb2Rlc0J5VHlwZShcInNoYWRlcjo6b3V0cHV0L3ZlcnRleFwiKTtcclxuXHRcdHZlcnRleG91dCA9IHZlcnRleG91dCAmJiB2ZXJ0ZXhvdXQubGVuZ3RoID8gdmVydGV4b3V0WzBdIDogbnVsbDtcclxuXHRcdHZhciBmcmFnbWVudG91dCA9IGdyYXBoLmZpbmROb2Rlc0J5VHlwZShcInNoYWRlcjo6b3V0cHV0L2ZyYWdjb2xvclwiKTtcclxuXHRcdGZyYWdtZW50b3V0ID0gZnJhZ21lbnRvdXQgJiYgZnJhZ21lbnRvdXQubGVuZ3RoID8gZnJhZ21lbnRvdXRbMF0gOiBudWxsO1xyXG5cdFx0aWYoIWZyYWdtZW50b3V0KSAvLz8/XHJcblx0XHRcdHJldHVybiBudWxsOyBcclxuXHJcblx0XHQvL3Byb3BhZ2F0ZSBiYWNrIGRlc3RpbmF0aW9uc1xyXG5cdFx0Z3JhcGguc2VuZEV2ZW50VG9BbGxOb2RlcyggXCJjbGVhckRlc3RpbmF0aW9uXCIgKTtcclxuXHRcdGlmKHZlcnRleG91dClcclxuXHRcdFx0dmVydGV4b3V0LnByb3BhZ2F0ZURlc3RpbmF0aW9uKFwidnNcIik7XHJcblx0XHRpZihmcmFnbWVudG91dClcclxuXHRcdFx0ZnJhZ21lbnRvdXQucHJvcGFnYXRlRGVzdGluYXRpb24oXCJmc1wiKTtcclxuXHJcblx0XHQvL2dldHMgY29kZSBmcm9tIGdyYXBoXHJcblx0XHRncmFwaC5zZW5kRXZlbnRUb0FsbE5vZGVzKFwib25HZXRDb2RlXCIsIHRoaXMgKTtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXMgPSBcIlwiO1xyXG5cdFx0Zm9yKHZhciBpIGluIHRoaXMuX3VuaWZvcm1zKVxyXG5cdFx0XHR1bmlmb3JtcyArPSBcInVuaWZvcm0gXCIgKyB0aGlzLl91bmlmb3Jtc1tpXSArIFwiIFwiICsgaSArIFwiO1xcblwiO1xyXG5cdFx0aWYoZXh0cmFfdW5pZm9ybXMpXHJcblx0XHRcdGZvcih2YXIgaSBpbiBleHRyYV91bmlmb3JtcylcclxuXHRcdFx0XHR1bmlmb3JtcyArPSBcInVuaWZvcm0gXCIgKyBleHRyYV91bmlmb3Jtc1tpXSArIFwiIFwiICsgaSArIFwiO1xcblwiO1xyXG5cclxuXHRcdHZhciBmdW5jdGlvbnMgPSBcIlwiO1xyXG5cdFx0Zm9yKHZhciBpIGluIHRoaXMuX2Z1bmN0aW9ucylcclxuXHRcdFx0ZnVuY3Rpb25zICs9IFwiLy9cIiArIGkgKyBcIlxcblwiICsgdGhpcy5fZnVuY3Rpb25zW2ldICsgXCJcXG5cIjtcclxuXHJcblx0XHR2YXIgYmxvY2tzID0gdGhpcy5fY29kZXBhcnRzO1xyXG5cdFx0YmxvY2tzLnVuaWZvcm1zID0gdW5pZm9ybXM7XHJcblx0XHRibG9ja3MuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xyXG5cdFx0cmV0dXJuIGJsb2NrcztcclxuXHR9XHJcblxyXG5cdC8vcmVwbGFjZXMgYmxvY2tzIHVzaW5nIHRoZSB2cyBhbmQgZnMgdGVtcGxhdGUgYW5kIHJldHVybnMgdGhlIGZpbmFsIGNvZGVzXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5jb21wdXRlU2hhZGVyQ29kZSA9IGZ1bmN0aW9uKCBncmFwaCApXHJcblx0e1xyXG5cdFx0dmFyIGJsb2NrcyA9IHRoaXMuY29tcHV0ZUNvZGVCbG9ja3MoIGdyYXBoICk7XHJcblx0XHR2YXIgdnNfY29kZSA9IEdMLlNoYWRlci5yZXBsYWNlQ29kZVVzaW5nQ29udGV4dCggdGhpcy52c190ZW1wbGF0ZSwgYmxvY2tzICk7XHJcblx0XHR2YXIgZnNfY29kZSA9IEdMLlNoYWRlci5yZXBsYWNlQ29kZVVzaW5nQ29udGV4dCggdGhpcy5mc190ZW1wbGF0ZSwgYmxvY2tzICk7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR2c19jb2RlOiB2c19jb2RlLFxyXG5cdFx0XHRmc19jb2RlOiBmc19jb2RlXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Ly9nZW5lcmF0ZXMgdGhlIHNoYWRlciBjb2RlIGZyb20gdGhlIHRlbXBsYXRlIGFuZCB0aGUgXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5jb21wdXRlU2hhZGVyID0gZnVuY3Rpb24oIGdyYXBoLCBzaGFkZXIgKVxyXG5cdHtcclxuXHRcdHZhciBmaW5hbGNvZGUgPSB0aGlzLmNvbXB1dGVTaGFkZXJDb2RlKCBncmFwaCApO1xyXG5cdFx0Y29uc29sZS5sb2coIGZpbmFsY29kZS52c19jb2RlLCBmaW5hbGNvZGUuZnNfY29kZSApO1xyXG5cclxuXHRcdGlmKCFMaXRlR3JhcGguY2F0Y2hfZXhjZXB0aW9ucylcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5fc2hhZGVyX2Vycm9yID0gdHJ1ZTtcclxuXHRcdFx0aWYoc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlci51cGRhdGVTaGFkZXIoIGZpbmFsY29kZS52c19jb2RlLCBmaW5hbGNvZGUuZnNfY29kZSApO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0c2hhZGVyID0gbmV3IEdMLlNoYWRlciggZmluYWxjb2RlLnZzX2NvZGUsIGZpbmFsY29kZS5mc19jb2RlICk7XHJcblx0XHRcdHRoaXMuX3NoYWRlcl9lcnJvciA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeVxyXG5cdFx0e1xyXG5cdFx0XHRpZihzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyLnVwZGF0ZVNoYWRlciggZmluYWxjb2RlLnZzX2NvZGUsIGZpbmFsY29kZS5mc19jb2RlICk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRzaGFkZXIgPSBuZXcgR0wuU2hhZGVyKCBmaW5hbGNvZGUudnNfY29kZSwgZmluYWxjb2RlLmZzX2NvZGUgKTtcclxuXHRcdFx0dGhpcy5fc2hhZGVyX2Vycm9yID0gZmFsc2U7XHJcblx0XHRcdHJldHVybiBzaGFkZXI7XHJcblx0XHR9XHJcblx0XHRjYXRjaCAoZXJyKVxyXG5cdFx0e1xyXG5cdFx0XHRpZighdGhpcy5fc2hhZGVyX2Vycm9yKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIpO1xyXG5cdFx0XHRcdGlmKGVyci5pbmRleE9mKFwiRnJhZ21lbnQgc2hhZGVyXCIpICE9IC0xKVxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGZpbmFsY29kZS5mc19jb2RlLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbih2LGkpeyByZXR1cm4gaSArIFwiLi0gXCIgKyB2OyB9KS5qb2luKFwiXFxuXCIpICk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGZpbmFsY29kZS52c19jb2RlICk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fc2hhZGVyX2Vycm9yID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7Ly9uZXZlciBoZXJlXHJcblx0fVxyXG5cclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmdldFNoYWRlciA9IGZ1bmN0aW9uKCBncmFwaCApXHJcblx0e1xyXG5cdFx0Ly9pZiBncmFwaCBub3QgY2hhbmdlZD9cclxuXHRcdGlmKHRoaXMuX3NoYWRlciAmJiB0aGlzLl9zaGFkZXIuX3ZlcnNpb24gPT0gZ3JhcGguX3ZlcnNpb24pXHJcblx0XHRcdHJldHVybiB0aGlzLl9zaGFkZXI7XHJcblxyXG5cdFx0Ly9jb21waWxlIHNoYWRlclxyXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuY29tcHV0ZVNoYWRlciggZ3JhcGgsIHRoaXMuX3NoYWRlciApO1xyXG5cdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcclxuXHRcdHRoaXMuX3NoYWRlciA9IHNoYWRlcjtcclxuXHRcdHNoYWRlci5fdmVyc2lvbiA9IGdyYXBoLl92ZXJzaW9uO1xyXG5cdFx0cmV0dXJuIHNoYWRlcjtcclxuXHR9XHJcblxyXG5cdC8vc29tZSBzaGFkZXIgbm9kZXMgY291bGQgcmVxdWlyZSB0byBmaWxsIHRoZSBib3ggd2l0aCBzb21lIHVuaWZvcm1zXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5maWxsVW5pZm9ybXMgPSBmdW5jdGlvbiggdW5pZm9ybXMsIHBhcmFtIClcclxuXHR7XHJcblx0XHRpZighdGhpcy5fdW5pZm9ybV92YWx1ZSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGZvcih2YXIgaSBpbiB0aGlzLl91bmlmb3JtX3ZhbHVlKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdiA9IHRoaXMuX3VuaWZvcm1fdmFsdWVbaV07XHJcblx0XHRcdGlmKHYgPT0gbnVsbClcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0aWYodi5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pXHJcblx0XHRcdFx0dW5pZm9ybXNbaV0gPSB2LmNhbGwoIHRoaXMsIHBhcmFtICk7XHJcblx0XHRcdGVsc2UgaWYodi5jb25zdHJ1Y3RvciA9PT0gR0wuVGV4dHVyZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdC8vdG9kby4uLlxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR1bmlmb3Jtc1tpXSA9IHY7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGguU2hhZGVyQ29udGV4dCA9IExpdGVHcmFwaC5TaGFkZXJzLkNvbnRleHQgPSBMR1NoYWRlckNvbnRleHQ7XHJcblxyXG5cdC8vIExHcmFwaFNoYWRlckdyYXBoICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0Ly8gYXBwbGllcyBhIHNoYWRlciBncmFwaCB0byB0ZXh0dXJlLCBpdCBjYW4gYmUgdXNlcyBhcyBhbiBleGFtcGxlXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckdyYXBoKCkge1xyXG5cclxuXHRcdC8vYmVmb3JlIGlucHV0c1xyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGggPSBuZXcgTGl0ZUdyYXBoLkxHcmFwaCgpO1xyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGguX3N1YmdyYXBoX25vZGUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGguX2lzX3N1YmdyYXBoID0gdHJ1ZTtcclxuXHRcdHRoaXMuc3ViZ3JhcGguZmlsdGVyID0gXCJzaGFkZXJcIjtcclxuXHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJ0ZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJ0ZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCBhbHBoYTogZmFsc2UsIHByZWNpc2lvbjogdHlwZW9mKExHcmFwaFRleHR1cmUpICE9IFwidW5kZWZpbmVkXCIgPyBMR3JhcGhUZXh0dXJlLkRFRkFVTFQgOiAyIH07XHJcblxyXG5cdFx0dmFyIGlucHV0Tm9kZSA9IHRoaXMuc3ViZ3JhcGguZmluZE5vZGVzQnlUeXBlKFwic2hhZGVyOjppbnB1dC91bmlmb3JtXCIpWzBdO1xyXG5cdFx0aW5wdXROb2RlLnBvcyA9IFsyMDAsMzAwXTtcclxuXHJcblx0XHR2YXIgc2FtcGxlciA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwic2hhZGVyOjp0ZXh0dXJlL3NhbXBsZXIyRFwiKTtcclxuXHRcdHNhbXBsZXIucG9zID0gWzQwMCwzMDBdO1xyXG5cdFx0dGhpcy5zdWJncmFwaC5hZGQoIHNhbXBsZXIgKTtcclxuXHJcblx0XHR2YXIgb3V0bm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwic2hhZGVyOjpvdXRwdXQvZnJhZ2NvbG9yXCIpO1xyXG5cdFx0b3V0bm9kZS5wb3MgPSBbNjAwLDMwMF07XHJcblx0XHR0aGlzLnN1YmdyYXBoLmFkZCggb3V0bm9kZSApO1xyXG5cclxuXHRcdGlucHV0Tm9kZS5jb25uZWN0KCAwLCBzYW1wbGVyICk7XHJcblx0XHRzYW1wbGVyLmNvbm5lY3QoIDAsIG91dG5vZGUgKTtcclxuXHJcblx0XHR0aGlzLnNpemUgPSBbMTgwLDYwXTtcclxuXHRcdHRoaXMucmVkcmF3X29uX21vdXNlID0gdHJ1ZTsgLy9mb3JjZSByZWRyYXdcclxuXHJcblx0XHR0aGlzLl91bmlmb3JtcyA9IHt9O1xyXG5cdFx0dGhpcy5fc2hhZGVyID0gbnVsbDtcclxuXHRcdHRoaXMuX2NvbnRleHQgPSBuZXcgTEdTaGFkZXJDb250ZXh0KCk7XHJcblx0XHR0aGlzLl9jb250ZXh0LnZzX3RlbXBsYXRlID0gXCIjZGVmaW5lIFZFUlRFWFxcblwiICsgR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSO1xyXG5cdFx0dGhpcy5fY29udGV4dC5mc190ZW1wbGF0ZSA9IExHcmFwaFNoYWRlckdyYXBoLnRlbXBsYXRlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgudGVtcGxhdGUgPSBcIlxcblxcXHJcbiNkZWZpbmUgRlJBR01FTlRcXG5cXFxyXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxudmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxue3t2YXJ5aW5nfX1cXG5cXFxyXG57e3VuaWZvcm1zfX1cXG5cXFxyXG57e2Z1bmN0aW9uc319XFxuXFxcclxue3tmc19mdW5jdGlvbnN9fVxcblxcXHJcbnZvaWQgbWFpbigpIHtcXG5cXG5cXFxyXG52ZWMyIHV2ID0gdl9jb29yZDtcXG5cXFxyXG52ZWM0IGZyYWdjb2xvciA9IHZlYzQoMC4wKTtcXG5cXFxyXG52ZWM0IGZyYWdjb2xvcjEgPSB2ZWM0KDAuMCk7XFxuXFxcclxue3tmc19jb2RlfX1cXG5cXFxyXG5nbF9GcmFnQ29sb3IgPSBmcmFnY29sb3I7XFxuXFxcclxufVxcblxcXHJcblx0XCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC50aXRsZSA9IFwiU2hhZGVyR3JhcGhcIjtcclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5kZXNjID0gXCJCdWlsZHMgYSBzaGFkZXIgdXNpbmcgYSBncmFwaFwiO1xyXG5cdExHcmFwaFNoYWRlckdyYXBoLmlucHV0X25vZGVfdHlwZSA9IFwiaW5wdXQvdW5pZm9ybVwiO1xyXG5cdExHcmFwaFNoYWRlckdyYXBoLm91dHB1dF9ub2RlX3R5cGUgPSBcIm91dHB1dC9mcmFnY29sb3JcIjtcclxuXHRMR3JhcGhTaGFkZXJHcmFwaC50aXRsZV9jb2xvciA9IFNIQURFUk5PREVTX0NPTE9SO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25TZXJpYWxpemUgPSBmdW5jdGlvbihvKVxyXG5cdHtcclxuXHRcdG8uc3ViZ3JhcGggPSB0aGlzLnN1YmdyYXBoLnNlcmlhbGl6ZSgpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uQ29uZmlndXJlID0gZnVuY3Rpb24obylcclxuXHR7XHJcblx0XHR0aGlzLnN1YmdyYXBoLmNvbmZpZ3VyZShvLnN1YmdyYXBoKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vcmVhZCBpbnB1dCB0ZXh0dXJlXHJcblx0XHR2YXIgaW50ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKGludGV4ICYmIGludGV4LmNvbnN0cnVjdG9yICE9IEdMLlRleHR1cmUpXHJcblx0XHRcdGludGV4ID0gbnVsbDtcclxuXHJcblx0XHR2YXIgdyA9IHRoaXMucHJvcGVydGllcy53aWR0aCB8IDA7XHJcblx0XHR2YXIgaCA9IHRoaXMucHJvcGVydGllcy5oZWlnaHQgfCAwO1xyXG5cdFx0aWYgKHcgPT0gMCkge1xyXG5cdFx0XHR3ID0gaW50ZXggPyBpbnRleC53aWR0aCA6IGdsLnZpZXdwb3J0X2RhdGFbMl07XHJcblx0XHR9IC8vMCBtZWFucyBkZWZhdWx0XHJcblx0XHRpZiAoaCA9PSAwKSB7XHJcblx0XHRcdGggPSBpbnRleCA/IGludGV4LmhlaWdodCA6IGdsLnZpZXdwb3J0X2RhdGFbM107XHJcblx0XHR9IC8vMCBtZWFucyBkZWZhdWx0XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlKCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uLCBpbnRleCApO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcclxuXHRcdGlmICggIXRleHR1cmUgfHwgdGV4dHVyZS53aWR0aCAhPSB3IHx8IHRleHR1cmUuaGVpZ2h0ICE9IGggfHwgdGV4dHVyZS50eXBlICE9IHR5cGUgKSB7XHJcblx0XHRcdHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodywgaCwge1xyXG5cdFx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdFx0Zm9ybWF0OiB0aGlzLmFscGhhID8gZ2wuUkdCQSA6IGdsLlJHQixcclxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKCB0aGlzLnN1YmdyYXBoICk7XHJcblx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XHJcblx0XHR0aGlzLl9jb250ZXh0LmZpbGxVbmlmb3JtcyggdW5pZm9ybXMgKTtcclxuXHJcblx0XHR2YXIgdGV4X3Nsb3QgPSAwO1xyXG5cdFx0aWYodGhpcy5pbnB1dHMpXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG5cdFx0XHRpZihpbnB1dC50eXBlID09IFwidGV4dHVyZVwiKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYoIWRhdGEpXHJcblx0XHRcdFx0XHRkYXRhID0gR0wuVGV4dHVyZS5nZXRXaGl0ZVRleHR1cmUoKTtcclxuXHRcdFx0XHRkYXRhID0gZGF0YS5iaW5kKHRleF9zbG90KyspO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihkYXRhICE9IG51bGwpXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidV9cIiArIGlucHV0Lm5hbWUgXSA9IGRhdGE7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1lc2ggPSBHTC5NZXNoLmdldFNjcmVlblF1YWQoKTtcclxuXHJcblx0XHRnbC5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdHRleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCl7XHJcblx0XHRcdHNoYWRlci51bmlmb3JtcyggdW5pZm9ybXMgKTtcclxuXHRcdFx0c2hhZGVyLmRyYXcoIG1lc2ggKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vdXNlIHN1YmdyYXBoIG91dHB1dCBcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXh0dXJlICk7XHJcblx0fTtcclxuXHJcblx0Ly9hZGQgaW5wdXQgbm9kZSBpbnNpZGUgc3ViZ3JhcGhcclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25JbnB1dEFkZGVkID0gZnVuY3Rpb24oIHNsb3RfaW5mbyApXHJcblx0e1xyXG5cdFx0dmFyIHN1Ym5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcInNoYWRlcjo6aW5wdXQvdW5pZm9ybVwiKTtcclxuXHRcdHN1Ym5vZGUuc2V0UHJvcGVydHkoXCJuYW1lXCIsc2xvdF9pbmZvLm5hbWUpO1xyXG5cdFx0c3Vibm9kZS5zZXRQcm9wZXJ0eShcInR5cGVcIixzbG90X2luZm8udHlwZSk7XHJcblx0XHR0aGlzLnN1YmdyYXBoLmFkZCggc3Vibm9kZSApO1xyXG5cdH1cclxuXHJcblx0Ly9yZW1vdmUgYWxsXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uSW5wdXRSZW1vdmVkID0gZnVuY3Rpb24oIHNsb3QsIHNsb3RfaW5mbyApXHJcblx0e1xyXG5cdFx0dmFyIG5vZGVzID0gdGhpcy5zdWJncmFwaC5maW5kTm9kZXNCeVR5cGUoXCJzaGFkZXI6OmlucHV0L3VuaWZvcm1cIik7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBub2RlID0gbm9kZXNbaV07XHJcblx0XHRcdGlmKG5vZGUucHJvcGVydGllcy5uYW1lID09IHNsb3RfaW5mby5uYW1lIClcclxuXHRcdFx0XHR0aGlzLnN1YmdyYXBoLnJlbW92ZSggbm9kZSApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciBudW1faW5wdXRzID0gdGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggOiAwO1xyXG5cdFx0dmFyIG51bV9vdXRwdXRzID0gdGhpcy5vdXRwdXRzID8gdGhpcy5vdXRwdXRzLmxlbmd0aCA6IDA7XHJcblx0XHRyZXR1cm4gWyAyMDAsIE1hdGgubWF4KG51bV9pbnB1dHMsbnVtX291dHB1dHMpICogTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAxMF07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUuZ2V0U2hhZGVyID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLl9jb250ZXh0LmdldFNoYWRlciggdGhpcy5zdWJncmFwaCApO1xyXG5cdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBudWxsO1xyXG5cdFx0cmV0dXJuIHNoYWRlcjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4LCBncmFwaGNhbnZhcywgY2FudmFzLCBwb3MpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHQvL2FsbG93cyB0byBwcmV2aWV3IHRoZSBub2RlIGlmIHRoZSBjYW52YXMgaXMgYSB3ZWJnbCBjYW52YXNcclxuXHRcdHZhciB0ZXggPSB0aGlzLmdldE91dHB1dERhdGEoMCk7XHJcblx0XHR2YXIgaW5wdXRzX3kgPSB0aGlzLmlucHV0cyA/IHRoaXMuaW5wdXRzLmxlbmd0aCAqIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUIDogMDtcclxuXHRcdGlmICh0ZXggJiYgY3R4ID09IHRleC5nbCAmJiB0aGlzLnNpemVbMV0gPiBpbnB1dHNfeSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCApIHtcclxuXHRcdFx0Y3R4LmRyYXdJbWFnZSggdGV4LCAxMCx5LCB0aGlzLnNpemVbMF0gLSAyMCwgdGhpcy5zaXplWzFdIC0gaW5wdXRzX3kgLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeSA9IHRoaXMuc2l6ZVsxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDAuNTtcclxuXHJcblx0XHQvL2J1dHRvblxyXG5cdFx0dmFyIG92ZXIgPSBMaXRlR3JhcGguaXNJbnNpZGVSZWN0YW5nbGUocG9zWzBdLHBvc1sxXSx0aGlzLnBvc1swXSx0aGlzLnBvc1sxXSArIHksdGhpcy5zaXplWzBdLExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCk7XHJcblx0XHRjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiIzU1NVwiIDogXCIjMjIyXCI7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRpZiAodGhpcy5fc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSlcclxuXHRcdFx0Y3R4LnJlY3QoMCwgeSwgdGhpcy5zaXplWzBdKzEsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGN0eC5yb3VuZFJlY3QoIDAsIHksIHRoaXMuc2l6ZVswXSsxLCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsIDAsIDgpO1xyXG5cdFx0Y3R4LmZpbGwoKTtcclxuXHJcblx0XHQvL2J1dHRvblxyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcblx0XHRjdHguZm9udCA9IFwiMjRweCBBcmlhbFwiO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IG92ZXIgPyBcIiNERERcIiA6IFwiIzk5OVwiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KCBcIitcIiwgdGhpcy5zaXplWzBdICogMC41LCB5ICsgMjQgKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGxvY2FscG9zLCBncmFwaGNhbnZhcylcclxuXHR7XHJcblx0XHR2YXIgeSA9IHRoaXMuc2l6ZVsxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDAuNTtcclxuXHRcdGlmKGxvY2FscG9zWzFdID4geSlcclxuXHRcdHtcclxuXHRcdFx0Z3JhcGhjYW52YXMuc2hvd1N1YmdyYXBoUHJvcGVydGllc0RpYWxvZyh0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbkRyYXdTdWJncmFwaEJhY2tncm91bmQgPSBmdW5jdGlvbihncmFwaGNhbnZhcylcclxuXHR7XHJcblx0XHQvL1RPRE9cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5nZXRFeHRyYU1lbnVPcHRpb25zID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpXHJcblx0e1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBbeyBjb250ZW50OiBcIlByaW50IENvZGVcIiwgY2FsbGJhY2s6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBjb2RlID0gdGhhdC5fY29udGV4dC5jb21wdXRlU2hhZGVyQ29kZSgpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyggY29kZS52c19jb2RlLCBjb2RlLmZzX2NvZGUgKTtcclxuXHRcdH19XTtcclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInRleHR1cmUvc2hhZGVyR3JhcGhcIiwgTEdyYXBoU2hhZGVyR3JhcGggKTtcclxuXHJcblx0ZnVuY3Rpb24gc2hhZGVyTm9kZUZyb21GdW5jdGlvbiggY2xhc3NuYW1lLCBwYXJhbXMsIHJldHVybl90eXBlLCBjb2RlIClcclxuXHR7XHJcblx0XHQvL1RPRE9cclxuXHR9XHJcblxyXG5cdC8vU2hhZGVyIE5vZGVzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdC8vYXBwbGllcyBhIHNoYWRlciBncmFwaCB0byBhIGNvZGVcclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJVbmlmb3JtKCkge1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IFwiXCIgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclVuaWZvcm0udGl0bGUgPSBcIlVuaWZvcm1cIjtcclxuXHRMR3JhcGhTaGFkZXJVbmlmb3JtLmRlc2MgPSBcIklucHV0IGRhdGEgZm9yIHRoZSBzaGFkZXJcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyVW5pZm9ybS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYoIHRoaXMucHJvcGVydGllcy5uYW1lICYmIHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKyBcIiBcIiArIHRoaXMucHJvcGVydGllcy5uYW1lO1xyXG5cdFx0cmV0dXJuIFwiVW5pZm9ybVwiO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVW5pZm9ybS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdHRoaXMub3V0cHV0c1swXS5uYW1lID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKyBcIiBcIiArIHRoaXMucHJvcGVydGllcy5uYW1lO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVW5pZm9ybS5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XHJcblx0XHRpZiggIXR5cGUgKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiggIWNvbnRleHQub25HZXRQcm9wZXJ0eUluZm8gKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dmFyIGluZm8gPSBjb250ZXh0Lm9uR2V0UHJvcGVydHlJbmZvKCB0aGlzLnByb3BlcnR5Lm5hbWUgKTtcclxuXHRcdFx0aWYoIWluZm8pXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR0eXBlID0gaW5mby50eXBlO1xyXG5cdFx0fVxyXG5cdFx0aWYodHlwZSA9PSBcIm51bWJlclwiKVxyXG5cdFx0XHR0eXBlID0gXCJmbG9hdFwiO1xyXG5cdFx0ZWxzZSBpZih0eXBlID09IFwidGV4dHVyZVwiKVxyXG5cdFx0XHR0eXBlID0gXCJzYW1wbGVyMkRcIjtcclxuXHRcdGlmICggTEdTaGFkZXJzLkdMU0xfdHlwZXMuaW5kZXhPZih0eXBlKSA9PSAtMSApXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRjb250ZXh0LmFkZFVuaWZvcm0oIFwidV9cIiArIHRoaXMucHJvcGVydGllcy5uYW1lLCB0eXBlICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHR5cGUgKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclVuaWZvcm0ucHJvdG90eXBlLmdldE91dHB1dFZhck5hbWUgPSBmdW5jdGlvbihzbG90KVxyXG5cdHtcclxuXHRcdHJldHVybiBcInVfXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJpbnB1dC91bmlmb3JtXCIsIExHcmFwaFNoYWRlclVuaWZvcm0gKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckF0dHJpYnV0ZSgpIHtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwidmVjMlwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgbmFtZTogXCJjb29yZFwiLCB0eXBlOiBcInZlYzJcIiB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQXR0cmlidXRlLnRpdGxlID0gXCJBdHRyaWJ1dGVcIjtcclxuXHRMR3JhcGhTaGFkZXJBdHRyaWJ1dGUuZGVzYyA9IFwiSW5wdXQgZGF0YSBmcm9tIG1lc2ggYXR0cmlidXRlXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0cmV0dXJuIFwiYXR0LiBcIiArIHRoaXMucHJvcGVydGllcy5uYW1lO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLnByb3BlcnRpZXMudHlwZTtcclxuXHRcdGlmKCAhdHlwZSB8fCBMR1NoYWRlcnMuR0xTTF90eXBlcy5pbmRleE9mKHR5cGUpID09IC0xIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYodHlwZSA9PSBcIm51bWJlclwiKVxyXG5cdFx0XHR0eXBlID0gXCJmbG9hdFwiO1xyXG5cdFx0aWYoIHRoaXMucHJvcGVydGllcy5uYW1lICE9IFwiY29vcmRcIilcclxuXHRcdHtcclxuXHRcdFx0Y29udGV4dC5hZGRDb2RlKCBcInZhcnlpbmdcIiwgXCIgdmFyeWluZyBcIiArIHR5cGUgK1wiIHZfXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZSArIFwiO1wiICk7XHJcblx0XHRcdC8vaWYoICFjb250ZXh0LnZhcnlpbmdzWyB0aGlzLnByb3BlcnRpZXMubmFtZSBdIClcclxuXHRcdFx0Ly9jb250ZXh0LmFkZENvZGUoIFwidnNfY29kZVwiLCBcInZfXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZSArIFwiID0gXCIgKyBpbnB1dF9uYW1lICsgXCI7XCIgKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdHlwZSApO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5nZXRPdXRwdXRWYXJOYW1lID0gZnVuY3Rpb24oc2xvdClcclxuXHR7XHJcblx0XHRyZXR1cm4gXCJ2X1wiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiaW5wdXQvYXR0cmlidXRlXCIsIExHcmFwaFNoYWRlckF0dHJpYnV0ZSApO1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJTYW1wbGVyMkQoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidGV4XCIsIFwic2FtcGxlcjJEXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInV2XCIsIFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwicmdiYVwiLCBcInZlYzRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInJnYlwiLCBcInZlYzNcIik7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJTYW1wbGVyMkQudGl0bGUgPSBcIlNhbXBsZXIyRFwiO1xyXG5cdExHcmFwaFNoYWRlclNhbXBsZXIyRC5kZXNjID0gXCJSZWFkcyBhIHBpeGVsIGZyb20gYSB0ZXh0dXJlXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlclNhbXBsZXIyRC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciB0ZXhuYW1lID0gZ2V0SW5wdXRMaW5rSUQoIHRoaXMsIDAgKTtcclxuXHRcdHZhciB2YXJuYW1lID0gZ2V0U2hhZGVyTm9kZVZhck5hbWUodGhpcyk7XHJcblx0XHR2YXIgY29kZSA9IFwidmVjNCBcIiArIHZhcm5hbWUgKyBcIiA9IHZlYzQoMC4wKTtcXG5cIjtcclxuXHRcdGlmKHRleG5hbWUpXHJcblx0XHR7XHJcblx0XHRcdHZhciB1dm5hbWUgPSBnZXRJbnB1dExpbmtJRCggdGhpcywgMSApIHx8IGNvbnRleHQuYnVmZmVyX25hbWVzLnV2cztcclxuXHRcdFx0Y29kZSArPSB2YXJuYW1lICsgXCIgPSB0ZXh0dXJlMkQoXCIrdGV4bmFtZStcIixcIit1dm5hbWUrXCIpO1xcblwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rMCA9IGdldE91dHB1dExpbmtJRCggdGhpcywgMCApO1xyXG5cdFx0aWYobGluazApXHJcblx0XHRcdGNvZGUgKz0gXCJ2ZWM0IFwiICsgZ2V0T3V0cHV0TGlua0lEKCB0aGlzLCAwICkgKyBcIiA9IFwiK3Zhcm5hbWUrXCI7XFxuXCI7XHJcblxyXG5cdFx0dmFyIGxpbmsxID0gZ2V0T3V0cHV0TGlua0lEKCB0aGlzLCAxICk7XHJcblx0XHRpZihsaW5rMSlcclxuXHRcdFx0Y29kZSArPSBcInZlYzMgXCIgKyBnZXRPdXRwdXRMaW5rSUQoIHRoaXMsIDEgKSArIFwiID0gXCIrdmFybmFtZStcIi54eXo7XFxuXCI7XHJcblxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKCBcImNvZGVcIiwgY29kZSwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgXCJ2ZWM0XCIgKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMSwgXCJ2ZWMzXCIgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJ0ZXh0dXJlL3NhbXBsZXIyRFwiLCBMR3JhcGhTaGFkZXJTYW1wbGVyMkQgKTtcclxuXHJcblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyQ29uc3RhbnQoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsXCJmbG9hdFwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdHR5cGU6IFwiZmxvYXRcIixcclxuXHRcdFx0dmFsdWU6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwidHlwZVwiLFwiZmxvYXRcIixudWxsLCB7IHZhbHVlczogR0xTTF90eXBlc19jb25zdCwgcHJvcGVydHk6IFwidHlwZVwiIH0gKTtcclxuXHRcdHRoaXMudXBkYXRlV2lkZ2V0cygpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQ29uc3RhbnQudGl0bGUgPSBcImNvbnN0XCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckNvbnN0YW50LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuXHRcdFx0cmV0dXJuIHZhbHVlVG9HTFNMKCB0aGlzLnByb3BlcnRpZXMudmFsdWUsIHRoaXMucHJvcGVydGllcy50eXBlLCAyICk7XHJcblx0XHRyZXR1cm4gXCJDb25zdFwiO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQ29uc3RhbnQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRpZihuYW1lID09IFwidHlwZVwiKVxyXG5cdFx0e1xyXG5cdFx0XHRpZih0aGlzLm91dHB1dHNbMF0udHlwZSAhPSB2YWx1ZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdE91dHB1dCgwKTtcclxuXHRcdFx0XHR0aGlzLm91dHB1dHNbMF0udHlwZSA9IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMud2lkZ2V0cy5sZW5ndGggPSAxOyAvL3JlbW92ZSBleHRyYSB3aWRnZXRzXHJcblx0XHRcdHRoaXMudXBkYXRlV2lkZ2V0cygpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmFtZSA9PSBcInZhbHVlXCIpXHJcblx0XHR7XHJcblx0XHRcdGlmKCF2YWx1ZS5sZW5ndGgpXHJcblx0XHRcdFx0dGhpcy53aWRnZXRzWzFdLnZhbHVlID0gdmFsdWU7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMud2lkZ2V0c1sxXS52YWx1ZSA9IHZhbHVlWzFdO1xyXG5cdFx0XHRcdGlmKHZhbHVlLmxlbmd0aCA+IDIpXHJcblx0XHRcdFx0XHR0aGlzLndpZGdldHNbMl0udmFsdWUgPSB2YWx1ZVsyXTtcclxuXHRcdFx0XHRpZih2YWx1ZS5sZW5ndGggPiAzKVxyXG5cdFx0XHRcdFx0dGhpcy53aWRnZXRzWzNdLnZhbHVlID0gdmFsdWVbM107XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckNvbnN0YW50LnByb3RvdHlwZS51cGRhdGVXaWRnZXRzID0gZnVuY3Rpb24oIG9sZF92YWx1ZSApXHJcblx0e1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dmFyIG9sZF92YWx1ZSA9IHRoaXMucHJvcGVydGllcy52YWx1ZTtcclxuXHRcdHZhciBvcHRpb25zID0geyBzdGVwOiAwLjAxIH07XHJcblx0XHRzd2l0Y2godGhpcy5wcm9wZXJ0aWVzLnR5cGUpXHJcblx0XHR7XHJcblx0XHRcdGNhc2UgJ2Zsb2F0JzogXHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gMDtcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwidlwiLDAseyBzdGVwOjAuMDEsIHByb3BlcnR5OiBcInZhbHVlXCIgfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ3ZlYzInOiBcclxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXMudmFsdWUgPSBvbGRfdmFsdWUgJiYgb2xkX3ZhbHVlLmxlbmd0aCA9PSAyID8gW29sZF92YWx1ZVswXSxvbGRfdmFsdWVbMV1dIDogWzAsMCwwXTtcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwieFwiLHRoaXMucHJvcGVydGllcy52YWx1ZVswXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVswXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ5XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzFdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzFdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ3ZlYzMnOiBcclxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXMudmFsdWUgPSBvbGRfdmFsdWUgJiYgb2xkX3ZhbHVlLmxlbmd0aCA9PSAzID8gW29sZF92YWx1ZVswXSxvbGRfdmFsdWVbMV0sb2xkX3ZhbHVlWzJdXSA6IFswLDAsMF07XHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInhcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMF0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMF0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwieVwiLHRoaXMucHJvcGVydGllcy52YWx1ZVsxXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVsxXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ6XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzJdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzJdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ3ZlYzQnOiBcclxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXMudmFsdWUgPSBvbGRfdmFsdWUgJiYgb2xkX3ZhbHVlLmxlbmd0aCA9PSA0ID8gW29sZF92YWx1ZVswXSxvbGRfdmFsdWVbMV0sb2xkX3ZhbHVlWzJdLG9sZF92YWx1ZVszXV0gOiBbMCwwLDAsMF07XHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInhcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMF0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMF0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwieVwiLHRoaXMucHJvcGVydGllcy52YWx1ZVsxXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVsxXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ6XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzJdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzJdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcIndcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbM10sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbM10gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwidW5rbm93biB0eXBlIGZvciBjb25zdGFudFwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckNvbnN0YW50LnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHZhbHVlID0gdmFsdWVUb0dMU0woIHRoaXMucHJvcGVydGllcy52YWx1ZSwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKTtcclxuXHRcdHZhciBsaW5rX25hbWUgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdGlmKCFsaW5rX25hbWUpIC8vbm90IGNvbm5lY3RlZFxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGNvZGUgPSBcIlx0XCIgKyB0aGlzLnByb3BlcnRpZXMudHlwZSArIFwiIFwiICsgbGlua19uYW1lICsgXCIgPSBcIiArIHZhbHVlICsgXCI7XCI7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoIFwiY29kZVwiLCBjb2RlLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJjb25zdC9jb25zdFwiLCBMR3JhcGhTaGFkZXJDb25zdGFudCApO1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJWZWMyKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHlcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieVwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh5XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieVwiLFwiZmxvYXRcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB4OiAwLCB5OiAwIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWMyLnRpdGxlID0gXCJ2ZWMyXCI7XHJcblx0TEdyYXBoU2hhZGVyVmVjMi52YXJtb2RlcyA9IFtcInh5XCIsXCJ4XCIsXCJ5XCJdO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWMyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHQgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjMi5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcclxuXHJcblx0XHR2YXIgdmFybmFtZSA9IGdldFNoYWRlck5vZGVWYXJOYW1lKHRoaXMpO1xyXG5cdFx0dmFyIGNvZGUgPSBcIlx0dmVjMiBcIiArIHZhcm5hbWUgKyBcIiA9IFwiICsgdmFsdWVUb0dMU0woW3Byb3BzLngscHJvcHMueV0pICsgXCI7XFxuXCI7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDtpIDwgTEdyYXBoU2hhZGVyVmVjMi52YXJtb2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhcm1vZGUgPSBMR3JhcGhTaGFkZXJWZWMyLnZhcm1vZGVzW2ldO1xyXG5cdFx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcyxpKTtcclxuXHRcdFx0aWYoIWlubGluaylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0Y29kZSArPSBcIlx0XCIgKyB2YXJuYW1lICsgXCIuXCIrdmFybW9kZStcIiA9IFwiICsgaW5saW5rICsgXCI7XFxuXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDtpIDwgTEdyYXBoU2hhZGVyVmVjMi52YXJtb2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhcm1vZGUgPSBMR3JhcGhTaGFkZXJWZWMyLnZhcm1vZGVzW2ldO1xyXG5cdFx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLGkpO1xyXG5cdFx0XHRpZighb3V0bGluaylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIHR5cGUgPSBHTFNMX3R5cGVzX2NvbnN0W3Zhcm1vZGUubGVuZ3RoIC0gMV07XHJcblx0XHRcdGNvZGUgKz0gXCJcdFwiK3R5cGUrXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIiArIHZhcm5hbWUgKyBcIi5cIiArIHZhcm1vZGUgKyBcIjtcXG5cIjtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCBpLCB0eXBlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKCBcImNvZGVcIiwgY29kZSwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJjb25zdC92ZWMyXCIsIExHcmFwaFNoYWRlclZlYzIgKTtcdFxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJWZWMzKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHl6XCIsXCJ2ZWMzXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInhcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInlcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInpcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh5XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh6XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInl6XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4eXpcIixcInZlYzNcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInhcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ5XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwielwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh5XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4elwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieXpcIixcInZlYzJcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB4OjAsIHk6IDAsIHo6IDAgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzMudGl0bGUgPSBcInZlYzNcIjtcclxuXHRMR3JhcGhTaGFkZXJWZWMzLnZhcm1vZGVzID0gW1wieHl6XCIsXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ4eVwiLFwieHpcIixcInl6XCJdO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWMzLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWMzLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xyXG5cclxuXHRcdHZhciB2YXJuYW1lID0gZ2V0U2hhZGVyTm9kZVZhck5hbWUodGhpcyk7XHJcblx0XHR2YXIgY29kZSA9IFwidmVjMyBcIiArIHZhcm5hbWUgKyBcIiA9IFwiICsgdmFsdWVUb0dMU0woW3Byb3BzLngscHJvcHMueSxwcm9wcy56XSkgKyBcIjtcXG5cIjtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwO2kgPCBMR3JhcGhTaGFkZXJWZWMzLnZhcm1vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdmFybW9kZSA9IExHcmFwaFNoYWRlclZlYzMudmFybW9kZXNbaV07XHJcblx0XHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLGkpO1xyXG5cdFx0XHRpZighaW5saW5rKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRjb2RlICs9IFwiXHRcIiArIHZhcm5hbWUgKyBcIi5cIit2YXJtb2RlK1wiID0gXCIgKyBpbmxpbmsgKyBcIjtcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgTEdyYXBoU2hhZGVyVmVjMy52YXJtb2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhcm1vZGUgPSBMR3JhcGhTaGFkZXJWZWMzLnZhcm1vZGVzW2ldO1xyXG5cdFx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLGkpO1xyXG5cdFx0XHRpZighb3V0bGluaylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIHR5cGUgPSBHTFNMX3R5cGVzX2NvbnN0W3Zhcm1vZGUubGVuZ3RoIC0gMV07XHJcblx0XHRcdGNvZGUgKz0gXCJcdFwiK3R5cGUrXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIiArIHZhcm5hbWUgKyBcIi5cIiArIHZhcm1vZGUgKyBcIjtcXG5cIjtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCBpLCB0eXBlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKCBcImNvZGVcIiwgY29kZSwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJjb25zdC92ZWMzXCIsIExHcmFwaFNoYWRlclZlYzMgKTtcdFxyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyVmVjNCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh5endcIixcInZlYzRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHl6XCIsXCJ2ZWMzXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInhcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInlcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInpcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIndcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh5XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInl6XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInp3XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4eXp3XCIsXCJ2ZWM0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4eXpcIixcInZlYzNcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInhcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ5XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwielwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh5XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ5elwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiendcIixcInZlYzJcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB4OjAsIHk6IDAsIHo6IDAsIHc6IDAgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzQudGl0bGUgPSBcInZlYzRcIjtcclxuXHRMR3JhcGhTaGFkZXJWZWM0LnZhcm1vZGVzID0gW1wieHl6d1wiLFwieHl6XCIsXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ4eVwiLFwieXpcIixcInp3XCJdO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWM0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWM0LnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xyXG5cclxuXHRcdHZhciB2YXJuYW1lID0gZ2V0U2hhZGVyTm9kZVZhck5hbWUodGhpcyk7XHJcblx0XHR2YXIgY29kZSA9IFwidmVjNCBcIiArIHZhcm5hbWUgKyBcIiA9IFwiICsgdmFsdWVUb0dMU0woW3Byb3BzLngscHJvcHMueSxwcm9wcy56LHByb3BzLnddKSArIFwiO1xcblwiO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7aSA8IExHcmFwaFNoYWRlclZlYzQudmFybW9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2YXJtb2RlID0gTEdyYXBoU2hhZGVyVmVjNC52YXJtb2Rlc1tpXTtcclxuXHRcdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsaSk7XHJcblx0XHRcdGlmKCFpbmxpbmspXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdGNvZGUgKz0gXCJcdFwiICsgdmFybmFtZSArIFwiLlwiK3Zhcm1vZGUrXCIgPSBcIiArIGlubGluayArIFwiO1xcblwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7aSA8IExHcmFwaFNoYWRlclZlYzQudmFybW9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2YXJtb2RlID0gTEdyYXBoU2hhZGVyVmVjNC52YXJtb2Rlc1tpXTtcclxuXHRcdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcyxpKTtcclxuXHRcdFx0aWYoIW91dGxpbmspXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHZhciB0eXBlID0gR0xTTF90eXBlc19jb25zdFt2YXJtb2RlLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRjb2RlICs9IFwiXHRcIit0eXBlK1wiIFwiICsgb3V0bGluayArIFwiID0gXCIgKyB2YXJuYW1lICsgXCIuXCIgKyB2YXJtb2RlICsgXCI7XFxuXCI7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggaSwgdHlwZSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQuYWRkQ29kZSggXCJjb2RlXCIsIGNvZGUsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImNvbnN0L3ZlYzRcIiwgTEdyYXBoU2hhZGVyVmVjNCApO1x0XHJcblx0XHJcblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyRnJhZ0NvbG9yKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImNvbG9yXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYmxvY2tfZGVsZXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckZyYWdDb2xvci50aXRsZSA9IFwiRnJhZ0NvbG9yXCI7XHJcblx0TEdyYXBoU2hhZGVyRnJhZ0NvbG9yLmRlc2MgPSBcIlBpeGVsIGZpbmFsIGNvbG9yXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckZyYWdDb2xvci5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdHZhciBsaW5rX25hbWUgPSBnZXRJbnB1dExpbmtJRCggdGhpcywgMCApO1xyXG5cdFx0aWYoIWxpbmtfbmFtZSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHZhciBjb2RlID0gdmFyVG9UeXBlR0xTTCggbGlua19uYW1lLCB0eXBlLCBcInZlYzRcIiApO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiZnNfY29kZVwiLCBcImZyYWdjb2xvciA9IFwiICsgY29kZSArIFwiO1wiKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJvdXRwdXQvZnJhZ2NvbG9yXCIsIExHcmFwaFNoYWRlckZyYWdDb2xvciApO1xyXG5cclxuXHJcblx0LypcclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJEaXNjYXJkKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidlwiLFwiVFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtaW5cIixcIlRcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG1pbl92YWx1ZTogMC4wIH07XHJcblx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwibWluXCIsMCx7IHN0ZXA6IDAuMDEsIHByb3BlcnR5OiBcIm1pbl92YWx1ZVwiIH0pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRGlzY2FyZC50aXRsZSA9IFwiRGlzY2FyZFwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJEaXNjYXJkLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdHZhciBpbmxpbmsxID0gZ2V0SW5wdXRMaW5rSUQodGhpcywxKTtcclxuXHJcblx0XHRpZighaW5saW5rICYmICFpbmxpbmsxKSAvL25vdCBjb25uZWN0ZWRcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gKCAoXCIgKyBpbmxpbmsgKyBcIiAtIFwiK21pbnYrXCIpIC8gKFwiKyBtYXh2K1wiIC0gXCIrbWluditcIikgKSAqIChcIisgbWF4djIrXCIgLSBcIittaW52MitcIikgKyBcIiArIG1pbnYyICsgXCI7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHJldHVybl90eXBlICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwib3V0cHV0L2Rpc2NhcmRcIiwgTEdyYXBoU2hhZGVyRGlzY2FyZCApO1xyXG5cdCovXHJcblxyXG5cclxuXHQvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlck9wZXJhdGlvbigpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIixcIlwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0b3BlcmF0aW9uOiBcIipcIlxyXG5cdFx0fTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcIm9wLlwiLHRoaXMucHJvcGVydGllcy5vcGVyYXRpb24seyBwcm9wZXJ0eTogXCJvcGVyYXRpb25cIiwgdmFsdWVzOiBMR3JhcGhTaGFkZXJPcGVyYXRpb24ub3BlcmF0aW9ucyB9KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlck9wZXJhdGlvbi50aXRsZSA9IFwiT3BlcmF0aW9uXCI7XHJcblx0TEdyYXBoU2hhZGVyT3BlcmF0aW9uLm9wZXJhdGlvbnMgPSBbXCIrXCIsXCItXCIsXCIqXCIsXCIvXCJdO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJPcGVyYXRpb24ucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxyXG5cdFx0XHRyZXR1cm4gXCJBXCIgKyB0aGlzLnByb3BlcnRpZXMub3BlcmF0aW9uICsgXCJCXCI7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBcIk9wZXJhdGlvblwiO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyT3BlcmF0aW9uLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rcyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IDM7ICsraSlcclxuXHRcdFx0aW5saW5rcy5wdXNoKCB7IG5hbWU6IGdldElucHV0TGlua0lEKHRoaXMsaSksIHR5cGU6IHRoaXMuZ2V0SW5wdXREYXRhKGkpIHx8IFwiZmxvYXRcIiB9ICk7XHJcblxyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdGlmKCFvdXRsaW5rKSAvL25vdCBjb25uZWN0ZWRcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vZnVuY19kZXNjXHJcblx0XHR2YXIgYmFzZV90eXBlID0gaW5saW5rc1swXS50eXBlO1xyXG5cdFx0dmFyIHJldHVybl90eXBlID0gYmFzZV90eXBlO1xyXG5cdFx0dmFyIG9wID0gdGhpcy5wcm9wZXJ0aWVzLm9wZXJhdGlvbjtcclxuXHJcblx0XHR2YXIgcGFyYW1zID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMjsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgcGFyYW1fY29kZSA9IGlubGlua3NbaV0ubmFtZTtcclxuXHRcdFx0aWYocGFyYW1fY29kZSA9PSBudWxsKSAvL25vdCBwbHVnZ2VkXHJcblx0XHRcdHtcclxuXHRcdFx0XHRwYXJhbV9jb2RlID0gcC52YWx1ZSAhPSBudWxsID8gcC52YWx1ZSA6IFwiKDEuMClcIjtcclxuXHRcdFx0XHRpbmxpbmtzW2ldLnR5cGUgPSBcImZsb2F0XCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29udmVydFxyXG5cdFx0XHRpZiggaW5saW5rc1tpXS50eXBlICE9IGJhc2VfdHlwZSApIFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYoIGlubGlua3NbaV0udHlwZSA9PSBcImZsb2F0XCIgJiYgKG9wID09IFwiKlwiIHx8IG9wID09IFwiL1wiKSApXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Ly9JIGZpbmQgaGFyZCB0byBjcmVhdGUgdGhlIG9wcG9zaXRlIGNvbmRpdGlvbiBub3csIHNvIEkgcHJlZmVlciBhbiBlbHNlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHBhcmFtX2NvZGUgPSBjb252ZXJ0VmFyVG9HTFNMVHlwZSggcGFyYW1fY29kZSwgaW5saW5rc1tpXS50eXBlLCBiYXNlX3R5cGUgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwYXJhbXMucHVzaCggcGFyYW1fY29kZSApO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIisgcGFyYW1zWzBdICsgb3AgKyBwYXJhbXNbMV0gKyBcIjtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgcmV0dXJuX3R5cGUgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJtYXRoL29wZXJhdGlvblwiLCBMR3JhcGhTaGFkZXJPcGVyYXRpb24gKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckZ1bmMoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJCXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsXCJcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGZ1bmM6IFwiZmxvb3JcIlxyXG5cdFx0fTtcclxuXHRcdHRoaXMuX2N1cnJlbnQgPSBcImZsb29yXCI7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJmdW5jXCIsdGhpcy5wcm9wZXJ0aWVzLmZ1bmMseyBwcm9wZXJ0eTogXCJmdW5jXCIsIHZhbHVlczogR0xTTF9mdW5jdGlvbnNfbmFtZSB9KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckZ1bmMudGl0bGUgPSBcIkZ1bmNcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyRnVuYy5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHJcblx0XHRpZihuYW1lID09IFwiZnVuY1wiKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgZnVuY19kZXNjID0gR0xTTF9mdW5jdGlvbnNbIHZhbHVlIF07XHJcblx0XHRcdGlmKCFmdW5jX2Rlc2MpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0Ly9yZW1vdmUgZXh0cmEgaW5wdXRzXHJcblx0XHRcdGZvcih2YXIgaSA9IGZ1bmNfZGVzYy5wYXJhbXMubGVuZ3RoOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnB1dChpKTtcclxuXHJcblx0XHRcdC8vYWRkIGFuZCB1cGRhdGUgaW5wdXRzXHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBmdW5jX2Rlc2MucGFyYW1zLmxlbmd0aDsgKytpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHAgPSBmdW5jX2Rlc2MucGFyYW1zW2ldO1xyXG5cdFx0XHRcdGlmKCB0aGlzLmlucHV0c1tpXSApXHJcblx0XHRcdFx0XHR0aGlzLmlucHV0c1tpXS5uYW1lID0gcC5uYW1lICsgKHAudmFsdWUgPyBcIiAoXCIgKyBwLnZhbHVlICsgXCIpXCIgOiBcIlwiKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aGlzLmFkZElucHV0KCBwLm5hbWUsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRnVuYy5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXHJcblx0XHRcdHJldHVybiB0aGlzLnByb3BlcnRpZXMuZnVuYztcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIFwiRnVuY1wiO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRnVuYy5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGlua3MgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCAzOyArK2kpXHJcblx0XHRcdGlubGlua3MucHVzaCggeyBuYW1lOiBnZXRJbnB1dExpbmtJRCh0aGlzLGkpLCB0eXBlOiB0aGlzLmdldElucHV0RGF0YShpKSB8fCBcImZsb2F0XCIgfSApO1xyXG5cclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHRpZighb3V0bGluaykgLy9ub3QgY29ubmVjdGVkXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgZnVuY19kZXNjID0gR0xTTF9mdW5jdGlvbnNbIHRoaXMucHJvcGVydGllcy5mdW5jIF07XHJcblx0XHRpZighZnVuY19kZXNjKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly9mdW5jX2Rlc2NcclxuXHRcdHZhciBiYXNlX3R5cGUgPSBpbmxpbmtzWzBdLnR5cGU7XHJcblx0XHR2YXIgcmV0dXJuX3R5cGUgPSBmdW5jX2Rlc2MucmV0dXJuX3R5cGU7XHJcblx0XHRpZiggcmV0dXJuX3R5cGUgPT0gXCJUXCIgKVxyXG5cdFx0XHRyZXR1cm5fdHlwZSA9IGJhc2VfdHlwZTtcclxuXHJcblx0XHR2YXIgcGFyYW1zID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZnVuY19kZXNjLnBhcmFtcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHAgPSBmdW5jX2Rlc2MucGFyYW1zW2ldO1xyXG5cdFx0XHR2YXIgcGFyYW1fY29kZSA9IGlubGlua3NbaV0ubmFtZTtcclxuXHRcdFx0aWYocGFyYW1fY29kZSA9PSBudWxsKSAvL25vdCBwbHVnZ2VkXHJcblx0XHRcdHtcclxuXHRcdFx0XHRwYXJhbV9jb2RlID0gcC52YWx1ZSAhPSBudWxsID8gcC52YWx1ZSA6IFwiKDEuMClcIjtcclxuXHRcdFx0XHRpbmxpbmtzW2ldLnR5cGUgPSBcImZsb2F0XCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIChwLnR5cGUgPT0gXCJUXCIgJiYgaW5saW5rc1tpXS50eXBlICE9IGJhc2VfdHlwZSkgfHxcclxuXHRcdFx0XHQocC50eXBlICE9IFwiVFwiICYmIGlubGlua3NbaV0udHlwZSAhPSBiYXNlX3R5cGUpIClcclxuXHRcdFx0XHRwYXJhbV9jb2RlID0gY29udmVydFZhclRvR0xTTFR5cGUoIHBhcmFtX2NvZGUsIGlubGlua3NbaV0udHlwZSwgYmFzZV90eXBlICk7XHJcblx0XHRcdHBhcmFtcy5wdXNoKCBwYXJhbV9jb2RlICk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGNvbnRleHQuYWRkRnVuY3Rpb24oXCJyb3VuZFwiLFwiZmxvYXQgcm91bmQoZmxvYXQgdil7IHJldHVybiBmbG9vcih2KzAuNSk7IH1cXG52ZWMyIHJvdW5kKHZlYzIgdil7IHJldHVybiBmbG9vcih2K3ZlYzIoMC41KSk7fVxcbnZlYzMgcm91bmQodmVjMyB2KXsgcmV0dXJuIGZsb29yKHYrdmVjMygwLjUpKTt9XFxudmVjNCByb3VuZCh2ZWM0IHYpeyByZXR1cm4gZmxvb3Iodit2ZWM0KDAuNSkpOyB9XFxuXCIpO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gXCIrZnVuY19kZXNjLmZ1bmMrXCIoXCIrcGFyYW1zLmpvaW4oXCIsXCIpK1wiKTtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHJldHVybl90eXBlICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwibWF0aC9mdW5jXCIsIExHcmFwaFNoYWRlckZ1bmMgKTtcclxuXHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJTbmlwcGV0KClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQVwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIkNcIixcInZlYzRcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGNvZGU6XCJDID0gQStCXCIsXHJcblx0XHRcdHR5cGU6IFwidmVjNFwiXHJcblx0XHR9XHJcblx0XHR0aGlzLmFkZFdpZGdldChcInRleHRcIixcImNvZGVcIix0aGlzLnByb3BlcnRpZXMuY29kZSx7IHByb3BlcnR5OiBcImNvZGVcIiB9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcInR5cGVcIix0aGlzLnByb3BlcnRpZXMudHlwZSx7IHZhbHVlczpbXCJmbG9hdFwiLFwidmVjMlwiLFwidmVjM1wiLFwidmVjNFwiXSwgcHJvcGVydHk6IFwidHlwZVwiIH0pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyU25pcHBldC50aXRsZSA9IFwiU25pcHBldFwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJTbmlwcGV0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0dGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cclxuXHRcdGlmKG5hbWUgPT0gXCJ0eXBlXCImJiB0aGlzLm91dHB1dHNbMF0udHlwZSAhPSB2YWx1ZSlcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5kaXNjb25uZWN0T3V0cHV0KDApO1xyXG5cdFx0XHR0aGlzLm91dHB1dHNbMF0udHlwZSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyU25pcHBldC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXHJcblx0XHRcdHJldHVybiB0aGlzLnByb3BlcnRpZXMuY29kZTtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIFwiU25pcHBldFwiO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyU25pcHBldC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmtBID0gZ2V0SW5wdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdGlmKCFpbmxpbmtBKVxyXG5cdFx0XHRpbmxpbmtBID0gXCIxLjBcIjtcclxuXHRcdHZhciBpbmxpbmtCID0gZ2V0SW5wdXRMaW5rSUQodGhpcywxKTtcclxuXHRcdGlmKCFpbmxpbmtCKVxyXG5cdFx0XHRpbmxpbmtCID0gXCIxLjBcIjtcclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHRpZighb3V0bGluaykgLy9ub3QgY29ubmVjdGVkXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5BX3R5cGUgPSB0aGlzLmdldElucHV0RGF0YSgwKSB8fCBcImZsb2F0XCI7XHJcblx0XHR2YXIgaW5CX3R5cGUgPSB0aGlzLmdldElucHV0RGF0YSgxKSB8fCBcImZsb2F0XCI7XHJcblx0XHR2YXIgcmV0dXJuX3R5cGUgPSB0aGlzLnByb3BlcnRpZXMudHlwZTtcclxuXHJcblx0XHQvL2Nhbm5vdCByZXNvbHZlIGlucHV0XHJcblx0XHRpZihpbkFfdHlwZSA9PSBcIlRcIiB8fCBpbkJfdHlwZSA9PSBcIlRcIilcclxuXHRcdHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZ1bmNuYW1lID0gXCJmdW5jU25pcHBldFwiICsgdGhpcy5pZDtcclxuXHJcblx0XHR2YXIgZnVuY19jb2RlID0gXCJcXG5cIiArIHJldHVybl90eXBlICsgXCIgXCIgKyBmdW5jbmFtZSArIFwiKCBcIiArIGluQV90eXBlICsgXCIgQSwgXCIgKyBpbkJfdHlwZSArIFwiIEIpIHtcXG5cIjtcclxuXHRcdGZ1bmNfY29kZSArPSBcIlx0XCIgKyByZXR1cm5fdHlwZSArIFwiIEMgPSBcIiArIHJldHVybl90eXBlICsgXCIoMC4wKTtcXG5cIjtcclxuXHRcdGZ1bmNfY29kZSArPSBcIlx0XCIgKyB0aGlzLnByb3BlcnRpZXMuY29kZSArIFwiO1xcblwiO1xyXG5cdFx0ZnVuY19jb2RlICs9IFwiXHRyZXR1cm4gQztcXG59XFxuXCI7XHJcblxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiZnVuY3Rpb25zXCIsIGZ1bmNfY29kZSwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiK2Z1bmNuYW1lK1wiKFwiK2lubGlua0ErXCIsXCIraW5saW5rQitcIik7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCByZXR1cm5fdHlwZSApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcInV0aWxzL3NuaXBwZXRcIiwgTEdyYXBoU2hhZGVyU25pcHBldCApO1xyXG5cclxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJSYW5kKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLFwiZmxvYXRcIik7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJSYW5kLnRpdGxlID0gXCJSYW5kXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlclJhbmQucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cclxuXHRcdGNvbnRleHQuYWRkVW5pZm9ybSggXCJ1X3JhbmRcIiArIHRoaXMuaWQsIFwiZmxvYXRcIiwgZnVuY3Rpb24oKXsgcmV0dXJuIE1hdGgucmFuZG9tKCk7IH0pO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCBcImZsb2F0IFwiICsgb3V0bGluayArIFwiID0gdV9yYW5kXCIgKyB0aGlzLmlkICtcIjtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgXCJmbG9hdFwiICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiaW5wdXQvcmFuZFwiLCBMR3JhcGhTaGFkZXJSYW5kICk7XHJcblxyXG5cdC8vbm9pc2VcclxuXHQvL2h0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdHJpY2lvZ29uemFsZXp2aXZvLzY3MGMyMmYzOTY2ZTY2MmQyZjgzXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyTm9pc2UoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJvdXRcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInNjYWxlXCIsIFwiZmxvYXRcIiApO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHR0eXBlOiBcIm5vaXNlXCIsXHJcblx0XHRcdHNjYWxlOiAxXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwidHlwZVwiLCB0aGlzLnByb3BlcnRpZXMudHlwZSwgeyBwcm9wZXJ0eTogXCJ0eXBlXCIsIHZhbHVlczogTEdyYXBoU2hhZGVyTm9pc2UuTk9JU0VfVFlQRVMgfSk7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwic2NhbGVcIiwgdGhpcy5wcm9wZXJ0aWVzLnNjYWxlLCB7IHByb3BlcnR5OiBcInNjYWxlXCIgfSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJOb2lzZS5OT0lTRV9UWVBFUyA9IFtcIm5vaXNlXCIsXCJyYW5kXCJdO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJOb2lzZS50aXRsZSA9IFwibm9pc2VcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyTm9pc2UucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblxyXG5cdFx0dmFyIGludHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWlubGluaylcclxuXHRcdHtcclxuXHRcdFx0aW50eXBlID0gXCJ2ZWMyXCI7XHJcblx0XHRcdGlubGluayA9IGNvbnRleHQuYnVmZmVyX25hbWVzLnV2cztcclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0LmFkZEZ1bmN0aW9uKFwibm9pc2VcIixMR3JhcGhTaGFkZXJOb2lzZS5zaGFkZXJfZnVuY3Rpb25zKTtcclxuXHRcdGNvbnRleHQuYWRkVW5pZm9ybSggXCJ1X25vaXNlX3NjYWxlXCIgKyB0aGlzLmlkLCBcImZsb2F0XCIsIHRoaXMucHJvcGVydGllcy5zY2FsZSApO1xyXG5cdFx0aWYoIGludHlwZSA9PSBcImZsb2F0XCIgKVxyXG5cdFx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIFwiZmxvYXQgXCIgKyBvdXRsaW5rICsgXCIgPSBzbm9pc2UoIHZlYzIoXCIgKyBpbmxpbmsgK1wiKSAqIHVfbm9pc2Vfc2NhbGVcIiArIHRoaXMuaWQgK1wiKTtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdGVsc2UgaWYoIGludHlwZSA9PSBcInZlYzJcIiB8fCBpbnR5cGUgPT0gXCJ2ZWMzXCIgKVxyXG5cdFx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIFwiZmxvYXQgXCIgKyBvdXRsaW5rICsgXCIgPSBzbm9pc2UoXCIgKyBpbmxpbmsgK1wiICogdV9ub2lzZV9zY2FsZVwiICsgdGhpcy5pZCArXCIpO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0ZWxzZSBpZiggaW50eXBlID09IFwidmVjNFwiIClcclxuXHRcdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCBcImZsb2F0IFwiICsgb3V0bGluayArIFwiID0gc25vaXNlKFwiICsgaW5saW5rICtcIi54eXogKiB1X25vaXNlX3NjYWxlXCIgKyB0aGlzLmlkICtcIik7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIFwiZmxvYXRcIiApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm1hdGgvbm9pc2VcIiwgTEdyYXBoU2hhZGVyTm9pc2UgKTtcclxuXHJcbkxHcmFwaFNoYWRlck5vaXNlLnNoYWRlcl9mdW5jdGlvbnMgPSBcIlxcblxcXHJcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHsgcmV0dXJuIG1vZCgoKHgqMzQuMCkrMS4wKSp4LCAyODkuMCk7IH1cXG5cXFxyXG5cXG5cXFxyXG5mbG9hdCBzbm9pc2UodmVjMiB2KXtcXG5cXFxyXG4gIGNvbnN0IHZlYzQgQyA9IHZlYzQoMC4yMTEzMjQ4NjU0MDUxODcsIDAuMzY2MDI1NDAzNzg0NDM5LC0wLjU3NzM1MDI2OTE4OTYyNiwgMC4wMjQzOTAyNDM5MDI0MzkpO1xcblxcXHJcbiAgdmVjMiBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkgKTtcXG5cXFxyXG4gIHZlYzIgeDAgPSB2IC0gICBpICsgZG90KGksIEMueHgpO1xcblxcXHJcbiAgdmVjMiBpMTtcXG5cXFxyXG4gIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XFxuXFxcclxuICB2ZWM0IHgxMiA9IHgwLnh5eHkgKyBDLnh4eno7XFxuXFxcclxuICB4MTIueHkgLT0gaTE7XFxuXFxcclxuICBpID0gbW9kKGksIDI4OS4wKTtcXG5cXFxyXG4gIHZlYzMgcCA9IHBlcm11dGUoIHBlcm11dGUoIGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjAgKSlcXG5cXFxyXG4gICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCApKTtcXG5cXFxyXG4gIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MTIueHkseDEyLnh5KSxkb3QoeDEyLnp3LHgxMi56dykpLCAwLjApO1xcblxcXHJcbiAgbSA9IG0qbSA7XFxuXFxcclxuICBtID0gbSptIDtcXG5cXFxyXG4gIHZlYzMgeCA9IDIuMCAqIGZyYWN0KHAgKiBDLnd3dykgLSAxLjA7XFxuXFxcclxuICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XFxuXFxcclxuICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XFxuXFxcclxuICB2ZWMzIGEwID0geCAtIG94O1xcblxcXHJcbiAgbSAqPSAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqICggYTAqYTAgKyBoKmggKTtcXG5cXFxyXG4gIHZlYzMgZztcXG5cXFxyXG4gIGcueCAgPSBhMC54ICAqIHgwLnggICsgaC54ICAqIHgwLnk7XFxuXFxcclxuICBnLnl6ID0gYTAueXogKiB4MTIueHogKyBoLnl6ICogeDEyLnl3O1xcblxcXHJcbiAgcmV0dXJuIDEzMC4wICogZG90KG0sIGcpO1xcblxcXHJcbn1cXG5cXFxyXG52ZWM0IHBlcm11dGUodmVjNCB4KXtyZXR1cm4gbW9kKCgoeCozNC4wKSsxLjApKngsIDI4OS4wKTt9XFxuXFxcclxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcil7cmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjt9XFxuXFxcclxuXFxuXFxcclxuZmxvYXQgc25vaXNlKHZlYzMgdil7IFxcblxcXHJcbiAgY29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCkgO1xcblxcXHJcbiAgY29uc3QgdmVjNCAgRCA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMi4wKTtcXG5cXFxyXG5cXG5cXFxyXG4vLyBGaXJzdCBjb3JuZXJcXG5cXFxyXG4gIHZlYzMgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXl5KSApO1xcblxcXHJcbiAgdmVjMyB4MCA9ICAgdiAtIGkgKyBkb3QoaSwgQy54eHgpIDtcXG5cXFxyXG5cXG5cXFxyXG4vLyBPdGhlciBjb3JuZXJzXFxuXFxcclxuICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcXG5cXFxyXG4gIHZlYzMgbCA9IDEuMCAtIGc7XFxuXFxcclxuICB2ZWMzIGkxID0gbWluKCBnLnh5eiwgbC56eHkgKTtcXG5cXFxyXG4gIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xcblxcXHJcblxcblxcXHJcbiAgLy8gIHgwID0geDAgLSAwLiArIDAuMCAqIEMgXFxuXFxcclxuICB2ZWMzIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHh4O1xcblxcXHJcbiAgdmVjMyB4MiA9IHgwIC0gaTIgKyAyLjAgKiBDLnh4eDtcXG5cXFxyXG4gIHZlYzMgeDMgPSB4MCAtIDEuICsgMy4wICogQy54eHg7XFxuXFxcclxuXFxuXFxcclxuLy8gUGVybXV0YXRpb25zXFxuXFxcclxuICBpID0gbW9kKGksIDI4OS4wICk7IFxcblxcXHJcbiAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggXFxuXFxcclxuICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcXG5cXFxyXG4gICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKSBcXG5cXFxyXG4gICAgICAgICAgICsgaS54ICsgdmVjNCgwLjAsIGkxLngsIGkyLngsIDEuMCApKTtcXG5cXFxyXG5cXG5cXFxyXG4vLyBHcmFkaWVudHNcXG5cXFxyXG4vLyAoIE4qTiBwb2ludHMgdW5pZm9ybWx5IG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uKVxcblxcXHJcbiAgZmxvYXQgbl8gPSAxLjAvNy4wOyAvLyBOPTdcXG5cXFxyXG4gIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xcblxcXHJcblxcblxcXHJcbiAgdmVjNCBqID0gcCAtIDQ5LjAgKiBmbG9vcihwICogbnMueiAqbnMueik7ICAvLyAgbW9kKHAsTipOKVxcblxcXHJcblxcblxcXHJcbiAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG5cXFxyXG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcXG5cXFxyXG4gIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcXG5cXFxyXG4gIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XFxuXFxcclxuICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xcblxcXHJcblxcblxcXHJcbiAgdmVjNCBzMCA9IGZsb29yKGIwKSoyLjAgKyAxLjA7XFxuXFxcclxuICB2ZWM0IHMxID0gZmxvb3IoYjEpKjIuMCArIDEuMDtcXG5cXFxyXG4gIHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xcblxcXHJcblxcblxcXHJcbiAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXkgO1xcblxcXHJcbiAgdmVjNCBhMSA9IGIxLnh6eXcgKyBzMS54enl3KnNoLnp6d3cgO1xcblxcXHJcblxcblxcXHJcbiAgdmVjMyBwMCA9IHZlYzMoYTAueHksaC54KTtcXG5cXFxyXG4gIHZlYzMgcDEgPSB2ZWMzKGEwLnp3LGgueSk7XFxuXFxcclxuICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xcblxcXHJcbiAgdmVjMyBwMyA9IHZlYzMoYTEuencsaC53KTtcXG5cXFxyXG5cXG5cXFxyXG4vL05vcm1hbGlzZSBncmFkaWVudHNcXG5cXFxyXG4gIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xcblxcXHJcbiAgcDAgKj0gbm9ybS54O1xcblxcXHJcbiAgcDEgKj0gbm9ybS55O1xcblxcXHJcbiAgcDIgKj0gbm9ybS56O1xcblxcXHJcbiAgcDMgKj0gbm9ybS53O1xcblxcXHJcblxcblxcXHJcbi8vIE1peCBmaW5hbCBub2lzZSB2YWx1ZVxcblxcXHJcbiAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XFxuXFxcclxuICBtID0gbSAqIG07XFxuXFxcclxuICByZXR1cm4gNDIuMCAqIGRvdCggbSptLCB2ZWM0KCBkb3QocDAseDApLCBkb3QocDEseDEpLGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcblxcXHJcbn1cXG5cXFxyXG5cXG5cXFxyXG52ZWMzIGhhc2gzKCB2ZWMyIHAgKXtcXG5cXFxyXG4gICAgdmVjMyBxID0gdmVjMyggZG90KHAsdmVjMigxMjcuMSwzMTEuNykpLCBcXG5cXFxyXG5cdFx0XHRcdCAgIGRvdChwLHZlYzIoMjY5LjUsMTgzLjMpKSwgXFxuXFxcclxuXHRcdFx0XHQgICBkb3QocCx2ZWMyKDQxOS4yLDM3MS45KSkgKTtcXG5cXFxyXG5cdHJldHVybiBmcmFjdChzaW4ocSkqNDM3NTguNTQ1Myk7XFxuXFxcclxufVxcblxcXHJcbnZlYzQgaGFzaDQoIHZlYzMgcCApe1xcblxcXHJcbiAgICB2ZWM0IHEgPSB2ZWM0KCBkb3QocCx2ZWMzKDEyNy4xLDMxMS43LDI1Ny4zKSksIFxcblxcXHJcblx0XHRcdFx0ICAgZG90KHAsdmVjMygyNjkuNSwxODMuMywzMzUuMSkpLCBcXG5cXFxyXG5cdFx0XHRcdCAgIGRvdChwLHZlYzMoMzE0LjUsMjM1LjEsNDY3LjMpKSwgXFxuXFxcclxuXHRcdFx0XHQgICBkb3QocCx2ZWMzKDQxOS4yLDM3MS45LDExNC45KSkgKTtcXG5cXFxyXG5cdHJldHVybiBmcmFjdChzaW4ocSkqNDM3NTguNTQ1Myk7XFxuXFxcclxufVxcblxcXHJcblxcblxcXHJcbmZsb2F0IGlxbm9pc2UoIGluIHZlYzIgeCwgZmxvYXQgdSwgZmxvYXQgdiApe1xcblxcXHJcbiAgICB2ZWMyIHAgPSBmbG9vcih4KTtcXG5cXFxyXG4gICAgdmVjMiBmID0gZnJhY3QoeCk7XFxuXFxcclxuXHRcXG5cXFxyXG5cdGZsb2F0IGsgPSAxLjArNjMuMCpwb3coMS4wLXYsNC4wKTtcXG5cXFxyXG5cdFxcblxcXHJcblx0ZmxvYXQgdmEgPSAwLjA7XFxuXFxcclxuXHRmbG9hdCB3dCA9IDAuMDtcXG5cXFxyXG4gICAgZm9yKCBpbnQgaj0tMjsgajw9MjsgaisrIClcXG5cXFxyXG4gICAgZm9yKCBpbnQgaT0tMjsgaTw9MjsgaSsrIClcXG5cXFxyXG4gICAge1xcblxcXHJcbiAgICAgICAgdmVjMiBnID0gdmVjMiggZmxvYXQoaSksZmxvYXQoaikgKTtcXG5cXFxyXG5cdFx0dmVjMyBvID0gaGFzaDMoIHAgKyBnICkqdmVjMyh1LHUsMS4wKTtcXG5cXFxyXG5cdFx0dmVjMiByID0gZyAtIGYgKyBvLnh5O1xcblxcXHJcblx0XHRmbG9hdCBkID0gZG90KHIscik7XFxuXFxcclxuXHRcdGZsb2F0IHd3ID0gcG93KCAxLjAtc21vb3Roc3RlcCgwLjAsMS40MTQsc3FydChkKSksIGsgKTtcXG5cXFxyXG5cdFx0dmEgKz0gby56Knd3O1xcblxcXHJcblx0XHR3dCArPSB3dztcXG5cXFxyXG4gICAgfVxcblxcXHJcblx0XFxuXFxcclxuICAgIHJldHVybiB2YS93dDtcXG5cXFxyXG59XFxuXFxcclxuXCJcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyVGltZSgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIixcImZsb2F0XCIpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVGltZS50aXRsZSA9IFwiVGltZVwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJUaW1lLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHJcblx0XHRjb250ZXh0LmFkZFVuaWZvcm0oIFwidV90aW1lXCIgKyB0aGlzLmlkLCBcImZsb2F0XCIsIGZ1bmN0aW9uKCl7IHJldHVybiBnZXRUaW1lKCkgKiAwLjAwMTsgfSk7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIFwiZmxvYXQgXCIgKyBvdXRsaW5rICsgXCIgPSB1X3RpbWVcIiArIHRoaXMuaWQgK1wiO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBcImZsb2F0XCIgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJpbnB1dC90aW1lXCIsIExHcmFwaFNoYWRlclRpbWUgKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckRpdGhlcigpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsXCJUXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIixcImZsb2F0XCIpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRGl0aGVyLnRpdGxlID0gXCJEaXRoZXJcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyRGl0aGVyLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHR2YXIgcmV0dXJuX3R5cGUgPSBcImZsb2F0XCI7XHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0dmFyIGludHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aW5saW5rID0gdmFyVG9UeXBlR0xTTCggaW5saW5rLCBpbnR5cGUsIFwiZmxvYXRcIiApO1xyXG5cdFx0Y29udGV4dC5hZGRGdW5jdGlvbihcImRpdGhlcjh4OFwiLCBMR3JhcGhTaGFkZXJEaXRoZXIuZGl0aGVyX2Z1bmMpO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gZGl0aGVyOHg4KFwiKyBpbmxpbmsgK1wiKTtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgcmV0dXJuX3R5cGUgKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckRpdGhlci5kaXRoZXJfdmFsdWVzID0gWzAuNTE1NjI1LDAuMTQwNjI1LDAuNjQwNjI1LDAuMDQ2ODc1LDAuNTQ2ODc1LDAuMTcxODc1LDAuNjcxODc1LDAuNzY1NjI1LDAuMjY1NjI1LDAuODkwNjI1LDAuMzkwNjI1LDAuNzk2ODc1LDAuMjk2ODc1LDAuOTIxODc1LDAuNDIxODc1LDAuMjAzMTI1LDAuNzAzMTI1LDAuMDc4MTI1LDAuNTc4MTI1LDAuMjM0Mzc1LDAuNzM0Mzc1LDAuMTA5Mzc1LDAuNjA5Mzc1LDAuOTUzMTI1LDAuNDUzMTI1LDAuODI4MTI1LDAuMzI4MTI1LDAuOTg0Mzc1LDAuNDg0Mzc1LDAuODU5Mzc1LDAuMzU5Mzc1LDAuMDYyNSwwLjU2MjUsMC4xODc1LDAuNjg3NSwwLjAzMTI1LDAuNTMxMjUsMC4xNTYyNSwwLjY1NjI1LDAuODEyNSwwLjMxMjUsMC45Mzc1LDAuNDM3NSwwLjc4MTI1LDAuMjgxMjUsMC45MDYyNSwwLjQwNjI1LDAuMjUsMC43NSwwLjEyNSwwLjYyNSwwLjIxODc1LDAuNzE4NzUsMC4wOTM3NSwwLjU5Mzc1LDEuMDAwMSwwLjUsMC44NzUsMC4zNzUsMC45Njg3NSwwLjQ2ODc1LDAuODQzNzUsMC4zNDM3NV07XHJcblx0XHJcblx0TEdyYXBoU2hhZGVyRGl0aGVyLmRpdGhlcl9mdW5jID0gXCJcXG5cXFxyXG5cdFx0ZmxvYXQgZGl0aGVyOHg4KGZsb2F0IGJyaWdodG5lc3MpIHtcXG5cXFxyXG5cdFx0ICB2ZWMyIHBvc2l0aW9uID0gdmVjMigwLjApO1xcblxcXHJcblx0XHQgICNpZmRlZiBGUkFHTUVOVFxcblxcXHJcblx0XHRcdHBvc2l0aW9uID0gZ2xfRnJhZ0Nvb3JkLnh5O1xcblxcXHJcblx0XHQgICNlbmRpZlxcblxcXHJcblx0XHQgIGludCB4ID0gaW50KG1vZChwb3NpdGlvbi54LCA4LjApKTtcXG5cXFxyXG5cdFx0ICBpbnQgeSA9IGludChtb2QocG9zaXRpb24ueSwgOC4wKSk7XFxuXFxcclxuXHRcdCAgaW50IGluZGV4ID0geCArIHkgKiA4O1xcblxcXHJcblx0XHQgIGZsb2F0IGxpbWl0ID0gMC4wO1xcblxcXHJcblx0XHQgIGlmICh4IDwgOCkge1xcblxcXHJcblx0XHRcdGlmKGluZGV4PT0wKSBsaW1pdCA9IDAuMDE1NjI1O1xcblxcXHJcblx0XHRcdFwiKyhMR3JhcGhTaGFkZXJEaXRoZXIuZGl0aGVyX3ZhbHVlcy5tYXAoIGZ1bmN0aW9uKHYsaSl7IHJldHVybiBcImVsc2UgaWYoaW5kZXg9PSBcIisoaSsxKStcIikgbGltaXQgPSBcIiArIHYgKyBcIjtcIn0pLmpvaW4oXCJcXG5cIikpK1wiXFxuXFxcclxuXHRcdCAgfVxcblxcXHJcblx0XHQgIHJldHVybiBicmlnaHRuZXNzIDwgbGltaXQgPyAwLjAgOiAxLjA7XFxuXFxcclxuXHRcdH1cXG5cIixcclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm1hdGgvZGl0aGVyXCIsIExHcmFwaFNoYWRlckRpdGhlciApO1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJSZW1hcCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIlwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLFwiXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRtaW5fdmFsdWU6IDAsXHJcblx0XHRcdG1heF92YWx1ZTogMSxcclxuXHRcdFx0bWluX3ZhbHVlMjogMCxcclxuXHRcdFx0bWF4X3ZhbHVlMjogMVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJtaW5cIiwwLHsgc3RlcDogMC4xLCBwcm9wZXJ0eTogXCJtaW5fdmFsdWVcIiB9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJtYXhcIiwxLHsgc3RlcDogMC4xLCBwcm9wZXJ0eTogXCJtYXhfdmFsdWVcIiB9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJtaW4yXCIsMCx7IHN0ZXA6IDAuMSwgcHJvcGVydHk6IFwibWluX3ZhbHVlMlwifSk7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwibWF4MlwiLDEseyBzdGVwOiAwLjEsIHByb3BlcnR5OiBcIm1heF92YWx1ZTJcIn0pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyUmVtYXAudGl0bGUgPSBcIlJlbWFwXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlclJlbWFwLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJSZW1hcC5wcm90b3R5cGUub25Db25uZWN0aW9uc0NoYW5nZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgcmV0dXJuX3R5cGUgPSB0aGlzLmdldElucHV0RGF0YVR5cGUoMCk7XHJcblx0XHR0aGlzLm91dHB1dHNbMF0udHlwZSA9IHJldHVybl90eXBlIHx8IFwiVFwiO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyUmVtYXAucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHRpZighaW5saW5rICYmICFvdXRsaW5rKSAvL25vdCBjb25uZWN0ZWRcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciByZXR1cm5fdHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhVHlwZSgwKTtcclxuXHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gcmV0dXJuX3R5cGU7XHJcblx0XHRpZihyZXR1cm5fdHlwZSA9PSBcIlRcIilcclxuXHRcdHtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwibm9kZSB0eXBlIGlzIFQgYW5kIGNhbm5vdCBiZSByZXNvbHZlZFwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCFpbmxpbmspXHJcblx0XHR7XHJcblx0XHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIixcIlx0XCIgKyByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gXCIgKyByZXR1cm5fdHlwZSArIFwiKDAuMCk7XFxuXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1pbnYgPSB2YWx1ZVRvR0xTTCggdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSApO1xyXG5cdFx0dmFyIG1heHYgPSB2YWx1ZVRvR0xTTCggdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZSApO1xyXG5cdFx0dmFyIG1pbnYyID0gdmFsdWVUb0dMU0woIHRoaXMucHJvcGVydGllcy5taW5fdmFsdWUyICk7XHJcblx0XHR2YXIgbWF4djIgPSB2YWx1ZVRvR0xTTCggdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZTIgKTtcclxuXHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSAoIChcIiArIGlubGluayArIFwiIC0gXCIrbWluditcIikgLyAoXCIrIG1heHYrXCIgLSBcIittaW52K1wiKSApICogKFwiKyBtYXh2MitcIiAtIFwiK21pbnYyK1wiKSArIFwiICsgbWludjIgKyBcIjtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgcmV0dXJuX3R5cGUgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJtYXRoL3JlbWFwXCIsIExHcmFwaFNoYWRlclJlbWFwICk7XHJcblxyXG59KSh0aGlzKTtcclxuXHJcblxyXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cclxuXHR2YXIgdmlld19tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHR2YXIgcHJvamVjdGlvbl9tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHR2YXIgdmlld3Byb2plY3Rpb25fbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblx0dmFyIG1vZGVsX21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cdHZhciBnbG9iYWxfdW5pZm9ybXMgPSB7XHJcblx0XHR1X3ZpZXc6IHZpZXdfbWF0cml4LFxyXG5cdFx0dV9wcm9qZWN0aW9uOiBwcm9qZWN0aW9uX21hdHJpeCxcclxuXHRcdHVfdmlld3Byb2plY3Rpb246IHZpZXdwcm9qZWN0aW9uX21hdHJpeCxcclxuXHRcdHVfbW9kZWw6IG1vZGVsX21hdHJpeCBcclxuXHR9O1xyXG5cclxuXHRMaXRlR3JhcGguTEdyYXBoUmVuZGVyID0ge1xyXG5cdFx0b25SZXF1ZXN0Q2FtZXJhTWF0cmljZXM6IG51bGwgLy9vdmVyd3JpdGUgd2l0aCB5b3VyIDNEIGVuZ2luZSBzcGVjaWZpY3MsIGl0IHdpbGwgcmVjZWl2ZSAodmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCkgYW5kIG11c3QgYmUgZmlsbGVkXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2VuZXJhdGVHZW9tZXRyeUlkKCkge1xyXG5cdFx0cmV0dXJuIChNYXRoLnJhbmRvbSgpICogMTAwMDAwKXwwO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoUG9pbnRzM0QoKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm9ialwiLCBcIlwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJyYWRpdXNcIiwgXCJudW1iZXJcIik7XHJcblxyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwicG9pbnRzXCIsIFwiW3ZlYzNdXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRyYWRpdXM6IDEsXHJcblx0XHRcdG51bV9wb2ludHM6IDQwOTYsXHJcblx0XHRcdGdlbmVyYXRlX25vcm1hbHM6IHRydWUsXHJcblx0XHRcdHJlZ3VsYXI6IGZhbHNlLFxyXG5cdFx0XHRtb2RlOiBMR3JhcGhQb2ludHMzRC5TUEhFUkUsXHJcblx0XHRcdGZvcmNlX3VwZGF0ZTogZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnByb3BlcnRpZXMubnVtX3BvaW50cyAqIDMgKTtcclxuXHRcdHRoaXMubm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMucHJvcGVydGllcy5udW1fcG9pbnRzICogMyApO1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsXCJ1cGRhdGVcIixudWxsLCBmdW5jdGlvbigpeyB0aGF0Lm11c3RfdXBkYXRlID0gdHJ1ZTsgfSk7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IHtcclxuXHRcdFx0dmVydGljZXM6IG51bGwsXHJcblx0XHRcdF9pZDogZ2VuZXJhdGVHZW9tZXRyeUlkKClcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9vbGRfb2JqID0gbnVsbDtcclxuXHRcdHRoaXMuX2xhc3RfcmFkaXVzID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdGdsb2JhbC5MR3JhcGhQb2ludHMzRCA9IExHcmFwaFBvaW50czNEO1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5SRUNUQU5HTEUgPSAxO1xyXG5cdExHcmFwaFBvaW50czNELkNJUkNMRSA9IDI7XHJcblxyXG5cdExHcmFwaFBvaW50czNELkNVQkUgPSAxMDtcclxuXHRMR3JhcGhQb2ludHMzRC5TUEhFUkUgPSAxMTtcclxuXHRMR3JhcGhQb2ludHMzRC5IRU1JU1BIRVJFID0gMTI7XHJcblx0TEdyYXBoUG9pbnRzM0QuSU5TSURFX1NQSEVSRSA9IDEzO1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5PQkpFQ1QgPSAyMDtcclxuXHRMR3JhcGhQb2ludHMzRC5PQkpFQ1RfVU5JRk9STUxZID0gMjE7XHJcblx0TEdyYXBoUG9pbnRzM0QuT0JKRUNUX0lOU0lERSA9IDIyO1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5NT0RFX1ZBTFVFUyA9IHsgXCJyZWN0YW5nbGVcIjpMR3JhcGhQb2ludHMzRC5SRUNUQU5HTEUsIFwiY2lyY2xlXCI6TEdyYXBoUG9pbnRzM0QuQ0lSQ0xFLCBcImN1YmVcIjpMR3JhcGhQb2ludHMzRC5DVUJFLCBcInNwaGVyZVwiOkxHcmFwaFBvaW50czNELlNQSEVSRSwgXCJoZW1pc3BoZXJlXCI6TEdyYXBoUG9pbnRzM0QuSEVNSVNQSEVSRSwgXCJpbnNpZGVfc3BoZXJlXCI6TEdyYXBoUG9pbnRzM0QuSU5TSURFX1NQSEVSRSwgXCJvYmplY3RcIjpMR3JhcGhQb2ludHMzRC5PQkpFQ1QsIFwib2JqZWN0X3VuaWZvcm1seVwiOkxHcmFwaFBvaW50czNELk9CSkVDVF9VTklGT1JNTFksIFwib2JqZWN0X2luc2lkZVwiOkxHcmFwaFBvaW50czNELk9CSkVDVF9JTlNJREUgfTtcclxuXHJcblx0TEdyYXBoUG9pbnRzM0Qud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0bW9kZTogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhQb2ludHMzRC5NT0RFX1ZBTFVFUyB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoUG9pbnRzM0QudGl0bGUgPSBcImxpc3Qgb2YgcG9pbnRzXCI7XHJcblx0TEdyYXBoUG9pbnRzM0QuZGVzYyA9IFwicmV0dXJucyBhbiBhcnJheSBvZiBwb2ludHNcIjtcclxuXHJcblx0TEdyYXBoUG9pbnRzM0QucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZiggb2JqICE9IHRoaXMuX29sZF9vYmogfHwgKG9iaiAmJiBvYmouX3ZlcnNpb24gIT0gdGhpcy5fb2xkX29ial92ZXJzaW9uKSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuX29sZF9vYmogPSBvYmo7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByYWRpdXMgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKHJhZGl1cyA9PSBudWxsKVxyXG5cdFx0XHRyYWRpdXMgPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzO1xyXG5cdFx0aWYoIHRoaXMuX2xhc3RfcmFkaXVzICE9IHJhZGl1cyApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuX2xhc3RfcmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLm11c3RfdXBkYXRlIHx8IHRoaXMucHJvcGVydGllcy5mb3JjZV91cGRhdGUgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMudXBkYXRlUG9pbnRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyA9IHRoaXMucG9pbnRzO1xyXG5cdFx0dGhpcy5nZW9tZXRyeS5ub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xyXG5cdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMuZ2VvbWV0cnkgKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELnByb3RvdHlwZS51cGRhdGVQb2ludHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBudW1fcG9pbnRzID0gdGhpcy5wcm9wZXJ0aWVzLm51bV9wb2ludHN8MDtcclxuXHRcdGlmKG51bV9wb2ludHMgPCAxKVxyXG5cdFx0XHRudW1fcG9pbnRzID0gMTtcclxuXHJcblx0XHRpZighdGhpcy5wb2ludHMgfHwgdGhpcy5wb2ludHMubGVuZ3RoICE9IG51bV9wb2ludHMgKiAzKVxyXG5cdFx0XHR0aGlzLnBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bV9wb2ludHMgKiAzICk7XHJcblxyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLmdlbmVyYXRlX25vcm1hbHMpXHJcblx0XHR7XHJcblx0XHRcdGlmICghdGhpcy5ub3JtYWxzIHx8IHRoaXMubm9ybWFscy5sZW5ndGggIT0gdGhpcy5wb2ludHMubGVuZ3RoKVxyXG5cdFx0XHRcdHRoaXMubm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMucG9pbnRzLmxlbmd0aCApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLm5vcm1hbHMgPSBudWxsO1xyXG5cclxuXHRcdHZhciByYWRpdXMgPSB0aGlzLl9sYXN0X3JhZGl1cyB8fCB0aGlzLnByb3BlcnRpZXMucmFkaXVzO1xyXG5cdFx0dmFyIG1vZGUgPSB0aGlzLnByb3BlcnRpZXMubW9kZTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHR0aGlzLl9vbGRfb2JqX3ZlcnNpb24gPSBvYmogPyBvYmouX3ZlcnNpb24gOiBudWxsO1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gTEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVQb2ludHMoIHJhZGl1cywgbnVtX3BvaW50cywgbW9kZSwgdGhpcy5wb2ludHMsIHRoaXMubm9ybWFscywgdGhpcy5wcm9wZXJ0aWVzLnJlZ3VsYXIsIG9iaiApO1xyXG5cclxuXHRcdHRoaXMudmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0Ly9nbG9iYWxcclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVBvaW50cyA9IGZ1bmN0aW9uKCByYWRpdXMsIG51bV9wb2ludHMsIG1vZGUsIHBvaW50cywgbm9ybWFscywgcmVndWxhciwgb2JqIClcclxuXHR7XHJcblx0XHR2YXIgc2l6ZSA9IG51bV9wb2ludHMgKiAzO1xyXG5cdFx0aWYoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoICE9IHNpemUpXHJcblx0XHRcdHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKTtcclxuXHRcdHZhciB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuXHRcdHZhciBVUCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwXSk7XHJcblxyXG5cdFx0aWYocmVndWxhcilcclxuXHRcdHtcclxuXHRcdFx0aWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuUkVDVEFOR0xFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHNpZGUgPSBNYXRoLmZsb29yKE1hdGguc3FydChudW1fcG9pbnRzKSk7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpZGU7ICsraSlcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgc2lkZTsgKytqKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBwb3MgPSBpKjMgKyBqKjMqc2lkZTtcclxuXHRcdFx0XHRcdHBvaW50c1twb3NdID0gKChpL3NpZGUpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0XHRwb2ludHNbcG9zKzFdID0gMDtcclxuXHRcdFx0XHRcdHBvaW50c1twb3MrMl0gPSAoKGovc2lkZSkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSggcG9pbnRzLnN1YmFycmF5KDAsc2lkZSpzaWRlKjMpICk7XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrPTMpXHJcblx0XHRcdFx0XHRcdG5vcm1hbHMuc2V0KFVQLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5TUEhFUkUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgc2lkZSA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KG51bV9wb2ludHMpKTtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2lkZTsgKytpKVxyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBzaWRlOyArK2opXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIHBvcyA9IGkqMyArIGoqMypzaWRlO1xyXG5cdFx0XHRcdFx0cG9sYXJUb0NhcnRlc2lhbiggdGVtcCwgKGkvc2lkZSkgKiAyICogTWF0aC5QSSwgKChqL3NpZGUpIC0gMC41KSAqIDIgKiBNYXRoLlBJLCByYWRpdXMgKTtcclxuXHRcdFx0XHRcdHBvaW50c1twb3NdID0gdGVtcFswXTtcclxuXHRcdFx0XHRcdHBvaW50c1twb3MrMV0gPSB0ZW1wWzFdO1xyXG5cdFx0XHRcdFx0cG9pbnRzW3BvcysyXSA9IHRlbXBbMl07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvaW50cy5zdWJhcnJheSgwLHNpZGUqc2lkZSozKSApO1xyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMoIHBvaW50cywgbm9ybWFscyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuQ0lSQ0xFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiAoaS9zaXplKTtcclxuXHRcdFx0XHRcdHBvaW50c1tpXSA9IE1hdGguY29zKCBhbmdsZSApICogcmFkaXVzO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2krMV0gPSAwO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2krMl0gPSBNYXRoLnNpbiggYW5nbGUgKSAqIHJhZGl1cztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrPTMpXHJcblx0XHRcdFx0XHRcdG5vcm1hbHMuc2V0KFVQLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgLy9ub24gcmVndWxhclxyXG5cdFx0e1xyXG5cdFx0XHRpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5SRUNUQU5HTEUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRwb2ludHNbaV0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2krMV0gPSAwO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2krMl0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSs9MylcclxuXHRcdFx0XHRcdFx0bm9ybWFscy5zZXQoVVAsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELkNVQkUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRwb2ludHNbaV0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2krMV0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2krMl0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSs9MylcclxuXHRcdFx0XHRcdFx0bm9ybWFscy5zZXQoVVAsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELlNQSEVSRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJlKCBwb2ludHMsIHNpemUsIHJhZGl1cyApO1xyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMoIHBvaW50cywgbm9ybWFscyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuSEVNSVNQSEVSRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlSGVtaXNwaGVyZSggcG9pbnRzLCBzaXplLCByYWRpdXMgKTtcclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzKCBwb2ludHMsIG5vcm1hbHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELkNJUkNMRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlSW5zaWRlQ2lyY2xlKCBwb2ludHMsIHNpemUsIHJhZGl1cyApO1xyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMoIHBvaW50cywgbm9ybWFscyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuSU5TSURFX1NQSEVSRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlSW5zaWRlU3BoZXJlKCBwb2ludHMsIHNpemUsIHJhZGl1cyApO1xyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMoIHBvaW50cywgbm9ybWFscyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuT0JKRUNUKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVGcm9tT2JqZWN0KCBwb2ludHMsIG5vcm1hbHMsIHNpemUsIG9iaiwgZmFsc2UgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELk9CSkVDVF9VTklGT1JNTFkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUZyb21PYmplY3QoIHBvaW50cywgbm9ybWFscywgc2l6ZSwgb2JqLCB0cnVlICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5PQkpFQ1RfSU5TSURFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVGcm9tSW5zaWRlT2JqZWN0KCBwb2ludHMsIHNpemUsIG9iaiApO1xyXG5cdFx0XHRcdC8vaWYobm9ybWFscylcclxuXHRcdFx0XHQvL1x0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzKCBwb2ludHMsIG5vcm1hbHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwid3JvbmcgbW9kZSBpbiBMR3JhcGhQb2ludHMzRFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzID0gZnVuY3Rpb24ocG9pbnRzLCBub3JtYWxzKVxyXG5cdHtcclxuXHRcdHZhciB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dGVtcFswXSA9IHBvaW50c1tpXTtcclxuXHRcdFx0dGVtcFsxXSA9IHBvaW50c1tpKzFdO1xyXG5cdFx0XHR0ZW1wWzJdID0gcG9pbnRzW2krMl07XHJcblx0XHRcdHZlYzMubm9ybWFsaXplKHRlbXAsdGVtcCk7XHJcblx0XHRcdG5vcm1hbHMuc2V0KHRlbXAsaSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyZSA9IGZ1bmN0aW9uIChwb2ludHMsIHNpemUsIHJhZGl1cylcclxuXHR7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dmFyIHIxID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHIyID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHggPSAyICogTWF0aC5jb3MoIDIgKiBNYXRoLlBJICogcjEgKSAqIE1hdGguc3FydCggcjIgKiAoMS1yMikgKTtcclxuXHRcdFx0dmFyIHkgPSAxIC0gMiAqIHIyO1xyXG5cdFx0XHR2YXIgeiA9IDIgKiBNYXRoLnNpbiggMiAqIE1hdGguUEkgKiByMSApICogTWF0aC5zcXJ0KCByMiAqICgxLXIyKSApO1xyXG5cdFx0XHRwb2ludHNbaV0gPSB4ICogcmFkaXVzO1xyXG5cdFx0XHRwb2ludHNbaSsxXSA9IHkgKiByYWRpdXM7XHJcblx0XHRcdHBvaW50c1tpKzJdID0geiAqIHJhZGl1cztcclxuXHRcdH1cdFx0XHRcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlSGVtaXNwaGVyZSA9IGZ1bmN0aW9uIChwb2ludHMsIHNpemUsIHJhZGl1cylcclxuXHR7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dmFyIHIxID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHIyID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHggPSBNYXRoLmNvcyggMiAqIE1hdGguUEkgKiByMSApICogTWF0aC5zcXJ0KDEgLSByMipyMiApO1xyXG5cdFx0XHR2YXIgeSA9IHIyO1xyXG5cdFx0XHR2YXIgeiA9IE1hdGguc2luKCAyICogTWF0aC5QSSAqIHIxICkgKiBNYXRoLnNxcnQoMSAtIHIyKnIyICk7XHJcblx0XHRcdHBvaW50c1tpXSA9IHggKiByYWRpdXM7XHJcblx0XHRcdHBvaW50c1tpKzFdID0geSAqIHJhZGl1cztcclxuXHRcdFx0cG9pbnRzW2krMl0gPSB6ICogcmFkaXVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVJbnNpZGVDaXJjbGUgPSBmdW5jdGlvbiAocG9pbnRzLCBzaXplLCByYWRpdXMpXHJcblx0e1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHZhciByMSA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciByMiA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciB4ID0gTWF0aC5jb3MoIDIgKiBNYXRoLlBJICogcjEgKSAqIE1hdGguc3FydCgxIC0gcjIqcjIgKTtcclxuXHRcdFx0dmFyIHkgPSByMjtcclxuXHRcdFx0dmFyIHogPSBNYXRoLnNpbiggMiAqIE1hdGguUEkgKiByMSApICogTWF0aC5zcXJ0KDEgLSByMipyMiApO1xyXG5cdFx0XHRwb2ludHNbaV0gPSB4ICogcmFkaXVzO1xyXG5cdFx0XHRwb2ludHNbaSsxXSA9IDA7XHJcblx0XHRcdHBvaW50c1tpKzJdID0geiAqIHJhZGl1cztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlSW5zaWRlU3BoZXJlID0gZnVuY3Rpb24gKHBvaW50cywgc2l6ZSwgcmFkaXVzKVxyXG5cdHtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdSA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciB2ID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHRoZXRhID0gdSAqIDIuMCAqIE1hdGguUEk7XHJcblx0XHRcdHZhciBwaGkgPSBNYXRoLmFjb3MoMi4wICogdiAtIDEuMCk7XHJcblx0XHRcdHZhciByID0gTWF0aC5jYnJ0KE1hdGgucmFuZG9tKCkpICogcmFkaXVzO1xyXG5cdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XHJcblx0XHRcdHZhciBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcclxuXHRcdFx0dmFyIHNpblBoaSA9IE1hdGguc2luKHBoaSk7XHJcblx0XHRcdHZhciBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xyXG5cdFx0XHRwb2ludHNbaV0gPSByICogc2luUGhpICogY29zVGhldGE7XHJcblx0XHRcdHBvaW50c1tpKzFdID0gciAqIHNpblBoaSAqIHNpblRoZXRhO1xyXG5cdFx0XHRwb2ludHNbaSsyXSA9IHIgKiBjb3NQaGk7XHJcblx0XHR9XHRcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZpbmRSYW5kb21UcmlhbmdsZSggYXJlYXMsIGYgKVxyXG5cdHtcclxuXHRcdHZhciBsID0gYXJlYXMubGVuZ3RoO1xyXG5cdFx0dmFyIGltaW4gPSAwO1xyXG5cdFx0dmFyIGltaWQgPSAwO1xyXG5cdFx0dmFyIGltYXggPSBsO1xyXG5cclxuXHRcdGlmKGwgPT0gMClcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0aWYobCA9PSAxKVxyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdC8vZGljaG90aW1pYyBzZWFyY2hcclxuXHRcdHdoaWxlIChpbWF4ID49IGltaW4pXHJcblx0XHR7XHJcblx0XHRcdGltaWQgPSAoKGltYXggKyBpbWluKSowLjUpfDA7XHJcblx0XHRcdHZhciB0ID0gYXJlYXNbIGltaWQgXTtcclxuXHRcdFx0aWYoIHQgPT0gZiApXHJcblx0XHRcdFx0cmV0dXJuIGltaWQ7IFxyXG5cdFx0XHRpZiggaW1pbiA9PSAoaW1heCAtIDEpIClcclxuXHRcdFx0XHRyZXR1cm4gaW1pbjtcclxuXHRcdFx0aWYgKHQgPCBmKVxyXG5cdFx0XHRcdGltaW4gPSBpbWlkO1xyXG5cdFx0XHRlbHNlICAgICAgICAgXHJcblx0XHRcdFx0aW1heCA9IGltaWQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW1pZDtcdFx0XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUZyb21PYmplY3QgPSBmdW5jdGlvbiggcG9pbnRzLCBub3JtYWxzLCBzaXplLCBvYmosIGV2ZW5seSApXHJcblx0e1xyXG5cdFx0aWYoIW9iailcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IG51bGw7XHJcblx0XHR2YXIgbWVzaF9ub3JtYWxzID0gbnVsbDtcclxuXHRcdHZhciBpbmRpY2VzID0gbnVsbDtcclxuXHRcdHZhciBhcmVhcyA9IG51bGw7XHJcblx0XHRpZiggb2JqLmNvbnN0cnVjdG9yID09PSBHTC5NZXNoIClcclxuXHRcdHtcclxuXHRcdFx0dmVydGljZXMgPSBvYmoudmVydGV4QnVmZmVycy52ZXJ0aWNlcy5kYXRhO1xyXG5cdFx0XHRtZXNoX25vcm1hbHMgPSBvYmoudmVydGV4QnVmZmVycy5ub3JtYWxzID8gb2JqLnZlcnRleEJ1ZmZlcnMubm9ybWFscy5kYXRhIDogbnVsbDtcclxuXHRcdFx0aW5kaWNlcyA9IG9iai5pbmRleEJ1ZmZlcnMuaW5kaWNlcyA/IG9iai5pbmRleEJ1ZmZlcnMuaW5kaWNlcy5kYXRhIDogbnVsbDtcclxuXHRcdFx0aWYoIWluZGljZXMpXHJcblx0XHRcdFx0aW5kaWNlcyA9IG9iai5pbmRleEJ1ZmZlcnMudHJpYW5nbGVzID8gb2JqLmluZGV4QnVmZmVycy50cmlhbmdsZXMuZGF0YSA6IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZighdmVydGljZXMpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0dmFyIG51bV90cmlhbmdsZXMgPSBpbmRpY2VzID8gaW5kaWNlcy5sZW5ndGggLyAzIDogdmVydGljZXMubGVuZ3RoIC8gKDMqMyk7XHJcblx0XHR2YXIgdG90YWxfYXJlYSA9IDA7IC8vc3VtIG9mIGFyZWFzIG9mIGFsbCB0cmlhbmdsZXNcclxuXHJcblx0XHRpZihldmVubHkpXHJcblx0XHR7XHJcblx0XHRcdGFyZWFzID0gbmV3IEZsb2F0MzJBcnJheShudW1fdHJpYW5nbGVzKTsgLy9hY2N1bVxyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtX3RyaWFuZ2xlczsgKytpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYoaW5kaWNlcylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRhID0gaW5kaWNlc1tpKjNdKjM7XHJcblx0XHRcdFx0XHRiID0gaW5kaWNlc1tpKjMrMV0qMztcclxuXHRcdFx0XHRcdGMgPSBpbmRpY2VzW2kqMysyXSozO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0YSA9IGkqOTtcclxuXHRcdFx0XHRcdGIgPSBpKjkrMztcclxuXHRcdFx0XHRcdGMgPSBpKjkrNjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIFAxID0gdmVydGljZXMuc3ViYXJyYXkoYSxhKzMpO1xyXG5cdFx0XHRcdHZhciBQMiA9IHZlcnRpY2VzLnN1YmFycmF5KGIsYiszKTtcclxuXHRcdFx0XHR2YXIgUDMgPSB2ZXJ0aWNlcy5zdWJhcnJheShjLGMrMyk7XHJcblx0XHRcdFx0dmFyIGFMID0gdmVjMy5kaXN0YW5jZSggUDEsIFAyICk7XHJcblx0XHRcdFx0dmFyIGJMID0gdmVjMy5kaXN0YW5jZSggUDIsIFAzICk7XHJcblx0XHRcdFx0dmFyIGNMID0gdmVjMy5kaXN0YW5jZSggUDMsIFAxICk7XHJcblx0XHRcdFx0dmFyIHMgPSAoYUwgKyBiTCsgY0wpIC8gMjtcclxuXHRcdFx0XHR0b3RhbF9hcmVhICs9IE1hdGguc3FydChzICogKHMgLSBhTCkgKiAocyAtIGJMKSAqIChzIC0gY0wpKTtcclxuXHRcdFx0XHRhcmVhc1tpXSA9IHRvdGFsX2FyZWE7XHJcblx0XHRcdH1cdFx0XHRcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG51bV90cmlhbmdsZXM7ICsraSkgLy9ub3JtYWxpemVcclxuXHRcdFx0XHRhcmVhc1tpXSAvPSB0b3RhbF9hcmVhO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgciA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciBpbmRleCA9IGV2ZW5seSA/IGZpbmRSYW5kb21UcmlhbmdsZSggYXJlYXMsIHIgKSA6IE1hdGguZmxvb3IociAqIG51bV90cmlhbmdsZXMgKTtcclxuXHRcdFx0Ly9nZXQgcmFuZG9tIHRyaWFuZ2xlXHJcblx0XHRcdHZhciBhID0gMDtcclxuXHRcdFx0dmFyIGIgPSAwO1xyXG5cdFx0XHR2YXIgYyA9IDA7XHJcblx0XHRcdGlmKGluZGljZXMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRhID0gaW5kaWNlc1tpbmRleCozXSozO1xyXG5cdFx0XHRcdGIgPSBpbmRpY2VzW2luZGV4KjMrMV0qMztcclxuXHRcdFx0XHRjID0gaW5kaWNlc1tpbmRleCozKzJdKjM7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0YSA9IGluZGV4Kjk7XHJcblx0XHRcdFx0YiA9IGluZGV4KjkrMztcclxuXHRcdFx0XHRjID0gaW5kZXgqOSs2O1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBzID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgc3FydF9zID0gTWF0aC5zcXJ0KHMpO1xyXG5cdFx0XHR2YXIgYWYgPSAxIC0gc3FydF9zO1xyXG5cdFx0XHR2YXIgYmYgPSBzcXJ0X3MgKiAoIDEgLSB0KTtcclxuXHRcdFx0dmFyIGNmID0gdCAqIHNxcnRfcztcclxuXHRcdFx0cG9pbnRzW2ldID0gYWYgKiB2ZXJ0aWNlc1thXSArIGJmKnZlcnRpY2VzW2JdICsgY2YqdmVydGljZXNbY107XHJcblx0XHRcdHBvaW50c1tpKzFdID0gYWYgKiB2ZXJ0aWNlc1thKzFdICsgYmYqdmVydGljZXNbYisxXSArIGNmKnZlcnRpY2VzW2MrMV07XHJcblx0XHRcdHBvaW50c1tpKzJdID0gYWYgKiB2ZXJ0aWNlc1thKzJdICsgYmYqdmVydGljZXNbYisyXSArIGNmKnZlcnRpY2VzW2MrMl07XHJcblx0XHRcdGlmKG5vcm1hbHMgJiYgbWVzaF9ub3JtYWxzKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bm9ybWFsc1tpXSA9IGFmICogbWVzaF9ub3JtYWxzW2FdICsgYmYqbWVzaF9ub3JtYWxzW2JdICsgY2YqbWVzaF9ub3JtYWxzW2NdO1xyXG5cdFx0XHRcdG5vcm1hbHNbaSsxXSA9IGFmICogbWVzaF9ub3JtYWxzW2ErMV0gKyBiZiptZXNoX25vcm1hbHNbYisxXSArIGNmKm1lc2hfbm9ybWFsc1tjKzFdO1xyXG5cdFx0XHRcdG5vcm1hbHNbaSsyXSA9IGFmICogbWVzaF9ub3JtYWxzW2ErMl0gKyBiZiptZXNoX25vcm1hbHNbYisyXSArIGNmKm1lc2hfbm9ybWFsc1tjKzJdO1xyXG5cdFx0XHRcdHZhciBOID0gbm9ybWFscy5zdWJhcnJheShpLGkrMyk7XHJcblx0XHRcdFx0dmVjMy5ub3JtYWxpemUoTixOKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVGcm9tSW5zaWRlT2JqZWN0ID0gZnVuY3Rpb24oIHBvaW50cywgc2l6ZSwgbWVzaCApXHJcblx0e1xyXG5cdFx0aWYoIW1lc2ggfHwgbWVzaC5jb25zdHJ1Y3RvciAhPT0gR0wuTWVzaClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBhYWJiID0gbWVzaC5nZXRCb3VuZGluZ0JveCgpO1xyXG5cdFx0aWYoIW1lc2gub2N0cmVlKVxyXG5cdFx0XHRtZXNoLm9jdHJlZSA9IG5ldyBHTC5PY3RyZWUoIG1lc2ggKTtcclxuXHRcdHZhciBvY3RyZWUgPSBtZXNoLm9jdHJlZTtcclxuXHRcdHZhciBvcmlnaW4gPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIGRpcmVjdGlvbiA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XHJcblx0XHR2YXIgdGVtcCA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgaSA9IDA7XHJcblx0XHR2YXIgdHJpZXMgPSAwO1xyXG5cdFx0d2hpbGUoaSA8IHNpemUgJiYgdHJpZXMgPCBwb2ludHMubGVuZ3RoICogMTApIC8vbGltaXQgdG8gYXZvaWQgcHJvYmxlbXNcclxuXHRcdHtcclxuXHRcdFx0dHJpZXMgKz0gMVxyXG5cdFx0XHR2YXIgciA9IHZlYzMucmFuZG9tKHRlbXApOyAvL3JhbmRvbSBwb2ludCBpbnNpZGUgdGhlIGFhYmJcclxuXHRcdFx0clswXSA9IChyWzBdICogMiAtIDEpICogYWFiYlszXSArIGFhYmJbMF07XHJcblx0XHRcdHJbMV0gPSAoclsxXSAqIDIgLSAxKSAqIGFhYmJbNF0gKyBhYWJiWzFdO1xyXG5cdFx0XHRyWzJdID0gKHJbMl0gKiAyIC0gMSkgKiBhYWJiWzVdICsgYWFiYlsyXTtcclxuXHRcdFx0b3JpZ2luLnNldChyKTtcclxuXHRcdFx0dmFyIGhpdCA9IG9jdHJlZS50ZXN0UmF5KCBvcmlnaW4sIGRpcmVjdGlvbiwgMCwgMTAwMDAsIHRydWUsIEdMLk9jdHJlZS5BTEwgKTtcclxuXHRcdFx0aWYoIWhpdCB8fCBoaXQubGVuZ3RoICUgMiA9PSAwKSAvL25vdCBpbnNpZGVcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0cG9pbnRzLnNldCggciwgaSApO1xyXG5cdFx0XHRpKz0zO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvcG9pbnRzM0RcIiwgTEdyYXBoUG9pbnRzM0QgKTtcclxuXHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhQb2ludHNUb0luc3RhbmNlcygpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJwb2ludHNcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiaW5zdGFuY2VzXCIsIFwiW21hdDRdXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRtb2RlOiAxLFxyXG5cdFx0XHRhdXRvdXBkYXRlOiB0cnVlXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5tYXRyaWNlcyA9IFtdO1xyXG5cdFx0dGhpcy5maXJzdF90aW1lID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLk5PUk1BTCA9IDA7XHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuVkVSVElDQUwgPSAxO1xyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlNQSEVSSUNBTCA9IDI7XHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuUkFORE9NID0gMztcclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5SQU5ET01fVkVSVElDQUwgPSA0O1xyXG5cclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5tb2RlcyA9IHtcIm5vcm1hbFwiOjAsXCJ2ZXJ0aWNhbFwiOjEsXCJzcGhlcmljYWxcIjoyLFwicmFuZG9tXCI6MyxcInJhbmRvbV92ZXJ0aWNhbFwiOjR9O1xyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdG1vZGU6IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMubW9kZXMgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLnRpdGxlID0gXCJwb2ludHMgdG8gaW5zdFwiO1xyXG5cclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciBnZW8gPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCAhZ2VvIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsbnVsbCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiggIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGhhc19jaGFuZ2VkID0gKGdlby5fdmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uIHx8IGdlby5faWQgIT0gdGhpcy5fZ2VvbWV0cnlfaWQpO1xyXG5cclxuXHRcdGlmKCBoYXNfY2hhbmdlZCAmJiB0aGlzLnByb3BlcnRpZXMuYXV0b3VwZGF0ZSB8fCB0aGlzLmZpcnN0X3RpbWUgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmZpcnN0X3RpbWUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy51cGRhdGVJbnN0YW5jZXMoIGdlbyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5tYXRyaWNlcyApO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMucHJvdG90eXBlLnVwZGF0ZUluc3RhbmNlcyA9IGZ1bmN0aW9uKCBnZW9tZXRyeSApXHJcblx0e1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRpZighdmVydGljZXMpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBnZW9tZXRyeS5ub3JtYWxzO1xyXG5cclxuXHRcdHZhciBtYXRyaWNlcyA9IHRoaXMubWF0cmljZXM7XHJcblx0XHR2YXIgbnVtX3BvaW50cyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XHJcblx0XHRpZiggbWF0cmljZXMubGVuZ3RoICE9IG51bV9wb2ludHMpXHJcblx0XHRcdG1hdHJpY2VzLmxlbmd0aCA9IG51bV9wb2ludHM7XHJcblx0XHR2YXIgaWRlbnRpdHkgPSBtYXQ0LmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHRlbXAgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHplcm8gPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIFVQID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcclxuXHRcdHZhciBGUk9OVCA9IHZlYzMuZnJvbVZhbHVlcygwLDAsLTEpO1xyXG5cdFx0dmFyIFJJR0hUID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcclxuXHRcdHZhciBSID0gcXVhdC5jcmVhdGUoKTtcclxuXHJcblx0XHR2YXIgZnJvbnQgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHJpZ2h0ID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciB0b3AgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMylcclxuXHRcdHtcclxuXHRcdFx0dmFyIGluZGV4ID0gaS8zO1xyXG5cdFx0XHR2YXIgbSA9IG1hdHJpY2VzW2luZGV4XTtcclxuXHRcdFx0aWYoIW0pXHJcblx0XHRcdFx0bSA9IG1hdHJpY2VzW2luZGV4XSA9IG1hdDQuY3JlYXRlKCk7XHJcblx0XHRcdG0uc2V0KCBpZGVudGl0eSApO1xyXG5cdFx0XHR2YXIgcG9pbnQgPSB2ZXJ0aWNlcy5zdWJhcnJheShpLGkrMyk7XHJcblxyXG5cdFx0XHRzd2l0Y2godGhpcy5wcm9wZXJ0aWVzLm1vZGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjYXNlIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLk5PUk1BTDogXHJcblx0XHRcdFx0XHRtYXQ0LnNldFRyYW5zbGF0aW9uKCBtLCBwb2ludCApO1xyXG5cdFx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbCA9IG5vcm1hbHMuc3ViYXJyYXkoaSxpKzMpO1xyXG5cdFx0XHRcdFx0XHR0b3Auc2V0KCBub3JtYWwgKTtcclxuXHRcdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIHRvcCwgdG9wICk7XHJcblx0XHRcdFx0XHRcdHZlYzMuY3Jvc3MoIHJpZ2h0LCBGUk9OVCwgdG9wICk7XHJcblx0XHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCByaWdodCwgcmlnaHQgKTtcclxuXHRcdFx0XHRcdFx0dmVjMy5jcm9zcyggZnJvbnQsIHJpZ2h0LCB0b3AgKTtcclxuXHRcdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIGZyb250LCBmcm9udCApO1xyXG5cdFx0XHRcdFx0XHRtLnNldChyaWdodCwwKTtcclxuXHRcdFx0XHRcdFx0bS5zZXQodG9wLDQpO1xyXG5cdFx0XHRcdFx0XHRtLnNldChmcm9udCw4KTtcclxuXHRcdFx0XHRcdFx0bWF0NC5zZXRUcmFuc2xhdGlvbiggbSwgcG9pbnQgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuVkVSVElDQUw6IFxyXG5cdFx0XHRcdFx0bWF0NC5zZXRUcmFuc2xhdGlvbiggbSwgcG9pbnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuU1BIRVJJQ0FMOiBcclxuXHRcdFx0XHRcdGZyb250LnNldCggcG9pbnQgKTtcclxuXHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCBmcm9udCwgZnJvbnQgKTtcclxuXHRcdFx0XHRcdHZlYzMuY3Jvc3MoIHJpZ2h0LCBVUCwgZnJvbnQgKTtcclxuXHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCByaWdodCwgcmlnaHQgKTtcclxuXHRcdFx0XHRcdHZlYzMuY3Jvc3MoIHRvcCwgZnJvbnQsIHJpZ2h0ICk7XHJcblx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggdG9wLCB0b3AgKTtcclxuXHRcdFx0XHRcdG0uc2V0KHJpZ2h0LDApO1xyXG5cdFx0XHRcdFx0bS5zZXQodG9wLDQpO1xyXG5cdFx0XHRcdFx0bS5zZXQoZnJvbnQsOCk7XHJcblx0XHRcdFx0XHRtYXQ0LnNldFRyYW5zbGF0aW9uKCBtLCBwb2ludCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5SQU5ET006XHJcblx0XHRcdFx0XHR0ZW1wWzBdID0gTWF0aC5yYW5kb20oKSoyIC0gMTtcclxuXHRcdFx0XHRcdHRlbXBbMV0gPSBNYXRoLnJhbmRvbSgpKjIgLSAxO1xyXG5cdFx0XHRcdFx0dGVtcFsyXSA9IE1hdGgucmFuZG9tKCkqMiAtIDE7XHJcblx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggdGVtcCwgdGVtcCApO1xyXG5cdFx0XHRcdFx0cXVhdC5zZXRBeGlzQW5nbGUoIFIsIHRlbXAsIE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSSApO1xyXG5cdFx0XHRcdFx0bWF0NC5mcm9tUXVhdChtLCBSKTtcclxuXHRcdFx0XHRcdG1hdDQuc2V0VHJhbnNsYXRpb24oIG0sIHBvaW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlJBTkRPTV9WRVJUSUNBTDpcclxuXHRcdFx0XHRcdHF1YXQuc2V0QXhpc0FuZ2xlKCBSLCBVUCwgTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJICk7XHJcblx0XHRcdFx0XHRtYXQ0LmZyb21RdWF0KG0sIFIpO1xyXG5cdFx0XHRcdFx0bWF0NC5zZXRUcmFuc2xhdGlvbiggbSwgcG9pbnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cdFx0dGhpcy5fZ2VvbWV0cnlfaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9wb2ludHNfdG9faW5zdGFuY2VzXCIsIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhHZW9tZXRyeVRyYW5zZm9ybSgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5LFttYXQ0XVwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtYXQ0XCIsIFwibWF0NFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0ge1xyXG5cdFx0XHR0eXBlOiBcInRyaWFuZ2xlc1wiLFxyXG5cdFx0XHR2ZXJ0aWNlczogbnVsbCxcclxuXHRcdFx0X2lkOiBnZW5lcmF0ZUdlb21ldHJ5SWQoKSxcclxuXHRcdFx0X3ZlcnNpb246IDBcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5fbGFzdF9nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy5fbGFzdF92ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLl9sYXN0X2tleSA9IFwiXCI7XHJcblxyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVRyYW5zZm9ybS50aXRsZSA9IFwiVHJhbnNmb3JtXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5VHJhbnNmb3JtLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgaW5wdXQgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHZhciBtb2RlbCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cclxuXHRcdGlmKCFpbnB1dClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vYXJyYXkgb2YgbWF0cmljZXNcclxuXHRcdGlmKGlucHV0LmNvbnN0cnVjdG9yID09PSBBcnJheSlcclxuXHRcdHtcclxuXHRcdFx0aWYoaW5wdXQubGVuZ3RoID09IDApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR0aGlzLm91dHB1dHNbMF0udHlwZSA9IFwiW21hdDRdXCI7XHJcblx0XHRcdGlmKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0aWYoIW1vZGVsKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsaW5wdXQpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoIXRoaXMuX291dHB1dClcclxuXHRcdFx0XHR0aGlzLl9vdXRwdXQgPSBuZXcgQXJyYXkoKTtcclxuXHRcdFx0aWYodGhpcy5fb3V0cHV0Lmxlbmd0aCAhPSBpbnB1dC5sZW5ndGgpXHJcblx0XHRcdFx0dGhpcy5fb3V0cHV0Lmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIG0gPSB0aGlzLl9vdXRwdXRbaV07XHJcblx0XHRcdFx0aWYoIW0pXHJcblx0XHRcdFx0XHRtID0gdGhpcy5fb3V0cHV0W2ldID0gbWF0NC5jcmVhdGUoKTtcclxuXHRcdFx0XHRtYXQ0Lm11bHRpcGx5KG0saW5wdXRbaV0sbW9kZWwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuX291dHB1dCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvL2dlb21ldHJ5XHJcblx0XHRpZighaW5wdXQudmVydGljZXMgfHwgIWlucHV0LnZlcnRpY2VzLmxlbmd0aClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0dmFyIGdlbyA9IGlucHV0O1xyXG5cdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSBcImdlb21ldHJ5XCI7XHJcblx0XHRpZiggIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRpZighbW9kZWwpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLGdlbyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIga2V5ID0gdHlwZWRBcnJheVRvQXJyYXkobW9kZWwpLmpvaW4oXCIsXCIpO1xyXG5cclxuXHRcdGlmKCB0aGlzLm11c3RfdXBkYXRlIHx8IGdlby5faWQgIT0gdGhpcy5fbGFzdF9nZW9tZXRyeV9pZCB8fCBnZW8uX3ZlcnNpb24gIT0gdGhpcy5fbGFzdF92ZXJzaW9uIHx8IGtleSAhPSB0aGlzLl9sYXN0X2tleSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMudXBkYXRlR2VvbWV0cnkoZ2VvLCBtb2RlbCk7XHJcblx0XHRcdHRoaXMuX2xhc3Rfa2V5ID0ga2V5O1xyXG5cdFx0XHR0aGlzLl9sYXN0X3ZlcnNpb24gPSBnZW8uX3ZlcnNpb247XHJcblx0XHRcdHRoaXMuX2xhc3RfZ2VvbWV0cnlfaWQgPSBnZW8uX2lkO1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5nZW9tZXRyeSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlR2VvbWV0cnkgPSBmdW5jdGlvbihnZW9tZXRyeSwgbW9kZWwpIHtcclxuXHRcdHZhciBvbGRfdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRpZiggIXZlcnRpY2VzIHx8IHZlcnRpY2VzLmxlbmd0aCAhPSBvbGRfdmVydGljZXMubGVuZ3RoIClcclxuXHRcdFx0dmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggb2xkX3ZlcnRpY2VzLmxlbmd0aCApO1xyXG5cdFx0dmFyIHRlbXAgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR0ZW1wWzBdID0gb2xkX3ZlcnRpY2VzW2ldOyB0ZW1wWzFdID0gb2xkX3ZlcnRpY2VzW2krMV07IHRlbXBbMl0gPSBvbGRfdmVydGljZXNbaSsyXTsgXHJcblx0XHRcdG1hdDQubXVsdGlwbHlWZWMzKCB0ZW1wLCBtb2RlbCwgdGVtcCApO1xyXG5cdFx0XHR2ZXJ0aWNlc1tpXSA9IHRlbXBbMF07IHZlcnRpY2VzW2krMV0gPSB0ZW1wWzFdOyB2ZXJ0aWNlc1tpKzJdID0gdGVtcFsyXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihnZW9tZXRyeS5ub3JtYWxzKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiggIXRoaXMuZ2VvbWV0cnkubm9ybWFscyB8fCB0aGlzLmdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoICE9IGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoIClcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5Lm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCApO1xyXG5cdFx0XHR2YXIgbm9ybWFscyA9IHRoaXMuZ2VvbWV0cnkubm9ybWFscztcclxuXHRcdFx0dmFyIG5vcm1hbF9tb2RlbCA9IG1hdDQuaW52ZXJ0KG1hdDQuY3JlYXRlKCksIG1vZGVsKTtcclxuXHRcdFx0aWYobm9ybWFsX21vZGVsKVxyXG5cdFx0XHRcdG1hdDQudHJhbnNwb3NlKG5vcm1hbF9tb2RlbCwgbm9ybWFsX21vZGVsKTtcclxuXHRcdFx0dmFyIG9sZF9ub3JtYWxzID0gZ2VvbWV0cnkubm9ybWFscztcclxuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgbDsgaSs9MylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRlbXBbMF0gPSBvbGRfbm9ybWFsc1tpXTsgdGVtcFsxXSA9IG9sZF9ub3JtYWxzW2krMV07IHRlbXBbMl0gPSBvbGRfbm9ybWFsc1tpKzJdOyBcclxuXHRcdFx0XHRtYXQ0Lm11bHRpcGx5VmVjMyggdGVtcCwgbm9ybWFsX21vZGVsLCB0ZW1wICk7XHJcblx0XHRcdFx0bm9ybWFsc1tpXSA9IHRlbXBbMF07IG5vcm1hbHNbaSsxXSA9IHRlbXBbMV07IG5vcm1hbHNbaSsyXSA9IHRlbXBbMl07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LnR5cGUgPSBnZW9tZXRyeS50eXBlO1xyXG5cdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvdHJhbnNmb3JtXCIsIExHcmFwaEdlb21ldHJ5VHJhbnNmb3JtICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhHZW9tZXRyeVBvbHlnb24oKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwic2lkZXNcIiwgXCJudW1iZXJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwicmFkaXVzXCIsIFwibnVtYmVyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgc2lkZXM6IDYsIHJhZGl1czogMSwgdXZzOiBmYWxzZSB9XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IHtcclxuXHRcdFx0dHlwZTogXCJsaW5lX2xvb3BcIixcclxuXHRcdFx0dmVydGljZXM6IG51bGwsXHJcblx0XHRcdF9pZDogZ2VuZXJhdGVHZW9tZXRyeUlkKClcclxuXHRcdH07XHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubGFzdF9pbmZvID0geyBzaWRlczogLTEsIHJhZGl1czogLTEgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UG9seWdvbi50aXRsZSA9IFwiUG9seWdvblwiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVBvbHlnb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGlmKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSApXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgc2lkZXMgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInNpZGVzXCIpO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwicmFkaXVzXCIpO1xyXG5cdFx0c2lkZXMgPSBNYXRoLm1heCgzLHNpZGVzKXwwO1xyXG5cclxuXHRcdC8vdXBkYXRlXHJcblx0XHRpZiggdGhpcy5sYXN0X2luZm8uc2lkZXMgIT0gc2lkZXMgfHwgdGhpcy5sYXN0X2luZm8ucmFkaXVzICE9IHJhZGl1cyApXHJcblx0XHRcdHRoaXMudXBkYXRlR2VvbWV0cnkoc2lkZXMsIHJhZGl1cyk7XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5nZW9tZXRyeSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVBvbHlnb24ucHJvdG90eXBlLnVwZGF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oc2lkZXMsIHJhZGl1cykge1xyXG5cdFx0dmFyIG51bSA9IDMqc2lkZXM7XHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0aWYoICF2ZXJ0aWNlcyB8fCB2ZXJ0aWNlcy5sZW5ndGggIT0gbnVtIClcclxuXHRcdFx0dmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMypzaWRlcyApO1xyXG5cdFx0dmFyIGRlbHRhID0gKE1hdGguUEkgKiAyKSAvIHNpZGVzO1xyXG5cdFx0dmFyIGdlbl91dnMgPSB0aGlzLnByb3BlcnRpZXMudXZzO1xyXG5cdFx0aWYoZ2VuX3V2cylcclxuXHRcdHtcclxuXHRcdFx0dXZzID0gdGhpcy5nZW9tZXRyeS5jb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCAzKnNpZGVzICk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaWRlczsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgYW5nbGUgPSBkZWx0YSAqIC1pO1xyXG5cdFx0XHR2YXIgeCA9IE1hdGguY29zKCBhbmdsZSApICogcmFkaXVzO1xyXG5cdFx0XHR2YXIgeSA9IDA7XHJcblx0XHRcdHZhciB6ID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXM7XHJcblx0XHRcdHZlcnRpY2VzW2kqM10gPSB4O1xyXG5cdFx0XHR2ZXJ0aWNlc1tpKjMrMV0gPSB5O1xyXG5cdFx0XHR2ZXJ0aWNlc1tpKjMrMl0gPSB6O1xyXG5cclxuXHRcdFx0aWYoZ2VuX3V2cylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5nZW9tZXRyeS5faWQgPSArK3RoaXMuZ2VvbWV0cnlfaWQ7XHJcblx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gKyt0aGlzLnZlcnNpb247XHJcblx0XHR0aGlzLmxhc3RfaW5mby5zaWRlcyA9IHNpZGVzO1xyXG5cdFx0dGhpcy5sYXN0X2luZm8ucmFkaXVzID0gcmFkaXVzO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvcG9seWdvblwiLCBMR3JhcGhHZW9tZXRyeVBvbHlnb24gKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5RXh0cnVkZSgpIHtcclxuXHJcblx0XHR0aGlzLmFkZElucHV0KFwiXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB0b3BfY2FwOiB0cnVlLCBib3R0b21fY2FwOiB0cnVlLCBvZmZzZXQ6IFswLDEwMCwwXSB9O1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblxyXG5cdFx0dGhpcy5fbGFzdF9nZW9fdmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFeHRydWRlLnRpdGxlID0gXCJleHRydWRlXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXh0cnVkZS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSlcclxuXHR7XHJcblx0XHR0aGlzLl9tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV4dHJ1ZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgZ2VvID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZiggIWdlbyB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSApXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZihnZW8udmVyc2lvbiAhPSB0aGlzLl9sYXN0X2dlb192ZXJzaW9uIHx8IHRoaXMuX211c3RfdXBkYXRlKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLl9nZW8gPSB0aGlzLmV4dHJ1ZGVHZW9tZXRyeSggZ2VvLCB0aGlzLl9nZW8gKTtcclxuXHRcdFx0aWYodGhpcy5fZ2VvKVxyXG5cdFx0XHRcdHRoaXMuX2dlby52ZXJzaW9uID0gdGhpcy52ZXJzaW9uKys7XHJcblx0XHRcdHRoaXMuX211c3RfdXBkYXRlID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2dlbyk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV4dHJ1ZGUucHJvdG90eXBlLmV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBnZW8gKVxyXG5cdHtcclxuXHRcdC8vZm9yIGV2ZXJ5IHBhaXIgb2YgdmVydGljZXNcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlby52ZXJ0aWNlcztcclxuXHRcdHZhciBudW1fcG9pbnRzID0gdmVydGljZXMubGVuZ3RoIC8gMztcclxuXHJcblx0XHR2YXIgdGVtcEEgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHRlbXBCID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciB0ZW1wQyA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgdGVtcEQgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMucHJvcGVydGllcy5vZmZzZXQgKTtcclxuXHJcblx0XHRpZihnZW8udHlwZSA9PSBcImxpbmVfbG9vcFwiKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgbmV3X3ZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtX3BvaW50cyAqIDYgKiAzICk7IC8vZXZlcnkgcG9pbnRzIGJlY29tZSA2ICggY2FwcyBub3QgaW5jbHVkZWQgKVxyXG5cdFx0XHR2YXIgbnBvcyA9IDA7XHJcblx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0ZW1wQVswXSA9IHZlcnRpY2VzW2ldOyB0ZW1wQVsxXSA9IHZlcnRpY2VzW2krMV07IHRlbXBBWzJdID0gdmVydGljZXNbaSsyXTtcclxuXHJcblx0XHRcdFx0aWYoIGkrMyA8IGwgKSAvL2xvb3BcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR0ZW1wQlswXSA9IHZlcnRpY2VzW2krM107IHRlbXBCWzFdID0gdmVydGljZXNbaSs0XTsgdGVtcEJbMl0gPSB2ZXJ0aWNlc1tpKzVdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dGVtcEJbMF0gPSB2ZXJ0aWNlc1swXTsgdGVtcEJbMV0gPSB2ZXJ0aWNlc1sxXTsgdGVtcEJbMl0gPSB2ZXJ0aWNlc1syXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZlYzMuYWRkKCB0ZW1wQywgdGVtcEEsIG9mZnNldCApO1xyXG5cdFx0XHRcdHZlYzMuYWRkKCB0ZW1wRCwgdGVtcEIsIG9mZnNldCApO1xyXG5cclxuXHRcdFx0XHRuZXdfdmVydGljZXMuc2V0KCB0ZW1wQSwgbnBvcyApOyBucG9zICs9IDM7XHJcblx0XHRcdFx0bmV3X3ZlcnRpY2VzLnNldCggdGVtcEIsIG5wb3MgKTsgbnBvcyArPSAzO1xyXG5cdFx0XHRcdG5ld192ZXJ0aWNlcy5zZXQoIHRlbXBDLCBucG9zICk7IG5wb3MgKz0gMztcclxuXHJcblx0XHRcdFx0bmV3X3ZlcnRpY2VzLnNldCggdGVtcEIsIG5wb3MgKTsgbnBvcyArPSAzO1xyXG5cdFx0XHRcdG5ld192ZXJ0aWNlcy5zZXQoIHRlbXBELCBucG9zICk7IG5wb3MgKz0gMztcclxuXHRcdFx0XHRuZXdfdmVydGljZXMuc2V0KCB0ZW1wQywgbnBvcyApOyBucG9zICs9IDM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3V0X2dlbyA9IHtcclxuXHRcdFx0X2lkOiBnZW5lcmF0ZUdlb21ldHJ5SWQoKSxcclxuXHRcdFx0dHlwZTogXCJ0cmlhbmdsZXNcIixcclxuXHRcdFx0dmVydGljZXM6IG5ld192ZXJ0aWNlc1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gb3V0X2dlbztcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L2V4dHJ1ZGVcIiwgTEdyYXBoR2VvbWV0cnlFeHRydWRlICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhHZW9tZXRyeUV2YWwoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRjb2RlOiBcIlZbMV0gKz0gMC4wMSAqIE1hdGguc2luKEkgKyBUKjAuMDAxKTtcIixcclxuXHRcdFx0ZXhlY3V0ZV9ldmVyeV9mcmFtZTogZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IG51bGw7XHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMgPSBudWxsO1xyXG5cdFx0dGhpcy5mdW5jID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC50aXRsZSA9IFwiZ2VvZXZhbFwiO1xyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC5kZXNjID0gXCJldmFsIGNvZGVcIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdGNvZGU6IHsgd2lkZ2V0OiBcImNvZGVcIiB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pXHJcblx0e1xyXG5cdFx0dGhpcy5jb21waWxlQ29kZSgpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLnByb3RvdHlwZS5jb21waWxlQ29kZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZighdGhpcy5wcm9wZXJ0aWVzLmNvZGUpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR0cnlcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5mdW5jID0gbmV3IEZ1bmN0aW9uKFwiVlwiLFwiSVwiLFwiVFwiLCB0aGlzLnByb3BlcnRpZXMuY29kZSk7IFxyXG5cdFx0XHR0aGlzLmJveGNvbG9yID0gXCIjQUZBXCI7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Y2F0Y2ggKGVycilcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpXHJcblx0e1xyXG5cdFx0aWYobmFtZSA9PSBcImNvZGVcIilcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmNvZGUgPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5jb21waWxlQ29kZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWdlb21ldHJ5KVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIXRoaXMuZnVuYylcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsZ2VvbWV0cnkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIHRoaXMuZ2VvbWV0cnlfaWQgIT0gZ2VvbWV0cnkuX2lkIHx8IHRoaXMudmVyc2lvbiAhPSBnZW9tZXRyeS5fdmVyc2lvbiB8fCB0aGlzLm11c3RfdXBkYXRlIHx8IHRoaXMucHJvcGVydGllcy5leGVjdXRlX2V2ZXJ5X2ZyYW1lIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5X2lkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0XHRpZih0aGlzLnByb3BlcnRpZXMuZXhlY3V0ZV9ldmVyeV9mcmFtZSlcclxuXHRcdFx0XHR0aGlzLnZlcnNpb24rKztcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRoaXMudmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cdFx0XHR2YXIgZnVuYyA9IHRoaXMuZnVuYztcclxuXHRcdFx0dmFyIFQgPSBnZXRUaW1lKCk7XHJcblxyXG5cdFx0XHQvL2Nsb25lXHJcblx0XHRcdGlmKCF0aGlzLmdlb21ldHJ5KVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkgPSB7fTtcclxuXHRcdFx0Zm9yKHZhciBpIGluIGdlb21ldHJ5KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYoZ2VvbWV0cnlbaV0gPT0gbnVsbClcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdGlmKCBnZW9tZXRyeVtpXS5jb25zdHJ1Y3RvciA9PSBGbG9hdDMyQXJyYXkgKVxyXG5cdFx0XHRcdFx0dGhpcy5nZW9tZXRyeVtpXSA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5W2ldICk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0dGhpcy5nZW9tZXRyeVtpXSA9IGdlb21ldHJ5W2ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX2lkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0XHRpZih0aGlzLnByb3BlcnRpZXMuZXhlY3V0ZV9ldmVyeV9mcmFtZSlcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uICsgMTtcclxuXHJcblx0XHRcdHZhciBWID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuXHRcdFx0aWYoIXZlcnRpY2VzIHx8IHRoaXMudmVydGljZXMubGVuZ3RoICE9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aClcclxuXHRcdFx0XHR2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dmVydGljZXMuc2V0KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0VlswXSA9IHZlcnRpY2VzW2ldO1xyXG5cdFx0XHRcdFZbMV0gPSB2ZXJ0aWNlc1tpKzFdO1xyXG5cdFx0XHRcdFZbMl0gPSB2ZXJ0aWNlc1tpKzJdO1xyXG5cdFx0XHRcdGZ1bmMoVixpLzMsVCk7XHJcblx0XHRcdFx0dmVydGljZXNbaV0gPSBWWzBdO1xyXG5cdFx0XHRcdHZlcnRpY2VzW2krMV0gPSBWWzFdO1xyXG5cdFx0XHRcdHZlcnRpY2VzW2krMl0gPSBWWzJdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLmdlb21ldHJ5KTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L2V2YWxcIiwgTEdyYXBoR2VvbWV0cnlFdmFsICk7XHJcblxyXG4vKlxyXG5mdW5jdGlvbiBMR3JhcGhHZW9tZXRyeURpc3BsYWNlKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW1nXCIsIFwiaW1hZ2VcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0Z3JpZF9zaXplOiAxXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RGlzcGxhY2UudGl0bGUgPSBcImRpc3BsYWNlXCI7XHJcblx0TEdyYXBoR2VvbWV0cnlEaXNwbGFjZS5kZXNjID0gXCJkaXNwbGFjZSBwb2ludHNcIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlEaXNwbGFjZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYoIWdlb21ldHJ5KVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIWltYWdlKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxnZW9tZXRyeSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiggdGhpcy5nZW9tZXRyeV9pZCAhPSBnZW9tZXRyeS5faWQgfHwgdGhpcy52ZXJzaW9uICE9IGdlb21ldHJ5Ll92ZXJzaW9uIHx8IHRoaXMubXVzdF91cGRhdGUgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHRcdHRoaXMudmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cclxuXHRcdFx0Ly9jb3B5XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkgPSB7fTtcclxuXHRcdFx0Zm9yKHZhciBpIGluIGdlb21ldHJ5KVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnlbaV0gPSBnZW9tZXRyeVtpXTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5faWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbiArIDE7XHJcblxyXG5cdFx0XHR2YXIgZ3JpZF9zaXplID0gdGhpcy5wcm9wZXJ0aWVzLmdyaWRfc2l6ZTtcclxuXHRcdFx0aWYoZ3JpZF9zaXplICE9IDApXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cdFx0XHRcdGlmKCF2ZXJ0aWNlcyB8fCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAhPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aClcclxuXHRcdFx0XHRcdHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZlcnRpY2VzW2ldID0gTWF0aC5yb3VuZCh2ZXJ0aWNlc1tpXS9ncmlkX3NpemUpICogZ3JpZF9zaXplO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbaSsxXSA9IE1hdGgucm91bmQodmVydGljZXNbaSsxXS9ncmlkX3NpemUpICogZ3JpZF9zaXplO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbaSsyXSA9IE1hdGgucm91bmQodmVydGljZXNbaSsyXS9ncmlkX3NpemUpICogZ3JpZF9zaXplO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzID0gdmVydGljZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLmdlb21ldHJ5KTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L2Rpc3BsYWNlXCIsIExHcmFwaEdlb21ldHJ5RGlzcGxhY2UgKTtcclxuKi9cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoQ29ubmVjdFBvaW50cygpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdG1pbl9kaXN0OiAwLjQsXHJcblx0XHRcdG1heF9kaXN0OiAwLjUsXHJcblx0XHRcdG1heF9jb25uZWN0aW9uczogMCxcclxuXHRcdFx0cHJvYmFiaWxpdHk6IDFcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm15X3ZlcnNpb24gPSAxO1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhDb25uZWN0UG9pbnRzLnRpdGxlID0gXCJjb25uZWN0IHBvaW50c1wiO1xyXG5cdExHcmFwaENvbm5lY3RQb2ludHMuZGVzYyA9IFwiYWRkcyBpbmRpY2VzIGJldHdlZW4gbmVhciBwb2ludHNcIjtcclxuXHJcblx0TEdyYXBoQ29ubmVjdFBvaW50cy5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoQ29ubmVjdFBvaW50cy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFnZW9tZXRyeSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCB0aGlzLmdlb21ldHJ5X2lkICE9IGdlb21ldHJ5Ll9pZCB8fCB0aGlzLnZlcnNpb24gIT0gZ2VvbWV0cnkuX3ZlcnNpb24gfHwgdGhpcy5tdXN0X3VwZGF0ZSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeV9pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdFx0dGhpcy52ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblxyXG5cdFx0XHQvL2NvcHlcclxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IHt9O1xyXG5cdFx0XHRmb3IodmFyIGkgaW4gZ2VvbWV0cnkpXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeVtpXSA9IGdlb21ldHJ5W2ldO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll9pZCA9IGdlbmVyYXRlR2VvbWV0cnlJZCgpO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gdGhpcy5teV92ZXJzaW9uKys7XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdFx0dmFyIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblx0XHRcdHZhciBtaW5fZGlzdCA9IHRoaXMucHJvcGVydGllcy5taW5fZGlzdDtcclxuXHRcdFx0dmFyIG1heF9kaXN0ID0gdGhpcy5wcm9wZXJ0aWVzLm1heF9kaXN0O1xyXG5cdFx0XHR2YXIgcHJvYmFiaWxpdHkgPSB0aGlzLnByb3BlcnRpZXMucHJvYmFiaWxpdHk7XHJcblx0XHRcdHZhciBtYXhfY29ubmVjdGlvbnMgPSB0aGlzLnByb3BlcnRpZXMubWF4X2Nvbm5lY3Rpb25zO1xyXG5cdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cdFx0XHRcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrPTMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgeCA9IHZlcnRpY2VzW2ldO1xyXG5cdFx0XHRcdHZhciB5ID0gdmVydGljZXNbaSsxXTtcclxuXHRcdFx0XHR2YXIgeiA9IHZlcnRpY2VzW2krMl07XHJcblx0XHRcdFx0dmFyIGNvbm5lY3Rpb25zID0gMDtcclxuXHRcdFx0XHRmb3IodmFyIGogPSBpKzM7IGogPCBsOyBqKz0zKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciB4MiA9IHZlcnRpY2VzW2pdO1xyXG5cdFx0XHRcdFx0dmFyIHkyID0gdmVydGljZXNbaisxXTtcclxuXHRcdFx0XHRcdHZhciB6MiA9IHZlcnRpY2VzW2orMl07XHJcblx0XHRcdFx0XHR2YXIgZGlzdCA9IE1hdGguc3FydCggKHgteDIpKih4LXgyKSArICh5LXkyKSooeS15MikgKyAoei16MikqKHotejIpKTtcclxuXHRcdFx0XHRcdGlmKGRpc3QgPiBtYXhfZGlzdCB8fCBkaXN0IDwgbWluX2Rpc3QgfHwgKHByb2JhYmlsaXR5IDwgMSAmJiBwcm9iYWJpbGl0eSA8IE1hdGgucmFuZG9tKCkpIClcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goaS8zLGovMyk7XHJcblx0XHRcdFx0XHRjb25uZWN0aW9ucyArPSAxO1xyXG5cdFx0XHRcdFx0aWYobWF4X2Nvbm5lY3Rpb25zICYmIGNvbm5lY3Rpb25zID4gbWF4X2Nvbm5lY3Rpb25zKVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5pbmRpY2VzID0gdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGluZGljZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMuaW5kaWNlcyAmJiB0aGlzLmluZGljZXMubGVuZ3RoKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmluZGljZXMgPSB0aGlzLmluZGljZXM7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5nZW9tZXRyeSApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIG51bGwgKTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L2Nvbm5lY3RQb2ludHNcIiwgTEdyYXBoQ29ubmVjdFBvaW50cyApO1xyXG5cclxuICAgIC8vV29ya3Mgd2l0aCBMaXRlZ2wuanMgdG8gY3JlYXRlIFdlYkdMIG5vZGVzXHJcbiAgICBpZiAodHlwZW9mIEdMID09IFwidW5kZWZpbmVkXCIpIC8vTGl0ZUdMIFJFTEFURUQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhUb0dlb21ldHJ5KCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1lc2hcIiwgXCJtZXNoXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0ge307XHJcblx0XHR0aGlzLmxhc3RfbWVzaCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhUb0dlb21ldHJ5LnRpdGxlID0gXCJ0byBnZW9tZXRyeVwiO1xyXG5cdExHcmFwaFRvR2VvbWV0cnkuZGVzYyA9IFwiY29udmVydHMgYSBtZXNoIHRvIGdlb21ldHJ5XCI7XHJcblxyXG5cdExHcmFwaFRvR2VvbWV0cnkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lc2ggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFtZXNoKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYobWVzaCAhPSB0aGlzLmxhc3RfbWVzaClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5sYXN0X21lc2ggPSBtZXNoO1xyXG5cdFx0XHRmb3IoaSBpbiBtZXNoLnZlcnRleEJ1ZmZlcnMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgYnVmZmVyID0gbWVzaC52ZXJ0ZXhCdWZmZXJzW2ldO1xyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnlbaV0gPSBidWZmZXIuZGF0YVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKG1lc2guaW5kZXhCdWZmZXJzW1widHJpYW5nbGVzXCJdKVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkuaW5kaWNlcyA9IG1lc2guaW5kZXhCdWZmZXJzW1widHJpYW5nbGVzXCJdLmRhdGE7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll9pZCA9IGdlbmVyYXRlR2VvbWV0cnlJZCgpO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLmdlb21ldHJ5KTtcclxuXHRcdGlmKHRoaXMuZ2VvbWV0cnkpXHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLHRoaXMuZ2VvbWV0cnkudmVydGljZXMpO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvdG9HZW9tZXRyeVwiLCBMR3JhcGhUb0dlb21ldHJ5ICk7XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5VG9NZXNoKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm1lc2hcIiwgXCJtZXNoXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge307XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubWVzaCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVRvTWVzaC50aXRsZSA9IFwiR2VvIHRvIE1lc2hcIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlUb01lc2gucHJvdG90eXBlLnVwZGF0ZU1lc2ggPSBmdW5jdGlvbihnZW9tZXRyeSlcclxuXHR7XHJcblx0XHRpZighdGhpcy5tZXNoKVxyXG5cdFx0XHR0aGlzLm1lc2ggPSBuZXcgR0wuTWVzaCgpO1xyXG5cclxuXHRcdGZvcih2YXIgaSBpbiBnZW9tZXRyeSlcclxuXHRcdHtcclxuXHRcdFx0aWYoaVswXSA9PSBcIl9cIilcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdHZhciBidWZmZXJfZGF0YSA9IGdlb21ldHJ5W2ldO1xyXG5cclxuXHRcdFx0dmFyIGluZm8gPSBHTC5NZXNoLmNvbW1vbl9idWZmZXJzW2ldO1xyXG5cdFx0XHRpZighaW5mbyAmJiBpICE9IFwiaW5kaWNlc1wiKSAvL3Vua25vd24gYnVmZmVyXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHZhciBzcGFjaW5nID0gaW5mbyA/IGluZm8uc3BhY2luZyA6IDM7XHJcblx0XHRcdHZhciBtZXNoX2J1ZmZlciA9IHRoaXMubWVzaC52ZXJ0ZXhCdWZmZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYoIW1lc2hfYnVmZmVyIHx8IG1lc2hfYnVmZmVyLmRhdGEubGVuZ3RoICE9IGJ1ZmZlcl9kYXRhLmxlbmd0aClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG1lc2hfYnVmZmVyID0gbmV3IEdMLkJ1ZmZlciggaSA9PSBcImluZGljZXNcIiA/IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogR0wuQVJSQVlfQlVGRkVSLCBidWZmZXJfZGF0YSwgc3BhY2luZywgR0wuRFlOQU1JQ19EUkFXICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWVzaF9idWZmZXIuZGF0YS5zZXQoIGJ1ZmZlcl9kYXRhICk7XHJcblx0XHRcdFx0bWVzaF9idWZmZXIudXBsb2FkKEdMLkRZTkFNSUNfRFJBVyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWVzaC5hZGRCdWZmZXIoIGksIG1lc2hfYnVmZmVyICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5tZXNoLnZlcnRleEJ1ZmZlcnMubm9ybWFscyAmJnRoaXMubWVzaC52ZXJ0ZXhCdWZmZXJzLm5vcm1hbHMuZGF0YS5sZW5ndGggIT0gdGhpcy5tZXNoLnZlcnRleEJ1ZmZlcnMudmVydGljZXMuZGF0YS5sZW5ndGggKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwXSk7XHJcblx0XHRcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5tZXNoLnZlcnRleEJ1ZmZlcnMudmVydGljZXMuZGF0YS5sZW5ndGggKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKz0gMylcclxuXHRcdFx0XHRub3JtYWxzLnNldCggbiwgaSApO1xyXG5cdFx0XHRtZXNoX2J1ZmZlciA9IG5ldyBHTC5CdWZmZXIoIEdMLkFSUkFZX0JVRkZFUiwgbm9ybWFscywgMyApO1xyXG5cdFx0XHR0aGlzLm1lc2guYWRkQnVmZmVyKCBcIm5vcm1hbHNcIiwgbWVzaF9idWZmZXIgKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1lc2gudXBkYXRlQm91bmRpbmdCb3goKTtcclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSB0aGlzLm1lc2guaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHR0aGlzLnZlcnNpb24gPSB0aGlzLm1lc2gudmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cdFx0cmV0dXJuIHRoaXMubWVzaDtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5VG9NZXNoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFnZW9tZXRyeSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYoIHRoaXMudmVyc2lvbiAhPSBnZW9tZXRyeS5fdmVyc2lvbiB8fCB0aGlzLmdlb21ldHJ5X2lkICE9IGdlb21ldHJ5Ll9pZCApXHJcblx0XHRcdHRoaXMudXBkYXRlTWVzaCggZ2VvbWV0cnkgKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLm1lc2gpO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvdG9NZXNoXCIsIExHcmFwaEdlb21ldHJ5VG9NZXNoICk7XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFJlbmRlck1lc2goKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWVzaFwiLCBcIm1lc2hcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWF0NFwiLCBcIm1hdDRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidGV4XCIsIFwidGV4dHVyZVwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRcdHByaW1pdGl2ZTogR0wuVFJJQU5HTEVTLFxyXG5cdFx0XHRhZGRpdGl2ZTogZmFsc2UsXHJcblx0XHRcdGNvbG9yOiBbMSwxLDFdLFxyXG5cdFx0XHRvcGFjaXR5OiAxXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSB2ZWM0LmNyZWF0ZShbMSwxLDEsMV0pO1xyXG5cdFx0dGhpcy5tb2RlbF9tYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG5cdFx0dGhpcy51bmlmb3JtcyA9IHtcclxuXHRcdFx0dV9jb2xvcjogdGhpcy5jb2xvcixcclxuXHRcdFx0dV9tb2RlbDogdGhpcy5tb2RlbF9tYXRyaXhcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhSZW5kZXJNZXNoLnRpdGxlID0gXCJSZW5kZXIgTWVzaFwiO1xyXG5cdExHcmFwaFJlbmRlck1lc2guZGVzYyA9IFwicmVuZGVycyBhIG1lc2ggZmxhdFwiO1xyXG5cclxuXHRMR3JhcGhSZW5kZXJNZXNoLlBSSU1JVElWRV9WQUxVRVMgPSB7IFwicG9pbnRzXCI6R0wuUE9JTlRTLCBcImxpbmVzXCI6R0wuTElORVMsIFwibGluZV9sb29wXCI6R0wuTElORV9MT09QLFwibGluZV9zdHJpcFwiOkdMLkxJTkVfU1RSSVAsIFwidHJpYW5nbGVzXCI6R0wuVFJJQU5HTEVTLCBcInRyaWFuZ2xlX2ZhblwiOkdMLlRSSUFOR0xFX0ZBTiwgXCJ0cmlhbmdsZV9zdHJpcFwiOkdMLlRSSUFOR0xFX1NUUklQIH07XHJcblxyXG5cdExHcmFwaFJlbmRlck1lc2gud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0cHJpbWl0aXZlOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFJlbmRlck1lc2guUFJJTUlUSVZFX1ZBTFVFUyB9LFxyXG5cdFx0Y29sb3I6IHsgd2lkZ2V0OiBcImNvbG9yXCIgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaFJlbmRlck1lc2gucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGlmKCF0aGlzLnByb3BlcnRpZXMuZW5hYmxlZClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBtZXNoID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighbWVzaClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCFMaXRlR3JhcGguTEdyYXBoUmVuZGVyLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzKVxyXG5cdFx0e1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJjYW5ub3QgcmVuZGVyIGdlb21ldHJ5LCBMaXRlR3JhcGgub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMgaXMgbnVsbCwgcmVtZW1iZXIgdG8gZmlsbCB0aGlzIHdpdGggYSBjYWxsYmFjayh2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4KSB0byB1c2UgM0QgcmVuZGVyaW5nIGZyb20gdGhlIGdyYXBoXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0TGl0ZUdyYXBoLkxHcmFwaFJlbmRlci5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcyggdmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCApO1xyXG5cdFx0dmFyIHNoYWRlciA9IG51bGw7XHJcblx0XHR2YXIgdGV4dHVyZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG5cdFx0aWYodGV4dHVyZSlcclxuXHRcdHtcclxuXHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInRleHR1cmVkXCJdO1xyXG5cdFx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJ0ZXh0dXJlZFwiXSA9IG5ldyBHTC5TaGFkZXIoIExHcmFwaFJlbmRlclBvaW50cy52ZXJ0ZXhfc2hhZGVyX2NvZGUsIExHcmFwaFJlbmRlclBvaW50cy5mcmFnbWVudF9zaGFkZXJfY29kZSwgeyBVU0VfVEVYVFVSRTpcIlwiIH0pO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1wiZmxhdFwiXTtcclxuXHRcdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1wiZmxhdFwiXSA9IG5ldyBHTC5TaGFkZXIoIExHcmFwaFJlbmRlclBvaW50cy52ZXJ0ZXhfc2hhZGVyX2NvZGUsIExHcmFwaFJlbmRlclBvaW50cy5mcmFnbWVudF9zaGFkZXJfY29kZSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29sb3Iuc2V0KCB0aGlzLnByb3BlcnRpZXMuY29sb3IgKTtcclxuXHRcdHRoaXMuY29sb3JbM10gPSB0aGlzLnByb3BlcnRpZXMub3BhY2l0eTtcclxuXHJcblx0XHR2YXIgbW9kZWxfbWF0cml4ID0gdGhpcy5tb2RlbF9tYXRyaXg7XHJcblx0XHR2YXIgbSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYobSlcclxuXHRcdFx0bW9kZWxfbWF0cml4LnNldChtKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bWF0NC5pZGVudGl0eSggbW9kZWxfbWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BvaW50X3NpemUgPSAxO1xyXG5cdFx0dmFyIHByaW1pdGl2ZSA9IHRoaXMucHJvcGVydGllcy5wcmltaXRpdmU7XHJcblxyXG5cdFx0c2hhZGVyLnVuaWZvcm1zKCBnbG9iYWxfdW5pZm9ybXMgKTtcclxuXHRcdHNoYWRlci51bmlmb3JtcyggdGhpcy51bmlmb3JtcyApO1xyXG5cclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5vcGFjaXR5ID49IDEpXHJcblx0XHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGdsLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0aWYoIHRoaXMucHJvcGVydGllcy5hZGRpdGl2ZSApXHJcblx0XHR7XHJcblx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcclxuXHRcdFx0Z2wuZGVwdGhNYXNrKCBmYWxzZSApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gXCJpbmRpY2VzXCI7XHJcblx0XHRpZiggbWVzaC5pbmRleEJ1ZmZlcnMudHJpYW5nbGVzIClcclxuXHRcdFx0aW5kaWNlcyA9IFwidHJpYW5nbGVzXCI7XHJcblx0XHRzaGFkZXIuZHJhdyggbWVzaCwgcHJpbWl0aXZlLCBpbmRpY2VzICk7XHJcblx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuZGVwdGhNYXNrKCB0cnVlICk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9yZW5kZXJfbWVzaFwiLCBMR3JhcGhSZW5kZXJNZXNoICk7XHJcblxyXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInNpemVcIiwgXCJudW1iZXJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm1lc2hcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHR5cGU6IDEsIHNpemU6IDEsIHN1YmRpdmlzaW9uczogMzIgfTtcclxuXHJcblx0XHR0aGlzLnZlcnNpb24gPSAoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCl8MDtcclxuXHRcdHRoaXMubGFzdF9pbmZvID0geyB0eXBlOiAtMSwgc2l6ZTogLTEsIHN1YmRpdmlzaW9uczogLTEgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlLnRpdGxlID0gXCJQcmltaXRpdmVcIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQcmltaXRpdmUuVkFMSUQgPSB7IFwiQ1VCRVwiOjEsIFwiUExBTkVcIjoyLCBcIkNZTElOREVSXCI6MywgXCJTUEhFUkVcIjo0LCBcIkNJUkNMRVwiOjUsIFwiSEVNSVNQSEVSRVwiOjYsIFwiSUNPU0FIRURST05cIjo3LCBcIkNPTkVcIjo4LCBcIlFVQURcIjo5IH07XHJcblx0TEdyYXBoR2VvbWV0cnlQcmltaXRpdmUud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0dHlwZTogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZS5WQUxJRCB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQcmltaXRpdmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGlmKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSApXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgc2l6ZSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwic2l6ZVwiKTtcclxuXHJcblx0XHQvL3VwZGF0ZVxyXG5cdFx0aWYoIHRoaXMubGFzdF9pbmZvLnR5cGUgIT0gdGhpcy5wcm9wZXJ0aWVzLnR5cGUgfHwgdGhpcy5sYXN0X2luZm8uc2l6ZSAhPSBzaXplIHx8IHRoaXMubGFzdF9pbmZvLnN1YmRpdmlzaW9ucyAhPSB0aGlzLnByb3BlcnRpZXMuc3ViZGl2aXNpb25zIClcclxuXHRcdFx0dGhpcy51cGRhdGVNZXNoKCB0aGlzLnByb3BlcnRpZXMudHlwZSwgc2l6ZSwgdGhpcy5wcm9wZXJ0aWVzLnN1YmRpdmlzaW9ucyApO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuX21lc2gpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQcmltaXRpdmUucHJvdG90eXBlLnVwZGF0ZU1lc2ggPSBmdW5jdGlvbih0eXBlLCBzaXplLCBzdWJkaXZpc2lvbnMpXHJcblx0e1xyXG5cdFx0c3ViZGl2aXNpb25zID0gTWF0aC5tYXgoMCxzdWJkaXZpc2lvbnMpfDA7XHJcblxyXG5cdFx0c3dpdGNoICh0eXBlKVxyXG5cdFx0e1xyXG5cdFx0XHRjYXNlIDE6IC8vQ1VCRTogXHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guY3ViZSh7c2l6ZTogc2l6ZSwgbm9ybWFsczp0cnVlLGNvb3Jkczp0cnVlfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgMjogLy9QTEFORTpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5wbGFuZSh7c2l6ZTogc2l6ZSwgeHo6IHRydWUsIGRldGFpbDogc3ViZGl2aXNpb25zLCBub3JtYWxzOnRydWUsY29vcmRzOnRydWV9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAzOiAvL0NZTElOREVSOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLmN5bGluZGVyKHtzaXplOiBzaXplLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucywgbm9ybWFsczp0cnVlLGNvb3Jkczp0cnVlfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgNDogLy9TUEhFUkU6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guc3BoZXJlKHtzaXplOiBzaXplLCBcImxvbmdcIjogc3ViZGl2aXNpb25zLCBsYXQ6IHN1YmRpdmlzaW9ucywgbm9ybWFsczp0cnVlLGNvb3Jkczp0cnVlfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgNTogLy9DSVJDTEU6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guY2lyY2xlKHtzaXplOiBzaXplLCBzbGljZXM6IHN1YmRpdmlzaW9ucywgbm9ybWFsczp0cnVlLCBjb29yZHM6dHJ1ZX0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDY6IC8vSEVNSVNQSEVSRTpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5zcGhlcmUoe3NpemU6IHNpemUsIFwibG9uZ1wiOiBzdWJkaXZpc2lvbnMsIGxhdDogc3ViZGl2aXNpb25zLCBub3JtYWxzOnRydWUsIGNvb3Jkczp0cnVlLCBoZW1pOiB0cnVlfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgNzogLy9JQ09TQUhFRFJPTjpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5pY29zYWhlZHJvbih7c2l6ZTogc2l6ZSwgc3ViZGl2aXNpb25zOnN1YmRpdmlzaW9ucyB9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA4OiAvL0NPTkU6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guY29uZSh7cmFkaXVzOiBzaXplLCBoZWlnaHQ6IHNpemUsIHN1YmRpdmlzaW9uczpzdWJkaXZpc2lvbnMgfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgOTogLy9RVUFEOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLnBsYW5lKHtzaXplOiBzaXplLCB4ejogZmFsc2UsIGRldGFpbDogc3ViZGl2aXNpb25zLCBub3JtYWxzOnRydWUsIGNvb3Jkczp0cnVlIH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubGFzdF9pbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0dGhpcy5sYXN0X2luZm8uc2l6ZSA9IHNpemU7XHJcblx0XHR0aGlzLmxhc3RfaW5mby5zdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnM7XHJcblx0XHR0aGlzLl9tZXNoLnZlcnNpb24gPSB0aGlzLnZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L21lc2hfcHJpbWl0aXZlXCIsIExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhSZW5kZXJQb2ludHMoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtYXQ0XCIsIFwibWF0NFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ0ZXhcIiwgXCJ0ZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRlbmFibGVkOiB0cnVlLFxyXG5cdFx0XHRwb2ludF9zaXplOiAwLjEsXHJcblx0XHRcdGZpeGVkX3NpemU6IGZhbHNlLFxyXG5cdFx0XHRhZGRpdGl2ZTogdHJ1ZSxcclxuXHRcdFx0Y29sb3I6IFsxLDEsMV0sXHJcblx0XHRcdG9wYWNpdHk6IDFcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IHZlYzQuY3JlYXRlKFsxLDEsMSwxXSk7XHJcblxyXG5cdFx0dGhpcy51bmlmb3JtcyA9IHtcclxuXHRcdFx0dV9wb2ludF9zaXplOiAxLFxyXG5cdFx0XHR1X3BlcnNwZWN0aXZlOiAxLFxyXG5cdFx0XHR1X3BvaW50X3BlcnNwZWN0aXZlOiAxLFxyXG5cdFx0XHR1X2NvbG9yOiB0aGlzLmNvbG9yXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHcmFwaFJlbmRlclBvaW50cy50aXRsZSA9IFwicmVuZGVyUG9pbnRzXCI7XHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLmRlc2MgPSBcInJlbmRlciBwb2ludHMgd2l0aCBhIHRleHR1cmVcIjtcclxuXHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdGNvbG9yOiB7IHdpZGdldDogXCJjb2xvclwiIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhSZW5kZXJQb2ludHMucHJvdG90eXBlLnVwZGF0ZU1lc2ggPSBmdW5jdGlvbihnZW9tZXRyeSlcclxuXHR7XHJcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcblx0XHRpZighdGhpcy5idWZmZXIgfHwgIXRoaXMuYnVmZmVyLmRhdGEgfHwgdGhpcy5idWZmZXIuZGF0YS5sZW5ndGggIT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoKVxyXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBHTC5CdWZmZXIoIEdMLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkudmVydGljZXMsMyxHTC5EWU5BTUlDX0RSQVcpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmJ1ZmZlci5kYXRhLnNldCggZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0dGhpcy5idWZmZXIudXBsb2FkKEdMLkRZTkFNSUNfRFJBVyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIXRoaXMubWVzaClcclxuXHRcdFx0dGhpcy5tZXNoID0gbmV3IEdMLk1lc2goKTtcclxuXHJcblx0XHR0aGlzLm1lc2guYWRkQnVmZmVyKFwidmVydGljZXNcIix0aGlzLmJ1ZmZlcik7XHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gdGhpcy5tZXNoLmlkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gdGhpcy5tZXNoLnZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFJlbmRlclBvaW50cy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0aWYoIXRoaXMucHJvcGVydGllcy5lbmFibGVkKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighZ2VvbWV0cnkpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKHRoaXMudmVyc2lvbiAhPSBnZW9tZXRyeS5fdmVyc2lvbiB8fCB0aGlzLmdlb21ldHJ5X2lkICE9IGdlb21ldHJ5Ll9pZCApXHJcblx0XHRcdHRoaXMudXBkYXRlTWVzaCggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRpZighTGl0ZUdyYXBoLkxHcmFwaFJlbmRlci5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcylcclxuXHRcdHtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiY2Fubm90IHJlbmRlciBnZW9tZXRyeSwgTGl0ZUdyYXBoLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzIGlzIG51bGwsIHJlbWVtYmVyIHRvIGZpbGwgdGhpcyB3aXRoIGEgY2FsbGJhY2sodmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCkgdG8gdXNlIDNEIHJlbmRlcmluZyBmcm9tIHRoZSBncmFwaFwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdExpdGVHcmFwaC5MR3JhcGhSZW5kZXIub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMoIHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXggKTtcclxuXHRcdHZhciBzaGFkZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcblx0XHRcclxuXHRcdGlmKHRleHR1cmUpXHJcblx0XHR7XHJcblx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJ0ZXh0dXJlZF9wb2ludHNcIl07XHJcblx0XHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInRleHR1cmVkX3BvaW50c1wiXSA9IG5ldyBHTC5TaGFkZXIoIExHcmFwaFJlbmRlclBvaW50cy52ZXJ0ZXhfc2hhZGVyX2NvZGUsIExHcmFwaFJlbmRlclBvaW50cy5mcmFnbWVudF9zaGFkZXJfY29kZSwgeyBVU0VfVEVYVFVSRURfUE9JTlRTOlwiXCIgfSk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJwb2ludHNcIl07XHJcblx0XHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInBvaW50c1wiXSA9IG5ldyBHTC5TaGFkZXIoIExHcmFwaFJlbmRlclBvaW50cy52ZXJ0ZXhfc2hhZGVyX2NvZGUsIExHcmFwaFJlbmRlclBvaW50cy5mcmFnbWVudF9zaGFkZXJfY29kZSwgeyBVU0VfUE9JTlRTOiBcIlwiIH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29sb3Iuc2V0KCB0aGlzLnByb3BlcnRpZXMuY29sb3IgKTtcclxuXHRcdHRoaXMuY29sb3JbM10gPSB0aGlzLnByb3BlcnRpZXMub3BhY2l0eTtcclxuXHJcblx0XHR2YXIgbSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYobSlcclxuXHRcdFx0bW9kZWxfbWF0cml4LnNldChtKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bWF0NC5pZGVudGl0eSggbW9kZWxfbWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BvaW50X3NpemUgPSB0aGlzLnByb3BlcnRpZXMucG9pbnRfc2l6ZTtcclxuXHRcdHRoaXMudW5pZm9ybXMudV9wb2ludF9wZXJzcGVjdGl2ZSA9IHRoaXMucHJvcGVydGllcy5maXhlZF9zaXplID8gMCA6IDE7XHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcGVyc3BlY3RpdmUgPSBnbC52aWV3cG9ydF9kYXRhWzNdICogcHJvamVjdGlvbl9tYXRyaXhbNV07XHJcblxyXG5cdFx0c2hhZGVyLnVuaWZvcm1zKCBnbG9iYWxfdW5pZm9ybXMgKTtcclxuXHRcdHNoYWRlci51bmlmb3JtcyggdGhpcy51bmlmb3JtcyApO1xyXG5cclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5vcGFjaXR5ID49IDEpXHJcblx0XHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdGlmKCB0aGlzLnByb3BlcnRpZXMuYWRkaXRpdmUgKVxyXG5cdFx0e1xyXG5cdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XHJcblx0XHRcdGdsLmRlcHRoTWFzayggZmFsc2UgKTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcblx0XHRzaGFkZXIuZHJhdyggdGhpcy5tZXNoLCBHTC5QT0lOVFMgKTtcclxuXHJcblx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuZGVwdGhNYXNrKCB0cnVlICk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9yZW5kZXJfcG9pbnRzXCIsIExHcmFwaFJlbmRlclBvaW50cyApO1xyXG5cclxuXHRMR3JhcGhSZW5kZXJQb2ludHMudmVydGV4X3NoYWRlcl9jb2RlID0gJ1xcXHJcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXFxyXG5cdFx0YXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXg7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMyB2X3ZlcnRleDtcXG5cXFxyXG5cdFx0YXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHRhdHRyaWJ1dGUgdmVjMiBhX2Nvb3JkO1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9TSVpFXFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIGZsb2F0IGFfZXh0cmE7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHQjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgbWF0NCB1X21vZGVsO1xcblxcXHJcblx0XHQjZWxzZVxcblxcXHJcblx0XHRcdHVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0dW5pZm9ybSBtYXQ0IHVfdmlld3Byb2plY3Rpb247XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wb2ludF9zaXplO1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfcGVyc3BlY3RpdmU7XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wb2ludF9wZXJzcGVjdGl2ZTtcXG5cXFxyXG5cdFx0ZmxvYXQgY29tcHV0ZVBvaW50U2l6ZShmbG9hdCByYWRpdXMsIGZsb2F0IHcpXFxuXFxcclxuXHRcdHtcXG5cXFxyXG5cdFx0XHRpZihyYWRpdXMgPCAwLjApXFxuXFxcclxuXHRcdFx0XHRyZXR1cm4gLXJhZGl1cztcXG5cXFxyXG5cdFx0XHRyZXR1cm4gdV9wZXJzcGVjdGl2ZSAqIHJhZGl1cyAvIHc7XFxuXFxcclxuXHRcdH1cXG5cXFxyXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdHZfY29vcmQgPSBhX2Nvb3JkO1xcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgPSBhX2NvbG9yO1xcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdHZfdmVydGV4ID0gKCB1X21vZGVsICogdmVjNCggYV92ZXJ0ZXgsIDEuMCApKS54eXo7XFxuXFxcclxuXHRcdFx0dl9ub3JtYWwgPSAoIHVfbW9kZWwgKiB2ZWM0KCBhX25vcm1hbCwgMC4wICkpLnh5ejtcXG5cXFxyXG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHVfdmlld3Byb2plY3Rpb24gKiB2ZWM0KHZfdmVydGV4LDEuMCk7XFxuXFxcclxuXHRcdFx0Z2xfUG9pbnRTaXplID0gdV9wb2ludF9zaXplO1xcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfU0laRVxcblxcXHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gYV9leHRyYTtcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHRpZih1X3BvaW50X3BlcnNwZWN0aXZlICE9IDAuMClcXG5cXFxyXG5cdFx0XHRcdGdsX1BvaW50U2l6ZSA9IGNvbXB1dGVQb2ludFNpemUoIGdsX1BvaW50U2l6ZSwgZ2xfUG9zaXRpb24udyApO1xcblxcXHJcblx0XHR9XFxcclxuXHQnO1xyXG5cclxuXHRMR3JhcGhSZW5kZXJQb2ludHMuZnJhZ21lbnRfc2hhZGVyX2NvZGUgPSAnXFxcclxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcXHJcblx0XHR1bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdHZlYzQgY29sb3IgPSB1X2NvbG9yO1xcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfVEVYVFVSRURfUE9JTlRTXFxuXFxcclxuXHRcdFx0XHRjb2xvciAqPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCBnbF9Qb2ludENvb3JkLnh5KTtcXG5cXFxyXG5cdFx0XHQjZWxzZVxcblxcXHJcblx0XHRcdFx0I2lmZGVmIFVTRV9URVhUVVJFXFxuXFxcclxuXHRcdFx0XHQgIGNvbG9yICo9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0ICBpZihjb2xvci5hIDwgMC4xKVxcblxcXHJcblx0XHRcdFx0XHRkaXNjYXJkO1xcblxcXHJcblx0XHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0XHQjaWZkZWYgVVNFX1BPSU5UU1xcblxcXHJcblx0XHRcdFx0XHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCBnbF9Qb2ludENvb3JkLnh5IC0gdmVjMigwLjUpICk7XFxuXFxcclxuXHRcdFx0XHRcdGlmKCBkaXN0ID4gMC40NSApXFxuXFxcclxuXHRcdFx0XHRcdFx0ZGlzY2FyZDtcXG5cXFxyXG5cdFx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHRcdGNvbG9yICo9IHZfY29sb3I7XFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcclxuXHRcdH1cXFxyXG5cdCc7XHJcblxyXG5cdC8vYmFzZWQgb24gaHR0cHM6Ly9pbmNvbnZlcmdlbnQubmV0LzIwMTkvZGVwdGgtb2YtZmllbGQvXHJcblx0LypcclxuXHRmdW5jdGlvbiBMR3JhcGhSZW5kZXJHZW9tZXRyeURPRigpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1hdDRcIiwgXCJtYXQ0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInRleFwiLCBcInRleHR1cmVcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRcdGxpbmVzOiB0cnVlLFxyXG5cdFx0XHRwb2ludF9zaXplOiAwLjEsXHJcblx0XHRcdGZpeGVkX3NpemU6IGZhbHNlLFxyXG5cdFx0XHRhZGRpdGl2ZTogdHJ1ZSxcclxuXHRcdFx0Y29sb3I6IFsxLDEsMV0sXHJcblx0XHRcdG9wYWNpdHk6IDFcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IHZlYzQuY3JlYXRlKFsxLDEsMSwxXSk7XHJcblxyXG5cdFx0dGhpcy51bmlmb3JtcyA9IHtcclxuXHRcdFx0dV9wb2ludF9zaXplOiAxLFxyXG5cdFx0XHR1X3BlcnNwZWN0aXZlOiAxLFxyXG5cdFx0XHR1X3BvaW50X3BlcnNwZWN0aXZlOiAxLFxyXG5cdFx0XHR1X2NvbG9yOiB0aGlzLmNvbG9yXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdGNvbG9yOiB7IHdpZGdldDogXCJjb2xvclwiIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi5wcm90b3R5cGUudXBkYXRlTWVzaCA9IGZ1bmN0aW9uKGdlb21ldHJ5KVxyXG5cdHtcclxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuXHRcdGlmKCF0aGlzLmJ1ZmZlciB8fCB0aGlzLmJ1ZmZlci5kYXRhLmxlbmd0aCAhPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGgpXHJcblx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEdMLkJ1ZmZlciggR0wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS52ZXJ0aWNlcywzLEdMLkRZTkFNSUNfRFJBVyk7XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuYnVmZmVyLmRhdGEuc2V0KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHR0aGlzLmJ1ZmZlci51cGxvYWQoR0wuRFlOQU1JQ19EUkFXKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZighdGhpcy5tZXNoKVxyXG5cdFx0XHR0aGlzLm1lc2ggPSBuZXcgR0wuTWVzaCgpO1xyXG5cclxuXHRcdHRoaXMubWVzaC5hZGRCdWZmZXIoXCJ2ZXJ0aWNlc1wiLHRoaXMuYnVmZmVyKTtcclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSB0aGlzLm1lc2guaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHR0aGlzLnZlcnNpb24gPSB0aGlzLm1lc2gudmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUmVuZGVyR2VvbWV0cnlET0YucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGlmKCF0aGlzLnByb3BlcnRpZXMuZW5hYmxlZClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWdlb21ldHJ5KVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRpZih0aGlzLnZlcnNpb24gIT0gZ2VvbWV0cnkuX3ZlcnNpb24gfHwgdGhpcy5nZW9tZXRyeV9pZCAhPSBnZW9tZXRyeS5faWQgKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1lc2goIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0aWYoIUxpdGVHcmFwaC5MR3JhcGhSZW5kZXIub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMpXHJcblx0XHR7XHJcblx0XHRcdGNvbnNvbGUud2FybihcImNhbm5vdCByZW5kZXIgZ2VvbWV0cnksIExpdGVHcmFwaC5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcyBpcyBudWxsLCByZW1lbWJlciB0byBmaWxsIHRoaXMgd2l0aCBhIGNhbGxiYWNrKHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXgpIHRvIHVzZSAzRCByZW5kZXJpbmcgZnJvbSB0aGUgZ3JhcGhcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRMaXRlR3JhcGguTEdyYXBoUmVuZGVyLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzKCB2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4ICk7XHJcblx0XHR2YXIgc2hhZGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG5cdFx0XHJcblx0XHRpZih0ZXh0dXJlKVxyXG5cdFx0e1xyXG5cdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1widGV4dHVyZWRfcG9pbnRzXCJdO1xyXG5cdFx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJ0ZXh0dXJlZF9wb2ludHNcIl0gPSBuZXcgR0wuU2hhZGVyKCBMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi52ZXJ0ZXhfc2hhZGVyX2NvZGUsIExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLmZyYWdtZW50X3NoYWRlcl9jb2RlLCB7IFVTRV9URVhUVVJFRF9QT0lOVFM6XCJcIiB9KTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInBvaW50c1wiXTtcclxuXHRcdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1wicG9pbnRzXCJdID0gbmV3IEdMLlNoYWRlciggTEdyYXBoUmVuZGVyR2VvbWV0cnlET0YudmVydGV4X3NoYWRlcl9jb2RlLCBMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi5mcmFnbWVudF9zaGFkZXJfY29kZSwgeyBVU0VfUE9JTlRTOiBcIlwiIH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29sb3Iuc2V0KCB0aGlzLnByb3BlcnRpZXMuY29sb3IgKTtcclxuXHRcdHRoaXMuY29sb3JbM10gPSB0aGlzLnByb3BlcnRpZXMub3BhY2l0eTtcclxuXHJcblx0XHR2YXIgbSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYobSlcclxuXHRcdFx0bW9kZWxfbWF0cml4LnNldChtKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bWF0NC5pZGVudGl0eSggbW9kZWxfbWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BvaW50X3NpemUgPSB0aGlzLnByb3BlcnRpZXMucG9pbnRfc2l6ZTtcclxuXHRcdHRoaXMudW5pZm9ybXMudV9wb2ludF9wZXJzcGVjdGl2ZSA9IHRoaXMucHJvcGVydGllcy5maXhlZF9zaXplID8gMCA6IDE7XHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcGVyc3BlY3RpdmUgPSBnbC52aWV3cG9ydF9kYXRhWzNdICogcHJvamVjdGlvbl9tYXRyaXhbNV07XHJcblxyXG5cdFx0c2hhZGVyLnVuaWZvcm1zKCBnbG9iYWxfdW5pZm9ybXMgKTtcclxuXHRcdHNoYWRlci51bmlmb3JtcyggdGhpcy51bmlmb3JtcyApO1xyXG5cclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5vcGFjaXR5ID49IDEpXHJcblx0XHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdGlmKCB0aGlzLnByb3BlcnRpZXMuYWRkaXRpdmUgKVxyXG5cdFx0e1xyXG5cdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XHJcblx0XHRcdGdsLmRlcHRoTWFzayggZmFsc2UgKTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcblx0XHRzaGFkZXIuZHJhdyggdGhpcy5tZXNoLCBHTC5QT0lOVFMgKTtcclxuXHJcblx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuZGVwdGhNYXNrKCB0cnVlICk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9yZW5kZXJfZG9mXCIsIExHcmFwaFJlbmRlckdlb21ldHJ5RE9GICk7XHJcblxyXG5cdExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLnZlcnRleF9zaGFkZXJfY29kZSA9ICdcXFxyXG5cdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxcclxuXHRcdGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4O1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzMgdl92ZXJ0ZXg7XFxuXFxcclxuXHRcdGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0YXR0cmlidXRlIHZlYzIgYV9jb29yZDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfU0laRVxcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSBmbG9hdCBhX2V4dHJhO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIG1hdDQgdV9tb2RlbDtcXG5cXFxyXG5cdFx0I2Vsc2VcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIG1hdDQgdV9tb2RlbDtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdHVuaWZvcm0gbWF0NCB1X3ZpZXdwcm9qZWN0aW9uO1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfcG9pbnRfc2l6ZTtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BlcnNwZWN0aXZlO1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfcG9pbnRfcGVyc3BlY3RpdmU7XFxuXFxcclxuXHRcdGZsb2F0IGNvbXB1dGVQb2ludFNpemUoZmxvYXQgcmFkaXVzLCBmbG9hdCB3KVxcblxcXHJcblx0XHR7XFxuXFxcclxuXHRcdFx0aWYocmFkaXVzIDwgMC4wKVxcblxcXHJcblx0XHRcdFx0cmV0dXJuIC1yYWRpdXM7XFxuXFxcclxuXHRcdFx0cmV0dXJuIHVfcGVyc3BlY3RpdmUgKiByYWRpdXMgLyB3O1xcblxcXHJcblx0XHR9XFxuXFxcclxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHR2X2Nvb3JkID0gYV9jb29yZDtcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yID0gYV9jb2xvcjtcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHR2X3ZlcnRleCA9ICggdV9tb2RlbCAqIHZlYzQoIGFfdmVydGV4LCAxLjAgKSkueHl6O1xcblxcXHJcblx0XHRcdHZfbm9ybWFsID0gKCB1X21vZGVsICogdmVjNCggYV9ub3JtYWwsIDAuMCApKS54eXo7XFxuXFxcclxuXHRcdFx0Z2xfUG9zaXRpb24gPSB1X3ZpZXdwcm9qZWN0aW9uICogdmVjNCh2X3ZlcnRleCwxLjApO1xcblxcXHJcblx0XHRcdGdsX1BvaW50U2l6ZSA9IHVfcG9pbnRfc2l6ZTtcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX1NJWkVcXG5cXFxyXG5cdFx0XHRcdGdsX1BvaW50U2l6ZSA9IGFfZXh0cmE7XFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0aWYodV9wb2ludF9wZXJzcGVjdGl2ZSAhPSAwLjApXFxuXFxcclxuXHRcdFx0XHRnbF9Qb2ludFNpemUgPSBjb21wdXRlUG9pbnRTaXplKCBnbF9Qb2ludFNpemUsIGdsX1Bvc2l0aW9uLncgKTtcXG5cXFxyXG5cdFx0fVxcXHJcblx0JztcclxuXHJcblx0TEdyYXBoUmVuZGVyR2VvbWV0cnlET0YuZnJhZ21lbnRfc2hhZGVyX2NvZGUgPSAnXFxcclxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcXHJcblx0XHR1bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdHZlYzQgY29sb3IgPSB1X2NvbG9yO1xcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfVEVYVFVSRURfUE9JTlRTXFxuXFxcclxuXHRcdFx0XHRjb2xvciAqPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCBnbF9Qb2ludENvb3JkLnh5KTtcXG5cXFxyXG5cdFx0XHQjZWxzZVxcblxcXHJcblx0XHRcdFx0I2lmZGVmIFVTRV9URVhUVVJFXFxuXFxcclxuXHRcdFx0XHQgIGNvbG9yICo9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0ICBpZihjb2xvci5hIDwgMC4xKVxcblxcXHJcblx0XHRcdFx0XHRkaXNjYXJkO1xcblxcXHJcblx0XHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0XHQjaWZkZWYgVVNFX1BPSU5UU1xcblxcXHJcblx0XHRcdFx0XHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCBnbF9Qb2ludENvb3JkLnh5IC0gdmVjMigwLjUpICk7XFxuXFxcclxuXHRcdFx0XHRcdGlmKCBkaXN0ID4gMC40NSApXFxuXFxcclxuXHRcdFx0XHRcdFx0ZGlzY2FyZDtcXG5cXFxyXG5cdFx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHRcdGNvbG9yICo9IHZfY29sb3I7XFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcclxuXHRcdH1cXFxyXG5cdCc7XHJcblx0Ki9cclxuXHJcblxyXG5cclxufSkodGhpcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuICAgIHZhciBMR3JhcGhUZXh0dXJlID0gZ2xvYmFsLkxHcmFwaFRleHR1cmU7XHJcblxyXG4gICAgLy9Xb3JrcyB3aXRoIExpdGVnbC5qcyB0byBjcmVhdGUgV2ViR0wgbm9kZXNcclxuICAgIGlmICh0eXBlb2YgR0wgIT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIC8vIFRleHR1cmUgTGVucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIGZ1bmN0aW9uIExHcmFwaEZYTGVucygpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiQWJlcnJhdGlvblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIkRpc3RvcnRpb25cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCbHVyXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBhYmVycmF0aW9uOiAxLjAsXHJcbiAgICAgICAgICAgICAgICBkaXN0b3J0aW9uOiAxLjAsXHJcbiAgICAgICAgICAgICAgICBibHVyOiAxLjAsXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCFMR3JhcGhGWExlbnMuX3NoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgTEdyYXBoRlhMZW5zLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgICAgICAgICBMR3JhcGhGWExlbnMucGl4ZWxfc2hhZGVyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgTEdyYXBoRlhMZW5zLl90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoMywgMSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZ2wuUkdCLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX0VER0UsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFnRmlsdGVyOiBnbC5MSU5FQVIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyOiBnbC5MSU5FQVIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxfZGF0YTogWzI1NSwgMCwgMCwgMCwgMjU1LCAwLCAwLCAwLCAyNTVdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTEdyYXBoRlhMZW5zLnRpdGxlID0gXCJMZW5zXCI7XHJcbiAgICAgICAgTEdyYXBoRlhMZW5zLmRlc2MgPSBcIkNhbWVyYSBMZW5zIGRpc3RvcnRpb25cIjtcclxuICAgICAgICBMR3JhcGhGWExlbnMud2lkZ2V0c19pbmZvID0ge1xyXG4gICAgICAgICAgICBwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhMZW5zLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICB0ZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWJlcnJhdGlvbiA9IHRoaXMucHJvcGVydGllcy5hYmVycmF0aW9uO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XHJcbiAgICAgICAgICAgICAgICBhYmVycmF0aW9uID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuYWJlcnJhdGlvbiA9IGFiZXJyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaXN0b3J0aW9uID0gdGhpcy5wcm9wZXJ0aWVzLmRpc3RvcnRpb247XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMikpIHtcclxuICAgICAgICAgICAgICAgIGRpc3RvcnRpb24gPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5kaXN0b3J0aW9uID0gZGlzdG9ydGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGJsdXIgPSB0aGlzLnByb3BlcnRpZXMuYmx1cjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgzKSkge1xyXG4gICAgICAgICAgICAgICAgYmx1ciA9IHRoaXMuZ2V0SW5wdXREYXRhKDMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmJsdXIgPSBibHVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgdmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcclxuICAgICAgICAgICAgdmFyIHNoYWRlciA9IExHcmFwaEZYTGVucy5fc2hhZGVyO1xyXG4gICAgICAgICAgICAvL3ZhciBjYW1lcmEgPSBMUy5SZW5kZXJlci5fY3VycmVudF9jYW1lcmE7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGV4LmJpbmQoMCk7XHJcbiAgICAgICAgICAgICAgICBzaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICAudW5pZm9ybXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHR1cmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfYWJlcnJhdGlvbjogYWJlcnJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9kaXN0b3J0aW9uOiBkaXN0b3J0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2JsdXI6IGJsdXJcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5kcmF3KG1lc2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYTGVucy5waXhlbF9zaGFkZXIgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X2NhbWVyYV9wbGFuZXM7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X2FiZXJyYXRpb247XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X2Rpc3RvcnRpb247XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjMiBjb29yZCA9IHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBkaXN0ID0gZGlzdGFuY2UodmVjMigwLjUpLCBjb29yZCk7XFxuXFxcclxuXHRcdFx0XHR2ZWMyIGRpc3RfY29vcmQgPSBjb29yZCAtIHZlYzIoMC41KTtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IHBlcmNlbnQgPSAxLjAgKyAoKDAuNSAtIGRpc3QpIC8gMC41KSAqIHVfZGlzdG9ydGlvbjtcXG5cXFxyXG5cdFx0XHRcdGRpc3RfY29vcmQgKj0gcGVyY2VudDtcXG5cXFxyXG5cdFx0XHRcdGNvb3JkID0gZGlzdF9jb29yZCArIHZlYzIoMC41KTtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLGNvb3JkLCB1X2JsdXIgKiBkaXN0KTtcXG5cXFxyXG5cdFx0XHRcdGNvbG9yLnIgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLHZlYzIoMC41KSArIGRpc3RfY29vcmQgKiAoMS4wKzAuMDEqdV9hYmVycmF0aW9uKSwgdV9ibHVyICogZGlzdCApLnI7XFxuXFxcclxuXHRcdFx0XHRjb2xvci5iID0gdGV4dHVyZTJEKHVfdGV4dHVyZSx2ZWMyKDAuNSkgKyBkaXN0X2Nvb3JkICogKDEuMC0wLjAxKnVfYWJlcnJhdGlvbiksIHVfYmx1ciAqIGRpc3QgKS5iO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcclxuXHRcdFx0fVxcblxcXHJcblx0XHRcdFwiO1xyXG4gICAgICAgIC8qXHJcblx0XHRcdGZsb2F0IG5vcm1hbGl6ZWRfdHVuYWJsZV9zaWdtb2lkKGZsb2F0IHhzLCBmbG9hdCBrKVxcblxcXHJcblx0XHRcdHtcXG5cXFxyXG5cdFx0XHRcdHhzID0geHMgKiAyLjAgLSAxLjA7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBzaWdueCA9IHNpZ24oeHMpO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgYWJzeCA9IGFicyh4cyk7XFxuXFxcclxuXHRcdFx0XHRyZXR1cm4gc2lnbnggKiAoKC1rIC0gMS4wKSphYnN4KS8oMi4wKigtMi4wKmsqYWJzeCtrLTEuMCkpICsgMC41O1xcblxcXHJcblx0XHRcdH1cXG5cXFxyXG5cdFx0Ki9cclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJmeC9sZW5zXCIsIExHcmFwaEZYTGVucyk7XHJcbiAgICAgICAgZ2xvYmFsLkxHcmFwaEZYTGVucyA9IExHcmFwaEZYTGVucztcclxuXHJcbiAgICAgICAgLyogbm90IHdvcmtpbmcgeWV0XHJcblx0ZnVuY3Rpb24gTEdyYXBoRGVwdGhPZkZpZWxkKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQ29sb3JcIixcIlRleHR1cmVcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiTGluZWFyIERlcHRoXCIsXCJUZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkNhbWVyYVwiLFwiY2FtZXJhXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsXCJUZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBoaWdoX3ByZWNpc2lvbjogZmFsc2UgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaERlcHRoT2ZGaWVsZC50aXRsZSA9IFwiRGVwdGggT2YgRmllbGRcIjtcclxuXHRMR3JhcGhEZXB0aE9mRmllbGQuZGVzYyA9IFwiQXBwbGllcyBhIGRlcHRoIG9mIGZpZWxkIGVmZmVjdFwiO1xyXG5cclxuXHRMR3JhcGhEZXB0aE9mRmllbGQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHR2YXIgZGVwdGggPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdHZhciBjYW1lcmEgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuXHJcblx0XHRpZighdGV4IHx8ICFkZXB0aCB8fCAhY2FtZXJhKSBcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlY2lzaW9uID0gZ2wuVU5TSUdORURfQllURTtcclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5oaWdoX3ByZWNpc2lvbilcclxuXHRcdFx0cHJlY2lzaW9uID0gZ2wuaGFsZl9mbG9hdF9leHQgPyBnbC5IQUxGX0ZMT0FUX09FUyA6IGdsLkZMT0FUO1x0XHRcdFxyXG5cdFx0aWYoIXRoaXMuX3RlbXBfdGV4dHVyZSB8fCB0aGlzLl90ZW1wX3RleHR1cmUudHlwZSAhPSBwcmVjaXNpb24gfHxcclxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLndpZHRoICE9IHRleC53aWR0aCB8fCB0aGlzLl90ZW1wX3RleHR1cmUuaGVpZ2h0ICE9IHRleC5oZWlnaHQpXHJcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKCB0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHsgdHlwZTogcHJlY2lzaW9uLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH0pO1xyXG5cclxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhEZXB0aE9mRmllbGQuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoRGVwdGhPZkZpZWxkLl9waXhlbF9zaGFkZXIgKTtcclxuXHJcblx0XHR2YXIgc2NyZWVuX21lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcclxuXHJcblx0XHRnbC5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdHZhciBjYW1lcmFfcG9zaXRpb24gPSBjYW1lcmEuZ2V0RXllKCk7XHJcblx0XHR2YXIgZm9jdXNfcG9pbnQgPSBjYW1lcmEuZ2V0Q2VudGVyKCk7XHJcblx0XHR2YXIgZGlzdGFuY2UgPSB2ZWMzLmRpc3RhbmNlKCBjYW1lcmFfcG9zaXRpb24sIGZvY3VzX3BvaW50ICk7XHJcblx0XHR2YXIgZmFyID0gY2FtZXJhLmZhcjtcclxuXHRcdHZhciBmb2N1c19yYW5nZSA9IGRpc3RhbmNlICogMC41O1xyXG5cclxuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0ZXguYmluZCgwKTtcclxuXHRcdFx0ZGVwdGguYmluZCgxKTtcclxuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHt1X3RleHR1cmU6MCwgdV9kZXB0aF90ZXh0dXJlOjEsIHVfcmVzb2x1dGlvbjogWzEvdGV4LndpZHRoLCAxL3RleC5oZWlnaHRdLCB1X2ZhcjogZmFyLCB1X2ZvY3VzX3BvaW50OiBkaXN0YW5jZSwgdV9mb2N1c19zY2FsZTogZm9jdXNfcmFuZ2UgfSkuZHJhdyhzY3JlZW5fbWVzaCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcclxuXHR9XHJcblxyXG5cdC8vZnJvbSBodHRwOi8vdHV4ZWRvbGFicy5ibG9nc3BvdC5jb20uZXMvMjAxOC8wNS9ib2tlaC1kZXB0aC1vZi1maWVsZC1pbi1zaW5nbGUtcGFzcy5odG1sXHJcblx0TEdyYXBoRGVwdGhPZkZpZWxkLl9waXhlbF9zaGFkZXIgPSBcIlxcblxcXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7IC8vSW1hZ2UgdG8gYmUgcHJvY2Vzc2VkXFxuXFxcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfZGVwdGhfdGV4dHVyZTsgLy9MaW5lYXIgZGVwdGgsIHdoZXJlIDEuMCA9PSBmYXIgcGxhbmVcXG5cXFxyXG5cdFx0dW5pZm9ybSB2ZWMyIHVfaXJlc29sdXRpb247IC8vVGhlIHNpemUgb2YgYSBwaXhlbDogdmVjMigxLjAvd2lkdGgsIDEuMC9oZWlnaHQpXFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mYXI7IC8vIEZhciBwbGFuZVxcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfZm9jdXNfcG9pbnQ7XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mb2N1c19zY2FsZTtcXG5cXFxyXG5cdFx0XFxuXFxcclxuXHRcdGNvbnN0IGZsb2F0IEdPTERFTl9BTkdMRSA9IDIuMzk5OTYzMjM7XFxuXFxcclxuXHRcdGNvbnN0IGZsb2F0IE1BWF9CTFVSX1NJWkUgPSAyMC4wO1xcblxcXHJcblx0XHRjb25zdCBmbG9hdCBSQURfU0NBTEUgPSAwLjU7IC8vIFNtYWxsZXIgPSBuaWNlciBibHVyLCBsYXJnZXIgPSBmYXN0ZXJcXG5cXFxyXG5cdFx0XFxuXFxcclxuXHRcdGZsb2F0IGdldEJsdXJTaXplKGZsb2F0IGRlcHRoLCBmbG9hdCBmb2N1c1BvaW50LCBmbG9hdCBmb2N1c1NjYWxlKVxcblxcXHJcblx0XHR7XFxuXFxcclxuXHRcdCBmbG9hdCBjb2MgPSBjbGFtcCgoMS4wIC8gZm9jdXNQb2ludCAtIDEuMCAvIGRlcHRoKSpmb2N1c1NjYWxlLCAtMS4wLCAxLjApO1xcblxcXHJcblx0XHQgcmV0dXJuIGFicyhjb2MpICogTUFYX0JMVVJfU0laRTtcXG5cXFxyXG5cdFx0fVxcblxcXHJcblx0XHRcXG5cXFxyXG5cdFx0dmVjMyBkZXB0aE9mRmllbGQodmVjMiB0ZXhDb29yZCwgZmxvYXQgZm9jdXNQb2ludCwgZmxvYXQgZm9jdXNTY2FsZSlcXG5cXFxyXG5cdFx0e1xcblxcXHJcblx0XHQgZmxvYXQgY2VudGVyRGVwdGggPSB0ZXh0dXJlMkQodV9kZXB0aF90ZXh0dXJlLCB0ZXhDb29yZCkuciAqIHVfZmFyO1xcblxcXHJcblx0XHQgZmxvYXQgY2VudGVyU2l6ZSA9IGdldEJsdXJTaXplKGNlbnRlckRlcHRoLCBmb2N1c1BvaW50LCBmb2N1c1NjYWxlKTtcXG5cXFxyXG5cdFx0IHZlYzMgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKS5yZ2I7XFxuXFxcclxuXHRcdCBmbG9hdCB0b3QgPSAxLjA7XFxuXFxcclxuXHRcdFxcblxcXHJcblx0XHQgZmxvYXQgcmFkaXVzID0gUkFEX1NDQUxFO1xcblxcXHJcblx0XHQgZm9yIChmbG9hdCBhbmcgPSAwLjA7IGFuZyA8IDEwMC4wOyBhbmcgKz0gR09MREVOX0FOR0xFKVxcblxcXHJcblx0XHQge1xcblxcXHJcblx0XHQgIHZlYzIgdGMgPSB0ZXhDb29yZCArIHZlYzIoY29zKGFuZyksIHNpbihhbmcpKSAqIHVfaXJlc29sdXRpb24gKiByYWRpdXM7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdCAgdmVjMyBzYW1wbGVDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHRjKS5yZ2I7XFxuXFxcclxuXHRcdCAgZmxvYXQgc2FtcGxlRGVwdGggPSB0ZXh0dXJlMkQodV9kZXB0aF90ZXh0dXJlLCB0YykuciAqIHVfZmFyO1xcblxcXHJcblx0XHQgIGZsb2F0IHNhbXBsZVNpemUgPSBnZXRCbHVyU2l6ZSggc2FtcGxlRGVwdGgsIGZvY3VzUG9pbnQsIGZvY3VzU2NhbGUgKTtcXG5cXFxyXG5cdFx0ICBpZiAoc2FtcGxlRGVwdGggPiBjZW50ZXJEZXB0aClcXG5cXFxyXG5cdFx0ICAgc2FtcGxlU2l6ZSA9IGNsYW1wKHNhbXBsZVNpemUsIDAuMCwgY2VudGVyU2l6ZSoyLjApO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHQgIGZsb2F0IG0gPSBzbW9vdGhzdGVwKHJhZGl1cy0wLjUsIHJhZGl1cyswLjUsIHNhbXBsZVNpemUpO1xcblxcXHJcblx0XHQgIGNvbG9yICs9IG1peChjb2xvci90b3QsIHNhbXBsZUNvbG9yLCBtKTtcXG5cXFxyXG5cdFx0ICB0b3QgKz0gMS4wO1xcblxcXHJcblx0XHQgIHJhZGl1cyArPSBSQURfU0NBTEUvcmFkaXVzO1xcblxcXHJcblx0XHQgIGlmKHJhZGl1cz49TUFYX0JMVVJfU0laRSlcXG5cXFxyXG5cdFx0XHQgcmV0dXJuIGNvbG9yIC8gdG90O1xcblxcXHJcblx0XHQgfVxcblxcXHJcblx0XHQgcmV0dXJuIGNvbG9yIC8gdG90O1xcblxcXHJcblx0XHR9XFxuXFxcclxuXHRcdHZvaWQgbWFpbigpXFxuXFxcclxuXHRcdHtcXG5cXFxyXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkZXB0aE9mRmllbGQoIHZfY29vcmQsIHVfZm9jdXNfcG9pbnQsIHVfZm9jdXNfc2NhbGUgKSwgMS4wICk7XFxuXFxcclxuXHRcdFx0Ly9nbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQodV9kZXB0aF90ZXh0dXJlLCB2X2Nvb3JkKS5yICk7XFxuXFxcclxuXHRcdH1cXG5cXFxyXG5cdFx0XCI7XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZngvRE9GXCIsIExHcmFwaERlcHRoT2ZGaWVsZCApO1xyXG5cdGdsb2JhbC5MR3JhcGhEZXB0aE9mRmllbGQgPSBMR3JhcGhEZXB0aE9mRmllbGQ7XHJcblx0Ki9cclxuXHJcbiAgICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIExHcmFwaEZYQm9rZWgoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJsdXJyZWRcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiTWFza1wiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJUaHJlc2hvbGRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMTAsXHJcbiAgICAgICAgICAgICAgICBhbHBoYTogMS4wLFxyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxLjAsXHJcbiAgICAgICAgICAgICAgICBoaWdoX3ByZWNpc2lvbjogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWgudGl0bGUgPSBcIkJva2VoXCI7XHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC5kZXNjID0gXCJhcHBsaWVzIGFuIEJva2VoIGVmZmVjdFwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLndpZGdldHNfaW5mbyA9IHsgc2hhcGU6IHsgd2lkZ2V0OiBcInRleHR1cmVcIiB9IH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIHZhciBibHVycmVkX3RleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICB2YXIgbWFza190ZXggPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICAgICAgaWYgKCF0ZXggfHwgIW1hc2tfdGV4IHx8ICF0aGlzLnByb3BlcnRpZXMuc2hhcGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJsdXJyZWRfdGV4KSB7XHJcbiAgICAgICAgICAgICAgICBibHVycmVkX3RleCA9IHRleDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZSh0aGlzLnByb3BlcnRpZXMuc2hhcGUpO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXBlX3RleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5wcm9wZXJ0aWVzLnRocmVzaG9sZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gdGhpcy5nZXRJbnB1dERhdGEoMyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gZ2wuVU5TSUdORURfQllURTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oaWdoX3ByZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gZ2wuaGFsZl9mbG9hdF9leHQgPyBnbC5IQUxGX0ZMT0FUX09FUyA6IGdsLkZMT0FUO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICF0aGlzLl90ZW1wX3RleHR1cmUgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBfdGV4dHVyZS50eXBlICE9IHByZWNpc2lvbiB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcF90ZXh0dXJlLndpZHRoICE9IHRleC53aWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcF90ZXh0dXJlLmhlaWdodCAhPSB0ZXguaGVpZ2h0XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJlY2lzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZ2wuUkdCQSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGdsLkxJTkVBUlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMucHJvcGVydGllcy5zaXplO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZpcnN0X3NoYWRlciA9IExHcmFwaEZYQm9rZWguX2ZpcnN0X3NoYWRlcjtcclxuICAgICAgICAgICAgaWYgKCFmaXJzdF9zaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0X3NoYWRlciA9IExHcmFwaEZYQm9rZWguX2ZpcnN0X3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxyXG4gICAgICAgICAgICAgICAgICAgIExHcmFwaEZYQm9rZWguX2ZpcnN0X3BpeGVsX3NoYWRlclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNlY29uZF9zaGFkZXIgPSBMR3JhcGhGWEJva2VoLl9zZWNvbmRfc2hhZGVyO1xyXG4gICAgICAgICAgICBpZiAoIXNlY29uZF9zaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHNlY29uZF9zaGFkZXIgPSBMR3JhcGhGWEJva2VoLl9zZWNvbmRfc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcclxuICAgICAgICAgICAgICAgICAgICBMR3JhcGhGWEJva2VoLl9zZWNvbmRfdmVydGV4X3NoYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBMR3JhcGhGWEJva2VoLl9zZWNvbmRfcGl4ZWxfc2hhZGVyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9pbnRzX21lc2ggPSB0aGlzLl9wb2ludHNfbWVzaDtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgIXBvaW50c19tZXNoIHx8XHJcbiAgICAgICAgICAgICAgICBwb2ludHNfbWVzaC5fd2lkdGggIT0gdGV4LndpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICBwb2ludHNfbWVzaC5faGVpZ2h0ICE9IHRleC5oZWlnaHQgfHxcclxuICAgICAgICAgICAgICAgIHBvaW50c19tZXNoLl9zcGFjaW5nICE9IDJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNfbWVzaCA9IHRoaXMuY3JlYXRlUG9pbnRzTWVzaCh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIDIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2NyZWVuX21lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb2ludF9zaXplID0gdGhpcy5wcm9wZXJ0aWVzLnNpemU7XHJcbiAgICAgICAgICAgIHZhciBtaW5fbGlnaHQgPSB0aGlzLnByb3BlcnRpZXMubWluX2xpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLnByb3BlcnRpZXMuYWxwaGE7XHJcblxyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXguYmluZCgwKTtcclxuICAgICAgICAgICAgICAgIGJsdXJyZWRfdGV4LmJpbmQoMSk7XHJcbiAgICAgICAgICAgICAgICBtYXNrX3RleC5iaW5kKDIpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3Rfc2hhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnVuaWZvcm1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXh0dXJlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHR1cmVfYmx1cjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9tYXNrOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHNpemU6IFt0ZXgud2lkdGgsIHRleC5oZWlnaHRdXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZHJhdyhzY3JlZW5fbWVzaCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vY2xlYXIgYmVjYXVzZSB3ZSB1c2UgYmxlbmRpbmdcclxuICAgICAgICAgICAgICAgIC8vZ2wuY2xlYXJDb2xvcigwLjAsMC4wLDAuMCwxLjApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5jbGVhciggZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4LmJpbmQoMCk7XHJcbiAgICAgICAgICAgICAgICBzaGFwZV90ZXguYmluZCgzKTtcclxuICAgICAgICAgICAgICAgIHNlY29uZF9zaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICAudW5pZm9ybXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHR1cmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfbWFzazogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9zaGFwZTogMyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9hbHBoYTogYWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGhyZXNob2xkOiB0aHJlc2hvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfcG9pbnRTaXplOiBwb2ludF9zaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2l0ZXhzaXplOiBbMS4wIC8gdGV4LndpZHRoLCAxLjAgLyB0ZXguaGVpZ2h0XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRyYXcocG9pbnRzX21lc2gsIGdsLlBPSU5UUyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC5wcm90b3R5cGUuY3JlYXRlUG9pbnRzTWVzaCA9IGZ1bmN0aW9uKFxyXG4gICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICBzcGFjaW5nXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHZhciBud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoIC8gc3BhY2luZyk7XHJcbiAgICAgICAgICAgIHZhciBuaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgLyBzcGFjaW5nKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkobndpZHRoICogbmhlaWdodCAqIDIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG55ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBkeCA9ICgyIC8gd2lkdGgpICogc3BhY2luZztcclxuICAgICAgICAgICAgdmFyIGR5ID0gKDIgLyBoZWlnaHQpICogc3BhY2luZztcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBuaGVpZ2h0OyArK3kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBueCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBud2lkdGg7ICsreCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB5ICogbndpZHRoICogMiArIHggKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW3Bvc10gPSBueDtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1twb3MgKyAxXSA9IG55O1xyXG4gICAgICAgICAgICAgICAgICAgIG54ICs9IGR4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbnkgKz0gZHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c19tZXNoID0gR0wuTWVzaC5sb2FkKHsgdmVydGljZXMyRDogdmVydGljZXMgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c19tZXNoLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHNfbWVzaC5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHNfbWVzaC5fc3BhY2luZyA9IHNwYWNpbmc7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzX21lc2g7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLypcclxuXHRMR3JhcGhUZXh0dXJlQm9rZWguX3BpeGVsX3NoYWRlciA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiBhX2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3NoYXBlO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgZ2xfUG9pbnRDb29yZCApO1xcblxcXHJcblx0XHRcdFx0Y29sb3IgKj0gdl9jb2xvciAqIHVfYWxwaGE7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblx0Ki9cclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC5fZmlyc3RfcGl4ZWxfc2hhZGVyID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVfYmx1cjtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X21hc2s7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0dmVjNCBibHVycmVkX2NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZV9ibHVyLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IG1hc2sgPSB0ZXh0dXJlMkQodV9tYXNrLCB2X2Nvb3JkKS54O1xcblxcXHJcblx0XHRcdCAgIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvciwgYmx1cnJlZF9jb2xvciwgbWFzayk7XFxuXFxcclxuXHRcdFx0fVxcblxcXHJcblx0XHRcdFwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLl9zZWNvbmRfdmVydGV4X3NoYWRlciA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4MkQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfbWFzaztcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9pdGV4c2l6ZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfcG9pbnRTaXplO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV90aHJlc2hvbGQ7XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjMiBjb29yZCA9IGFfdmVydGV4MkQgKiAwLjUgKyAwLjU7XFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIGNvb3JkICk7XFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yICs9IHRleHR1cmUyRCggdV90ZXh0dXJlLCBjb29yZCArIHZlYzIodV9pdGV4c2l6ZS54LCAwLjApICk7XFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yICs9IHRleHR1cmUyRCggdV90ZXh0dXJlLCBjb29yZCArIHZlYzIoMC4wLCB1X2l0ZXhzaXplLnkpKTtcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgKz0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIGNvb3JkICsgdV9pdGV4c2l6ZSk7XFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yICo9IDAuMjU7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBtYXNrID0gdGV4dHVyZTJEKHVfbWFzaywgY29vcmQpLng7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBsdW1pbmFuY2UgPSBsZW5ndGgodl9jb2xvcikgKiBtYXNrO1xcblxcXHJcblx0XHRcdFx0LypsdW1pbmFuY2UgLz0gKHVfcG9pbnRTaXplKnVfcG9pbnRTaXplKSowLjAxICovO1xcblxcXHJcblx0XHRcdFx0bHVtaW5hbmNlIC09IHVfdGhyZXNob2xkO1xcblxcXHJcblx0XHRcdFx0aWYobHVtaW5hbmNlIDwgMC4wKVxcblxcXHJcblx0XHRcdFx0e1xcblxcXHJcblx0XHRcdFx0XHRnbF9Qb3NpdGlvbi54ID0gLTEwMC4wO1xcblxcXHJcblx0XHRcdFx0XHRyZXR1cm47XFxuXFxcclxuXHRcdFx0XHR9XFxuXFxcclxuXHRcdFx0XHRnbF9Qb2ludFNpemUgPSB1X3BvaW50U2l6ZTtcXG5cXFxyXG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleDJELDAuMCwxLjApO1xcblxcXHJcblx0XHRcdH1cXG5cXFxyXG5cdFx0XHRcIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC5fc2Vjb25kX3BpeGVsX3NoYWRlciA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfc2hhcGU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X2FscGhhO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoIHVfc2hhcGUsIGdsX1BvaW50Q29vcmQgKTtcXG5cXFxyXG5cdFx0XHRcdGNvbG9yICo9IHZfY29sb3IgKiB1X2FscGhhO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImZ4L2Jva2VoXCIsIExHcmFwaEZYQm9rZWgpO1xyXG4gICAgICAgIGdsb2JhbC5MR3JhcGhGWEJva2VoID0gTEdyYXBoRlhCb2tlaDtcclxuXHJcbiAgICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTEdyYXBoRlhHZW5lcmljKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2YWx1ZTFcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2YWx1ZTJcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgICAgIGZ4OiBcImhhbGZ0b25lXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTE6IDEsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTI6IDEsXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnRpdGxlID0gXCJGWFwiO1xyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5kZXNjID0gXCJhcHBsaWVzIGFuIEZYIGZyb20gYSBsaXN0XCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy53aWRnZXRzX2luZm8gPSB7XHJcbiAgICAgICAgICAgIGZ4OiB7XHJcbiAgICAgICAgICAgICAgICB3aWRnZXQ6IFwiY29tYm9cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlczogW1wiaGFsZnRvbmVcIiwgXCJwaXhlbGF0ZVwiLCBcImxvd3BhbGV0dGVcIiwgXCJub2lzZVwiLCBcImdhbW1hXCJdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5zaGFkZXJzID0ge307XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IC8vc2F2ZXMgd29ya1xyXG5cclxuICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICB0ZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvL2l0ZXJhdGlvbnNcclxuICAgICAgICAgICAgdmFyIHZhbHVlMSA9IHRoaXMucHJvcGVydGllcy52YWx1ZTE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlMSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlMSA9IHZhbHVlMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlMiA9IHRoaXMucHJvcGVydGllcy52YWx1ZTI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMikpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlMiA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlMiA9IHZhbHVlMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGZ4ID0gdGhpcy5wcm9wZXJ0aWVzLmZ4O1xyXG4gICAgICAgICAgICB2YXIgc2hhZGVyID0gTEdyYXBoRlhHZW5lcmljLnNoYWRlcnNbZnhdO1xyXG4gICAgICAgICAgICBpZiAoIXNoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsX3NoYWRlcl9jb2RlID0gTEdyYXBoRlhHZW5lcmljW1wicGl4ZWxfc2hhZGVyX1wiICsgZnhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwaXhlbF9zaGFkZXJfY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzaGFkZXIgPSBMR3JhcGhGWEdlbmVyaWMuc2hhZGVyc1tmeF0gPSBuZXcgR0wuU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgICAgICAgICBwaXhlbF9zaGFkZXJfY29kZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgICAgIHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XHJcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSBnbG9iYWwuTFMgPyBMUy5SZW5kZXJlci5fY3VycmVudF9jYW1lcmEgOiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgY2FtZXJhX3BsYW5lcztcclxuICAgICAgICAgICAgaWYgKGNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhX3BsYW5lcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBMUy5SZW5kZXJlci5fY3VycmVudF9jYW1lcmEubmVhcixcclxuICAgICAgICAgICAgICAgICAgICBMUy5SZW5kZXJlci5fY3VycmVudF9jYW1lcmEuZmFyXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhX3BsYW5lcyA9IFsxLCAxMDBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZnggPT0gXCJub2lzZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBub2lzZSA9IExHcmFwaFRleHR1cmUuZ2V0Tm9pc2VUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXguYmluZCgwKTtcclxuICAgICAgICAgICAgICAgIGlmIChmeCA9PSBcIm5vaXNlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2lzZS5iaW5kKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNoYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC51bmlmb3Jtcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4dHVyZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9ub2lzZTogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9zaXplOiBbdGV4LndpZHRoLCB0ZXguaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9yYW5kOiBbTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdmFsdWUxOiB2YWx1ZTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdmFsdWUyOiB2YWx1ZTIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfY2FtZXJhX3BsYW5lczogY2FtZXJhX3BsYW5lc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRyYXcobWVzaCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnBpeGVsX3NoYWRlcl9oYWxmdG9uZSA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9jYW1lcmFfcGxhbmVzO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X3NpemU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUyO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdGZsb2F0IHBhdHRlcm4oKSB7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBzID0gc2luKHVfdmFsdWUxICogMy4xNDE1KSwgYyA9IGNvcyh1X3ZhbHVlMSAqIDMuMTQxNSk7XFxuXFxcclxuXHRcdFx0XHR2ZWMyIHRleCA9IHZfY29vcmQgKiB1X3NpemUueHk7XFxuXFxcclxuXHRcdFx0XHR2ZWMyIHBvaW50ID0gdmVjMihcXG5cXFxyXG5cdFx0XHRcdCAgIGMgKiB0ZXgueCAtIHMgKiB0ZXgueSAsXFxuXFxcclxuXHRcdFx0XHQgICBzICogdGV4LnggKyBjICogdGV4LnkgXFxuXFxcclxuXHRcdFx0XHQpICogdV92YWx1ZTI7XFxuXFxcclxuXHRcdFx0XHRyZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7XFxuXFxcclxuXHRcdFx0fVxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhhdmVyYWdlICogMTAuMCAtIDUuMCArIHBhdHRlcm4oKSksIGNvbG9yLmEpO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnBpeGVsX3NoYWRlcl9waXhlbGF0ZSA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9jYW1lcmFfcGxhbmVzO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X3NpemU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUyO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzIgY29vcmQgPSB2ZWMyKCBmbG9vcih2X2Nvb3JkLnggKiB1X3ZhbHVlMSkgLyB1X3ZhbHVlMSwgZmxvb3Iodl9jb29yZC55ICogdV92YWx1ZTIpIC8gdV92YWx1ZTIgKTtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCBjb29yZCk7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5waXhlbF9zaGFkZXJfbG93cGFsZXR0ZSA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9jYW1lcmFfcGxhbmVzO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X3NpemU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUyO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGZsb29yKGNvbG9yICogdV92YWx1ZTEpIC8gdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMucGl4ZWxfc2hhZGVyX25vaXNlID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfbm9pc2U7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfc2l6ZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTI7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfcmFuZDtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHR2ZWMzIG5vaXNlID0gdGV4dHVyZTJEKHVfbm9pc2UsIHZfY29vcmQgKiB2ZWMyKHVfc2l6ZS54IC8gNTEyLjAsIHVfc2l6ZS55IC8gNTEyLjApICsgdV9yYW5kKS54eXogLSB2ZWMzKDAuNSk7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvci54eXogKyBub2lzZSAqIHVfdmFsdWUxLCBjb2xvci5hICk7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMucGl4ZWxfc2hhZGVyX2dhbW1hID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgZ2FtbWEgPSAxLjAgLyB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBvdyggY29sb3IueHl6LCB2ZWMzKGdhbW1hKSApLCBjb2xvci5hICk7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImZ4L2dlbmVyaWNcIiwgTEdyYXBoRlhHZW5lcmljKTtcclxuICAgICAgICBnbG9iYWwuTEdyYXBoRlhHZW5lcmljID0gTEdyYXBoRlhHZW5lcmljO1xyXG5cclxuICAgICAgICAvLyBWaWduZXRpbmcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIExHcmFwaEZYVmlnbmV0aW5nKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiVGV4LlwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbnRlbnNpdHlcIiwgXCJudW1iZXJcIik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlbnNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBpbnZlcnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICghTEdyYXBoRlhWaWduZXRpbmcuX3NoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxyXG4gICAgICAgICAgICAgICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLnBpeGVsX3NoYWRlclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcudGl0bGUgPSBcIlZpZ25ldGluZ1wiO1xyXG4gICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLmRlc2MgPSBcIlZpZ25ldGluZ1wiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy53aWRnZXRzX2luZm8gPSB7XHJcbiAgICAgICAgICAgIHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcclxuICAgICAgICAgICAgICAgIHRleCxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleCxcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRlbnNpdHkgPSB0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlbnNpdHkgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcclxuICAgICAgICAgICAgdmFyIHNoYWRlciA9IExHcmFwaEZYVmlnbmV0aW5nLl9zaGFkZXI7XHJcbiAgICAgICAgICAgIHZhciBpbnZlcnQgPSB0aGlzLnByb3BlcnRpZXMuaW52ZXJ0O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRleC5iaW5kKDApO1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnVuaWZvcm1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXh0dXJlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2ludGVuc2l0eTogaW50ZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2lzaXplOiBbMSAvIHRleC53aWR0aCwgMSAvIHRleC5oZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2ludmVydDogaW52ZXJ0ID8gMSA6IDBcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5kcmF3KG1lc2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLnBpeGVsX3NoYWRlciA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGludCB1X2ludmVydDtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBsdW1pbmFuY2UgPSAxLjAgLSBsZW5ndGgoIHZfY29vcmQgLSB2ZWMyKDAuNSkgKSAqIDEuNDE0O1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0aWYodV9pbnZlcnQgPT0gMSlcXG5cXFxyXG5cdFx0XHRcdFx0bHVtaW5hbmNlID0gMS4wIC0gbHVtaW5hbmNlO1xcblxcXHJcblx0XHRcdFx0bHVtaW5hbmNlID0gbWl4KDEuMCwgbHVtaW5hbmNlLCB1X2ludGVuc2l0eSk7XFxuXFxcclxuXHRcdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggbHVtaW5hbmNlICogY29sb3IueHl6LCBjb2xvci5hKTtcXG5cXFxyXG5cdFx0XHR9XFxuXFxcclxuXHRcdFx0XCI7XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZngvdmlnbmV0aW5nXCIsIExHcmFwaEZYVmlnbmV0aW5nKTtcclxuICAgICAgICBnbG9iYWwuTEdyYXBoRlhWaWduZXRpbmcgPSBMR3JhcGhGWFZpZ25ldGluZztcclxuICAgIH1cclxufSkodGhpcyk7XHJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcbiAgICB2YXIgTUlESV9DT0xPUiA9IFwiIzI0M1wiO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1JRElFdmVudChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsID0gMDtcclxuICAgICAgICB0aGlzLmNtZCA9IDA7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KDMpO1xyXG5cclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldHVwKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBMaXRlR3JhcGguTUlESUV2ZW50ID0gTUlESUV2ZW50O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbihvKSB7XHJcbiAgICAgICAgdGhpcy5zZXR1cChvLmRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHZhciByYXdfZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgaWYgKGRhdGEuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICByYXdfZGF0YSA9IGRhdGEuZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5zZXQocmF3X2RhdGEpO1xyXG5cclxuICAgICAgICB2YXIgbWlkaVN0YXR1cyA9IHJhd19kYXRhWzBdO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gbWlkaVN0YXR1cztcclxuXHJcbiAgICAgICAgdmFyIG1pZGlDb21tYW5kID0gbWlkaVN0YXR1cyAmIDB4ZjA7XHJcblxyXG4gICAgICAgIGlmIChtaWRpU3RhdHVzID49IDB4ZjApIHtcclxuICAgICAgICAgICAgdGhpcy5jbWQgPSBtaWRpU3RhdHVzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY21kID0gbWlkaUNvbW1hbmQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTiAmJiB0aGlzLnZlbG9jaXR5ID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jbWQgPSBNSURJRXZlbnQuTk9URU9GRjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY21kX3N0ciA9IE1JRElFdmVudC5jb21tYW5kc1t0aGlzLmNtZF0gfHwgXCJcIjtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBtaWRpQ29tbWFuZCA+PSBNSURJRXZlbnQuTk9URU9OIHx8XHJcbiAgICAgICAgICAgIG1pZGlDb21tYW5kIDw9IE1JRElFdmVudC5OT1RFT0ZGXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbCA9IG1pZGlTdGF0dXMgJiAweDBmO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1JRElFdmVudC5wcm90b3R5cGUsIFwidmVsb2NpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNtZCA9PSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMl0gPSB2OyAvLyAgdiAvIDEyNztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIE1JRElFdmVudC5ub3RlcyA9IFtcclxuICAgICAgICBcIkFcIixcclxuICAgICAgICBcIkEjXCIsXHJcbiAgICAgICAgXCJCXCIsXHJcbiAgICAgICAgXCJDXCIsXHJcbiAgICAgICAgXCJDI1wiLFxyXG4gICAgICAgIFwiRFwiLFxyXG4gICAgICAgIFwiRCNcIixcclxuICAgICAgICBcIkVcIixcclxuICAgICAgICBcIkZcIixcclxuICAgICAgICBcIkYjXCIsXHJcbiAgICAgICAgXCJHXCIsXHJcbiAgICAgICAgXCJHI1wiXHJcbiAgICBdO1xyXG4gICAgTUlESUV2ZW50Lm5vdGVfdG9faW5kZXggPSB7XHJcbiAgICAgICAgQTogMCxcclxuICAgICAgICBcIkEjXCI6IDEsXHJcbiAgICAgICAgQjogMixcclxuICAgICAgICBDOiAzLFxyXG4gICAgICAgIFwiQyNcIjogNCxcclxuICAgICAgICBEOiA1LFxyXG4gICAgICAgIFwiRCNcIjogNixcclxuICAgICAgICBFOiA3LFxyXG4gICAgICAgIEY6IDgsXHJcbiAgICAgICAgXCJGI1wiOiA5LFxyXG4gICAgICAgIEc6IDEwLFxyXG4gICAgICAgIFwiRyNcIjogMTFcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1JRElFdmVudC5wcm90b3R5cGUsIFwibm90ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY21kICE9IE1JRElFdmVudC5OT1RFT04pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LnRvTm90ZVN0cmluZyh0aGlzLmRhdGFbMV0sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibm90ZXMgY2Fubm90IGJlIGFzc2lnbmVkIHRoaXMgd2F5LCBtdXN0IG1vZGlmeSB0aGUgZGF0YVsxXVwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1JRElFdmVudC5wcm90b3R5cGUsIFwib2N0YXZlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbWQgIT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvY3RhdmUgPSB0aGlzLmRhdGFbMV0gLSAyNDtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iob2N0YXZlIC8gMTIgKyAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICB0aHJvdyBcIm9jdGF2ZSBjYW5ub3QgYmUgYXNzaWduZWQgdGhpcyB3YXksIG11c3QgbW9kaWZ5IHRoZSBkYXRhWzFdXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvL3JldHVybnMgSFpzXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLmdldFBpdGNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsICh0aGlzLmRhdGFbMV0gLSA2OSkgLyAxMikgKiA0NDA7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21wdXRlUGl0Y2ggPSBmdW5jdGlvbihub3RlKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIChub3RlIC0gNjkpIC8gMTIpICogNDQwO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLmdldENDID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsxXTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5nZXRDQ1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsyXTtcclxuICAgIH07XHJcblxyXG4gICAgLy9ub3QgdGVzdGVkLCB0aGVyZSBpcyBhIGZvcm11bGEgbWlzc2luZyBoZXJlXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLmdldFBpdGNoQmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMV0gKyAodGhpcy5kYXRhWzJdIDw8IDcpIC0gODE5MjtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbXB1dGVQaXRjaEJlbmQgPSBmdW5jdGlvbih2MSwgdjIpIHtcclxuICAgICAgICByZXR1cm4gdjEgKyAodjIgPDwgNykgLSA4MTkyO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLnNldENvbW1hbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgdGhpcy5jbWQgPSBNSURJRXZlbnQuY29tcHV0ZUNvbW1hbmRGcm9tU3RyaW5nKHN0cik7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21wdXRlQ29tbWFuZEZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICBpZiAoIXN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOT1RFIE9OXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJOT1RFT05cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuTk9URU9OO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOT1RFIE9GRlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiTk9URU9GRlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5OT1RFT047XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIktFWSBQUkVTU1VSRVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiS0VZUFJFU1NVUkVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuS0VZUFJFU1NVUkU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIkNPTlRST0xMRVIgQ0hBTkdFXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJDT05UUk9MTEVSQ0hBTkdFXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJDQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5DT05UUk9MTEVSQ0hBTkdFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQUk9HUkFNIENIQU5HRVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUFJPR1JBTUNIQU5HRVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUENcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuUFJPR1JBTUNIQU5HRTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiQ0hBTk5FTCBQUkVTU1VSRVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiQ0hBTk5FTFBSRVNTVVJFXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LkNIQU5ORUxQUkVTU1VSRTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiUElUQ0ggQkVORFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUElUQ0hCRU5EXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LlBJVENIQkVORDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiVElNRSBUSUNLXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJUSU1FVElDS1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5USU1FVElDSztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihzdHIpOyAvL2FzdW1lIGl0cyBhIGhleCBjb2RlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL3RyYW5zZm9ybSBmcm9tIGEgcGl0Y2ggbnVtYmVyIHRvIHN0cmluZyBsaWtlIFwiQzRcIlxyXG4gICAgTUlESUV2ZW50LnRvTm90ZVN0cmluZyA9IGZ1bmN0aW9uKGQsIHNraXBfb2N0YXZlKSB7XHJcbiAgICAgICAgZCA9IE1hdGgucm91bmQoZCk7IC8vaW4gY2FzZSBpdCBoYXMgZGVjaW1hbHNcclxuICAgICAgICB2YXIgbm90ZSA9IGQgLSAyMTtcclxuICAgICAgICB2YXIgb2N0YXZlID0gTWF0aC5mbG9vcigoZCAtIDI0KSAvIDEyICsgMSk7XHJcbiAgICAgICAgbm90ZSA9IG5vdGUgJSAxMjtcclxuICAgICAgICBpZiAobm90ZSA8IDApIHtcclxuICAgICAgICAgICAgbm90ZSA9IDEyICsgbm90ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1JRElFdmVudC5ub3Rlc1tub3RlXSArIChza2lwX29jdGF2ZSA/IFwiXCIgOiBvY3RhdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQuTm90ZVN0cmluZ1RvUGl0Y2ggPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB2YXIgbm90ZSA9IHN0clswXTtcclxuICAgICAgICB2YXIgb2N0YXZlID0gNDtcclxuXHJcbiAgICAgICAgaWYgKHN0clsxXSA9PSBcIiNcIikge1xyXG4gICAgICAgICAgICBub3RlICs9IFwiI1wiO1xyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIG9jdGF2ZSA9IE51bWJlcihzdHJbMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBvY3RhdmUgPSBOdW1iZXIoc3RyWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGl0Y2ggPSBNSURJRXZlbnQubm90ZV90b19pbmRleFtub3RlXTtcclxuICAgICAgICBpZiAocGl0Y2ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChvY3RhdmUgLSAxKSAqIDEyICsgcGl0Y2ggKyAyMTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzdHIgPSBcIlwiICsgdGhpcy5jaGFubmVsICsgXCIuIFwiO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5jbWQpIHtcclxuICAgICAgICAgICAgY2FzZSBNSURJRXZlbnQuTk9URU9OOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiTk9URU9OIFwiICsgTUlESUV2ZW50LnRvTm90ZVN0cmluZyh0aGlzLmRhdGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50Lk5PVEVPRkY6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJOT1RFT0ZGIFwiICsgTUlESUV2ZW50LnRvTm90ZVN0cmluZyh0aGlzLmRhdGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LkNPTlRST0xMRVJDSEFOR0U6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJDQyBcIiArIHRoaXMuZGF0YVsxXSArIFwiIFwiICsgdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LlBST0dSQU1DSEFOR0U6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJQQyBcIiArIHRoaXMuZGF0YVsxXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5QSVRDSEJFTkQ6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJQSVRDSEJFTkQgXCIgKyB0aGlzLmdldFBpdGNoQmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LktFWVBSRVNTVVJFOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiS0VZUFJFU1MgXCIgKyB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5kYXRhW2ldLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV0sXHJcbiAgICAgICAgICAgIG9iamVjdF9jbGFzczogXCJNSURJRXZlbnRcIlxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5OT1RFT0ZGID0gMHg4MDtcclxuICAgIE1JRElFdmVudC5OT1RFT04gPSAweDkwO1xyXG4gICAgTUlESUV2ZW50LktFWVBSRVNTVVJFID0gMHhhMDtcclxuICAgIE1JRElFdmVudC5DT05UUk9MTEVSQ0hBTkdFID0gMHhiMDtcclxuICAgIE1JRElFdmVudC5QUk9HUkFNQ0hBTkdFID0gMHhjMDtcclxuICAgIE1JRElFdmVudC5DSEFOTkVMUFJFU1NVUkUgPSAweGQwO1xyXG4gICAgTUlESUV2ZW50LlBJVENIQkVORCA9IDB4ZTA7XHJcbiAgICBNSURJRXZlbnQuVElNRVRJQ0sgPSAweGY4O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21tYW5kcyA9IHtcclxuICAgICAgICAweDgwOiBcIm5vdGUgb2ZmXCIsXHJcbiAgICAgICAgMHg5MDogXCJub3RlIG9uXCIsXHJcbiAgICAgICAgMHhhMDogXCJrZXkgcHJlc3N1cmVcIixcclxuICAgICAgICAweGIwOiBcImNvbnRyb2xsZXIgY2hhbmdlXCIsXHJcbiAgICAgICAgMHhjMDogXCJwcm9ncmFtIGNoYW5nZVwiLFxyXG4gICAgICAgIDB4ZDA6IFwiY2hhbm5lbCBwcmVzc3VyZVwiLFxyXG4gICAgICAgIDB4ZTA6IFwicGl0Y2ggYmVuZFwiLFxyXG4gICAgICAgIDB4ZjA6IFwic3lzdGVtXCIsXHJcbiAgICAgICAgMHhmMjogXCJTb25nIHBvc1wiLFxyXG4gICAgICAgIDB4ZjM6IFwiU29uZyBzZWxlY3RcIixcclxuICAgICAgICAweGY2OiBcIlR1bmUgcmVxdWVzdFwiLFxyXG4gICAgICAgIDB4Zjg6IFwidGltZSB0aWNrXCIsXHJcbiAgICAgICAgMHhmYTogXCJTdGFydCBTb25nXCIsXHJcbiAgICAgICAgMHhmYjogXCJDb250aW51ZSBTb25nXCIsXHJcbiAgICAgICAgMHhmYzogXCJTdG9wIFNvbmdcIixcclxuICAgICAgICAweGZlOiBcIlNlbnNpbmdcIixcclxuICAgICAgICAweGZmOiBcIlJlc2V0XCJcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbW1hbmRzX3Nob3J0ID0ge1xyXG4gICAgICAgIDB4ODA6IFwiTk9URU9GRlwiLFxyXG4gICAgICAgIDB4OTA6IFwiTk9URU9GRlwiLFxyXG4gICAgICAgIDB4YTA6IFwiS0VZUFwiLFxyXG4gICAgICAgIDB4YjA6IFwiQ0NcIixcclxuICAgICAgICAweGMwOiBcIlBDXCIsXHJcbiAgICAgICAgMHhkMDogXCJDUFwiLFxyXG4gICAgICAgIDB4ZTA6IFwiUEJcIixcclxuICAgICAgICAweGYwOiBcIlNZU1wiLFxyXG4gICAgICAgIDB4ZjI6IFwiUE9TXCIsXHJcbiAgICAgICAgMHhmMzogXCJTRUxFQ1RcIixcclxuICAgICAgICAweGY2OiBcIlRVTkVSRVFcIixcclxuICAgICAgICAweGY4OiBcIlRUXCIsXHJcbiAgICAgICAgMHhmYTogXCJTVEFSVFwiLFxyXG4gICAgICAgIDB4ZmI6IFwiQ09OVElOVUVcIixcclxuICAgICAgICAweGZjOiBcIlNUT1BcIixcclxuICAgICAgICAweGZlOiBcIlNFTlNcIixcclxuICAgICAgICAweGZmOiBcIlJFU0VUXCJcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbW1hbmRzX3JldmVyc2VkID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIE1JRElFdmVudC5jb21tYW5kcykge1xyXG4gICAgICAgIE1JRElFdmVudC5jb21tYW5kc19yZXZlcnNlZFtNSURJRXZlbnQuY29tbWFuZHNbaV1dID0gaTtcclxuICAgIH1cclxuXHJcbiAgICAvL01JREkgd3JhcHBlciwgaW5zdGFudGlhdGUgYnkgTUlESUluIGFuZCBNSURJT3V0XHJcbiAgICBmdW5jdGlvbiBNSURJSW50ZXJmYWNlKG9uX3JlYWR5LCBvbl9lcnJvcikge1xyXG4gICAgICAgIGlmICghbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIm5vdCBzdXBwb29ydGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChvbl9lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb25fZXJyb3IoXCJOb3Qgc3VwcG9ydGVkXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1JREkgTk9UIFNVUFBPUlRFRCwgZW5hYmxlIGJ5IGNocm9tZTovL2ZsYWdzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub25fcmVhZHkgPSBvbl9yZWFkeTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgbm90ZTogW10sXHJcbiAgICAgICAgICAgIGNjOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG5cdFx0dGhpcy5pbnB1dF9wb3J0cyA9IG51bGw7XHJcblx0XHR0aGlzLmlucHV0X3BvcnRzX2luZm8gPSBbXTtcclxuXHRcdHRoaXMub3V0cHV0X3BvcnRzID0gbnVsbDtcclxuXHRcdHRoaXMub3V0cHV0X3BvcnRzX2luZm8gPSBbXTtcclxuXHJcbiAgICAgICAgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCkudGhlbih0aGlzLm9uTUlESVN1Y2Nlc3MuYmluZCh0aGlzKSwgdGhpcy5vbk1JRElGYWlsdXJlLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIE1JRElJbnRlcmZhY2UuaW5wdXQgPSBudWxsO1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UuTUlESUV2ZW50ID0gTUlESUV2ZW50O1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UucHJvdG90eXBlLm9uTUlESVN1Y2Nlc3MgPSBmdW5jdGlvbihtaWRpQWNjZXNzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNSURJIHJlYWR5IVwiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhtaWRpQWNjZXNzKTtcclxuICAgICAgICB0aGlzLm1pZGkgPSBtaWRpQWNjZXNzOyAvLyBzdG9yZSBpbiB0aGUgZ2xvYmFsIChpbiByZWFsIHVzYWdlLCB3b3VsZCBwcm9iYWJseSBrZWVwIGluIGFuIG9iamVjdCBpbnN0YW5jZSlcclxuICAgICAgICB0aGlzLnVwZGF0ZVBvcnRzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uX3JlYWR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25fcmVhZHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS51cGRhdGVQb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtaWRpID0gdGhpcy5taWRpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRfcG9ydHMgPSBtaWRpLmlucHV0cztcclxuXHRcdHRoaXMuaW5wdXRfcG9ydHNfaW5mbyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0cHV0X3BvcnRzID0gbWlkaS5vdXRwdXRzO1xyXG5cdFx0dGhpcy5vdXRwdXRfcG9ydHNfaW5mbyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgbnVtID0gMDtcclxuXHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5pbnB1dF9wb3J0cy52YWx1ZXMoKTtcclxuICAgICAgICB2YXIgaXRfdmFsdWUgPSBpdC5uZXh0KCk7XHJcbiAgICAgICAgd2hpbGUgKGl0X3ZhbHVlICYmIGl0X3ZhbHVlLmRvbmUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3J0X2luZm8gPSBpdF92YWx1ZS52YWx1ZTtcclxuXHRcdFx0dGhpcy5pbnB1dF9wb3J0c19pbmZvLnB1c2gocG9ydF9pbmZvKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coIFwiSW5wdXQgcG9ydCBbdHlwZTonXCIgKyBwb3J0X2luZm8udHlwZSArIFwiJ10gaWQ6J1wiICsgcG9ydF9pbmZvLmlkICsgXCInIG1hbnVmYWN0dXJlcjonXCIgKyBwb3J0X2luZm8ubWFudWZhY3R1cmVyICsgXCInIG5hbWU6J1wiICsgcG9ydF9pbmZvLm5hbWUgKyBcIicgdmVyc2lvbjonXCIgKyBwb3J0X2luZm8udmVyc2lvbiArIFwiJ1wiICk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgICAgICBpdF92YWx1ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5udW1faW5wdXRfcG9ydHMgPSBudW07XHJcblxyXG4gICAgICAgIG51bSA9IDA7XHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5vdXRwdXRfcG9ydHMudmFsdWVzKCk7XHJcbiAgICAgICAgdmFyIGl0X3ZhbHVlID0gaXQubmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChpdF92YWx1ZSAmJiBpdF92YWx1ZS5kb25lID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB2YXIgcG9ydF9pbmZvID0gaXRfdmFsdWUudmFsdWU7XHJcblx0XHRcdHRoaXMub3V0cHV0X3BvcnRzX2luZm8ucHVzaChwb3J0X2luZm8pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggXCJPdXRwdXQgcG9ydCBbdHlwZTonXCIgKyBwb3J0X2luZm8udHlwZSArIFwiJ10gaWQ6J1wiICsgcG9ydF9pbmZvLmlkICsgXCInIG1hbnVmYWN0dXJlcjonXCIgKyBwb3J0X2luZm8ubWFudWZhY3R1cmVyICsgXCInIG5hbWU6J1wiICsgcG9ydF9pbmZvLm5hbWUgKyBcIicgdmVyc2lvbjonXCIgKyBwb3J0X2luZm8udmVyc2lvbiArIFwiJ1wiICk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgICAgICBpdF92YWx1ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5udW1fb3V0cHV0X3BvcnRzID0gbnVtO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS5vbk1JRElGYWlsdXJlID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgTUlESSBhY2Nlc3MgLSBcIiArIG1zZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UucHJvdG90eXBlLm9wZW5JbnB1dFBvcnQgPSBmdW5jdGlvbihwb3J0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBpbnB1dF9wb3J0ID0gdGhpcy5pbnB1dF9wb3J0cy5nZXQoXCJpbnB1dC1cIiArIHBvcnQpO1xyXG4gICAgICAgIGlmICghaW5wdXRfcG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1JRElJbnRlcmZhY2UuaW5wdXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgaW5wdXRfcG9ydC5vbm1pZGltZXNzYWdlID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoYS5kYXRhKTtcclxuICAgICAgICAgICAgdGhhdC51cGRhdGVTdGF0ZShtaWRpX2V2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhLmRhdGEsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNSURJSW50ZXJmYWNlLm9uX21lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIE1JRElJbnRlcmZhY2Uub25fbWVzc2FnZShhLmRhdGEsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInBvcnQgb3BlbjogXCIsIGlucHV0X3BvcnQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnBhcnNlTXNnID0gZnVuY3Rpb24oZGF0YSkge307XHJcblxyXG4gICAgTUlESUludGVyZmFjZS5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbihtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChtaWRpX2V2ZW50LmNtZCkge1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5OT1RFT046XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm5vdGVbbWlkaV9ldmVudC52YWx1ZTEgfCAwXSA9IG1pZGlfZXZlbnQudmFsdWUyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50Lk5PVEVPRkY6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm5vdGVbbWlkaV9ldmVudC52YWx1ZTEgfCAwXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNSURJRXZlbnQuQ09OVFJPTExFUkNIQU5HRTpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2NbbWlkaV9ldmVudC5nZXRDQygpXSA9IG1pZGlfZXZlbnQuZ2V0Q0NWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS5zZW5kTUlESSA9IGZ1bmN0aW9uKHBvcnQsIG1pZGlfZGF0YSkge1xyXG4gICAgICAgIGlmICghbWlkaV9kYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXRfcG9ydCA9IHRoaXMub3V0cHV0X3BvcnRzX2luZm9bcG9ydF07Ly90aGlzLm91dHB1dF9wb3J0cy5nZXQoXCJvdXRwdXQtXCIgKyBwb3J0KTtcclxuICAgICAgICBpZiAoIW91dHB1dF9wb3J0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1JRElJbnRlcmZhY2Uub3V0cHV0ID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKG1pZGlfZGF0YS5jb25zdHJ1Y3RvciA9PT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIG91dHB1dF9wb3J0LnNlbmQobWlkaV9kYXRhLmRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dHB1dF9wb3J0LnNlbmQobWlkaV9kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESUluKCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibWlkaVwiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHBvcnQ6IDAgfTtcclxuICAgICAgICB0aGlzLl9sYXN0X21pZGlfZXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRfbWlkaV9ldmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FBQVwiO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfdGltZSA9IDA7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBuZXcgTUlESUludGVyZmFjZShmdW5jdGlvbihtaWRpKSB7XHJcbiAgICAgICAgICAgIC8vb3BlblxyXG4gICAgICAgICAgICB0aGF0Ll9taWRpID0gbWlkaTtcclxuICAgICAgICAgICAgaWYgKHRoYXQuX3dhaXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQub25TdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQuX3dhaXRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElJbi5NSURJSW50ZXJmYWNlID0gTUlESUludGVyZmFjZTtcclxuXHJcbiAgICBMR01JRElJbi50aXRsZSA9IFwiTUlESSBJbnB1dFwiO1xyXG4gICAgTEdNSURJSW4uZGVzYyA9IFwiUmVhZHMgTUlESSBmcm9tIGEgaW5wdXQgcG9ydFwiO1xyXG4gICAgTEdNSURJSW4uY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUluZm8gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taWRpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09IFwicG9ydFwiKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9taWRpLmlucHV0X3BvcnRzX2luZm8ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX21pZGkuaW5wdXRfcG9ydHNfaW5mb1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IGkgKyBcIi4tIFwiICsgaW5wdXQubmFtZSArIFwiIHZlcnNpb246XCIgKyBpbnB1dC52ZXJzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW51bVwiLCB2YWx1ZXM6IHZhbHVlcyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJSW4ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWlkaSkge1xyXG4gICAgICAgICAgICB0aGlzLl9taWRpLm9wZW5JbnB1dFBvcnQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucG9ydCxcclxuICAgICAgICAgICAgICAgIHRoaXMub25NSURJRXZlbnQuYmluZCh0aGlzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJSW4ucHJvdG90eXBlLm9uTUlESUV2ZW50ID0gZnVuY3Rpb24oZGF0YSwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RfbWlkaV9ldmVudCA9IG1pZGlfZXZlbnQ7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FGQVwiO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfdGltZSA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fbWlkaVwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9ub3Rlb25cIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuTk9URU9GRikge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9ub3Rlb2ZmXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50LkNPTlRST0xMRVJDSEFOR0UpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fY2NcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuUFJPR1JBTUNIQU5HRSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9wY1wiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1pZGlfZXZlbnQuY21kID09IE1JRElFdmVudC5QSVRDSEJFTkQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fcGl0Y2hiZW5kXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJSW4ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUFBXCI7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZsYWdzLmNvbGxhcHNlZCAmJiB0aGlzLl9sYXN0X21pZGlfZXZlbnQpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgdmFyIG5vdyA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBmID0gMS4wIC0gTWF0aC5tYXgoMCwgKG5vdyAtIHRoaXMuX2xhc3RfdGltZSkgKiAwLjAwMSk7XHJcbiAgICAgICAgICAgIGlmIChmID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBjdHguZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gZjtcclxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gXCIxMnB4IFRhaG9tYVwiO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RfbWlkaV9ldmVudC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplWzFdICogMC41ICsgM1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8vY3R4LmZpbGxSZWN0KDAsMCx0aGlzLnNpemVbMF0sdGhpcy5zaXplWzFdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5fbGFzdF9taWRpX2V2ZW50O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlkaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fbWlkaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxhc3RfbWlkaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJsYXN0X21pZGlcIiwgXCJtaWRpXCJdLFxyXG4gICAgICAgICAgICBbXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX25vdGVvblwiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJvbl9ub3Rlb2ZmXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX2NjXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX3BjXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX3BpdGNoYmVuZFwiLCBMaXRlR3JhcGguRVZFTlRdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2lucHV0XCIsIExHTUlESUluKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElPdXQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNlbmRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHBvcnQ6IDAgfTtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG5ldyBNSURJSW50ZXJmYWNlKGZ1bmN0aW9uKG1pZGkpIHtcclxuICAgICAgICAgICAgdGhhdC5fbWlkaSA9IG1pZGk7XHJcblx0XHRcdHRoYXQud2lkZ2V0Lm9wdGlvbnMudmFsdWVzID0gdGhhdC5nZXRNSURJT3V0cHV0cygpO1xyXG4gICAgICAgIH0pO1xyXG5cdFx0dGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJEZXZpY2VcIix0aGlzLnByb3BlcnRpZXMucG9ydCx7IHByb3BlcnR5OiBcInBvcnRcIiwgdmFsdWVzOiB0aGlzLmdldE1JRElPdXRwdXRzLmJpbmQodGhpcykgfSk7XHJcblx0XHR0aGlzLnNpemUgPSBbMzQwLDYwXTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElPdXQuTUlESUludGVyZmFjZSA9IE1JRElJbnRlcmZhY2U7XHJcblxyXG4gICAgTEdNSURJT3V0LnRpdGxlID0gXCJNSURJIE91dHB1dFwiO1xyXG4gICAgTEdNSURJT3V0LmRlc2MgPSBcIlNlbmRzIE1JREkgdG8gb3V0cHV0IGNoYW5uZWxcIjtcclxuICAgIExHTUlESU91dC5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJT3V0LnByb3RvdHlwZS5vbkdldFByb3BlcnR5SW5mbyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21pZGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwb3J0XCIpIHtcclxuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0TUlESU91dHB1dHMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnVtXCIsIHZhbHVlczogdmFsdWVzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHRMR01JRElPdXQuZGVmYXVsdF9wb3J0cyA9IHswOlwidW5rbm93blwifTtcclxuXHJcblx0TEdNSURJT3V0LnByb3RvdHlwZS5nZXRNSURJT3V0cHV0cyA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgdmFsdWVzID0ge307XHJcblx0XHRpZighdGhpcy5fbWlkaSlcclxuXHRcdFx0cmV0dXJuIExHTUlESU91dC5kZWZhdWx0X3BvcnRzO1xyXG5cdFx0aWYodGhpcy5fbWlkaS5vdXRwdXRfcG9ydHNfaW5mbylcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWlkaS5vdXRwdXRfcG9ydHNfaW5mby5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gdGhpcy5fbWlkaS5vdXRwdXRfcG9ydHNfaW5mb1tpXTtcclxuXHRcdFx0aWYoIW91dHB1dClcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIG5hbWUgPSBpICsgXCIuLSBcIiArIG91dHB1dC5uYW1lICsgXCIgdmVyc2lvbjpcIiArIG91dHB1dC52ZXJzaW9uO1xyXG5cdFx0XHR2YWx1ZXNbaV0gPSBuYW1lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG4gICAgTEdNSURJT3V0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhtaWRpX2V2ZW50KTtcclxuICAgICAgICBpZiAoIXRoaXMuX21pZGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJzZW5kXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWlkaS5zZW5kTUlESSh0aGlzLnByb3BlcnRpZXMucG9ydCwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm1pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESU91dC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcInNlbmRcIiwgTGl0ZUdyYXBoLkFDVElPTl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElPdXQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlRdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL291dHB1dFwiLCBMR01JRElPdXQpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElTaG93KCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5fc3RyID0gXCJcIjtcclxuICAgICAgICB0aGlzLnNpemUgPSBbMjAwLCA0MF07XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJU2hvdy50aXRsZSA9IFwiTUlESSBTaG93XCI7XHJcbiAgICBMR01JRElTaG93LmRlc2MgPSBcIlNob3dzIE1JREkgaW4gdGhlIGdyYXBoXCI7XHJcbiAgICBMR01JRElTaG93LmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElTaG93LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaWRpX2V2ZW50LmNvbnN0cnVjdG9yID09PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RyID0gbWlkaV9ldmVudC50b1N0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ciA9IFwiPz8/XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElTaG93LnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdHIgfHwgdGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjMwcHggQXJpYWxcIjtcclxuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5fc3RyLCAxMCwgdGhpcy5zaXplWzFdICogMC44KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImluXCIsIExpdGVHcmFwaC5BQ1RJT05dXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvc2hvd1wiLCBMR01JRElTaG93KTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElGaWx0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBjaGFubmVsOiAtMSxcclxuICAgICAgICAgICAgY21kOiAtMSxcclxuICAgICAgICAgICAgbWluX3ZhbHVlOiAtMSxcclxuICAgICAgICAgICAgbWF4X3ZhbHVlOiAtMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLl9sZWFybmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsIFwiTGVhcm5cIiwgXCJcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX2xlYXJuaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0ZBM1wiO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUFBXCI7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJRmlsdGVyLnRpdGxlID0gXCJNSURJIEZpbHRlclwiO1xyXG4gICAgTEdNSURJRmlsdGVyLmRlc2MgPSBcIkZpbHRlcnMgTUlESSBtZXNzYWdlc1wiO1xyXG4gICAgTEdNSURJRmlsdGVyLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElGaWx0ZXJbXCJAY21kXCJdID0ge1xyXG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxyXG4gICAgICAgIHRpdGxlOiBcIkNvbW1hbmRcIixcclxuICAgICAgICB2YWx1ZXM6IE1JRElFdmVudC5jb21tYW5kc19yZXZlcnNlZFxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElGaWx0ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jbWQgPT0gLTEpIHtcclxuICAgICAgICAgICAgc3RyID0gXCJOb3RoaW5nXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RyID0gTUlESUV2ZW50LmNvbW1hbmRzX3Nob3J0W3RoaXMucHJvcGVydGllcy5jbWRdIHx8IFwiVW5rbm93blwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICE9IC0xICYmXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgIT0gLTFcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc3RyICs9XHJcbiAgICAgICAgICAgICAgICBcIiBcIiArXHJcbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSA9PSB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICtcclxuICAgICAgICAgICAgICAgICAgICAgIFwiLi5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBcIkZpbHRlcjogXCIgKyBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUZpbHRlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiY21kXCIpIHtcclxuICAgICAgICAgICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XHJcbiAgICAgICAgICAgICAgICBudW0gPSBNSURJRXZlbnQuY29tbWFuZHNbdmFsdWVdIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCA9IG51bTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUZpbHRlci5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCB8fCBtaWRpX2V2ZW50LmNvbnN0cnVjdG9yICE9PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xlYXJuaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlYXJuaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBQUFcIjtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWwgPSBtaWRpX2V2ZW50LmNoYW5uZWw7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jbWQgPSBtaWRpX2V2ZW50LmNtZDtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSA9IHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsICE9IC0xICYmXHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50LmNoYW5uZWwgIT0gdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCAhPSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5jbWQgIT0gdGhpcy5wcm9wZXJ0aWVzLmNtZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICE9IC0xICYmXHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMV0gPCB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgIT0gLTEgJiZcclxuICAgICAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVsxXSA+IHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWVcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX21pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9maWx0ZXJcIiwgTEdNSURJRmlsdGVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGNoYW5uZWw6IDAsXHJcbiAgICAgICAgICAgIGNtZDogMTQ0LCAvLzB4OTBcclxuICAgICAgICAgICAgdmFsdWUxOiAxLFxyXG4gICAgICAgICAgICB2YWx1ZTI6IDFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VuZFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhc3NpZ25cIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHJcbiAgICAgICAgdGhpcy5taWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuZ2F0ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESUV2ZW50LnRpdGxlID0gXCJNSURJRXZlbnRcIjtcclxuICAgIExHTUlESUV2ZW50LmRlc2MgPSBcIkNyZWF0ZSBhIE1JREkgRXZlbnRcIjtcclxuICAgIExHTUlESUV2ZW50LmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCA9PSBcImFzc2lnblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsID0gbWlkaV9ldmVudC5jaGFubmVsO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY21kID0gbWlkaV9ldmVudC5jbWQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTEgPSBtaWRpX2V2ZW50LmRhdGFbMV07XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTIgPSBtaWRpX2V2ZW50LmRhdGFbMl07XHJcbiAgICAgICAgICAgIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pZGlfZXZlbnQuY21kID09IE1JRElFdmVudC5OT1RFT0ZGKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NlbmRcclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IHRoaXMubWlkaV9ldmVudDtcclxuICAgICAgICBtaWRpX2V2ZW50LmNoYW5uZWwgPSB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbDtcclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmNtZCAmJiB0aGlzLnByb3BlcnRpZXMuY21kLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5zZXRDb21tYW5kRnJvbVN0cmluZyh0aGlzLnByb3BlcnRpZXMuY21kKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtaWRpX2V2ZW50LmNtZCA9IHRoaXMucHJvcGVydGllcy5jbWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pZGlfZXZlbnQuZGF0YVswXSA9IG1pZGlfZXZlbnQuY21kIHwgbWlkaV9ldmVudC5jaGFubmVsO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuZGF0YVsxXSA9IE51bWJlcih0aGlzLnByb3BlcnRpZXMudmFsdWUxKTtcclxuICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMl0gPSBOdW1iZXIodGhpcy5wcm9wZXJ0aWVzLnZhbHVlMik7XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX21pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUV2ZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm90ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IE1JRElFdmVudC5Ob3RlU3RyaW5nVG9QaXRjaCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTEgPSAodiB8IDApICUgMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbWRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlMVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUxID0gTWF0aC5jbGFtcCh2fDAsMCwxMjcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZTJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlMiA9IE1hdGguY2xhbXAodnwwLDAsMTI3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlkaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LnNldHVwKFtwcm9wcy5jbWQsIHByb3BzLnZhbHVlMSwgcHJvcHMudmFsdWUyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuY2hhbm5lbCA9IHByb3BzLmNoYW5uZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tYW5kXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwcm9wcy5jbWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjY1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcHJvcHMudmFsdWUxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2NfdmFsdWVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHByb3BzLnZhbHVlMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuY21kID09IE1JRElFdmVudC5OT1RFT0ZGXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9wcy52YWx1ZTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWxvY2l0eVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcHJvcHMuY21kID09IE1JRElFdmVudC5OT1RFT04gPyBwcm9wcy52YWx1ZTIgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGl0Y2hcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTUlESUV2ZW50LmNvbXB1dGVQaXRjaChwcm9wcy52YWx1ZTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGl0Y2hiZW5kXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuY21kID09IE1JRElFdmVudC5QSVRDSEJFTkRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1JRElFdmVudC5jb21wdXRlUGl0Y2hCZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnZhbHVlMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnYXRlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHYgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUV2ZW50LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjbWRcIikge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY21kID0gTUlESUV2ZW50LmNvbXB1dGVDb21tYW5kRnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElFdmVudC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImNtZFwiLCBcIm51bWJlclwiXSxbXCJub3RlXCIsIFwibnVtYmVyXCJdLFtcInZhbHVlMVwiLCBcIm51bWJlclwiXSxbXCJ2YWx1ZTJcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElFdmVudC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wibWlkaVwiLCBcIm1pZGlcIl0sXHJcbiAgICAgICAgICAgIFtcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcclxuICAgICAgICAgICAgW1wiY29tbWFuZFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wibm90ZVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1widmVsb2NpdHlcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImNjXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJjY192YWx1ZVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicGl0Y2hcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImdhdGVcIiwgXCJib29sXCJdLFxyXG4gICAgICAgICAgICBbXCJwaXRjaGJlbmRcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvZXZlbnRcIiwgTEdNSURJRXZlbnQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESUNDKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgLy9cdFx0Y2hhbm5lbDogMCxcclxuICAgICAgICAgICAgY2M6IDEsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElDQy50aXRsZSA9IFwiTUlESUNDXCI7XHJcbiAgICBMR01JRElDQy5kZXNjID0gXCJnZXRzIGEgQ29udHJvbGxlciBDaGFuZ2VcIjtcclxuICAgIExHTUlESUNDLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElDQy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xyXG4gICAgICAgIGlmIChNSURJSW50ZXJmYWNlLmlucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICBNSURJSW50ZXJmYWNlLmlucHV0LnN0YXRlLmNjW3RoaXMucHJvcGVydGllcy5jY107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvY2NcIiwgTEdNSURJQ0MpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESUdlbmVyYXRvcigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZ2VuZXJhdGVcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNjYWxlXCIsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvY3RhdmVcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJub3RlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBub3RlczogXCJBLEEjLEIsQyxDIyxELEQjLEUsRixGIyxHLEcjXCIsXHJcbiAgICAgICAgICAgIG9jdGF2ZTogMixcclxuICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcclxuICAgICAgICAgICAgbW9kZTogXCJzZXF1ZW5jZVwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5ub3Rlc19waXRjaGVzID0gTEdNSURJR2VuZXJhdG9yLnByb2Nlc3NTY2FsZShcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm5vdGVzXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlX2luZGV4ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElHZW5lcmF0b3IudGl0bGUgPSBcIk1JREkgR2VuZXJhdG9yXCI7XHJcbiAgICBMR01JRElHZW5lcmF0b3IuZGVzYyA9IFwiR2VuZXJhdGVzIGEgcmFuZG9tIE1JREkgbm90ZVwiO1xyXG4gICAgTEdNSURJR2VuZXJhdG9yLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElHZW5lcmF0b3IucHJvY2Vzc1NjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuICAgICAgICB2YXIgbm90ZXMgPSBzY2FsZS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5vdGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoKG4ubGVuZ3RoID09IDIgJiYgblsxXSAhPSBcIiNcIikgfHwgbi5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICBub3Rlc1tpXSA9IC1MaXRlR3JhcGguTUlESUV2ZW50Lk5vdGVTdHJpbmdUb1BpdGNoKG4pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm90ZXNbaV0gPSBNSURJRXZlbnQubm90ZV90b19pbmRleFtuXSB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub3RlcztcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJR2VuZXJhdG9yLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJub3Rlc1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90ZXNfcGl0Y2hlcyA9IExHTUlESUdlbmVyYXRvci5wcm9jZXNzU2NhbGUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJR2VuZXJhdG9yLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb2N0YXZlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgaWYgKG9jdGF2ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5vY3RhdmUgPSBvY3RhdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3Rlc19waXRjaGVzID0gTEdNSURJR2VuZXJhdG9yLnByb2Nlc3NTY2FsZShzY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElHZW5lcmF0b3IucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICAvL3ZhciByYW5nZSA9IHRoaXMucHJvcGVydGllcy5tYXggLSB0aGlzLnByb3BlcnRpZXMubWluO1xyXG4gICAgICAgIC8vdmFyIHBpdGNoID0gdGhpcy5wcm9wZXJ0aWVzLm1pbiArICgoTWF0aC5yYW5kb20oKSAqIHJhbmdlKXwwKTtcclxuICAgICAgICB2YXIgcGl0Y2ggPSAwO1xyXG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMubm90ZXNfcGl0Y2hlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5tb2RlID09IFwic2VxdWVuY2VcIikge1xyXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuc2VxdWVuY2VfaW5kZXggPSAodGhpcy5zZXF1ZW5jZV9pbmRleCArIDEpICUgcmFuZ2U7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BlcnRpZXMubW9kZSA9PSBcInJhbmRvbVwiKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzX3BpdGNoZXNbaW5kZXhdO1xyXG4gICAgICAgIGlmIChub3RlID49IDApIHtcclxuICAgICAgICAgICAgcGl0Y2ggPSBub3RlICsgKHRoaXMucHJvcGVydGllcy5vY3RhdmUgLSAxKSAqIDEyICsgMzM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGl0Y2ggPSAtbm90ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuc2V0dXAoW01JRElFdmVudC5OT1RFT04sIHBpdGNoLCAxMF0pO1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucHJvcGVydGllcy5kdXJhdGlvbiB8fCAxO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcblxyXG4gICAgICAgIC8vbm90ZW9mZlxyXG4gICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50LnNldHVwKFtNSURJRXZlbnQuTk9URU9GRiwgcGl0Y2gsIDBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgZHVyYXRpb24gKiAxMDAwXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2dlbmVyYXRvclwiLCBMR01JRElHZW5lcmF0b3IpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESVRyYW5zcG9zZSgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGFtb3VudDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhbW91bnRcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHJcbiAgICAgICAgdGhpcy5taWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESVRyYW5zcG9zZS50aXRsZSA9IFwiTUlESSBUcmFuc3Bvc2VcIjtcclxuICAgIExHTUlESVRyYW5zcG9zZS5kZXNjID0gXCJUcmFuc3Bvc2UgYSBNSURJIG5vdGVcIjtcclxuICAgIExHTUlESVRyYW5zcG9zZS5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJVHJhbnNwb3NlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgaWYgKCFtaWRpX2V2ZW50IHx8IG1pZGlfZXZlbnQuY29uc3RydWN0b3IgIT09IE1JRElFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9OIHx8XHJcbiAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9GRlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudC5zZXR1cChtaWRpX2V2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQuZGF0YVsxXSA9IE1hdGgucm91bmQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQuZGF0YVsxXSArIHRoaXMucHJvcGVydGllcy5hbW91bnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib3V0XCIsIHRoaXMubWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib3V0XCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJVHJhbnNwb3NlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYW1vdW50ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKGFtb3VudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5hbW91bnQgPSBhbW91bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvdHJhbnNwb3NlXCIsIExHTUlESVRyYW5zcG9zZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJUXVhbnRpemUoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBzY2FsZTogXCJBLEEjLEIsQyxDIyxELEQjLEUsRixGIyxHLEcjXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJub3RlXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzY2FsZVwiLCBcInN0cmluZ1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG5cclxuICAgICAgICB0aGlzLnZhbGlkX25vdGVzID0gbmV3IEFycmF5KDEyKTtcclxuICAgICAgICB0aGlzLm9mZnNldF9ub3RlcyA9IG5ldyBBcnJheSgxMik7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzU2NhbGUodGhpcy5wcm9wZXJ0aWVzLnNjYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElRdWFudGl6ZS50aXRsZSA9IFwiTUlESSBRdWFudGl6ZSBQaXRjaFwiO1xyXG4gICAgTEdNSURJUXVhbnRpemUuZGVzYyA9IFwiVHJhbnNwb3NlIGEgTUlESSBub3RlIHRwIGZpdCBhbiBzY2FsZVwiO1xyXG4gICAgTEdNSURJUXVhbnRpemUuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESVF1YW50aXplLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzY2FsZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1NjYWxlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVF1YW50aXplLnByb3RvdHlwZS5wcm9jZXNzU2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRfc2NhbGUgPSBzY2FsZTtcclxuICAgICAgICB0aGlzLm5vdGVzX3BpdGNoZXMgPSBMR01JRElHZW5lcmF0b3IucHJvY2Vzc1NjYWxlKHNjYWxlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZF9ub3Rlc1tpXSA9IHRoaXMubm90ZXNfcGl0Y2hlcy5pbmRleE9mKGkpICE9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRfbm90ZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0X25vdGVzW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgMTI7ICsraikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRfbm90ZXNbKGkgLSBqKSAlIDEyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0X25vdGVzW2ldID0gLWo7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZF9ub3Rlc1soaSArIGopICUgMTJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRfbm90ZXNbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElRdWFudGl6ZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCB8fCBtaWRpX2V2ZW50LmNvbnN0cnVjdG9yICE9PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPTiB8fFxyXG4gICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPRkZcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQuc2V0dXAobWlkaV9ldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgdmFyIG5vdGUgPSBtaWRpX2V2ZW50Lm5vdGU7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE1JRElFdmVudC5ub3RlX3RvX2luZGV4W25vdGVdO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRfbm90ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQuZGF0YVsxXSArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm91dFwiLCB0aGlzLm1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm91dFwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVF1YW50aXplLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCAmJiBzY2FsZSAhPSB0aGlzLl9jdXJyZW50X3NjYWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1NjYWxlKHNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9xdWFudGl6ZVwiLCBMR01JRElRdWFudGl6ZSk7XHJcblxyXG5cdGZ1bmN0aW9uIExHTUlESUZyb21GaWxlKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgdXJsOiBcIlwiLFxyXG5cdFx0XHRhdXRvcGxheTogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJwbGF5XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJwYXVzZVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHRcdHRoaXMuX21pZGkgPSBudWxsO1xyXG5cdFx0dGhpcy5fY3VycmVudF90aW1lID0gMDtcclxuXHRcdHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBNaWRpUGFyc2VyID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgICAgIFwibWlkaS1wYXJzZXIuanMgbm90IGluY2x1ZGVkLCBMR01pZGlQbGF5IHJlcXVpcmVzIHRoYXQgbGlicmFyeTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NvbHhpL21pZGktcGFyc2VyLWpzL21hc3Rlci9zcmMvbWFpbi5qc1wiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG4gICAgTEdNSURJRnJvbUZpbGUudGl0bGUgPSBcIk1JREkgZnJvbUZpbGVcIjtcclxuICAgIExHTUlESUZyb21GaWxlLmRlc2MgPSBcIlBsYXlzIGEgTUlESSBmaWxlXCI7XHJcbiAgICBMR01JRElGcm9tRmlsZS5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG5cdExHTUlESUZyb21GaWxlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKCBuYW1lIClcclxuXHR7XHJcblx0XHRpZihuYW1lID09IFwicGxheVwiKVxyXG5cdFx0XHR0aGlzLnBsYXkoKTtcclxuXHRcdGVsc2UgaWYobmFtZSA9PSBcInBhdXNlXCIpXHJcblx0XHRcdHRoaXMuX3BsYXlpbmcgPSAhdGhpcy5fcGxheWluZztcclxuXHR9XHJcblxyXG5cdExHTUlESUZyb21GaWxlLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0aWYobmFtZSA9PSBcInVybFwiKVxyXG5cdFx0XHR0aGlzLmxvYWRNSURJRmlsZSh2YWx1ZSk7XHJcblx0fVxyXG5cclxuICAgIExHTUlESUZyb21GaWxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKCF0aGlzLl9taWRpKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIXRoaXMuX3BsYXlpbmcpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR0aGlzLl9jdXJyZW50X3RpbWUgKz0gdGhpcy5ncmFwaC5lbGFwc2VkX3RpbWU7XHJcblx0XHR2YXIgY3VycmVudF90aW1lID0gdGhpcy5fY3VycmVudF90aW1lICogMTAwO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9taWRpLnRyYWNrczsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdHJhY2sgPSB0aGlzLl9taWRpLnRyYWNrW2ldO1xyXG5cdFx0XHRpZighdHJhY2suX2xhc3RfcG9zKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dHJhY2suX2xhc3RfcG9zID0gMDtcclxuXHRcdFx0XHR0cmFjay5fdGltZSA9IDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBlbGVtID0gdHJhY2suZXZlbnRbIHRyYWNrLl9sYXN0X3BvcyBdO1xyXG5cdFx0XHRpZihlbGVtICYmICh0cmFjay5fdGltZSArIGVsZW0uZGVsdGFUaW1lKSA8PSBjdXJyZW50X3RpbWUgKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dHJhY2suX2xhc3RfcG9zKys7XHJcblx0XHRcdFx0dHJhY2suX3RpbWUgKz0gZWxlbS5kZWx0YVRpbWU7XHJcblxyXG5cdFx0XHRcdGlmKGVsZW0uZGF0YSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgbWlkaV9jbWQgPSBlbGVtLnR5cGUgPDwgNCArIGVsZW0uY2hhbm5lbDtcclxuXHRcdFx0XHRcdHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG5cdFx0XHRcdFx0bWlkaV9ldmVudC5zZXR1cChbbWlkaV9jbWQsIGVsZW0uZGF0YVswXSwgZWxlbS5kYXRhWzFdXSk7XHJcblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH1cclxuICAgIH07XHJcblxyXG5cdExHTUlESUZyb21GaWxlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5fY3VycmVudF90aW1lID0gMDtcclxuXHRcdGlmKCF0aGlzLl9taWRpKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX21pZGkudHJhY2tzOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB0cmFjayA9IHRoaXMuX21pZGkudHJhY2tbaV07XHJcblx0XHRcdHRyYWNrLl9sYXN0X3BvcyA9IDA7XHJcblx0XHRcdHRyYWNrLl90aW1lID0gMDtcclxuXHRcdH1cdFx0XHJcblx0fVxyXG5cclxuXHRMR01JRElGcm9tRmlsZS5wcm90b3R5cGUubG9hZE1JRElGaWxlID0gZnVuY3Rpb24odXJsKVxyXG5cdHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdExpdGVHcmFwaC5mZXRjaEZpbGUoIHVybCwgXCJhcnJheWJ1ZmZlclwiLCBmdW5jdGlvbihkYXRhKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGF0LmJveGNvbG9yID0gXCIjQUZBXCI7XHJcblx0XHRcdHRoYXQuX21pZGkgPSBNaWRpUGFyc2VyLnBhcnNlKCBuZXcgVWludDhBcnJheShkYXRhKSApO1xyXG5cdFx0XHRpZih0aGF0LnByb3BlcnRpZXMuYXV0b3BsYXkpXHJcblx0XHRcdFx0dGhhdC5wbGF5KCk7XHJcblx0XHR9LCBmdW5jdGlvbihlcnIpe1xyXG5cdFx0XHR0aGF0LmJveGNvbG9yID0gXCIjRkFBXCI7XHJcblx0XHRcdHRoYXQuX21pZGkgPSBudWxsO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRMR01JRElGcm9tRmlsZS5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGZpbGUpXHJcblx0e1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzLnVybCA9IFwiXCI7XHJcblx0XHR0aGlzLmxvYWRNSURJRmlsZSggZmlsZSApO1xyXG5cdH1cclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvZnJvbUZpbGVcIiwgTEdNSURJRnJvbUZpbGUpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElQbGF5KCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgdm9sdW1lOiAwLjUsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwibm90ZVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwidm9sdW1lXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkdXJhdGlvblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBBdWRpb1N5bnRoID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgICAgIFwiQXVkaW9zeW50aC5qcyBub3QgaW5jbHVkZWQsIExHTWlkaVBsYXkgcmVxdWlyZXMgdGhhdCBsaWJyYXJ5XCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIFN5bnRoID0gKHRoaXMuc3ludGggPSBuZXcgQXVkaW9TeW50aCgpKTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0cnVtZW50ID0gU3ludGguY3JlYXRlSW5zdHJ1bWVudChcInBpYW5vXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBMR01JRElQbGF5LnRpdGxlID0gXCJNSURJIFBsYXlcIjtcclxuICAgIExHTUlESVBsYXkuZGVzYyA9IFwiUGxheXMgYSBNSURJIG5vdGVcIjtcclxuICAgIExHTUlESVBsYXkuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESVBsYXkucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICBpZiAoIW1pZGlfZXZlbnQgfHwgbWlkaV9ldmVudC5jb25zdHJ1Y3RvciAhPT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmluc3RydW1lbnQgJiYgbWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT04pIHtcclxuICAgICAgICAgICAgdmFyIG5vdGUgPSBtaWRpX2V2ZW50Lm5vdGU7IC8vQyNcclxuICAgICAgICAgICAgaWYgKCFub3RlIHx8IG5vdGUgPT0gXCJ1bmRlZmluZWRcIiB8fCBub3RlLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmluc3RydW1lbnQucGxheShcclxuICAgICAgICAgICAgICAgIG5vdGUsXHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50Lm9jdGF2ZSxcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52b2x1bWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJUGxheS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHZvbHVtZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh2b2x1bWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudm9sdW1lID0gdm9sdW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvcGxheVwiLCBMR01JRElQbGF5KTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElLZXlzKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgbnVtX29jdGF2ZXM6IDIsXHJcbiAgICAgICAgICAgIHN0YXJ0X29jdGF2ZTogMlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInJlc2V0XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwibm90ZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs0MDAsIDEwMF07XHJcbiAgICAgICAgdGhpcy5rZXlzID0gW107XHJcbiAgICAgICAgdGhpcy5fbGFzdF9rZXkgPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElLZXlzLnRpdGxlID0gXCJNSURJIEtleXNcIjtcclxuICAgIExHTUlESUtleXMuZGVzYyA9IFwiS2V5Ym9hcmQgdG8gcGxheSBub3Rlc1wiO1xyXG4gICAgTEdNSURJS2V5cy5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJS2V5cy5rZXlzID0gW1xyXG4gICAgICAgIHsgeDogMCwgdzogMSwgaDogMSwgdDogMCB9LFxyXG4gICAgICAgIHsgeDogMC43NSwgdzogMC41LCBoOiAwLjYsIHQ6IDEgfSxcclxuICAgICAgICB7IHg6IDEsIHc6IDEsIGg6IDEsIHQ6IDAgfSxcclxuICAgICAgICB7IHg6IDEuNzUsIHc6IDAuNSwgaDogMC42LCB0OiAxIH0sXHJcbiAgICAgICAgeyB4OiAyLCB3OiAxLCBoOiAxLCB0OiAwIH0sXHJcbiAgICAgICAgeyB4OiAyLjc1LCB3OiAwLjUsIGg6IDAuNiwgdDogMSB9LFxyXG4gICAgICAgIHsgeDogMywgdzogMSwgaDogMSwgdDogMCB9LFxyXG4gICAgICAgIHsgeDogNCwgdzogMSwgaDogMSwgdDogMCB9LFxyXG4gICAgICAgIHsgeDogNC43NSwgdzogMC41LCBoOiAwLjYsIHQ6IDEgfSxcclxuICAgICAgICB7IHg6IDUsIHc6IDEsIGg6IDEsIHQ6IDAgfSxcclxuICAgICAgICB7IHg6IDUuNzUsIHc6IDAuNSwgaDogMC42LCB0OiAxIH0sXHJcbiAgICAgICAgeyB4OiA2LCB3OiAxLCBoOiAxLCB0OiAwIH1cclxuICAgIF07XHJcblxyXG4gICAgTEdNSURJS2V5cy5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbnVtX2tleXMgPSB0aGlzLnByb3BlcnRpZXMubnVtX29jdGF2ZXMgKiAxMjtcclxuICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gbnVtX2tleXM7XHJcbiAgICAgICAgdmFyIGtleV93aWR0aCA9IHRoaXMuc2l6ZVswXSAvICh0aGlzLnByb3BlcnRpZXMubnVtX29jdGF2ZXMgKiA3KTtcclxuICAgICAgICB2YXIga2V5X2hlaWdodCA9IHRoaXMuc2l6ZVsxXTtcclxuXHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuXHJcbiAgICAgICAgZm9yIChcclxuICAgICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICAgICBrIDwgMjtcclxuICAgICAgICAgICAgaysrIC8vZHJhdyBmaXJzdCB3aGl0ZXMgKDApIHRoZW4gYmxhY2tzICgxKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9rZXlzOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlfaW5mbyA9IExHTUlESUtleXMua2V5c1tpICUgMTJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleV9pbmZvLnQgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9jdGF2ZSA9IE1hdGguZmxvb3IoaSAvIDEyKTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gb2N0YXZlICogNyAqIGtleV93aWR0aCArIGtleV9pbmZvLnggKiBrZXlfd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMua2V5c1tpXSA/IFwiI0NDQ1wiIDogXCJ3aGl0ZVwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5rZXlzW2ldID8gXCIjMzMzXCIgOiBcImJsYWNrXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgeCArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBrZXlfd2lkdGggKiBrZXlfaW5mby53IC0gMixcclxuICAgICAgICAgICAgICAgICAgICBrZXlfaGVpZ2h0ICoga2V5X2luZm8uaFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJS2V5cy5wcm90b3R5cGUuZ2V0S2V5SW5kZXggPSBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgbnVtX2tleXMgPSB0aGlzLnByb3BlcnRpZXMubnVtX29jdGF2ZXMgKiAxMjtcclxuICAgICAgICB2YXIga2V5X3dpZHRoID0gdGhpcy5zaXplWzBdIC8gKHRoaXMucHJvcGVydGllcy5udW1fb2N0YXZlcyAqIDcpO1xyXG4gICAgICAgIHZhciBrZXlfaGVpZ2h0ID0gdGhpcy5zaXplWzFdO1xyXG5cclxuICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICB2YXIgayA9IDE7XHJcbiAgICAgICAgICAgIGsgPj0gMDtcclxuICAgICAgICAgICAgay0tIC8vdGVzdCBibGFja3MgZmlyc3QgKDEpIHRoZW4gd2hpdGVzICgwKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleV9pbmZvID0gTEdNSURJS2V5cy5rZXlzW2kgJSAxMl07XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5X2luZm8udCAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgb2N0YXZlID0gTWF0aC5mbG9vcihpIC8gMTIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBvY3RhdmUgKiA3ICoga2V5X3dpZHRoICsga2V5X2luZm8ueCAqIGtleV93aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB3ID0ga2V5X3dpZHRoICoga2V5X2luZm8udztcclxuICAgICAgICAgICAgICAgIHZhciBoID0ga2V5X2hlaWdodCAqIGtleV9pbmZvLmg7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zWzBdIDwgeCB8fCBwb3NbMF0gPiB4ICsgdyB8fCBwb3NbMV0gPiBoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUtleXMucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xyXG4gICAgICAgIGlmIChldmVudCA9PSBcInJlc2V0XCIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcGFyYW1zIHx8IHBhcmFtcy5jb25zdHJ1Y3RvciAhPT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBwYXJhbXM7XHJcbiAgICAgICAgdmFyIHN0YXJ0X25vdGUgPSAodGhpcy5wcm9wZXJ0aWVzLnN0YXJ0X29jdGF2ZSAtIDEpICogMTIgKyAyOTtcclxuICAgICAgICB2YXIgaW5kZXggPSBtaWRpX2V2ZW50LmRhdGFbMV0gLSBzdGFydF9ub3RlO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAobWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT04pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9GRikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzW2luZGV4XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElLZXlzLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIHBvcykge1xyXG4gICAgICAgIGlmIChwb3NbMV0gPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChwb3MpO1xyXG4gICAgICAgIHRoaXMua2V5c1tpbmRleF0gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2xhc3Rfa2V5ID0gaW5kZXg7XHJcbiAgICAgICAgdmFyIHBpdGNoID0gKHRoaXMucHJvcGVydGllcy5zdGFydF9vY3RhdmUgLSAxKSAqIDEyICsgMjkgKyBpbmRleDtcclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICBtaWRpX2V2ZW50LnNldHVwKFtNSURJRXZlbnQuTk9URU9OLCBwaXRjaCwgMTAwXSk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJS2V5cy5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlLCBwb3MpIHtcclxuICAgICAgICBpZiAocG9zWzFdIDwgMCB8fCB0aGlzLl9sYXN0X2tleSA9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChwb3MpO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0X2tleSA9PSBpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5rZXlzW3RoaXMuX2xhc3Rfa2V5XSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBwaXRjaCA9XHJcbiAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMuc3RhcnRfb2N0YXZlIC0gMSkgKiAxMiArIDI5ICsgdGhpcy5fbGFzdF9rZXk7XHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgbWlkaV9ldmVudC5zZXR1cChbTUlESUV2ZW50Lk5PVEVPRkYsIHBpdGNoLCAxMDBdKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG5cclxuICAgICAgICB0aGlzLmtleXNbaW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcGl0Y2ggPSAodGhpcy5wcm9wZXJ0aWVzLnN0YXJ0X29jdGF2ZSAtIDEpICogMTIgKyAyOSArIGluZGV4O1xyXG4gICAgICAgIHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuc2V0dXAoW01JRElFdmVudC5OT1RFT04sIHBpdGNoLCAxMDBdKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXN0X2tleSA9IGluZGV4O1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElLZXlzLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlLCBwb3MpIHtcclxuICAgICAgICBpZiAocG9zWzFdIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgocG9zKTtcclxuICAgICAgICB0aGlzLmtleXNbaW5kZXhdID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbGFzdF9rZXkgPSAtMTtcclxuICAgICAgICB2YXIgcGl0Y2ggPSAodGhpcy5wcm9wZXJ0aWVzLnN0YXJ0X29jdGF2ZSAtIDEpICogMTIgKyAyOSArIGluZGV4O1xyXG4gICAgICAgIHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuc2V0dXAoW01JRElFdmVudC5OT1RFT0ZGLCBwaXRjaCwgMTAwXSk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2tleXNcIiwgTEdNSURJS2V5cyk7XHJcblxyXG4gICAgZnVuY3Rpb24gbm93KCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcbn0pKHRoaXMpO1xyXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cclxuICAgIHZhciBMR0F1ZGlvID0ge307XHJcbiAgICBnbG9iYWwuTEdBdWRpbyA9IExHQXVkaW87XHJcblxyXG4gICAgTEdBdWRpby5nZXRBdWRpb0NvbnRleHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2F1ZGlvX2NvbnRleHQpIHtcclxuICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmICghd2luZG93LkF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkF1ZGlvQ29udGV4dCBub3Qgc3VwcG9ydGVkIGJ5IGJyb3dzZXJcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb19jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb19jb250ZXh0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJtc2dcIiwgbXNnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9fY29udGV4dC5vbmVuZGVkID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVuZGVkXCIsIG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvX2NvbnRleHQub25jb21wbGV0ZSA9IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb21wbGV0ZVwiLCBtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pbiBjYXNlIGl0IGNyYXNoZXNcclxuICAgICAgICAvL2lmKHRoaXMuX2F1ZGlvX2NvbnRleHQuc3RhdGUgPT0gXCJzdXNwZW5kZWRcIilcclxuICAgICAgICAvL1x0dGhpcy5fYXVkaW9fY29udGV4dC5yZXN1bWUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXVkaW9fY29udGV4dDtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jb25uZWN0ID0gZnVuY3Rpb24oYXVkaW9ub2RlQSwgYXVkaW9ub2RlQikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF1ZGlvbm9kZUEuY29ubmVjdChhdWRpb25vZGVCKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTEdyYXBoQXVkaW86XCIsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihhdWRpb25vZGVBLCBhdWRpb25vZGVCKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXVkaW9ub2RlQS5kaXNjb25uZWN0KGF1ZGlvbm9kZUIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJMR3JhcGhBdWRpbzpcIiwgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY2hhbmdlQWxsQXVkaW9zQ29ubmVjdGlvbnMgPSBmdW5jdGlvbihub2RlLCBjb25uZWN0KSB7XHJcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IG5vZGUuZ3JhcGgubGlua3NbaW5wdXQubGlua107XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5fbm9kZSA9IG5vZGUuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLm9yaWdpbl9pZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luX2F1ZGlvbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luX25vZGUuZ2V0QXVkaW9Ob2RlSW5PdXRwdXRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luX2F1ZGlvbm9kZSA9IG9yaWdpbl9ub2RlLmdldEF1ZGlvTm9kZUluT3V0cHV0U2xvdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLm9yaWdpbl9zbG90XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luX2F1ZGlvbm9kZSA9IG9yaWdpbl9ub2RlLmF1ZGlvbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X2F1ZGlvbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldF9hdWRpb25vZGUgPSBub2RlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90KGkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRfYXVkaW9ub2RlID0gbm9kZS5hdWRpb25vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBMR0F1ZGlvLmNvbm5lY3Qob3JpZ2luX2F1ZGlvbm9kZSwgdGFyZ2V0X2F1ZGlvbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIExHQXVkaW8uZGlzY29ubmVjdChvcmlnaW5fYXVkaW9ub2RlLCB0YXJnZXRfYXVkaW9ub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5vZGUub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0LmxpbmtzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IG5vZGUuZ3JhcGgubGlua3Nbb3V0cHV0LmxpbmtzW2pdXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5fYXVkaW9ub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRBdWRpb05vZGVJbk91dHB1dFNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luX2F1ZGlvbm9kZSA9IG5vZGUuZ2V0QXVkaW9Ob2RlSW5PdXRwdXRTbG90KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbl9hdWRpb25vZGUgPSBub2RlLmF1ZGlvbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IG5vZGUuZ3JhcGguZ2V0Tm9kZUJ5SWQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby50YXJnZXRfaWRcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfYXVkaW9ub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X2F1ZGlvbm9kZSA9IHRhcmdldF9ub2RlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X2F1ZGlvbm9kZSA9IHRhcmdldF9ub2RlLmF1ZGlvbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExHQXVkaW8uY29ubmVjdChvcmlnaW5fYXVkaW9ub2RlLCB0YXJnZXRfYXVkaW9ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMR0F1ZGlvLmRpc2Nvbm5lY3Qob3JpZ2luX2F1ZGlvbm9kZSwgdGFyZ2V0X2F1ZGlvbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL3VzZWQgYnkgbWFueSBub2Rlc1xyXG4gICAgTEdBdWRpby5vbkNvbm5lY3Rpb25zQ2hhbmdlID0gZnVuY3Rpb24oXHJcbiAgICAgICAgY29ubmVjdGlvbixcclxuICAgICAgICBzbG90LFxyXG4gICAgICAgIGNvbm5lY3RlZCxcclxuICAgICAgICBsaW5rX2luZm9cclxuICAgICkge1xyXG4gICAgICAgIC8vb25seSBwcm9jZXNzIHRoZSBvdXRwdXRzIGV2ZW50c1xyXG4gICAgICAgIGlmIChjb25uZWN0aW9uICE9IExpdGVHcmFwaC5PVVRQVVQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhcmdldF9ub2RlID0gbnVsbDtcclxuICAgICAgICBpZiAobGlua19pbmZvKSB7XHJcbiAgICAgICAgICAgIHRhcmdldF9ub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rX2luZm8udGFyZ2V0X2lkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGFyZ2V0X25vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9nZXQgb3JpZ2luIGF1ZGlvbm9kZVxyXG4gICAgICAgIHZhciBsb2NhbF9hdWRpb25vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmdldEF1ZGlvTm9kZUluT3V0cHV0U2xvdCkge1xyXG4gICAgICAgICAgICBsb2NhbF9hdWRpb25vZGUgPSB0aGlzLmdldEF1ZGlvTm9kZUluT3V0cHV0U2xvdChzbG90KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2NhbF9hdWRpb25vZGUgPSB0aGlzLmF1ZGlvbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZ2V0IHRhcmdldCBhdWRpb25vZGVcclxuICAgICAgICB2YXIgdGFyZ2V0X2F1ZGlvbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRhcmdldF9ub2RlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90KSB7XHJcbiAgICAgICAgICAgIHRhcmdldF9hdWRpb25vZGUgPSB0YXJnZXRfbm9kZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdChcclxuICAgICAgICAgICAgICAgIGxpbmtfaW5mby50YXJnZXRfc2xvdFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldF9hdWRpb25vZGUgPSB0YXJnZXRfbm9kZS5hdWRpb25vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RvIHRoZSBjb25uZWN0aW9uL2Rpc2Nvbm5lY3Rpb25cclxuICAgICAgICBpZiAoY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIExHQXVkaW8uY29ubmVjdChsb2NhbF9hdWRpb25vZGUsIHRhcmdldF9hdWRpb25vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIExHQXVkaW8uZGlzY29ubmVjdChsb2NhbF9hdWRpb25vZGUsIHRhcmdldF9hdWRpb25vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy90aGlzIGZ1bmN0aW9uIGhlbHBzIGNyZWF0aW5nIHdyYXBwZXJzIHRvIGV4aXN0aW5nIGNsYXNzZXNcclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlciA9IGZ1bmN0aW9uKGNsYXNzX29iamVjdCkge1xyXG4gICAgICAgIHZhciBvbGRfZnVuYyA9IGNsYXNzX29iamVjdC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQ7XHJcblxyXG4gICAgICAgIGNsYXNzX29iamVjdC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAob2xkX2Z1bmMpIHtcclxuICAgICAgICAgICAgICAgIG9sZF9mdW5jLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXVkaW9ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvbm9kZVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvbm9kZVtuYW1lXS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtuYW1lXS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNsYXNzX29iamVjdC5wcm90b3R5cGUub25Db25uZWN0aW9uc0NoYW5nZSA9XHJcbiAgICAgICAgICAgIExHQXVkaW8ub25Db25uZWN0aW9uc0NoYW5nZTtcclxuICAgIH07XHJcblxyXG4gICAgLy9jb250YWlucyB0aGUgc2FtcGxlcyBkZWNvZGVkIG9mIHRoZSBsb2FkZWQgYXVkaW9zIGluIEF1ZGlvQnVmZmVyIGZvcm1hdFxyXG4gICAgTEdBdWRpby5jYWNoZWRfYXVkaW9zID0ge307XHJcblxyXG4gICAgTEdBdWRpby5sb2FkU291bmQgPSBmdW5jdGlvbih1cmwsIG9uX2NvbXBsZXRlLCBvbl9lcnJvcikge1xyXG4gICAgICAgIGlmIChMR0F1ZGlvLmNhY2hlZF9hdWRpb3NbdXJsXSAmJiB1cmwuaW5kZXhPZihcImJsb2I6XCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChvbl9jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgb25fY29tcGxldGUoTEdBdWRpby5jYWNoZWRfYXVkaW9zW3VybF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChMR0F1ZGlvLm9uUHJvY2Vzc0F1ZGlvVVJMKSB7XHJcbiAgICAgICAgICAgIHVybCA9IExHQXVkaW8ub25Qcm9jZXNzQXVkaW9VUkwodXJsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbG9hZCBuZXcgc2FtcGxlXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcclxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgICAgICAvLyBEZWNvZGUgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkF1ZGlvU291cmNlIGxvYWRlZFwiKTtcclxuICAgICAgICAgICAgY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBdWRpb1NvdXJjZSBkZWNvZGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIExHQXVkaW8uY2FjaGVkX2F1ZGlvc1t1cmxdID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbl9jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbl9jb21wbGV0ZShidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBdWRpbyBsb2FkaW5nIHNhbXBsZSBlcnJvcjpcIiwgZXJyKTtcclxuICAgICAgICAgICAgaWYgKG9uX2Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbl9lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH07XHJcblxyXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb1NvdXJjZSgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHNyYzogXCJcIixcclxuICAgICAgICAgICAgZ2FpbjogMC41LFxyXG4gICAgICAgICAgICBsb29wOiB0cnVlLFxyXG4gICAgICAgICAgICBhdXRvcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgcGxheWJhY2tSYXRlOiAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ19hdWRpbyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvYnVmZmVyID0gbnVsbDsgLy9wb2ludHMgdG8gQXVkaW9CdWZmZXIgd2l0aCB0aGUgYXVkaW8gc2FtcGxlcyBkZWNvZGVkXHJcbiAgICAgICAgdGhpcy5fYXVkaW9ub2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xhc3Rfc291cmNlbm9kZSA9IG51bGw7IC8vdGhlIGxhc3QgQXVkaW9CdWZmZXJTb3VyY2VOb2RlICh0aGVyZSBjb3VsZCBiZSBtb3JlIGlmIHRoZXJlIGFyZSBzZXZlcmFsIHNvdW5kcyBwbGF5aW5nKVxyXG5cclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJnYWluXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuICAgICAgICAvL2luaXQgY29udGV4dFxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgZ2FpbiBub2RlIHRvIGNvbnRyb2wgdm9sdW1lXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5ncmFwaG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbjtcclxuXHJcbiAgICAgICAgLy9kZWJ1Z1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuc3JjKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFNvdW5kKHRoaXMucHJvcGVydGllcy5zcmMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblx0TEdBdWRpb1NvdXJjZS5kZXNjID0gXCJQbGF5cyBhbiBhdWRpbyBmaWxlXCI7XHJcbiAgICBMR0F1ZGlvU291cmNlW1wiQHNyY1wiXSA9IHsgd2lkZ2V0OiBcInJlc291cmNlXCIgfTtcclxuICAgIExHQXVkaW9Tb3VyY2Uuc3VwcG9ydGVkX2V4dGVuc2lvbnMgPSBbXCJ3YXZcIiwgXCJvZ2dcIiwgXCJtcDNcIl07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25BZGRlZCA9IGZ1bmN0aW9uKGdyYXBoKSB7XHJcbiAgICAgICAgaWYgKGdyYXBoLnN0YXR1cyA9PT0gTEdyYXBoLlNUQVRVU19SVU5OSU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYXVkaW9idWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5hdXRvcGxheSkge1xyXG5cdFx0XHR0aGlzLnBsYXlCdWZmZXIodGhpcy5fYXVkaW9idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wQWxsU291bmRzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uUGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnBhdXNlQWxsU291bmRzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uVW5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudW5wYXVzZUFsbFNvdW5kcygpO1xyXG4gICAgICAgIC8vdGhpcy5vblN0YXJ0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcEFsbFNvdW5kcygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9kcm9wcGVkX3VybCkge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX3VybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5zdG9wQWxsU291bmRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9pdGVyYXRlIGFuZCBzdG9wXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hdWRpb25vZGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdWRpb25vZGVzW2ldLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvbm9kZXNbaV0uc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9ub2Rlc1tpXS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy90aGlzLl9hdWRpb25vZGVzW2ldLmRpc2Nvbm5lY3QoIHRoaXMuYXVkaW9ub2RlICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2F1ZGlvbm9kZXMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUucGF1c2VBbGxTb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLnN1c3BlbmQoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUudW5wYXVzZUFsbFNvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkucmVzdW1lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubmFtZSA9PSBcImdhaW5cIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0Lm5hbWUgPT0gXCJzcmNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvcGVydHkoXCJzcmNcIix2KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubmFtZSA9PSBcInBsYXliYWNrUmF0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnBsYXliYWNrUmF0ZSA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9hdWRpb25vZGVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvbm9kZXNbal0ucGxheWJhY2tSYXRlLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lm5hbWUgPT0gXCJidWZmZXJcIiAmJiB0aGlzLl9hdWRpb2J1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCB0aGlzLl9hdWRpb2J1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fYXVkaW9idWZmZXIpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50ID09IFwiUGxheVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdWZmZXIodGhpcy5fYXVkaW9idWZmZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09IFwiU3RvcFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbGxTb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwic3JjXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkU291bmQodmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImdhaW5cIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwicGxheWJhY2tSYXRlXCIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9hdWRpb25vZGVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb25vZGVzW2pdLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5wbGF5QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgYSBuZXcgYXVkaW9ub2RlICh0aGlzIGlzIG1hbmRhdG9yeSwgQXVkaW9BUEkgZG9lc250IGxpa2UgdG8gcmV1c2Ugb2xkIG9uZXMpXHJcbiAgICAgICAgdmFyIGF1ZGlvbm9kZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7IC8vY3JlYXRlIGEgQXVkaW9CdWZmZXJTb3VyY2VOb2RlXHJcbiAgICAgICAgdGhpcy5fbGFzdF9zb3VyY2Vub2RlID0gYXVkaW9ub2RlO1xyXG4gICAgICAgIGF1ZGlvbm9kZS5ncmFwaG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIGF1ZGlvbm9kZS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgYXVkaW9ub2RlLmxvb3AgPSB0aGlzLnByb3BlcnRpZXMubG9vcDtcclxuICAgICAgICBhdWRpb25vZGUucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLnBsYXliYWNrUmF0ZTtcclxuICAgICAgICB0aGlzLl9hdWRpb25vZGVzLnB1c2goYXVkaW9ub2RlKTtcclxuICAgICAgICBhdWRpb25vZGUuY29ubmVjdCh0aGlzLmF1ZGlvbm9kZSk7IC8vY29ubmVjdCB0byBnYWluXHJcblxyXG5cdFx0dGhpcy5fYXVkaW9ub2Rlcy5wdXNoKGF1ZGlvbm9kZSk7XHJcblxyXG5cdFx0dGhpcy50cmlnZ2VyKFwic3RhcnRcIik7XHJcblxyXG4gICAgICAgIGF1ZGlvbm9kZS5vbmVuZGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJlbmRlZCFcIik7XHJcbiAgICAgICAgICAgIHRoYXQudHJpZ2dlcihcImVuZGVkXCIpO1xyXG4gICAgICAgICAgICAvL3JlbW92ZVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGF0Ll9hdWRpb25vZGVzLmluZGV4T2YoYXVkaW9ub2RlKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9hdWRpb25vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIWF1ZGlvbm9kZS5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvbm9kZS5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgYXVkaW9ub2RlLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdWRpb25vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLmxvYWRTb3VuZCA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgLy9raWxsIHByZXZpb3VzIGxvYWRcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFib3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fYXVkaW9idWZmZXIgPSBudWxsOyAvL3BvaW50cyB0byB0aGUgYXVkaW9idWZmZXIgb25jZSB0aGUgYXVkaW8gaXMgbG9hZGVkXHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ19hdWRpbyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIXVybCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gTEdBdWRpby5sb2FkU291bmQodXJsLCBpbm5lcik7XHJcblxyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdfYXVkaW8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBQTRcIjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5uZXIoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBMaXRlR3JhcGguTk9ERV9ERUZBVUxUX0JPWENPTE9SO1xyXG4gICAgICAgICAgICB0aGF0Ll9hdWRpb2J1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhhdC5fbG9hZGluZ19hdWRpbyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL2lmIGlzIHBsYXlpbmcsIHRoZW4gcGxheSBpdFxyXG4gICAgICAgICAgICBpZiAodGhhdC5ncmFwaCAmJiB0aGF0LmdyYXBoLnN0YXR1cyA9PT0gTEdyYXBoLlNUQVRVU19SVU5OSU5HKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm9uU3RhcnQoKTtcclxuICAgICAgICAgICAgfSAvL3RoaXMgY29udHJvbHMgdGhlIGF1dG9wbGF5IGFscmVhZHlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vSGVscHMgY29ubmVjdC9kaXNjb25uZWN0IEF1ZGlvTm9kZXMgd2hlbiBuZXcgY29ubmVjdGlvbnMgYXJlIG1hZGUgaW4gdGhlIG5vZGVcclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uQ29ubmVjdGlvbnNDaGFuZ2UgPSBMR0F1ZGlvLm9uQ29ubmVjdGlvbnNDaGFuZ2U7XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJwbGF5YmFja1JhdGVcIiwgXCJudW1iZXJcIl0sXHJcblx0XHRcdFtcInNyY1wiLFwic3RyaW5nXCJdLFxyXG4gICAgICAgICAgICBbXCJQbGF5XCIsIExpdGVHcmFwaC5BQ1RJT05dLFxyXG4gICAgICAgICAgICBbXCJTdG9wXCIsIExpdGVHcmFwaC5BQ1RJT05dXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJidWZmZXJcIiwgXCJhdWRpb2J1ZmZlclwiXSwgW1wic3RhcnRcIiwgTGl0ZUdyYXBoLkVWRU5UXSwgW1wiZW5kZWRcIiwgTGl0ZUdyYXBoLkVWRU5UXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRfdXJsKSB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fZHJvcHBlZF91cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMuc3JjID0gdXJsO1xyXG4gICAgICAgIHRoaXMubG9hZFNvdW5kKHVybCk7XHJcbiAgICAgICAgdGhpcy5fZHJvcHBlZF91cmwgPSB1cmw7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UudGl0bGUgPSBcIlNvdXJjZVwiO1xyXG4gICAgTEdBdWRpb1NvdXJjZS5kZXNjID0gXCJQbGF5cyBhdWRpb1wiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9zb3VyY2VcIiwgTEdBdWRpb1NvdXJjZSk7XHJcblxyXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb01lZGlhU291cmNlKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZ2FpbjogMC41XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fYXVkaW9ub2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX21lZGlhX3N0cmVhbSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImdhaW5cIiwgXCJudW1iZXJcIik7XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGdhaW4gbm9kZSB0byBjb250cm9sIHZvbHVtZVxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdyYXBobm9kZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25BZGRlZCA9IGZ1bmN0aW9uKGdyYXBoKSB7XHJcbiAgICAgICAgaWYgKGdyYXBoLnN0YXR1cyA9PT0gTEdyYXBoLlNUQVRVU19SVU5OSU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lZGlhX3N0cmVhbSA9PSBudWxsICYmICF0aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uVW5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbjtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vblJlbW92ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5hdWRpb3NvdXJjZV9ub2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9zb3VyY2Vfbm9kZS5kaXNjb25uZWN0KHRoaXMuYXVkaW9ub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb3NvdXJjZV9ub2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX21lZGlhX3N0cmVhbSkge1xyXG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fbWVkaWFfc3RyZWFtLmdldFRyYWNrcygpO1xyXG4gICAgICAgICAgICBpZiAodHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tzWzBdLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vcGVuU3RyZWFtID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgXCJnZXRVc2VyTWVkaWEoKSBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlciwgdXNlIGNocm9tZSBhbmQgZW5hYmxlIFdlYlJUQyBmcm9tIGFib3V0Oi8vZmxhZ3NcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbiA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIE5vdCBzaG93aW5nIHZlbmRvciBwcmVmaXhlcy5cclxuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXHJcbiAgICAgICAgICAgIC5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSwgdmlkZW86IGZhbHNlIH0pXHJcbiAgICAgICAgICAgIC50aGVuKHRoaXMuc3RyZWFtUmVhZHkuYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgLmNhdGNoKG9uRmFpbFNvSGFyZCk7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBmdW5jdGlvbiBvbkZhaWxTb0hhcmQoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWVkaWEgcmVqZWN0ZWRcIiwgZXJyKTtcclxuICAgICAgICAgICAgdGhhdC5fbWVkaWFfc3RyZWFtID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcInJlZFwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5zdHJlYW1SZWFkeSA9IGZ1bmN0aW9uKGxvY2FsTWVkaWFTdHJlYW0pIHtcclxuICAgICAgICB0aGlzLl9tZWRpYV9zdHJlYW0gPSBsb2NhbE1lZGlhU3RyZWFtO1xyXG4gICAgICAgIC8vdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy9pbml0IGNvbnRleHRcclxuICAgICAgICBpZiAodGhpcy5hdWRpb3NvdXJjZV9ub2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9zb3VyY2Vfbm9kZS5kaXNjb25uZWN0KHRoaXMuYXVkaW9ub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9zb3VyY2Vfbm9kZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoXHJcbiAgICAgICAgICAgIGxvY2FsTWVkaWFTdHJlYW1cclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYXVkaW9zb3VyY2Vfbm9kZS5ncmFwaG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYXVkaW9zb3VyY2Vfbm9kZS5jb25uZWN0KHRoaXMuYXVkaW9ub2RlKTtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJ3aGl0ZVwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tZWRpYV9zdHJlYW0gPT0gbnVsbCAmJiAhdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lm5hbWUgPT0gXCJnYWluXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW4gPSB2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJQbGF5XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT0gXCJTdG9wXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImdhaW5cIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL0hlbHBzIGNvbm5lY3QvZGlzY29ubmVjdCBBdWRpb05vZGVzIHdoZW4gbmV3IGNvbm5lY3Rpb25zIGFyZSBtYWRlIGluIHRoZSBub2RlXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uQ29ubmVjdGlvbnNDaGFuZ2UgPVxyXG4gICAgICAgIExHQXVkaW8ub25Db25uZWN0aW9uc0NoYW5nZTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wicGxheWJhY2tSYXRlXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJQbGF5XCIsIExpdGVHcmFwaC5BQ1RJT05dLFxyXG4gICAgICAgICAgICBbXCJTdG9wXCIsIExpdGVHcmFwaC5BQ1RJT05dXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnRpdGxlID0gXCJNZWRpYVNvdXJjZVwiO1xyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLmRlc2MgPSBcIlBsYXlzIG1pY3JvcGhvbmVcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vbWVkaWFfc291cmNlXCIsIExHQXVkaW9NZWRpYVNvdXJjZSk7XHJcblxyXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9BbmFseXNlcigpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGZmdFNpemU6IDIwNDgsXHJcbiAgICAgICAgICAgIG1pbkRlY2liZWxzOiAtMTAwLFxyXG4gICAgICAgICAgICBtYXhEZWNpYmVsczogLTEwLFxyXG4gICAgICAgICAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAuNVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBjb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ3JhcGhub2RlID0gdGhpcztcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5mZnRTaXplID0gdGhpcy5wcm9wZXJ0aWVzLmZmdFNpemU7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUubWluRGVjaWJlbHMgPSB0aGlzLnByb3BlcnRpZXMubWluRGVjaWJlbHM7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUubWF4RGVjaWJlbHMgPSB0aGlzLnByb3BlcnRpZXMubWF4RGVjaWJlbHM7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gdGhpcy5wcm9wZXJ0aWVzLnNtb290aGluZ1RpbWVDb25zdGFudDtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmcmVxc1wiLCBcImFycmF5XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwic2FtcGxlc1wiLCBcImFycmF5XCIpO1xyXG5cclxuICAgICAgICB0aGlzLl9mcmVxX2JpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGltZV9iaW4gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9BbmFseXNlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlW25hbWVdID0gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9BbmFseXNlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcclxuICAgICAgICAgICAgLy9zZW5kIEZGVFxyXG4gICAgICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gdGhpcy5hdWRpb25vZGUuZnJlcXVlbmN5QmluQ291bnQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZnJlcV9iaW4gfHwgdGhpcy5fZnJlcV9iaW4ubGVuZ3RoICE9IGJ1ZmZlckxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlcV9iaW4gPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdldEJ5dGVGcmVxdWVuY3lEYXRhKHRoaXMuX2ZyZXFfYmluKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2ZyZXFfYmluKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2VuZCBhbmFseXplclxyXG4gICAgICAgIGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDEpKSB7XHJcbiAgICAgICAgICAgIC8vc2VuZCBTYW1wbGVzXHJcbiAgICAgICAgICAgIHZhciBidWZmZXJMZW5ndGggPSB0aGlzLmF1ZGlvbm9kZS5mcmVxdWVuY3lCaW5Db3VudDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90aW1lX2JpbiB8fCB0aGlzLl90aW1lX2Jpbi5sZW5ndGggIT0gYnVmZmVyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lX2JpbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKHRoaXMuX3RpbWVfYmluKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3RpbWVfYmluKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJvcGVydGllc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW2lucHV0Lm5hbWVdLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aW1lIGRvbWFpblxyXG4gICAgICAgIC8vdGhpcy5hdWRpb25vZGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSggZGF0YUFycmF5ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9BbmFseXNlci5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJtaW5EZWNpYmVsc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wibWF4RGVjaWJlbHNcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInNtb290aGluZ1RpbWVDb25zdGFudFwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9BbmFseXNlci5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJmcmVxc1wiLCBcImFycmF5XCJdLCBbXCJzYW1wbGVzXCIsIFwiYXJyYXlcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQW5hbHlzZXIudGl0bGUgPSBcIkFuYWx5c2VyXCI7XHJcbiAgICBMR0F1ZGlvQW5hbHlzZXIuZGVzYyA9IFwiQXVkaW8gQW5hbHlzZXJcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vYW5hbHlzZXJcIiwgTEdBdWRpb0FuYWx5c2VyKTtcclxuXHJcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0dhaW4oKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBnYWluOiAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZ2FpblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9HYWluLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzIHx8ICF0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbaW5wdXQubmFtZV0udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb0dhaW4pO1xyXG5cclxuICAgIExHQXVkaW9HYWluLnRpdGxlID0gXCJHYWluXCI7XHJcbiAgICBMR0F1ZGlvR2Fpbi5kZXNjID0gXCJBdWRpbyBnYWluXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2dhaW5cIiwgTEdBdWRpb0dhaW4pO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9Db252b2x2ZXIoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBpbXB1bHNlX3NyYzogXCJcIixcclxuICAgICAgICAgICAgbm9ybWFsaXplOiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUNvbnZvbHZlcigpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9Db252b2x2ZXIpO1xyXG5cclxuICAgIExHQXVkaW9Db252b2x2ZXIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRfdXJsKSB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fZHJvcHBlZF91cmwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0NvbnZvbHZlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiaW1wdWxzZV9zcmNcIikge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRJbXB1bHNlKHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJub3JtYWxpemVcIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5ub3JtYWxpemUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Db252b2x2ZXIucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRfdXJsKSB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fZHJvcHBlZF91cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kcm9wcGVkX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmltcHVsc2Vfc3JjID0gdGhpcy5fZHJvcHBlZF91cmw7XHJcbiAgICAgICAgdGhpcy5sb2FkSW1wdWxzZSh0aGlzLl9kcm9wcGVkX3VybCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Db252b2x2ZXIucHJvdG90eXBlLmxvYWRJbXB1bHNlID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAvL2tpbGwgcHJldmlvdXMgbG9hZFxyXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9pbXB1bHNlX2J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ19pbXB1bHNlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbG9hZCBuZXcgc2FtcGxlXHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IExHQXVkaW8ubG9hZFNvdW5kKHVybCwgaW5uZXIpO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdfaW1wdWxzZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIERlY29kZSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGF0Ll9pbXB1bHNlX2J1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhhdC5hdWRpb25vZGUuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkltcHVsc2Ugc2lnbmFsIHNldFwiKTtcclxuICAgICAgICAgICAgdGhhdC5fbG9hZGluZ19pbXB1bHNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQ29udm9sdmVyLnRpdGxlID0gXCJDb252b2x2ZXJcIjtcclxuICAgIExHQXVkaW9Db252b2x2ZXIuZGVzYyA9IFwiQ29udm9sdmVzIHRoZSBzaWduYWwgKHVzZWQgZm9yIHJldmVyYilcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vY29udm9sdmVyXCIsIExHQXVkaW9Db252b2x2ZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3IoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IC01MCxcclxuICAgICAgICAgICAga25lZTogNDAsXHJcbiAgICAgICAgICAgIHJhdGlvOiAxMixcclxuICAgICAgICAgICAgcmVkdWN0aW9uOiAtMjAsXHJcbiAgICAgICAgICAgIGF0dGFjazogMCxcclxuICAgICAgICAgICAgcmVsZWFzZTogMC4yNVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yKTtcclxuXHJcbiAgICBMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzIHx8ICF0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtpbnB1dC5uYW1lXS52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3IucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1widGhyZXNob2xkXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJrbmVlXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJyYXRpb1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmVkdWN0aW9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJhdHRhY2tcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJlbGVhc2VcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yLnRpdGxlID0gXCJEeW5hbWljc0NvbXByZXNzb3JcIjtcclxuICAgIExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3IuZGVzYyA9IFwiRHluYW1pY3MgQ29tcHJlc3NvclwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXHJcbiAgICAgICAgXCJhdWRpby9keW5hbWljc0NvbXByZXNzb3JcIixcclxuICAgICAgICBMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yXHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9XYXZlU2hhcGVyKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlV2F2ZVNoYXBlcigpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzaGFwZVwiLCBcIndhdmVzaGFwZVwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9XYXZlU2hhcGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzIHx8ICF0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5jdXJ2ZSA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9XYXZlU2hhcGVyLnByb3RvdHlwZS5zZXRXYXZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmN1cnZlID0gc2hhcGU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvV2F2ZVNoYXBlcik7XHJcblxyXG4gICAgLyogZGlzYWJsZWQgdGlsbCBJIGRvbnQgZmluZCBhIHdheSB0byBkbyBhIHdhdmUgc2hhcGVcclxuTEdBdWRpb1dhdmVTaGFwZXIudGl0bGUgPSBcIldhdmVTaGFwZXJcIjtcclxuTEdBdWRpb1dhdmVTaGFwZXIuZGVzYyA9IFwiRGlzdG9ydGlvbiB1c2luZyB3YXZlIHNoYXBlXCI7XHJcbkxpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vd2F2ZVNoYXBlclwiLCBMR0F1ZGlvV2F2ZVNoYXBlcik7XHJcbiovXHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb01peGVyKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZ2FpbjE6IDAuNSxcclxuICAgICAgICAgICAgZ2FpbjI6IDAuNVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlMSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlMS5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW4xO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlMiA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlMi5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW4yO1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZTEuY29ubmVjdCh0aGlzLmF1ZGlvbm9kZSk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUyLmNvbm5lY3QodGhpcy5hdWRpb25vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW4xXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluMSBnYWluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbjJcIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW4yIGdhaW5cIiwgXCJudW1iZXJcIik7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb01peGVyLnByb3RvdHlwZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdCA9IGZ1bmN0aW9uKHNsb3QpIHtcclxuICAgICAgICBpZiAoc2xvdCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1ZGlvbm9kZTE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzbG90ID09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9ub2RlMjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NaXhlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiZ2FpbjFcIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZTEuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImdhaW4yXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUyLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NaXhlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsIHx8IGlucHV0LnR5cGUgPT0gXCJhdWRpb1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlMS5nYWluLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09IDMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlMi5nYWluLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9NaXhlcik7XHJcblxyXG4gICAgTEdBdWRpb01peGVyLnRpdGxlID0gXCJNaXhlclwiO1xyXG4gICAgTEdBdWRpb01peGVyLmRlc2MgPSBcIkF1ZGlvIG1peGVyXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL21peGVyXCIsIExHQXVkaW9NaXhlcik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0FEU1IoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBBOiAwLjEsXHJcbiAgICAgICAgICAgIEQ6IDAuMSxcclxuICAgICAgICAgICAgUzogMC4xLFxyXG4gICAgICAgICAgICBSOiAwLjFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJnYXRlXCIsIFwiYm9vbFwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuZ2F0ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9BRFNSLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICB2YXIgbm93ID0gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5hdWRpb25vZGU7XHJcbiAgICAgICAgdmFyIGdhaW4gPSBub2RlLmdhaW47XHJcbiAgICAgICAgdmFyIGN1cnJlbnRfZ2F0ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cclxuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiQVwiKTtcclxuICAgICAgICB2YXIgRCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiRFwiKTtcclxuICAgICAgICB2YXIgUyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiU1wiKTtcclxuICAgICAgICB2YXIgUiA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiUlwiKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdhdGUgJiYgY3VycmVudF9nYXRlKSB7XHJcbiAgICAgICAgICAgIGdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xyXG4gICAgICAgICAgICBnYWluLnNldFZhbHVlQXRUaW1lKDAsIG5vdyk7XHJcbiAgICAgICAgICAgIGdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgbm93ICsgQSk7XHJcbiAgICAgICAgICAgIGdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoUywgbm93ICsgQSArIEQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5nYXRlICYmICFjdXJyZW50X2dhdGUpIHtcclxuICAgICAgICAgICAgZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XHJcbiAgICAgICAgICAgIGdhaW4uc2V0VmFsdWVBdFRpbWUoZ2Fpbi52YWx1ZSwgbm93KTtcclxuICAgICAgICAgICAgZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBub3cgKyBSKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2F0ZSA9IGN1cnJlbnRfZ2F0ZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0FEU1IucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wiQVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiRFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiU1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiUlwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvQURTUik7XHJcblxyXG4gICAgTEdBdWRpb0FEU1IudGl0bGUgPSBcIkFEU1JcIjtcclxuICAgIExHQXVkaW9BRFNSLmRlc2MgPSBcIkF1ZGlvIGVudmVsb3BlXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2Fkc3JcIiwgTEdBdWRpb0FEU1IpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9EZWxheSgpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGRlbGF5VGltZTogMC41XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZURlbGF5KDEwKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5kZWxheVRpbWUudmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZGVsYXlUaW1lO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ0aW1lXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9EZWxheSk7XHJcblxyXG4gICAgTEdBdWRpb0RlbGF5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZGVsYXlUaW1lLnZhbHVlID0gdjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9EZWxheS50aXRsZSA9IFwiRGVsYXlcIjtcclxuICAgIExHQXVkaW9EZWxheS5kZXNjID0gXCJBdWRpbyBkZWxheVwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9kZWxheVwiLCBMR0F1ZGlvRGVsYXkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9CaXF1YWRGaWx0ZXIoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBmcmVxdWVuY3k6IDM1MCxcclxuICAgICAgICAgICAgZGV0dW5lOiAwLFxyXG4gICAgICAgICAgICBROiAxXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidHlwZVwiLCBcImxvd3Bhc3NcIiwgXCJlbnVtXCIsIHtcclxuICAgICAgICAgICAgdmFsdWVzOiBbXHJcbiAgICAgICAgICAgICAgICBcImxvd3Bhc3NcIixcclxuICAgICAgICAgICAgICAgIFwiaGlnaHBhc3NcIixcclxuICAgICAgICAgICAgICAgIFwiYmFuZHBhc3NcIixcclxuICAgICAgICAgICAgICAgIFwibG93c2hlbGZcIixcclxuICAgICAgICAgICAgICAgIFwiaGlnaHNoZWxmXCIsXHJcbiAgICAgICAgICAgICAgICBcInBlYWtpbmdcIixcclxuICAgICAgICAgICAgICAgIFwibm90Y2hcIixcclxuICAgICAgICAgICAgICAgIFwiYWxscGFzc1wiXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgbm9kZVxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcclxuXHJcbiAgICAgICAgLy9zbG90c1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb0JpcXVhZEZpbHRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW2lucHV0Lm5hbWVdLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0JpcXVhZEZpbHRlci5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImZyZXF1ZW5jeVwiLCBcIm51bWJlclwiXSwgW1wiZGV0dW5lXCIsIFwibnVtYmVyXCJdLCBbXCJRXCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9CaXF1YWRGaWx0ZXIpO1xyXG5cclxuICAgIExHQXVkaW9CaXF1YWRGaWx0ZXIudGl0bGUgPSBcIkJpcXVhZEZpbHRlclwiO1xyXG4gICAgTEdBdWRpb0JpcXVhZEZpbHRlci5kZXNjID0gXCJBdWRpbyBmaWx0ZXJcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vYmlxdWFkZmlsdGVyXCIsIExHQXVkaW9CaXF1YWRGaWx0ZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9Pc2NpbGxhdG9yTm9kZSgpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGZyZXF1ZW5jeTogNDQwLFxyXG4gICAgICAgICAgICBkZXR1bmU6IDAsXHJcbiAgICAgICAgICAgIHR5cGU6IFwic2luZVwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidHlwZVwiLCBcInNpbmVcIiwgXCJlbnVtXCIsIHtcclxuICAgICAgICAgICAgdmFsdWVzOiBbXCJzaW5lXCIsIFwic3F1YXJlXCIsIFwic2F3dG9vdGhcIiwgXCJ0cmlhbmdsZVwiLCBcImN1c3RvbVwiXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBub2RlXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuXHJcbiAgICAgICAgLy9zbG90c1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1ZGlvbm9kZS5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuc3RhcnQoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5hdWRpb25vZGUuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMub25TdG9wKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUub25VbnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5vblN0YXJ0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW2lucHV0Lm5hbWVdLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcImZyZXF1ZW5jeVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiZGV0dW5lXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ0eXBlXCIsIFwic3RyaW5nXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9Pc2NpbGxhdG9yTm9kZSk7XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnRpdGxlID0gXCJPc2NpbGxhdG9yXCI7XHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUuZGVzYyA9IFwiT3NjaWxsYXRvclwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9vc2NpbGxhdG9yXCIsIExHQXVkaW9Pc2NpbGxhdG9yTm9kZSk7XHJcblxyXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgIC8vRVhUUkFcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvVmlzdWFsaXphdGlvbigpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVvdXM6IHRydWUsXHJcbiAgICAgICAgICAgIG1hcms6IC0xXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImRhdGFcIiwgXCJhcnJheVwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwibWFya1wiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbMzAwLCAyMDBdO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfYnVmZmVyID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvVmlzdWFsaXphdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdF9idWZmZXIgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1hcmsgPSB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1Zpc3VhbGl6YXRpb24ucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2xhc3RfYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl9sYXN0X2J1ZmZlcjtcclxuXHJcbiAgICAgICAgLy9kZWx0YSByZXByZXNlbnRzIGhvdyBtYW55IHNhbXBsZXMgd2UgYWR2YW5jZSBwZXIgcGl4ZWxcclxuICAgICAgICB2YXIgZGVsdGEgPSBidWZmZXIubGVuZ3RoIC8gdGhpcy5zaXplWzBdO1xyXG4gICAgICAgIHZhciBoID0gdGhpcy5zaXplWzFdO1xyXG5cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB2YXIgeCA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY29udGludW91cykge1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgaCAtIChidWZmZXJbaSB8IDBdIC8gMjU1KSAqIGgpO1xyXG4gICAgICAgICAgICAgICAgeCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IGRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyAwLjUsIGgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMC41LCBoIC0gKGJ1ZmZlcltpIHwgMF0gLyAyNTUpICogaCk7XHJcbiAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmsgPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlcmF0ZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuc2FtcGxlUmF0ZTtcclxuICAgICAgICAgICAgdmFyIGJpbmZyZXEgPSBzYW1wbGVyYXRlIC8gYnVmZmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHggPSAoMiAqICh0aGlzLnByb3BlcnRpZXMubWFyayAvIGJpbmZyZXEpKSAvIGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAoeCA+PSB0aGlzLnNpemVbMF0pIHtcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLnNpemVbMF0gLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCBoKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCAwKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1Zpc3VhbGl6YXRpb24udGl0bGUgPSBcIlZpc3VhbGl6YXRpb25cIjtcclxuICAgIExHQXVkaW9WaXN1YWxpemF0aW9uLmRlc2MgPSBcIkF1ZGlvIFZpc3VhbGl6YXRpb25cIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vdmlzdWFsaXphdGlvblwiLCBMR0F1ZGlvVmlzdWFsaXphdGlvbik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0JhbmRTaWduYWwoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBiYW5kOiA0NDAsXHJcbiAgICAgICAgICAgIGFtcGxpdHVkZTogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJmcmVxc1wiLCBcImFycmF5XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwic2lnbmFsXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9CYW5kU2lnbmFsLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9mcmVxcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICghdGhpcy5fZnJlcXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJhbmQgPSB0aGlzLnByb3BlcnRpZXMuYmFuZDtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmFuZCA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2FtcGxlcmF0ZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuc2FtcGxlUmF0ZTtcclxuICAgICAgICB2YXIgYmluZnJlcSA9IHNhbXBsZXJhdGUgLyB0aGlzLl9mcmVxcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMiAqIChiYW5kIC8gYmluZnJlcSk7XHJcbiAgICAgICAgdmFyIHYgPSAwO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdiA9IHRoaXMuX2ZyZXFzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fZnJlcXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHYgPSB0aGlzLl9mcmVxc1t0aGlzLl9mcmVxcy5sZW5ndGggLSAxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gaW5kZXggfCAwO1xyXG4gICAgICAgICAgICB2YXIgdjAgPSB0aGlzLl9mcmVxc1twb3NdO1xyXG4gICAgICAgICAgICB2YXIgdjEgPSB0aGlzLl9mcmVxc1twb3MgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGYgPSBpbmRleCAtIHBvcztcclxuICAgICAgICAgICAgdiA9IHYwICogKDEgLSBmKSArIHYxICogZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCAodiAvIDI1NSkgKiB0aGlzLnByb3BlcnRpZXMuYW1wbGl0dWRlKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0JhbmRTaWduYWwucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJiYW5kXCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0JhbmRTaWduYWwudGl0bGUgPSBcIlNpZ25hbFwiO1xyXG4gICAgTEdBdWRpb0JhbmRTaWduYWwuZGVzYyA9IFwiZXh0cmFjdCB0aGUgc2lnbmFsIG9mIHNvbWUgZnJlcXVlbmN5XCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL3NpZ25hbFwiLCBMR0F1ZGlvQmFuZFNpZ25hbCk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb1NjcmlwdCgpIHtcclxuICAgICAgICBpZiAoIUxHQXVkaW9TY3JpcHQuZGVmYXVsdF9jb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gTEdBdWRpb1NjcmlwdC5kZWZhdWx0X2Z1bmN0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvZGUuaW5kZXhPZihcIntcIikgKyAxO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gY29kZS5sYXN0SW5kZXhPZihcIn1cIik7XHJcbiAgICAgICAgICAgIExHQXVkaW9TY3JpcHQuZGVmYXVsdF9jb2RlID0gY29kZS5zdWJzdHIoaW5kZXgsIGluZGV4MiAtIGluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgY29kZTogTEdBdWRpb1NjcmlwdC5kZWZhdWx0X2NvZGVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBub2RlXHJcbiAgICAgICAgdmFyIGN0eCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgaWYgKGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBjdHguY3JlYXRlU2NyaXB0UHJvY2Vzc29yKDQwOTYsIDEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2J1ZmZlciBzaXplLCBpbnB1dCBjaGFubmVscywgb3V0cHV0IGNoYW5uZWxzXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNjcmlwdFByb2Nlc3Nvck5vZGUgZGVwcmVjYXRlZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBjdHguY3JlYXRlR2FpbigpOyAvL2J5cGFzcyBhdWRpb1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29kZSgpO1xyXG4gICAgICAgIGlmICghTEdBdWRpb1NjcmlwdC5fYnlwYXNzX2Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIExHQXVkaW9TY3JpcHQuX2J5cGFzc19mdW5jdGlvbiA9IHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zbG90c1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25BZGRlZCA9IGZ1bmN0aW9uKGdyYXBoKSB7XHJcbiAgICAgICAgaWYgKGdyYXBoLnN0YXR1cyA9PSBMR3JhcGguU1RBVFVTX1JVTk5JTkcpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSB0aGlzLl9jYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHRbXCJAY29kZVwiXSA9IHsgd2lkZ2V0OiBcImNvZGVcIiwgdHlwZTogXCJjb2RlXCIgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSB0aGlzLl9jYWxsYmFjaztcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSBMR0F1ZGlvU2NyaXB0Ll9ieXBhc3NfZnVuY3Rpb247XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uUGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IExHQXVkaW9TY3JpcHQuX2J5cGFzc19mdW5jdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25VbnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSB0aGlzLl9jYWxsYmFjaztcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9ub3RoaW5nISBiZWNhdXNlIHdlIG5lZWQgYW4gb25FeGVjdXRlIHRvIHJlY2VpdmUgb25TdGFydC4uLiBmaXggdGhhdFxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vblJlbW92ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IExHQXVkaW9TY3JpcHQuX2J5cGFzc19mdW5jdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUucHJvY2Vzc0NvZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IG5ldyBGdW5jdGlvbihcInByb3BlcnRpZXNcIiwgdGhpcy5wcm9wZXJ0aWVzLmNvZGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JpcHQgPSBuZXcgZnVuYyh0aGlzLnByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9vbGRfY29kZSA9IHRoaXMucHJvcGVydGllcy5jb2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX3NjcmlwdC5vbmF1ZGlvcHJvY2VzcztcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIG9uYXVkaW9wcm9jZXNzIGNvZGVcIiwgZXJyKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBMR0F1ZGlvU2NyaXB0Ll9ieXBhc3NfZnVuY3Rpb247XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5fY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjb2RlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNvZGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29kZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLnN0YXR1cyA9PSBMR3JhcGguU1RBVFVTX1JVTk5JTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5fY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQuZGVmYXVsdF9mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbihhdWRpb1Byb2Nlc3NpbmdFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBzb25nIHdlIGxvYWRlZCBlYXJsaWVyXHJcbiAgICAgICAgICAgIHZhciBpbnB1dEJ1ZmZlciA9IGF1ZGlvUHJvY2Vzc2luZ0V2ZW50LmlucHV0QnVmZmVyO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG91dHB1dCBidWZmZXIgY29udGFpbnMgdGhlIHNhbXBsZXMgdGhhdCB3aWxsIGJlIG1vZGlmaWVkIGFuZCBwbGF5ZWRcclxuICAgICAgICAgICAgdmFyIG91dHB1dEJ1ZmZlciA9IGF1ZGlvUHJvY2Vzc2luZ0V2ZW50Lm91dHB1dEJ1ZmZlcjtcclxuXHJcbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgb3V0cHV0IGNoYW5uZWxzIChpbiB0aGlzIGNhc2UgdGhlcmUgaXMgb25seSBvbmUpXHJcbiAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsIDwgb3V0cHV0QnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsKytcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXREYXRhID0gaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0RGF0YSA9IG91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIDQwOTYgc2FtcGxlc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2FtcGxlID0gMDsgc2FtcGxlIDwgaW5wdXRCdWZmZXIubGVuZ3RoOyBzYW1wbGUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugb3V0cHV0IGVxdWFsIHRvIHRoZSBzYW1lIGFzIHRoZSBpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dERhdGFbc2FtcGxlXSA9IGlucHV0RGF0YVtzYW1wbGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9TY3JpcHQpO1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQudGl0bGUgPSBcIlNjcmlwdFwiO1xyXG4gICAgTEdBdWRpb1NjcmlwdC5kZXNjID0gXCJhcHBseSBzY3JpcHQgdG8gc2lnbmFsXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL3NjcmlwdFwiLCBMR0F1ZGlvU2NyaXB0KTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvRGVzdGluYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmRlc3RpbmF0aW9uO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9EZXN0aW5hdGlvbi50aXRsZSA9IFwiRGVzdGluYXRpb25cIjtcclxuICAgIExHQXVkaW9EZXN0aW5hdGlvbi5kZXNjID0gXCJBdWRpbyBvdXRwdXRcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vZGVzdGluYXRpb25cIiwgTEdBdWRpb0Rlc3RpbmF0aW9uKTtcclxufSkodGhpcyk7XHJcblxuLy9ldmVudCByZWxhdGVkIG5vZGVzXHJcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHV2ViU29ja2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2MCwgMjBdO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzZW5kXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicmVjZWl2ZWRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICB1cmw6IFwiXCIsXHJcbiAgICAgICAgICAgIHJvb206IFwibGdyYXBoXCIsIC8vYWxsb3dzIHRvIGZpbHRlciBtZXNzYWdlcyxcclxuICAgICAgICAgICAgb25seV9zZW5kX2NoYW5nZXM6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3dzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sYXN0X3NlbnRfZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfcmVjZWl2ZWRfZGF0YSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIExHV2ViU29ja2V0LnRpdGxlID0gXCJXZWJTb2NrZXRcIjtcclxuICAgIExHV2ViU29ja2V0LmRlc2MgPSBcIlNlbmQgZGF0YSB0aHJvdWdoIGEgd2Vic29ja2V0XCI7XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInVybFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFNvY2tldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fd3MgJiYgdGhpcy5wcm9wZXJ0aWVzLnVybCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RTb2NrZXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fd3MgfHwgdGhpcy5fd3MucmVhZHlTdGF0ZSAhPSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcm9vbSA9IHRoaXMucHJvcGVydGllcy5yb29tO1xyXG4gICAgICAgIHZhciBvbmx5X2NoYW5nZXMgPSB0aGlzLnByb3BlcnRpZXMub25seV9zZW5kX2NoYW5nZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGpzb247XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vbTogcm9vbSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbmx5X2NoYW5nZXMgJiYgdGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gPT0ganNvbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldID0ganNvbjtcclxuICAgICAgICAgICAgdGhpcy5fd3Muc2VuZChqc29uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCB0aGlzLl9sYXN0X3JlY2VpdmVkX2RhdGFbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYm94Y29sb3IgPT0gXCIjQUZBXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiIzZDNlwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLmNvbm5lY3RTb2NrZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucHJvcGVydGllcy51cmw7XHJcbiAgICAgICAgaWYgKHVybC5zdWJzdHIoMCwgMikgIT0gXCJ3c1wiKSB7XHJcbiAgICAgICAgICAgIHVybCA9IFwid3M6Ly9cIiArIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XHJcbiAgICAgICAgdGhpcy5fd3Mub25vcGVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVhZHlcIik7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiM2QzZcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3dzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0FGQVwiO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEucm9vbSAmJiBkYXRhLnJvb20gIT0gdGhhdC5wcm9wZXJ0aWVzLnJvb20pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGEub2JqZWN0X2NsYXNzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoW2RhdGEuZGF0YS5vYmplY3RfY2xhc3NdXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgTGl0ZUdyYXBoW2RhdGEuZGF0YS5vYmplY3RfY2xhc3NdKGRhdGEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlclNsb3QoMCwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyU2xvdCgwLCBkYXRhLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fbGFzdF9yZWNlaXZlZF9kYXRhW2RhdGEuY2hhbm5lbCB8fCAwXSA9IGRhdGEuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fd3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb3VsZG50IGNvbm5lY3QgdG8gd2Vic29ja2V0XCIpO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjRTg4XCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl93cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3Rpb24gY2xvc2VkXCIpO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjMDAwXCI7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93cyB8fCB0aGlzLl93cy5yZWFkeVN0YXRlICE9IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6IDEsIG1zZzogZGF0YSB9KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3dzIHx8IHRoaXMuX3dzLnJlYWR5U3RhdGUgIT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cy5zZW5kKHtcclxuICAgICAgICAgICAgdHlwZTogMSxcclxuICAgICAgICAgICAgcm9vbTogdGhpcy5wcm9wZXJ0aWVzLnJvb20sXHJcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxyXG4gICAgICAgICAgICBkYXRhOiBwYXJhbVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImluXCIsIDBdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wib3V0XCIsIDBdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJuZXR3b3JrL3dlYnNvY2tldFwiLCBMR1dlYlNvY2tldCk7XHJcblxyXG4gICAgLy9JdCBpcyBsaWtlIGEgd2Vic29ja2V0IGJ1dCB1c2luZyB0aGUgU2lsbHlTZXJ2ZXIuanMgc2VydmVyIHRoYXQgYm91bmNlcyBwYWNrZXRzIGJhY2sgdG8gYWxsIGNsaWVudHMgY29ubmVjdGVkOlxyXG4gICAgLy9Gb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2phZ2Vuam8vU2lsbHlTZXJ2ZXIuanNcclxuXHJcbiAgICBmdW5jdGlvbiBMR1NpbGx5Q2xpZW50KCkge1xyXG4gICAgICAgIC8vdGhpcy5zaXplID0gWzYwLDIwXTtcclxuICAgICAgICB0aGlzLnJvb21fd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXHJcbiAgICAgICAgICAgIFwidGV4dFwiLFxyXG4gICAgICAgICAgICBcIlJvb21cIixcclxuICAgICAgICAgICAgXCJsZ3JhcGhcIixcclxuICAgICAgICAgICAgdGhpcy5zZXRSb29tLmJpbmQodGhpcylcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KFxyXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxyXG4gICAgICAgICAgICBcIlJlY29ubmVjdFwiLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RTb2NrZXQuYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzZW5kXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicmVjZWl2ZWRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICB1cmw6IFwidGFtYXRzLmNvbTo1NTAwMFwiLFxyXG4gICAgICAgICAgICByb29tOiBcImxncmFwaFwiLFxyXG4gICAgICAgICAgICBvbmx5X3NlbmRfY2hhbmdlczogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX3NlcnZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0U29ja2V0KCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdF9zZW50X2RhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLl9sYXN0X3JlY2VpdmVkX2RhdGEgPSBbXTtcclxuXHJcblx0XHRpZih0eXBlb2YoU2lsbHlDbGllbnQpID09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRcdGNvbnNvbGUud2FybihcInJlbWVtYmVyIHRvIGFkZCBTaWxseUNsaWVudC5qcyB0byB5b3VyIHByb2plY3Q6IGh0dHBzOi8vdGFtYXRzLmNvbS9wcm9qZWN0cy9zaWxseXNlcnZlci9zcmMvc2lsbHljbGllbnQuanNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC50aXRsZSA9IFwiU2lsbHlDbGllbnRcIjtcclxuICAgIExHU2lsbHlDbGllbnQuZGVzYyA9IFwiQ29ubmVjdHMgdG8gU2lsbHlTZXJ2ZXIgdG8gYnJvYWRjYXN0IG1lc3NhZ2VzXCI7XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwicm9vbVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vbV93aWRnZXQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0U29ja2V0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLnNldFJvb20gPSBmdW5jdGlvbihyb29tX25hbWUpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMucm9vbSA9IHJvb21fbmFtZTtcclxuICAgICAgICB0aGlzLnJvb21fd2lkZ2V0LnZhbHVlID0gcm9vbV9uYW1lO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFNvY2tldCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL2ZvcmNlIGxhYmVsIG5hbWVzXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICBzbG90LmxhYmVsID0gXCJpbl9cIiArIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICBzbG90LmxhYmVsID0gXCJvdXRfXCIgKyBpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zZXJ2ZXIgfHwgIXRoaXMuX3NlcnZlci5pc19jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9ubHlfc2VuZF9jaGFuZ2VzID0gdGhpcy5wcm9wZXJ0aWVzLm9ubHlfc2VuZF9jaGFuZ2VzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcblx0XHRcdHZhciBwcmV2X2RhdGEgPSB0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXTtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ubHlfc2VuZF9jaGFuZ2VzKVxyXG5cdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0dmFyIGlzX2VxdWFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmKCBkYXRhICYmIGRhdGEubGVuZ3RoICYmIHByZXZfZGF0YSAmJiBwcmV2X2RhdGEubGVuZ3RoID09IGRhdGEubGVuZ3RoICYmIGRhdGEuY29uc3RydWN0b3IgIT09IFN0cmluZylcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyArK2opXHJcblx0XHRcdFx0XHRcdFx0aWYoIHByZXZfZGF0YVtqXSAhPSBkYXRhW2pdIClcclxuXHRcdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0XHRpc19lcXVhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZih0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSAhPSBkYXRhKVxyXG5cdFx0XHRcdFx0XHRpc19lcXVhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0aWYoaXNfZXF1YWwpXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXIuc2VuZE1lc3NhZ2UoeyB0eXBlOiAwLCBjaGFubmVsOiBpLCBkYXRhOiBkYXRhIH0pO1xyXG5cdFx0XHRcdGlmKCBkYXRhLmxlbmd0aCAmJiBkYXRhLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGlmKCB0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSApXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7ICsrailcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXVtqXSA9IGRhdGFbal07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIC8vY3JlYXRlXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGlmKGRhdGEuY29uc3RydWN0b3IgPT09IEFycmF5KVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldID0gZGF0YS5jb25jYXQoKTtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldID0gbmV3IGRhdGEuY29uc3RydWN0b3IoIGRhdGEgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSA9IGRhdGE7IC8vc2hvdWxkIGJlIGNsb25lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fbGFzdF9yZWNlaXZlZF9kYXRhW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmJveGNvbG9yID09IFwiI0FGQVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiM2QzZcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLmNvbm5lY3RTb2NrZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBTaWxseUNsaWVudCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJTaWxseUNsaWVudCBub2RlIGNhbm5vdCBiZSB1c2VkLCB5b3UgbXVzdCBpbmNsdWRlIFNpbGx5U2VydmVyLmpzXCJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXIgPSBuZXcgU2lsbHlDbGllbnQoKTtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXIub25fcmVhZHkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWFkeVwiKTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiIzZDNlwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fc2VydmVyLm9uX21lc3NhZ2UgPSBmdW5jdGlvbihpZCwgbXNnKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG1zZyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vRVZFTlQgc2xvdFxyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YS5vYmplY3RfY2xhc3MgJiZcclxuICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGhbZGF0YS5kYXRhLm9iamVjdF9jbGFzc11cclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBMaXRlR3JhcGhbZGF0YS5kYXRhLm9iamVjdF9jbGFzc10oZGF0YS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyU2xvdCgwLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJTbG90KDAsIGRhdGEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gLy9mb3IgRkxPVyBzbG90c1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2xhc3RfcmVjZWl2ZWRfZGF0YVtkYXRhLmNoYW5uZWwgfHwgMF0gPSBkYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0FGQVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fc2VydmVyLm9uX2Vycm9yID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvdWxkbnQgY29ubmVjdCB0byB3ZWJzb2NrZXRcIik7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiNFODhcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3NlcnZlci5vbl9jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0aW9uIGNsb3NlZFwiKTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiIzAwMFwiO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMudXJsICYmIHRoaXMucHJvcGVydGllcy5yb29tKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXIuY29ubmVjdCh0aGlzLnByb3BlcnRpZXMudXJsLCB0aGlzLnByb3BlcnRpZXMucm9vbSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNpbGx5U2VydmVyIGVycm9yOiBcIiArIGVycik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsX3VybCA9IHRoaXMucHJvcGVydGllcy51cmwgKyBcIi9cIiArIHRoaXMucHJvcGVydGllcy5yb29tO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3NlcnZlciB8fCAhdGhpcy5fc2VydmVyLmlzX2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NlcnZlci5zZW5kTWVzc2FnZSh7IHR5cGU6IDEsIGRhdGE6IGRhdGEgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2VydmVyIHx8ICF0aGlzLl9zZXJ2ZXIuaXNfY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2VydmVyLnNlbmRNZXNzYWdlKHsgdHlwZTogMSwgYWN0aW9uOiBhY3Rpb24sIGRhdGE6IHBhcmFtIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiaW5cIiwgMF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcIm91dFwiLCAwXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibmV0d29yay9zaWxseWNsaWVudFwiLCBMR1NpbGx5Q2xpZW50KTtcclxufSkodGhpcyk7XHJcblxuIiwiaW1wb3J0IHsgU3BsaW5lIH0gZnJvbSBcImRlZXBzbGF0ZVwiO1xuaW1wb3J0IHsgTGl0ZUdyYXBoLCBMR3JhcGgsIExHcmFwaENhbnZhcywgTEdyYXBoTm9kZSwgSUNvbnRleHRNZW51T3B0aW9ucyB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IENvbnN0YW50RGVuc2l0eUZ1bmN0aW9uIH0gZnJvbSBcIi4uL25vZGVzL2NvbnN0YW50X2RlbnNpdHlfZnVuY3Rpb25cIjtcbmltcG9ydCB7IERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuLi9ub2Rlcy9kZW5zaXR5X2Z1bmN0aW9uXCI7XG5pbXBvcnQgeyBEZW5zaXR5RnVuY3Rpb25PdXRwdXQgfSBmcm9tIFwiLi4vbm9kZXMvZGVuc2l0eV9mdW5jdGlvbl9vdXRwdXRcIjtcbmltcG9ydCB7IFNwbGluZURlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuLi9ub2Rlcy9kZW5zaXR5X2Z1bmN0aW9uX3NwbGluZVwiO1xuaW1wb3J0IHsgTmFtZWREZW5zaXR5RnVuY3Rpb24gfSBmcm9tIFwiLi4vbm9kZXMvbmFtZWRfZGVuc2l0eV9mdW5jdGlvblwiO1xuaW1wb3J0IHsgcmVnaXN0ZXJOb2RlcyB9IGZyb20gXCIuLi9ub2Rlcy9yZWdpc3RlclwiO1xuaW1wb3J0IHsgTWVudU1hbmFnZXIgfSBmcm9tIFwiLi9NZW51TWFuYWdlclwiO1xuXG5leHBvcnQgY2xhc3MgR3JhcGhNYW5hZ2VyIHtcbiAgICBzdGF0aWMgb3V0cHV0X25vZGU6IExHcmFwaE5vZGVcbiAgICBzdGF0aWMgZ3JhcGg6IExHcmFwaFxuICAgIHN0YXRpYyBjYW52YXM6IExHcmFwaENhbnZhc1xuXG4gICAgc3RhdGljIG5hbWVkX25vZGVzOiB7IFtrZXk6IHN0cmluZ106IE5hbWVkRGVuc2l0eUZ1bmN0aW9uIH1cblxuICAgIHN0YXRpYyBpbml0KCkge1xuICAgICAgICBMaXRlR3JhcGguY2xlYXJSZWdpc3RlcmVkVHlwZXMoKSAvLyBkb24ndCB1c2UgZGVmYXVsdCBub2RlIHR5cGVzXG4gICAgICAgIHJlZ2lzdGVyTm9kZXMoKVxuXG4gICAgICAgIHRoaXMuZ3JhcGggPSBuZXcgTEdyYXBoKCk7XG5cbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgTEdyYXBoQ2FudmFzKFwiI215Y2FudmFzXCIsIHRoaXMuZ3JhcGgpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hdXRvcmVzaXplID0gdHJ1ZVxuICAgICAgICB0aGlzLmNhbnZhcy5jYW52YXMub25yZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5kaXJ0eV9jYW52YXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMub25EcmF3TGlua1Rvb2x0aXAgPSAoY3R4LCBsaW5rLCBjYW52YXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5vblNob3dOb2RlUGFuZWwgPSAobikgPT4geyB9XG5cbiAgICAgICAgdGhpcy5vdXRwdXRfbm9kZSA9IG5ldyBEZW5zaXR5RnVuY3Rpb25PdXRwdXQoKTsgLy8gbm90IHJlZ2lzdGVyZWQgYXMgb25seSBvbmUgZXhpc3RzXG4gICAgICAgIHRoaXMub3V0cHV0X25vZGUucG9zID0gWzkwMCwgNDAwXTtcbiAgICAgICAgdGhpcy5ncmFwaC5hZGQodGhpcy5vdXRwdXRfbm9kZSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaC5zdGFydCgpXG5cblxuICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSAoZXY6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICgoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSAmJiBldi5rZXkgPT09IFwic1wiKSB7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIE1lbnVNYW5hZ2VyLnNhdmUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5wcm9jZXNzS2V5KGV2KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmdyYXBoLmNsZWFyKClcbiAgICAgICAgdGhpcy5uYW1lZF9ub2RlcyA9IHt9XG5cbiAgICAgICAgdGhpcy5vdXRwdXRfbm9kZSA9IG5ldyBEZW5zaXR5RnVuY3Rpb25PdXRwdXQoKTsgLy8gbm90IHJlZ2lzdGVyZWQgYXMgb25seSBvbmUgZXhpc3RzXG4gICAgICAgIHRoaXMub3V0cHV0X25vZGUucG9zID0gWzkwMCwgNDAwXTtcbiAgICAgICAgdGhpcy5ncmFwaC5hZGQodGhpcy5vdXRwdXRfbm9kZSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaC5ydW5TdGVwKClcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0T3V0cHV0KCk6IGFueSB7XG4gICAgICAgIHRoaXMuZ3JhcGgucnVuU3RlcCgpXG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dF9ub2RlLmdldElucHV0RGF0YUJ5TmFtZShcInJlc3VsdFwiKSA/PyB7anNvbjp7fSwgZXJyb3I6IHRydWV9XG4gICAgfVxuXG4gICAgc3RhdGljIGxvYWRKU09OKGpzb246IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoanNvbi5ub2lzZV9yb3V0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG1lbnVfaW5mbzogYW55ID0gW11cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzb24ubm9pc2Vfcm91dGVyKS5mb3JFYWNoKChlbGVtZW50KSA9PiBtZW51X2luZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRKU09OKGpzb24ubm9pc2Vfcm91dGVyW2VsZW1lbnRdKVxuICAgICAgICAgICAgICAgICAgICBNZW51TWFuYWdlci5maWxlTmFtZSA9IGVsZW1lbnQgKyBcIi5qc29uXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHRvcDogMjAwLCBsZWZ0OiAyMDAgfVxuICAgICAgICAgICAgY29uc3QgZSA9IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSAoKSA9PiB7IH1cbiAgICAgICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShtZW51X2luZm8sIG9wdGlvbnMgYXMgSUNvbnRleHRNZW51T3B0aW9ucywgdGhpcy5jYW52YXMuZ2V0Q2FudmFzV2luZG93KCkpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciA9IGVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5jbGVhcigpXG4gICAgICAgICAgICB0aGlzLm5hbWVkX25vZGVzID0ge31cblxuICAgICAgICAgICAgdGhpcy5vdXRwdXRfbm9kZSA9IG5ldyBEZW5zaXR5RnVuY3Rpb25PdXRwdXQoKTsgLy8gbm90IHJlZ2lzdGVyZWQgYXMgb25seSBvbmUgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZCh0aGlzLm91dHB1dF9ub2RlKTtcblxuICAgICAgICAgICAgY29uc3QgW24sIHldID0gdGhpcy5jcmVhdGVOb2RlRnJvbUpzb24oanNvbiwgWzkwMCAtIDI1MCwgNDAwXSlcblxuICAgICAgICAgICAgbi5jb25uZWN0KDAsIHRoaXMub3V0cHV0X25vZGUsIDApXG4gICAgICAgICAgICB0aGlzLm91dHB1dF9ub2RlLnBvcyA9IFs5MDAsIHkgLyAyXTtcblxuICAgICAgICAgICAgdGhpcy5ncmFwaC5ydW5TdGVwKClcbiAgICAgICAgICAgIE1lbnVNYW5hZ2VyLnNldEVkaXRlZChmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVOb2RlRnJvbUpzb24oanNvbjogYW55LCBwb3M6IFtudW1iZXIsIG51bWJlcl0pOiBbTEdyYXBoTm9kZSwgbnVtYmVyXSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGpzb24gaW4gdGhpcy5uYW1lZF9ub2RlcyAmJiB0aGlzLm5hbWVkX25vZGVzW2pzb25dLnBvc1swXSA8PSBwb3NbMF0gKyA0MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMubmFtZWRfbm9kZXNbanNvbl0sIHBvc1sxXV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwiZGVuc2l0eV9mdW5jdGlvbi9uYW1lZFwiKTtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuaWQgPSBqc29uXG4gICAgICAgICAgICAgICAgICAgIDsgKG5vZGUgYXMgTmFtZWREZW5zaXR5RnVuY3Rpb24pLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICAgICAgICAgIG5vZGUucG9zID0gcG9zO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuY29sbGFwc2UoZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lZF9ub2Rlc1tqc29uXSA9IChub2RlIGFzIE5hbWVkRGVuc2l0eUZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBbbm9kZSwgcG9zWzFdICsgMTUwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBqc29uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJkZW5zaXR5X2Z1bmN0aW9uL2NvbnN0YW50XCIpO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnZhbHVlID0ganNvblxuICAgICAgICAgICAgICAgIDsgKG5vZGUgYXMgQ29uc3RhbnREZW5zaXR5RnVuY3Rpb24pLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICAgICAgbm9kZS5wb3MgPSBwb3M7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUuY29sbGFwc2UoZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gW25vZGUsIHBvc1sxXSArIDE1MF1cbiAgICAgICAgfSBlbHNlIGlmIChqc29uLnR5cGUgPT09IFwibWluZWNyYWZ0OnNwbGluZVwiKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHBvc1sxXVxuXG4gICAgICAgICAgICBjb25zdCBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJkZW5zaXR5X2Z1bmN0aW9uL3NwbGluZVwiKSBhcyBTcGxpbmVEZW5zaXR5RnVuY3Rpb25cblxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLm1pbl92YWx1ZSA9IGpzb24ubWluX3ZhbHVlXG4gICAgICAgICAgICBub2RlLnByb3BlcnRpZXMubWF4X3ZhbHVlID0ganNvbi5tYXhfdmFsdWVcblxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25zID0gW11cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdXG4gICAgICAgICAgICBjb25zdCBkZXJpdmF0aXZlcyA9IFtdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGpzb24uc3BsaW5lLnBvaW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQudmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJNdWx0aWRpbWVuaW9uYWwgU3BsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCAoeWV0KVwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11bHRpZGltZW5pb25hbCBTcGxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkICh5ZXQpXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5wdXNoKHBvaW50LmxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCgpID0+IHBvaW50LnZhbHVlKVxuICAgICAgICAgICAgICAgIGRlcml2YXRpdmVzLnB1c2gocG9pbnQuZGVyaXZhdGl2ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5zcGxpbmVXaWRnZXQudmFsdWUgPSBuZXcgU3BsaW5lPG51bWJlcj4oXCJzcGluZVwiLCAoYykgPT4gYywgbG9jYXRpb25zLCB2YWx1ZXMsIGRlcml2YXRpdmVzKTtcbiAgICAgICAgICAgIG5vZGUuc3BsaW5lV2lkZ2V0Lm1pbl9pbnB1dCA9IGxvY2F0aW9uc1swXSAtIDAuMVxuICAgICAgICAgICAgbm9kZS5zcGxpbmVXaWRnZXQubWF4X2lucHV0ID0gbG9jYXRpb25zW2xvY2F0aW9ucy5sZW5ndGggLSAxXSArIDAuMVxuXG4gICAgICAgICAgICBub2RlLnVwZGF0ZVdpZGdldHMoKVxuXG4gICAgICAgICAgICB2YXIgbjogTEdyYXBoTm9kZVxuICAgICAgICAgICAgW24sIHldID0gdGhpcy5jcmVhdGVOb2RlRnJvbUpzb24oanNvbi5zcGxpbmUuY29vcmRpbmF0ZSwgW3Bvc1swXSAtIDI1MCwgeV0pXG4gICAgICAgICAgICBuLmNvbm5lY3QoMCwgbm9kZSwgXCJjb29yZGluYXRlXCIpXG4gICAgICAgICAgICBub2RlLnBvcyA9IFtwb3NbMF0sIChwb3NbMV0gKyB5IC0gMTUwKSAvIDJdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gW25vZGUsIHldXG4gICAgICAgIH0gZWxzZSBpZiAoanNvbi50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJkZW5zaXR5X2Z1bmN0aW9uL1wiICsgKGpzb24udHlwZS5yZXBsYWNlKFwibWluZWNyYWZ0OlwiLCBcIlwiKSkpIGFzIERlbnNpdHlGdW5jdGlvblxuICAgICAgICAgICAgdmFyIHkgPSBwb3NbMV1cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPSBqc29uW3Byb3BlcnR5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWlzc2luZyBwcm9wZXJ0eSBcIiArIHByb3BlcnR5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlV2lkZ2V0cygpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5wdXRfbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBub2RlLmlucHV0X25hbWVzW2ldXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uW2lucHV0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjogTEdyYXBoTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgW24sIHldID0gdGhpcy5jcmVhdGVOb2RlRnJvbUpzb24oanNvbltpbnB1dF0sIFtwb3NbMF0gLSAyNTAsIHldKVxuICAgICAgICAgICAgICAgICAgICAgICAgbi5jb25uZWN0KDAsIG5vZGUsIGlucHV0KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWlzc2luZyBkZW5zaXR5IGZ1bmN0aW9uIFwiICsgaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnBvcyA9IFtwb3NbMF0sIChwb3NbMV0gKyB5IC0gMTUwKSAvIDJdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gW25vZGUsIHldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgbG9hZCBkZW5zaXR5IGZ1bmN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkoanNvbikpXG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgR3JhcGhNYW5hZ2VyIH0gZnJvbSBcIi4vR3JhcGhNYW5hZ2VyXCJcblxuZXhwb3J0IGNsYXNzIE1lbnVNYW5hZ2VyIHtcblxuICAgIHN0YXRpYyBmaWxlSGFuZGxlOiBGaWxlU3lzdGVtRmlsZUhhbmRsZVxuICAgIHN0YXRpYyBmaWxlTmFtZTogc3RyaW5nID0gXCJkZW5zaXR5X2Z1bmN0aW9uLmpzb25cIlxuXG4gICAgc3RhdGljIGVkaXRlZDogYm9vbGVhbiA9IGZhbHNlXG4gICAgc3RhdGljIHNhdmVfYnV0dG9uOiBIVE1MRWxlbWVudFxuXG4gICAgc3RhdGljIGFkZEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLnNhdmVfYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1zYXZlXCIpXG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1uZXdcIikub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRlZCAmJiAhY29uZmlybShcIllvdSBoYXZlIHVuc2F2ZWQgY2hhbmdlcywgY29udGludWU/XCIpKXtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdyYXBoTWFuYWdlci5jbGVhcigpXG4gICAgICAgICAgICB0aGlzLmZpbGVIYW5kbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImRlbnNpdHlfZnVuY3Rpb24uanNvblwiXG4gICAgICAgICAgICB0aGlzLnNhdmVfYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKVxuICAgICAgICAgICAgdGhpcy5lZGl0ZWQgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1vcGVuXCIpLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0ZWQgJiYgIWNvbmZpcm0oXCJZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMsIGNvbnRpbnVlP1wiKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJzaG93T3BlbkZpbGVQaWNrZXJcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICBbdGhpcy5maWxlSGFuZGxlXSA9IGF3YWl0IHdpbmRvdy5zaG93T3BlbkZpbGVQaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkFsbCBKU09OIGZpbGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiBbXCIuanNvblwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5maWxlSGFuZGxlLmdldEZpbGUoKVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBhd2FpdCBmaWxlLnRleHQoKVxuICAgICAgICAgICAgICAgIGlmIChHcmFwaE1hbmFnZXIubG9hZEpTT04oSlNPTi5wYXJzZShqc29uU3RyaW5nKSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlSGFuZGxlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZGlzYWJsZWRcIilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVIYW5kbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwiZGVuc2l0eV9mdW5jdGlvbi5qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlX2J1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9ICdmaWxlJ1xuICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdCA9ICcuanNvbidcblxuICAgICAgICAgICAgICAgIGlucHV0Lm9uY2hhbmdlID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuZmlsZXNbMF1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlLCAnVVRGLTgnKVxuXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZXZ0OiBQcm9ncmVzc0V2ZW50PEZpbGVSZWFkZXI+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gZXZ0LnRhcmdldC5yZXN1bHQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVIYW5kbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChHcmFwaE1hbmFnZXIubG9hZEpTT04oSlNPTi5wYXJzZShqc29uU3RyaW5nKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwiZGVuc2l0eV9mdW5jdGlvbi5qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0LmNsaWNrKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1zYXZlLWFzXCIpLm9uY2xpY2sgPSBhc3luYyAoKSA9PntcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZUFzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2F2ZV9idXR0b24ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZSgpXG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRKc29uU3RyaW5nKCl7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEdyYXBoTWFuYWdlci5nZXRPdXRwdXQoKVxuICAgICAgICBpZiAob3V0cHV0LmVycm9yICYmICFjb25maXJtKFwiU29tZSBub2RlcyBoYXZlIHVuY29ubmVjdGVkIGlucHV0cywgdGhlIHJlc3VsdGluZyBKU09OIHdpbGwgYmUgaW52YWxpZC4gQ29udGludWU/XCIpKXtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvdXRwdXQuanNvbiwgbnVsbCwgMilcbiAgICAgICAgICAgIHJldHVybiBqc29uU3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgc2F2ZSgpe1xuICAgICAgICBpZiAodGhpcy5maWxlSGFuZGxlKXtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSB0aGlzLmdldEpzb25TdHJpbmcoKVxuICAgICAgICAgICAgaWYgKGpzb25TdHJpbmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBhd2FpdCB0aGlzLmZpbGVIYW5kbGUuY3JlYXRlV3JpdGFibGUoKVxuICAgICAgICAgICAgYXdhaXQgd3JpdGFibGUud3JpdGUoanNvblN0cmluZylcbiAgICAgICAgICAgIGF3YWl0IHdyaXRhYmxlLmNsb3NlKClcbiAgICAgICAgICAgIHRoaXMuZWRpdGVkID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUFzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBzYXZlQXMoKXtcbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IHRoaXMuZ2V0SnNvblN0cmluZygpXG4gICAgICAgIGlmIChqc29uU3RyaW5nID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgaWYgKFwic2hvd1NhdmVGaWxlUGlja2VyXCIgaW4gd2luZG93KXtcbiAgICAgICAgICAgIHRoaXMuZmlsZUhhbmRsZSA9IGF3YWl0IHdpbmRvdy5zaG93U2F2ZUZpbGVQaWNrZXIoXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkFsbCBKU09OIGZpbGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjogW1wiLmpzb25cIl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sIHN1Z2dlc3RlZE5hbWU6IHRoaXMuZmlsZU5hbWVcbiAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IHRoaXMuZmlsZUhhbmRsZS5uYW1lXG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZSA9IGF3YWl0IHRoaXMuZmlsZUhhbmRsZS5jcmVhdGVXcml0YWJsZSgpXG4gICAgICAgICAgICBhd2FpdCB3cml0YWJsZS53cml0ZShqc29uU3RyaW5nKVxuICAgICAgICAgICAgYXdhaXQgd3JpdGFibGUuY2xvc2UoKVxuXG4gICAgICAgICAgICB0aGlzLmVkaXRlZCA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLnNhdmVfYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkaXNhYmxlZFwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmIgPSBuZXcgQmxvYihbanNvblN0cmluZ10sIHt0eXBlOiAndGV4dC9wbGFpbid9KVxuICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICAgICAgYS5kb3dubG9hZCA9IHRoaXMuZmlsZU5hbWVcbiAgICAgICAgICAgIGEuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJiKVxuICAgICAgICAgICAgYS5jbGljaygpXG4gICAgICAgICAgICB0aGlzLmVkaXRlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0RWRpdGVkKGZvcmNlOiBib29sZWFuID0gdHJ1ZSl7XG4gICAgICAgIHRoaXMuZWRpdGVkID0gZm9yY2VcbiAgICB9XG59IiwiaW1wb3J0IHsgSUNvbnRleHRNZW51SXRlbSwgTEdyYXBoQ2FudmFzLCBMR3JhcGhOb2RlIH0gZnJvbSBcImxpdGVncmFwaC5qc1wiO1xuaW1wb3J0IHsgTWVudU1hbmFnZXIgfSBmcm9tIFwiLi4vVUkvTWVudU1hbmFnZXJcIjtcblxuXG5leHBvcnQgY2xhc3MgTEdyYXBoTm9kZUZpeGVkIGV4dGVuZHMgTEdyYXBoTm9kZXtcbiAgICBvblByb3BlcnR5Q2hhbmdlZCgpIHtcbiAgICAgICAgTWVudU1hbmFnZXIuc2V0RWRpdGVkKClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgb25Db25uZWN0aW9uc0NoYW5nZSgpe1xuICAgICAgICBNZW51TWFuYWdlci5zZXRFZGl0ZWQoKVxuICAgIH1cblxuICAgIG9uQWRkZWQoKXtcbiAgICAgICAgTWVudU1hbmFnZXIuc2V0RWRpdGVkKClcbiAgICB9XG5cbiAgICBvblJlbW92ZWQoKXtcbiAgICAgICAgTWVudU1hbmFnZXIuc2V0RWRpdGVkKClcbiAgICB9XG5cbiAgICBnZXRNZW51T3B0aW9ucyhvbkV4ZWN1dGU6IExHcmFwaENhbnZhcyk6IElDb250ZXh0TWVudUl0ZW1bXXtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgdXBkYXRlV2lkZ2V0cygpOiB2b2lkIHt9XG59IiwiaW1wb3J0IHsgSUNvbnRleHRNZW51SXRlbSwgSVdpZGdldCwgTEdyYXBoQ2FudmFzLCBMR3JhcGhOb2RlLCBMaXRlR3JhcGggfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5pbXBvcnQgeyBNZW51TWFuYWdlciB9IGZyb20gXCIuLi9VSS9NZW51TWFuYWdlclwiO1xuaW1wb3J0IHsgTEdyYXBoTm9kZUZpeGVkIH0gZnJvbSBcIi4vTEdyYXBoTm9kZUZpeGVkXCI7XG5cbmV4cG9ydCBjbGFzcyBDb25zdGFudERlbnNpdHlGdW5jdGlvbiBleHRlbmRzIExHcmFwaE5vZGVGaXhlZHtcbiAgICBzdGF0aWMgdGl0bGUgPSBcImNvbnN0YW50XCJcblxuICAgIHByaXZhdGUgd2RndDogSVdpZGdldFxuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmFkZE91dHB1dChcIm91dHB1dFwiLFwiZGVuc2l0eUZ1bmN0aW9uXCIsIHtsb2NrZWQ6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIDAsIFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMud2RndCA9IHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsIFwiVmFsdWVcIiwgMCwgKHZhbHVlKSA9PiB7dGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gdmFsdWV9KVxuICAgICAgICB0aGlzLnRpdGxlID0gXCJDb25zdGFudFwiXG4gICAgICAgIHRoaXMuY29sb3IgPSBcIiMwMDAwMzNcIlxuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVXaWRnZXRzKCkge1xuICAgICAgICB0aGlzLndkZ3QudmFsdWUgPSB0aGlzLnByb3BlcnRpZXMudmFsdWVcbiAgICB9XG5cbiAgICBnZXRUaXRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG5cbiAgICBvbkV4ZWN1dGUoKXtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHtcbiAgICAgICAgICAgIGpzb246dGhpcy5wcm9wZXJ0aWVzLnZhbHVlLFxuICAgICAgICAgICAgZXJyb3I6ZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IElDb250ZXh0TWVudUl0ZW0sIElOb2RlSW5wdXRTbG90LCBJV2lkZ2V0LCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIExpdGVHcmFwaCB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IE1lbnVNYW5hZ2VyIH0gZnJvbSBcIi4uL1VJL01lbnVNYW5hZ2VyXCI7XG5pbXBvcnQgeyBMR3JhcGhOb2RlRml4ZWQgfSBmcm9tIFwiLi9MR3JhcGhOb2RlRml4ZWRcIjtcblxuY29uc3Qgc3BsaW5lX3ZhbHVlcyA9IFtcIm9mZnNldFwiLCBcImZhY3RvclwiLCBcImphZ2dlZG5lc3NcIl1cbmNvbnN0IHNhbXBsZXJfdHlwZXMgPSBbXCJ0eXBlXzFcIiwgXCJ0eXBlXzJcIl1cblxuZXhwb3J0IGNsYXNzIERlbnNpdHlGdW5jdGlvbiBleHRlbmRzIExHcmFwaE5vZGVGaXhlZHtcblxuICAgIFxuXG4gICAgcHVibGljIGlucHV0X25hbWVzOiBzdHJpbmdbXVxuICAgIHByaXZhdGUgd2Rnczoge1trZXk6IHN0cmluZ106IElXaWRnZXR9ID0ge31cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbmFtZTogc3RyaW5nLCBhcmdzOiBNYXA8c3RyaW5nLCBzdHJpbmc+KXtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIHRoaXMuaW5wdXRfbmFtZXMgPSBbXVxuXG4gICAgICAgIGFyZ3MuZm9yRWFjaCgodHlwZSwgYXJndW1lbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImRlbnNpdHlGdW5jdGlvblwiKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZElucHV0KGFyZ3VtZW50LCBcImRlbnNpdHlGdW5jdGlvblwiLCB7bGFiZWw6IGFyZ3VtZW50LCBsb2NrZWQ6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRfbmFtZXMucHVzaChhcmd1bWVudClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvcGVydHkoYXJndW1lbnQsIDAsIFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhpcy53ZGdzW2FyZ3VtZW50XSA9IHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsIGFyZ3VtZW50LCAwLCAodmFsdWUpID0+IHt0aGlzLnByb3BlcnRpZXNbYXJndW1lbnRdID0gdmFsdWV9KVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInNwbGluZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShhcmd1bWVudCwgMCwgXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aGlzLndkZ3NbYXJndW1lbnRdID0gdGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLCBhcmd1bWVudCwgXCJvZmZzZXRcIiwgKHZhbHVlKSA9PiB7dGhpcy5wcm9wZXJ0aWVzW2FyZ3VtZW50XSA9IHZhbHVlfSwge3ZhbHVlczogc3BsaW5lX3ZhbHVlc30pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9pc2VcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvcGVydHkoYXJndW1lbnQsIDAsIFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy53ZGdzW2FyZ3VtZW50XSA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLCBhcmd1bWVudCwgXCJtaW5lY3JhZnQ6XCIsICh2YWx1ZSkgPT4ge3RoaXMucHJvcGVydGllc1thcmd1bWVudF0gPSB2YWx1ZX0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2FtcGxlcl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFByb3BlcnR5KGFyZ3VtZW50LCAwLCBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMud2Rnc1thcmd1bWVudF0gPSB0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsIGFyZ3VtZW50LCBcInR5cGVfMVwiLCAodmFsdWUpID0+IHt0aGlzLnByb3BlcnRpZXNbYXJndW1lbnRdID0gdmFsdWV9LCB7dmFsdWVzOiBzYW1wbGVyX3R5cGVzfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dHB1dFwiLFwiZGVuc2l0eUZ1bmN0aW9uXCIsIHtsb2NrZWQ6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy50aXRsZSA9IG5hbWUucmVwbGFjZShcIm1pbmVjcmFmdDpcIiwgXCJcIilcbiAgICAgICAgdGhpcy5jb2xvciA9IHRoaXMuaW5wdXRzLmxlbmd0aCA+IDAgPyBcIiMzMzAwMDBcIiA6IFwiIzAwMDAzM1wiXG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVdpZGdldHMoKXtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiB0aGlzLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgdGhpcy53ZGdzW3Byb3BlcnR5XS52YWx1ZSA9IHRoaXMucHJvcGVydGllc1twcm9wZXJ0eV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ29ubmVjdGlvbnNDaGFuZ2UoKXtcbiAgICAgICAgdGhpcy5jb2xvciA9IHRoaXMuaW5wdXRzLmZpbHRlcihpID0+ICFpLmxpbmspLmxlbmd0aCA+IDAgPyBcIiMzMzAwMDBcIiA6IFwiIzAwMDAzM1wiXG4gICAgfVxuXG4gICAgb25FeGVjdXRlKCl7XG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSgpXG4gICAgICAgIGNvbnN0IGlucHV0czogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZVxuICAgICAgICB2YXIgaW5wdXRfaGFzX2Vycm9yID0gZmFsc2VcbiAgICAgICAgdGhpcy5pbnB1dF9uYW1lcy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0SW5wdXREYXRhQnlOYW1lKGlucHV0KVxuICAgICAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0c1tpbnB1dF0gPSBpLmpzb25cbiAgICAgICAgICAgICAgICBpbnB1dF9oYXNfZXJyb3IgfHw9IGkuZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwge1xuICAgICAgICAgICAganNvbjoge3R5cGU6IHRoaXMubmFtZSwgLi4udGhpcy5wcm9wZXJ0aWVzLCAuLi5pbnB1dHN9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIHx8IGlucHV0X2hhc19lcnJvclxuICAgICAgICB9KVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgSUNvbnRleHRNZW51SXRlbSwgSU5vZGVJbnB1dFNsb3QsIExHcmFwaENhbnZhcywgTEdyYXBoTm9kZSwgTGl0ZUdyYXBoIH0gZnJvbSBcImxpdGVncmFwaC5qc1wiO1xuXG5leHBvcnQgY2xhc3MgRGVuc2l0eUZ1bmN0aW9uT3V0cHV0IGV4dGVuZHMgTEdyYXBoTm9kZXtcbiAgICBzdGF0aWMgdGl0bGUgPSBcIk91dHB1dFwiXG4gICAgcmVtb3ZhYmxlOiBib29sZWFuO1xuICAgIGNsb25hYmxlOiBib29sZWFuO1xuICAgIC8vc3RhdGljIHJlbW92YWJsZSA9IGZhbHNlXG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMudGl0bGUgPSBcIk91dHB1dFwiXG4gICAgICAgIHRoaXMuY29sb3IgPSBcIiMzMzAwMDBcIlxuICAgICAgICB0aGlzLmFkZElucHV0KFwicmVzdWx0XCIsIFwiZGVuc2l0eUZ1bmN0aW9uXCIsIHtsYWJlbDogXCJyZXN1bHRcIiwgbG9ja2VkOiB0cnVlLCBuYW1lTG9ja2VkOiB0cnVlfSlcbiAgICAgICAgdGhpcy5yZW1vdmFibGUgPSBmYWxzZVxuICAgICAgICB0aGlzLmNsb25hYmxlID0gZmFsc2VcbiAgICB9XG5cblxuICAgIG9uQ29ubmVjdGlvbnNDaGFuZ2UoKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJ0ZXN0XCIpXG4gICAgICAgIHRoaXMuY29sb3IgPSAhdGhpcy5pbnB1dHNbMF0ubGluayA/IFwiIzMzMDAwMFwiIDogXCIjMDAwMDMzXCJcbiAgICB9XG5cbiAgICBvbkV4ZWN1dGUoKXtcbiAgICB9XG5cbiAgICBnZXRNZW51T3B0aW9ucyhvbkV4ZWN1dGU6IExHcmFwaENhbnZhcyk6IElDb250ZXh0TWVudUl0ZW1bXXtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBJQ29udGV4dE1lbnVJdGVtLCBJTm9kZUlucHV0U2xvdCwgSVdpZGdldCwgTEdyYXBoQ2FudmFzLCBMR3JhcGhOb2RlLCBMaXRlR3JhcGggfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5pbXBvcnQgeyBNZW51TWFuYWdlciB9IGZyb20gXCIuLi9VSS9NZW51TWFuYWdlclwiO1xuaW1wb3J0IHsgU3BsaW5lV2lkZ2V0IH0gZnJvbSBcIi4uL3dpZGdldHMvU3BsaW5lV2lkZ2V0XCI7XG5pbXBvcnQgeyBMR3JhcGhOb2RlRml4ZWQgfSBmcm9tIFwiLi9MR3JhcGhOb2RlRml4ZWRcIjtcblxuY29uc3Qgc3BsaW5lX3ZhbHVlcyA9IFtcIm9mZnNldFwiLCBcImZhY3RvclwiLCBcImphZ2dlZG5lc3NcIl1cbmNvbnN0IHNhbXBsZXJfdHlwZXMgPSBbXCJ0eXBlXzFcIiwgXCJ0eXBlXzJcIl1cblxuZXhwb3J0IGNsYXNzIFNwbGluZURlbnNpdHlGdW5jdGlvbiBleHRlbmRzIExHcmFwaE5vZGVGaXhlZHtcblxuICAgIHN0YXRpYyB0aXRsZSA9IFwic3BsaW5lXCJcbiAgICBcblxuICAgIHByaXZhdGUgd2Rnczoge1trZXk6IHN0cmluZ106IElXaWRnZXR9ID0ge31cbiAgICBwdWJsaWMgc3BsaW5lV2lkZ2V0OiBTcGxpbmVXaWRnZXRcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICB0aGlzLmFkZElucHV0KFwiY29vcmRpbmF0ZVwiLCBcImRlbnNpdHlGdW5jdGlvblwiLCB7bGFiZWw6IFwiY29vcmRpbmF0ZVwiLCBsb2NrZWQ6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KVxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dHB1dFwiLCBcImRlbnNpdHlGdW5jdGlvblwiLCB7bG9ja2VkOiB0cnVlLCBuYW1lTG9ja2VkOiB0cnVlfSk7XG4gICAgICAgIHRoaXMuc3BsaW5lV2lkZ2V0ID0gdGhpcy5hZGRDdXN0b21XaWRnZXQ8U3BsaW5lV2lkZ2V0PihuZXcgU3BsaW5lV2lkZ2V0KCkpXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtaW5fdmFsdWVcIiwgLTEsIFwibnVtYmVyXCIpXG4gICAgICAgIHRoaXMud2Rncy5taW5fdmFsdWUgPSB0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLCBcIm1pbl92YWx1ZVwiLCAtMSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIHRoaXMuc3BsaW5lV2lkZ2V0Lm1pbl92YWx1ZSA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtYXhfdmFsdWVcIiwgMSwgXCJudW1iZXJcIilcbiAgICAgICAgdGhpcy53ZGdzLm1heF92YWx1ZSA9IHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsIFwibWF4X3ZhbHVlXCIsIDEsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICB0aGlzLnNwbGluZVdpZGdldC5tYXhfdmFsdWUgPSB2YWx1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMudGl0bGUgPSBcInNwbGluZVwiXG4gICAgICAgIHRoaXMuY29sb3IgPSBcIiMzMzAwMDBcIlxuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVXaWRnZXRzKCl7XG4gICAgICAgIHRoaXMud2Rncy5taW5fdmFsdWUudmFsdWUgPSB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlXG4gICAgICAgIHRoaXMud2Rncy5tYXhfdmFsdWUudmFsdWUgPSB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXG4gICAgICAgIHRoaXMuc3BsaW5lV2lkZ2V0Lm1pbl92YWx1ZSA9IHRoaXMucHJvcGVydGllcy5taW5fdmFsdWVcbiAgICAgICAgdGhpcy5zcGxpbmVXaWRnZXQubWF4X3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZVxuICAgIH1cblxuICAgIG9uQ29ubmVjdGlvbnNDaGFuZ2UoKXtcbiAgICAgICAgdGhpcy5jb2xvciA9ICF0aGlzLmlucHV0c1swXS5saW5rID8gXCIjMzMwMDAwXCIgOiBcIiMwMDAwMzNcIlxuICAgIH1cblxuICAgIG9uRXhlY3V0ZSgpe1xuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHRoaXMuc3BsaW5lV2lkZ2V0LnZhbHVlLmxvY2F0aW9ucy5sZW5ndGggOyBpKyspe1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnNwbGluZVdpZGdldC52YWx1ZS5sb2NhdGlvbnNbaV0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3BsaW5lV2lkZ2V0LnZhbHVlLnZhbHVlc1tpXSgwKSxcbiAgICAgICAgICAgICAgICBkZXJpdmF0aXZlOiB0aGlzLnNwbGluZVdpZGdldC52YWx1ZS5kZXJpdmF0aXZlc1tpXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXRJbnB1dERhdGFCeU5hbWUoXCJjb29yZGluYXRlXCIpXG5cbiAgICAgICAgY29uc3QgZXJyb3IgPSAoaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBpbnB1dC5lcnJvcilcblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwge1xuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibWluZWNyYWZ0OnNwbGluZVwiLFxuICAgICAgICAgICAgICAgIG1pbl92YWx1ZTogdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSxcbiAgICAgICAgICAgICAgICBtYXhfdmFsdWU6IHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUsXG4gICAgICAgICAgICAgICAgc3BsaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGU6IGlucHV0Lmpzb24sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9KVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgSUNvbnRleHRNZW51SXRlbSwgSVdpZGdldCwgTEdyYXBoQ2FudmFzLCBMR3JhcGhOb2RlLCBMaXRlR3JhcGggfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5pbXBvcnQgeyBNZW51TWFuYWdlciB9IGZyb20gXCIuLi9VSS9NZW51TWFuYWdlclwiO1xuaW1wb3J0IHsgTEdyYXBoTm9kZUZpeGVkIH0gZnJvbSBcIi4vTEdyYXBoTm9kZUZpeGVkXCI7XG5cbmV4cG9ydCBjbGFzcyBOYW1lZERlbnNpdHlGdW5jdGlvbiBleHRlbmRzIExHcmFwaE5vZGVGaXhlZHtcbiAgICBzdGF0aWMgdGl0bGUgPSBcIk5hbWVkIERlbnNpdHkgRnVuY3Rpb25cIlxuXG4gICAgcHJpdmF0ZSB3ZGd0OiBJV2lkZ2V0XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0cHV0XCIsXCJkZW5zaXR5RnVuY3Rpb25cIiwge2xvY2tlZDogdHJ1ZSwgbmFtZUxvY2tlZDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiaWRcIiwgXCJcIiwgXCJzdHJpbmdcIilcbiAgICAgICAgdGhpcy53ZGd0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsIFwiSWRcIiwgXCJcIiwgKHZhbHVlKSA9PiB7dGhpcy5wcm9wZXJ0aWVzLmlkID0gdmFsdWV9KVxuICAgICAgICB0aGlzLnRpdGxlID0gXCJOYW1lZCBEZW5zaXR5IEZ1bmN0aW9uXCJcbiAgICAgICAgdGhpcy5jb2xvciA9IFwiIzAwMzMwMFwiXG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVdpZGdldHMoKSB7XG4gICAgICAgIHRoaXMud2RndC52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5pZFxuICAgIH1cblxuICAgIGdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIGlkOnN0cmluZyA9IHRoaXMucHJvcGVydGllcy5pZFxuICAgICAgICAgICAgaWYgKGlkLmxlbmd0aCA+IDIwKXtcbiAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cmluZyhpZC5sYXN0SW5kZXhPZihcIi9cIikrMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9O1xuXG4gICAgb25FeGVjdXRlKCl7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB7XG4gICAgICAgICAgICBqc29uOiB0aGlzLnByb3BlcnRpZXMuaWQsXG4gICAgICAgICAgICBlcnJvcjogZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IExpdGVHcmFwaCB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IHNjaGVtYXMgfSBmcm9tIFwiLi4vdmFuaWxsYS9zY2hlbWFzXCI7XG5pbXBvcnQgeyBDb25zdGFudERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL2NvbnN0YW50X2RlbnNpdHlfZnVuY3Rpb25cIjtcbmltcG9ydCB7IERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL2RlbnNpdHlfZnVuY3Rpb25cIjtcbmltcG9ydCB7IFNwbGluZURlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL2RlbnNpdHlfZnVuY3Rpb25fc3BsaW5lXCI7XG5pbXBvcnQgeyBOYW1lZERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL25hbWVkX2RlbnNpdHlfZnVuY3Rpb25cIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJOb2Rlcygpe1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZGVuc2l0eV9mdW5jdGlvbi9uYW1lZFwiLCBOYW1lZERlbnNpdHlGdW5jdGlvbiApO1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZGVuc2l0eV9mdW5jdGlvbi9jb25zdGFudFwiLCBDb25zdGFudERlbnNpdHlGdW5jdGlvbiApO1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZGVuc2l0eV9mdW5jdGlvbi9zcGxpbmVcIiwgU3BsaW5lRGVuc2l0eUZ1bmN0aW9uICk7XG5cbiAgICBzY2hlbWFzLmZvckVhY2goKHNjaGVtYSwgbikgPT4ge1xuICAgICAgICBjbGFzcyBmIGV4dGVuZHMgRGVuc2l0eUZ1bmN0aW9ue1xuICAgICAgICAgICAgc3RhdGljIHRpdGxlID0gbi5yZXBsYWNlKFwibWluZWNyYWZ0OlwiLCBcIlwiKVxuXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAgICAgICAgIHN1cGVyKG4sIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc2NoZW1hKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJkZW5zaXR5X2Z1bmN0aW9uL1wiICsgKG4ucmVwbGFjZShcIm1pbmVjcmFmdDpcIiwgXCJcIikpLCBmKVxuICAgIH0pXG5cblxuXG59IiwiZXhwb3J0IGNvbnN0IHNjaGVtYXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHtcbiAgICAnbWluZWNyYWZ0OmFicyc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmFkZCc6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmJlYXJkaWZpZXInOiB7fSxcbiAgICAnbWluZWNyYWZ0OmJsZW5kX2FscGhhJzoge30sXG4gICAgJ21pbmVjcmFmdDpibGVuZF9kZW5zaXR5Jzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6YmxlbmRfb2Zmc2V0Jzoge30sXG4gICAgJ21pbmVjcmFmdDpjYWNoZV8yZCc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmNhY2hlX2FsbF9pbl9jZWxsJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6Y2FjaGVfb25jZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmNsYW1wJzoge1xuICAgICAgICBpbnB1dDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgbWluOiBcIm51bWJlclwiLFxuICAgICAgICBtYXg6IFwibnVtYmVyXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmN1YmUnOiB7XG4gICAgICAgIGFyZ3VtZW50OiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgIH0sXG4gICAgXCJtaW5lY3JhZnQ6ZW5kX2lzbGFuZHNcIjoge30sXG4gICAgJ21pbmVjcmFmdDpmbGF0X2NhY2hlJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6aGFsZl9uZWdhdGl2ZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmludGVycG9sYXRlZCc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om1heCc6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om1pbic6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om11bCc6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om5vaXNlJzoge1xuICAgICAgICBub2lzZTogXCJub2lzZVwiLFxuICAgICAgICB4el9zY2FsZTogXCJudW1iZXJcIixcbiAgICAgICAgeV9zY2FsZTogXCJudW1iZXJcIixcbiAgICB9LFxuICAgIFwibWluZWNyYWZ0Om9sZF9ibGVuZGVkX25vaXNlXCI6IHt9LFxuICAgICdtaW5lY3JhZnQ6cXVhcnRlcl9uZWdhdGl2ZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnJhbmdlX2Nob2ljZSc6IHtcbiAgICAgICAgaW5wdXQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgICAgIG1pbl9pbmNsdXNpdmU6IFwibnVtYmVyXCIsXG4gICAgICAgIG1heF9leGNsdXNpdmU6IFwibnVtYmVyXCIsXG4gICAgICAgIHdoZW5faW5fcmFuZ2U6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgICAgIHdoZW5fb3V0X29mX3JhbmdlOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgIH0sXG4gICAgJ21pbmVjcmFmdDpzaGlmdCc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnNoaWZ0X2EnOiB7XG4gICAgICAgIGFyZ3VtZW50OiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgIH0sXG4gICAgJ21pbmVjcmFmdDpzaGlmdF9iJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6c2hpZnRlZF9ub2lzZSc6IHtcbiAgICAgICAgc2hpZnRfeDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgc2hpZnRfeTogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgc2hpZnRfejogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgbm9pc2U6IFwibm9pc2VcIixcbiAgICAgICAgeHpfc2NhbGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHlfc2NhbGU6IFwibnVtYmVyXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnNsaWRlJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6c3F1YXJlJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6c3F1ZWV6ZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnRlcnJhaW5fc2hhcGVyX3NwbGluZSc6IHtcbiAgICAgICAgc3BsaW5lOiBcInNwbGluZVwiLFxuICAgICAgICBtaW5fdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgIG1heF92YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgY29udGluZW50YWxuZXNzOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBlcm9zaW9uOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICB3ZWlyZG5lc3M6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OndlaXJkX3NjYWxlZF9zYW1wbGVyJzoge1xuICAgICAgICByYXJpdHlfdmFsdWVfbWFwcGVyOiBcInNhbXBsZXJfdHlwZVwiLFxuICAgICAgICBub2lzZTogXCJub2lzZVwiLFxuICAgICAgICBpbnB1dDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6eV9jbGFtcGVkX2dyYWRpZW50Jzoge1xuICAgICAgICBmcm9tX3k6IFwibnVtYmVyXCIsXG4gICAgICAgIHRvX3k6IFwibnVtYmVyXCIsXG4gICAgICAgIGZyb21fdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgIHRvX3ZhbHVlOiBcIm51bWJlclwiLFxuICAgIH1cbn0pKVxuXG5leHBvcnQgY29uc3Qgbm9pc2Vfcm91dGVyX2ZpZWxkcyA9IFtcbiAgICBcImZpbmFsX2RlbnNpdHlcIixcbiAgICBcInZlaW5fdG9nZ2xlXCIsXG4gICAgXCJ2ZWluX3JpZGdlZFwiLFxuICAgIFwidmVpbl9nYXBcIixcbiAgICBcImVyb3Npb25cIixcbiAgICBcImRlcHRoXCIsXG4gICAgXCJyaWRnZXNcIixcbiAgICBcImluaXRpYWxfZGVuc2l0eV93aXRob3V0X2phZ2dlZG5lc3NcIixcbiAgICBcImxhdmFcIixcbiAgICBcInRlbXBlcmF0dXJlXCIsXG4gICAgXCJ2ZWdldGF0aW9uXCIsXG4gICAgXCJjb250aW5lbnRzXCIsXG4gICAgXCJiYXJyaWVyXCIsXG4gICAgXCJmbHVpZF9sZXZlbF9mbG9vZGVkbmVzc1wiLFxuICAgIFwiZmx1aWRfbGV2ZWxfc3ByZWFkXCJcbl0iLCJcbmltcG9ydCB7IFNwbGluZSB9IGZyb20gJ2RlZXBzbGF0ZSc7XG5pbXBvcnQgeyBJV2lkZ2V0LCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIFZlY3RvcjIsIFdpZGdldENhbGxiYWNrLCB3aWRnZXRUeXBlcyB9IGZyb20gJ2xpdGVncmFwaC5qcydcblxuZXhwb3J0IGNsYXNzIFNwbGluZVdpZGdldCBpbXBsZW1lbnRzIElXaWRnZXQ8U3BsaW5lPG51bWJlcj4+e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZTogU3BsaW5lPG51bWJlcj4gPSBuZXcgU3BsaW5lPG51bWJlcj4oXCJzcGluZVwiLCAoYykgPT4gYywgWy0xLCAxXSwgWygpID0+IC0xLCAoKSA9PiAxXSwgWzEsIDFdKTtcblxuICAgIHB1YmxpYyBtaW5faW5wdXQ6IG51bWJlciA9IC0xO1xuICAgIHB1YmxpYyBtYXhfaW5wdXQ6IG51bWJlciA9IDE7XG4gICAgcHVibGljIG1pbl92YWx1ZTogbnVtYmVyID0gLTE7XG4gICAgcHVibGljIG1heF92YWx1ZTogbnVtYmVyID0gMTtcblxuICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgcHJpdmF0ZSB3aWRnZWRfd2lkdGg6IG51bWJlclxuICAgIHByaXZhdGUgd2lkZ2V0X3Bvc3k6IG51bWJlclxuXG4gICAgcHJpdmF0ZSBkcmFnZ2luZ19pZDogbnVtYmVyID0gLTFcbiAgICBwcml2YXRlIHNlbGVjdGVkX2lkOiBudW1iZXIgPSAtMVxuICAgIHByaXZhdGUgZHJhZ2dpbmdfZGVyaXZhdGl2ZTogYm9vbGVhbiA9IGZhbHNlXG4gICAgcHJpdmF0ZSBsYXN0X2NsaWNrX3RpbWU6IG51bWJlciA9IDAgXG5cbiAgICBwcml2YXRlIG5vZGU6IExHcmFwaE5vZGVcblxuICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG5vZGU6IExHcmFwaE5vZGUsIHdpZHRoOiBudW1iZXIsIHBvc1k6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGVcblxuICAgICAgICBjdHguc2F2ZSgpXG4gICAgICAgIHdpZHRoLT0yMDtcbiAgICAgICAgdGhpcy53aWRnZWRfd2lkdGggPSB3aWR0aFxuICAgICAgICB0aGlzLndpZGdldF9wb3N5ID0gcG9zWVxuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCJcbiAgICAgICAgY3R4LnJlY3QoMTAsIHBvc1ksIHdpZHRoLCB3aWR0aClcbiAgICAgICAgY3R4LmNsaXAoKVxuICAgICAgICBjdHguZmlsbFJlY3QoMTAsIHBvc1ksIHdpZHRoLCB3aWR0aClcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMC41XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiZ3JheVwiXG4gICAgICAgIGZvciAodmFyIGxvY2F0aW9uID0gTWF0aC5mbG9vcih0aGlzLm1pbl9pbnB1dCAvIDIpICogMiA7IGxvY2F0aW9uIDw9IHRoaXMubWF4X2lucHV0IDsgbG9jYXRpb24rPTAuNSl7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3MobG9jYXRpb24sIHdpZHRoKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBwb3NZKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBwb3NZICsgd2lkdGgpXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB2YWx1ZSA9IE1hdGguZmxvb3IodGhpcy5taW5fdmFsdWUgLyAyKSAqIDIgOyB2YWx1ZSA8PSB0aGlzLm1heF92YWx1ZSA7IHZhbHVlKz0wLjUpe1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5vdXRwdXRUb1Bvcyh2YWx1ZSwgd2lkdGgpXG4gICAgICAgICAgICBjdHgubGluZVRvKDEwLCB5KVxuICAgICAgICAgICAgY3R4LmxpbmVUbygxMCt3aWR0aCwgeSlcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDFcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjb25zdCBzdGVwID0gNVxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeDw9d2lkdGg7IHgrPXN0ZXApe1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4KzEwLCB0aGlzLm91dHB1dFRvUG9zKHRoaXMudmFsdWUuYXBwbHkodGhpcy5wb3NUb0lucHV0KHggKyAxMCwgd2lkdGgpKSwgd2lkdGgpKVxuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lVG8od2lkdGgrMTAsIHRoaXMub3V0cHV0VG9Qb3ModGhpcy52YWx1ZS5hcHBseSh0aGlzLnBvc1RvSW5wdXQod2lkdGggKyAxMCwgd2lkdGgpKSwgd2lkdGgpKVxuICAgICAgICBjdHguc3Ryb2tlKClcblxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGk8dGhpcy52YWx1ZS5sb2NhdGlvbnMubGVuZ3RoIDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3ModGhpcy52YWx1ZS5sb2NhdGlvbnNbaV0sIHdpZHRoKVxuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMub3V0cHV0VG9Qb3ModGhpcy52YWx1ZS52YWx1ZXNbaV0oMCksIHdpZHRoKVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGkgPT0gdGhpcy5zZWxlY3RlZF9pZCA/IFwib3JhbmdlXCIgOiBcIndoaXRlXCJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBpID09IHRoaXMuc2VsZWN0ZWRfaWQgPyAzIDogMiwgMCwgMiAqIE1hdGguUEkpOyAgXG4gICAgICAgICAgICBjdHguZmlsbCgpICAgXG4gICAgICAgICAgICBpZiAoaSA9PSB0aGlzLnNlbGVjdGVkX2lkKXtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIm9yYW5nZVwiXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2YXRpdmUgPSB0aGlzLnZhbHVlLmRlcml2YXRpdmVzW2ldICogKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpIC8gKHRoaXMubWF4X3ZhbHVlIC0gdGhpcy5taW5fdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4oZGVyaXZhdGl2ZSlcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSAzMCpNYXRoLmNvcyhhbmdsZSksIHkgKyAzMCpNYXRoLnNpbihhbmdsZSkpXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMzAqTWF0aC5jb3MoYW5nbGUpLCB5IC0gMzAqTWF0aC5zaW4oYW5nbGUpKVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8vY3R4LmZpbGxUZXh0KHRoaXMubWF4X3ZhbHVlLnRvRml4ZWQoMiksIDEwLCBwb3NZKzEyKVxuICAgICAgIC8vY3R4LmZpbGxUZXh0KHRoaXMubWluX3ZhbHVlLnRvRml4ZWQoMiksIDEwLCBwb3NZK3dpZHRoLTEpXG5cbiAgICAgICBjdHgucmVzdG9yZSgpXG5cbiAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgY3R4LmZpbGxUZXh0KHRoaXMubWluX2lucHV0LnRvRml4ZWQoMiksIDEwLCBwb3NZK3dpZHRoKzEyKVxuICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm1heF9pbnB1dC50b0ZpeGVkKDIpLCAxMCt3aWR0aC1jdHgubWVhc3VyZVRleHQodGhpcy5tYXhfaW5wdXQudG9GaXhlZCgyKSkud2lkdGgsIHBvc1krd2lkdGgrMTIpXG4gICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfaWQgPj0gMCl7XG4gICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIm9yYW5nZVwiXG4gICAgICAgICAgIGNvbnN0IHRleHQgPSBcIihcIiArIHRoaXMudmFsdWUubG9jYXRpb25zW3RoaXMuc2VsZWN0ZWRfaWRdLnRvRml4ZWQoMikgKyBcIiwgXCIgKyB0aGlzLnZhbHVlLnZhbHVlc1t0aGlzLnNlbGVjdGVkX2lkXSgwKS50b0ZpeGVkKDIpICsgXCIpXCJcbiAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIDEwK3dpZHRoLzItY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoLzIsIHBvc1krd2lkdGgrMTIpXG4gICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcG9zVG9JbnB1dChwb3M6IG51bWJlciwgd2lkdGg6IG51bWJlcil7XG4gICAgICAgIHJldHVybiAocG9zIC0gMTApL3dpZHRoICogKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpICsgdGhpcy5taW5faW5wdXRcbiAgICB9IFxuXG4gICAgcHJpdmF0ZSBpbnB1dFRvUG9zKGlucHV0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpe1xuICAgICAgICByZXR1cm4gKGlucHV0IC0gdGhpcy5taW5faW5wdXQpIC8gKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpICogd2lkdGggKyAxMFxuICAgIH0gXG5cbiAgICBwcml2YXRlIHBvc1RvT3V0cHV0KHBvczogbnVtYmVyLCB3aWR0aDogbnVtYmVyKXtcbiAgICAgICAgcmV0dXJuICgxIC0gKChwb3MgLSB0aGlzLndpZGdldF9wb3N5KSAvd2lkdGgpKSAqICh0aGlzLm1heF92YWx1ZSAtIHRoaXMubWluX3ZhbHVlKSArIHRoaXMubWluX3ZhbHVlXG4gICAgfSBcblxuICAgIHByaXZhdGUgb3V0cHV0VG9Qb3Mob3V0cHV0OiBudW1iZXIsIGhlaWdodDogbnVtYmVyKXtcbiAgICAgICAgcmV0dXJuICgxIC0gKChvdXRwdXQgLSB0aGlzLm1pbl92YWx1ZSkgLyAodGhpcy5tYXhfdmFsdWUgLSB0aGlzLm1pbl92YWx1ZSkpKSAqIGhlaWdodCArIHRoaXMud2lkZ2V0X3Bvc3lcbiAgICB9XG5cbiAgICBtb3VzZShldmVudDogTW91c2VFdmVudCwgcG9zOiBWZWN0b3IyLCBub2RlOiBMR3JhcGhOb2RlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlZG93blwiKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaTx0aGlzLnZhbHVlLmxvY2F0aW9ucy5sZW5ndGggOyBpKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3ModGhpcy52YWx1ZS5sb2NhdGlvbnNbaV0sIHRoaXMud2lkZ2VkX3dpZHRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLm91dHB1dFRvUG9zKHRoaXMudmFsdWUudmFsdWVzW2ldKDApLCB0aGlzLndpZGdlZF93aWR0aClcblxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAoeCAtIHBvc1swXSkqKHggLSBwb3NbMF0pICsgKHkgLSBwb3NbMV0pKih5IC0gcG9zWzFdKVxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDEwMCl7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX2lkID09IGkgJiYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0X2NsaWNrX3RpbWUpPCA1MDAgJiYgdGhpcy52YWx1ZS5sb2NhdGlvbnMubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9ucy5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudmFsdWVzLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXJpdmF0aXZlcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfaWQgPSAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9pZCA9IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfaWQgPSBpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2lkID0gaVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19kZXJpdmF0aXZlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdF9jbGlja190aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNocmluaygpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAxMDAwICYmIGkgPT0gdGhpcy5zZWxlY3RlZF9pZCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2YXRpdmUgPSB0aGlzLnZhbHVlLmRlcml2YXRpdmVzW2ldICogKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpIC8gKHRoaXMubWF4X3ZhbHVlIC0gdGhpcy5taW5fdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlX2FuZ2xlID0gTWF0aC5hdGFuKCh5IC0gcG9zWzFdKS8gKC14ICsgcG9zWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVyaXZhdGl2ZV9hbmdsZSA9IE1hdGguYXRhbihkZXJpdmF0aXZlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobW91c2VfYW5nbGUgLSBkZXJpdmF0aXZlX2FuZ2xlKTwwLjEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19pZCA9IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfZGVyaXZhdGl2ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNocmluaygpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnBvc1RvSW5wdXQocG9zWzBdLCB0aGlzLndpZGdlZF93aWR0aClcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wb3NUb091dHB1dChwb3NbMV0sIHRoaXMud2lkZ2VkX3dpZHRoKVxuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5vdXRwdXRUb1Bvcyh0aGlzLnZhbHVlLmFwcGx5KGxvY2F0aW9uKSwgdGhpcy53aWRnZWRfd2lkdGgpIC0gcG9zWzFdKSA8IDEwKXtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnZhbHVlLmxvY2F0aW9ucy5maW5kSW5kZXgoKGxvYykgPT4gbG9jID4gbG9jYXRpb24pXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnZhbHVlLmxvY2F0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9ucy5zcGxpY2UoaW5kZXgsIDAsIGxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudmFsdWVzLnNwbGljZShpbmRleCwgMCwgKCkgPT4gdmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXJpdmF0aXZlcy5zcGxpY2UoaW5kZXgsIDAsIDApXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19pZCA9IGluZGV4XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9pZCA9IGluZGV4XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19kZXJpdmF0aXZlID0gZmFsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTaHJpbmsoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSAgIFxuXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2lkID0gLTFcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaWQgPSAtMVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgJiYgdGhpcy5kcmFnZ2luZ19pZCA+PSAwKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nX2Rlcml2YXRpdmUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3ModGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0sIHRoaXMud2lkZ2VkX3dpZHRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLm91dHB1dFRvUG9zKHRoaXMudmFsdWUudmFsdWVzW3RoaXMuZHJhZ2dpbmdfaWRdKDApLCB0aGlzLndpZGdlZF93aWR0aClcblxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSAoeSAtIHBvc1sxXSkvICgteCArIHBvc1swXSkgLyAodGhpcy5tYXhfaW5wdXQgLSB0aGlzLm1pbl9pbnB1dCkgKiAodGhpcy5tYXhfdmFsdWUgLSB0aGlzLm1pbl92YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc1swXSA8IDApe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RXhwYW5kKFwibGVmdFwiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zWzBdID4gdGhpcy53aWRnZWRfd2lkdGggKyAyMCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFeHBhbmQoXCJyaWdodFwiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEV4cGFuZCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBNYXRoLmNsYW1wKHRoaXMucG9zVG9JbnB1dChwb3NbMF0sIHRoaXMud2lkZ2VkX3dpZHRoKSwgdGhpcy5taW5faW5wdXQsIHRoaXMubWF4X2lucHV0KVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gTWF0aC5jbGFtcCh0aGlzLnBvc1RvT3V0cHV0KHBvc1sxXSwgdGhpcy53aWRnZWRfd2lkdGgpLCB0aGlzLm1pbl92YWx1ZSwgdGhpcy5tYXhfdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgZGVyaXZhdGl2ZSA9IHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF1cblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmRyYWdnaW5nX2lkID4gMCAmJiBsb2NhdGlvbiA8IHRoaXMudmFsdWUubG9jYXRpb25zW3RoaXMuZHJhZ2dpbmdfaWQtMV0pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkXSA9IHRoaXMudmFsdWUubG9jYXRpb25zW3RoaXMuZHJhZ2dpbmdfaWQtMV1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXJpdmF0aXZlc1t0aGlzLmRyYWdnaW5nX2lkXSA9IHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZC0xXVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnZhbHVlc1t0aGlzLmRyYWdnaW5nX2lkXSA9IHRoaXMudmFsdWUudmFsdWVzW3RoaXMuZHJhZ2dpbmdfaWQtMV1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19pZC0tXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaWQtLVxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5kcmFnZ2luZ19pZCA8IHRoaXMudmFsdWUubG9jYXRpb25zLmxlbmd0aCAtIDEgJiYgbG9jYXRpb24gPiB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkKzFdKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkKzFdXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLnZhbHVlLmRlcml2YXRpdmVzW3RoaXMuZHJhZ2dpbmdfaWQrMV1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS52YWx1ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLnZhbHVlLnZhbHVlc1t0aGlzLmRyYWdnaW5nX2lkKzFdXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfaWQrK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2lkKytcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkXSA9IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS52YWx1ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSAoKSA9PiB2YWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSBkZXJpdmF0aXZlXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2V1cFwiKXtcbiAgICAgICAgICAgIHRoaXMuc3RvcEV4cGFuZCgpXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2lkID0gLTFcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaHJpbmsoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29tcHV0ZVNpemUod2lkdGg6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICByZXR1cm4gW3dpZHRoLCB3aWR0aC0yMCsxNV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRfdGltZXI6IE5vZGVKUy5UaW1lciA9IHVuZGVmaW5lZFxuICAgIHByaXZhdGUgc3RhcnRFeHBhbmQoZGlyZWN0aW9uOiBcImxlZnRcInxcInJpZ2h0XCIpe1xuICAgICAgICBpZiAoIXRoaXMuZXhwYW5kX3RpbWVyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZF90aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5faW5wdXQgLT0gMC4wMlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLm1pbl9pbnB1dFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhfaW5wdXQgKz0gMC4wMlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLm1heF9pbnB1dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZT8uc2V0RGlydHlDYW52YXModHJ1ZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfSwgMjApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0b3BFeHBhbmQoKXtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kX3RpbWVyKXtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5leHBhbmRfdGltZXIpXG4gICAgICAgICAgICB0aGlzLmV4cGFuZF90aW1lciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaHJpbmtfdGltZXI6IE5vZGVKUy5UaW1lciA9IHVuZGVmaW5lZFxuICAgIHByaXZhdGUgc3RhcnRTaHJpbmsoKXtcbiAgICAgICAgaWYgKCF0aGlzLnNocmlua190aW1lcil7XG4gICAgICAgICAgICB0aGlzLnNocmlua190aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluX2lucHV0IDwgdGhpcy52YWx1ZS5sb2NhdGlvbnNbMF0tMC4zKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5faW5wdXQgKz0gMC4wMlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhfaW5wdXQgPiB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLnZhbHVlLmxvY2F0aW9ucy5sZW5ndGggLSAxXSswLjMpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heF9pbnB1dCAtPSAwLjAyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNocmluaygpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlPy5zZXREaXJ0eUNhbnZhcyh0cnVlLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RvcFNocmluaygpe1xuICAgICAgICBpZiAodGhpcy5zaHJpbmtfdGltZXIpe1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNocmlua190aW1lcilcbiAgICAgICAgICAgIHRoaXMuc2hyaW5rX3RpbWVyID0gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9XG59IiwiXG4vKiEgcGFrbyAyLjAuNCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28gQGxpY2Vuc2UgKE1JVCBBTkQgWmxpYikgKi9cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQkMSAgICAgICAgICAgICAgID0gNDtcbi8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbmNvbnN0IFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG5jb25zdCBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbmNvbnN0IFpfVU5LTk9XTiQxICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvJDEoYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIJDEgICAgPSAzO1xuY29uc3QgTUFYX01BVENIJDEgICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbmNvbnN0IExFTkdUSF9DT0RFUyQxICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG5jb25zdCBMX0NPREVTJDEgICAgICAgPSBMSVRFUkFMUyQxICsgMSArIExFTkdUSF9DT0RFUyQxO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IERfQ09ERVMkMSAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbmNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSQxICAgICA9IDIgKiBMX0NPREVTJDEgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxuY29uc3QgTUFYX0JJVFMkMSAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTJDEgKyAyKSAqIDIpO1xuemVybyQxKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbmNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxICogMik7XG56ZXJvJDEoc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxuY29uc3QgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8kMShfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbmNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIJDEgLSBNSU5fTUFUQ0gkMSArIDEpO1xuemVybyQxKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTJDEpO1xuemVybyQxKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxKTtcbnplcm8kMShiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICBjb25zdCBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICBjb25zdCBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICBjb25zdCBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICBsZXQgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgbGV0IG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIGxldCB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICBsZXQgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICBsZXQgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRSQxOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuY29uc3QgZ2VuX2NvZGVzID0gKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgPT5cbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgY29uc3QgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTJDEgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgbGV0IGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgbGV0IGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmNvbnN0IHRyX3N0YXRpY19pbml0ID0gKCkgPT4ge1xuXG4gIGxldCBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgbGV0IGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIGxldCBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyQxIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTJDE7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMkMSArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMkMSArIDEsIExfQ09ERVMkMSwgTUFYX0JJVFMkMSk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUyQxLCBNQVhfQklUUyQxKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMkMSwgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuY29uc3QgaW5pdF9ibG9jayA9IChzKSA9PiB7XG5cbiAgbGV0IG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUyQxOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUyQxOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5jb25zdCBiaV93aW5kdXAgPSAocykgPT5cbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuY29uc3QgY29weV9ibG9jayA9IChzLCBidWYsIGxlbiwgaGVhZGVyKSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgcy5wZW5kaW5nX2J1Zi5zZXQocy53aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmNvbnN0IHNtYWxsZXIgPSAodHJlZSwgbiwgbSwgZGVwdGgpID0+IHtcblxuICBjb25zdCBfbjIgPSBuICogMjtcbiAgY29uc3QgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5jb25zdCBwcWRvd25oZWFwID0gKHMsIHRyZWUsIGspID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIGNvbnN0IHYgPSBzLmhlYXBba107XG4gIGxldCBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn07XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gY29uc3QgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5jb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgbGV0IGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICBsZXQgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgbGV0IGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTJDEgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuY29uc3QgYnVpbGRfdHJlZSA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgbGV0IG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIGxldCBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkUkMTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5jb25zdCBzZW5kX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5jb25zdCBidWlsZF9ibF90cmVlID0gKHMpID0+IHtcblxuICBsZXQgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMkMSAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmNvbnN0IHNlbmRfYWxsX3RyZWVzID0gKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgbGV0IHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuY29uc3QgZGV0ZWN0X2RhdGFfdHlwZSA9IChzKSA9PiB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgbGV0IGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICBsZXQgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUyQxOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59O1xuXG5cbmxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5jb25zdCBfdHJfaW5pdCQxID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayQxID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmNvbnN0IF90cl9hbGlnbiQxID0gKHMpID0+IHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmNvbnN0IF90cl9mbHVzaF9ibG9jayQxID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIGxldCBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTiQxKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEJDEgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkkMSA9IChzLCBkaXN0LCBsYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL2xldCBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTJDEgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufTtcblxudmFyIF90cl9pbml0XzEgID0gX3RyX2luaXQkMTtcbnZhciBfdHJfc3RvcmVkX2Jsb2NrXzEgPSBfdHJfc3RvcmVkX2Jsb2NrJDE7XG52YXIgX3RyX2ZsdXNoX2Jsb2NrXzEgID0gX3RyX2ZsdXNoX2Jsb2NrJDE7XG52YXIgX3RyX3RhbGx5XzEgPSBfdHJfdGFsbHkkMTtcbnZhciBfdHJfYWxpZ25fMSA9IF90cl9hbGlnbiQxO1xuXG52YXIgdHJlZXMgPSB7XG5cdF90cl9pbml0OiBfdHJfaW5pdF8xLFxuXHRfdHJfc3RvcmVkX2Jsb2NrOiBfdHJfc3RvcmVkX2Jsb2NrXzEsXG5cdF90cl9mbHVzaF9ibG9jazogX3RyX2ZsdXNoX2Jsb2NrXzEsXG5cdF90cl90YWxseTogX3RyX3RhbGx5XzEsXG5cdF90cl9hbGlnbjogX3RyX2FsaWduXzFcbn07XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IGFkbGVyMzIgPSAoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgbGV0IHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn07XG5cblxudmFyIGFkbGVyMzJfMSA9IGFkbGVyMzI7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuY29uc3QgbWFrZVRhYmxlID0gKCkgPT4ge1xuICBsZXQgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn07XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG5jb25zdCBjcmNUYWJsZSA9IG5ldyBVaW50MzJBcnJheShtYWtlVGFibGUoKSk7XG5cblxuY29uc3QgY3JjMzIgPSAoY3JjLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGNvbnN0IHQgPSBjcmNUYWJsZTtcbiAgY29uc3QgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufTtcblxuXG52YXIgY3JjMzJfMSA9IGNyYzMyO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIGNvbnN0YW50cyQyID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIFpfTUVNX0VSUk9SOiAgICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCB7IF90cl9pbml0LCBfdHJfc3RvcmVkX2Jsb2NrLCBfdHJfZmx1c2hfYmxvY2ssIF90cl90YWxseSwgX3RyX2FsaWduIH0gPSB0cmVlcztcblxuXG5cblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSDogWl9OT19GTFVTSCQyLCBaX1BBUlRJQUxfRkxVU0gsIFpfRlVMTF9GTFVTSDogWl9GVUxMX0ZMVVNIJDEsIFpfRklOSVNIOiBaX0ZJTklTSCQzLCBaX0JMT0NLOiBaX0JMT0NLJDEsXG4gIFpfT0s6IFpfT0skMywgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMywgWl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SJDIsIFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SJDIsIFpfQlVGX0VSUk9SOiBaX0JVRl9FUlJPUiQxLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxLFxuICBaX0ZJTFRFUkVELCBaX0hVRkZNQU5fT05MWSwgWl9STEUsIFpfRklYRUQsIFpfREVGQVVMVF9TVFJBVEVHWTogWl9ERUZBVUxUX1NUUkFURUdZJDEsXG4gIFpfVU5LTk9XTixcbiAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQyXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbmNvbnN0IE1BWF9XQklUUyQxID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbmNvbnN0IExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5jb25zdCBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuY29uc3QgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgTUlOX01BVENIID0gMztcbmNvbnN0IE1BWF9NQVRDSCA9IDI1ODtcbmNvbnN0IE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbmNvbnN0IFBSRVNFVF9ESUNUID0gMHgyMDtcblxuY29uc3QgSU5JVF9TVEFURSA9IDQyO1xuY29uc3QgRVhUUkFfU1RBVEUgPSA2OTtcbmNvbnN0IE5BTUVfU1RBVEUgPSA3MztcbmNvbnN0IENPTU1FTlRfU1RBVEUgPSA5MTtcbmNvbnN0IEhDUkNfU1RBVEUgPSAxMDM7XG5jb25zdCBCVVNZX1NUQVRFID0gMTEzO1xuY29uc3QgRklOSVNIX1NUQVRFID0gNjY2O1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn07XG5cbmNvbnN0IHplcm8gPSAoYnVmKSA9PiB7XG4gIGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH1cbn07XG5cblxuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xubGV0IEhBU0hfWkxJQiA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgcy5oYXNoX3NoaWZ0KSBeIGRhdGEpICYgcy5oYXNoX21hc2s7XG4vLyBUaGlzIGhhc2ggY2F1c2VzIGxlc3MgY29sbGlzaW9ucywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2lzc3Vlcy8xMzVcbi8vIEJ1dCBicmVha3MgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vbGV0IEhBU0hfRkFTVCA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgOCkgKyAocHJldiA+PiA4KSArIChkYXRhIDw8IDQpKSAmIHMuaGFzaF9tYXNrO1xubGV0IEhBU0ggPSBIQVNIX1pMSUI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmNvbnN0IGZsdXNoX3BlbmRpbmcgPSAoc3RybSkgPT4ge1xuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICBsZXQgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHN0cm0ub3V0cHV0LnNldChzLnBlbmRpbmdfYnVmLnN1YmFycmF5KHMucGVuZGluZ19vdXQsIHMucGVuZGluZ19vdXQgKyBsZW4pLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59O1xuXG5cbmNvbnN0IGZsdXNoX2Jsb2NrX29ubHkgPSAocywgbGFzdCkgPT4ge1xuICBfdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn07XG5cblxuY29uc3QgcHV0X2J5dGUgPSAocywgYikgPT4ge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuY29uc3QgcHV0U2hvcnRNU0IgPSAocywgYikgPT4ge1xuXG4gIC8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5jb25zdCByZWFkX2J1ZiA9IChzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSA9PiB7XG5cbiAgbGV0IGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIGJ1Zi5zZXQoc3RybS5pbnB1dC5zdWJhcnJheShzdHJtLm5leHRfaW4sIHN0cm0ubmV4dF9pbiArIGxlbiksIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyXzEoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmNvbnN0IGxvbmdlc3RfbWF0Y2ggPSAocywgY3VyX21hdGNoKSA9PiB7XG5cbiAgbGV0IGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgbGV0IHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIGxldCBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgbGV0IG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgY29uc3QgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgY29uc3Qgd21hc2sgPSBzLndfbWFzaztcbiAgY29uc3QgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgY29uc3Qgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgbGV0IHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICBsZXQgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuY29uc3QgZmlsbF93aW5kb3cgPSAocykgPT4ge1xuXG4gIGNvbnN0IF93X3NpemUgPSBzLndfc2l6ZTtcbiAgbGV0IHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KF93X3NpemUsIF93X3NpemUgKyBfd19zaXplKSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIGNvbnN0IGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICBsZXQgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IGRlZmxhdGVfc3RvcmVkID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICBsZXQgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgY29uc3QgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuY29uc3QgZGVmbGF0ZV9mYXN0ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmNvbnN0IGRlZmxhdGVfc2xvdyA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgbGV0IG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5jb25zdCBkZWZsYXRlX3JsZSA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgbGV0IHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfaHVmZiA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcblxuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxuY29uc3QgY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5jb25zdCBsbV9pbml0ID0gKHMpID0+IHtcblxuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufTtcblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQkMjsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IFVpbnQxNkFycmF5KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmNvbnN0IGRlZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIJDI7XG4gIF90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGNvbnN0IHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0skMykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZVNldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQyOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlSW5pdDIgPSAoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSkge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEJDIgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgVWludDE2QXJyYXkocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgVWludDE2QXJyYXkocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuY29uc3QgZGVmbGF0ZUluaXQgPSAoc3RybSwgbGV2ZWwpID0+IHtcblxuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVEJDIsIE1BWF9XQklUUyQxLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kkMSk7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGUkMiA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0skMSB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKSA6IFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCQzKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SJDEgOiBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICBsZXQgaGVhZGVyID0gKFpfREVGTEFURUQkMiArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIGxldCBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIJDMpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SJDEpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IkMSk7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCQyICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICBfdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSyQxKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gkMSkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCQzKSB7IHJldHVybiBaX09LJDM7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQkMzsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LJDMgOiBaX1NUUkVBTV9FTkQkMztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUiQyKSA6IFpfT0skMztcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5jb25zdCBkZWZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG5cbiAgbGV0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGNvbnN0IHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgbGV0IHRtcERpY3QgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSk7XG4gICAgdG1wRGljdC5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShkaWN0TGVuZ3RoIC0gcy53X3NpemUsIGRpY3RMZW5ndGgpLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgY29uc3QgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBjb25zdCBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBjb25zdCBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBsZXQgc3RyID0gcy5zdHJzdGFydDtcbiAgICBsZXQgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG52YXIgZGVmbGF0ZUluaXRfMSA9IGRlZmxhdGVJbml0O1xudmFyIGRlZmxhdGVJbml0Ml8xID0gZGVmbGF0ZUluaXQyO1xudmFyIGRlZmxhdGVSZXNldF8xID0gZGVmbGF0ZVJlc2V0O1xudmFyIGRlZmxhdGVSZXNldEtlZXBfMSA9IGRlZmxhdGVSZXNldEtlZXA7XG52YXIgZGVmbGF0ZVNldEhlYWRlcl8xID0gZGVmbGF0ZVNldEhlYWRlcjtcbnZhciBkZWZsYXRlXzIkMSA9IGRlZmxhdGUkMjtcbnZhciBkZWZsYXRlRW5kXzEgPSBkZWZsYXRlRW5kO1xudmFyIGRlZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbnZhciBkZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG5cbnZhciBkZWZsYXRlXzEkMiA9IHtcblx0ZGVmbGF0ZUluaXQ6IGRlZmxhdGVJbml0XzEsXG5cdGRlZmxhdGVJbml0MjogZGVmbGF0ZUluaXQyXzEsXG5cdGRlZmxhdGVSZXNldDogZGVmbGF0ZVJlc2V0XzEsXG5cdGRlZmxhdGVSZXNldEtlZXA6IGRlZmxhdGVSZXNldEtlZXBfMSxcblx0ZGVmbGF0ZVNldEhlYWRlcjogZGVmbGF0ZVNldEhlYWRlcl8xLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzIkMSxcblx0ZGVmbGF0ZUVuZDogZGVmbGF0ZUVuZF8xLFxuXHRkZWZsYXRlU2V0RGljdGlvbmFyeTogZGVmbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0ZGVmbGF0ZUluZm86IGRlZmxhdGVJbmZvXG59O1xuXG5jb25zdCBfaGFzID0gKG9iaiwga2V5KSA9PiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbnZhciBmbGF0dGVuQ2h1bmtzID0gKGNodW5rcykgPT4ge1xuICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgbGV0IGxlbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gIH1cblxuICAvLyBqb2luIGNodW5rc1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNvbW1vbiA9IHtcblx0YXNzaWduOiBhc3NpZ24sXG5cdGZsYXR0ZW5DaHVua3M6IGZsYXR0ZW5DaHVua3Ncbn07XG5cbi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG5sZXQgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbmNvbnN0IF91dGY4bGVuID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAobGV0IHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IChzdHIpID0+IHtcbiAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyAmJiBUZXh0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICB9XG5cbiAgbGV0IGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXJcbmNvbnN0IGJ1ZjJiaW5zdHJpbmcgPSAoYnVmLCBsZW4pID0+IHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zi5sZW5ndGggPT09IGxlbiA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG52YXIgYnVmMnN0cmluZyA9IChidWYsIG1heCkgPT4ge1xuICBjb25zdCBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIFRleHREZWNvZGVyID09PSAnZnVuY3Rpb24nICYmIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1Zi5zdWJhcnJheSgwLCBtYXgpKTtcbiAgfVxuXG4gIGxldCBpLCBvdXQ7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgY29uc3QgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGxldCBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IChidWYsIG1heCkgPT4ge1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIGxldCBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG52YXIgc3RyaW5ncyA9IHtcblx0c3RyaW5nMmJ1Zjogc3RyaW5nMmJ1Zixcblx0YnVmMnN0cmluZzogYnVmMnN0cmluZyxcblx0dXRmOGJvcmRlcjogdXRmOGJvcmRlclxufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG52YXIgenN0cmVhbSA9IFpTdHJlYW07XG5cbmNvbnN0IHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDEsIFpfU1lOQ19GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSDogWl9GSU5JU0gkMixcbiAgWl9PSzogWl9PSyQyLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQyLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gIFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQxXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlJDEob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBjb21tb24uYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCQxLFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWVxuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBsZXQgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LJDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIGRlZmxhdGVfMSQyLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIGxldCBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmckMS5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LJDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0XG4gKiBoYXZlIGBmbHVzaF9tb2RlYCBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmdcbiAqIGJ1ZmZlcnMgYW5kIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0uXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUkMS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCQyIDogWl9OT19GTFVTSCQxO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXZhaWxfb3V0ID4gNiB0byBhdm9pZCByZXBlYXRpbmcgbWFya2Vyc1xuICAgIGlmICgoX2ZsdXNoX21vZGUgPT09IFpfU1lOQ19GTFVTSCB8fCBfZmx1c2hfbW9kZSA9PT0gWl9GVUxMX0ZMVVNIKSAmJiBzdHJtLmF2YWlsX291dCA8PSA2KSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2hcbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMikge1xuICAgICAgaWYgKHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSyQyO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIG91dCBidWZmZXIgZnVsbFxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgcmVxdWVzdGVkIGFuZCBoYXMgZGF0YVxuICAgIGlmIChfZmx1c2hfbW9kZSA+IDAgJiYgc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5KTogb3V0cHV0IGRhdGEuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlJDEucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZSQxLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSyQyKSB7XG4gICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBkZWZsYXRvciA9IG5ldyBEZWZsYXRlJDEob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbWVzc2FnZXNbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3JDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAkMShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxudmFyIERlZmxhdGVfMSQxID0gRGVmbGF0ZSQxO1xudmFyIGRlZmxhdGVfMiA9IGRlZmxhdGUkMTtcbnZhciBkZWZsYXRlUmF3XzEkMSA9IGRlZmxhdGVSYXckMTtcbnZhciBnemlwXzEkMSA9IGd6aXAkMTtcbnZhciBjb25zdGFudHMkMSA9IGNvbnN0YW50cyQyO1xuXG52YXIgZGVmbGF0ZV8xJDEgPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSQxLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzIsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSQxLFxuXHRnemlwOiBnemlwXzEkMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHMkMVxufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbmNvbnN0IEJBRCQxID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0IFRZUEUkMSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xudmFyIGluZmZhc3QgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgbGV0IF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICBsZXQgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgbGV0IGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgbGV0IHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICBsZXQgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICBsZXQgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIGxldCBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIGxldCBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgbGV0IGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgbGV0IGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICBsZXQgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgbGV0IGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICBsZXQgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgbGV0IGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuXG5cbiAgbGV0IGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgTUFYQklUUyA9IDE1O1xuY29uc3QgRU5PVUdIX0xFTlMkMSA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyQxID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgQ09ERVMkMSA9IDA7XG5jb25zdCBMRU5TJDEgPSAxO1xuY29uc3QgRElTVFMkMSA9IDI7XG5cbmNvbnN0IGxiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl0pO1xuXG5jb25zdCBsZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl0pO1xuXG5jb25zdCBkYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl0pO1xuXG5jb25zdCBkZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl0pO1xuXG5jb25zdCBpbmZsYXRlX3RhYmxlID0gKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpID0+XG57XG4gIGNvbnN0IGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIGxldCBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIGxldCBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICBsZXQgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgbGV0IHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgbGV0IGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgbGV0IGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICBsZXQgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIGxldCB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIGxldCBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICBsZXQgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgbGV0IGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICBsZXQgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgbGV0IG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICBsZXQgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgYmFzZV9pbmRleCA9IDA7XG4vLyAgbGV0IHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgY29uc3QgY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgY29uc3Qgb2ZmcyA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICBsZXQgZXh0cmEgPSBudWxsO1xuICBsZXQgZXh0cmFfaW5kZXggPSAwO1xuXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyQxIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUyQxKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TJDEpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TJDEgJiYgdXNlZCA+IEVOT1VHSF9MRU5TJDEpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTJDEgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUyQxKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TJDEgJiYgdXNlZCA+IEVOT1VHSF9MRU5TJDEpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG5cblxudmFyIGluZnRyZWVzID0gaW5mbGF0ZV90YWJsZTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5cblxuXG5cblxuY29uc3QgQ09ERVMgPSAwO1xuY29uc3QgTEVOUyA9IDE7XG5jb25zdCBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfRklOSVNIOiBaX0ZJTklTSCQxLCBaX0JMT0NLLCBaX1RSRUVTLFxuICBaX09LOiBaX09LJDEsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDEsIFpfTkVFRF9ESUNUOiBaX05FRURfRElDVCQxLCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMSwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMSwgWl9NRU1fRVJST1I6IFpfTUVNX0VSUk9SJDEsIFpfQlVGX0VSUk9SLFxuICBaX0RFRkxBVEVEXG59ID0gY29uc3RhbnRzJDI7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG5jb25zdCAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG5jb25zdCAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xuY29uc3QgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG5jb25zdCAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbmNvbnN0ICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG5jb25zdCAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbmNvbnN0ICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xuY29uc3QgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xuY29uc3QgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xuY29uc3QgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbmNvbnN0ICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG5jb25zdCAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG5jb25zdCAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG5jb25zdCAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbmNvbnN0ICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG5jb25zdCAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxuY29uc3QgRU5PVUdIX0xFTlMgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5jb25zdCB6c3dhcDMyID0gKHEpID0+IHtcblxuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn07XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IFVpbnQxNkFycmF5KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSyQxO1xufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuICBsZXQgd3JhcDtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBjb25zdCBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSyQxKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0ID0gKHN0cm0pID0+IHtcblxuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59O1xuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbmxldCB2aXJnaW4gPSB0cnVlO1xuXG5sZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5cbmNvbnN0IGZpeGVkdGFibGVzID0gKHN0YXRlKSA9PiB7XG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIGxlbmZpeCA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyBJbnQzMkFycmF5KDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgbGV0IHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZnRyZWVzKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mdHJlZXMoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59O1xuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5jb25zdCB1cGRhdGV3aW5kb3cgPSAoc3RybSwgc3JjLCBlbmQsIGNvcHkpID0+IHtcblxuICBsZXQgZGlzdDtcbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gc3RhdGUud3NpemUsIGVuZCksIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQgLSBjb3B5ICsgZGlzdCksIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGUkMiA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LJDE7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICEhISBwYWtvIHBhdGNoLiBGb3JjZSB1c2UgYG9wdGlvbnMud2luZG93Qml0c2AgaWYgcGFzc2VkLlxuICAgICAgICAvLyBSZXF1aXJlZCB0byBhbHdheXMgdXNlIG1heCB3aW5kb3cgc2l6ZSBieSBkZWZhdWx0LlxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICAgICAgLy9zdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG5cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYS5zZXQoXG4gICAgICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICAgIG5leHQgKyBjb3B5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUJDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQkMTtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQxKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCQxKSAmJiByZXQgPT09IFpfT0skMSkge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICBsZXQgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUdldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSyQxO1xufTtcblxuXG5jb25zdCBpbmZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG4gIGNvbnN0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBsZXQgc3RhdGU7XG4gIGxldCBkaWN0aWQ7XG4gIGxldCByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyXzEoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUiQxO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbnZhciBpbmZsYXRlUmVzZXRfMSA9IGluZmxhdGVSZXNldDtcbnZhciBpbmZsYXRlUmVzZXQyXzEgPSBpbmZsYXRlUmVzZXQyO1xudmFyIGluZmxhdGVSZXNldEtlZXBfMSA9IGluZmxhdGVSZXNldEtlZXA7XG52YXIgaW5mbGF0ZUluaXRfMSA9IGluZmxhdGVJbml0O1xudmFyIGluZmxhdGVJbml0Ml8xID0gaW5mbGF0ZUluaXQyO1xudmFyIGluZmxhdGVfMiQxID0gaW5mbGF0ZSQyO1xudmFyIGluZmxhdGVFbmRfMSA9IGluZmxhdGVFbmQ7XG52YXIgaW5mbGF0ZUdldEhlYWRlcl8xID0gaW5mbGF0ZUdldEhlYWRlcjtcbnZhciBpbmZsYXRlU2V0RGljdGlvbmFyeV8xID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuXG52YXIgaW5mbGF0ZV8xJDIgPSB7XG5cdGluZmxhdGVSZXNldDogaW5mbGF0ZVJlc2V0XzEsXG5cdGluZmxhdGVSZXNldDI6IGluZmxhdGVSZXNldDJfMSxcblx0aW5mbGF0ZVJlc2V0S2VlcDogaW5mbGF0ZVJlc2V0S2VlcF8xLFxuXHRpbmZsYXRlSW5pdDogaW5mbGF0ZUluaXRfMSxcblx0aW5mbGF0ZUluaXQyOiBpbmZsYXRlSW5pdDJfMSxcblx0aW5mbGF0ZTogaW5mbGF0ZV8yJDEsXG5cdGluZmxhdGVFbmQ6IGluZmxhdGVFbmRfMSxcblx0aW5mbGF0ZUdldEhlYWRlcjogaW5mbGF0ZUdldEhlYWRlcl8xLFxuXHRpbmZsYXRlU2V0RGljdGlvbmFyeTogaW5mbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0aW5mbGF0ZUluZm86IGluZmxhdGVJbmZvXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG52YXIgZ3poZWFkZXIgPSBHWmhlYWRlcjtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNILCBaX0ZJTklTSCxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX05FRURfRElDVCwgWl9TVFJFQU1fRVJST1IsIFpfREFUQV9FUlJPUiwgWl9NRU1fRVJST1Jcbn0gPSBjb25zdGFudHMkMjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlJDEob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBjb21tb24uYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDEwMjQgKiA2NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgY29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyAgPSBpbmZsYXRlXzEkMi5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IGd6aGVhZGVyKCk7XG5cbiAgaW5mbGF0ZV8xJDIuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGFcbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRVxuICogICBmbHVzaCBtb2Rlcy4gU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsXG4gKiAgIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIElmIGVuZCBvZiBzdHJlYW0gZGV0ZWN0ZWQsXG4gKiBbW0luZmxhdGUjb25FbmRdXSB3aWxsIGJlIGNhbGxlZC5cbiAqXG4gKiBgZmx1c2hfbW9kZWAgaXMgbm90IG5lZWRlZCBmb3Igbm9ybWFsIG9wZXJhdGlvbiwgYmVjYXVzZSBlbmQgb2Ygc3RyZWFtXG4gKiBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5LiBZb3UgbWF5IHRyeSB0byB1c2UgaXQgZm9yIGFkdmFuY2VkIHRoaW5ncywgYnV0XG4gKiB0aGlzIGZ1bmN0aW9uYWxpdHkgd2FzIG5vdCB0ZXN0ZWQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGNvbnN0IGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGUsIGxhc3RfYXZhaWxfb3V0O1xuXG4gIGlmICh0aGlzLmVuZGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICBpZiAoc3RhdHVzID09PSBaX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBjb2RlIHdpdGggbW9yZSB2ZXJib3NlXG4gICAgICAgIHN0YXR1cyA9IFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgc255YyBtYXJrZXJzIGlmIG1vcmUgZGF0YSBmb2xsb3dzIGFuZCBub3QgcmF3IG1vZGVcbiAgICB3aGlsZSAoc3RybS5hdmFpbF9pbiA+IDAgJiZcbiAgICAgICAgICAgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQgJiZcbiAgICAgICAgICAgc3RybS5zdGF0ZS53cmFwID4gMCAmJlxuICAgICAgICAgICBkYXRhW3N0cm0ubmV4dF9pbl0gIT09IDApXG4gICAge1xuICAgICAgaW5mbGF0ZV8xJDIuaW5mbGF0ZVJlc2V0KHN0cm0pO1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgWl9TVFJFQU1fRVJST1I6XG4gICAgICBjYXNlIFpfREFUQV9FUlJPUjpcbiAgICAgIGNhc2UgWl9ORUVEX0RJQ1Q6XG4gICAgICBjYXNlIFpfTUVNX0VSUk9SOlxuICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgcmVhbCBgYXZhaWxfb3V0YCB2YWx1ZSwgYmVjYXVzZSB3ZSBtYXkgcGF0Y2ggb3V0IGJ1ZmZlciBjb250ZW50XG4gICAgLy8gdG8gYWxpZ24gdXRmOCBzdHJpbmdzIGJvdW5kYXJpZXMuXG4gICAgbGFzdF9hdmFpbF9vdXQgPSBzdHJtLmF2YWlsX291dDtcblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbGV0IG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgbGV0IHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICBsZXQgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWwgJiByZWFsaWduIGNvdW50ZXJzXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSBzdHJtLm91dHB1dC5zZXQoc3RybS5vdXRwdXQuc3ViYXJyYXkobmV4dF9vdXRfdXRmOCwgbmV4dF9vdXRfdXRmOCArIHRhaWwpLCAwKTtcblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQubGVuZ3RoID09PSBzdHJtLm5leHRfb3V0ID8gc3RybS5vdXRwdXQgOiBzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNdXN0IHJlcGVhdCBpdGVyYXRpb24gaWYgb3V0IGJ1ZmZlciBpcyBmdWxsXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9PSyAmJiBsYXN0X2F2YWlsX291dCA9PT0gMCkgY29udGludWU7XG5cbiAgICAvLyBGaW5hbGl6ZSBpZiBlbmQgb2Ygc3RyZWFtIHJlYWNoZWQuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBlYWNoIGNodW5rIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZSQxLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZSQxLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XG4gKiBjb25zdCBpbnB1dCA9IHBha28uZGVmbGF0ZShuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKSk7XG4gKiBsZXQgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpIHtcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGluZmxhdG9yID0gbmV3IEluZmxhdGUkMShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0KTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbWVzc2FnZXNbaW5mbGF0b3IuZXJyXTtcblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3JDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbnZhciBJbmZsYXRlXzEkMSA9IEluZmxhdGUkMTtcbnZhciBpbmZsYXRlXzIgPSBpbmZsYXRlJDE7XG52YXIgaW5mbGF0ZVJhd18xJDEgPSBpbmZsYXRlUmF3JDE7XG52YXIgdW5nemlwJDEgPSBpbmZsYXRlJDE7XG52YXIgY29uc3RhbnRzID0gY29uc3RhbnRzJDI7XG5cbnZhciBpbmZsYXRlXzEkMSA9IHtcblx0SW5mbGF0ZTogSW5mbGF0ZV8xJDEsXG5cdGluZmxhdGU6IGluZmxhdGVfMixcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xJDEsXG5cdHVuZ3ppcDogdW5nemlwJDEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzXG59O1xuXG5jb25zdCB7IERlZmxhdGUsIGRlZmxhdGUsIGRlZmxhdGVSYXcsIGd6aXAgfSA9IGRlZmxhdGVfMSQxO1xuXG5jb25zdCB7IEluZmxhdGUsIGluZmxhdGUsIGluZmxhdGVSYXcsIHVuZ3ppcCB9ID0gaW5mbGF0ZV8xJDE7XG5cblxuXG52YXIgRGVmbGF0ZV8xID0gRGVmbGF0ZTtcbnZhciBkZWZsYXRlXzEgPSBkZWZsYXRlO1xudmFyIGRlZmxhdGVSYXdfMSA9IGRlZmxhdGVSYXc7XG52YXIgZ3ppcF8xID0gZ3ppcDtcbnZhciBJbmZsYXRlXzEgPSBJbmZsYXRlO1xudmFyIGluZmxhdGVfMSA9IGluZmxhdGU7XG52YXIgaW5mbGF0ZVJhd18xID0gaW5mbGF0ZVJhdztcbnZhciB1bmd6aXBfMSA9IHVuZ3ppcDtcbnZhciBjb25zdGFudHNfMSA9IGNvbnN0YW50cyQyO1xuXG52YXIgcGFrbyA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzEsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSxcblx0Z3ppcDogZ3ppcF8xLFxuXHRJbmZsYXRlOiBJbmZsYXRlXzEsXG5cdGluZmxhdGU6IGluZmxhdGVfMSxcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xLFxuXHR1bmd6aXA6IHVuZ3ppcF8xLFxuXHRjb25zdGFudHM6IGNvbnN0YW50c18xXG59O1xuXG5leHBvcnQgeyBEZWZsYXRlXzEgYXMgRGVmbGF0ZSwgSW5mbGF0ZV8xIGFzIEluZmxhdGUsIGNvbnN0YW50c18xIGFzIGNvbnN0YW50cywgcGFrbyBhcyBkZWZhdWx0LCBkZWZsYXRlXzEgYXMgZGVmbGF0ZSwgZGVmbGF0ZVJhd18xIGFzIGRlZmxhdGVSYXcsIGd6aXBfMSBhcyBnemlwLCBpbmZsYXRlXzEgYXMgaW5mbGF0ZSwgaW5mbGF0ZVJhd18xIGFzIGluZmxhdGVSYXcsIHVuZ3ppcF8xIGFzIHVuZ3ppcCB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IExHcmFwaCwgTEdyYXBoQ2FudmFzLCBMaXRlR3JhcGggfSBmcm9tICdsaXRlZ3JhcGguanMnO1xuaW1wb3J0IHsgRGVuc2l0eUZ1bmN0aW9uT3V0cHV0IH0gZnJvbSAnLi9ub2Rlcy9kZW5zaXR5X2Z1bmN0aW9uX291dHB1dCc7XG5pbXBvcnQgeyByZWdpc3Rlck5vZGVzIH0gZnJvbSAnLi9ub2Rlcy9yZWdpc3Rlcic7XG5pbXBvcnQgeyBHcmFwaE1hbmFnZXIgfSBmcm9tICcuL1VJL0dyYXBoTWFuYWdlcic7XG5pbXBvcnQgeyBNZW51TWFuYWdlciB9IGZyb20gJy4vVUkvTWVudU1hbmFnZXInO1xuXG5vbmxvYWQgPSAoKSA9PiB7XG4gICAgTWVudU1hbmFnZXIuYWRkSGFuZGxlcnMoKVxuICAgIEdyYXBoTWFuYWdlci5pbml0KClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==