/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/deepslate/dist/deepslate.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/deepslate/dist/deepslate.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlendedNoise": () => (/* binding */ Y),
/* harmony export */   "BlockColors": () => (/* binding */ nt),
/* harmony export */   "BlockDefinition": () => (/* binding */ lt),
/* harmony export */   "BlockModel": () => (/* binding */ ft),
/* harmony export */   "BlockPos": () => (/* binding */ o),
/* harmony export */   "BlockState": () => (/* binding */ B),
/* harmony export */   "Chunk": () => (/* binding */ C),
/* harmony export */   "ChunkPos": () => (/* binding */ I),
/* harmony export */   "ChunkSection": () => (/* binding */ E),
/* harmony export */   "Climate": () => (/* binding */ yt),
/* harmony export */   "Direction": () => (/* binding */ n),
/* harmony export */   "FixedBiome": () => (/* binding */ Rt),
/* harmony export */   "ImprovedNoise": () => (/* binding */ V),
/* harmony export */   "Json": () => (/* binding */ k),
/* harmony export */   "MultiNoise": () => (/* binding */ _t),
/* harmony export */   "NbtReader": () => (/* binding */ h),
/* harmony export */   "NbtWriter": () => (/* binding */ u),
/* harmony export */   "NoiseChunkGenerator": () => (/* binding */ Nt),
/* harmony export */   "NoiseGeneratorSettings": () => (/* binding */ Ct),
/* harmony export */   "NoiseInterpolator": () => (/* binding */ Ft),
/* harmony export */   "NoiseOctaves": () => (/* binding */ kt),
/* harmony export */   "NoiseParameters": () => (/* binding */ R),
/* harmony export */   "NoiseSampler": () => (/* binding */ Mt),
/* harmony export */   "NoiseSamplingSettings": () => (/* binding */ Bt),
/* harmony export */   "NoiseSettings": () => (/* binding */ St),
/* harmony export */   "NoiseSlideSettings": () => (/* binding */ Et),
/* harmony export */   "NormalNoise": () => (/* binding */ X),
/* harmony export */   "PerlinNoise": () => (/* binding */ j),
/* harmony export */   "PerlinSimplexNoise": () => (/* binding */ H),
/* harmony export */   "Random": () => (/* binding */ W),
/* harmony export */   "SimplexNoise": () => (/* binding */ z),
/* harmony export */   "Spline": () => (/* binding */ Z),
/* harmony export */   "Structure": () => (/* binding */ _),
/* harmony export */   "StructureRenderer": () => (/* binding */ wt),
/* harmony export */   "StructureSettings": () => (/* binding */ It),
/* harmony export */   "TerrainShaper": () => (/* binding */ At),
/* harmony export */   "TextureAtlas": () => (/* binding */ xt),
/* harmony export */   "WorldgenRandom": () => (/* binding */ J),
/* harmony export */   "binarySearch": () => (/* binding */ L),
/* harmony export */   "clamp": () => (/* binding */ M),
/* harmony export */   "clampedLerp": () => (/* binding */ U),
/* harmony export */   "getListTag": () => (/* binding */ A),
/* harmony export */   "getOptional": () => (/* binding */ S),
/* harmony export */   "getTag": () => (/* binding */ y),
/* harmony export */   "lerp": () => (/* binding */ N),
/* harmony export */   "lerp2": () => (/* binding */ T),
/* harmony export */   "lerp3": () => (/* binding */ O),
/* harmony export */   "read": () => (/* binding */ f),
/* harmony export */   "readChunk": () => (/* binding */ p),
/* harmony export */   "readCompressed": () => (/* binding */ d),
/* harmony export */   "readRegion": () => (/* binding */ g),
/* harmony export */   "readUncompressed": () => (/* binding */ c),
/* harmony export */   "smoothstep": () => (/* binding */ D),
/* harmony export */   "square": () => (/* binding */ F),
/* harmony export */   "tagNames": () => (/* binding */ l),
/* harmony export */   "tagTypes": () => (/* binding */ a),
/* harmony export */   "write": () => (/* binding */ b),
/* harmony export */   "writeChunk": () => (/* binding */ P),
/* harmony export */   "writeCompressed": () => (/* binding */ v),
/* harmony export */   "writeRegion": () => (/* binding */ w),
/* harmony export */   "writeUncompressed": () => (/* binding */ m)
/* harmony export */ });
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ "./node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/common.js");
var n;!function(t){t.UP="up",t.DOWN="down",t.NORTH="north",t.EAST="east",t.SOUTH="south",t.WEST="west"}(n||(n={}));const r={[n.UP]:[0,1,0],[n.DOWN]:[0,-1,0],[n.NORTH]:[0,0,-1],[n.EAST]:[1,0,0],[n.SOUTH]:[0,0,1],[n.WEST]:[-1,0,0]};var o;!function(t){t.ALL=[t.UP,t.DOWN,t.NORTH,t.EAST,t.SOUTH,t.WEST],t.normal=function(t){return r[t]}}(n||(n={})),function(t){t.create=function(t,e,s){return[t,e,s]},t.offset=function(t,e,s,i){return[t[0]+e,t[1]+s,t[2]+i]},t.towards=function(e,s){return t.offset(e,...n.normal(s))}}(o||(o={}));const a={end:0,byte:1,short:2,int:3,long:4,float:5,double:6,byteArray:7,string:8,list:9,compound:10,intArray:11,longArray:12},l=["end","byte","short","int","long","float","double","byteArray","string","list","compound","intArray","longArray"];class h{constructor(t,e=!1){this.byte=this.readNum.bind(this,"getInt8",1),this.short=this.readNum.bind(this,"getInt16",2),this.int=this.readNum.bind(this,"getInt32",4),this.float=this.readNum.bind(this,"getFloat32",4),this.double=this.readNum.bind(this,"getFloat64",8),this.offset=0,this.littleEndian=e,this.arrayView=t,this.dataView=new DataView(t.buffer,t.byteOffset)}end(){return null}readNum(t,e){const s=this.dataView[t](this.offset,this.littleEndian);return this.offset+=e,s}long(){return[this.int(),this.int()]}byteArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.byte());return e}intArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.int());return e}longArray(){const t=this.int(),e=[];for(let s=0;s<t;s++)e.push(this.long());return e}string(){const t=this.short(),e=this.arrayView.slice(this.offset,this.offset+t);return this.offset+=t,function(t){var e,s=[];for(e=0;e<t.length;e++)0==(128&t[e])?s.push(127&t[e]):e+1<t.length&&192==(224&t[e])&&128==(192&t[e+1])?s.push((31&t[e])<<6|63&t[e+1]):e+2<t.length&&224==(240&t[e])&&128==(192&t[e+1])&&128==(192&t[e+2])?s.push((15&t[e])<<12|(63&t[e+1])<<6|63&t[e+2]):e+3<t.length&&240==(248&t[e])&&128==(192&t[e+1])&&128==(192&t[e+2])&&128==(192&t[e+3])&&s.push((7&t[e])<<18|(63&t[e+1])<<12|(63&t[e+2])<<6|63&t[e+3]);return String.fromCharCode.apply(null,s)}(e)}list(){const t=l[this.byte()],e=this.int(),s=[];for(let i=0;i<e;i++)s.push(this[t]());return{type:t,value:s}}compound(){const t={};for(;;){const e=l[this.byte()];if("end"===e)break;const s=this.string(),i=this[e]();t[s]={type:e,value:i}}return t}}class u{constructor(t=!1){this.byte=this.writeNum.bind(this,"setInt8",1),this.short=this.writeNum.bind(this,"setInt16",2),this.int=this.writeNum.bind(this,"setInt32",4),this.float=this.writeNum.bind(this,"setFloat32",4),this.double=this.writeNum.bind(this,"setFloat64",8),this.offset=0,this.littleEndian=t,this.buffer=new ArrayBuffer(1024),this.arrayView=new Uint8Array(this.buffer),this.dataView=new DataView(this.buffer)}accommodate(t){const e=this.offset+t;if(this.buffer.byteLength>=e)return;let s=this.buffer.byteLength;for(;s<e;)s*=2;const i=new ArrayBuffer(s),n=new Uint8Array(i);n.set(this.arrayView),this.offset>this.buffer.byteLength&&n.fill(0,this.buffer.byteLength,this.offset),this.buffer=i,this.dataView=new DataView(i),this.arrayView=n}getData(){return this.accommodate(0),this.arrayView.slice(0,this.offset)}end(t){}writeNum(t,e,s){this.accommodate(e),this.dataView[t](this.offset,s,this.littleEndian),this.offset+=e}long(t){this.int(t[0]),this.int(t[1])}byteArray(t){this.int(t.length),this.accommodate(t.length),this.arrayView.set(t,this.offset),this.offset+=t.length}intArray(t){this.int(t.length);for(let e=0;e<t.length;e++)this.int(t[e])}longArray(t){this.int(t.length);for(let e=0;e<t.length;e++)this.long(t[e])}string(t){const e=function(t){var e,s,i=[];for(e=0;e<t.length;e++)(s=t.charCodeAt(e))<128?i.push(s):s<2048?(i.push(192|s>>6),i.push(128|63&s)):s<65536?(i.push(224|s>>12),i.push(128|s>>6&63),i.push(128|63&s)):(i.push(240|s>>18&7),i.push(128|s>>12&63),i.push(128|s>>6&63),i.push(128|63&s));return i}(t);this.short(e.length),this.accommodate(e.length),this.arrayView.set(e,this.offset),this.offset+=e.length}list(t){this.byte(a[t.type]),this.int(t.value.length),t.value;for(let e=0;e<t.value.length;e++)this[t.type](t.value[e])}compound(t){for(const e in t)this.byte(a[t[e].type]),this.string(e),this[t[e].type](t[e].value);this.byte(a.end)}}function c(t,e){const s=new h(t,e);if(s.byte()!==a.compound)throw new Error("Top tag should be a compound");return{name:s.string(),value:s.compound()}}function d(e,s){return c(pako__WEBPACK_IMPORTED_MODULE_0__["default"].inflate(e),s)}function f(t,e){return 2===(s=new Uint8Array(t.slice(0,2))).length&&31===s[0]&&139===s[1]?{compressed:!0,result:d(t,e)}:{compressed:!1,result:c(t,e)};var s}function g(t){const e=[];for(let s=0;s<32;s+=1)for(let i=0;i<32;i+=1){const n=4*((31&s)+32*(31&i));if(0===t[n+3])continue;const r=(t[n]<<16)+(t[n+1]<<8)+t[n+2],o=(t[n+4096]<<24)+(t[n+4097]<<16)+(t[n+4098]<<8)+t[n+4099],a=4096*r,l=(t[a]<<24)+(t[a+1]<<16)+(t[a+2]<<8)+t[a+3],h=t[a+4],u=t.slice(a+5,a+4+l);e.push({x:s,z:i,timestamp:o,compression:h,data:u})}return e}function p(t,e,s){const i=x(t,e,s);switch(i.compression){case 1:case 2:i.nbt=d(i.data);break;case 3:i.nbt=c(i.data);break;default:throw new Error(`Invalid compression mode ${i.compression}`)}return i}function m(t,e){const s=new u(e);return s.byte(a.compound),s.string(t.name),s.compound(t.value),s.getData()}function v(e,s,i){const n=m(e,s);return pako__WEBPACK_IMPORTED_MODULE_0__["default"][i?"deflate":"gzip"](n)}function b(t,e,s){return e?v(t,s):m(t,s)}function w(t){let e=0;for(const s of t)e+=Math.ceil(s.data.length/4096);const s=new Uint8Array(8192+4096*e),i=new DataView(s.buffer);let n=2;for(const e of t){const t=4*((31&e.x)+32*(31&e.z)),r=Math.ceil(e.data.length/4096);i.setInt8(t,n>>16),i.setInt16(t+1,65535&n),i.setInt8(t+3,r),i.setInt32(t+4096,e.timestamp);const o=4096*n;i.setInt32(o,e.data.length+1),i.setInt8(o+4,e.compression),s.set(e.data,o+5),n+=r}return s}function P(t,e,s,i){const n=x(t,e,s);switch(n.compression){case 1:n.data=v(i);break;case 2:n.data=v(i,!1,!0);break;case 3:n.data=m(i);break;default:throw new Error(`Invalid compression mode ${n.compression}`)}return n}function x(t,e,s){const i=t.find((t=>t.x===e&&t.z===s));if(void 0===i)throw new Error(`Cannot find chunk [${e}, ${s}]`);return i}function y(t,e,s){if(!t[e])throw new Error(`Missing ${e} tag`);if(t[e].type!==s)throw new Error(`Expected ${e} to be of type ${s}, but found ${t[e].type}`);return t[e].value}function A(t,e,s,i){const n=y(t,e,"list");if(n.type!==s)throw new Error(`Expected ${e} to be a list of ${s}s, but found ${n.type}s`);if(i&&n.value.length!==i)throw new Error(`Expected ${e} to be a list of length ${i}, but found length ${n.value.length}`);return n.value}function S(t,e){try{return t()}catch(t){return e}}class B{constructor(t,e={}){this.name=t,this.properties=e}getName(){return this.name}getProperties(){return this.properties}getProperty(t){return this.properties[t]}isFluid(){return"minecraft:water"===this.name||"minecraft:lava"===this.name}equals(t){return this.name===t.name&&Object.keys(this.properties).every((e=>t.properties[e]===this.properties[e]))}toString(){return 0===Object.keys(this.properties).length?this.name:`${this.name}[${Object.entries(this.properties).map((([t,e])=>t+"="+e)).join(",")}]`}static fromNbt(t){const e=y(t.value,"Name","string"),s=S((()=>y(t.value,"Properties","compound")),{}),i=Object.keys(s).reduce(((t,e)=>Object.assign(Object.assign({},t),{[e]:y(s,e,"string")})),{});return new B(e,i)}static fromJson(t){var e,s;const i=null!==(e=k.readObject(t))&&void 0!==e?e:{},n=null!==(s=k.readString(i.Name))&&void 0!==s?s:"minecraft:stone",r=k.readMap(i.Properties,(t=>{var e;return null!==(e=k.readString(t))&&void 0!==e?e:""}));return new B(n,r)}}B.AIR=new B("minecraft:air");class E{constructor(t){this.minY=t,this.storage=Array(E.SIZE),this.palette=[B.AIR]}get minBlockY(){return this.minY<<4}index(t,e,s){return(t<<8)+(e<<4)+s}getBlockState(t,e,s){var i;const n=this.storage[this.index(t,e,s)];return null!==(i=this.palette[n])&&void 0!==i?i:B.AIR}setBlockState(t,e,s,i){let n=this.palette.findIndex((t=>t.equals(i)));-1===n&&(n=this.palette.length,this.palette.push(i)),this.storage[this.index(t,e,s)]=n}}E.WIDTH=16,E.SIZE=E.WIDTH*E.WIDTH*E.WIDTH;class C{constructor(t,e,s){this.minY=t,this.height=e,this.pos=s,this.sections=Array(this.sectionsCount).fill(null)}get maxY(){return this.minY+this.height}get minSection(){return this.minY>>4}get maxSection(){return 1+(this.maxY-1>>4)}get sectionsCount(){return this.maxSection-this.minSection}getSectionIndex(t){return(t>>4)-this.minSection}getBlockState(t){var e;const[s,i,n]=t,r=this.sections[this.getSectionIndex(i)];return null!==(e=null==r?void 0:r.getBlockState(15&s,15&i,15&n))&&void 0!==e?e:B.AIR}setBlockState(t,e){const[s,i,n]=t,r=this.getSectionIndex(i);let o=this.sections[r];if(null===o){if(e.equals(B.AIR))return;o=this.getOrCreateSection(r)}o.setBlockState(15&s,15&i,15&n,e)}getOrCreateSection(t){return null==this.sections[t]&&(this.sections[t]=new E(this.minSection+t)),this.sections[t]}}var I,k,R;!function(t){t.create=function(t,e){return[t,e]},t.fromBlockPos=function(t){return[t[0]>>4,t[2]>>4]},t.fromLong=function(t){return[4294967295&Number(t),Number(t>>BigInt(32))]},t.minBlockX=function(t){return t[0]<<4},t.minBlockZ=function(t){return t[1]<<4},t.maxBlockX=function(t){return t[0]<<19},t.maxBlockZ=function(t){return t[1]<<19}}(I||(I={})),function(t){function e(t){return"object"==typeof t&&null!==t?t:void 0}t.readNumber=function(t){return"number"==typeof t?t:void 0},t.readInt=function(t){return"number"==typeof t?Math.floor(t):void 0},t.readString=function(t){return"string"==typeof t?t:void 0},t.readBoolean=function(t){return"boolean"==typeof t?t:void 0},t.readObject=e,t.readArray=function(t,e){if(Array.isArray(t))return t.map((t=>e(t)))},t.readMap=function(t,s){var i;const n=null!==(i=e(t))&&void 0!==i?i:{};return Object.fromEntries(Object.entries(n).map((([t,e])=>[t,s(e)])))},t.compose=function(t,e,s){const i=e(t);return i?s(i):void 0}}(k||(k={}));class _{constructor(t,e=[],s=[]){this.size=t,this.palette=e,this.blocks=s,this.blocksMap=[],s.forEach((e=>{if(!this.isInside(e.pos))throw new Error(`Found block at ${e.pos} which is outside the structure bounds ${this.size}`);this.blocksMap[e.pos[0]*t[1]*t[2]+e.pos[1]*t[2]+e.pos[2]]=e}))}getSize(){return this.size}addBlock(t,e,s,i){if(!this.isInside(t))throw new Error(`Cannot add block at ${t} outside the structure bounds ${this.size}`);const n=new B(e,s);let r=this.palette.findIndex((t=>t.equals(n)));return-1===r&&(r=this.palette.length,this.palette.push(n)),this.blocks.push({pos:t,state:r,nbt:i}),this.blocksMap[t[0]*this.size[1]*this.size[2]+t[1]*this.size[2]+t[2]]={pos:t,state:r,nbt:i},this}getBlocks(){return this.blocks.map((t=>({pos:t.pos,state:this.palette[t.state],nbt:t.nbt})))}getBlock(t){if(!this.isInside(t))return null;const e=this.blocksMap[t[0]*this.size[1]*this.size[2]+t[1]*this.size[2]+t[2]];if(!e)return null;return{pos:e.pos,state:this.palette[e.state],nbt:e.nbt}}isInside(t){return t[0]>=0&&t[0]<this.size[0]&&t[1]>=0&&t[1]<this.size[1]&&t[2]>=0&&t[2]<this.size[2]}static fromNbt(t){const e=A(t.value,"size","int",3),s=A(t.value,"palette","compound").map((t=>B.fromNbt({name:"",value:t}))),i=A(t.value,"blocks","compound").map((t=>({pos:A(t,"pos","int",3),state:y(t,"state","int"),nbt:S((()=>y(t,"nbt","compound")),void 0)})));return new _(e,s,i)}}function F(t){return t*t}function M(t,e,s){return Math.max(e,Math.min(s,t))}function N(t,e,s){return e+t*(s-e)}function T(t,e,s,i,n,r){return N(e,N(t,s,i),N(t,n,r))}function O(t,e,s,i,n,r,o,a,l,h,u){return N(s,T(t,e,i,n,r,o),T(t,e,a,l,h,u))}function U(t,e,s){return s<0?t:s>1?e:N(s,t,e)}function D(t){return t*t*t*(t*(6*t-15)+10)}function L(t,e,s){let i=e-t;for(;i>0;){const e=Math.floor(i/2),n=t+e;s(n)?i=e:(t=n+1,i-=e+1)}return t}class z{constructor(t){this.xo=256*t.nextDouble(),this.yo=256*t.nextDouble(),this.zo=256*t.nextDouble(),this.p=Array(256);for(let t=0;t<256;t+=1)this.p[t]=t;for(let e=0;e<256;e+=1){const s=t.nextInt(256-e),i=this.p[e];this.p[e]=this.p[e+s],this.p[e+s]=i}}sample2D(t,e){let s,i,n;const r=(t+e)*z.F2,o=Math.floor(t+r),a=t-(o-(s=(o+(i=Math.floor(e+r)))*z.G2));let l,h;a>(n=e-(i-s))?(l=1,h=0):(l=0,h=1);const u=a-l+z.G2,c=n-h+z.G2,d=a-1+2*z.G2,f=n-1+2*z.G2,g=255&o,p=255&i,m=this.P(g+this.P(p))%12,v=this.P(g+l+this.P(p+h))%12,b=this.P(g+1+this.P(p+1))%12;return 70*(this.getCornerNoise3D(m,a,n,0,.5)+this.getCornerNoise3D(v,u,c,0,.5)+this.getCornerNoise3D(b,d,f,0,.5))}sample(t,e,s){const i=.3333333333333333*(t+e+s),n=Math.floor(t+i),r=Math.floor(e+i),o=Math.floor(s+i),a=.16666666666666666*(n+r+o),l=t-(n-a),h=e-(r-a),u=s-(o-a);let c,d,f,g,p,m;l>=h?h>=u?(c=1,d=0,f=0,g=1,p=1,m=0):l>=u?(c=1,d=0,f=0,g=1,p=0,m=1):(c=0,d=0,f=1,g=1,p=0,m=1):h<u?(c=0,d=0,f=1,g=0,p=1,m=1):l<u?(c=0,d=1,f=0,g=0,p=1,m=1):(c=0,d=1,f=0,g=1,p=1,m=0);const v=l-c+.16666666666666666,b=h-d+.16666666666666666,w=u-f+.16666666666666666,P=l-g+.3333333333333333,x=h-p+.3333333333333333,y=u-m+.3333333333333333,A=l-.5,S=h-.5,B=u-.5,E=255&n,C=255&r,I=255&o,k=this.P(E+this.P(C+this.P(I)))%12,R=this.P(E+c+this.P(C+d+this.P(I+f)))%12,_=this.P(E+g+this.P(C+p+this.P(I+m)))%12,F=this.P(E+1+this.P(C+1+this.P(I+1)))%12;return 32*(this.getCornerNoise3D(k,l,h,u,.6)+this.getCornerNoise3D(R,v,b,w,.6)+this.getCornerNoise3D(_,P,x,y,.6)+this.getCornerNoise3D(F,A,S,B,.6))}P(t){return this.p[255&t]}getCornerNoise3D(t,e,s,i,n){let r,o=n-e*e-s*s-i*i;return o<0?r=0:(o*=o,r=o*o*z.gradDot(t,e,s,i)),r}static gradDot(t,e,s,i){const n=z.GRADIENT[15&t];return n[0]*e+n[1]*s+n[2]*i}}z.GRADIENT=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1],[1,1,0],[0,-1,1],[-1,1,0],[0,-1,-1]],z.F2=.5*(Math.sqrt(3)-1),z.G2=(3-Math.sqrt(3))/6;class V{constructor(t){this.xo=256*t.nextDouble(),this.yo=256*t.nextDouble(),this.zo=256*t.nextDouble(),this.p=Array(256);for(let t=0;t<256;t+=1)this.p[t]=t>127?t-256:t;for(let e=0;e<256;e+=1){const s=t.nextInt(256-e),i=this.p[e];this.p[e]=this.p[e+s],this.p[e+s]=i}}sample(t,e,s,i=0,n=0){const r=t+this.xo,o=e+this.yo,a=s+this.zo,l=Math.floor(r),h=Math.floor(o),u=Math.floor(a),c=r-l,d=o-h,f=a-u;let g=0;if(0!==i){const t=n>=0&&n<d?n:d;g=Math.floor(t/i+1e-7)*i}return this.sampleAndLerp(l,h,u,c,d-g,f,d)}sampleAndLerp(t,e,s,i,n,r,o){const a=this.P(t),l=this.P(t+1),h=this.P(a+e),u=this.P(a+e+1),c=this.P(l+e),d=this.P(l+e+1),f=z.gradDot(this.P(h+s),i,n,r),g=z.gradDot(this.P(c+s),i-1,n,r),p=z.gradDot(this.P(u+s),i,n-1,r),m=z.gradDot(this.P(d+s),i-1,n-1,r),v=z.gradDot(this.P(h+s+1),i,n,r-1),b=z.gradDot(this.P(c+s+1),i-1,n,r-1),w=z.gradDot(this.P(u+s+1),i,n-1,r-1),P=z.gradDot(this.P(d+s+1),i-1,n-1,r-1);return O(D(i),D(o),D(r),f,g,p,m,v,b,w,P)}P(t){return 255&this.p[255&t]}}class j{constructor(t,e,s){if(1-e<s.length)throw new Error("Positive octaves are not allowed");this.noiseLevels=Array(s.length);for(let i=-e;i>=0;i-=1)i<s.length&&0!==s[i]?this.noiseLevels[i]=new V(t):t.consume(262);this.amplitudes=s,this.lowestFreqInputFactor=Math.pow(2,e),this.lowestFreqValueFactor=Math.pow(2,s.length-1)/(Math.pow(2,s.length)-1)}sample(t,e,s,i=0,n=0,r=!1){let o=0,a=this.lowestFreqInputFactor,l=this.lowestFreqValueFactor;for(let h=0;h<this.noiseLevels.length;h+=1){const u=this.noiseLevels[h];u&&(o+=this.amplitudes[h]*l*u.sample(j.wrap(t*a),r?-u.yo:j.wrap(e*a),j.wrap(s*a),i*a,n*a)),a*=2,l/=2}return o}getOctaveNoise(t){return this.noiseLevels[this.noiseLevels.length-1-t]}static wrap(t){return t-33554432*Math.floor(t/33554432+.5)}}class Y{constructor(t){this.minLimitNoise=new j(t,-15,[1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0]),this.maxLimitNoise=new j(t,-15,[1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0]),this.mainNoise=new j(t,-7,[1,1,1,1,1,0,0,0])}sample(t,e,s,i,n,r,o){let a,l=0,h=1;for(let i=0;i<8;i+=1){if(a=this.mainNoise.getOctaveNoise(i),a){const i=r*h,n=o*h,u=j.wrap(t*i),c=j.wrap(e*n),d=j.wrap(s*i);l+=a.sample(u,c,d,n,e*n)/h}h/=2}l=(l/10+1)/2,h=1;let u=0,c=0;for(let r=0;r<16;r+=1){const o=i*h,d=n*h,f=j.wrap(t*o),g=j.wrap(e*d),p=j.wrap(s*o);l<1&&(a=this.minLimitNoise.getOctaveNoise(r))&&(u+=a.sample(f,g,p,d,e*d)/h),l>0&&(a=this.maxLimitNoise.getOctaveNoise(r))&&(c+=a.sample(f,g,p,d,e*d)/h),h/=2}return U(u/512,c/512,l)}}class X{constructor(t,{firstOctave:e,amplitudes:s}){this.first=new j(t,e,s),this.second=new j(t,e,s);let i=1/0,n=-1/0;for(let t=0;t<s.length;t+=1)0!==s[t]&&(i=Math.min(i,t),n=Math.max(n,t));const r=.1*(1+1/(n-i+1));this.valueFactor=1/6/r}sample(t,e,s){const i=t*X.INPUT_FACTOR,n=e*X.INPUT_FACTOR,r=s*X.INPUT_FACTOR;return(this.first.sample(t,e,s)+this.second.sample(i,n,r))*this.valueFactor}}X.INPUT_FACTOR=1.0181268882175227,function(t){t.fromJson=function(t){var e,s,i;const n=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{firstOctave:null!==(s=k.readInt(n.firstOctave))&&void 0!==s?s:0,amplitudes:null!==(i=k.readArray(n.amplitudes,(t=>{var e;return null!==(e=k.readNumber(t))&&void 0!==e?e:0})))&&void 0!==i?i:[]}}}(R||(R={}));class H{constructor(t,e){const s=e[e.length-1],i=-e[0]+s+1,n=new Set(e),r=new z(t);this.noiseLevels=Array(i),s>=0&&s<i&&n.has(0)&&(this.noiseLevels[s]=r);for(let e=s+1;e<i;e+=1)e>=0&&n.has(s-e)?this.noiseLevels[e]=new z(t):t.consume(262);if(s>0)throw new Error("Positive octaves are not allowed");this.highestFreqInputFactor=Math.pow(2,s),this.highestFreqValueFactor=1/(Math.pow(2,i)-1)}sample(t,e,s){let i=0,n=this.highestFreqInputFactor,r=this.highestFreqValueFactor;for(let o=0;o<this.noiseLevels.length;o+=1){const a=this.noiseLevels[o];a&&(i+=r*a.sample2D(t*n+(s?a.xo:0),e*n+(s?a.yo:0))),n/=2,r*=2}return i}}class W{constructor(t){this.seed=BigInt(0),this.setSeed(t)}fork(){return new W(this.nextLong())}setSeed(t){this.seed=t^W.MULTIPLIER&W.MODULUS_MASK}advance(){this.seed=this.seed*W.MULTIPLIER+W.INCREMENT&W.MODULUS_MASK}consume(t){for(let e=0;e<t;e+=1)this.advance()}next(t){this.advance();const e=Number(this.seed>>BigInt(W.MODULUS_BITS-t));return e>2147483647?e-4294967296:e}nextInt(t){if(void 0===t)return this.next(32);if(0==(t&t-1))return Number(BigInt(t)*BigInt(this.next(31))>>BigInt(31));let e,s;for(;(e=this.next(31))-(s=e%t)+(t-1)<0;);return s}nextLong(){return(BigInt(this.next(32))<<BigInt(32))+BigInt(this.next(32))}nextFloat(){return this.next(24)*W.FLOAT_MULTIPLIER}nextDouble(){const t=this.next(30);return this.advance(),t*W.DOUBLE_MULTIPLIER}}W.MODULUS_BITS=48,W.MODULUS_MASK=BigInt("281474976710655"),W.MULTIPLIER=BigInt("25214903917"),W.INCREMENT=BigInt("11"),W.FLOAT_MULTIPLIER=1/Math.pow(2,24),W.DOUBLE_MULTIPLIER=1/Math.pow(2,30);class J extends W{constructor(){super(...arguments),this.count=0}getCount(){return this.count}next(t){return this.count+=1,super.next(t)}}class Z{constructor(t,e,s=[],i=[],n=[]){this.name=t,this.coordinate=e,this.locations=s,this.values=i,this.derivatives=n}apply(t){const e=this.coordinate(t),s=L(0,this.locations.length,(t=>e<this.locations[t]))-1,i=this.locations.length-1;if(s<0)return this.values[0](t)+this.derivatives[0]*(e-this.locations[0]);if(s===i)return this.values[i](t)+this.derivatives[i]*(e-this.locations[i]);const n=this.locations[s],r=this.locations[s+1],o=this.derivatives[s],a=this.derivatives[s+1],l=(e-n)/(r-n),h=this.values[s](t),u=this.values[s+1](t),c=o*(r-n)-(u-h),d=-a*(r-n)+(u-h);return N(l,h,u)+l*(1-l)*N(l,c,d)}addPoint(t,e,s=0){return this.locations.push(t),this.values.push("number"==typeof e?()=>e:e.apply.bind(e)),this.derivatives.push(s),this}}const $=t=>[(t>>16&255)/256,(t>>8&255)/256,(255&t)/256],G=[124/256,189/256,107/256],q=$(6396257),K=$(8431445),Q=$(4764952),tt=$(4159204),et=$(8431445),st=$(2129968),it=t=>[t/8,1-t/32,64*t],nt={large_fern:()=>G,tall_grass:()=>G,grass_block:()=>G,fern:()=>G,grass:()=>G,potted_fern:()=>G,spruce_leaves:()=>q,birch_leaves:()=>K,oak_leaves:()=>Q,jungle_leaves:()=>Q,acacia_leaves:()=>Q,dark_oak_leaves:()=>Q,vine:()=>Q,water:()=>tt,bubble_column:()=>tt,cauldron:()=>tt,redstone_wire:t=>{var e;return(t=>{const e=t/15;return[.6*e+(e>0?.4:.3),M(e*e*.7-.5,0,1),M(e*e*.6-.7,0,1)]})(parseInt(null!==(e=t.power)&&void 0!==e?e:"0"))},sugar_cane:()=>G,attached_melon_stem:()=>et,attached_pumpkin_stem:()=>et,melon_stem:t=>{var e;return it(parseInt(null!==(e=t.age)&&void 0!==e?e:"0"))},pumpkin_stem:t=>{var e;return it(parseInt(null!==(e=t.age)&&void 0!==e?e:"0"))},lily_pad:()=>st};var rt;function ot(...t){let e=0;for(const s of t)e+=s.length;const s=new Float32Array(e);let i=0;for(const e of t)s.set(e,i),i+=e.length;return s}function at(t,s){const i=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();for(let n=0;n<t.length;n+=3)i[0]=t[n],i[1]=t[n+1],i[2]=t[n+2],gl_matrix__WEBPACK_IMPORTED_MODULE_1__.transformMat4(i,i,s),t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2]}!function(t){t.rotate=function(t,e,s){let{up:i,down:n,north:r,east:o,south:a,west:l}=t;switch(s){case 90:[r,o,a,l]=[o,a,l,r];break;case 180:[r,o,a,l]=[a,l,r,o];break;case 270:[r,o,a,l]=[l,r,o,a]}switch(e){case 90:[i,r,n,a]=[r,n,a,i];break;case 180:[i,r,n,a]=[n,a,i,r];break;case 270:[i,r,n,a]=[a,i,r,n]}return{up:i,down:n,north:r,east:o,south:a,west:l}}}(rt||(rt={}));class lt{constructor(t,e,s){this.id=t,this.variants=e,this.multipart=s,this.variants=e}getModelVariants(t){if(this.variants){const e=Object.keys(this.variants).filter((e=>this.matchesVariant(e,t)));if(0===e.length)return[];const s=this.variants[e[0]];return[Array.isArray(s)?s[0]:s]}if(this.multipart){return this.multipart.filter((e=>!e.when||this.matchesCase(e.when,t))).map((t=>Array.isArray(t.apply)?t.apply[0]:t.apply))}return[]}getBuffers(t,e,n,r,o,a){var l,h,u,c;const d=this.getModelVariants(e),f=[],g=[],p=[],m=[];for(const v of d){const d=rt.rotate(a,null!==(l=v.x)&&void 0!==l?l:0,null!==(h=v.y)&&void 0!==h?h:0),b=r.getBlockModel(v.model).getBuffers(t,e,n,o,d);if(v.x||v.y){const t=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(t,t,[8,8,8]),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateY(t,t,-gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(null!==(u=v.y)&&void 0!==u?u:0)),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateX(t,t,-gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(null!==(c=v.x)&&void 0!==c?c:0)),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(t,t,[-8,-8,-8]),at(b.position,t)}f.push(b.position),g.push(...b.texCoord),p.push(...b.tintColor),m.push(...b.index),o+=b.texCoord.length/2}const v=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(v),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(v,v,[.0625,.0625,.0625]);const b=ot(...f);return at(b,v),{position:b,texCoord:g,tintColor:p,index:m}}matchesVariant(t,e){return t.split(",").every((t=>{const[s,i]=t.split("=");return e[s]===i}))}matchesCase(t,e){if(Array.isArray(t.OR))return t.OR.some((t=>this.matchesCase(t,e)));const s=t;return Object.keys(s).every((t=>s[t].split("|").includes(e[t])))}static fromJson(t,e){return new lt(t,e.variants,e.multipart)}}const ht={0:[0,3,2,3,2,1,0,1],90:[2,3,2,1,0,1,0,3],180:[2,1,0,1,0,3,2,3],270:[0,1,0,3,2,3,2,1]},ut={x:[1,0,0],y:[0,1,0],z:[0,0,1]},ct=1.41421356237,dt={x:[1,ct,ct],y:[ct,1,ct],z:[ct,ct,1]};class ft{constructor(t,e,s,i){this.id=t,this.parent=e,this.textures=s,this.elements=i,this.flattened=!1}getBuffers(t,e,s,i,n){var r;const o=[],a=[],l=[],h=[];for(const u of null!==(r=this.elements)&&void 0!==r?r:[]){const r=this.getElementBuffers(t,e,u,i,s,n);o.push(r.position),a.push(...r.texCoord),l.push(...r.tintColor),h.push(...r.index),i+=r.texCoord.length/2}return{position:ot(...o),texCoord:a,tintColor:l,index:h}}getElementBuffers(t,n,r,o,a,l){var h,u,c,d,f,g,p,m,v,b,w,P;const x=r.from[0],y=r.from[1],A=r.from[2],S=r.to[0],B=r.to[1],E=r.to[2],C=[],I=[],k=[],R=[],_=(e,s,i)=>{var r,l,h,u,c,d,f,g,p,m,v,b;const[w,P,x,y]=a.getTextureUV(this.getTexture(e.texture)),A=(x-w)/16,S=(y-P)/16,B=A/16,E=S/16;s[0]=(null!==(l=null===(r=e.uv)||void 0===r?void 0:r[0])&&void 0!==l?l:s[0])*A+B,s[1]=(null!==(u=null===(h=e.uv)||void 0===h?void 0:h[1])&&void 0!==u?u:s[1])*S+E,s[2]=(null!==(d=null===(c=e.uv)||void 0===c?void 0:c[2])&&void 0!==d?d:s[2])*A-B,s[3]=(null!==(g=null===(f=e.uv)||void 0===f?void 0:f[3])&&void 0!==g?g:s[3])*S-E;const _=ht[null!==(p=e.rotation)&&void 0!==p?p:0];I.push(w+s[_[0]],P+s[_[1]],w+s[_[2]],P+s[_[3]],w+s[_[4]],P+s[_[5]],w+s[_[6]],P+s[_[7]]);const F=(null!==(m=e.tintindex)&&void 0!==m?m:-1)>=0&&null!==(b=null===(v=nt[t.slice(10)])||void 0===v?void 0:v.call(nt,n))&&void 0!==b?b:[1,1,1];k.push(...F,...F,...F,...F),C.push(...i),R.push(o,o+1,o+2,o,o+2,o+3),o+=4};!(null===(u=null===(h=r.faces)||void 0===h?void 0:h.up)||void 0===u?void 0:u.texture)||r.faces.up.cullface&&l[r.faces.up.cullface]||_(r.faces.up,[x,16-E,S,16-A],[x,B,E,S,B,E,S,B,A,x,B,A]),!(null===(d=null===(c=r.faces)||void 0===c?void 0:c.down)||void 0===d?void 0:d.texture)||r.faces.down.cullface&&l[r.faces.down.cullface]||_(r.faces.down,[16-E,16-S,16-A,16-x],[x,y,A,S,y,A,S,y,E,x,y,E]),!(null===(g=null===(f=r.faces)||void 0===f?void 0:f.south)||void 0===g?void 0:g.texture)||r.faces.south.cullface&&l[r.faces.south.cullface]||_(r.faces.south,[x,16-B,S,16-y],[x,y,E,S,y,E,S,B,E,x,B,E]),!(null===(m=null===(p=r.faces)||void 0===p?void 0:p.north)||void 0===m?void 0:m.texture)||r.faces.north.cullface&&l[r.faces.north.cullface]||_(r.faces.north,[16-S,16-B,16-x,16-y],[S,y,A,x,y,A,x,B,A,S,B,A]),!(null===(b=null===(v=r.faces)||void 0===v?void 0:v.east)||void 0===b?void 0:b.texture)||r.faces.east.cullface&&l[r.faces.east.cullface]||_(r.faces.east,[16-E,16-B,16-A,16-y],[S,y,E,S,y,A,S,B,A,S,B,E]),!(null===(P=null===(w=r.faces)||void 0===w?void 0:w.west)||void 0===P?void 0:P.texture)||r.faces.west.cullface&&l[r.faces.west.cullface]||_(r.faces.west,[A,16-B,E,16-y],[x,y,A,x,y,E,x,B,E,x,B,A]);const F=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();if(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.identity(F),r.rotation){const t=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(...r.rotation.origin);gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(F,F,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate(F,F,gl_matrix__WEBPACK_IMPORTED_MODULE_3__.toRadian(r.rotation.angle),ut[r.rotation.axis]),r.rotation.rescale&&gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(F,F,dt[r.rotation.axis]),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.negate(t,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(F,F,t)}const M=new Float32Array(C);return at(M,F),{position:M,texCoord:I,tintColor:k,index:R}}getTexture(t){for(var e,s;t.startsWith("#");)t=null!==(s=null===(e=this.textures)||void 0===e?void 0:e[t.slice(1)])&&void 0!==s?s:"";return t.startsWith("minecraft:")||(t="minecraft:"+t),t}flatten(t){var e;if(!this.flattened&&this.parent){const s=t.getBlockModel(this.parent);if(!s)return console.warn(`parent ${this.parent} does not exist!`),void(this.flattened=!0);s.flatten(t),this.elements||(this.elements=s.elements),this.textures||(this.textures={}),Object.keys(null!==(e=s.textures)&&void 0!==e?e:{}).forEach((t=>{this.textures[t]||(this.textures[t]=s.textures[t])})),this.flattened=!0}}static fromJson(t,e){let s=e.parent;return s&&!s.startsWith("minecraft:")&&(s="minecraft:"+s),new ft(t,s,e.textures,e.elements)}}class gt{constructor(t,e,s){this.gl=t,this.program=this.initShaderProgram(e,s)}getProgram(){return this.program}initShaderProgram(t,e){const s=this.loadShader(this.gl.VERTEX_SHADER,t),i=this.loadShader(this.gl.FRAGMENT_SHADER,e),n=this.gl.createProgram();if(this.gl.attachShader(n,s),this.gl.attachShader(n,i),this.gl.linkProgram(n),!this.gl.getProgramParameter(n,this.gl.LINK_STATUS))throw new Error(`Unable to link shader program: ${this.gl.getProgramInfoLog(n)}`);return n}loadShader(t,e){const s=this.gl.createShader(t);if(this.gl.shaderSource(s,e),this.gl.compileShader(s),!this.gl.getShaderParameter(s,this.gl.COMPILE_STATUS)){const e=new Error(`Compiling ${t===this.gl.VERTEX_SHADER?"vertex":"fragment"} shader: ${this.gl.getShaderInfoLog(s)}`);throw this.gl.deleteShader(s),e}return s}}function pt(t,e,s,i,n){const r=new lt("",{"":{model:""}},void 0),o={getBlockModel:()=>n};return n.flatten(o),r.getBuffers(t,{},e,o,s,i)}function mt(t,e,s,i,r,o){const a=r.up?16:[14.2,12.5,10.5,9,7,5.3,3.7,1.9,16,16,16,16,16,16,16,16][s];return pt(`minecraft:${t}`,i,e,r,new ft("","",{still:`minecraft:block/${t}_still`,flow:`minecraft:block/${t}_flow`},[{from:[0,0,0],to:[16,a,16],faces:{up:{texture:"#still",tintindex:o,cullface:n.UP},down:{texture:"#still",tintindex:o,cullface:n.DOWN},north:{texture:"#flow",tintindex:o,cullface:n.NORTH},east:{texture:"#flow",tintindex:o,cullface:n.EAST},south:{texture:"#flow",tintindex:o,cullface:n.SOUTH},west:{texture:"#flow",tintindex:o,cullface:n.WEST}}}]))}const vt={"minecraft:water":(t,e,s,i)=>mt("water",t,parseInt(e.level),s,i,0),"minecraft:lava":(t,e,s,i)=>mt("lava",t,parseInt(e.level),s,i),"minecraft:chest":(t,e,s)=>function(t,e,s,i){return pt("minecraft:chest",i,t,{},new ft("","",{0:"minecraft:block/chest"},[{from:[1,0,1],to:[15,14,15],faces:{up:{texture:"#0"},down:{texture:"#0"},north:{texture:"#0"},east:{texture:"#0"},south:{texture:"#0"},west:{texture:"#0"}}}]))}(t,e.facing,e.type,s)},bt=new Set(Object.keys(vt));class wt{constructor(t,e,s,i){var n,r;this.gl=t,this.structure=e,this.resources=s,this.chunks=[],(null==i?void 0:i.facesPerBuffer)&&console.warn("webgl render warning: facesPerBuffer option has been removed in favor of chunkSize"),this.chunkSize=null!==(n=null==i?void 0:i.chunkSize)&&void 0!==n?n:16,this.useInvisibleBlockBuffer=null===(r=null==i?void 0:i.useInvisibleBlockBuffer)||void 0===r||r,this.shaderProgram=new gt(t,"\n  attribute vec4 vertPos;\n  attribute vec2 texCoord;\n  attribute vec3 tintColor;\n  attribute vec3 normal;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec2 vTexCoord;\n  varying highp vec3 vTintColor;\n  varying highp float vLighting;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vTexCoord = texCoord;\n    vTintColor = tintColor;\n    vLighting = normal.y * 0.2 + abs(normal.z) * 0.1 + 0.8;\n  }\n","\n  precision highp float;\n  varying highp vec2 vTexCoord;\n  varying highp vec3 vTintColor;\n  varying highp float vLighting;\n\n  uniform sampler2D sampler;\n\n  void main(void) {\n    vec4 texColor = texture2D(sampler, vTexCoord);\n    if(texColor.a < 0.01) discard;\n    gl_FragColor = vec4(texColor.xyz * vTintColor * vLighting, texColor.a);\n  }\n").getProgram(),this.gridShaderProgram=new gt(t,"\n  attribute vec4 vertPos;\n  attribute vec3 vertColor;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vColor = vertColor;\n  }\n","\n  precision highp float;\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n").getProgram(),this.colorShaderProgram=new gt(t,"\n  attribute vec4 vertPos;\n  attribute vec3 blockPos;\n\n  uniform mat4 mView;\n  uniform mat4 mProj;\n\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_Position = mProj * mView * vertPos;\n    vColor = blockPos / 256.0;\n  }\n","\n  precision highp float;\n  varying highp vec3 vColor;\n\n  void main(void) {\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n").getProgram(),this.updateStructureBuffers(),this.gridBuffers=this.getGridBuffers(),this.outlineBuffers=this.getOutlineBuffers(),this.invisibleBlockBuffers=this.getInvisibleBlockBuffers(),this.atlasTexture=this.getBlockTexture(),this.projMatrix=this.getPerspective(),this.activeShader=this.shaderProgram,this.initialize()}setStructure(t){this.structure=t,this.updateStructureBuffers(),this.gridBuffers=this.getGridBuffers(),this.invisibleBlockBuffers=this.getInvisibleBlockBuffers()}initialize(){this.gl.enable(this.gl.DEPTH_TEST),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK)}getBlockTexture(){const t=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,this.resources.getTextureAtlas()),this.gl.generateMipmap(this.gl.TEXTURE_2D),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),t}getPerspective(){const t=70*Math.PI/180,e=this.gl.canvas.clientWidth/this.gl.canvas.clientHeight,i=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();return gl_matrix__WEBPACK_IMPORTED_MODULE_2__.perspective(i,t,e,.1,500),i}getChunk(t){const e=2*Math.abs(t[0])+(t[0]<0?1:0),s=2*Math.abs(t[1])+(t[1]<0?1:0),i=2*Math.abs(t[2])+(t[2]<0?1:0);return this.chunks[e]||(this.chunks[e]=[]),this.chunks[e][s]||(this.chunks[e][s]=[]),this.chunks[e][s][i]||(this.chunks[e][s][i]={positions:[],textureCoordinates:[],tintColors:[],blockPositions:[],normals:[],indices:[],indexOffset:0}),this.chunks[e][s][i]}updateStructureBuffers(t){var i;const r=(t,i,n)=>{const r=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(r,r,i),at(t.position,r),n.positions.push(t.position),n.textureCoordinates.push(...t.texCoord),n.tintColors.push(...t.tintColor);for(let s=0;s<t.position.length;s+=12){const i=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s],t.position[s+1],t.position[s+2]),r=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s+3],t.position[s+4],t.position[s+5]),o=gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(t.position[s+6],t.position[s+7],t.position[s+8]);gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(r,r,i),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(o,o,i),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.cross(r,r,o),gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(r,r),n.normals.push(...r,...r,...r,...r)}for(let e=0;e<t.texCoord.length/2;e+=1)n.blockPositions.push(...i);n.indices.push(...t.index),n.indexOffset+=t.texCoord.length/2},o=t=>{t.positions=[],t.textureCoordinates=[],t.tintColors=[],t.blockPositions=[],t.normals=[],t.indices=[],t.indexOffset=0},a=t=>{t.buffer?(this.updateBuffer(t.buffer.position,this.gl.ARRAY_BUFFER,ot(...t.positions)),this.updateBuffer(t.buffer.texCoord,this.gl.ARRAY_BUFFER,new Float32Array(t.textureCoordinates)),this.updateBuffer(t.buffer.tintColor,this.gl.ARRAY_BUFFER,new Float32Array(t.tintColors)),this.updateBuffer(t.buffer.normal,this.gl.ARRAY_BUFFER,new Float32Array(t.normals)),this.updateBuffer(t.buffer.blockPos,this.gl.ARRAY_BUFFER,new Float32Array(t.blockPositions)),this.updateBuffer(t.buffer.index,this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t.indices)),t.buffer.length=t.indices.length):t.buffer={position:this.createBuffer(this.gl.ARRAY_BUFFER,ot(...t.positions)),texCoord:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.textureCoordinates)),tintColor:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.tintColors)),blockPos:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.blockPositions)),normal:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t.normals)),index:this.createBuffer(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t.indices)),length:t.indices.length}};let l;t?t.forEach((t=>{const e=this.getChunk(t);o(e)})):this.chunks.forEach((t=>t.forEach((t=>t.forEach((t=>{o(t)}))))));for(const s of this.structure.getBlocks()){const o=s.state.getName(),a=s.state.getProperties(),h=null!==(i=this.resources.getDefaultBlockProperties(o))&&void 0!==i?i:{};Object.entries(h).forEach((([t,e])=>{a[t]||(a[t]=e)}));const u=[Math.floor(s.pos[0]/this.chunkSize),Math.floor(s.pos[1]/this.chunkSize),Math.floor(s.pos[2]/this.chunkSize)];if(t&&!t.some((t=>gl_matrix__WEBPACK_IMPORTED_MODULE_1__.equals(t,u))))continue;const c=this.getChunk(u);try{const t=this.resources.getBlockDefinition(o),e={up:this.needsCull(s,n.UP),down:this.needsCull(s,n.DOWN),west:this.needsCull(s,n.WEST),east:this.needsCull(s,n.EAST),north:this.needsCull(s,n.NORTH),south:this.needsCull(s,n.SOUTH)};t&&(l=t.getBuffers(o,a,this.resources,this.resources,c.indexOffset,e),r(l,s.pos,c)),bt.has(o)&&(l=vt[o](c.indexOffset,a,this.resources,e),r(l,s.pos,c))}catch(t){console.error(`Error rendering block ${o}`,t)}}t?t.forEach((t=>{const e=this.getChunk(t);a(e)})):this.chunks.forEach((t=>t.forEach((t=>t.forEach((t=>{a(t)}))))))}needsCull(t,e){var s,i;const r=null===(s=this.structure.getBlock(o.towards(t.pos,e)))||void 0===s?void 0:s.state;return!!r&&((null===(i=this.resources.getBlockFlags(r.getName()))||void 0===i?void 0:i.opaque)?!(e===n.UP&&t.state.isFluid()):t.state.isFluid()&&r.isFluid())}getGridBuffers(){const[t,e,s]=this.structure.getSize(),i=[],n=[];i.push(0,0,0,t,0,0),n.push(1,0,0,1,0,0),i.push(0,0,0,0,0,s),n.push(0,0,1,0,0,1),i.push(0,0,0,0,e,0),i.push(t,0,0,t,e,0),i.push(0,0,s,0,e,s),i.push(t,0,s,t,e,s),i.push(0,e,0,0,e,s),i.push(t,e,0,t,e,s),i.push(0,e,0,t,e,0),i.push(0,e,s,t,e,s);for(let e=1;e<=t;e+=1)i.push(e,0,0,e,0,s);for(let e=1;e<=s;e+=1)i.push(0,0,e,t,0,e);for(let e=0;e<8+t+s;e+=1)n.push(.8,.8,.8,.8,.8,.8);return{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(i)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(n)),length:i.length/3}}getOutlineBuffers(){const t=[],e=[];return this.addCube(t,e,[1,1,1],[0,0,0],[1,1,1]),{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(t)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(e)),length:t.length/3}}getInvisibleBlockBuffers(){if(!this.useInvisibleBlockBuffer)return;const t=this.structure.getSize(),e=[],s=[];for(let i=0;i<t[0];i+=1)for(let n=0;n<t[1];n+=1)for(let r=0;r<t[2];r+=1){const t=this.structure.getBlock([i,n,r]);void 0!==t&&(null===t?this.addCube(e,s,[1,.25,.25],[i+.4375,n+.4375,r+.4375],[i+.5625,n+.5625,r+.5625]):"minecraft:air"===t.state.getName()?this.addCube(e,s,[.5,.5,1],[i+.375,n+.375,r+.375],[i+.625,n+.625,r+.625]):"minecraft:cave_air"===t.state.getName()&&this.addCube(e,s,[.5,1,.5],[i+.375,n+.375,r+.375],[i+.625,n+.625,r+.625]))}return{position:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(e)),color:this.createBuffer(this.gl.ARRAY_BUFFER,new Float32Array(s)),length:e.length/3}}addCube(t,e,s,i,n){t.push(i[0],i[1],i[2],i[0],i[1],n[2]),t.push(n[0],i[1],i[2],n[0],i[1],n[2]),t.push(i[0],i[1],i[2],n[0],i[1],i[2]),t.push(i[0],i[1],n[2],n[0],i[1],n[2]),t.push(i[0],i[1],i[2],i[0],n[1],i[2]),t.push(n[0],i[1],i[2],n[0],n[1],i[2]),t.push(i[0],i[1],n[2],i[0],n[1],n[2]),t.push(n[0],i[1],n[2],n[0],n[1],n[2]),t.push(i[0],n[1],i[2],i[0],n[1],n[2]),t.push(n[0],n[1],i[2],n[0],n[1],n[2]),t.push(i[0],n[1],i[2],n[0],n[1],i[2]),t.push(i[0],n[1],n[2],n[0],n[1],n[2]);for(let t=0;t<24;t+=1)e.push(...s)}createBuffer(t,e){const s=this.gl.createBuffer();return this.gl.bindBuffer(t,s),this.gl.bufferData(t,e,this.gl.DYNAMIC_DRAW),s}updateBuffer(t,e,s){this.gl.bindBuffer(e,t),this.gl.bufferData(e,s,this.gl.STATIC_DRAW)}drawGrid(t){this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.gridBuffers.position),this.setVertexAttr("vertColor",3,this.gridBuffers.color),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.gridBuffers.length)}drawInvisibleBlocks(t){this.useInvisibleBlockBuffer&&(this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.invisibleBlockBuffers.position),this.setVertexAttr("vertColor",3,this.invisibleBlockBuffers.color),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.invisibleBlockBuffers.length))}drawStructure(t){this.setShader(this.shaderProgram),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.atlasTexture),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.chunks.forEach((t=>{t.forEach((t=>{t.forEach((t=>{t.buffer&&(this.setVertexAttr("vertPos",3,t.buffer.position),this.setVertexAttr("texCoord",2,t.buffer.texCoord),this.setVertexAttr("tintColor",3,t.buffer.tintColor),this.setVertexAttr("normal",3,t.buffer.normal),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer.index),this.gl.drawElements(this.gl.TRIANGLES,t.buffer.length,this.gl.UNSIGNED_SHORT,0))}))}))}))}drawColoredStructure(t){this.setShader(this.colorShaderProgram),this.setUniform("mView",t),this.setUniform("mProj",this.projMatrix),this.chunks.forEach((t=>{t.forEach((t=>{t.forEach((t=>{t.buffer&&(this.setVertexAttr("vertPos",3,t.buffer.position),this.setVertexAttr("blockPos",3,t.buffer.blockPos),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.buffer.index),this.gl.drawElements(this.gl.TRIANGLES,t.buffer.length,this.gl.UNSIGNED_SHORT,0))}))}))}))}drawOutline(t,e){this.setShader(this.gridShaderProgram),this.setVertexAttr("vertPos",3,this.outlineBuffers.position),this.setVertexAttr("vertColor",3,this.outlineBuffers.color);const i=gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();gl_matrix__WEBPACK_IMPORTED_MODULE_2__.copy(i,t),gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(i,i,e),this.setUniform("mView",i),this.setUniform("mProj",this.projMatrix),this.gl.drawArrays(this.gl.LINES,0,this.outlineBuffers.length)}setViewport(t,e,s,i){this.gl.viewport(t,e,s,i),this.projMatrix=this.getPerspective()}setShader(t){this.gl.useProgram(t),this.activeShader=t}setVertexAttr(t,e,s){const i=this.gl.getAttribLocation(this.activeShader,t);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s),this.gl.vertexAttribPointer(i,e,this.gl.FLOAT,!1,0,0),this.gl.enableVertexAttribArray(i)}setUniform(t,e){const s=this.gl.getUniformLocation(this.activeShader,t);this.gl.uniformMatrix4fv(s,!1,e)}}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function Pt(t,e,s,i){return new(s||(s=Promise))((function(n,r){function o(t){try{l(i.next(t))}catch(t){r(t)}}function a(t){try{l(i.throw(t))}catch(t){r(t)}}function l(t){var e;t.done?n(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(o,a)}l((i=i.apply(t,e||[])).next())}))}class xt{constructor(t,e){this.img=t,this.idMap=e,this.part=16/t.width}getTextureAtlas(){return this.img}getTextureUV(t){var e;return null!==(e=this.idMap[t])&&void 0!==e?e:[0,0,this.part,this.part]}static fromBlobs(t){return Pt(this,void 0,void 0,(function*(){const e=Math.sqrt(Object.keys(t).length+1),s=Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))),i=16*s,n=1/s,r=document.createElement("canvas");r.width=i,r.height=i;const o=r.getContext("2d");this.drawInvalidTexture(o);const a={};let l=1;return yield Promise.all(Object.keys(t).map((e=>Pt(this,void 0,void 0,(function*(){const i=l%s,r=Math.floor(l/s);l+=1,a[e]=[n*i,n*r,n*i+n,n*r+n];const h=yield createImageBitmap(t[e]);o.drawImage(h,0,0,16,16,16*i,16*r,16,16)}))))),new xt(o.getImageData(0,0,i,i),a)}))}static empty(){const t=document.createElement("canvas");t.width=16,t.height=16;const e=t.getContext("2d");return xt.drawInvalidTexture(e),new xt(e.getImageData(0,0,16,16),{})}static drawInvalidTexture(t){t.fillStyle="black",t.fillRect(0,0,16,16),t.fillStyle="magenta",t.fillRect(0,0,8,8),t.fillRect(8,8,8,8)}}var yt,At,St,Bt,Et,Ct,It,kt;!function(t){function e(t,e){return"number"==typeof t?new s(t,null!=e?e:t):t}t.target=function(t,e,s,i,r,o){return new n(t,e,s,i,r,o)},t.parameters=function(t,s,n,r,o,a,l){return new i(e(t),e(s),e(n),e(r),e(o),e(a),l)},t.param=e;class s{constructor(t,e){this.min=t,this.max=e}distance(t){const e=("number"==typeof t?t:t.min)-this.max,s=this.min-("number"==typeof t?t:t.max);return e>0?e:Math.max(s,0)}union(t){return new s(Math.min(this.min,t.min),Math.max(this.max,t.max))}static fromJson(t){var e;if("number"==typeof t)return new s(t,t);const[i,n]=null!==(e=k.readArray(t,(t=>k.readNumber(t))))&&void 0!==e?e:[];return new s(null!=i?i:0,null!=n?n:0)}}t.Param=s;class i{constructor(t,e,s,i,n,r,o){this.temperature=t,this.humidity=e,this.continentalness=s,this.erosion=i,this.depth=n,this.weirdness=r,this.offset=o}fittness(t){return F(this.temperature.distance(t.temperature))+F(this.humidity.distance(t.humidity))+F(this.continentalness.distance(t.continentalness))+F(this.erosion.distance(t.erosion))+F(this.depth.distance(t.depth))+F(this.weirdness.distance(t.weirdness))+F(this.offset-t.offset)}space(){return[this.temperature,this.humidity,this.continentalness,this.erosion,this.depth,this.weirdness,new s(this.offset,this.offset)]}static fromJson(t){var e,n;const r=null!==(e=k.readObject(t))&&void 0!==e?e:{};return new i(s.fromJson(r.temperature),s.fromJson(r.humidity),s.fromJson(r.continentalness),s.fromJson(r.erosion),s.fromJson(r.depth),s.fromJson(r.weirdness),null!==(n=k.readInt(r.offset))&&void 0!==n?n:0)}}t.ParamPoint=i;class n{constructor(t,e,s,i,n,r){this.temperature=t,this.humidity=e,this.continentalness=s,this.erosion=i,this.depth=n,this.weirdness=r}get offset(){return 0}toArray(){return[this.temperature,this.humidity,this.continentalness,this.erosion,this.depth,this.weirdness,this.offset]}}t.TargetPoint=n;t.Parameters=class{constructor(t){this.things=t,this.index=new r(t)}find(t){return this.index.search(t,((t,e)=>t.distance(e)))}};class r{constructor(t){this.root=r.build(t.map((([t,e])=>new l(t,e))))}static build(t){if(1===t.length)return t[0];if(t.length<=r.CHILDREN_PER_NODE){const e=t.map((t=>{let e=0;for(let s=0;s<7;s+=1){const i=t.space[s];e+=Math.abs((i.min+i.max)/2)}return{key:e,node:t}})).sort(((t,e)=>t.key-e.key)).map((({node:t})=>t));return new a(e)}let e=1/0,s=-1,i=[];for(let n=0;n<7;++n){r.sort(t,n,!1),i=r.bucketize(t);let o=0;for(const t of i)o+=r.area(t.space);e>o&&(e=o,s=n)}return t=r.sort(t,s,!1),i=r.bucketize(t),i=r.sort(i,s,!0),new a(i.map((t=>r.build(t.children))))}static sort(t,e,s){return t.map((t=>{const i=t.space[e],n=(i.min+i.max)/2;return{key:s?Math.abs(n):n,node:t}})).sort(((t,e)=>t.key-e.key)).map((({node:t})=>t))}static bucketize(t){const e=[];let s=[];const i=Math.pow(10,Math.floor(Math.log(t.length-.01)/Math.log(10)));for(const n of t)s.push(n),s.length<i||(e.push(new a(s)),s=[]);return 0!==s.length&&e.push(new a(s)),e}static area(t){let e=0;for(const s of t)e+=Math.abs(s.max-s.min);return e}search(t,e){return this.root.search(t.toArray(),e).thing()}}r.CHILDREN_PER_NODE=10,t.RTree=r;class o{constructor(t){this.space=t}distance(t){let e=0;for(let s=0;s<7;s+=1)e+=F(this.space[s].distance(t[s]));return e}}t.RNode=o;class a extends o{constructor(t){super(a.buildSpace(t)),this.children=t}static buildSpace(t){let e=[...Array(7)].map((()=>new s(1/0,-1/0)));for(const s of t)e=[...Array(7)].map(((t,i)=>e[i].union(s.space[i])));return e}search(t,e){let s=1/0,i=null;for(const n of this.children){const r=e(n,t);if(s<=r)continue;const o=n.search(t,e),a=n==o?r:e(o,t);s<=a||(s=a,i=o)}return i}}t.RSubTree=a;class l extends o{constructor(t,e){super(t.space()),this.thing=e}search(){return this}}t.RLeaf=l}(yt||(yt={}));class Rt{constructor(t){this.biome=t}getBiome(){return this.biome}static fromJson(t){var e,s;const i=null!==(e=k.readObject(t))&&void 0!==e?e:{},n=null!==(s=k.readString(i.biome))&&void 0!==s?s:"minecraft:the_void";return new Rt(n)}}class _t{constructor(t){this.parameters=t}getBiome(t,e,s,i){const n=i(t,e,s);return this.parameters.find(n)}static fromJson(t){var e,s;const i=null!==(e=k.readObject(t))&&void 0!==e?e:{},n=(null!==(s=k.readArray(i.biomes,(t=>{var e;return(t=>{var e;return{biome:null!==(e=k.readString(t.biome))&&void 0!==e?e:"minecraft:the_void",parameters:yt.ParamPoint.fromJson(t.parameters)}})(null!==(e=k.readObject(t))&&void 0!==e?e:{})})))&&void 0!==s?s:[]).map((t=>[t.parameters,()=>t.biome]));return new _t(new yt.Parameters(n))}}!function(t){function e(t){return h.apply(t)+.015}function s(t){return u.apply(t)}function i(t){return c.apply(t)}function n(t){return 3*-(Math.abs(Math.abs(t)-.6666667)-.33333334)}t.offset=e,t.factor=s,t.peaks=i,t.peaksAndValleys=n,t.point=function(t,e,s){return{continents:t,erosion:e,weirdness:s,ridges:n(s)}},t.nearWater=function(t,e){return!(t<-.2)&&(t<-.05||Math.abs(e)<.15)},t.shape=function(t,n){return{offset:e(t),factor:s(t),peaks:i(t),nearWater:n}};const r=f("beachSpline",-.15,-.05,0,0,.1,0,-.03,!1,!1),o=f("lowSpline",-.1,-.1,.03,.1,.1,.01,-.03,!1,!1),a=f("midSpline",-.1,-.1,.03,.1,.7,.01,-.03,!0,!0),l=f("highSpline",-.05,.3,.03,.1,1,.01,.01,!0,!0),h=new Z("offsetSampler",(t=>t.continents)).addPoint(-1.1,.044).addPoint(-1.02,-.2222).addPoint(-.51,-.2222).addPoint(-.44,-.12).addPoint(-.18,-.12).addPoint(-.16,r).addPoint(-.15,r).addPoint(-.1,o).addPoint(.25,a).addPoint(1,l),u=new Z("Factor-Continents",(t=>t.continents)).addPoint(-.19,505).addPoint(-.15,d("erosionCoast",800,!0,"ridgeCoast-OldMountains")).addPoint(-.1,d("erosionInland",700,!0,"ridgeInland-OldMountains")).addPoint(.03,d("erosionMidInland",650,!0,"ridgeMidInland-OldMountains")).addPoint(.06,d("erosionFarInland",600,!1,"ridgeFarInland-OldMountains")),c=new Z("Peaks",(t=>t.continents)).addPoint(.1,0).addPoint(.2,new Z("Peaks-erosion",(t=>t.erosion)).addPoint(-.8,new Z("Peaks-erosion-ridges",(t=>t.ridges)).addPoint(-1,0).addPoint(.2,0).addPoint(1,new Z("Peaks-erosion-ridges-weirdness",(t=>t.weirdness)).addPoint(-.01,80).addPoint(.01,20))).addPoint(-.4,0));function d(t,e,s,i){const n=new Z(t,(t=>t.erosion)).addPoint(-.6,e).addPoint(-.5,342).addPoint(-.35,e).addPoint(-.25,e).addPoint(-.1,342).addPoint(.03,e);if(s){const t=new Z("weirdnessShattered",(t=>t.weirdness)).addPoint(0,e).addPoint(.1,80),s=new Z("ridgesShattered",(t=>t.ridges)).addPoint(-.9,e).addPoint(-.69,t);n.addPoint(.35,e).addPoint(.45,s).addPoint(.55,s).addPoint(.62,e)}else{const t=new Z(i,(t=>t.ridges)).addPoint(-.7,e).addPoint(-.15,175),s=new Z(i,(t=>t.ridges)).addPoint(.45,e).addPoint(.7,200);n.addPoint(.05,s).addPoint(.4,s).addPoint(.45,t).addPoint(.55,t).addPoint(.58,e)}return n}function f(t,e,s,i,n,r,o,a,l,h){const u=g(N(r,.6,1.5),h),c=g(N(r,.6,1),h),d=g(r,h),f=v(t+"-widePlateau",e-.15,.5*r,N(.5,.5,.5)*r,.5*r,.6*r,.5),p=v(t+"-narrowPlateau",e,o*r,i*r,.5*r,.6*r,.5),m=v(t+"-plains",e,o,o,i,n,.5),b=v(t+"-plainsFarInland",e,o,o,i,n,.5),w=new Z(t,(t=>t.ridges)).addPoint(-1,e).addPoint(-.4,m).addPoint(0,n+.07),P=v(t+"-swamps",-.02,a,a,i,n,0),x=new Z(t,(t=>t.erosion)).addPoint(-.85,u).addPoint(-.7,c).addPoint(-.4,d).addPoint(-.35,f).addPoint(-.1,p).addPoint(.2,m);return l&&x.addPoint(.4,b).addPoint(.45,w).addPoint(.55,w).addPoint(.58,b),x.addPoint(.7,P),x}function g(t,e){const s=new Z(`M-spline for continentalness: ${t} ${e}`,(t=>t.ridges)),i=p(-1,t,-.7),n=p(1,t,-.7),r=function(t){return.5*(1-t)/(.46082947*(1-.5*(1-t)))-1.17}(t);if(-.65<r&&r<1){const e=p(-.65,t,-.7),o=p(-.75,t,-.7),a=m(i,o,-1,-.75);s.addPoint(-1,i,a),s.addPoint(-.75,o),s.addPoint(-.65,e);const l=p(r,t,-.7),h=m(l,n,r,1);s.addPoint(r-.01,l),s.addPoint(r,l,h),s.addPoint(1,n,h)}else{const t=m(i,n,-1,1);e?(s.addPoint(-1,Math.max(.2,i)),s.addPoint(0,N(.5,i,n),t)):s.addPoint(-1,i,t),s.addPoint(1,n,t)}return s}function p(t,e,s){const i=.46082947*(t+1.17)*(1-.5*(1-e))-.5*(1-e);return t<s?Math.max(i,-.2222):Math.max(i,0)}function m(t,e,s,i){return(e-t)/(i-s)}function v(t,e,s,i,n,r,o){const a=Math.max(.5*(s-e),o),l=5*(i-s);return new Z(t,(t=>t.ridges)).addPoint(-1,e,a).addPoint(-.4,s,Math.min(a,l)).addPoint(0,i,l).addPoint(.4,n,2*(n-i)).addPoint(1,r,.7*(r-n))}}(At||(At={}));class Ft{constructor(t,e,s,i,n,r){this.cellCountY=e,this.cellCountZ=s,this.cellMinY=n,this.filler=r,this.noise000=0,this.noise001=0,this.noise100=0,this.noise101=0,this.noise010=0,this.noise011=0,this.noise110=0,this.noise111=0,this.valueXZ00=0,this.valueXZ10=0,this.valueXZ01=0,this.valueXZ11=0,this.valueZ0=0,this.valueZ1=0,this.minCellX=i[0]*t,this.minCellZ=i[1]*s,this.slice0=Ft.allocateSlice(e,s),this.slice1=Ft.allocateSlice(e,s)}static allocateSlice(t,e){const s=Array(e+1);for(let i=0;i<e+1;i+=1)s[i]=Array(t+1);return s}initializeForFirstCellX(){this.fillSlice(this.slice0,this.minCellX)}advanceCellX(t){this.fillSlice(this.slice1,this.minCellX+t+1)}fillSlice(t,e){for(let s=0;s<this.cellCountZ+1;s+=1)this.filler(t[s],e,this.minCellZ+s,this.cellMinY,this.cellCountY)}selectCellYZ(t,e){this.noise000=this.slice0[e][t],this.noise001=this.slice0[e+1][t],this.noise100=this.slice1[e][t],this.noise101=this.slice1[e+1][t],this.noise010=this.slice0[e][t+1],this.noise011=this.slice0[e+1][t+1],this.noise110=this.slice1[e][t+1],this.noise111=this.slice1[e+1][t+1]}updateForY(t){this.valueXZ00=N(t,this.noise000,this.noise010),this.valueXZ10=N(t,this.noise100,this.noise110),this.valueXZ01=N(t,this.noise001,this.noise011),this.valueXZ11=N(t,this.noise101,this.noise111)}updateForX(t){this.valueZ0=N(t,this.valueXZ00,this.valueXZ10),this.valueZ1=N(t,this.valueXZ01,this.valueXZ11)}calculateValue(t){return N(t,this.valueZ0,this.valueZ1)}swapSlices(){[this.slice0,this.slice1]=[this.slice1,this.slice0]}}class Mt{constructor(t,e,s,i,n,r,o,a){this.cellWidth=t,this.cellHeight=e,this.cellCountY=s,this.biomeSource=i,this.settings=n,this.shapeOverride=a;const l=new W(o),h=n.useLegacyRandom?new W(o):l.fork();this.blendedNoise=new Y(h),l.consume(8),this.temperatureNoise=new X(new J(o),r.temperature),this.humidityNoise=new X(new J(o+BigInt(1)),r.humidity),this.continentalnessNoise=new X(new J(o+BigInt(2)),r.continentalness),this.erosionNoise=new X(new J(o+BigInt(3)),r.erosion),this.weirdnessNoise=new X(new J(o+BigInt(4)),r.weirdness),this.offsetNoise=new X(new J(o+BigInt(5)),r.shift),this.mountainPeakNoise=new X(l.fork(),{firstOctave:-16,amplitudes:[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]})}getClimate(t,e,s){const i=t+this.getOffset(t,0,s),n=e+this.getOffset(e,s,t),r=s+this.getOffset(s,t,0),o=this.temperatureNoise.sample(i,n,r),a=this.humidityNoise.sample(i,n,r),l=this.continentalnessNoise.sample(i,0,r),h=this.erosionNoise.sample(i,0,r),u=this.weirdnessNoise.sample(i,0,r),c=At.offset(At.point(l,h,u)),d=Mt.computeDimensionDensity(1,-.51875,4*e)+c;return new yt.TargetPoint(o,a,l,h,d,u)}getTerrainShape(t,e){if(this.shapeOverride)return this.shapeOverride;const s=t+this.getOffset(t,0,e),i=e+this.getOffset(e,t,0),n=this.continentalnessNoise.sample(s,0,i),r=this.erosionNoise.sample(s,0,i),o=this.weirdnessNoise.sample(s,0,i),a=At.point(n,r,o),l=At.nearWater(n,o);return At.shape(a,l)}getOffset(t,e,s){return 4*this.offsetNoise.sample(t,e,s)}fillNoiseColumn(t,e,s,i,n){const r=e*this.cellWidth>>2,o=s*this.cellWidth>>2,{offset:a,factor:l,peaks:h}=this.getTerrainShape(r,o),u=684.412*this.settings.sampling.xzScale,c=684.412*this.settings.sampling.yScale,d=u/this.settings.sampling.xzFactor,f=c/this.settings.sampling.yFactor;for(let r=0;r<=n;r+=1){const n=r+i,o=this.blendedNoise.sample(e,n,s,u,c,d,f),g=this.samplePeakNoise(h,e*this.cellHeight,s*this.cellHeight)/128,p=this.computeInitialDensity(n*this.cellHeight,a,l,0,g)+o;t[r]=this.applySlide(p,n)}}samplePeakNoise(t,e,s){if(0===t)return 0;const i=3e3/this.cellWidth,n=this.mountainPeakNoise.sample(e*i,0,s*i);return n>0?t*n:t/2*n}computeInitialDensity(t,e,s,i,n){const r=(Mt.computeDimensionDensity(this.settings.densityFactor,this.settings.densityOffset,t,i)+e+n)*s;return r*(r>0?4:1)}applySlide(t,e){const s=e-Math.floor(this.settings.minY/this.cellHeight);if(this.settings.topSlide.size>0){const e=(this.cellCountY-s-this.settings.topSlide.offset)/this.settings.topSlide.size;t=U(this.settings.topSlide.target,t,e)}if(this.settings.bottomSlide.size>0){const e=(s-this.settings.bottomSlide.offset)/this.settings.bottomSlide.size;t=U(this.settings.bottomSlide.target,t,e)}return t}static computeDimensionDensity(t,e,s,i=0){return t*(1-s/128+i)+e}}class Nt{constructor(t,e,s,i){this.seed=t,this.biomeSource=e,this.settings=s,this.cellHeight=s.noise.ySize<<2,this.cellWidth=s.noise.xzSize<<2,this.cellCountXZ=Math.floor(16/this.cellWidth),this.cellCountY=Math.floor(s.noise.height/this.cellHeight),this.sampler=new Mt(this.cellWidth,this.cellHeight,this.cellCountY,e,s.noise,s.octaves,t,i)}fill(t){const e=Math.max(t.minY,this.settings.noise.minY),s=Math.min(t.maxY,this.settings.noise.minY+this.settings.noise.height),i=Math.floor(e/this.cellHeight),n=Math.floor((s-e)/this.cellHeight),r=I.minBlockX(t.pos),o=I.minBlockZ(t.pos),a=new Ft(this.cellCountXZ,n,this.cellCountXZ,t.pos,i,this.sampler.fillNoiseColumn.bind(this.sampler)),l=Array(a);l.forEach((t=>t.initializeForFirstCellX()));for(let e=0;e<this.cellCountXZ;e+=1){l.forEach((t=>t.advanceCellX(e)));for(let s=0;s<this.cellCountXZ;s+=1){let h=t.getOrCreateSection(t.sectionsCount-1);for(let u=n-1;u>=0;u-=1){l.forEach((t=>t.selectCellYZ(u,s)));for(let n=this.cellHeight-1;n>=0;n-=1){const c=(i+u)*this.cellHeight+n,d=15&c,f=t.getSectionIndex(c);t.getSectionIndex(h.minBlockY)!==f&&(h=t.getOrCreateSection(f));const g=n/this.cellHeight;l.forEach((t=>t.updateForY(g)));for(let t=0;t<this.cellWidth;t+=1){const i=r+e*this.cellWidth+t,n=15&i,u=t/this.cellWidth;l.forEach((t=>t.updateForX(u)));for(let t=0;t<this.cellWidth;t+=1){const e=o+s*this.cellWidth+t,r=15&e,l=t/this.cellWidth,u=a.calculateValue(l),f=this.baseState(i,c,e,u);f.equals(B.AIR)||h.setBlockState(n,d,r,f)}}}}}l.forEach((t=>t.swapSlices()))}}baseState(t,e,s,i){return(i=(i=M(i/200,-1,1))/2-i*i*i/24)>0?this.settings.defaultBlock:e<this.settings.seaLevel?this.settings.defaultFluid:B.AIR}}!function(t){t.fromJson=function(t){var e,s,i,n,r,o,a,l,h,u,c,d;const f=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{minY:null!==(s=k.readInt(f.min_y))&&void 0!==s?s:0,height:null!==(i=k.readInt(f.height))&&void 0!==i?i:256,xzSize:null!==(n=k.readInt(f.size_horizontal))&&void 0!==n?n:1,ySize:null!==(r=k.readInt(f.size_vertical))&&void 0!==r?r:1,densityFactor:null!==(o=k.readNumber(f.density_factor))&&void 0!==o?o:0,densityOffset:null!==(a=k.readNumber(f.density_offset))&&void 0!==a?a:0,sampling:Bt.fromJson(f.sampling),topSlide:Et.fromJson(f.top_slide),bottomSlide:Et.fromJson(f.bottom_slide),useSimplexSurfaceNoise:null!==(l=k.readBoolean(f.simplex_surface_noise))&&void 0!==l&&l,randomDensityOffset:null!==(h=k.readBoolean(f.random_density_offset))&&void 0!==h&&h,islandNoiseOverride:null!==(u=k.readBoolean(f.island_noise_override))&&void 0!==u&&u,isAmplified:null!==(c=k.readBoolean(f.amplified))&&void 0!==c&&c,useLegacyRandom:null!==(d=k.readBoolean(f.use_legacy_random))&&void 0!==d&&d}}}(St||(St={})),function(t){t.fromJson=function(t){var e,s,i,n,r;const o=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{xzScale:null!==(s=k.readNumber(o.xz_scale))&&void 0!==s?s:1,yScale:null!==(i=k.readNumber(o.y_scale))&&void 0!==i?i:1,xzFactor:null!==(n=k.readNumber(o.xz_factor))&&void 0!==n?n:80,yFactor:null!==(r=k.readNumber(o.y_factor))&&void 0!==r?r:80}}}(Bt||(Bt={})),function(t){t.fromJson=function(t){var e,s,i,n;const r=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{target:null!==(s=k.readNumber(r.target))&&void 0!==s?s:0,size:null!==(i=k.readInt(r.size))&&void 0!==i?i:0,offset:null!==(n=k.readInt(r.offset))&&void 0!==n?n:0}}}(Et||(Et={})),function(t){t.fromJson=function(t){var e,s,i,n,r,o,a,l,h,u;const c=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{structures:It.fromJson(c.structures),noise:St.fromJson(c.noise),octaves:kt.fromJson(c.octaves),defaultBlock:B.fromJson(c.default_block),defaultFluid:B.fromJson(c.default_fluid),bedrockRoofPosition:null!==(s=k.readInt(c.bedrock_roof_position))&&void 0!==s?s:0,bedrockFloorPosition:null!==(i=k.readInt(c.bedrock_floor_position))&&void 0!==i?i:0,seaLevel:null!==(n=k.readInt(c.sea_level))&&void 0!==n?n:0,disableMobGeneration:null!==(r=k.readBoolean(c.disable_mob_generation))&&void 0!==r&&r,aquifersEnabled:null!==(o=k.readBoolean(c.aquifers_enabled))&&void 0!==o&&o,noiseCavesEnabled:null!==(a=k.readBoolean(c.noise_caves_enabled))&&void 0!==a&&a,deepslateEnabled:null!==(l=k.readBoolean(c.deepslate_enabled))&&void 0!==l&&l,oreVeinsEnabled:null!==(h=k.readBoolean(c.ore_veins_enabled))&&void 0!==h&&h,noodleCavesEnabled:null!==(u=k.readBoolean(c.noodle_caves_enabled))&&void 0!==u&&u}}}(Ct||(Ct={})),function(t){t.fromJson=function(t){var e;const s=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{stronghold:k.compose(s.stronghold,k.readObject,(t=>{var e,s,i;return{distance:null!==(e=k.readInt(t.distance))&&void 0!==e?e:0,spread:null!==(s=k.readInt(t.spread))&&void 0!==s?s:0,count:null!==(i=k.readInt(t.count))&&void 0!==i?i:0}})),structures:k.readMap(s.structures,(t=>{var e;return(t=>{var e,s,i;return{spacing:null!==(e=k.readInt(t.spacing))&&void 0!==e?e:0,separation:null!==(s=k.readInt(t.separation))&&void 0!==s?s:0,salt:null!==(i=k.readInt(t.salt))&&void 0!==i?i:0}})(null!==(e=k.readObject(t))&&void 0!==e?e:{})}))}}}(It||(It={})),function(t){t.fromJson=function(t){var e;const s=null!==(e=k.readObject(t))&&void 0!==e?e:{};return{temperature:R.fromJson(s.temperature),humidity:R.fromJson(s.humidity),continentalness:R.fromJson(s.continentalness),erosion:R.fromJson(s.erosion),weirdness:R.fromJson(s.weirdness),shift:R.fromJson(s.shift)}}}(kt||(kt={}));
//# sourceMappingURL=deepslate.esm.js.map


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "ARRAY_TYPE": () => (/* binding */ ARRAY_TYPE),
/* harmony export */   "RANDOM": () => (/* binding */ RANDOM),
/* harmony export */   "setMatrixArrayType": () => (/* binding */ setMatrixArrayType),
/* harmony export */   "toRadian": () => (/* binding */ toRadian),
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromXRotation": () => (/* binding */ fromXRotation),
/* harmony export */   "fromYRotation": () => (/* binding */ fromYRotation),
/* harmony export */   "fromZRotation": () => (/* binding */ fromZRotation),
/* harmony export */   "fromRotationTranslation": () => (/* binding */ fromRotationTranslation),
/* harmony export */   "fromQuat2": () => (/* binding */ fromQuat2),
/* harmony export */   "getTranslation": () => (/* binding */ getTranslation),
/* harmony export */   "getScaling": () => (/* binding */ getScaling),
/* harmony export */   "getRotation": () => (/* binding */ getRotation),
/* harmony export */   "fromRotationTranslationScale": () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   "fromRotationTranslationScaleOrigin": () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   "fromQuat": () => (/* binding */ fromQuat),
/* harmony export */   "frustum": () => (/* binding */ frustum),
/* harmony export */   "perspectiveNO": () => (/* binding */ perspectiveNO),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "perspectiveZO": () => (/* binding */ perspectiveZO),
/* harmony export */   "perspectiveFromFieldOfView": () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   "orthoNO": () => (/* binding */ orthoNO),
/* harmony export */   "ortho": () => (/* binding */ ortho),
/* harmony export */   "orthoZO": () => (/* binding */ orthoZO),
/* harmony export */   "lookAt": () => (/* binding */ lookAt),
/* harmony export */   "targetTo": () => (/* binding */ targetTo),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "hermite": () => (/* binding */ hermite),
/* harmony export */   "bezier": () => (/* binding */ bezier),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "transformMat3": () => (/* binding */ transformMat3),
/* harmony export */   "transformQuat": () => (/* binding */ transformQuat),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "angle": () => (/* binding */ angle),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/litegraph.js/build/litegraph.js":
/*!******************************************************!*\
  !*** ./node_modules/litegraph.js/build/litegraph.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

//packer version

(function(global) {
    // *************************************************************
    //   LiteGraph CLASS                                     *******
    // *************************************************************

    /**
     * The Global Scope. It contains all the registered node classes.
     *
     * @class LiteGraph
     * @constructor
     */

    var LiteGraph = (global.LiteGraph = {
        VERSION: 0.4,

        CANVAS_GRID_SIZE: 10,

        NODE_TITLE_HEIGHT: 30,
        NODE_TITLE_TEXT_Y: 20,
        NODE_SLOT_HEIGHT: 20,
        NODE_WIDGET_HEIGHT: 20,
        NODE_WIDTH: 140,
        NODE_MIN_WIDTH: 50,
        NODE_COLLAPSED_RADIUS: 10,
        NODE_COLLAPSED_WIDTH: 80,
        NODE_TITLE_COLOR: "#999",
        NODE_SELECTED_TITLE_COLOR: "#FFF",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#AAA",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#333",
        NODE_DEFAULT_BGCOLOR: "#353535",
        NODE_DEFAULT_BOXCOLOR: "#666",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#FFF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 24,

        WIDGET_BGCOLOR: "#222",
        WIDGET_OUTLINE_COLOR: "#666",
        WIDGET_TEXT_COLOR: "#DDD",
        WIDGET_SECONDARY_TEXT_COLOR: "#999",

        LINK_COLOR: "#9A9",
        EVENT_LINK_COLOR: "#A86",
        CONNECTING_LINK_COLOR: "#AFA",

        MAX_NUMBER_OF_NODES: 1000, //avoid infinite loops
        DEFAULT_POSITION: [100, 100], //default node position
        VALID_SHAPES: ["default", "box", "round", "card"], //,"circle"

        //shapes are used for nodes but also for slots
        BOX_SHAPE: 1,
        ROUND_SHAPE: 2,
        CIRCLE_SHAPE: 3,
        CARD_SHAPE: 4,
        ARROW_SHAPE: 5,

        //enums
        INPUT: 1,
        OUTPUT: 2,

        EVENT: -1, //for outputs
        ACTION: -1, //for inputs

        ALWAYS: 0,
        ON_EVENT: 1,
        NEVER: 2,
        ON_TRIGGER: 3,

        UP: 1,
        DOWN: 2,
        LEFT: 3,
        RIGHT: 4,
        CENTER: 5,

        STRAIGHT_LINK: 0,
        LINEAR_LINK: 1,
        SPLINE_LINK: 2,

        NORMAL_TITLE: 0,
        NO_TITLE: 1,
        TRANSPARENT_TITLE: 2,
        AUTOHIDE_TITLE: 3,

        proxy: null, //used to redirect calls
        node_images_path: "",

        debug: false,
        catch_exceptions: true,
        throw_errors: true,
        allow_scripts: false, //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits
        registered_node_types: {}, //nodetypes by string
        node_types_by_file_extension: {}, //used for dropping files in the canvas
        Nodes: {}, //node types by classname
		Globals: {}, //used to store vars between graphs

        searchbox_extras: {}, //used to add extra features to the search box
        auto_sort_node_types: false, // If set to true, will automatically sort node types / categories in the context menus

        /**
         * Register a node class so it can be listed when the user wants to create a new one
         * @method registerNodeType
         * @param {String} type name of the node and path
         * @param {Class} base_class class containing the structure of a node
         */

        registerNodeType: function(type, base_class) {
            if (!base_class.prototype) {
                throw "Cannot register a simple object, it must be a class with a prototype";
            }
            base_class.type = type;

            if (LiteGraph.debug) {
                console.log("Node registered: " + type);
            }

            var categories = type.split("/");
            var classname = base_class.name;

            var pos = type.lastIndexOf("/");
            base_class.category = type.substr(0, pos);

            if (!base_class.title) {
                base_class.title = classname;
            }
            //info.name = name.substr(pos+1,name.length - pos);

            //extend class
            if (base_class.prototype) {
                //is a class
                for (var i in LGraphNode.prototype) {
                    if (!base_class.prototype[i]) {
                        base_class.prototype[i] = LGraphNode.prototype[i];
                    }
                }
            }

            var prev = this.registered_node_types[type];
			if(prev)
				console.log("replacing node type: " + type);
			else
			{
				if( !Object.hasOwnProperty( base_class.prototype, "shape") )
				Object.defineProperty(base_class.prototype, "shape", {
					set: function(v) {
						switch (v) {
							case "default":
								delete this._shape;
								break;
							case "box":
								this._shape = LiteGraph.BOX_SHAPE;
								break;
							case "round":
								this._shape = LiteGraph.ROUND_SHAPE;
								break;
							case "circle":
								this._shape = LiteGraph.CIRCLE_SHAPE;
								break;
							case "card":
								this._shape = LiteGraph.CARD_SHAPE;
								break;
							default:
								this._shape = v;
						}
					},
					get: function(v) {
						return this._shape;
					},
					enumerable: true,
					configurable: true
				});

				//warnings
				if (base_class.prototype.onPropertyChange) {
					console.warn(
						"LiteGraph node class " +
							type +
							" has onPropertyChange method, it must be called onPropertyChanged with d at the end"
					);
				}

				//used to know which nodes create when dragging files to the canvas
				if (base_class.supported_extensions) {
					for (var i in base_class.supported_extensions) {
						var ext = base_class.supported_extensions[i];
						if(ext && ext.constructor === String)
							this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;
					}
				}
			}

            this.registered_node_types[type] = base_class;
            if (base_class.constructor.name) {
                this.Nodes[classname] = base_class;
            }
            if (LiteGraph.onNodeTypeRegistered) {
                LiteGraph.onNodeTypeRegistered(type, base_class);
            }
            if (prev && LiteGraph.onNodeTypeReplaced) {
                LiteGraph.onNodeTypeReplaced(type, base_class, prev);
            }

            //warnings
            if (base_class.prototype.onPropertyChange) {
                console.warn(
                    "LiteGraph node class " +
                        type +
                        " has onPropertyChange method, it must be called onPropertyChanged with d at the end"
                );
            }

			//used to know which nodes create when dragging files to the canvas
            if (base_class.supported_extensions) {
                for (var i=0; i < base_class.supported_extensions.length; i++) {
					var ext = base_class.supported_extensions[i];
					if(ext && ext.constructor === String)
	                    this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;
                }
            }
        },

        /**
         * removes a node type from the system
         * @method unregisterNodeType
         * @param {String|Object} type name of the node or the node constructor itself
         */
        unregisterNodeType: function(type) {
			var base_class = type.constructor === String ? this.registered_node_types[type] : type;
			if(!base_class)
				throw("node type not found: " + type );
			delete this.registered_node_types[base_class.type];
			if(base_class.constructor.name)
				delete this.Nodes[base_class.constructor.name];
		},

        /**
         * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
         * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
         * @method wrapFunctionAsNode
         * @param {String} name node name with namespace (p.e.: 'math/sum')
         * @param {Function} func
         * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
         * @param {String} return_type [optional] string with the return type, otherwise it will be generic
         * @param {Object} properties [optional] properties to be configurable
         */
        wrapFunctionAsNode: function(
            name,
            func,
            param_types,
            return_type,
            properties
        ) {
            var params = Array(func.length);
            var code = "";
            var names = LiteGraph.getParameterNames(func);
            for (var i = 0; i < names.length; ++i) {
                code +=
                    "this.addInput('" +
                    names[i] +
                    "'," +
                    (param_types && param_types[i]
                        ? "'" + param_types[i] + "'"
                        : "0") +
                    ");\n";
            }
            code +=
                "this.addOutput('out'," +
                (return_type ? "'" + return_type + "'" : 0) +
                ");\n";
            if (properties) {
                code +=
                    "this.properties = " + JSON.stringify(properties) + ";\n";
            }
            var classobj = Function(code);
            classobj.title = name.split("/").pop();
            classobj.desc = "Generated from " + func.name;
            classobj.prototype.onExecute = function onExecute() {
                for (var i = 0; i < params.length; ++i) {
                    params[i] = this.getInputData(i);
                }
                var r = func.apply(this, params);
                this.setOutputData(0, r);
            };
            this.registerNodeType(name, classobj);
        },

        /**
         * Removes all previously registered node's types
         */
        clearRegisteredTypes: function() {
            this.registered_node_types = {};
            this.node_types_by_file_extension = {};
            this.Nodes = {};
            this.searchbox_extras = {};
        },

        /**
         * Adds this method to all nodetypes, existing and to be created
         * (You can add it to LGraphNode.prototype but then existing node types wont have it)
         * @method addNodeMethod
         * @param {Function} func
         */
        addNodeMethod: function(name, func) {
            LGraphNode.prototype[name] = func;
            for (var i in this.registered_node_types) {
                var type = this.registered_node_types[i];
                if (type.prototype[name]) {
                    type.prototype["_" + name] = type.prototype[name];
                } //keep old in case of replacing
                type.prototype[name] = func;
            }
        },

        /**
         * Create a node of a given type with a name. The node is not attached to any graph yet.
         * @method createNode
         * @param {String} type full name of the node class. p.e. "math/sin"
         * @param {String} name a name to distinguish from other nodes
         * @param {Object} options to set options
         */

        createNode: function(type, title, options) {
            var base_class = this.registered_node_types[type];
            if (!base_class) {
                if (LiteGraph.debug) {
                    console.log(
                        'GraphNode type "' + type + '" not registered.'
                    );
                }
                return null;
            }

            var prototype = base_class.prototype || base_class;

            title = title || base_class.title || type;

            var node = null;

            if (LiteGraph.catch_exceptions) {
                try {
                    node = new base_class(title);
                } catch (err) {
                    console.error(err);
                    return null;
                }
            } else {
                node = new base_class(title);
            }

            node.type = type;

            if (!node.title && title) {
                node.title = title;
            }
            if (!node.properties) {
                node.properties = {};
            }
            if (!node.properties_info) {
                node.properties_info = [];
            }
            if (!node.flags) {
                node.flags = {};
            }
            if (!node.size) {
                node.size = node.computeSize();
				//call onresize?
            }
            if (!node.pos) {
                node.pos = LiteGraph.DEFAULT_POSITION.concat();
            }
            if (!node.mode) {
                node.mode = LiteGraph.ALWAYS;
            }

            //extra options
            if (options) {
                for (var i in options) {
                    node[i] = options[i];
                }
            }

            return node;
        },

        /**
         * Returns a registered node type with a given name
         * @method getNodeType
         * @param {String} type full name of the node class. p.e. "math/sin"
         * @return {Class} the node class
         */
        getNodeType: function(type) {
            return this.registered_node_types[type];
        },

        /**
         * Returns a list of node types matching one category
         * @method getNodeType
         * @param {String} category category name
         * @return {Array} array with all the node classes
         */

        getNodeTypesInCategory: function(category, filter) {
            var r = [];
            for (var i in this.registered_node_types) {
                var type = this.registered_node_types[i];
                if (type.filter != filter) {
                    continue;
                }

                if (category == "") {
                    if (type.category == null) {
                        r.push(type);
                    }
                } else if (type.category == category) {
                    r.push(type);
                }
            }

            if (this.auto_sort_node_types) {
                r.sort((a, b) => a.title.localeCompare(b.title));
            }

            return r;
        },

        /**
         * Returns a list with all the node type categories
         * @method getNodeTypesCategories
         * @param {String} filter only nodes with ctor.filter equal can be shown
         * @return {Array} array with all the names of the categories
         */
        getNodeTypesCategories: function( filter ) {
            var categories = { "": 1 };
            for (var i in this.registered_node_types) {
				var type = this.registered_node_types[i];
                if ( type.category && !type.skip_list )
                {
					if(type.filter != filter)
						continue;
                    categories[type.category] = 1;
                }
            }
            var result = [];
            for (var i in categories) {
                result.push(i);
            }
            return this.auto_sort_node_types ? result.sort() : result;
        },

        //debug purposes: reloads all the js scripts that matches a wildcard
        reloadNodes: function(folder_wildcard) {
            var tmp = document.getElementsByTagName("script");
            //weird, this array changes by its own, so we use a copy
            var script_files = [];
            for (var i=0; i < tmp.length; i++) {
                script_files.push(tmp[i]);
            }

            var docHeadObj = document.getElementsByTagName("head")[0];
            folder_wildcard = document.location.href + folder_wildcard;

            for (var i=0; i < script_files.length; i++) {
                var src = script_files[i].src;
                if (
                    !src ||
                    src.substr(0, folder_wildcard.length) != folder_wildcard
                ) {
                    continue;
                }

                try {
                    if (LiteGraph.debug) {
                        console.log("Reloading: " + src);
                    }
                    var dynamicScript = document.createElement("script");
                    dynamicScript.type = "text/javascript";
                    dynamicScript.src = src;
                    docHeadObj.appendChild(dynamicScript);
                    docHeadObj.removeChild(script_files[i]);
                } catch (err) {
                    if (LiteGraph.throw_errors) {
                        throw err;
                    }
                    if (LiteGraph.debug) {
                        console.log("Error while reloading " + src);
                    }
                }
            }

            if (LiteGraph.debug) {
                console.log("Nodes reloaded");
            }
        },

        //separated just to improve if it doesn't work
        cloneObject: function(obj, target) {
            if (obj == null) {
                return null;
            }
            var r = JSON.parse(JSON.stringify(obj));
            if (!target) {
                return r;
            }

            for (var i in r) {
                target[i] = r[i];
            }
            return target;
        },

        /**
         * Returns if the types of two slots are compatible (taking into account wildcards, etc)
         * @method isValidConnection
         * @param {String} type_a
         * @param {String} type_b
         * @return {Boolean} true if they can be connected
         */
        isValidConnection: function(type_a, type_b) {
            if (
                !type_a || //generic output
                !type_b || //generic input
                type_a == type_b || //same type (is valid for triggers)
                (type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION)
            ) {
                return true;
            }

            // Enforce string type to handle toLowerCase call (-1 number not ok)
            type_a = String(type_a);
            type_b = String(type_b);
            type_a = type_a.toLowerCase();
            type_b = type_b.toLowerCase();

            // For nodes supporting multiple connection types
            if (type_a.indexOf(",") == -1 && type_b.indexOf(",") == -1) {
                return type_a == type_b;
            }

            // Check all permutations to see if one is valid
            var supported_types_a = type_a.split(",");
            var supported_types_b = type_b.split(",");
            for (var i = 0; i < supported_types_a.length; ++i) {
                for (var j = 0; j < supported_types_b.length; ++j) {
                    if (supported_types_a[i] == supported_types_b[j]) {
                        return true;
                    }
                }
            }

            return false;
        },

        /**
         * Register a string in the search box so when the user types it it will recommend this node
         * @method registerSearchboxExtra
         * @param {String} node_type the node recommended
         * @param {String} description text to show next to it
         * @param {Object} data it could contain info of how the node should be configured
         * @return {Boolean} true if they can be connected
         */
        registerSearchboxExtra: function(node_type, description, data) {
            this.searchbox_extras[description.toLowerCase()] = {
                type: node_type,
                desc: description,
                data: data
            };
        },

        /**
         * Wrapper to load files (from url using fetch or from file using FileReader)
         * @method fetchFile
         * @param {String|File|Blob} url the url of the file (or the file itself)
         * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
         * @param {Function} on_complete callback(data)
         * @param {Function} on_error in case of an error
         * @return {FileReader|Promise} returns the object used to 
         */
		fetchFile: function( url, type, on_complete, on_error ) {
			var that = this;
			if(!url)
				return null;

			type = type || "text";
			if( url.constructor === String )
			{
				if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
					url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
				}
				return fetch(url)
				.then(function(response) {
					if(!response.ok)
						 throw new Error("File not found"); //it will be catch below
					if(type == "arraybuffer")
						return response.arrayBuffer();
					else if(type == "text" || type == "string")
						return response.text();
					else if(type == "json")
						return response.json();
					else if(type == "blob")
						return response.blob();
				})
				.then(function(data) {
					if(on_complete)
						on_complete(data);
				})
				.catch(function(error) {
					console.error("error fetching file:",url);
					if(on_error)
						on_error(error);
				});
			}
			else if( url.constructor === File || url.constructor === Blob)
			{
				var reader = new FileReader();
				reader.onload = function(e)
				{
					var v = e.target.result;
					if( type == "json" )
						v = JSON.parse(v);
					if(on_complete)
						on_complete(v);
				}
				if(type == "arraybuffer")
					return reader.readAsArrayBuffer(url);
				else if(type == "text" || type == "json")
					return reader.readAsText(url);
				else if(type == "blob")
					return reader.readAsBinaryString(url);
			}
			return null;
		}
    });

    //timer that works everywhere
    if (typeof performance != "undefined") {
        LiteGraph.getTime = performance.now.bind(performance);
    } else if (typeof Date != "undefined" && Date.now) {
        LiteGraph.getTime = Date.now.bind(Date);
    } else if (typeof process != "undefined") {
        LiteGraph.getTime = function() {
            var t = process.hrtime();
            return t[0] * 0.001 + t[1] * 1e-6;
        };
    } else {
        LiteGraph.getTime = function getTime() {
            return new Date().getTime();
        };
    }

    //*********************************************************************************
    // LGraph CLASS
    //*********************************************************************************

    /**
     * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.
	 * supported callbacks:
		+ onNodeAdded: when a new node is added to the graph
		+ onNodeRemoved: when a node inside this graph is removed
		+ onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)
     *
     * @class LGraph
     * @constructor
     * @param {Object} o data from previous serialization [optional]
     */

    function LGraph(o) {
        if (LiteGraph.debug) {
            console.log("Graph created");
        }
        this.list_of_graphcanvas = null;
        this.clear();

        if (o) {
            this.configure(o);
        }
    }

    global.LGraph = LiteGraph.LGraph = LGraph;

    //default supported types
    LGraph.supported_types = ["number", "string", "boolean"];

    //used to know which types of connections support this graph (some graphs do not allow certain types)
    LGraph.prototype.getSupportedTypes = function() {
        return this.supported_types || LGraph.supported_types;
    };

    LGraph.STATUS_STOPPED = 1;
    LGraph.STATUS_RUNNING = 2;

    /**
     * Removes all nodes from this graph
     * @method clear
     */

    LGraph.prototype.clear = function() {
        this.stop();
        this.status = LGraph.STATUS_STOPPED;

        this.last_node_id = 0;
        this.last_link_id = 0;

        this._version = -1; //used to detect changes

        //safe clear
        if (this._nodes) {
            for (var i = 0; i < this._nodes.length; ++i) {
                var node = this._nodes[i];
                if (node.onRemoved) {
                    node.onRemoved();
                }
            }
        }

        //nodes
        this._nodes = [];
        this._nodes_by_id = {};
        this._nodes_in_order = []; //nodes sorted in execution order
        this._nodes_executable = null; //nodes that contain onExecute sorted in execution order

        //other scene stuff
        this._groups = [];

        //links
        this.links = {}; //container with all the links

        //iterations
        this.iteration = 0;

        //custom data
        this.config = {};
		this.vars = {};
		this.extra = {}; //to store custom data

        //timing
        this.globaltime = 0;
        this.runningtime = 0;
        this.fixedtime = 0;
        this.fixedtime_lapse = 0.01;
        this.elapsed_time = 0.01;
        this.last_update_time = 0;
        this.starttime = 0;

        this.catch_errors = true;

        //subgraph_data
        this.inputs = {};
        this.outputs = {};

        //notify canvas to redraw
        this.change();

        this.sendActionToCanvas("clear");
    };

    /**
     * Attach Canvas to this graph
     * @method attachCanvas
     * @param {GraphCanvas} graph_canvas
     */

    LGraph.prototype.attachCanvas = function(graphcanvas) {
        if (graphcanvas.constructor != LGraphCanvas) {
            throw "attachCanvas expects a LGraphCanvas instance";
        }
        if (graphcanvas.graph && graphcanvas.graph != this) {
            graphcanvas.graph.detachCanvas(graphcanvas);
        }

        graphcanvas.graph = this;

        if (!this.list_of_graphcanvas) {
            this.list_of_graphcanvas = [];
        }
        this.list_of_graphcanvas.push(graphcanvas);
    };

    /**
     * Detach Canvas from this graph
     * @method detachCanvas
     * @param {GraphCanvas} graph_canvas
     */
    LGraph.prototype.detachCanvas = function(graphcanvas) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        var pos = this.list_of_graphcanvas.indexOf(graphcanvas);
        if (pos == -1) {
            return;
        }
        graphcanvas.graph = null;
        this.list_of_graphcanvas.splice(pos, 1);
    };

    /**
     * Starts running this graph every interval milliseconds.
     * @method start
     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
     */

    LGraph.prototype.start = function(interval) {
        if (this.status == LGraph.STATUS_RUNNING) {
            return;
        }
        this.status = LGraph.STATUS_RUNNING;

        if (this.onPlayEvent) {
            this.onPlayEvent();
        }

        this.sendEventToAllNodes("onStart");

        //launch
        this.starttime = LiteGraph.getTime();
        this.last_update_time = this.starttime;
        interval = interval || 0;
        var that = this;

		//execute once per frame
        if ( interval == 0 && typeof window != "undefined" && window.requestAnimationFrame ) {
            function on_frame() {
                if (that.execution_timer_id != -1) {
                    return;
                }
                window.requestAnimationFrame(on_frame);
				if(that.onBeforeStep)
					that.onBeforeStep();
                that.runStep(1, !that.catch_errors);
				if(that.onAfterStep)
					that.onAfterStep();
            }
            this.execution_timer_id = -1;
            on_frame();
        } else { //execute every 'interval' ms
            this.execution_timer_id = setInterval(function() {
                //execute
				if(that.onBeforeStep)
					that.onBeforeStep();
                that.runStep(1, !that.catch_errors);
				if(that.onAfterStep)
					that.onAfterStep();
            }, interval);
        }
    };

    /**
     * Stops the execution loop of the graph
     * @method stop execution
     */

    LGraph.prototype.stop = function() {
        if (this.status == LGraph.STATUS_STOPPED) {
            return;
        }

        this.status = LGraph.STATUS_STOPPED;

        if (this.onStopEvent) {
            this.onStopEvent();
        }

        if (this.execution_timer_id != null) {
            if (this.execution_timer_id != -1) {
                clearInterval(this.execution_timer_id);
            }
            this.execution_timer_id = null;
        }

        this.sendEventToAllNodes("onStop");
    };

    /**
     * Run N steps (cycles) of the graph
     * @method runStep
     * @param {number} num number of steps to run, default is 1
     * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors 
     * @param {number} limit max number of nodes to execute (used to execute from start to a node)
     */

    LGraph.prototype.runStep = function(num, do_not_catch_errors, limit ) {
        num = num || 1;

        var start = LiteGraph.getTime();
        this.globaltime = 0.001 * (start - this.starttime);

        var nodes = this._nodes_executable
            ? this._nodes_executable
            : this._nodes;
        if (!nodes) {
            return;
        }

		limit = limit || nodes.length;

        if (do_not_catch_errors) {
            //iterations
            for (var i = 0; i < num; i++) {
                for (var j = 0; j < limit; ++j) {
                    var node = nodes[j];
                    if (node.mode == LiteGraph.ALWAYS && node.onExecute) {
                        node.onExecute(); //hard to send elapsed time
                    }
                }

                this.fixedtime += this.fixedtime_lapse;
                if (this.onExecuteStep) {
                    this.onExecuteStep();
                }
            }

            if (this.onAfterExecute) {
                this.onAfterExecute();
            }
        } else {
            try {
                //iterations
                for (var i = 0; i < num; i++) {
                    for (var j = 0; j < limit; ++j) {
                        var node = nodes[j];
                        if (node.mode == LiteGraph.ALWAYS && node.onExecute) {
                            node.onExecute();
                        }
                    }

                    this.fixedtime += this.fixedtime_lapse;
                    if (this.onExecuteStep) {
                        this.onExecuteStep();
                    }
                }

                if (this.onAfterExecute) {
                    this.onAfterExecute();
                }
                this.errors_in_execution = false;
            } catch (err) {
                this.errors_in_execution = true;
                if (LiteGraph.throw_errors) {
                    throw err;
                }
                if (LiteGraph.debug) {
                    console.log("Error during execution: " + err);
                }
                this.stop();
            }
        }

        var now = LiteGraph.getTime();
        var elapsed = now - start;
        if (elapsed == 0) {
            elapsed = 1;
        }
        this.execution_time = 0.001 * elapsed;
        this.globaltime += 0.001 * elapsed;
        this.iteration += 1;
        this.elapsed_time = (now - this.last_update_time) * 0.001;
        this.last_update_time = now;
    };

    /**
     * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
     * nodes with only inputs.
     * @method updateExecutionOrder
     */
    LGraph.prototype.updateExecutionOrder = function() {
        this._nodes_in_order = this.computeExecutionOrder(false);
        this._nodes_executable = [];
        for (var i = 0; i < this._nodes_in_order.length; ++i) {
            if (this._nodes_in_order[i].onExecute) {
                this._nodes_executable.push(this._nodes_in_order[i]);
            }
        }
    };

    //This is more internal, it computes the executable nodes in order and returns it
    LGraph.prototype.computeExecutionOrder = function(
        only_onExecute,
        set_level
    ) {
        var L = [];
        var S = [];
        var M = {};
        var visited_links = {}; //to avoid repeating links
        var remaining_links = {}; //to a

        //search for the nodes without inputs (starting nodes)
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            var node = this._nodes[i];
            if (only_onExecute && !node.onExecute) {
                continue;
            }

            M[node.id] = node; //add to pending nodes

            var num = 0; //num of input connections
            if (node.inputs) {
                for (var j = 0, l2 = node.inputs.length; j < l2; j++) {
                    if (node.inputs[j] && node.inputs[j].link != null) {
                        num += 1;
                    }
                }
            }

            if (num == 0) {
                //is a starting node
                S.push(node);
                if (set_level) {
                    node._level = 1;
                }
            } //num of input links
            else {
                if (set_level) {
                    node._level = 0;
                }
                remaining_links[node.id] = num;
            }
        }

        while (true) {
            if (S.length == 0) {
                break;
            }

            //get an starting node
            var node = S.shift();
            L.push(node); //add to ordered list
            delete M[node.id]; //remove from the pending nodes

            if (!node.outputs) {
                continue;
            }

            //for every output
            for (var i = 0; i < node.outputs.length; i++) {
                var output = node.outputs[i];
                //not connected
                if (
                    output == null ||
                    output.links == null ||
                    output.links.length == 0
                ) {
                    continue;
                }

                //for every connection
                for (var j = 0; j < output.links.length; j++) {
                    var link_id = output.links[j];
                    var link = this.links[link_id];
                    if (!link) {
                        continue;
                    }

                    //already visited link (ignore it)
                    if (visited_links[link.id]) {
                        continue;
                    }

                    var target_node = this.getNodeById(link.target_id);
                    if (target_node == null) {
                        visited_links[link.id] = true;
                        continue;
                    }

                    if (
                        set_level &&
                        (!target_node._level ||
                            target_node._level <= node._level)
                    ) {
                        target_node._level = node._level + 1;
                    }

                    visited_links[link.id] = true; //mark as visited
                    remaining_links[target_node.id] -= 1; //reduce the number of links remaining
                    if (remaining_links[target_node.id] == 0) {
                        S.push(target_node);
                    } //if no more links, then add to starters array
                }
            }
        }

        //the remaining ones (loops)
        for (var i in M) {
            L.push(M[i]);
        }

        if (L.length != this._nodes.length && LiteGraph.debug) {
            console.warn("something went wrong, nodes missing");
        }

        var l = L.length;

        //save order number in the node
        for (var i = 0; i < l; ++i) {
            L[i].order = i;
        }

        //sort now by priority
        L = L.sort(function(A, B) {
            var Ap = A.constructor.priority || A.priority || 0;
            var Bp = B.constructor.priority || B.priority || 0;
            if (Ap == Bp) {
                //if same priority, sort by order
                return A.order - B.order;
            }
            return Ap - Bp; //sort by priority
        });

        //save order number in the node, again...
        for (var i = 0; i < l; ++i) {
            L[i].order = i;
        }

        return L;
    };

    /**
     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
     * It doesn't include the node itself
     * @method getAncestors
     * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution
     */
    LGraph.prototype.getAncestors = function(node) {
        var ancestors = [];
        var pending = [node];
        var visited = {};

        while (pending.length) {
            var current = pending.shift();
            if (!current.inputs) {
                continue;
            }
            if (!visited[current.id] && current != node) {
                visited[current.id] = true;
                ancestors.push(current);
            }

            for (var i = 0; i < current.inputs.length; ++i) {
                var input = current.getInputNode(i);
                if (input && ancestors.indexOf(input) == -1) {
                    pending.push(input);
                }
            }
        }

        ancestors.sort(function(a, b) {
            return a.order - b.order;
        });
        return ancestors;
    };

    /**
     * Positions every node in a more readable manner
     * @method arrange
     */
    LGraph.prototype.arrange = function(margin) {
        margin = margin || 100;

        var nodes = this.computeExecutionOrder(false, true);
        var columns = [];
        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            var col = node._level || 1;
            if (!columns[col]) {
                columns[col] = [];
            }
            columns[col].push(node);
        }

        var x = margin;

        for (var i = 0; i < columns.length; ++i) {
            var column = columns[i];
            if (!column) {
                continue;
            }
            var max_size = 100;
            var y = margin + LiteGraph.NODE_TITLE_HEIGHT;
            for (var j = 0; j < column.length; ++j) {
                var node = column[j];
                node.pos[0] = x;
                node.pos[1] = y;
                if (node.size[0] > max_size) {
                    max_size = node.size[0];
                }
                y += node.size[1] + margin + LiteGraph.NODE_TITLE_HEIGHT;
            }
            x += max_size + margin;
        }

        this.setDirtyCanvas(true, true);
    };

    /**
     * Returns the amount of time the graph has been running in milliseconds
     * @method getTime
     * @return {number} number of milliseconds the graph has been running
     */
    LGraph.prototype.getTime = function() {
        return this.globaltime;
    };

    /**
     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
     * @method getFixedTime
     * @return {number} number of milliseconds the graph has been running
     */

    LGraph.prototype.getFixedTime = function() {
        return this.fixedtime;
    };

    /**
     * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
     * if the nodes are using graphical actions
     * @method getElapsedTime
     * @return {number} number of milliseconds it took the last cycle
     */

    LGraph.prototype.getElapsedTime = function() {
        return this.elapsed_time;
    };

    /**
     * Sends an event to all the nodes, useful to trigger stuff
     * @method sendEventToAllNodes
     * @param {String} eventname the name of the event (function to be called)
     * @param {Array} params parameters in array format
     */
    LGraph.prototype.sendEventToAllNodes = function(eventname, params, mode) {
        mode = mode || LiteGraph.ALWAYS;

        var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
        if (!nodes) {
            return;
        }

        for (var j = 0, l = nodes.length; j < l; ++j) {
            var node = nodes[j];

            if (
                node.constructor === LiteGraph.Subgraph &&
                eventname != "onExecute"
            ) {
                if (node.mode == mode) {
                    node.sendEventToAllNodes(eventname, params, mode);
                }
                continue;
            }

            if (!node[eventname] || node.mode != mode) {
                continue;
            }
            if (params === undefined) {
                node[eventname]();
            } else if (params && params.constructor === Array) {
                node[eventname].apply(node, params);
            } else {
                node[eventname](params);
            }
        }
    };

    LGraph.prototype.sendActionToCanvas = function(action, params) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
            var c = this.list_of_graphcanvas[i];
            if (c[action]) {
                c[action].apply(c, params);
            }
        }
    };

    /**
     * Adds a new node instance to this graph
     * @method add
     * @param {LGraphNode} node the instance of the node
     */

    LGraph.prototype.add = function(node, skip_compute_order) {
        if (!node) {
            return;
        }

        //groups
        if (node.constructor === LGraphGroup) {
            this._groups.push(node);
            this.setDirtyCanvas(true);
            this.change();
            node.graph = this;
            this._version++;
            return;
        }

        //nodes
        if (node.id != -1 && this._nodes_by_id[node.id] != null) {
            console.warn(
                "LiteGraph: there is already a node with this ID, changing it"
            );
            node.id = ++this.last_node_id;
        }

        if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {
            throw "LiteGraph: max number of nodes in a graph reached";
        }

        //give him an id
        if (node.id == null || node.id == -1) {
            node.id = ++this.last_node_id;
        } else if (this.last_node_id < node.id) {
            this.last_node_id = node.id;
        }

        node.graph = this;
        this._version++;

        this._nodes.push(node);
        this._nodes_by_id[node.id] = node;

        if (node.onAdded) {
            node.onAdded(this);
        }

        if (this.config.align_to_grid) {
            node.alignToGrid();
        }

        if (!skip_compute_order) {
            this.updateExecutionOrder();
        }

        if (this.onNodeAdded) {
            this.onNodeAdded(node);
        }

        this.setDirtyCanvas(true);
        this.change();

        return node; //to chain actions
    };

    /**
     * Removes a node from the graph
     * @method remove
     * @param {LGraphNode} node the instance of the node
     */

    LGraph.prototype.remove = function(node) {
        if (node.constructor === LiteGraph.LGraphGroup) {
            var index = this._groups.indexOf(node);
            if (index != -1) {
                this._groups.splice(index, 1);
            }
            node.graph = null;
            this._version++;
            this.setDirtyCanvas(true, true);
            this.change();
            return;
        }

        if (this._nodes_by_id[node.id] == null) {
            return;
        } //not found

        if (node.ignore_remove) {
            return;
        } //cannot be removed

		this.beforeChange(); //sure?

        //disconnect inputs
        if (node.inputs) {
            for (var i = 0; i < node.inputs.length; i++) {
                var slot = node.inputs[i];
                if (slot.link != null) {
                    node.disconnectInput(i);
                }
            }
        }

        //disconnect outputs
        if (node.outputs) {
            for (var i = 0; i < node.outputs.length; i++) {
                var slot = node.outputs[i];
                if (slot.links != null && slot.links.length) {
                    node.disconnectOutput(i);
                }
            }
        }

        //node.id = -1; //why?

        //callback
        if (node.onRemoved) {
            node.onRemoved();
        }

        node.graph = null;
        this._version++;

        //remove from canvas render
        if (this.list_of_graphcanvas) {
            for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
                var canvas = this.list_of_graphcanvas[i];
                if (canvas.selected_nodes[node.id]) {
                    delete canvas.selected_nodes[node.id];
                }
                if (canvas.node_dragged == node) {
                    canvas.node_dragged = null;
                }
            }
        }

        //remove from containers
        var pos = this._nodes.indexOf(node);
        if (pos != -1) {
            this._nodes.splice(pos, 1);
        }
        delete this._nodes_by_id[node.id];

        if (this.onNodeRemoved) {
            this.onNodeRemoved(node);
        }

		//close panels
		this.sendActionToCanvas("checkPanels");

        this.setDirtyCanvas(true, true);
		this.afterChange(); //sure?
        this.change();

        this.updateExecutionOrder();
    };

    /**
     * Returns a node by its id.
     * @method getNodeById
     * @param {Number} id
     */

    LGraph.prototype.getNodeById = function(id) {
        if (id == null) {
            return null;
        }
        return this._nodes_by_id[id];
    };

    /**
     * Returns a list of nodes that matches a class
     * @method findNodesByClass
     * @param {Class} classObject the class itself (not an string)
     * @return {Array} a list with all the nodes of this type
     */
    LGraph.prototype.findNodesByClass = function(classObject, result) {
        result = result || [];
        result.length = 0;
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].constructor === classObject) {
                result.push(this._nodes[i]);
            }
        }
        return result;
    };

    /**
     * Returns a list of nodes that matches a type
     * @method findNodesByType
     * @param {String} type the name of the node type
     * @return {Array} a list with all the nodes of this type
     */
    LGraph.prototype.findNodesByType = function(type, result) {
        var type = type.toLowerCase();
        result = result || [];
        result.length = 0;
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].type.toLowerCase() == type) {
                result.push(this._nodes[i]);
            }
        }
        return result;
    };

    /**
     * Returns the first node that matches a name in its title
     * @method findNodeByTitle
     * @param {String} name the name of the node to search
     * @return {Node} the node or null
     */
    LGraph.prototype.findNodeByTitle = function(title) {
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].title == title) {
                return this._nodes[i];
            }
        }
        return null;
    };

    /**
     * Returns a list of nodes that matches a name
     * @method findNodesByTitle
     * @param {String} name the name of the node to search
     * @return {Array} a list with all the nodes with this name
     */
    LGraph.prototype.findNodesByTitle = function(title) {
        var result = [];
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            if (this._nodes[i].title == title) {
                result.push(this._nodes[i]);
            }
        }
        return result;
    };

    /**
     * Returns the top-most node in this position of the canvas
     * @method getNodeOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph
     * @return {LGraphNode} the node at this position or null
     */
    LGraph.prototype.getNodeOnPos = function(x, y, nodes_list, margin) {
        nodes_list = nodes_list || this._nodes;
        for (var i = nodes_list.length - 1; i >= 0; i--) {
            var n = nodes_list[i];
            if (n.isPointInside(x, y, margin)) {
                return n;
            }
        }
        return null;
    };

    /**
     * Returns the top-most group in that position
     * @method getGroupOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @return {LGraphGroup} the group or null
     */
    LGraph.prototype.getGroupOnPos = function(x, y) {
        for (var i = this._groups.length - 1; i >= 0; i--) {
            var g = this._groups[i];
            if (g.isPointInside(x, y, 2, true)) {
                return g;
            }
        }
        return null;
    };

    /**
     * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
     * this replaces the ones using the old version with the new version
     * @method checkNodeTypes
     */
    LGraph.prototype.checkNodeTypes = function() {
        var changes = false;
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var ctor = LiteGraph.registered_node_types[node.type];
            if (node.constructor == ctor) {
                continue;
            }
            console.log("node being replaced by newer version: " + node.type);
            var newnode = LiteGraph.createNode(node.type);
            changes = true;
            this._nodes[i] = newnode;
            newnode.configure(node.serialize());
            newnode.graph = this;
            this._nodes_by_id[newnode.id] = newnode;
            if (node.inputs) {
                newnode.inputs = node.inputs.concat();
            }
            if (node.outputs) {
                newnode.outputs = node.outputs.concat();
            }
        }
        this.updateExecutionOrder();
    };

    // ********** GLOBALS *****************

    LGraph.prototype.onAction = function(action, param) {
        this._input_nodes = this.findNodesByClass(
            LiteGraph.GraphInput,
            this._input_nodes
        );
        for (var i = 0; i < this._input_nodes.length; ++i) {
            var node = this._input_nodes[i];
            if (node.properties.name != action) {
                continue;
            }
            node.onAction(action, param);
            break;
        }
    };

    LGraph.prototype.trigger = function(action, param) {
        if (this.onTrigger) {
            this.onTrigger(action, param);
        }
    };

    /**
     * Tell this graph it has a global graph input of this type
     * @method addGlobalInput
     * @param {String} name
     * @param {String} type
     * @param {*} value [optional]
     */
    LGraph.prototype.addInput = function(name, type, value) {
        var input = this.inputs[name];
        if (input) {
            //already exist
            return;
        }

		this.beforeChange();
        this.inputs[name] = { name: name, type: type, value: value };
        this._version++;
		this.afterChange();

        if (this.onInputAdded) {
            this.onInputAdded(name, type);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Assign a data to the global graph input
     * @method setGlobalInputData
     * @param {String} name
     * @param {*} data
     */
    LGraph.prototype.setInputData = function(name, data) {
        var input = this.inputs[name];
        if (!input) {
            return;
        }
        input.value = data;
    };

    /**
     * Returns the current value of a global graph input
     * @method getInputData
     * @param {String} name
     * @return {*} the data
     */
    LGraph.prototype.getInputData = function(name) {
        var input = this.inputs[name];
        if (!input) {
            return null;
        }
        return input.value;
    };

    /**
     * Changes the name of a global graph input
     * @method renameInput
     * @param {String} old_name
     * @param {String} new_name
     */
    LGraph.prototype.renameInput = function(old_name, name) {
        if (name == old_name) {
            return;
        }

        if (!this.inputs[old_name]) {
            return false;
        }

        if (this.inputs[name]) {
            console.error("there is already one input with that name");
            return false;
        }

        this.inputs[name] = this.inputs[old_name];
        delete this.inputs[old_name];
        this._version++;

        if (this.onInputRenamed) {
            this.onInputRenamed(old_name, name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Changes the type of a global graph input
     * @method changeInputType
     * @param {String} name
     * @param {String} type
     */
    LGraph.prototype.changeInputType = function(name, type) {
        if (!this.inputs[name]) {
            return false;
        }

        if (
            this.inputs[name].type &&
            String(this.inputs[name].type).toLowerCase() ==
                String(type).toLowerCase()
        ) {
            return;
        }

        this.inputs[name].type = type;
        this._version++;
        if (this.onInputTypeChanged) {
            this.onInputTypeChanged(name, type);
        }
    };

    /**
     * Removes a global graph input
     * @method removeInput
     * @param {String} name
     * @param {String} type
     */
    LGraph.prototype.removeInput = function(name) {
        if (!this.inputs[name]) {
            return false;
        }

        delete this.inputs[name];
        this._version++;

        if (this.onInputRemoved) {
            this.onInputRemoved(name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
        return true;
    };

    /**
     * Creates a global graph output
     * @method addOutput
     * @param {String} name
     * @param {String} type
     * @param {*} value
     */
    LGraph.prototype.addOutput = function(name, type, value) {
        this.outputs[name] = { name: name, type: type, value: value };
        this._version++;

        if (this.onOutputAdded) {
            this.onOutputAdded(name, type);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Assign a data to the global output
     * @method setOutputData
     * @param {String} name
     * @param {String} value
     */
    LGraph.prototype.setOutputData = function(name, value) {
        var output = this.outputs[name];
        if (!output) {
            return;
        }
        output.value = value;
    };

    /**
     * Returns the current value of a global graph output
     * @method getOutputData
     * @param {String} name
     * @return {*} the data
     */
    LGraph.prototype.getOutputData = function(name) {
        var output = this.outputs[name];
        if (!output) {
            return null;
        }
        return output.value;
    };

    /**
     * Renames a global graph output
     * @method renameOutput
     * @param {String} old_name
     * @param {String} new_name
     */
    LGraph.prototype.renameOutput = function(old_name, name) {
        if (!this.outputs[old_name]) {
            return false;
        }

        if (this.outputs[name]) {
            console.error("there is already one output with that name");
            return false;
        }

        this.outputs[name] = this.outputs[old_name];
        delete this.outputs[old_name];
        this._version++;

        if (this.onOutputRenamed) {
            this.onOutputRenamed(old_name, name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    };

    /**
     * Changes the type of a global graph output
     * @method changeOutputType
     * @param {String} name
     * @param {String} type
     */
    LGraph.prototype.changeOutputType = function(name, type) {
        if (!this.outputs[name]) {
            return false;
        }

        if (
            this.outputs[name].type &&
            String(this.outputs[name].type).toLowerCase() ==
                String(type).toLowerCase()
        ) {
            return;
        }

        this.outputs[name].type = type;
        this._version++;
        if (this.onOutputTypeChanged) {
            this.onOutputTypeChanged(name, type);
        }
    };

    /**
     * Removes a global graph output
     * @method removeOutput
     * @param {String} name
     */
    LGraph.prototype.removeOutput = function(name) {
        if (!this.outputs[name]) {
            return false;
        }
        delete this.outputs[name];
        this._version++;

        if (this.onOutputRemoved) {
            this.onOutputRemoved(name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
        return true;
    };

    LGraph.prototype.triggerInput = function(name, value) {
        var nodes = this.findNodesByTitle(name);
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].onTrigger(value);
        }
    };

    LGraph.prototype.setCallback = function(name, func) {
        var nodes = this.findNodesByTitle(name);
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].setTrigger(func);
        }
    };

	//used for undo, called before any change is made to the graph
    LGraph.prototype.beforeChange = function(info) {
        if (this.onBeforeChange) {
            this.onBeforeChange(this,info);
        }
        this.sendActionToCanvas("onBeforeChange", this);
    };

	//used to resend actions, called after any change is made to the graph
    LGraph.prototype.afterChange = function(info) {
        if (this.onAfterChange) {
            this.onAfterChange(this,info);
        }
        this.sendActionToCanvas("onAfterChange", this);
    };

    LGraph.prototype.connectionChange = function(node, link_info) {
        this.updateExecutionOrder();
        if (this.onConnectionChange) {
            this.onConnectionChange(node);
        }
        this._version++;
        this.sendActionToCanvas("onConnectionChange");
    };

    /**
     * returns if the graph is in live mode
     * @method isLive
     */

    LGraph.prototype.isLive = function() {
        if (!this.list_of_graphcanvas) {
            return false;
        }

        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {
            var c = this.list_of_graphcanvas[i];
            if (c.live_mode) {
                return true;
            }
        }
        return false;
    };

    /**
     * clears the triggered slot animation in all links (stop visual animation)
     * @method clearTriggeredSlots
     */
    LGraph.prototype.clearTriggeredSlots = function() {
        for (var i in this.links) {
            var link_info = this.links[i];
            if (!link_info) {
                continue;
            }
            if (link_info._last_time) {
                link_info._last_time = 0;
            }
        }
    };

    /* Called when something visually changed (not the graph!) */
    LGraph.prototype.change = function() {
        if (LiteGraph.debug) {
            console.log("Graph changed");
        }
        this.sendActionToCanvas("setDirty", [true, true]);
        if (this.on_change) {
            this.on_change(this);
        }
    };

    LGraph.prototype.setDirtyCanvas = function(fg, bg) {
        this.sendActionToCanvas("setDirty", [fg, bg]);
    };

    /**
     * Destroys a link
     * @method removeLink
     * @param {Number} link_id
     */
    LGraph.prototype.removeLink = function(link_id) {
        var link = this.links[link_id];
        if (!link) {
            return;
        }
        var node = this.getNodeById(link.target_id);
        if (node) {
            node.disconnectInput(link.target_slot);
        }
    };

    //save and recover app state ***************************************
    /**
     * Creates a Object containing all the info about this graph, it can be serialized
     * @method serialize
     * @return {Object} value of the node
     */
    LGraph.prototype.serialize = function() {
        var nodes_info = [];
        for (var i = 0, l = this._nodes.length; i < l; ++i) {
            nodes_info.push(this._nodes[i].serialize());
        }

        //pack link info into a non-verbose format
        var links = [];
        for (var i in this.links) {
            //links is an OBJECT
            var link = this.links[i];
            if (!link.serialize) {
                //weird bug I havent solved yet
                console.warn(
                    "weird LLink bug, link info is not a LLink but a regular object"
                );
                var link2 = new LLink();
                for (var j in link) { 
                    link2[j] = link[j];
                }
                this.links[i] = link2;
                link = link2;
            }

            links.push(link.serialize());
        }

        var groups_info = [];
        for (var i = 0; i < this._groups.length; ++i) {
            groups_info.push(this._groups[i].serialize());
        }

        var data = {
            last_node_id: this.last_node_id,
            last_link_id: this.last_link_id,
            nodes: nodes_info,
            links: links,
            groups: groups_info,
            config: this.config,
			extra: this.extra,
            version: LiteGraph.VERSION
        };

		if(this.onSerialize)
			this.onSerialize(data);

        return data;
    };

    /**
     * Configure a graph from a JSON string
     * @method configure
     * @param {String} str configure a graph from a JSON string
     * @param {Boolean} returns if there was any error parsing
     */
    LGraph.prototype.configure = function(data, keep_old) {
        if (!data) {
            return;
        }

        if (!keep_old) {
            this.clear();
        }

        var nodes = data.nodes;

        //decode links info (they are very verbose)
        if (data.links && data.links.constructor === Array) {
            var links = [];
            for (var i = 0; i < data.links.length; ++i) {
                var link_data = data.links[i];
				if(!link_data) //weird bug
				{
					console.warn("serialized graph link data contains errors, skipping.");
					continue;
				}
                var link = new LLink();
                link.configure(link_data);
                links[link.id] = link;
            }
            data.links = links;
        }

        //copy all stored fields
        for (var i in data) {
			if(i == "nodes" || i == "groups" ) //links must be accepted
				continue;
            this[i] = data[i];
        }

        var error = false;

        //create nodes
        this._nodes = [];
        if (nodes) {
            for (var i = 0, l = nodes.length; i < l; ++i) {
                var n_info = nodes[i]; //stored info
                var node = LiteGraph.createNode(n_info.type, n_info.title);
                if (!node) {
                    if (LiteGraph.debug) {
                        console.log(
                            "Node not found or has errors: " + n_info.type
                        );
                    }

                    //in case of error we create a replacement node to avoid losing info
                    node = new LGraphNode();
                    node.last_serialization = n_info;
                    node.has_errors = true;
                    error = true;
                    //continue;
                }

                node.id = n_info.id; //id it or it will create a new id
                this.add(node, true); //add before configure, otherwise configure cannot create links
            }

            //configure nodes afterwards so they can reach each other
            for (var i = 0, l = nodes.length; i < l; ++i) {
                var n_info = nodes[i];
                var node = this.getNodeById(n_info.id);
                if (node) {
                    node.configure(n_info);
                }
            }
        }

        //groups
        this._groups.length = 0;
        if (data.groups) {
            for (var i = 0; i < data.groups.length; ++i) {
                var group = new LiteGraph.LGraphGroup();
                group.configure(data.groups[i]);
                this.add(group);
            }
        }

        this.updateExecutionOrder();

		this.extra = data.extra || {};

		if(this.onConfigure)
			this.onConfigure(data);

        this._version++;
        this.setDirtyCanvas(true, true);
        return error;
    };

    LGraph.prototype.load = function(url, callback) {
        var that = this;

		//from file
		if(url.constructor === File || url.constructor === Blob)
		{
			var reader = new FileReader();
			reader.addEventListener('load', function(event) {
				var data = JSON.parse(event.target.result);
				that.configure(data);
				if(callback)
					callback();
			});
			
			reader.readAsText(url);
			return;
		}

		//is a string, then an URL
        var req = new XMLHttpRequest();
        req.open("GET", url, true);
        req.send(null);
        req.onload = function(oEvent) {
            if (req.status !== 200) {
                console.error("Error loading graph:", req.status, req.response);
                return;
            }
            var data = JSON.parse( req.response );
            that.configure(data);
			if(callback)
				callback();
        };
        req.onerror = function(err) {
            console.error("Error loading graph:", err);
        };
    };

    LGraph.prototype.onNodeTrace = function(node, msg, color) {
        //TODO
    };

    //this is the class in charge of storing link information
    function LLink(id, type, origin_id, origin_slot, target_id, target_slot) {
        this.id = id;
        this.type = type;
        this.origin_id = origin_id;
        this.origin_slot = origin_slot;
        this.target_id = target_id;
        this.target_slot = target_slot;

        this._data = null;
        this._pos = new Float32Array(2); //center
    }

    LLink.prototype.configure = function(o) {
        if (o.constructor === Array) {
            this.id = o[0];
            this.origin_id = o[1];
            this.origin_slot = o[2];
            this.target_id = o[3];
            this.target_slot = o[4];
            this.type = o[5];
        } else {
            this.id = o.id;
            this.type = o.type;
            this.origin_id = o.origin_id;
            this.origin_slot = o.origin_slot;
            this.target_id = o.target_id;
            this.target_slot = o.target_slot;
        }
    };

    LLink.prototype.serialize = function() {
        return [
            this.id,
            this.origin_id,
            this.origin_slot,
            this.target_id,
            this.target_slot,
            this.type
        ];
    };

    LiteGraph.LLink = LLink;

    // *************************************************************
    //   Node CLASS                                          *******
    // *************************************************************

    /*
	title: string
	pos: [x,y]
	size: [x,y]

	input|output: every connection
		+  { name:string, type:string, pos: [x,y]=Optional, direction: "input"|"output", links: Array });

	general properties:
		+ clip_area: if you render outside the node, it will be clipped
		+ unsafe_execution: not allowed for safe execution
		+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected
		+ resizable: if set to false it wont be resizable with the mouse
		+ horizontal: slots are distributed horizontally
		+ widgets_start_y: widgets start at y distance from the top of the node
	
	flags object:
		+ collapsed: if it is collapsed

	supported callbacks:
		+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)
		+ onRemoved: when removed from graph
		+ onStart:	when the graph starts playing
		+ onStop:	when the graph stops playing
		+ onDrawForeground: render the inside widgets inside the node
		+ onDrawBackground: render the background area inside the node (only in edit mode)
		+ onMouseDown
		+ onMouseMove
		+ onMouseUp
		+ onMouseEnter
		+ onMouseLeave
		+ onExecute: execute the node
		+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)
		+ onGetInputs: returns an array of possible inputs
		+ onGetOutputs: returns an array of possible outputs
		+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])
		+ onDblClick: double clicked in the node
		+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)
		+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)
		+ onConfigure: called after the node has been configured
		+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)
		+ onSelected
		+ onDeselected
		+ onDropItem : DOM item dropped over the node
		+ onDropFile : file dropped over the node
		+ onConnectInput : if returns false the incoming connection will be canceled
		+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )
		+ onAction: action slot triggered
		+ getExtraMenuOptions: to add option to context menu
*/

    /**
     * Base Class for all the node type classes
     * @class LGraphNode
     * @param {String} name a name for the node
     */

    function LGraphNode(title) {
        this._ctor(title);
    }

    global.LGraphNode = LiteGraph.LGraphNode = LGraphNode;

    LGraphNode.prototype._ctor = function(title) {
        this.title = title || "Unnamed";
        this.size = [LiteGraph.NODE_WIDTH, 60];
        this.graph = null;

        this._pos = new Float32Array(10, 10);

        Object.defineProperty(this, "pos", {
            set: function(v) {
                if (!v || v.length < 2) {
                    return;
                }
                this._pos[0] = v[0];
                this._pos[1] = v[1];
            },
            get: function() {
                return this._pos;
            },
            enumerable: true
        });

        this.id = -1; //not know till not added
        this.type = null;

        //inputs available: array of inputs
        this.inputs = [];
        this.outputs = [];
        this.connections = [];

        //local data
        this.properties = {}; //for the values
        this.properties_info = []; //for the info

        this.flags = {};
    };

    /**
     * configure a node from an object containing the serialized info
     * @method configure
     */
    LGraphNode.prototype.configure = function(info) {
        if (this.graph) {
            this.graph._version++;
        }
        for (var j in info) {
            if (j == "properties") {
                //i don't want to clone properties, I want to reuse the old container
                for (var k in info.properties) {
                    this.properties[k] = info.properties[k];
                    if (this.onPropertyChanged) {
                        this.onPropertyChanged( k, info.properties[k] );
                    }
                }
                continue;
            }

            if (info[j] == null) {
                continue;
            } else if (typeof info[j] == "object") {
                //object
                if (this[j] && this[j].configure) {
                    this[j].configure(info[j]);
                } else {
                    this[j] = LiteGraph.cloneObject(info[j], this[j]);
                }
            } //value
            else {
                this[j] = info[j];
            }
        }

        if (!info.title) {
            this.title = this.constructor.title;
        }

        if (this.onConnectionsChange) {
            if (this.inputs) {
                for (var i = 0; i < this.inputs.length; ++i) {
                    var input = this.inputs[i];
                    var link_info = this.graph
                        ? this.graph.links[input.link]
                        : null;
                    this.onConnectionsChange(
                        LiteGraph.INPUT,
                        i,
                        true,
                        link_info,
                        input
                    ); //link_info has been created now, so its updated
                }
            }

            if (this.outputs) {
                for (var i = 0; i < this.outputs.length; ++i) {
                    var output = this.outputs[i];
                    if (!output.links) {
                        continue;
                    }
                    for (var j = 0; j < output.links.length; ++j) {
                        var link_info = this.graph
                            ? this.graph.links[output.links[j]]
                            : null;
                        this.onConnectionsChange(
                            LiteGraph.OUTPUT,
                            i,
                            true,
                            link_info,
                            output
                        ); //link_info has been created now, so its updated
                    }
                }
            }
        }

		if( this.widgets )
		{
			for (var i = 0; i < this.widgets.length; ++i)
			{
				var w = this.widgets[i];
				if(!w)
					continue;
				if(w.options && w.options.property && this.properties[ w.options.property ])
					w.value = JSON.parse( JSON.stringify( this.properties[ w.options.property ] ) );
			}
			if (info.widgets_values) {
				for (var i = 0; i < info.widgets_values.length; ++i) {
					if (this.widgets[i]) {
						this.widgets[i].value = info.widgets_values[i];
					}
				}
			}
		}

        if (this.onConfigure) {
            this.onConfigure(info);
        }
    };

    /**
     * serialize the content
     * @method serialize
     */

    LGraphNode.prototype.serialize = function() {
        //create serialization object
        var o = {
            id: this.id,
            type: this.type,
            pos: this.pos,
            size: this.size,
            flags: LiteGraph.cloneObject(this.flags),
			order: this.order,
            mode: this.mode
        };

        //special case for when there were errors
        if (this.constructor === LGraphNode && this.last_serialization) {
            return this.last_serialization;
        }

        if (this.inputs) {
            o.inputs = this.inputs;
        }

        if (this.outputs) {
            //clear outputs last data (because data in connections is never serialized but stored inside the outputs info)
            for (var i = 0; i < this.outputs.length; i++) {
                delete this.outputs[i]._data;
            }
            o.outputs = this.outputs;
        }

        if (this.title && this.title != this.constructor.title) {
            o.title = this.title;
        }

        if (this.properties) {
            o.properties = LiteGraph.cloneObject(this.properties);
        }

        if (this.widgets && this.serialize_widgets) {
            o.widgets_values = [];
            for (var i = 0; i < this.widgets.length; ++i) {
				if(this.widgets[i])
	                o.widgets_values[i] = this.widgets[i].value;
				else
					o.widgets_values[i] = null;
            }
        }

        if (!o.type) {
            o.type = this.constructor.type;
        }

        if (this.color) {
            o.color = this.color;
        }
        if (this.bgcolor) {
            o.bgcolor = this.bgcolor;
        }
        if (this.boxcolor) {
            o.boxcolor = this.boxcolor;
        }
        if (this.shape) {
            o.shape = this.shape;
        }

        if (this.onSerialize) {
            if (this.onSerialize(o)) {
                console.warn(
                    "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter"
                );
            }
        }

        return o;
    };

    /* Creates a clone of this node */
    LGraphNode.prototype.clone = function() {
        var node = LiteGraph.createNode(this.type);
        if (!node) {
            return null;
        }

        //we clone it because serialize returns shared containers
        var data = LiteGraph.cloneObject(this.serialize());

        //remove links
        if (data.inputs) {
            for (var i = 0; i < data.inputs.length; ++i) {
                data.inputs[i].link = null;
            }
        }

        if (data.outputs) {
            for (var i = 0; i < data.outputs.length; ++i) {
                if (data.outputs[i].links) {
                    data.outputs[i].links.length = 0;
                }
            }
        }

        delete data["id"];
        //remove links
        node.configure(data);

        return node;
    };

    /**
     * serialize and stringify
     * @method toString
     */

    LGraphNode.prototype.toString = function() {
        return JSON.stringify(this.serialize());
    };
    //LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph

    /**
     * get the title string
     * @method getTitle
     */

    LGraphNode.prototype.getTitle = function() {
        return this.title || this.constructor.title;
    };

    /**
     * sets the value of a property
     * @method setProperty
     * @param {String} name
     * @param {*} value
     */
    LGraphNode.prototype.setProperty = function(name, value) {
        if (!this.properties) {
            this.properties = {};
        }
		if( value === this.properties[name] )
			return;
		var prev_value = this.properties[name];
        this.properties[name] = value;
        if (this.onPropertyChanged) {
            if( this.onPropertyChanged(name, value, prev_value) === false ) //abort change
				this.properties[name] = prev_value;
        }
		if(this.widgets) //widgets could be linked to properties
			for(var i = 0; i < this.widgets.length; ++i)
			{
				var w = this.widgets[i];
				if(!w)
					continue;
				if(w.options.property == name)
				{
					w.value = value;
					break;
				}
			}
    };

    // Execution *************************
    /**
     * sets the output data
     * @method setOutputData
     * @param {number} slot
     * @param {*} data
     */
    LGraphNode.prototype.setOutputData = function(slot, data) {
        if (!this.outputs) {
            return;
        }

        //this maybe slow and a niche case
        //if(slot && slot.constructor === String)
        //	slot = this.findOutputSlot(slot);

        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }

        var output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }

        //store data in the output itself in case we want to debug
        output_info._data = data;

        //if there are connections, pass the data to the connections
        if (this.outputs[slot].links) {
            for (var i = 0; i < this.outputs[slot].links.length; i++) {
                var link_id = this.outputs[slot].links[i];
				var link = this.graph.links[link_id];
				if(link)
					link.data = data;
            }
        }
    };

    /**
     * sets the output data type, useful when you want to be able to overwrite the data type
     * @method setOutputDataType
     * @param {number} slot
     * @param {String} datatype
     */
    LGraphNode.prototype.setOutputDataType = function(slot, type) {
        if (!this.outputs) {
            return;
        }
        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }
        var output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }
        //store data in the output itself in case we want to debug
        output_info.type = type;

        //if there are connections, pass the data to the connections
        if (this.outputs[slot].links) {
            for (var i = 0; i < this.outputs[slot].links.length; i++) {
                var link_id = this.outputs[slot].links[i];
                this.graph.links[link_id].type = type;
            }
        }
    };

    /**
     * Retrieves the input data (data traveling through the connection) from one slot
     * @method getInputData
     * @param {number} slot
     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
     * @return {*} data or if it is not connected returns undefined
     */
    LGraphNode.prototype.getInputData = function(slot, force_update) {
        if (!this.inputs) {
            return;
        } //undefined;

        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return;
        }

        var link_id = this.inputs[slot].link;
        var link = this.graph.links[link_id];
        if (!link) {
            //bug: weird case but it happens sometimes
            return null;
        }

        if (!force_update) {
            return link.data;
        }

        //special case: used to extract data from the incoming connection before the graph has been executed
        var node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.data;
        }

        if (node.updateOutputData) {
            node.updateOutputData(link.origin_slot);
        } else if (node.onExecute) {
            node.onExecute();
        }

        return link.data;
    };

    /**
     * Retrieves the input data type (in case this supports multiple input types)
     * @method getInputDataType
     * @param {number} slot
     * @return {String} datatype in string format
     */
    LGraphNode.prototype.getInputDataType = function(slot) {
        if (!this.inputs) {
            return null;
        } //undefined;

        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return null;
        }
        var link_id = this.inputs[slot].link;
        var link = this.graph.links[link_id];
        if (!link) {
            //bug: weird case but it happens sometimes
            return null;
        }
        var node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.type;
        }
        var output_info = node.outputs[link.origin_slot];
        if (output_info) {
            return output_info.type;
        }
        return null;
    };

    /**
     * Retrieves the input data from one slot using its name instead of slot number
     * @method getInputDataByName
     * @param {String} slot_name
     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
     * @return {*} data or if it is not connected returns null
     */
    LGraphNode.prototype.getInputDataByName = function(
        slot_name,
        force_update
    ) {
        var slot = this.findInputSlot(slot_name);
        if (slot == -1) {
            return null;
        }
        return this.getInputData(slot, force_update);
    };

    /**
     * tells you if there is a connection in one input slot
     * @method isInputConnected
     * @param {number} slot
     * @return {boolean}
     */
    LGraphNode.prototype.isInputConnected = function(slot) {
        if (!this.inputs) {
            return false;
        }
        return slot < this.inputs.length && this.inputs[slot].link != null;
    };

    /**
     * tells you info about an input connection (which node, type, etc)
     * @method getInputInfo
     * @param {number} slot
     * @return {Object} object or null { link: id, name: string, type: string or 0 }
     */
    LGraphNode.prototype.getInputInfo = function(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot < this.inputs.length) {
            return this.inputs[slot];
        }
        return null;
    };

    /**
     * Returns the link info in the connection of an input slot
     * @method getInputLink
     * @param {number} slot
     * @return {LLink} object or null
     */
    LGraphNode.prototype.getInputLink = function(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot < this.inputs.length) {
            var slot_info = this.inputs[slot];
			return this.graph.links[ slot_info.link ];
        }
        return null;
    };

    /**
     * returns the node connected in the input slot
     * @method getInputNode
     * @param {number} slot
     * @return {LGraphNode} node or null
     */
    LGraphNode.prototype.getInputNode = function(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot >= this.inputs.length) {
            return null;
        }
        var input = this.inputs[slot];
        if (!input || input.link === null) {
            return null;
        }
        var link_info = this.graph.links[input.link];
        if (!link_info) {
            return null;
        }
        return this.graph.getNodeById(link_info.origin_id);
    };

    /**
     * returns the value of an input with this name, otherwise checks if there is a property with that name
     * @method getInputOrProperty
     * @param {string} name
     * @return {*} value
     */
    LGraphNode.prototype.getInputOrProperty = function(name) {
        if (!this.inputs || !this.inputs.length) {
            return this.properties ? this.properties[name] : null;
        }

        for (var i = 0, l = this.inputs.length; i < l; ++i) {
            var input_info = this.inputs[i];
            if (name == input_info.name && input_info.link != null) {
                var link = this.graph.links[input_info.link];
                if (link) {
                    return link.data;
                }
            }
        }
        return this.properties[name];
    };

    /**
     * tells you the last output data that went in that slot
     * @method getOutputData
     * @param {number} slot
     * @return {Object}  object or null
     */
    LGraphNode.prototype.getOutputData = function(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot >= this.outputs.length) {
            return null;
        }

        var info = this.outputs[slot];
        return info._data;
    };

    /**
     * tells you info about an output connection (which node, type, etc)
     * @method getOutputInfo
     * @param {number} slot
     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }
     */
    LGraphNode.prototype.getOutputInfo = function(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot < this.outputs.length) {
            return this.outputs[slot];
        }
        return null;
    };

    /**
     * tells you if there is a connection in one output slot
     * @method isOutputConnected
     * @param {number} slot
     * @return {boolean}
     */
    LGraphNode.prototype.isOutputConnected = function(slot) {
        if (!this.outputs) {
            return false;
        }
        return (
            slot < this.outputs.length &&
            this.outputs[slot].links &&
            this.outputs[slot].links.length
        );
    };

    /**
     * tells you if there is any connection in the output slots
     * @method isAnyOutputConnected
     * @return {boolean}
     */
    LGraphNode.prototype.isAnyOutputConnected = function() {
        if (!this.outputs) {
            return false;
        }
        for (var i = 0; i < this.outputs.length; ++i) {
            if (this.outputs[i].links && this.outputs[i].links.length) {
                return true;
            }
        }
        return false;
    };

    /**
     * retrieves all the nodes connected to this output slot
     * @method getOutputNodes
     * @param {number} slot
     * @return {array}
     */
    LGraphNode.prototype.getOutputNodes = function(slot) {
        if (!this.outputs || this.outputs.length == 0) {
            return null;
        }

        if (slot >= this.outputs.length) {
            return null;
        }

        var output = this.outputs[slot];
        if (!output.links || output.links.length == 0) {
            return null;
        }

        var r = [];
        for (var i = 0; i < output.links.length; i++) {
            var link_id = output.links[i];
            var link = this.graph.links[link_id];
            if (link) {
                var target_node = this.graph.getNodeById(link.target_id);
                if (target_node) {
                    r.push(target_node);
                }
            }
        }
        return r;
    };

    /**
     * Triggers an event in this node, this will trigger any output with the same name
     * @method trigger
     * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all
     * @param {*} param
     */
    LGraphNode.prototype.trigger = function(action, param) {
        if (!this.outputs || !this.outputs.length) {
            return;
        }

        if (this.graph)
            this.graph._last_trigger_time = LiteGraph.getTime();

        for (var i = 0; i < this.outputs.length; ++i) {
            var output = this.outputs[i];
            if ( !output || output.type !== LiteGraph.EVENT || (action && output.name != action) )
                continue;
            this.triggerSlot(i, param);
        }
    };

    /**
     * Triggers an slot event in this node
     * @method triggerSlot
     * @param {Number} slot the index of the output slot
     * @param {*} param
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
     */
    LGraphNode.prototype.triggerSlot = function(slot, param, link_id) {
        if (!this.outputs) {
            return;
        }

        var output = this.outputs[slot];
        if (!output) {
            return;
        }

        var links = output.links;
        if (!links || !links.length) {
            return;
        }

        if (this.graph) {
            this.graph._last_trigger_time = LiteGraph.getTime();
        }

        //for every link attached here
        for (var k = 0; k < links.length; ++k) {
            var id = links[k];
            if (link_id != null && link_id != id) {
                //to skip links
                continue;
            }
            var link_info = this.graph.links[links[k]];
            if (!link_info) {
                //not connected
                continue;
            }
            link_info._last_time = LiteGraph.getTime();
            var node = this.graph.getNodeById(link_info.target_id);
            if (!node) {
                //node not found?
                continue;
            }

            //used to mark events in graph
            var target_connection = node.inputs[link_info.target_slot];

			if (node.mode === LiteGraph.ON_TRIGGER)
			{
                if (node.onExecute) {
                    node.onExecute(param);
                }
			}
			else if (node.onAction) {
                node.onAction(target_connection.name, param);
            }
        }
    };

    /**
     * clears the trigger slot animation
     * @method clearTriggeredSlot
     * @param {Number} slot the index of the output slot
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
     */
    LGraphNode.prototype.clearTriggeredSlot = function(slot, link_id) {
        if (!this.outputs) {
            return;
        }

        var output = this.outputs[slot];
        if (!output) {
            return;
        }

        var links = output.links;
        if (!links || !links.length) {
            return;
        }

        //for every link attached here
        for (var k = 0; k < links.length; ++k) {
            var id = links[k];
            if (link_id != null && link_id != id) {
                //to skip links
                continue;
            }
            var link_info = this.graph.links[links[k]];
            if (!link_info) {
                //not connected
                continue;
            }
            link_info._last_time = 0;
        }
    };

    /**
     * changes node size and triggers callback
     * @method setSize
     * @param {vec2} size
     */
    LGraphNode.prototype.setSize = function(size)
	{
		this.size = size;
		if(this.onResize)
			this.onResize(this.size);
	}

    /**
     * add a new property to this node
     * @method addProperty
     * @param {string} name
     * @param {*} default_value
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)
     */
    LGraphNode.prototype.addProperty = function(
        name,
        default_value,
        type,
        extra_info
    ) {
        var o = { name: name, type: type, default_value: default_value };
        if (extra_info) {
            for (var i in extra_info) {
                o[i] = extra_info[i];
            }
        }
        if (!this.properties_info) {
            this.properties_info = [];
        }
        this.properties_info.push(o);
        if (!this.properties) {
            this.properties = {};
        }
        this.properties[name] = default_value;
        return o;
    };

    //connections

    /**
     * add a new output slot to use in this node
     * @method addOutput
     * @param {string} name
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of an output (label, special color, position, etc)
     */
    LGraphNode.prototype.addOutput = function(name, type, extra_info) {
        var o = { name: name, type: type, links: null };
        if (extra_info) {
            for (var i in extra_info) {
                o[i] = extra_info[i];
            }
        }

        if (!this.outputs) {
            this.outputs = [];
        }
        this.outputs.push(o);
        if (this.onOutputAdded) {
            this.onOutputAdded(o);
        }
        this.setSize( this.computeSize() );
        this.setDirtyCanvas(true, true);
        return o;
    };

    /**
     * add a new output slot to use in this node
     * @method addOutputs
     * @param {Array} array of triplets like [[name,type,extra_info],[...]]
     */
    LGraphNode.prototype.addOutputs = function(array) {
        for (var i = 0; i < array.length; ++i) {
            var info = array[i];
            var o = { name: info[0], type: info[1], link: null };
            if (array[2]) {
                for (var j in info[2]) {
                    o[j] = info[2][j];
                }
            }

            if (!this.outputs) {
                this.outputs = [];
            }
            this.outputs.push(o);
            if (this.onOutputAdded) {
                this.onOutputAdded(o);
            }
        }

        this.setSize( this.computeSize() );
        this.setDirtyCanvas(true, true);
    };

    /**
     * remove an existing output slot
     * @method removeOutput
     * @param {number} slot
     */
    LGraphNode.prototype.removeOutput = function(slot) {
        this.disconnectOutput(slot);
        this.outputs.splice(slot, 1);
        for (var i = slot; i < this.outputs.length; ++i) {
            if (!this.outputs[i] || !this.outputs[i].links) {
                continue;
            }
            var links = this.outputs[i].links;
            for (var j = 0; j < links.length; ++j) {
                var link = this.graph.links[links[j]];
                if (!link) {
                    continue;
                }
                link.origin_slot -= 1;
            }
        }

        this.setSize( this.computeSize() );
        if (this.onOutputRemoved) {
            this.onOutputRemoved(slot);
        }
        this.setDirtyCanvas(true, true);
    };

    /**
     * add a new input slot to use in this node
     * @method addInput
     * @param {string} name
     * @param {string} type string defining the input type ("vec3","number",...), it its a generic one use 0
     * @param {Object} extra_info this can be used to have special properties of an input (label, color, position, etc)
     */
    LGraphNode.prototype.addInput = function(name, type, extra_info) {
        type = type || 0;
        var o = { name: name, type: type, link: null };
        if (extra_info) {
            for (var i in extra_info) {
                o[i] = extra_info[i];
            }
        }

        if (!this.inputs) {
            this.inputs = [];
        }

        this.inputs.push(o);
        this.setSize( this.computeSize() );

        if (this.onInputAdded) {
            this.onInputAdded(o);
        }

        this.setDirtyCanvas(true, true);
        return o;
    };

    /**
     * add several new input slots in this node
     * @method addInputs
     * @param {Array} array of triplets like [[name,type,extra_info],[...]]
     */
    LGraphNode.prototype.addInputs = function(array) {
        for (var i = 0; i < array.length; ++i) {
            var info = array[i];
            var o = { name: info[0], type: info[1], link: null };
            if (array[2]) {
                for (var j in info[2]) {
                    o[j] = info[2][j];
                }
            }

            if (!this.inputs) {
                this.inputs = [];
            }
            this.inputs.push(o);
            if (this.onInputAdded) {
                this.onInputAdded(o);
            }
        }

        this.setSize( this.computeSize() );
        this.setDirtyCanvas(true, true);
    };

    /**
     * remove an existing input slot
     * @method removeInput
     * @param {number} slot
     */
    LGraphNode.prototype.removeInput = function(slot) {
        this.disconnectInput(slot);
        var slot_info = this.inputs.splice(slot, 1);
        for (var i = slot; i < this.inputs.length; ++i) {
            if (!this.inputs[i]) {
                continue;
            }
            var link = this.graph.links[this.inputs[i].link];
            if (!link) {
                continue;
            }
            link.target_slot -= 1;
        }
        this.setSize( this.computeSize() );
        if (this.onInputRemoved) {
            this.onInputRemoved(slot, slot_info[0] );
        }
        this.setDirtyCanvas(true, true);
    };

    /**
     * add an special connection to this node (used for special kinds of graphs)
     * @method addConnection
     * @param {string} name
     * @param {string} type string defining the input type ("vec3","number",...)
     * @param {[x,y]} pos position of the connection inside the node
     * @param {string} direction if is input or output
     */
    LGraphNode.prototype.addConnection = function(name, type, pos, direction) {
        var o = {
            name: name,
            type: type,
            pos: pos,
            direction: direction,
            links: null
        };
        this.connections.push(o);
        return o;
    };

    /**
     * computes the minimum size of a node according to its inputs and output slots
     * @method computeSize
     * @param {number} minHeight
     * @return {number} the total size
     */
    LGraphNode.prototype.computeSize = function(out) {
        if (this.constructor.size) {
            return this.constructor.size.concat();
        }

        var rows = Math.max(
            this.inputs ? this.inputs.length : 1,
            this.outputs ? this.outputs.length : 1
        );
        var size = out || new Float32Array([0, 0]);
        rows = Math.max(rows, 1);
        var font_size = LiteGraph.NODE_TEXT_SIZE; //although it should be graphcanvas.inner_text_font size

        var font_size = font_size;
        var title_width = compute_text_size(this.title);
        var input_width = 0;
        var output_width = 0;

        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i < l; ++i) {
                var input = this.inputs[i];
                var text = input.label || input.name || "";
                var text_width = compute_text_size(text);
                if (input_width < text_width) {
                    input_width = text_width;
                }
            }
        }

        if (this.outputs) {
            for (var i = 0, l = this.outputs.length; i < l; ++i) {
                var output = this.outputs[i];
                var text = output.label || output.name || "";
                var text_width = compute_text_size(text);
                if (output_width < text_width) {
                    output_width = text_width;
                }
            }
        }

        size[0] = Math.max(input_width + output_width + 10, title_width);
        size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH);
        if (this.widgets && this.widgets.length) {
            size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH * 1.5);
        }

        size[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;

        var widgets_height = 0;
        if (this.widgets && this.widgets.length) {
            for (var i = 0, l = this.widgets.length; i < l; ++i) {
                if (this.widgets[i].computeSize)
                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;
                else
                    widgets_height += LiteGraph.NODE_WIDGET_HEIGHT + 4;
            }
            widgets_height += 8;
        }

        //compute height using widgets height
        if( this.widgets_up )
            size[1] = Math.max( size[1], widgets_height );
        else if( this.widgets_start_y != null )
            size[1] = Math.max( size[1], widgets_height + this.widgets_start_y );
        else
            size[1] += widgets_height;

        function compute_text_size(text) {
            if (!text) {
                return 0;
            }
            return font_size * text.length * 0.6;
        }

        if (
            this.constructor.min_height &&
            size[1] < this.constructor.min_height
        ) {
            size[1] = this.constructor.min_height;
        }

        size[1] += 6; //margin

        return size;
    };

    /**
     * returns all the info available about a property of this node.
     *
     * @method getPropertyInfo
     * @param {String} property name of the property
     * @return {Object} the object with all the available info
    */
    LGraphNode.prototype.getPropertyInfo = function( property )
	{
        var info = null;

		//there are several ways to define info about a property
		//legacy mode
		if (this.properties_info) {
            for (var i = 0; i < this.properties_info.length; ++i) {
                if (this.properties_info[i].name == property) {
                    info = this.properties_info[i];
                    break;
                }
            }
        }
		//litescene mode using the constructor
		if(this.constructor["@" + property])
			info = this.constructor["@" + property];

		if(this.constructor.widgets_info && this.constructor.widgets_info[property])
			info = this.constructor.widgets_info[property];

		//litescene mode using the constructor
		if (!info && this.onGetPropertyInfo) {
            info = this.onGetPropertyInfo(property);
        }

        if (!info)
            info = {};
		if(!info.type)
			info.type = typeof this.properties[property];
		if(info.widget == "combo")
			info.type = "enum";

		return info;
	}

    /**
     * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
     *
     * @method addWidget
     * @param {String} type the widget type (could be "number","string","combo"
     * @param {String} name the text to show on the widget
     * @param {String} value the default value
     * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)
     * @param {Object} options the object that contains special properties of this widget 
     * @return {Object} the created widget object
     */
    LGraphNode.prototype.addWidget = function( type, name, value, callback, options )
	{
        if (!this.widgets) {
            this.widgets = [];
        }

		if(!options && callback && callback.constructor === Object)
		{
			options = callback;
			callback = null;
		}

		if(options && options.constructor === String) //options can be the property name
			options = { property: options };

		if(callback && callback.constructor === String) //callback can be the property name
		{
			if(!options)
				options = {};
			options.property = callback;
			callback = null;
		}

		if(callback && callback.constructor !== Function)
		{
			console.warn("addWidget: callback must be a function");
			callback = null;
		}

        var w = {
            type: type.toLowerCase(),
            name: name,
            value: value,
            callback: callback,
            options: options || {}
        };

        if (w.options.y !== undefined) {
            w.y = w.options.y;
        }

        if (!callback && !w.options.callback && !w.options.property) {
            console.warn("LiteGraph addWidget(...) without a callback or property assigned");
        }
        if (type == "combo" && !w.options.values) {
            throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
        }
        this.widgets.push(w);
		this.setSize( this.computeSize() );
        return w;
    };

    LGraphNode.prototype.addCustomWidget = function(custom_widget) {
        if (!this.widgets) {
            this.widgets = [];
        }
        this.widgets.push(custom_widget);
        return custom_widget;
    };

    /**
     * returns the bounding of the object, used for rendering purposes
     * bounding is: [topleft_cornerx, topleft_cornery, width, height]
     * @method getBounding
     * @return {Float32Array[4]} the total size
     */
    LGraphNode.prototype.getBounding = function(out) {
        out = out || new Float32Array(4);
        out[0] = this.pos[0] - 4;
        out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
        out[2] = this.size[0] + 4;
        out[3] = this.flags.collapsed ? LiteGraph.NODE_TITLE_HEIGHT : this.size[1] + LiteGraph.NODE_TITLE_HEIGHT;

        if (this.onBounding) {
            this.onBounding(out);
        }
        return out;
    };

    /**
     * checks if a point is inside the shape of a node
     * @method isPointInside
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    LGraphNode.prototype.isPointInside = function(x, y, margin, skip_title) {
        margin = margin || 0;

        var margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;
        if (skip_title) {
            margin_top = 0;
        }
        if (this.flags && this.flags.collapsed) {
            //if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] + this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)
            if (
                isInsideRectangle(
                    x,
                    y,
                    this.pos[0] - margin,
                    this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,
                    (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) +
                        2 * margin,
                    LiteGraph.NODE_TITLE_HEIGHT + 2 * margin
                )
            ) {
                return true;
            }
        } else if (
            this.pos[0] - 4 - margin < x &&
            this.pos[0] + this.size[0] + 4 + margin > x &&
            this.pos[1] - margin_top - margin < y &&
            this.pos[1] + this.size[1] + margin > y
        ) {
            return true;
        }
        return false;
    };

    /**
     * checks if a point is inside a node slot, and returns info about which slot
     * @method getSlotInPosition
     * @param {number} x
     * @param {number} y
     * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
     */
    LGraphNode.prototype.getSlotInPosition = function(x, y) {
        //search for inputs
        var link_pos = new Float32Array(2);
        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i < l; ++i) {
                var input = this.inputs[i];
                this.getConnectionPos(true, i, link_pos);
                if (
                    isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10
                    )
                ) {
                    return { input: input, slot: i, link_pos: link_pos };
                }
            }
        }

        if (this.outputs) {
            for (var i = 0, l = this.outputs.length; i < l; ++i) {
                var output = this.outputs[i];
                this.getConnectionPos(false, i, link_pos);
                if (
                    isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10
                    )
                ) {
                    return { output: output, slot: i, link_pos: link_pos };
                }
            }
        }

        return null;
    };

    /**
     * returns the input slot with a given name (used for dynamic slots), -1 if not found
     * @method findInputSlot
     * @param {string} name the name of the slot
     * @return {number} the slot (-1 if not found)
     */
    LGraphNode.prototype.findInputSlot = function(name) {
        if (!this.inputs) {
            return -1;
        }
        for (var i = 0, l = this.inputs.length; i < l; ++i) {
            if (name == this.inputs[i].name) {
                return i;
            }
        }
        return -1;
    };

    /**
     * returns the output slot with a given name (used for dynamic slots), -1 if not found
     * @method findOutputSlot
     * @param {string} name the name of the slot
     * @return {number} the slot (-1 if not found)
     */
    LGraphNode.prototype.findOutputSlot = function(name) {
        if (!this.outputs) {
            return -1;
        }
        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            if (name == this.outputs[i].name) {
                return i;
            }
        }
        return -1;
    };

    /**
     * connect this node output to the input of another node
     * @method connect
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} node the target node
     * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
     * @return {Object} the link_info is created, otherwise null
     */
    LGraphNode.prototype.connect = function(slot, target_node, target_slot) {
        target_slot = target_slot || 0;

        if (!this.graph) {
            //could be connected before adding it to a graph
            console.log(
                "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."
            ); //due to link ids being associated with graphs
            return null;
        }

        //seek for the output slot
        if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                if (LiteGraph.debug) {
                    console.log("Connect: Error, no slot of name " + slot);
                }
                return null;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return null;
        }

        if (target_node && target_node.constructor === Number) {
            target_node = this.graph.getNodeById(target_node);
        }
        if (!target_node) {
            throw "target node is null";
        }

        //avoid loopback
        if (target_node == this) {
            return null;
        }

        //you can specify the slot by name
        if (target_slot.constructor === String) {
            target_slot = target_node.findInputSlot(target_slot);
            if (target_slot == -1) {
                if (LiteGraph.debug) {
                    console.log(
                        "Connect: Error, no slot of name " + target_slot
                    );
                }
                return null;
            }
        } else if (target_slot === LiteGraph.EVENT) {
            //search for first slot with event?
            /*
		//create input for trigger
		var input = target_node.addInput("onTrigger", LiteGraph.EVENT );
		target_slot = target_node.inputs.length - 1; //last one is the one created
		target_node.mode = LiteGraph.ON_TRIGGER;
		*/
            return null;
        } else if (
            !target_node.inputs ||
            target_slot >= target_node.inputs.length
        ) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return null;
        }

		var changed = false;

        //if there is something already plugged there, disconnect
        if (target_node.inputs[target_slot].link != null) {
			this.graph.beforeChange();
            target_node.disconnectInput(target_slot);
			changed = true;
        }

        //why here??
        //this.setDirtyCanvas(false,true);
        //this.graph.connectionChange( this );

        var output = this.outputs[slot];

        //allows nodes to block connection
        if (target_node.onConnectInput) {
            if ( target_node.onConnectInput(target_slot, output.type, output, this, slot) === false ) {
                return null;
            }
        }

        var input = target_node.inputs[target_slot];
        var link_info = null;

		//this slots cannot be connected (different types)
        if (!LiteGraph.isValidConnection(output.type, input.type))
		{
	        this.setDirtyCanvas(false, true);
			if(changed)
		        this.graph.connectionChange(this, link_info);
			return null;
		}

		if(!changed)
			this.graph.beforeChange();

		//create link class
		link_info = new LLink(
			++this.graph.last_link_id,
			input.type,
			this.id,
			slot,
			target_node.id,
			target_slot
		);

		//add to graph links list
		this.graph.links[link_info.id] = link_info;

		//connect in output
		if (output.links == null) {
			output.links = [];
		}
		output.links.push(link_info.id);
		//connect in input
		target_node.inputs[target_slot].link = link_info.id;
		if (this.graph) {
			this.graph._version++;
		}
		if (this.onConnectionsChange) {
			this.onConnectionsChange(
				LiteGraph.OUTPUT,
				slot,
				true,
				link_info,
				output
			);
		} //link_info has been created now, so its updated
		if (target_node.onConnectionsChange) {
			target_node.onConnectionsChange(
				LiteGraph.INPUT,
				target_slot,
				true,
				link_info,
				input
			);
		}
		if (this.graph && this.graph.onNodeConnectionChange) {
			this.graph.onNodeConnectionChange(
				LiteGraph.INPUT,
				target_node,
				target_slot,
				this,
				slot
			);
			this.graph.onNodeConnectionChange(
				LiteGraph.OUTPUT,
				this,
				slot,
				target_node,
				target_slot
			);
		}

        this.setDirtyCanvas(false, true);
		this.graph.afterChange();
		this.graph.connectionChange(this, link_info);

        return link_info;
    };

    /**
     * disconnect one output to an specific node
     * @method disconnectOutput
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]
     * @return {boolean} if it was disconnected successfully
     */
    LGraphNode.prototype.disconnectOutput = function(slot, target_node) {
        if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                if (LiteGraph.debug) {
                    console.log("Connect: Error, no slot of name " + slot);
                }
                return false;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return false;
        }

        //get output slot
        var output = this.outputs[slot];
        if (!output || !output.links || output.links.length == 0) {
            return false;
        }

        //one of the output links in this slot
        if (target_node) {
            if (target_node.constructor === Number) {
                target_node = this.graph.getNodeById(target_node);
            }
            if (!target_node) {
                throw "Target Node not found";
            }

            for (var i = 0, l = output.links.length; i < l; i++) {
                var link_id = output.links[i];
                var link_info = this.graph.links[link_id];

                //is the link we are searching for...
                if (link_info.target_id == target_node.id) {
                    output.links.splice(i, 1); //remove here
                    var input = target_node.inputs[link_info.target_slot];
                    input.link = null; //remove there
                    delete this.graph.links[link_id]; //remove the link from the links pool
                    if (this.graph) {
                        this.graph._version++;
                    }
                    if (target_node.onConnectionsChange) {
                        target_node.onConnectionsChange(
                            LiteGraph.INPUT,
                            link_info.target_slot,
                            false,
                            link_info,
                            input
                        );
                    } //link_info hasn't been modified so its ok
                    if (this.onConnectionsChange) {
                        this.onConnectionsChange(
                            LiteGraph.OUTPUT,
                            slot,
                            false,
                            link_info,
                            output
                        );
                    }
                    if (this.graph && this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            LiteGraph.OUTPUT,
                            this,
                            slot
                        );
                    }
                    if (this.graph && this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            LiteGraph.OUTPUT,
                            this,
                            slot
                        );
                        this.graph.onNodeConnectionChange(
                            LiteGraph.INPUT,
                            target_node,
                            link_info.target_slot
                        );
                    }
                    break;
                }
            }
        } //all the links in this output slot
        else {
            for (var i = 0, l = output.links.length; i < l; i++) {
                var link_id = output.links[i];
                var link_info = this.graph.links[link_id];
                if (!link_info) {
                    //bug: it happens sometimes
                    continue;
                }

                var target_node = this.graph.getNodeById(link_info.target_id);
                var input = null;
                if (this.graph) {
                    this.graph._version++;
                }
                if (target_node) {
                    input = target_node.inputs[link_info.target_slot];
                    input.link = null; //remove other side link
                    if (target_node.onConnectionsChange) {
                        target_node.onConnectionsChange(
                            LiteGraph.INPUT,
                            link_info.target_slot,
                            false,
                            link_info,
                            input
                        );
                    } //link_info hasn't been modified so its ok
                    if (this.graph && this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            LiteGraph.INPUT,
                            target_node,
                            link_info.target_slot
                        );
                    }
                }
                delete this.graph.links[link_id]; //remove the link from the links pool
                if (this.onConnectionsChange) {
                    this.onConnectionsChange(
                        LiteGraph.OUTPUT,
                        slot,
                        false,
                        link_info,
                        output
                    );
                }
                if (this.graph && this.graph.onNodeConnectionChange) {
                    this.graph.onNodeConnectionChange(
                        LiteGraph.OUTPUT,
                        this,
                        slot
                    );
                    this.graph.onNodeConnectionChange(
                        LiteGraph.INPUT,
                        target_node,
                        link_info.target_slot
                    );
                }
            }
            output.links = null;
        }

        this.setDirtyCanvas(false, true);
        this.graph.connectionChange(this);
        return true;
    };

    /**
     * disconnect one input
     * @method disconnectInput
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @return {boolean} if it was disconnected successfully
     */
    LGraphNode.prototype.disconnectInput = function(slot) {
        //seek for the output slot
        if (slot.constructor === String) {
            slot = this.findInputSlot(slot);
            if (slot == -1) {
                if (LiteGraph.debug) {
                    console.log("Connect: Error, no slot of name " + slot);
                }
                return false;
            }
        } else if (!this.inputs || slot >= this.inputs.length) {
            if (LiteGraph.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return false;
        }

        var input = this.inputs[slot];
        if (!input) {
            return false;
        }

        var link_id = this.inputs[slot].link;
		if(link_id != null)
		{
			this.inputs[slot].link = null;

			//remove other side
			var link_info = this.graph.links[link_id];
			if (link_info) {
				var target_node = this.graph.getNodeById(link_info.origin_id);
				if (!target_node) {
					return false;
				}

				var output = target_node.outputs[link_info.origin_slot];
				if (!output || !output.links || output.links.length == 0) {
					return false;
				}

				//search in the inputs list for this link
				for (var i = 0, l = output.links.length; i < l; i++) {
					if (output.links[i] == link_id) {
						output.links.splice(i, 1);
						break;
					}
				}

				delete this.graph.links[link_id]; //remove from the pool
				if (this.graph) {
					this.graph._version++;
				}
				if (this.onConnectionsChange) {
					this.onConnectionsChange(
						LiteGraph.INPUT,
						slot,
						false,
						link_info,
						input
					);
				}
				if (target_node.onConnectionsChange) {
					target_node.onConnectionsChange(
						LiteGraph.OUTPUT,
						i,
						false,
						link_info,
						output
					);
				}
				if (this.graph && this.graph.onNodeConnectionChange) {
					this.graph.onNodeConnectionChange(
						LiteGraph.OUTPUT,
						target_node,
						i
					);
					this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, slot);
				}
			}
		} //link != null

        this.setDirtyCanvas(false, true);
		if(this.graph)
	        this.graph.connectionChange(this);
        return true;
    };

    /**
     * returns the center of a connection point in canvas coords
     * @method getConnectionPos
     * @param {boolean} is_input true if if a input slot, false if it is an output
     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
     * @param {vec2} out [optional] a place to store the output, to free garbage
     * @return {[x,y]} the position
     **/
    LGraphNode.prototype.getConnectionPos = function(
        is_input,
        slot_number,
        out
    ) {
        out = out || new Float32Array(2);
        var num_slots = 0;
        if (is_input && this.inputs) {
            num_slots = this.inputs.length;
        }
        if (!is_input && this.outputs) {
            num_slots = this.outputs.length;
        }

        var offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;

        if (this.flags.collapsed) {
            var w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
            if (this.horizontal) {
                out[0] = this.pos[0] + w * 0.5;
                if (is_input) {
                    out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
                } else {
                    out[1] = this.pos[1];
                }
            } else {
                if (is_input) {
                    out[0] = this.pos[0];
                } else {
                    out[0] = this.pos[0] + w;
                }
                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            }
            return out;
        }

        //weird feature that never got finished
        if (is_input && slot_number == -1) {
            out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
            return out;
        }

        //hard-coded pos
        if (
            is_input &&
            num_slots > slot_number &&
            this.inputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
            return out;
        } else if (
            !is_input &&
            num_slots > slot_number &&
            this.outputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
            return out;
        }

        //horizontal distributed slots
        if (this.horizontal) {
            out[0] =
                this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
            if (is_input) {
                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
            } else {
                out[1] = this.pos[1] + this.size[1];
            }
            return out;
        }

        //default vertical slots
        if (is_input) {
            out[0] = this.pos[0] + offset;
        } else {
            out[0] = this.pos[0] + this.size[0] + 1 - offset;
        }
        out[1] =
            this.pos[1] +
            (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +
            (this.constructor.slot_start_y || 0);
        return out;
    };

    /* Force align to grid */
    LGraphNode.prototype.alignToGrid = function() {
        this.pos[0] =
            LiteGraph.CANVAS_GRID_SIZE *
            Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);
        this.pos[1] =
            LiteGraph.CANVAS_GRID_SIZE *
            Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
    };

    /* Console output */
    LGraphNode.prototype.trace = function(msg) {
        if (!this.console) {
            this.console = [];
        }

        this.console.push(msg);
        if (this.console.length > LGraphNode.MAX_CONSOLE) {
            this.console.shift();
        }

		if(this.graph.onNodeTrace)
	        this.graph.onNodeTrace(this, msg);
    };

    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
    LGraphNode.prototype.setDirtyCanvas = function(
        dirty_foreground,
        dirty_background
    ) {
        if (!this.graph) {
            return;
        }
        this.graph.sendActionToCanvas("setDirty", [
            dirty_foreground,
            dirty_background
        ]);
    };

    LGraphNode.prototype.loadImage = function(url) {
        var img = new Image();
        img.src = LiteGraph.node_images_path + url;
        img.ready = false;

        var that = this;
        img.onload = function() {
            this.ready = true;
            that.setDirtyCanvas(true);
        };
        return img;
    };

    //safe LGraphNode action execution (not sure if safe)
    /*
LGraphNode.prototype.executeAction = function(action)
{
	if(action == "") return false;

	if( action.indexOf(";") != -1 || action.indexOf("}") != -1)
	{
		this.trace("Error: Action contains unsafe characters");
		return false;
	}

	var tokens = action.split("(");
	var func_name = tokens[0];
	if( typeof(this[func_name]) != "function")
	{
		this.trace("Error: Action not found on node: " + func_name);
		return false;
	}

	var code = action;

	try
	{
		var _foo = eval;
		eval = null;
		(new Function("with(this) { " + code + "}")).call(this);
		eval = _foo;
	}
	catch (err)
	{
		this.trace("Error executing action {" + action + "} :" + err);
		return false;
	}

	return true;
}
*/

    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
    LGraphNode.prototype.captureInput = function(v) {
        if (!this.graph || !this.graph.list_of_graphcanvas) {
            return;
        }

        var list = this.graph.list_of_graphcanvas;

        for (var i = 0; i < list.length; ++i) {
            var c = list[i];
            //releasing somebody elses capture?!
            if (!v && c.node_capturing_input != this) {
                continue;
            }

            //change
            c.node_capturing_input = v ? this : null;
        }
    };

    /**
     * Collapse the node to make it smaller on the canvas
     * @method collapse
     **/
    LGraphNode.prototype.collapse = function(force) {
        this.graph._version++;
        if (this.constructor.collapsable === false && !force) {
            return;
        }
        if (!this.flags.collapsed) {
            this.flags.collapsed = true;
        } else {
            this.flags.collapsed = false;
        }
        this.setDirtyCanvas(true, true);
    };

    /**
     * Forces the node to do not move or realign on Z
     * @method pin
     **/

    LGraphNode.prototype.pin = function(v) {
        this.graph._version++;
        if (v === undefined) {
            this.flags.pinned = !this.flags.pinned;
        } else {
            this.flags.pinned = v;
        }
    };

    LGraphNode.prototype.localToScreen = function(x, y, graphcanvas) {
        return [
            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],
            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]
        ];
    };

    function LGraphGroup(title) {
        this._ctor(title);
    }

    global.LGraphGroup = LiteGraph.LGraphGroup = LGraphGroup;

    LGraphGroup.prototype._ctor = function(title) {
        this.title = title || "Group";
        this.font_size = 24;
        this.color = LGraphCanvas.node_colors.pale_blue
            ? LGraphCanvas.node_colors.pale_blue.groupcolor
            : "#AAA";
        this._bounding = new Float32Array([10, 10, 140, 80]);
        this._pos = this._bounding.subarray(0, 2);
        this._size = this._bounding.subarray(2, 4);
        this._nodes = [];
        this.graph = null;

        Object.defineProperty(this, "pos", {
            set: function(v) {
                if (!v || v.length < 2) {
                    return;
                }
                this._pos[0] = v[0];
                this._pos[1] = v[1];
            },
            get: function() {
                return this._pos;
            },
            enumerable: true
        });

        Object.defineProperty(this, "size", {
            set: function(v) {
                if (!v || v.length < 2) {
                    return;
                }
                this._size[0] = Math.max(140, v[0]);
                this._size[1] = Math.max(80, v[1]);
            },
            get: function() {
                return this._size;
            },
            enumerable: true
        });
    };

    LGraphGroup.prototype.configure = function(o) {
        this.title = o.title;
        this._bounding.set(o.bounding);
        this.color = o.color;
        this.font = o.font;
    };

    LGraphGroup.prototype.serialize = function() {
        var b = this._bounding;
        return {
            title: this.title,
            bounding: [
                Math.round(b[0]),
                Math.round(b[1]),
                Math.round(b[2]),
                Math.round(b[3])
            ],
            color: this.color,
            font: this.font
        };
    };

    LGraphGroup.prototype.move = function(deltax, deltay, ignore_nodes) {
        this._pos[0] += deltax;
        this._pos[1] += deltay;
        if (ignore_nodes) {
            return;
        }
        for (var i = 0; i < this._nodes.length; ++i) {
            var node = this._nodes[i];
            node.pos[0] += deltax;
            node.pos[1] += deltay;
        }
    };

    LGraphGroup.prototype.recomputeInsideNodes = function() {
        this._nodes.length = 0;
        var nodes = this.graph._nodes;
        var node_bounding = new Float32Array(4);

        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            node.getBounding(node_bounding);
            if (!overlapBounding(this._bounding, node_bounding)) {
                continue;
            } //out of the visible area
            this._nodes.push(node);
        }
    };

    LGraphGroup.prototype.isPointInside = LGraphNode.prototype.isPointInside;
    LGraphGroup.prototype.setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas;

    //****************************************

    //Scale and Offset
    function DragAndScale(element, skip_events) {
        this.offset = new Float32Array([0, 0]);
        this.scale = 1;
        this.max_scale = 10;
        this.min_scale = 0.1;
        this.onredraw = null;
        this.enabled = true;
        this.last_mouse = [0, 0];
        this.element = null;
        this.visible_area = new Float32Array(4);

        if (element) {
            this.element = element;
            if (!skip_events) {
                this.bindEvents(element);
            }
        }
    }

    LiteGraph.DragAndScale = DragAndScale;

    DragAndScale.prototype.bindEvents = function(element) {
        this.last_mouse = new Float32Array(2);

        this._binded_mouse_callback = this.onMouse.bind(this);

        element.addEventListener("mousedown", this._binded_mouse_callback);
        element.addEventListener("mousemove", this._binded_mouse_callback);

        element.addEventListener(
            "mousewheel",
            this._binded_mouse_callback,
            false
        );
        element.addEventListener("wheel", this._binded_mouse_callback, false);
    };

    DragAndScale.prototype.computeVisibleArea = function( viewport ) {
        if (!this.element) {
            this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
            return;
        }
        var width = this.element.width;
        var height = this.element.height;
        var startx = -this.offset[0];
        var starty = -this.offset[1];
		if( viewport )
		{
			startx += viewport[0] / this.scale;
			starty += viewport[1] / this.scale;
			width = viewport[2];
			height = viewport[3];
		}
        var endx = startx + width / this.scale;
        var endy = starty + height / this.scale;
        this.visible_area[0] = startx;
        this.visible_area[1] = starty;
        this.visible_area[2] = endx - startx;
        this.visible_area[3] = endy - starty;
    };

    DragAndScale.prototype.onMouse = function(e) {
        if (!this.enabled) {
            return;
        }

        var canvas = this.element;
        var rect = canvas.getBoundingClientRect();
        var x = e.clientX - rect.left;
        var y = e.clientY - rect.top;
        e.canvasx = x;
        e.canvasy = y;
        e.dragging = this.dragging;

		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );

        var ignore = false;
        if (this.onmouse) {
            ignore = this.onmouse(e);
        }

        if (e.type == "mousedown" && is_inside) {
            this.dragging = true;
            canvas.removeEventListener( "mousemove", this._binded_mouse_callback );
            document.body.addEventListener( "mousemove", this._binded_mouse_callback );
            document.body.addEventListener( "mouseup", this._binded_mouse_callback );
        } else if (e.type == "mousemove") {
            if (!ignore) {
                var deltax = x - this.last_mouse[0];
                var deltay = y - this.last_mouse[1];
                if (this.dragging) {
                    this.mouseDrag(deltax, deltay);
                }
            }
        } else if (e.type == "mouseup") {
            this.dragging = false;
            document.body.removeEventListener( "mousemove", this._binded_mouse_callback );
            document.body.removeEventListener( "mouseup", this._binded_mouse_callback );
            canvas.addEventListener("mousemove", this._binded_mouse_callback );
        } else if ( is_inside &&
            (e.type == "mousewheel" ||
            e.type == "wheel" ||
            e.type == "DOMMouseScroll")
        ) {
            e.eventType = "mousewheel";
            if (e.type == "wheel") {
                e.wheel = -e.deltaY;
            } else {
                e.wheel =
                    e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
            }

            //from stack overflow
            e.delta = e.wheelDelta
                ? e.wheelDelta / 40
                : e.deltaY
                ? -e.deltaY / 3
                : 0;
            this.changeDeltaScale(1.0 + e.delta * 0.05);
        }

        this.last_mouse[0] = x;
        this.last_mouse[1] = y;

		if(is_inside)
		{
	        e.preventDefault();
		    e.stopPropagation();
		    return false;
		}
    };

    DragAndScale.prototype.toCanvasContext = function(ctx) {
        ctx.scale(this.scale, this.scale);
        ctx.translate(this.offset[0], this.offset[1]);
    };

    DragAndScale.prototype.convertOffsetToCanvas = function(pos) {
        //return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];
        return [
            (pos[0] + this.offset[0]) * this.scale,
            (pos[1] + this.offset[1]) * this.scale
        ];
    };

    DragAndScale.prototype.convertCanvasToOffset = function(pos, out) {
        out = out || [0, 0];
        out[0] = pos[0] / this.scale - this.offset[0];
        out[1] = pos[1] / this.scale - this.offset[1];
        return out;
    };

    DragAndScale.prototype.mouseDrag = function(x, y) {
        this.offset[0] += x / this.scale;
        this.offset[1] += y / this.scale;

        if (this.onredraw) {
            this.onredraw(this);
        }
    };

    DragAndScale.prototype.changeScale = function(value, zooming_center) {
        if (value < this.min_scale) {
            value = this.min_scale;
        } else if (value > this.max_scale) {
            value = this.max_scale;
        }

        if (value == this.scale) {
            return;
        }

        if (!this.element) {
            return;
        }

        var rect = this.element.getBoundingClientRect();
        if (!rect) {
            return;
        }

        zooming_center = zooming_center || [
            rect.width * 0.5,
            rect.height * 0.5
        ];
        var center = this.convertCanvasToOffset(zooming_center);
        this.scale = value;
        if (Math.abs(this.scale - 1) < 0.01) {
            this.scale = 1;
        }

        var new_center = this.convertCanvasToOffset(zooming_center);
        var delta_offset = [
            new_center[0] - center[0],
            new_center[1] - center[1]
        ];

        this.offset[0] += delta_offset[0];
        this.offset[1] += delta_offset[1];

        if (this.onredraw) {
            this.onredraw(this);
        }
    };

    DragAndScale.prototype.changeDeltaScale = function(value, zooming_center) {
        this.changeScale(this.scale * value, zooming_center);
    };

    DragAndScale.prototype.reset = function() {
        this.scale = 1;
        this.offset[0] = 0;
        this.offset[1] = 0;
    };

    //*********************************************************************************
    // LGraphCanvas: LGraph renderer CLASS
    //*********************************************************************************

    /**
     * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.
     * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked
     *
     * @class LGraphCanvas
     * @constructor
     * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in string format or the canvas element itself)
     * @param {LGraph} graph [optional]
     * @param {Object} options [optional] { skip_rendering, autoresize, viewport }
     */
    function LGraphCanvas(canvas, graph, options) {
        this.options = options = options || {};

        //if(graph === undefined)
        //	throw ("No graph assigned");
        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;

        if (canvas && canvas.constructor === String) {
            canvas = document.querySelector(canvas);
        }

        this.ds = new DragAndScale();
        this.zoom_modify_alpha = true; //otherwise it generates ugly patterns when scaling down too much

        this.title_text_font = "" + LiteGraph.NODE_TEXT_SIZE + "px Arial";
        this.inner_text_font =
            "normal " + LiteGraph.NODE_SUBTEXT_SIZE + "px Arial";
        this.node_title_color = LiteGraph.NODE_TITLE_COLOR;
        this.default_link_color = LiteGraph.LINK_COLOR;
        this.default_connection_color = {
            input_off: "#778",
            input_on: "#7F7",
            output_off: "#778",
            output_on: "#7F7"
        };

        this.highquality_render = true;
        this.use_gradients = false; //set to true to render titlebar with gradients
        this.editor_alpha = 1; //used for transition
        this.pause_rendering = false;
        this.clear_background = true;

		this.read_only = false; //if set to true users cannot modify the graph
        this.render_only_selected = true;
        this.live_mode = false;
        this.show_info = true;
        this.allow_dragcanvas = true;
        this.allow_dragnodes = true;
        this.allow_interaction = true; //allow to control widgets, buttons, collapse, etc
        this.allow_searchbox = true;
        this.allow_reconnect_links = false; //allows to change a connection with having to redo it again
		this.align_to_grid = false; //snap to grid

        this.drag_mode = false;
        this.dragging_rectangle = null;

        this.filter = null; //allows to filter to only accept some type of nodes in a graph

		this.set_canvas_dirty_on_mouse_event = true; //forces to redraw the canvas if the mouse does anything
        this.always_render_background = false;
        this.render_shadows = true;
        this.render_canvas_border = true;
        this.render_connections_shadows = false; //too much cpu
        this.render_connections_border = true;
        this.render_curved_connections = false;
        this.render_connection_arrows = false;
        this.render_collapsed_slots = true;
        this.render_execution_order = false;
        this.render_title_colored = true;
		this.render_link_tooltip = true;

        this.links_render_mode = LiteGraph.SPLINE_LINK;

        this.mouse = [0, 0]; //mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle
        this.graph_mouse = [0, 0]; //mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle
		this.canvas_mouse = this.graph_mouse; //LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD

        //to personalize the search box
        this.onSearchBox = null;
        this.onSearchBoxSelection = null;

        //callbacks
        this.onMouse = null;
        this.onDrawBackground = null; //to render background objects (behind nodes and connections) in the canvas affected by transform
        this.onDrawForeground = null; //to render foreground objects (above nodes and connections) in the canvas affected by transform
        this.onDrawOverlay = null; //to render foreground objects not affected by transform (for GUIs)
		this.onDrawLinkTooltip = null; //called when rendering a tooltip
		this.onNodeMoved = null; //called after moving a node
		this.onSelectionChange = null; //called if the selection changes
		this.onConnectingChange = null; //called before any link changes
		this.onBeforeChange = null; //called before modifying the graph
		this.onAfterChange = null; //called after modifying the graph

        this.connections_width = 3;
        this.round_radius = 8;

        this.current_node = null;
        this.node_widget = null; //used for widgets
		this.over_link_center = null;
        this.last_mouse_position = [0, 0];
        this.visible_area = this.ds.visible_area;
        this.visible_links = [];

		this.viewport = options.viewport || null; //to constraint render area to a portion of the canvas

        //link canvas and graph
        if (graph) {
            graph.attachCanvas(this);
        }

        this.setCanvas(canvas,options.skip_events);
        this.clear();

        if (!options.skip_render) {
            this.startRendering();
        }

        this.autoresize = options.autoresize;
    }

    global.LGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas;

	LGraphCanvas.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";

    LGraphCanvas.link_type_colors = {
        "-1": LiteGraph.EVENT_LINK_COLOR,
        number: "#AAA",
        node: "#DCA"
    };
    LGraphCanvas.gradients = {}; //cache of gradients

    /**
     * clears all the data inside
     *
     * @method clear
     */
    LGraphCanvas.prototype.clear = function() {
        this.frame = 0;
        this.last_draw_time = 0;
        this.render_time = 0;
        this.fps = 0;

        //this.scale = 1;
        //this.offset = [0,0];

        this.dragging_rectangle = null;

        this.selected_nodes = {};
        this.selected_group = null;

        this.visible_nodes = [];
        this.node_dragged = null;
        this.node_over = null;
        this.node_capturing_input = null;
        this.connecting_node = null;
        this.highlighted_links = {};

		this.dragging_canvas = false;

        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
        this.dirty_area = null;

        this.node_in_panel = null;
        this.node_widget = null;

        this.last_mouse = [0, 0];
        this.last_mouseclick = 0;
        this.visible_area.set([0, 0, 0, 0]);

        if (this.onClear) {
            this.onClear();
        }
    };

    /**
     * assigns a graph, you can reassign graphs to the same canvas
     *
     * @method setGraph
     * @param {LGraph} graph
     */
    LGraphCanvas.prototype.setGraph = function(graph, skip_clear) {
        if (this.graph == graph) {
            return;
        }

        if (!skip_clear) {
            this.clear();
        }

        if (!graph && this.graph) {
            this.graph.detachCanvas(this);
            return;
        }

        graph.attachCanvas(this);

		//remove the graph stack in case a subgraph was open
		if (this._graph_stack)
			this._graph_stack = null;

        this.setDirty(true, true);
    };

    /**
     * returns the top level graph (in case there are subgraphs open on the canvas)
     *
     * @method getTopGraph
     * @return {LGraph} graph
     */
	LGraphCanvas.prototype.getTopGraph = function()
	{
		if(this._graph_stack.length)
			return this._graph_stack[0];
		return this.graph;
	}

    /**
     * opens a graph contained inside a node in the current graph
     *
     * @method openSubgraph
     * @param {LGraph} graph
     */
    LGraphCanvas.prototype.openSubgraph = function(graph) {
        if (!graph) {
            throw "graph cannot be null";
        }

        if (this.graph == graph) {
            throw "graph cannot be the same";
        }

        this.clear();

        if (this.graph) {
            if (!this._graph_stack) {
                this._graph_stack = [];
            }
            this._graph_stack.push(this.graph);
        }

        graph.attachCanvas(this);
		this.checkPanels();
        this.setDirty(true, true);
    };

    /**
     * closes a subgraph contained inside a node
     *
     * @method closeSubgraph
     * @param {LGraph} assigns a graph
     */
    LGraphCanvas.prototype.closeSubgraph = function() {
        if (!this._graph_stack || this._graph_stack.length == 0) {
            return;
        }
        var subgraph_node = this.graph._subgraph_node;
        var graph = this._graph_stack.pop();
        this.selected_nodes = {};
        this.highlighted_links = {};
        graph.attachCanvas(this);
        this.setDirty(true, true);
        if (subgraph_node) {
            this.centerOnNode(subgraph_node);
            this.selectNodes([subgraph_node]);
        }
    };

    /**
     * returns the visualy active graph (in case there are more in the stack)
     * @method getCurrentGraph
     * @return {LGraph} the active graph
     */
    LGraphCanvas.prototype.getCurrentGraph = function() {
        return this.graph;
    };

    /**
     * assigns a canvas
     *
     * @method setCanvas
     * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)
     */
    LGraphCanvas.prototype.setCanvas = function(canvas, skip_events) {
        var that = this;

        if (canvas) {
            if (canvas.constructor === String) {
                canvas = document.getElementById(canvas);
                if (!canvas) {
                    throw "Error creating LiteGraph canvas: Canvas not found";
                }
            }
        }

        if (canvas === this.canvas) {
            return;
        }

        if (!canvas && this.canvas) {
            //maybe detach events from old_canvas
            if (!skip_events) {
                this.unbindEvents();
            }
        }

        this.canvas = canvas;
        this.ds.element = canvas;

        if (!canvas) {
            return;
        }

        //this.canvas.tabindex = "1000";
        canvas.className += " lgraphcanvas";
        canvas.data = this;
        canvas.tabindex = "1"; //to allow key events

        //bg canvas: used for non changing stuff
        this.bgcanvas = null;
        if (!this.bgcanvas) {
            this.bgcanvas = document.createElement("canvas");
            this.bgcanvas.width = this.canvas.width;
            this.bgcanvas.height = this.canvas.height;
        }

        if (canvas.getContext == null) {
            if (canvas.localName != "canvas") {
                throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " +
                    canvas.localName;
            }
            throw "This browser doesn't support Canvas";
        }

        var ctx = (this.ctx = canvas.getContext("2d"));
        if (ctx == null) {
            if (!canvas.webgl_enabled) {
                console.warn(
                    "This canvas seems to be WebGL, enabling WebGL renderer"
                );
            }
            this.enableWebGL();
        }

        //input:  (move and up could be unbinded)
        this._mousemove_callback = this.processMouseMove.bind(this);
        this._mouseup_callback = this.processMouseUp.bind(this);

        if (!skip_events) {
            this.bindEvents();
        }
    };

    //used in some events to capture them
    LGraphCanvas.prototype._doNothing = function doNothing(e) {
        e.preventDefault();
        return false;
    };
    LGraphCanvas.prototype._doReturnTrue = function doNothing(e) {
        e.preventDefault();
        return true;
    };

    /**
     * binds mouse, keyboard, touch and drag events to the canvas
     * @method bindEvents
     **/
    LGraphCanvas.prototype.bindEvents = function() {
        if (this._events_binded) {
            console.warn("LGraphCanvas: events already binded");
            return;
        }

        var canvas = this.canvas;

        var ref_window = this.getCanvasWindow();
        var document = ref_window.document; //hack used when moving canvas between windows

        this._mousedown_callback = this.processMouseDown.bind(this);
        this._mousewheel_callback = this.processMouseWheel.bind(this);
        this._touch_callback = this.touchHandler.bind(this);

        canvas.addEventListener("mousedown", this._mousedown_callback, true); //down do not need to store the binded
        canvas.addEventListener("mousemove", this._mousemove_callback);
        canvas.addEventListener("mousewheel", this._mousewheel_callback, false);

        canvas.addEventListener("contextmenu", this._doNothing);
        canvas.addEventListener(
            "DOMMouseScroll",
            this._mousewheel_callback,
            false
        );

        //touch events
        //if( 'touchstart' in document.documentElement )
        {
            canvas.addEventListener("touchstart", this._touch_callback, true);
            canvas.addEventListener("touchmove", this._touch_callback, true);
            canvas.addEventListener("touchend", this._touch_callback, true);
            canvas.addEventListener("touchcancel", this._touch_callback, true);
        }

        //Keyboard ******************
        this._key_callback = this.processKey.bind(this);

        canvas.addEventListener("keydown", this._key_callback, true);
        document.addEventListener("keyup", this._key_callback, true); //in document, otherwise it doesn't fire keyup

        //Dropping Stuff over nodes ************************************
        this._ondrop_callback = this.processDrop.bind(this);

        canvas.addEventListener("dragover", this._doNothing, false);
        canvas.addEventListener("dragend", this._doNothing, false);
        canvas.addEventListener("drop", this._ondrop_callback, false);
        canvas.addEventListener("dragenter", this._doReturnTrue, false);

        this._events_binded = true;
    };

    /**
     * unbinds mouse events from the canvas
     * @method unbindEvents
     **/
    LGraphCanvas.prototype.unbindEvents = function() {
        if (!this._events_binded) {
            console.warn("LGraphCanvas: no events binded");
            return;
        }

        var ref_window = this.getCanvasWindow();
        var document = ref_window.document;

        this.canvas.removeEventListener("mousedown", this._mousedown_callback);
        this.canvas.removeEventListener(
            "mousewheel",
            this._mousewheel_callback
        );
        this.canvas.removeEventListener(
            "DOMMouseScroll",
            this._mousewheel_callback
        );
        this.canvas.removeEventListener("keydown", this._key_callback);
        document.removeEventListener("keyup", this._key_callback);
        this.canvas.removeEventListener("contextmenu", this._doNothing);
        this.canvas.removeEventListener("drop", this._ondrop_callback);
        this.canvas.removeEventListener("dragenter", this._doReturnTrue);

        this.canvas.removeEventListener("touchstart", this._touch_callback );
        this.canvas.removeEventListener("touchmove", this._touch_callback );
        this.canvas.removeEventListener("touchend", this._touch_callback );
        this.canvas.removeEventListener("touchcancel", this._touch_callback );

        this._mousedown_callback = null;
        this._mousewheel_callback = null;
        this._key_callback = null;
        this._ondrop_callback = null;

        this._events_binded = false;
    };

    LGraphCanvas.getFileExtension = function(url) {
        var question = url.indexOf("?");
        if (question != -1) {
            url = url.substr(0, question);
        }
        var point = url.lastIndexOf(".");
        if (point == -1) {
            return "";
        }
        return url.substr(point + 1).toLowerCase();
    };

    /**
     * this function allows to render the canvas using WebGL instead of Canvas2D
     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL
     * @method enableWebGL
     **/
    LGraphCanvas.prototype.enableWebGL = function() {
        if (typeof GL === undefined) {
            throw "litegl.js must be included to use a WebGL canvas";
        }
        if (typeof enableWebGLCanvas === undefined) {
            throw "webglCanvas.js must be included to use this feature";
        }

        this.gl = this.ctx = enableWebGLCanvas(this.canvas);
        this.ctx.webgl = true;
        this.bgcanvas = this.canvas;
        this.bgctx = this.gl;
        this.canvas.webgl_enabled = true;

        /*
	GL.create({ canvas: this.bgcanvas });
	this.bgctx = enableWebGLCanvas( this.bgcanvas );
	window.gl = this.gl;
	*/
    };

    /**
     * marks as dirty the canvas, this way it will be rendered again
     *
     * @class LGraphCanvas
     * @method setDirty
     * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)
     * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)
     */
    LGraphCanvas.prototype.setDirty = function(fgcanvas, bgcanvas) {
        if (fgcanvas) {
            this.dirty_canvas = true;
        }
        if (bgcanvas) {
            this.dirty_bgcanvas = true;
        }
    };

    /**
     * Used to attach the canvas in a popup
     *
     * @method getCanvasWindow
     * @return {window} returns the window where the canvas is attached (the DOM root node)
     */
    LGraphCanvas.prototype.getCanvasWindow = function() {
        if (!this.canvas) {
            return window;
        }
        var doc = this.canvas.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    };

    /**
     * starts rendering the content of the canvas when needed
     *
     * @method startRendering
     */
    LGraphCanvas.prototype.startRendering = function() {
        if (this.is_rendering) {
            return;
        } //already rendering

        this.is_rendering = true;
        renderFrame.call(this);

        function renderFrame() {
            if (!this.pause_rendering) {
                this.draw();
            }

            var window = this.getCanvasWindow();
            if (this.is_rendering) {
                window.requestAnimationFrame(renderFrame.bind(this));
            }
        }
    };

    /**
     * stops rendering the content of the canvas (to save resources)
     *
     * @method stopRendering
     */
    LGraphCanvas.prototype.stopRendering = function() {
        this.is_rendering = false;
        /*
	if(this.rendering_timer_id)
	{
		clearInterval(this.rendering_timer_id);
		this.rendering_timer_id = null;
	}
	*/
    };

    /* LiteGraphCanvas input */

	//used to block future mouse events (because of im gui)
	LGraphCanvas.prototype.blockClick = function()
	{
		this.block_click = true;
		this.last_mouseclick = 0;
	}

    LGraphCanvas.prototype.processMouseDown = function(e) {

		if( this.set_canvas_dirty_on_mouse_event )
			this.dirty_canvas = true;
		
		if (!this.graph) {
            return;
        }

        this.adjustMouseEvent(e);

        var ref_window = this.getCanvasWindow();
        var document = ref_window.document;
        LGraphCanvas.active_canvas = this;
        var that = this;

		var x = e.localX;
		var y = e.localY;
		//console.log(y,this.viewport);

		this.ds.viewport = this.viewport;
		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );

        //move mouse move event to the window in case it drags outside of the canvas
		if(!this.options.skip_events)
		{
			this.canvas.removeEventListener("mousemove", this._mousemove_callback);
			ref_window.document.addEventListener( "mousemove", this._mousemove_callback, true ); //catch for the entire window
			ref_window.document.addEventListener( "mouseup", this._mouseup_callback, true );
		}

		if(!is_inside)
			return;

        var node = this.graph.getNodeOnPos( e.canvasX, e.canvasY, this.visible_nodes, 5 );
        var skip_dragging = false;
        var skip_action = false;
        var now = LiteGraph.getTime();
        var is_double_click = now - this.last_mouseclick < 300;
		this.mouse[0] = e.localX;
		this.mouse[1] = e.localY;
        this.graph_mouse[0] = e.canvasX;
        this.graph_mouse[1] = e.canvasY;
		this.last_click_position = [this.mouse[0],this.mouse[1]];

        this.canvas.focus();

        LiteGraph.closeAllContextMenus(ref_window);

        if (this.onMouse)
		{
            if (this.onMouse(e) == true)
                return;
        }

		//left button mouse
        if (e.which == 1)
		{
            if (e.ctrlKey)
			{
                this.dragging_rectangle = new Float32Array(4);
                this.dragging_rectangle[0] = e.canvasX;
                this.dragging_rectangle[1] = e.canvasY;
                this.dragging_rectangle[2] = 1;
                this.dragging_rectangle[3] = 1;
                skip_action = true;
            }

            var clicking_canvas_bg = false;

            //when clicked on top of a node
            //and it is not interactive
            if (node && this.allow_interaction && !skip_action && !this.read_only) {
                if (!this.live_mode && !node.flags.pinned) {
                    this.bringToFront(node);
                } //if it wasn't selected?

                //not dragging mouse to connect two slots
                if ( !this.connecting_node && !node.flags.collapsed && !this.live_mode ) {
                    //Search for corner for resize
                    if (
                        !skip_action &&
                        node.resizable !== false &&
                        isInsideRectangle(
                            e.canvasX,
                            e.canvasY,
                            node.pos[0] + node.size[0] - 5,
                            node.pos[1] + node.size[1] - 5,
                            10,
                            10
                        )
                    ) {
						this.graph.beforeChange();						
                        this.resizing_node = node;
                        this.canvas.style.cursor = "se-resize";
                        skip_action = true;
                    } else {
                        //search for outputs
                        if (node.outputs) {
                            for ( var i = 0, l = node.outputs.length; i < l; ++i ) {
                                var output = node.outputs[i];
                                var link_pos = node.getConnectionPos(false, i);
                                if (
                                    isInsideRectangle(
                                        e.canvasX,
                                        e.canvasY,
                                        link_pos[0] - 15,
                                        link_pos[1] - 10,
                                        30,
                                        20
                                    )
                                ) {
                                    this.connecting_node = node;
                                    this.connecting_output = output;
                                    this.connecting_pos = node.getConnectionPos( false, i );
                                    this.connecting_slot = i;

                                    if (e.shiftKey) {
                                        node.disconnectOutput(i);
                                    }

                                    if (is_double_click) {
                                        if (node.onOutputDblClick) {
                                            node.onOutputDblClick(i, e);
                                        }
                                    } else {
                                        if (node.onOutputClick) {
                                            node.onOutputClick(i, e);
                                        }
                                    }

                                    skip_action = true;
                                    break;
                                }
                            }
                        }

                        //search for inputs
                        if (node.inputs) {
                            for ( var i = 0, l = node.inputs.length; i < l; ++i ) {
                                var input = node.inputs[i];
                                var link_pos = node.getConnectionPos(true, i);
                                if (
                                    isInsideRectangle(
                                        e.canvasX,
                                        e.canvasY,
                                        link_pos[0] - 15,
                                        link_pos[1] - 10,
                                        30,
                                        20
                                    )
                                ) {
                                    if (is_double_click) {
                                        if (node.onInputDblClick) {
                                            node.onInputDblClick(i, e);
                                        }
                                    } else {
                                        if (node.onInputClick) {
                                            node.onInputClick(i, e);
                                        }
                                    }

                                    if (input.link !== null) {
                                        var link_info = this.graph.links[
                                            input.link
                                        ]; //before disconnecting
                                        node.disconnectInput(i);

                                        if (
                                            this.allow_reconnect_links ||
                                            e.shiftKey
                                        ) {
                                            this.connecting_node = this.graph._nodes_by_id[
                                                link_info.origin_id
                                            ];
                                            this.connecting_slot =
                                                link_info.origin_slot;
                                            this.connecting_output = this.connecting_node.outputs[
                                                this.connecting_slot
                                            ];
                                            this.connecting_pos = this.connecting_node.getConnectionPos( false, this.connecting_slot );
                                        }

                                        this.dirty_bgcanvas = true;
                                        skip_action = true;
                                    }
                                }
                            }
                        }
                    } //not resizing
                }

                //it wasn't clicked on the links boxes
                if (!skip_action) {
                    var block_drag_node = false;
					var pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];

                    //widgets
                    var widget = this.processNodeWidgets( node, this.graph_mouse, e );
                    if (widget) {
                        block_drag_node = true;
                        this.node_widget = [node, widget];
                    }

                    //double clicking
                    if (is_double_click && this.selected_nodes[node.id]) {
                        //double click node
                        if (node.onDblClick) {
                            node.onDblClick( e, pos, this );
                        }
                        this.processNodeDblClicked(node);
                        block_drag_node = true;
                    }

                    //if do not capture mouse
                    if ( node.onMouseDown && node.onMouseDown( e, pos, this ) ) {
                        block_drag_node = true;
                    } else {
						//open subgraph button
						if(node.subgraph && !node.skip_subgraph_button)
						{
							if ( !node.flags.collapsed && pos[0] > node.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos[1] < 0 ) {
								var that = this;
								setTimeout(function() {
									that.openSubgraph(node.subgraph);
								}, 10);
							}
						}

						if (this.live_mode) {
							clicking_canvas_bg = true;
	                        block_drag_node = true;
						}
                    }

                    if (!block_drag_node) {
                        if (this.allow_dragnodes) {
							this.graph.beforeChange();
                            this.node_dragged = node;
                        }
                        if (!this.selected_nodes[node.id]) {
                            this.processNodeSelected(node, e);
                        }
                    }

                    this.dirty_canvas = true;
                }
            } //clicked outside of nodes
            else {
                //search for link connector
				if(!this.read_only) 
					for (var i = 0; i < this.visible_links.length; ++i) {
						var link = this.visible_links[i];
						var center = link._pos;
						if (
							!center ||
							e.canvasX < center[0] - 4 ||
							e.canvasX > center[0] + 4 ||
							e.canvasY < center[1] - 4 ||
							e.canvasY > center[1] + 4
						) {
							continue;
						}
						//link clicked
						this.showLinkMenu(link, e);
						this.over_link_center = null; //clear tooltip
						break;
					}

                this.selected_group = this.graph.getGroupOnPos( e.canvasX, e.canvasY );
                this.selected_group_resizing = false;
                if (this.selected_group && !this.read_only ) {
                    if (e.ctrlKey) {
                        this.dragging_rectangle = null;
                    }

                    var dist = distance( [e.canvasX, e.canvasY], [ this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1] ] );
                    if (dist * this.ds.scale < 10) {
                        this.selected_group_resizing = true;
                    } else {
                        this.selected_group.recomputeInsideNodes();
                    }
                }

                if (is_double_click && !this.read_only && this.allow_searchbox) {
                    this.showSearchBox(e);
                }

                clicking_canvas_bg = true;
            }

            if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {
                this.dragging_canvas = true;
            }
        } else if (e.which == 2) {
            //middle button
        } else if (e.which == 3) {
            //right button
			if(!this.read_only)
	            this.processContextMenu(node, e);
        }

        //TODO
        //if(this.node_selected != prev_selected)
        //	this.onNodeSelectionChange(this.node_selected);

        this.last_mouse[0] = e.localX;
        this.last_mouse[1] = e.localY;
        this.last_mouseclick = LiteGraph.getTime();
        this.last_mouse_dragging = true;

        /*
	if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)
		this.draw();
	*/

        this.graph.change();

        //this is to ensure to defocus(blur) if a text input element is on focus
        if (
            !ref_window.document.activeElement ||
            (ref_window.document.activeElement.nodeName.toLowerCase() !=
                "input" &&
                ref_window.document.activeElement.nodeName.toLowerCase() !=
                    "textarea")
        ) {
            e.preventDefault();
        }
        e.stopPropagation();

        if (this.onMouseDown) {
            this.onMouseDown(e);
        }

        return false;
    };

    /**
     * Called when a mouse move event has to be processed
     * @method processMouseMove
     **/
    LGraphCanvas.prototype.processMouseMove = function(e) {
        if (this.autoresize) {
            this.resize();
        }

		if( this.set_canvas_dirty_on_mouse_event )
			this.dirty_canvas = true;

        if (!this.graph) {
            return;
        }

        LGraphCanvas.active_canvas = this;
        this.adjustMouseEvent(e);
        var mouse = [e.localX, e.localY];
		this.mouse[0] = mouse[0];
		this.mouse[1] = mouse[1];
        var delta = [
            mouse[0] - this.last_mouse[0],
            mouse[1] - this.last_mouse[1]
        ];
        this.last_mouse = mouse;
        this.graph_mouse[0] = e.canvasX;
        this.graph_mouse[1] = e.canvasY;

		if(this.block_click)
		{
			e.preventDefault();
			return false;
		}

        e.dragging = this.last_mouse_dragging;

        if (this.node_widget) {
            this.processNodeWidgets(
                this.node_widget[0],
                this.graph_mouse,
                e,
                this.node_widget[1]
            );
            this.dirty_canvas = true;
        }

        if (this.dragging_rectangle)
		{
            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];
            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];
            this.dirty_canvas = true;
        } 
		else if (this.selected_group && !this.read_only)
		{
            //moving/resizing a group
            if (this.selected_group_resizing) {
                this.selected_group.size = [
                    e.canvasX - this.selected_group.pos[0],
                    e.canvasY - this.selected_group.pos[1]
                ];
            } else {
                var deltax = delta[0] / this.ds.scale;
                var deltay = delta[1] / this.ds.scale;
                this.selected_group.move(deltax, deltay, e.ctrlKey);
                if (this.selected_group._nodes.length) {
                    this.dirty_canvas = true;
                }
            }
            this.dirty_bgcanvas = true;
        } else if (this.dragging_canvas) {
            this.ds.offset[0] += delta[0] / this.ds.scale;
            this.ds.offset[1] += delta[1] / this.ds.scale;
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
        } else if (this.allow_interaction && !this.read_only) {
            if (this.connecting_node) {
                this.dirty_canvas = true;
            }

            //get node over
            var node = this.graph.getNodeOnPos(e.canvasX,e.canvasY,this.visible_nodes);

            //remove mouseover flag
            for (var i = 0, l = this.graph._nodes.length; i < l; ++i) {
                if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i] ) {
                    //mouse leave
                    this.graph._nodes[i].mouseOver = false;
                    if (this.node_over && this.node_over.onMouseLeave) {
                        this.node_over.onMouseLeave(e);
                    }
                    this.node_over = null;
                    this.dirty_canvas = true;
                }
            }

            //mouse over a node
            if (node) {

				if(node.redraw_on_mouse)
                    this.dirty_canvas = true;

                //this.canvas.style.cursor = "move";
                if (!node.mouseOver) {
                    //mouse enter
                    node.mouseOver = true;
                    this.node_over = node;
                    this.dirty_canvas = true;

                    if (node.onMouseEnter) {
                        node.onMouseEnter(e);
                    }
                }

                //in case the node wants to do something
                if (node.onMouseMove) {
                    node.onMouseMove( e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this );
                }

                //if dragging a link
                if (this.connecting_node) {
                    var pos = this._highlight_input || [0, 0]; //to store the output of isOverNodeInput

                    //on top of input
                    if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {
                        //mouse on top of the corner box, don't know what to do
                    } else {
                        //check if I have a slot below de mouse
                        var slot = this.isOverNodeInput( node, e.canvasX, e.canvasY, pos );
                        if (slot != -1 && node.inputs[slot]) {
                            var slot_type = node.inputs[slot].type;
                            if ( LiteGraph.isValidConnection( this.connecting_output.type, slot_type ) ) {
                                this._highlight_input = pos;
                                this._highlight_input_slot = node.inputs[slot];
                            }
                        } else {
                            this._highlight_input = null;
                            this._highlight_input_slot = null;
                        }
                    }
                }

                //Search for corner
                if (this.canvas) {
                    if (
                        isInsideRectangle(
                            e.canvasX,
                            e.canvasY,
                            node.pos[0] + node.size[0] - 5,
                            node.pos[1] + node.size[1] - 5,
                            5,
                            5
                        )
                    ) {
                        this.canvas.style.cursor = "se-resize";
                    } else {
                        this.canvas.style.cursor = "crosshair";
                    }
                }
            } else { //not over a node

                //search for link connector
				var over_link = null;
				for (var i = 0; i < this.visible_links.length; ++i) {
					var link = this.visible_links[i];
					var center = link._pos;
					if (
						!center ||
						e.canvasX < center[0] - 4 ||
						e.canvasX > center[0] + 4 ||
						e.canvasY < center[1] - 4 ||
						e.canvasY > center[1] + 4
					) {
						continue;
					}
					over_link = link;
					break;
				}
				if( over_link != this.over_link_center )
				{
					this.over_link_center = over_link;
	                this.dirty_canvas = true;
				}

				if (this.canvas) {
	                this.canvas.style.cursor = "";
				}
			} //end

			//send event to node if capturing input (used with widgets that allow drag outside of the area of the node)
            if ( this.node_capturing_input && this.node_capturing_input != node && this.node_capturing_input.onMouseMove ) {
                this.node_capturing_input.onMouseMove(e,[e.canvasX - this.node_capturing_input.pos[0],e.canvasY - this.node_capturing_input.pos[1]], this);
            }

			//node being dragged
            if (this.node_dragged && !this.live_mode) {
				//console.log("draggin!",this.selected_nodes);
                for (var i in this.selected_nodes) {
                    var n = this.selected_nodes[i];
                    n.pos[0] += delta[0] / this.ds.scale;
                    n.pos[1] += delta[1] / this.ds.scale;
                }

                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
            }

            if (this.resizing_node && !this.live_mode) {
                //convert mouse to node space
				var desired_size = [ e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1] ];
				var min_size = this.resizing_node.computeSize();
				desired_size[0] = Math.max( min_size[0], desired_size[0] );
				desired_size[1] = Math.max( min_size[1], desired_size[1] );
				this.resizing_node.setSize( desired_size );

                this.canvas.style.cursor = "se-resize";
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
            }
        }

        e.preventDefault();
        return false;
    };

    /**
     * Called when a mouse up event has to be processed
     * @method processMouseUp
     **/
    LGraphCanvas.prototype.processMouseUp = function(e) {

		if( this.set_canvas_dirty_on_mouse_event )
			this.dirty_canvas = true;

        if (!this.graph)
            return;

        var window = this.getCanvasWindow();
        var document = window.document;
        LGraphCanvas.active_canvas = this;

        //restore the mousemove event back to the canvas
		if(!this.options.skip_events)
		{
			document.removeEventListener("mousemove",this._mousemove_callback,true);
			this.canvas.addEventListener("mousemove",this._mousemove_callback,true);
			document.removeEventListener("mouseup", this._mouseup_callback, true);
		}

        this.adjustMouseEvent(e);
        var now = LiteGraph.getTime();
        e.click_time = now - this.last_mouseclick;
        this.last_mouse_dragging = false;
		this.last_click_position = null;

		if(this.block_click)
		{
			console.log("foo");
			this.block_click = false; //used to avoid sending twice a click in a immediate button
		}

        if (e.which == 1) {

			if( this.node_widget )
			{
				this.processNodeWidgets( this.node_widget[0], this.graph_mouse, e );
			}

            //left button
            this.node_widget = null;

            if (this.selected_group) {
                var diffx =
                    this.selected_group.pos[0] -
                    Math.round(this.selected_group.pos[0]);
                var diffy =
                    this.selected_group.pos[1] -
                    Math.round(this.selected_group.pos[1]);
                this.selected_group.move(diffx, diffy, e.ctrlKey);
                this.selected_group.pos[0] = Math.round(
                    this.selected_group.pos[0]
                );
                this.selected_group.pos[1] = Math.round(
                    this.selected_group.pos[1]
                );
                if (this.selected_group._nodes.length) {
                    this.dirty_canvas = true;
                }
                this.selected_group = null;
            }
            this.selected_group_resizing = false;

            if (this.dragging_rectangle) {
                if (this.graph) {
                    var nodes = this.graph._nodes;
                    var node_bounding = new Float32Array(4);
                    this.deselectAllNodes();
                    //compute bounding and flip if left to right
                    var w = Math.abs(this.dragging_rectangle[2]);
                    var h = Math.abs(this.dragging_rectangle[3]);
                    var startx =
                        this.dragging_rectangle[2] < 0
                            ? this.dragging_rectangle[0] - w
                            : this.dragging_rectangle[0];
                    var starty =
                        this.dragging_rectangle[3] < 0
                            ? this.dragging_rectangle[1] - h
                            : this.dragging_rectangle[1];
                    this.dragging_rectangle[0] = startx;
                    this.dragging_rectangle[1] = starty;
                    this.dragging_rectangle[2] = w;
                    this.dragging_rectangle[3] = h;

                    //test against all nodes (not visible because the rectangle maybe start outside
                    var to_select = [];
                    for (var i = 0; i < nodes.length; ++i) {
                        var node = nodes[i];
                        node.getBounding(node_bounding);
                        if (
                            !overlapBounding(
                                this.dragging_rectangle,
                                node_bounding
                            )
                        ) {
                            continue;
                        } //out of the visible area
                        to_select.push(node);
                    }
                    if (to_select.length) {
                        this.selectNodes(to_select);
                    }
                }
                this.dragging_rectangle = null;
            } else if (this.connecting_node) {
                //dragging a connection
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;

                var node = this.graph.getNodeOnPos(
                    e.canvasX,
                    e.canvasY,
                    this.visible_nodes
                );

                //node below mouse
                if (node) {
                    if (
                        this.connecting_output.type == LiteGraph.EVENT &&
                        this.isOverNodeBox(node, e.canvasX, e.canvasY)
                    ) {
                        this.connecting_node.connect(
                            this.connecting_slot,
                            node,
                            LiteGraph.EVENT
                        );
                    } else {
                        //slot below mouse? connect
                        var slot = this.isOverNodeInput(
                            node,
                            e.canvasX,
                            e.canvasY
                        );
                        if (slot != -1) {
                            this.connecting_node.connect(
                                this.connecting_slot,
                                node,
                                slot
                            );
                        } else {
                            //not on top of an input
                            var input = node.getInputInfo(0);
                            //auto connect
                            if (
                                this.connecting_output.type == LiteGraph.EVENT
                            ) {
                                this.connecting_node.connect(
                                    this.connecting_slot,
                                    node,
                                    LiteGraph.EVENT
                                );
                            } else if (
                                input &&
                                !input.link &&
                                LiteGraph.isValidConnection(
                                    input.type && this.connecting_output.type
                                )
                            ) {
                                this.connecting_node.connect(
                                    this.connecting_slot,
                                    node,
                                    0
                                );
                            }
                        }
                    }
                }

                this.connecting_output = null;
                this.connecting_pos = null;
                this.connecting_node = null;
                this.connecting_slot = -1;
            } //not dragging connection
            else if (this.resizing_node) {
                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
				this.graph.afterChange(this.resizing_node);
                this.resizing_node = null;
            } else if (this.node_dragged) {
                //node being dragged?
                var node = this.node_dragged;
                if (
                    node &&
                    e.click_time < 300 &&
                    isInsideRectangle( e.canvasX, e.canvasY, node.pos[0], node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT )
                ) {
                    node.collapse();
                }

                this.dirty_canvas = true;
                this.dirty_bgcanvas = true;
                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
                if (this.graph.config.align_to_grid || this.align_to_grid ) {
                    this.node_dragged.alignToGrid();
                }
				if( this.onNodeMoved )
					this.onNodeMoved( this.node_dragged );
				this.graph.afterChange(this.node_dragged);
                this.node_dragged = null;
            } //no node being dragged
            else {
                //get node over
                var node = this.graph.getNodeOnPos(
                    e.canvasX,
                    e.canvasY,
                    this.visible_nodes
                );

                if (!node && e.click_time < 300) {
                    this.deselectAllNodes();
                }

                this.dirty_canvas = true;
                this.dragging_canvas = false;

                if (this.node_over && this.node_over.onMouseUp) {
                    this.node_over.onMouseUp( e, [ e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1] ], this );
                }
                if (
                    this.node_capturing_input &&
                    this.node_capturing_input.onMouseUp
                ) {
                    this.node_capturing_input.onMouseUp(e, [
                        e.canvasX - this.node_capturing_input.pos[0],
                        e.canvasY - this.node_capturing_input.pos[1]
                    ]);
                }
            }
        } else if (e.which == 2) {
            //middle button
            //trace("middle");
            this.dirty_canvas = true;
            this.dragging_canvas = false;
        } else if (e.which == 3) {
            //right button
            //trace("right");
            this.dirty_canvas = true;
            this.dragging_canvas = false;
        }

        /*
	if((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)
		this.draw();
	*/

        this.graph.change();

        e.stopPropagation();
        e.preventDefault();
        return false;
    };

    /**
     * Called when a mouse wheel event has to be processed
     * @method processMouseWheel
     **/
    LGraphCanvas.prototype.processMouseWheel = function(e) {
        if (!this.graph || !this.allow_dragcanvas) {
            return;
        }

        var delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;

        this.adjustMouseEvent(e);

		var x = e.localX;
		var y = e.localY;
		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
		if(!is_inside)
			return;

        var scale = this.ds.scale;

        if (delta > 0) {
            scale *= 1.1;
        } else if (delta < 0) {
            scale *= 1 / 1.1;
        }

        //this.setZoom( scale, [ e.localX, e.localY ] );
        this.ds.changeScale(scale, [e.localX, e.localY]);

        this.graph.change();

        e.preventDefault();
        return false; // prevent default
    };

    /**
     * returns true if a position (in graph space) is on top of a node little corner box
     * @method isOverNodeBox
     **/
    LGraphCanvas.prototype.isOverNodeBox = function(node, canvasx, canvasy) {
        var title_height = LiteGraph.NODE_TITLE_HEIGHT;
        if (
            isInsideRectangle(
                canvasx,
                canvasy,
                node.pos[0] + 2,
                node.pos[1] + 2 - title_height,
                title_height - 4,
                title_height - 4
            )
        ) {
            return true;
        }
        return false;
    };

    /**
     * returns true if a position (in graph space) is on top of a node input slot
     * @method isOverNodeInput
     **/
    LGraphCanvas.prototype.isOverNodeInput = function(
        node,
        canvasx,
        canvasy,
        slot_pos
    ) {
        if (node.inputs) {
            for (var i = 0, l = node.inputs.length; i < l; ++i) {
                var input = node.inputs[i];
                var link_pos = node.getConnectionPos(true, i);
                var is_inside = false;
                if (node.horizontal) {
                    is_inside = isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 5,
                        link_pos[1] - 10,
                        10,
                        20
                    );
                } else {
                    is_inside = isInsideRectangle(
                        canvasx,
                        canvasy,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        40,
                        10
                    );
                }
                if (is_inside) {
                    if (slot_pos) {
                        slot_pos[0] = link_pos[0];
                        slot_pos[1] = link_pos[1];
                    }
                    return i;
                }
            }
        }
        return -1;
    };

    /**
     * process a key event
     * @method processKey
     **/
    LGraphCanvas.prototype.processKey = function(e) {
        if (!this.graph) {
            return;
        }

        var block_default = false;
        //console.log(e); //debug

        if (e.target.localName == "input") {
            return;
        }

        if (e.type == "keydown") {
            if (e.keyCode == 32) {
                //esc
                this.dragging_canvas = true;
                block_default = true;
            }

            //select all Control A
            if (e.keyCode == 65 && e.ctrlKey) {
                this.selectNodes();
                block_default = true;
            }

            if (e.code == "KeyC" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
                //copy
                if (this.selected_nodes) {
                    this.copyToClipboard();
                    block_default = true;
                }
            }

            if (e.code == "KeyV" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
                //paste
                this.pasteFromClipboard();
            }

            //delete or backspace
            if (e.keyCode == 46 || e.keyCode == 8) {
                if (
                    e.target.localName != "input" &&
                    e.target.localName != "textarea"
                ) {
                    this.deleteSelectedNodes();
                    block_default = true;
                }
            }

            //collapse
            //...

            //TODO
            if (this.selected_nodes) {
                for (var i in this.selected_nodes) {
                    if (this.selected_nodes[i].onKeyDown) {
                        this.selected_nodes[i].onKeyDown(e);
                    }
                }
            }
        } else if (e.type == "keyup") {
            if (e.keyCode == 32) {
                this.dragging_canvas = false;
            }

            if (this.selected_nodes) {
                for (var i in this.selected_nodes) {
                    if (this.selected_nodes[i].onKeyUp) {
                        this.selected_nodes[i].onKeyUp(e);
                    }
                }
            }
        }

        this.graph.change();

        if (block_default) {
            e.preventDefault();
            e.stopImmediatePropagation();
            return false;
        }
    };

    LGraphCanvas.prototype.copyToClipboard = function() {
        var clipboard_info = {
            nodes: [],
            links: []
        };
        var index = 0;
        var selected_nodes_array = [];
        for (var i in this.selected_nodes) {
            var node = this.selected_nodes[i];
            node._relative_id = index;
            selected_nodes_array.push(node);
            index += 1;
        }

        for (var i = 0; i < selected_nodes_array.length; ++i) {
            var node = selected_nodes_array[i];
			var cloned = node.clone();
			if(!cloned)
			{
				console.warn("node type not found: " + node.type );
				continue;
			}
            clipboard_info.nodes.push(cloned.serialize());
            if (node.inputs && node.inputs.length) {
                for (var j = 0; j < node.inputs.length; ++j) {
                    var input = node.inputs[j];
                    if (!input || input.link == null) {
                        continue;
                    }
                    var link_info = this.graph.links[input.link];
                    if (!link_info) {
                        continue;
                    }
                    var target_node = this.graph.getNodeById(
                        link_info.origin_id
                    );
                    if (!target_node || !this.selected_nodes[target_node.id]) {
                        //improve this by allowing connections to non-selected nodes
                        continue;
                    } //not selected
                    clipboard_info.links.push([
                        target_node._relative_id,
                        link_info.origin_slot, //j,
                        node._relative_id,
                        link_info.target_slot
                    ]);
                }
            }
        }
        localStorage.setItem(
            "litegrapheditor_clipboard",
            JSON.stringify(clipboard_info)
        );
    };

    LGraphCanvas.prototype.pasteFromClipboard = function() {
        var data = localStorage.getItem("litegrapheditor_clipboard");
        if (!data) {
            return;
        }

		this.graph.beforeChange();

        //create nodes
        var clipboard_info = JSON.parse(data);
        var nodes = [];
        for (var i = 0; i < clipboard_info.nodes.length; ++i) {
            var node_data = clipboard_info.nodes[i];
            var node = LiteGraph.createNode(node_data.type);
            if (node) {
                node.configure(node_data);
                node.pos[0] += 5;
                node.pos[1] += 5;
                this.graph.add(node);
                nodes.push(node);
            }
        }

        //create links
        for (var i = 0; i < clipboard_info.links.length; ++i) {
            var link_info = clipboard_info.links[i];
            var origin_node = nodes[link_info[0]];
            var target_node = nodes[link_info[2]];
			if( origin_node && target_node )
	            origin_node.connect(link_info[1], target_node, link_info[3]);
			else
				console.warn("Warning, nodes missing on pasting");
        }

        this.selectNodes(nodes);

		this.graph.afterChange();
    };

    /**
     * process a item drop event on top the canvas
     * @method processDrop
     **/
    LGraphCanvas.prototype.processDrop = function(e) {
        e.preventDefault();
        this.adjustMouseEvent(e);
		var x = e.localX;
		var y = e.localY;
		var is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );
		if(!is_inside)
			return;

        var pos = [e.canvasX, e.canvasY];


        var node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;

        if (!node) {
            var r = null;
            if (this.onDropItem) {
                r = this.onDropItem(event);
            }
            if (!r) {
                this.checkDropItem(e);
            }
            return;
        }

        if (node.onDropFile || node.onDropData) {
            var files = e.dataTransfer.files;
            if (files && files.length) {
                for (var i = 0; i < files.length; i++) {
                    var file = e.dataTransfer.files[0];
                    var filename = file.name;
                    var ext = LGraphCanvas.getFileExtension(filename);
                    //console.log(file);

                    if (node.onDropFile) {
                        node.onDropFile(file);
                    }

                    if (node.onDropData) {
                        //prepare reader
                        var reader = new FileReader();
                        reader.onload = function(event) {
                            //console.log(event.target);
                            var data = event.target.result;
                            node.onDropData(data, filename, file);
                        };

                        //read data
                        var type = file.type.split("/")[0];
                        if (type == "text" || type == "") {
                            reader.readAsText(file);
                        } else if (type == "image") {
                            reader.readAsDataURL(file);
                        } else {
                            reader.readAsArrayBuffer(file);
                        }
                    }
                }
            }
        }

        if (node.onDropItem) {
            if (node.onDropItem(event)) {
                return true;
            }
        }

        if (this.onDropItem) {
            return this.onDropItem(event);
        }

        return false;
    };

    //called if the graph doesn't have a default drop item behaviour
    LGraphCanvas.prototype.checkDropItem = function(e) {
        if (e.dataTransfer.files.length) {
            var file = e.dataTransfer.files[0];
            var ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();
            var nodetype = LiteGraph.node_types_by_file_extension[ext];
            if (nodetype) {
				this.graph.beforeChange();
                var node = LiteGraph.createNode(nodetype.type);
                node.pos = [e.canvasX, e.canvasY];
                this.graph.add(node);
                if (node.onDropFile) {
                    node.onDropFile(file);
                }
				this.graph.afterChange();
            }
        }
    };

    LGraphCanvas.prototype.processNodeDblClicked = function(n) {
        if (this.onShowNodePanel) {
            this.onShowNodePanel(n);
        }
		else
		{
			this.showShowNodePanel(n);
		}

        if (this.onNodeDblClicked) {
            this.onNodeDblClicked(n);
        }

        this.setDirty(true);
    };

    LGraphCanvas.prototype.processNodeSelected = function(node, e) {
        this.selectNode(node, e && e.shiftKey);
        if (this.onNodeSelected) {
            this.onNodeSelected(node);
        }
    };

    /**
     * selects a given node (or adds it to the current selection)
     * @method selectNode
     **/
    LGraphCanvas.prototype.selectNode = function(
        node,
        add_to_current_selection
    ) {
        if (node == null) {
            this.deselectAllNodes();
        } else {
            this.selectNodes([node], add_to_current_selection);
        }
    };

    /**
     * selects several nodes (or adds them to the current selection)
     * @method selectNodes
     **/
    LGraphCanvas.prototype.selectNodes = function( nodes, add_to_current_selection )
	{
        if (!add_to_current_selection) {
            this.deselectAllNodes();
        }

        nodes = nodes || this.graph._nodes;
        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            if (node.is_selected) {
                continue;
            }

            if (!node.is_selected && node.onSelected) {
                node.onSelected();
            }
            node.is_selected = true;
            this.selected_nodes[node.id] = node;

            if (node.inputs) {
                for (var j = 0; j < node.inputs.length; ++j) {
                    this.highlighted_links[node.inputs[j].link] = true;
                }
            }
            if (node.outputs) {
                for (var j = 0; j < node.outputs.length; ++j) {
                    var out = node.outputs[j];
                    if (out.links) {
                        for (var k = 0; k < out.links.length; ++k) {
                            this.highlighted_links[out.links[k]] = true;
                        }
                    }
                }
            }
        }

		if(	this.onSelectionChange )
			this.onSelectionChange( this.selected_nodes );

        this.setDirty(true);
    };

    /**
     * removes a node from the current selection
     * @method deselectNode
     **/
    LGraphCanvas.prototype.deselectNode = function(node) {
        if (!node.is_selected) {
            return;
        }
        if (node.onDeselected) {
            node.onDeselected();
        }
        node.is_selected = false;

        if (this.onNodeDeselected) {
            this.onNodeDeselected(node);
        }

        //remove highlighted
        if (node.inputs) {
            for (var i = 0; i < node.inputs.length; ++i) {
                delete this.highlighted_links[node.inputs[i].link];
            }
        }
        if (node.outputs) {
            for (var i = 0; i < node.outputs.length; ++i) {
                var out = node.outputs[i];
                if (out.links) {
                    for (var j = 0; j < out.links.length; ++j) {
                        delete this.highlighted_links[out.links[j]];
                    }
                }
            }
        }
    };

    /**
     * removes all nodes from the current selection
     * @method deselectAllNodes
     **/
    LGraphCanvas.prototype.deselectAllNodes = function() {
        if (!this.graph) {
            return;
        }
        var nodes = this.graph._nodes;
        for (var i = 0, l = nodes.length; i < l; ++i) {
            var node = nodes[i];
            if (!node.is_selected) {
                continue;
            }
            if (node.onDeselected) {
                node.onDeselected();
            }
            node.is_selected = false;
			if (this.onNodeDeselected) {
				this.onNodeDeselected(node);
			}
        }
        this.selected_nodes = {};
        this.current_node = null;
        this.highlighted_links = {};
		if(	this.onSelectionChange )
			this.onSelectionChange( this.selected_nodes );
        this.setDirty(true);
    };

    /**
     * deletes all nodes in the current selection from the graph
     * @method deleteSelectedNodes
     **/
    LGraphCanvas.prototype.deleteSelectedNodes = function() {

		this.graph.beforeChange();

        for (var i in this.selected_nodes) {
            var node = this.selected_nodes[i];

			if(node.block_delete)
				continue;

			//autoconnect when possible (very basic, only takes into account first input-output)
			if(node.inputs && node.inputs.length && node.outputs && node.outputs.length && LiteGraph.isValidConnection( node.inputs[0].type, node.outputs[0].type ) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length ) 
			{
				var input_link = node.graph.links[ node.inputs[0].link ];
				var output_link = node.graph.links[ node.outputs[0].links[0] ];
				var input_node = node.getInputNode(0);
				var output_node = node.getOutputNodes(0)[0];
				if(input_node && output_node)
					input_node.connect( input_link.origin_slot, output_node, output_link.target_slot );
			}
            this.graph.remove(node);
			if (this.onNodeDeselected) {
				this.onNodeDeselected(node);
			}
        }
        this.selected_nodes = {};
        this.current_node = null;
        this.highlighted_links = {};
        this.setDirty(true);
		this.graph.afterChange();
    };

    /**
     * centers the camera on a given node
     * @method centerOnNode
     **/
    LGraphCanvas.prototype.centerOnNode = function(node) {
        this.ds.offset[0] =
            -node.pos[0] -
            node.size[0] * 0.5 +
            (this.canvas.width * 0.5) / this.ds.scale;
        this.ds.offset[1] =
            -node.pos[1] -
            node.size[1] * 0.5 +
            (this.canvas.height * 0.5) / this.ds.scale;
        this.setDirty(true, true);
    };

    /**
     * adds some useful properties to a mouse event, like the position in graph coordinates
     * @method adjustMouseEvent
     **/
    LGraphCanvas.prototype.adjustMouseEvent = function(e) {
        if (this.canvas) {
            var b = this.canvas.getBoundingClientRect();
            e.localX = e.clientX - b.left;
            e.localY = e.clientY - b.top;
        } else {
            e.localX = e.clientX;
            e.localY = e.clientY;
        }

        e.deltaX = e.localX - this.last_mouse_position[0];
        e.deltaY = e.localY - this.last_mouse_position[1];

        this.last_mouse_position[0] = e.localX;
        this.last_mouse_position[1] = e.localY;

        e.canvasX = e.localX / this.ds.scale - this.ds.offset[0];
        e.canvasY = e.localY / this.ds.scale - this.ds.offset[1];
    };

    /**
     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom
     * @method setZoom
     **/
    LGraphCanvas.prototype.setZoom = function(value, zooming_center) {
        this.ds.changeScale(value, zooming_center);
        /*
	if(!zooming_center && this.canvas)
		zooming_center = [this.canvas.width * 0.5,this.canvas.height * 0.5];

	var center = this.convertOffsetToCanvas( zooming_center );

	this.ds.scale = value;

	if(this.scale > this.max_zoom)
		this.scale = this.max_zoom;
	else if(this.scale < this.min_zoom)
		this.scale = this.min_zoom;

	var new_center = this.convertOffsetToCanvas( zooming_center );
	var delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];

	this.offset[0] += delta_offset[0];
	this.offset[1] += delta_offset[1];
	*/

        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
    };

    /**
     * converts a coordinate from graph coordinates to canvas2D coordinates
     * @method convertOffsetToCanvas
     **/
    LGraphCanvas.prototype.convertOffsetToCanvas = function(pos, out) {
        return this.ds.convertOffsetToCanvas(pos, out);
    };

    /**
     * converts a coordinate from Canvas2D coordinates to graph space
     * @method convertCanvasToOffset
     **/
    LGraphCanvas.prototype.convertCanvasToOffset = function(pos, out) {
        return this.ds.convertCanvasToOffset(pos, out);
    };

    //converts event coordinates from canvas2D to graph coordinates
    LGraphCanvas.prototype.convertEventToCanvasOffset = function(e) {
        var rect = this.canvas.getBoundingClientRect();
        return this.convertCanvasToOffset([
            e.clientX - rect.left,
            e.clientY - rect.top
        ]);
    };

    /**
     * brings a node to front (above all other nodes)
     * @method bringToFront
     **/
    LGraphCanvas.prototype.bringToFront = function(node) {
        var i = this.graph._nodes.indexOf(node);
        if (i == -1) {
            return;
        }

        this.graph._nodes.splice(i, 1);
        this.graph._nodes.push(node);
    };

    /**
     * sends a node to the back (below all other nodes)
     * @method sendToBack
     **/
    LGraphCanvas.prototype.sendToBack = function(node) {
        var i = this.graph._nodes.indexOf(node);
        if (i == -1) {
            return;
        }

        this.graph._nodes.splice(i, 1);
        this.graph._nodes.unshift(node);
    };

    /* Interaction */

    /* LGraphCanvas render */
    var temp = new Float32Array(4);

    /**
     * checks which nodes are visible (inside the camera area)
     * @method computeVisibleNodes
     **/
    LGraphCanvas.prototype.computeVisibleNodes = function(nodes, out) {
        var visible_nodes = out || [];
        visible_nodes.length = 0;
        nodes = nodes || this.graph._nodes;
        for (var i = 0, l = nodes.length; i < l; ++i) {
            var n = nodes[i];

            //skip rendering nodes in live mode
            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {
                continue;
            }

            if (!overlapBounding(this.visible_area, n.getBounding(temp))) {
                continue;
            } //out of the visible area

            visible_nodes.push(n);
        }
        return visible_nodes;
    };

    /**
     * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)
     * @method draw
     **/
    LGraphCanvas.prototype.draw = function(force_canvas, force_bgcanvas) {
        if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {
            return;
        }

        //fps counting
        var now = LiteGraph.getTime();
        this.render_time = (now - this.last_draw_time) * 0.001;
        this.last_draw_time = now;

        if (this.graph) {
            this.ds.computeVisibleArea(this.viewport);
        }

        if (
            this.dirty_bgcanvas ||
            force_bgcanvas ||
            this.always_render_background ||
            (this.graph &&
                this.graph._last_trigger_time &&
                now - this.graph._last_trigger_time < 1000)
        ) {
            this.drawBackCanvas();
        }

        if (this.dirty_canvas || force_canvas) {
            this.drawFrontCanvas();
        }

        this.fps = this.render_time ? 1.0 / this.render_time : 0;
        this.frame += 1;
    };

    /**
     * draws the front canvas (the one containing all the nodes)
     * @method drawFrontCanvas
     **/
    LGraphCanvas.prototype.drawFrontCanvas = function() {
        this.dirty_canvas = false;

        if (!this.ctx) {
            this.ctx = this.bgcanvas.getContext("2d");
        }
        var ctx = this.ctx;
        if (!ctx) {
            //maybe is using webgl...
            return;
        }

        var canvas = this.canvas;
        if ( ctx.start2D && !this.viewport ) {
            ctx.start2D();
			ctx.restore();
			ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        //clip dirty area if there is one, otherwise work in full canvas
		var area = this.viewport || this.dirty_area;
        if (area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect( area[0],area[1],area[2],area[3] );
            ctx.clip();
        }

        //clear
        //canvas.width = canvas.width;
        if (this.clear_background) {
			if(area)
	            ctx.clearRect( area[0],area[1],area[2],area[3] );
			else
	            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        //draw bg canvas
        if (this.bgcanvas == this.canvas) {
            this.drawBackCanvas();
        } else {
            ctx.drawImage( this.bgcanvas, 0, 0 );
        }

        //rendering
        if (this.onRender) {
            this.onRender(canvas, ctx);
        }

        //info widget
        if (this.show_info) {
            this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0 );
        }

        if (this.graph) {
            //apply transformations
            ctx.save();
            this.ds.toCanvasContext(ctx);

            //draw nodes
            var drawn_nodes = 0;
            var visible_nodes = this.computeVisibleNodes(
                null,
                this.visible_nodes
            );

            for (var i = 0; i < visible_nodes.length; ++i) {
                var node = visible_nodes[i];

                //transform coords system
                ctx.save();
                ctx.translate(node.pos[0], node.pos[1]);

                //Draw
                this.drawNode(node, ctx);
                drawn_nodes += 1;

                //Restore
                ctx.restore();
            }

            //on top (debug)
            if (this.render_execution_order) {
                this.drawExecutionOrder(ctx);
            }

            //connections ontop?
            if (this.graph.config.links_ontop) {
                if (!this.live_mode) {
                    this.drawConnections(ctx);
                }
            }

            //current connection (the one being dragged by the mouse)
            if (this.connecting_pos != null) {
                ctx.lineWidth = this.connections_width;
                var link_color = null;

                switch (this.connecting_output.type) {
                    case LiteGraph.EVENT:
                        link_color = LiteGraph.EVENT_LINK_COLOR;
                        break;
                    default:
                        link_color = LiteGraph.CONNECTING_LINK_COLOR;
                }

                //the connection being dragged by the mouse
                this.renderLink(
                    ctx,
                    this.connecting_pos,
                    [this.graph_mouse[0], this.graph_mouse[1]],
                    null,
                    false,
                    null,
                    link_color,
                    this.connecting_output.dir ||
                        (this.connecting_node.horizontal
                            ? LiteGraph.DOWN
                            : LiteGraph.RIGHT),
                    LiteGraph.CENTER
                );

                ctx.beginPath();
                if (
                    this.connecting_output.type === LiteGraph.EVENT ||
                    this.connecting_output.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(
                        this.connecting_pos[0] - 6 + 0.5,
                        this.connecting_pos[1] - 5 + 0.5,
                        14,
                        10
                    );
                } else if (this.connecting_output.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5);
                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5);
                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5);
                    ctx.closePath();
                } 
                else {
                    ctx.arc(
                        this.connecting_pos[0],
                        this.connecting_pos[1],
                        4,
                        0,
                        Math.PI * 2
                    );
                }
                ctx.fill();

                ctx.fillStyle = "#ffcc00";
                if (this._highlight_input) {
                    ctx.beginPath();
                    var shape = this._highlight_input_slot.shape;
                    if (shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);
                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);
                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
                        ctx.arc(
                            this._highlight_input[0],
                            this._highlight_input[1],
                            6,
                            0,
                            Math.PI * 2
                        );
                    }
                    ctx.fill();
                }
            }

			//the selection rectangle
            if (this.dragging_rectangle) {
                ctx.strokeStyle = "#FFF";
                ctx.strokeRect(
                    this.dragging_rectangle[0],
                    this.dragging_rectangle[1],
                    this.dragging_rectangle[2],
                    this.dragging_rectangle[3]
                );
            }

			//on top of link center
			if(this.over_link_center && this.render_link_tooltip)
				this.drawLinkTooltip( ctx, this.over_link_center );
			else
				if(this.onDrawLinkTooltip) //to remove
					this.onDrawLinkTooltip(ctx,null);

			//custom info
            if (this.onDrawForeground) {
                this.onDrawForeground(ctx, this.visible_rect);
            }

            ctx.restore();
        }

		//draws panel in the corner 
		if (this._graph_stack && this._graph_stack.length) {
			this.drawSubgraphPanel( ctx );
		}


        if (this.onDrawOverlay) {
            this.onDrawOverlay(ctx);
        }

        if (area) {
            ctx.restore();
        }

        if (ctx.finish2D) {
            //this is a function I use in webgl renderer
            ctx.finish2D();
        }
    };

    /**
     * draws the panel in the corner that shows subgraph properties
     * @method drawSubgraphPanel
     **/
	LGraphCanvas.prototype.drawSubgraphPanel = function(ctx) {
		var subgraph = this.graph;
		var subnode = subgraph._subgraph_node;
		if(!subnode)
		{
			console.warn("subgraph without subnode");
			return;
		}

		var num = subnode.inputs ? subnode.inputs.length : 0;
		var w = 300;
		var h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);

		ctx.fillStyle = "#111";
		ctx.globalAlpha = 0.8;
		ctx.beginPath();
		ctx.roundRect(10,10,w, (num + 1) * h + 50,8 );
		ctx.fill();
		ctx.globalAlpha = 1;

		ctx.fillStyle = "#888";
		ctx.font = "14px Arial";
		ctx.textAlign = "left";
		ctx.fillText( "Graph Inputs", 20, 34 );
		var pos = this.mouse;

		if( this.drawButton( w - 20, 20,20,20, "X", "#151515" ) )
		{
			this.closeSubgraph();
			return;
		}

		var y = 50;
		ctx.font = "20px Arial";
		if(subnode.inputs)
		for(var i = 0; i < subnode.inputs.length; ++i)
		{
			var input = subnode.inputs[i];
			if(input.not_subgraph_input)
				continue;

			//input button clicked
			if( this.drawButton( 20,y+2,w - 20, h - 2 ) )
			{
				var type = subnode.constructor.input_node_type || "graph/input";
				this.graph.beforeChange();
				var newnode = LiteGraph.createNode( type );
				if(newnode)
				{
					subgraph.add( newnode );
					this.block_click = false;
					this.last_click_position = null;
					this.selectNodes([newnode]);
					this.node_dragged = newnode;
					this.dragging_canvas = false;
					newnode.setProperty("name",input.name);
					newnode.setProperty("type",input.type);
					this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
					this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
					this.graph.afterChange();
				}
				else
					console.error("graph input node not found:",type);
			}

			ctx.fillStyle = "#9C9";
			ctx.beginPath();
			ctx.arc(w - 16,y + h * 0.5,5,0,2*Math.PI);
			ctx.fill();

			ctx.fillStyle = "#AAA";
			ctx.fillText( input.name, 50, y + h*0.75 );
			var tw = ctx.measureText( input.name );
			ctx.fillStyle = "#777";
			ctx.fillText( input.type, 50 + tw.width + 10, y + h*0.75 );

			y += h;
		}

		//add + button
		if( this.drawButton( 20,y+2,w - 20, h - 2, "+", "#151515", "#222" ) )
		{
			this.showSubgraphPropertiesDialog( subnode );
		}
	}

	//Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm
	LGraphCanvas.prototype.drawButton = function( x,y,w,h, text, bgcolor, hovercolor, textcolor )
	{
		var ctx = this.ctx;
		bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;
		hovercolor = hovercolor || "#555";
		textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;

		var pos = this.mouse;
		var hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
		pos = this.last_click_position;
		var clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );

		ctx.fillStyle = hover ? hovercolor : bgcolor;
		if(clicked)
			ctx.fillStyle = "#AAA";
		ctx.beginPath();
		ctx.roundRect(x,y,w,h,4 );
		ctx.fill();

		if(text != null)
		{
			if(text.constructor == String)
			{
				ctx.fillStyle = textcolor;
				ctx.textAlign = "center";
				ctx.font = ((h * 0.65)|0) + "px Arial";
				ctx.fillText( text, x + w * 0.5,y + h * 0.75 );
				ctx.textAlign = "left";
			}
		}

		var was_clicked = clicked && !this.block_click;
		if(clicked)
			this.blockClick();
		return was_clicked;
	}

	LGraphCanvas.prototype.isAreaClicked = function( x,y,w,h, hold_click )
	{
		var pos = this.mouse;
		var hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
		pos = this.last_click_position;
		var clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );
		var was_clicked = clicked && !this.block_click;
		if(clicked && hold_click)
			this.blockClick();
		return was_clicked;
	}

    /**
     * draws some useful stats in the corner of the canvas
     * @method renderInfo
     **/
    LGraphCanvas.prototype.renderInfo = function(ctx, x, y) {
        x = x || 10;
        y = y || this.canvas.height - 80;

        ctx.save();
        ctx.translate(x, y);

        ctx.font = "10px Arial";
        ctx.fillStyle = "#888";
		ctx.textAlign = "left";
        if (this.graph) {
            ctx.fillText( "T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1 );
            ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2 );
            ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3 );
            ctx.fillText("V: " + this.graph._version, 5, 13 * 4);
            ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);
        } else {
            ctx.fillText("No graph selected", 5, 13 * 1);
        }
        ctx.restore();
    };

    /**
     * draws the back canvas (the one containing the background and the connections)
     * @method drawBackCanvas
     **/
    LGraphCanvas.prototype.drawBackCanvas = function() {
        var canvas = this.bgcanvas;
        if (
            canvas.width != this.canvas.width ||
            canvas.height != this.canvas.height
        ) {
            canvas.width = this.canvas.width;
            canvas.height = this.canvas.height;
        }

        if (!this.bgctx) {
            this.bgctx = this.bgcanvas.getContext("2d");
        }
        var ctx = this.bgctx;
        if (ctx.start) {
            ctx.start();
        }

		var viewport = this.viewport || [0,0,ctx.canvas.width,ctx.canvas.height];

        //clear
        if (this.clear_background) {
            ctx.clearRect( viewport[0], viewport[1], viewport[2], viewport[3] );
        }

		//show subgraph stack header
        if (this._graph_stack && this._graph_stack.length) {
            ctx.save();
            var parent_graph = this._graph_stack[this._graph_stack.length - 1];
            var subgraph_node = this.graph._subgraph_node;
            ctx.strokeStyle = subgraph_node.bgcolor;
            ctx.lineWidth = 10;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            ctx.lineWidth = 1;
            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            ctx.fillStyle = subgraph_node.bgcolor || "#AAA";
            var title = "";
            for (var i = 1; i < this._graph_stack.length; ++i) {
                title +=
                    this._graph_stack[i]._subgraph_node.getTitle() + " >> ";
            }
            ctx.fillText(
                title + subgraph_node.getTitle(),
                canvas.width * 0.5,
                40
            );
            ctx.restore();
        }

        var bg_already_painted = false;
        if (this.onRenderBackground) {
            bg_already_painted = this.onRenderBackground(canvas, ctx);
        }

        //reset in case of error
        if ( !this.viewport )
		{
	        ctx.restore();
		    ctx.setTransform(1, 0, 0, 1, 0, 0);
		}
        this.visible_links.length = 0;

        if (this.graph) {
            //apply transformations
            ctx.save();
            this.ds.toCanvasContext(ctx);

            //render BG
            if (
                this.background_image &&
                this.ds.scale > 0.5 &&
                !bg_already_painted
            ) {
                if (this.zoom_modify_alpha) {
                    ctx.globalAlpha =
                        (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;
                } else {
                    ctx.globalAlpha = this.editor_alpha;
                }
                ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.imageSmoothingEnabled = false;
                if (
                    !this._bg_img ||
                    this._bg_img.name != this.background_image
                ) {
                    this._bg_img = new Image();
                    this._bg_img.name = this.background_image;
                    this._bg_img.src = this.background_image;
                    var that = this;
                    this._bg_img.onload = function() {
                        that.draw(true, true);
                    };
                }

                var pattern = null;
                if (this._pattern == null && this._bg_img.width > 0) {
                    pattern = ctx.createPattern(this._bg_img, "repeat");
                    this._pattern_img = this._bg_img;
                    this._pattern = pattern;
                } else {
                    pattern = this._pattern;
                }
                if (pattern) {
                    ctx.fillStyle = pattern;
                    ctx.fillRect(
                        this.visible_area[0],
                        this.visible_area[1],
                        this.visible_area[2],
                        this.visible_area[3]
                    );
                    ctx.fillStyle = "transparent";
                }

                ctx.globalAlpha = 1.0;
                ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.imageSmoothingEnabled = true;
            }

            //groups
            if (this.graph._groups.length && !this.live_mode) {
                this.drawGroups(canvas, ctx);
            }

            if (this.onDrawBackground) {
                this.onDrawBackground(ctx, this.visible_area);
            }
            if (this.onBackgroundRender) {
                //LEGACY
                console.error(
                    "WARNING! onBackgroundRender deprecated, now is named onDrawBackground "
                );
                this.onBackgroundRender = null;
            }

            //DEBUG: show clipping area
            //ctx.fillStyle = "red";
            //ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);

            //bg
            if (this.render_canvas_border) {
                ctx.strokeStyle = "#235";
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }

            if (this.render_connections_shadows) {
                ctx.shadowColor = "#000";
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.shadowBlur = 6;
            } else {
                ctx.shadowColor = "rgba(0,0,0,0)";
            }

            //draw connections
            if (!this.live_mode) {
                this.drawConnections(ctx);
            }

            ctx.shadowColor = "rgba(0,0,0,0)";

            //restore state
            ctx.restore();
        }

        if (ctx.finish) {
            ctx.finish();
        }

        this.dirty_bgcanvas = false;
        this.dirty_canvas = true; //to force to repaint the front canvas with the bgcanvas
    };

    var temp_vec2 = new Float32Array(2);

    /**
     * draws the given node inside the canvas
     * @method drawNode
     **/
    LGraphCanvas.prototype.drawNode = function(node, ctx) {
        var glow = false;
        this.current_node = node;

        var color = node.color || node.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;
        var bgcolor = node.bgcolor || node.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;

        //shadow and glow
        if (node.mouseOver) {
            glow = true;
        }

        var low_quality = this.ds.scale < 0.6; //zoomed out

        //only render if it forces it to do it
        if (this.live_mode) {
            if (!node.flags.collapsed) {
                ctx.shadowColor = "transparent";
                if (node.onDrawForeground) {
                    node.onDrawForeground(ctx, this, this.canvas);
                }
            }
            return;
        }

        var editor_alpha = this.editor_alpha;
        ctx.globalAlpha = editor_alpha;

        if (this.render_shadows && !low_quality) {
            ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
            ctx.shadowOffsetX = 2 * this.ds.scale;
            ctx.shadowOffsetY = 2 * this.ds.scale;
            ctx.shadowBlur = 3 * this.ds.scale;
        } else {
            ctx.shadowColor = "transparent";
        }

        //custom draw collapsed method (draw after shadows because they are affected)
        if (
            node.flags.collapsed &&
            node.onDrawCollapsed &&
            node.onDrawCollapsed(ctx, this) == true
        ) {
            return;
        }

        //clip if required (mask)
        var shape = node._shape || LiteGraph.BOX_SHAPE;
        var size = temp_vec2;
        temp_vec2.set(node.size);
        var horizontal = node.horizontal; // || node.flags.horizontal;

        if (node.flags.collapsed) {
            ctx.font = this.inner_text_font;
            var title = node.getTitle ? node.getTitle() : node.title;
            if (title != null) {
                node._collapsed_width = Math.min(
                    node.size[0],
                    ctx.measureText(title).width +
                        LiteGraph.NODE_TITLE_HEIGHT * 2
                ); //LiteGraph.NODE_COLLAPSED_WIDTH;
                size[0] = node._collapsed_width;
                size[1] = 0;
            }
        }

        if (node.clip_area) {
            //Start clipping
            ctx.save();
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE) {
                ctx.rect(0, 0, size[0], size[1]);
            } else if (shape == LiteGraph.ROUND_SHAPE) {
                ctx.roundRect(0, 0, size[0], size[1], 10);
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5,
                    0,
                    Math.PI * 2
                );
            }
            ctx.clip();
        }

        //draw shape
        if (node.has_errors) {
            bgcolor = "red";
        }
        this.drawNodeShape(
            node,
            ctx,
            size,
            color,
            bgcolor,
            node.is_selected,
            node.mouseOver
        );
        ctx.shadowColor = "transparent";

        //draw foreground
        if (node.onDrawForeground) {
            node.onDrawForeground(ctx, this, this.canvas);
        }

        //connection slots
        ctx.textAlign = horizontal ? "center" : "left";
        ctx.font = this.inner_text_font;

        var render_text = !low_quality;

        var out_slot = this.connecting_output;
        ctx.lineWidth = 1;

        var max_y = 0;
        var slot_pos = new Float32Array(2); //to reuse

        //render inputs and outputs
        if (!node.flags.collapsed) {
            //input connection slots
            if (node.inputs) {
                for (var i = 0; i < node.inputs.length; i++) {
                    var slot = node.inputs[i];

                    ctx.globalAlpha = editor_alpha;
                    //change opacity of incompatible slots when dragging a connection
                    if ( this.connecting_node && !LiteGraph.isValidConnection( slot.type , out_slot.type) ) {
                        ctx.globalAlpha = 0.4 * editor_alpha;
                    }

                    ctx.fillStyle =
                        slot.link != null
                            ? slot.color_on ||
                              this.default_connection_color.input_on
                            : slot.color_off ||
                              this.default_connection_color.input_off;

                    var pos = node.getConnectionPos(true, i, slot_pos);
                    pos[0] -= node.pos[0];
                    pos[1] -= node.pos[1];
                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
                    }

                    ctx.beginPath();

                    if (
                        slot.type === LiteGraph.EVENT ||
                        slot.shape === LiteGraph.BOX_SHAPE
                    ) {
                        if (horizontal) {
                            ctx.rect(
                                pos[0] - 5 + 0.5,
                                pos[1] - 8 + 0.5,
                                10,
                                14
                            );
                        } else {
                            ctx.rect(
                                pos[0] - 6 + 0.5,
                                pos[1] - 5 + 0.5,
                                14,
                                10
                            );
                        }
                    } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
						if(low_quality)
	                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 ); //faster
						else
	                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
                    }
                    ctx.fill();

                    //render name
                    if (render_text) {
                        var text = slot.label != null ? slot.label : slot.name;
                        if (text) {
                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                            if (horizontal || slot.dir == LiteGraph.UP) {
                                ctx.fillText(text, pos[0], pos[1] - 10);
                            } else {
                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);
                            }
                        }
                    }
                }
            }

            //output connection slots
            if (this.connecting_node) {
                ctx.globalAlpha = 0.4 * editor_alpha;
            }

            ctx.textAlign = horizontal ? "center" : "right";
            ctx.strokeStyle = "black";
            if (node.outputs) {
                for (var i = 0; i < node.outputs.length; i++) {
                    var slot = node.outputs[i];

                    var pos = node.getConnectionPos(false, i, slot_pos);
                    pos[0] -= node.pos[0];
                    pos[1] -= node.pos[1];
                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
                    }

                    ctx.fillStyle =
                        slot.links && slot.links.length
                            ? slot.color_on ||
                              this.default_connection_color.output_on
                            : slot.color_off ||
                              this.default_connection_color.output_off;
                    ctx.beginPath();
                    //ctx.rect( node.size[0] - 14,i*14,10,10);

                    if (
                        slot.type === LiteGraph.EVENT ||
                        slot.shape === LiteGraph.BOX_SHAPE
                    ) {
                        if (horizontal) {
                            ctx.rect(
                                pos[0] - 5 + 0.5,
                                pos[1] - 8 + 0.5,
                                10,
                                14
                            );
                        } else {
                            ctx.rect(
                                pos[0] - 6 + 0.5,
                                pos[1] - 5 + 0.5,
                                14,
                                10
                            );
                        }
                    } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);
                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);
                        ctx.closePath();
                    } else {
						if(low_quality)
	                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 );
						else
	                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
                    }

                    //trigger
                    //if(slot.node_id != null && slot.slot == -1)
                    //	ctx.fillStyle = "#F85";

                    //if(slot.links != null && slot.links.length)
                    ctx.fill();
					if(!low_quality)
	                    ctx.stroke();

                    //render output name
                    if (render_text) {
                        var text = slot.label != null ? slot.label : slot.name;
                        if (text) {
                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
                            if (horizontal || slot.dir == LiteGraph.DOWN) {
                                ctx.fillText(text, pos[0], pos[1] - 8);
                            } else {
                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);
                            }
                        }
                    }
                }
            }

            ctx.textAlign = "left";
            ctx.globalAlpha = 1;

            if (node.widgets) {
				var widgets_y = max_y;
                if (horizontal || node.widgets_up) {
                    widgets_y = 2;
                }
				if( node.widgets_start_y != null )
                    widgets_y = node.widgets_start_y;
                this.drawNodeWidgets(
                    node,
                    widgets_y,
                    ctx,
                    this.node_widget && this.node_widget[0] == node
                        ? this.node_widget[1]
                        : null
                );
            }
        } else if (this.render_collapsed_slots) {
            //if collapsed
            var input_slot = null;
            var output_slot = null;

            //get first connected slot to render
            if (node.inputs) {
                for (var i = 0; i < node.inputs.length; i++) {
                    var slot = node.inputs[i];
                    if (slot.link == null) {
                        continue;
                    }
                    input_slot = slot;
                    break;
                }
            }
            if (node.outputs) {
                for (var i = 0; i < node.outputs.length; i++) {
                    var slot = node.outputs[i];
                    if (!slot.links || !slot.links.length) {
                        continue;
                    }
                    output_slot = slot;
                }
            }

            if (input_slot) {
                var x = 0;
                var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; //center
                if (horizontal) {
                    x = node._collapsed_width * 0.5;
                    y = -LiteGraph.NODE_TITLE_HEIGHT;
                }
                ctx.fillStyle = "#686";
                ctx.beginPath();
                if (
                    slot.type === LiteGraph.EVENT ||
                    slot.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);
                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(x + 8, y);
                    ctx.lineTo(x + -4, y - 4);
                    ctx.lineTo(x + -4, y + 4);
                    ctx.closePath();
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
            }

            if (output_slot) {
                var x = node._collapsed_width;
                var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; //center
                if (horizontal) {
                    x = node._collapsed_width * 0.5;
                    y = 0;
                }
                ctx.fillStyle = "#686";
                ctx.strokeStyle = "black";
                ctx.beginPath();
                if (
                    slot.type === LiteGraph.EVENT ||
                    slot.shape === LiteGraph.BOX_SHAPE
                ) {
                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);
                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
                    ctx.moveTo(x + 6, y);
                    ctx.lineTo(x - 6, y - 4);
                    ctx.lineTo(x - 6, y + 4);
                    ctx.closePath();
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                }
                ctx.fill();
                //ctx.stroke();
            }
        }

        if (node.clip_area) {
            ctx.restore();
        }

        ctx.globalAlpha = 1.0;
    };

	//used by this.over_link_center
	LGraphCanvas.prototype.drawLinkTooltip = function( ctx, link )
	{
		var pos = link._pos;
		ctx.fillStyle = "black";
		ctx.beginPath();
		ctx.arc( pos[0], pos[1], 3, 0, Math.PI * 2 );
		ctx.fill();

		if(link.data == null)
			return;

		if(this.onDrawLinkTooltip)
			if( this.onDrawLinkTooltip(ctx,link,this) == true )
				return;

		var data = link.data;
		var text = null;

		if( data.constructor === Number )
			text = data.toFixed(2);
		else if( data.constructor === String )
			text = "\"" + data + "\"";
		else if( data.constructor === Boolean )
			text = String(data);
		else if (data.toToolTip)
			text = data.toToolTip();
		else
			text = "[" + data.constructor.name + "]";

		if(text == null)
			return;
		text = text.substr(0,30); //avoid weird

		ctx.font = "14px Courier New";
		var info = ctx.measureText(text);
		var w = info.width + 20;
		var h = 24;
		ctx.shadowColor = "black";
		ctx.shadowOffsetX = 2;
		ctx.shadowOffsetY = 2;
		ctx.shadowBlur = 3;
		ctx.fillStyle = "#454";
		ctx.beginPath();
		ctx.roundRect( pos[0] - w*0.5, pos[1] - 15 - h, w, h,3, 3);
		ctx.moveTo( pos[0] - 10, pos[1] - 15 );
		ctx.lineTo( pos[0] + 10, pos[1] - 15 );
		ctx.lineTo( pos[0], pos[1] - 5 );
		ctx.fill();
        ctx.shadowColor = "transparent";
		ctx.textAlign = "center";
		ctx.fillStyle = "#CEC";
		ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);
	}

    /**
     * draws the shape of the given node in the canvas
     * @method drawNodeShape
     **/
    var tmp_area = new Float32Array(4);

    LGraphCanvas.prototype.drawNodeShape = function(
        node,
        ctx,
        size,
        fgcolor,
        bgcolor,
        selected,
        mouse_over
    ) {
        //bg rect
        ctx.strokeStyle = fgcolor;
        ctx.fillStyle = bgcolor;

        var title_height = LiteGraph.NODE_TITLE_HEIGHT;
        var low_quality = this.ds.scale < 0.5;

        //render node area depending on shape
        var shape =
            node._shape || node.constructor.shape || LiteGraph.ROUND_SHAPE;

        var title_mode = node.constructor.title_mode;

        var render_title = true;
        if (title_mode == LiteGraph.TRANSPARENT_TITLE) {
            render_title = false;
        } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {
            render_title = true;
        }

        var area = tmp_area;
        area[0] = 0; //x
        area[1] = render_title ? -title_height : 0; //y
        area[2] = size[0] + 1; //w
        area[3] = render_title ? size[1] + title_height : size[1]; //h

        var old_alpha = ctx.globalAlpha;

        //full node shape
        //if(node.flags.collapsed)
        {
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE || low_quality) {
                ctx.fillRect(area[0], area[1], area[2], area[3]);
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                shape == LiteGraph.CARD_SHAPE
            ) {
                ctx.roundRect(
                    area[0],
                    area[1],
                    area[2],
                    area[3],
                    this.round_radius,
                    shape == LiteGraph.CARD_SHAPE ? 0 : this.round_radius
                );
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5,
                    0,
                    Math.PI * 2
                );
            }
            ctx.fill();

			//separator
			if(!node.flags.collapsed)
			{
				ctx.shadowColor = "transparent";
				ctx.fillStyle = "rgba(0,0,0,0.2)";
				ctx.fillRect(0, -1, area[2], 2);
			}
        }
        ctx.shadowColor = "transparent";

        if (node.onDrawBackground) {
            node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse );
        }

        //title bg (remember, it is rendered ABOVE the node)
        if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {
            //title bar
            if (node.onDrawTitleBar) {
                node.onDrawTitleBar( ctx, title_height, size, this.ds.scale, fgcolor );
            } else if (
                title_mode != LiteGraph.TRANSPARENT_TITLE &&
                (node.constructor.title_color || this.render_title_colored)
            ) {
                var title_color = node.constructor.title_color || fgcolor;

                if (node.flags.collapsed) {
                    ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
                }

                //* gradient test
                if (this.use_gradients) {
                    var grad = LGraphCanvas.gradients[title_color];
                    if (!grad) {
                        grad = LGraphCanvas.gradients[ title_color ] = ctx.createLinearGradient(0, 0, 400, 0);
                        grad.addColorStop(0, title_color);
                        grad.addColorStop(1, "#000");
                    }
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = title_color;
                }

                //ctx.globalAlpha = 0.5 * old_alpha;
                ctx.beginPath();
                if (shape == LiteGraph.BOX_SHAPE || low_quality) {
                    ctx.rect(0, -title_height, size[0] + 1, title_height);
                } else if (  shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE ) {
                    ctx.roundRect(
                        0,
                        -title_height,
                        size[0] + 1,
                        title_height,
                        this.round_radius,
                        node.flags.collapsed ? this.round_radius : 0
                    );
                }
                ctx.fill();
                ctx.shadowColor = "transparent";
            }

            //title box
            var box_size = 10;
            if (node.onDrawTitleBox) {
                node.onDrawTitleBox(ctx, title_height, size, this.ds.scale);
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                shape == LiteGraph.CIRCLE_SHAPE ||
                shape == LiteGraph.CARD_SHAPE
            ) {
                if (low_quality) {
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(
                        title_height * 0.5,
                        title_height * -0.5,
                        box_size * 0.5 + 1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;
				if(low_quality)
					ctx.fillRect( title_height * 0.5 - box_size *0.5, title_height * -0.5 - box_size *0.5, box_size , box_size  );
				else
				{
					ctx.beginPath();
					ctx.arc(
						title_height * 0.5,
						title_height * -0.5,
						box_size * 0.5,
						0,
						Math.PI * 2
					);
					ctx.fill();
				}
            } else {
                if (low_quality) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(
                        (title_height - box_size) * 0.5 - 1,
                        (title_height + box_size) * -0.5 - 1,
                        box_size + 2,
                        box_size + 2
                    );
                }
                ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;
                ctx.fillRect(
                    (title_height - box_size) * 0.5,
                    (title_height + box_size) * -0.5,
                    box_size,
                    box_size
                );
            }
            ctx.globalAlpha = old_alpha;

            //title text
            if (node.onDrawTitleText) {
                node.onDrawTitleText(
                    ctx,
                    title_height,
                    size,
                    this.ds.scale,
                    this.title_text_font,
                    selected
                );
            }
            if (!low_quality) {
                ctx.font = this.title_text_font;
                var title = String(node.getTitle());
                if (title) {
                    if (selected) {
                        ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;
                    } else {
                        ctx.fillStyle =
                            node.constructor.title_text_color ||
                            this.node_title_color;
                    }
                    if (node.flags.collapsed) {
                        ctx.textAlign = "left";
                        var measure = ctx.measureText(title);
                        ctx.fillText(
                            title.substr(0,20), //avoid urls too long
                            title_height,// + measure.width * 0.5,
                            LiteGraph.NODE_TITLE_TEXT_Y - title_height
                        );
                        ctx.textAlign = "left";
                    } else {
                        ctx.textAlign = "left";
                        ctx.fillText(
                            title,
                            title_height,
                            LiteGraph.NODE_TITLE_TEXT_Y - title_height
                        );
                    }
                }
            }

			//subgraph box
			if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {
				var w = LiteGraph.NODE_TITLE_HEIGHT;
				var x = node.size[0] - w;
				var over = LiteGraph.isInsideRectangle( this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x+2, -w+2, w-4, w-4 );
				ctx.fillStyle = over ? "#888" : "#555";
				if( shape == LiteGraph.BOX_SHAPE || low_quality)
					ctx.fillRect(x+2, -w+2, w-4, w-4);
				else
				{
					ctx.beginPath();
					ctx.roundRect(x+2, -w+2, w-4, w-4,4);
					ctx.fill();
				}
				ctx.fillStyle = "#333";
				ctx.beginPath();
				ctx.moveTo(x + w * 0.2, -w * 0.6);
				ctx.lineTo(x + w * 0.8, -w * 0.6);
				ctx.lineTo(x + w * 0.5, -w * 0.3);
				ctx.fill();
			}

			//custom title render
            if (node.onDrawTitle) {
                node.onDrawTitle(ctx);
            }
        }

        //render selection marker
        if (selected) {
            if (node.onBounding) {
                node.onBounding(area);
            }

            if (title_mode == LiteGraph.TRANSPARENT_TITLE) {
                area[1] -= title_height;
                area[3] += title_height;
            }
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            if (shape == LiteGraph.BOX_SHAPE) {
                ctx.rect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3]
                );
            } else if (
                shape == LiteGraph.ROUND_SHAPE ||
                (shape == LiteGraph.CARD_SHAPE && node.flags.collapsed)
            ) {
                ctx.roundRect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                    this.round_radius * 2
                );
            } else if (shape == LiteGraph.CARD_SHAPE) {
                ctx.roundRect(
                    -6 + area[0],
                    -6 + area[1],
                    12 + area[2],
                    12 + area[3],
                    this.round_radius * 2,
                    2
                );
            } else if (shape == LiteGraph.CIRCLE_SHAPE) {
                ctx.arc(
                    size[0] * 0.5,
                    size[1] * 0.5,
                    size[0] * 0.5 + 6,
                    0,
                    Math.PI * 2
                );
            }
            ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;
            ctx.stroke();
            ctx.strokeStyle = fgcolor;
            ctx.globalAlpha = 1;
        }
    };

    var margin_area = new Float32Array(4);
    var link_bounding = new Float32Array(4);
    var tempA = new Float32Array(2);
    var tempB = new Float32Array(2);

    /**
     * draws every connection visible in the canvas
     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time
     * @method drawConnections
     **/
    LGraphCanvas.prototype.drawConnections = function(ctx) {
        var now = LiteGraph.getTime();
        var visible_area = this.visible_area;
        margin_area[0] = visible_area[0] - 20;
        margin_area[1] = visible_area[1] - 20;
        margin_area[2] = visible_area[2] + 40;
        margin_area[3] = visible_area[3] + 40;

        //draw connections
        ctx.lineWidth = this.connections_width;

        ctx.fillStyle = "#AAA";
        ctx.strokeStyle = "#AAA";
        ctx.globalAlpha = this.editor_alpha;
        //for every node
        var nodes = this.graph._nodes;
        for (var n = 0, l = nodes.length; n < l; ++n) {
            var node = nodes[n];
            //for every input (we render just inputs because it is easier as every slot can only have one input)
            if (!node.inputs || !node.inputs.length) {
                continue;
            }

            for (var i = 0; i < node.inputs.length; ++i) {
                var input = node.inputs[i];
                if (!input || input.link == null) {
                    continue;
                }
                var link_id = input.link;
                var link = this.graph.links[link_id];
                if (!link) {
                    continue;
                }

                //find link info
                var start_node = this.graph.getNodeById(link.origin_id);
                if (start_node == null) {
                    continue;
                }
                var start_node_slot = link.origin_slot;
                var start_node_slotpos = null;
                if (start_node_slot == -1) {
                    start_node_slotpos = [
                        start_node.pos[0] + 10,
                        start_node.pos[1] + 10
                    ];
                } else {
                    start_node_slotpos = start_node.getConnectionPos(
                        false,
                        start_node_slot,
                        tempA
                    );
                }
                var end_node_slotpos = node.getConnectionPos(true, i, tempB);

                //compute link bounding
                link_bounding[0] = start_node_slotpos[0];
                link_bounding[1] = start_node_slotpos[1];
                link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];
                link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];
                if (link_bounding[2] < 0) {
                    link_bounding[0] += link_bounding[2];
                    link_bounding[2] = Math.abs(link_bounding[2]);
                }
                if (link_bounding[3] < 0) {
                    link_bounding[1] += link_bounding[3];
                    link_bounding[3] = Math.abs(link_bounding[3]);
                }

                //skip links outside of the visible area of the canvas
                if (!overlapBounding(link_bounding, margin_area)) {
                    continue;
                }

                var start_slot = start_node.outputs[start_node_slot];
                var end_slot = node.inputs[i];
                if (!start_slot || !end_slot) {
                    continue;
                }
                var start_dir =
                    start_slot.dir ||
                    (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);
                var end_dir =
                    end_slot.dir ||
                    (node.horizontal ? LiteGraph.UP : LiteGraph.LEFT);

                this.renderLink(
                    ctx,
                    start_node_slotpos,
                    end_node_slotpos,
                    link,
                    false,
                    0,
                    null,
                    start_dir,
                    end_dir
                );

                //event triggered rendered on top
                if (link && link._last_time && now - link._last_time < 1000) {
                    var f = 2.0 - (now - link._last_time) * 0.002;
                    var tmp = ctx.globalAlpha;
                    ctx.globalAlpha = tmp * f;
                    this.renderLink(
                        ctx,
                        start_node_slotpos,
                        end_node_slotpos,
                        link,
                        true,
                        f,
                        "white",
                        start_dir,
                        end_dir
                    );
                    ctx.globalAlpha = tmp;
                }
            }
        }
        ctx.globalAlpha = 1;
    };

    /**
     * draws a link between two points
     * @method renderLink
     * @param {vec2} a start pos
     * @param {vec2} b end pos
     * @param {Object} link the link object with all the link info
     * @param {boolean} skip_border ignore the shadow of the link
     * @param {boolean} flow show flow animation (for events)
     * @param {string} color the color for the link
     * @param {number} start_dir the direction enum
     * @param {number} end_dir the direction enum
     * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)
     **/
    LGraphCanvas.prototype.renderLink = function(
        ctx,
        a,
        b,
        link,
        skip_border,
        flow,
        color,
        start_dir,
        end_dir,
        num_sublines
    ) {
        if (link) {
            this.visible_links.push(link);
        }

        //choose color
        if (!color && link) {
            color = link.color || LGraphCanvas.link_type_colors[link.type];
        }
        if (!color) {
            color = this.default_link_color;
        }
        if (link != null && this.highlighted_links[link.id]) {
            color = "#FFF";
        }

        start_dir = start_dir || LiteGraph.RIGHT;
        end_dir = end_dir || LiteGraph.LEFT;

        var dist = distance(a, b);

        if (this.render_connections_border && this.ds.scale > 0.6) {
            ctx.lineWidth = this.connections_width + 4;
        }
        ctx.lineJoin = "round";
        num_sublines = num_sublines || 1;
        if (num_sublines > 1) {
            ctx.lineWidth = 0.5;
        }

        //begin line shape
        ctx.beginPath();
        for (var i = 0; i < num_sublines; i += 1) {
            var offsety = (i - (num_sublines - 1) * 0.5) * 5;

            if (this.links_render_mode == LiteGraph.SPLINE_LINK) {
                ctx.moveTo(a[0], a[1] + offsety);
                var start_offset_x = 0;
                var start_offset_y = 0;
                var end_offset_x = 0;
                var end_offset_y = 0;
                switch (start_dir) {
                    case LiteGraph.LEFT:
                        start_offset_x = dist * -0.25;
                        break;
                    case LiteGraph.RIGHT:
                        start_offset_x = dist * 0.25;
                        break;
                    case LiteGraph.UP:
                        start_offset_y = dist * -0.25;
                        break;
                    case LiteGraph.DOWN:
                        start_offset_y = dist * 0.25;
                        break;
                }
                switch (end_dir) {
                    case LiteGraph.LEFT:
                        end_offset_x = dist * -0.25;
                        break;
                    case LiteGraph.RIGHT:
                        end_offset_x = dist * 0.25;
                        break;
                    case LiteGraph.UP:
                        end_offset_y = dist * -0.25;
                        break;
                    case LiteGraph.DOWN:
                        end_offset_y = dist * 0.25;
                        break;
                }
                ctx.bezierCurveTo(
                    a[0] + start_offset_x,
                    a[1] + start_offset_y + offsety,
                    b[0] + end_offset_x,
                    b[1] + end_offset_y + offsety,
                    b[0],
                    b[1] + offsety
                );
            } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {
                ctx.moveTo(a[0], a[1] + offsety);
                var start_offset_x = 0;
                var start_offset_y = 0;
                var end_offset_x = 0;
                var end_offset_y = 0;
                switch (start_dir) {
                    case LiteGraph.LEFT:
                        start_offset_x = -1;
                        break;
                    case LiteGraph.RIGHT:
                        start_offset_x = 1;
                        break;
                    case LiteGraph.UP:
                        start_offset_y = -1;
                        break;
                    case LiteGraph.DOWN:
                        start_offset_y = 1;
                        break;
                }
                switch (end_dir) {
                    case LiteGraph.LEFT:
                        end_offset_x = -1;
                        break;
                    case LiteGraph.RIGHT:
                        end_offset_x = 1;
                        break;
                    case LiteGraph.UP:
                        end_offset_y = -1;
                        break;
                    case LiteGraph.DOWN:
                        end_offset_y = 1;
                        break;
                }
                var l = 15;
                ctx.lineTo(
                    a[0] + start_offset_x * l,
                    a[1] + start_offset_y * l + offsety
                );
                ctx.lineTo(
                    b[0] + end_offset_x * l,
                    b[1] + end_offset_y * l + offsety
                );
                ctx.lineTo(b[0], b[1] + offsety);
            } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {
                ctx.moveTo(a[0], a[1]);
                var start_x = a[0];
                var start_y = a[1];
                var end_x = b[0];
                var end_y = b[1];
                if (start_dir == LiteGraph.RIGHT) {
                    start_x += 10;
                } else {
                    start_y += 10;
                }
                if (end_dir == LiteGraph.LEFT) {
                    end_x -= 10;
                } else {
                    end_y -= 10;
                }
                ctx.lineTo(start_x, start_y);
                ctx.lineTo((start_x + end_x) * 0.5, start_y);
                ctx.lineTo((start_x + end_x) * 0.5, end_y);
                ctx.lineTo(end_x, end_y);
                ctx.lineTo(b[0], b[1]);
            } else {
                return;
            } //unknown
        }

        //rendering the outline of the connection can be a little bit slow
        if (
            this.render_connections_border &&
            this.ds.scale > 0.6 &&
            !skip_border
        ) {
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.stroke();
        }

        ctx.lineWidth = this.connections_width;
        ctx.fillStyle = ctx.strokeStyle = color;
        ctx.stroke();
        //end line shape

        var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);
        if (link && link._pos) {
            link._pos[0] = pos[0];
            link._pos[1] = pos[1];
        }

        //render arrow in the middle
        if (
            this.ds.scale >= 0.6 &&
            this.highquality_render &&
            end_dir != LiteGraph.CENTER
        ) {
            //render arrow
            if (this.render_connection_arrows) {
                //compute two points in the connection
                var posA = this.computeConnectionPoint(
                    a,
                    b,
                    0.25,
                    start_dir,
                    end_dir
                );
                var posB = this.computeConnectionPoint(
                    a,
                    b,
                    0.26,
                    start_dir,
                    end_dir
                );
                var posC = this.computeConnectionPoint(
                    a,
                    b,
                    0.75,
                    start_dir,
                    end_dir
                );
                var posD = this.computeConnectionPoint(
                    a,
                    b,
                    0.76,
                    start_dir,
                    end_dir
                );

                //compute the angle between them so the arrow points in the right direction
                var angleA = 0;
                var angleB = 0;
                if (this.render_curved_connections) {
                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);
                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);
                } else {
                    angleB = angleA = b[1] > a[1] ? 0 : Math.PI;
                }

                //render arrow
                ctx.save();
                ctx.translate(posA[0], posA[1]);
                ctx.rotate(angleA);
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(0, +7);
                ctx.lineTo(+5, -3);
                ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(posC[0], posC[1]);
                ctx.rotate(angleB);
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(0, +7);
                ctx.lineTo(+5, -3);
                ctx.fill();
                ctx.restore();
            }

            //circle
            ctx.beginPath();
            ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);
            ctx.fill();
        }

        //render flowing points
        if (flow) {
            ctx.fillStyle = color;
            for (var i = 0; i < 5; ++i) {
                var f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1;
                var pos = this.computeConnectionPoint(
                    a,
                    b,
                    f,
                    start_dir,
                    end_dir
                );
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    };

    //returns the link center point based on curvature
    LGraphCanvas.prototype.computeConnectionPoint = function(
        a,
        b,
        t,
        start_dir,
        end_dir
    ) {
        start_dir = start_dir || LiteGraph.RIGHT;
        end_dir = end_dir || LiteGraph.LEFT;

        var dist = distance(a, b);
        var p0 = a;
        var p1 = [a[0], a[1]];
        var p2 = [b[0], b[1]];
        var p3 = b;

        switch (start_dir) {
            case LiteGraph.LEFT:
                p1[0] += dist * -0.25;
                break;
            case LiteGraph.RIGHT:
                p1[0] += dist * 0.25;
                break;
            case LiteGraph.UP:
                p1[1] += dist * -0.25;
                break;
            case LiteGraph.DOWN:
                p1[1] += dist * 0.25;
                break;
        }
        switch (end_dir) {
            case LiteGraph.LEFT:
                p2[0] += dist * -0.25;
                break;
            case LiteGraph.RIGHT:
                p2[0] += dist * 0.25;
                break;
            case LiteGraph.UP:
                p2[1] += dist * -0.25;
                break;
            case LiteGraph.DOWN:
                p2[1] += dist * 0.25;
                break;
        }

        var c1 = (1 - t) * (1 - t) * (1 - t);
        var c2 = 3 * ((1 - t) * (1 - t)) * t;
        var c3 = 3 * (1 - t) * (t * t);
        var c4 = t * t * t;

        var x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];
        var y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];
        return [x, y];
    };

    LGraphCanvas.prototype.drawExecutionOrder = function(ctx) {
        ctx.shadowColor = "transparent";
        ctx.globalAlpha = 0.25;

        ctx.textAlign = "center";
        ctx.strokeStyle = "white";
        ctx.globalAlpha = 0.75;

        var visible_nodes = this.visible_nodes;
        for (var i = 0; i < visible_nodes.length; ++i) {
            var node = visible_nodes[i];
            ctx.fillStyle = "black";
            ctx.fillRect(
                node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
                node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
                LiteGraph.NODE_TITLE_HEIGHT,
                LiteGraph.NODE_TITLE_HEIGHT
            );
            if (node.order == 0) {
                ctx.strokeRect(
                    node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
                    node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
                    LiteGraph.NODE_TITLE_HEIGHT,
                    LiteGraph.NODE_TITLE_HEIGHT
                );
            }
            ctx.fillStyle = "#FFF";
            ctx.fillText(
                node.order,
                node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
                node.pos[1] - 6
            );
        }
        ctx.globalAlpha = 1;
    };

    /**
     * draws the widgets stored inside a node
     * @method drawNodeWidgets
     **/
    LGraphCanvas.prototype.drawNodeWidgets = function(
        node,
        posY,
        ctx,
        active_widget
    ) {
        if (!node.widgets || !node.widgets.length) {
            return 0;
        }
        var width = node.size[0];
        var widgets = node.widgets;
        posY += 2;
        var H = LiteGraph.NODE_WIDGET_HEIGHT;
        var show_text = this.ds.scale > 0.5;
        ctx.save();
        ctx.globalAlpha = this.editor_alpha;
        var outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
        var background_color = LiteGraph.WIDGET_BGCOLOR;
        var text_color = LiteGraph.WIDGET_TEXT_COLOR;
		var secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
        var margin = 15;

        for (var i = 0; i < widgets.length; ++i) {
            var w = widgets[i];
            var y = posY;
            if (w.y) {
                y = w.y;
            }
            w.last_y = y;
            ctx.strokeStyle = outline_color;
            ctx.fillStyle = "#222";
            ctx.textAlign = "left";
			//ctx.lineWidth = 2;
			if(w.disabled)
				ctx.globalAlpha *= 0.5;
			var widget_width = w.width || width;

            switch (w.type) {
                case "button":
                    if (w.clicked) {
                        ctx.fillStyle = "#AAA";
                        w.clicked = false;
                        this.dirty_canvas = true;
                    }
                    ctx.fillRect(margin, y, widget_width - margin * 2, H);
					if(show_text && !w.disabled)
	                    ctx.strokeRect( margin, y, widget_width - margin * 2, H );
                    if (show_text) {
                        ctx.textAlign = "center";
                        ctx.fillStyle = text_color;
                        ctx.fillText(w.name, widget_width * 0.5, y + H * 0.7);
                    }
                    break;
                case "toggle":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if (show_text)
	                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);
					else
	                    ctx.rect(margin, posY, widget_width - margin * 2, H );
                    ctx.fill();
					if(show_text && !w.disabled)
	                    ctx.stroke();
                    ctx.fillStyle = w.value ? "#89A" : "#333";
                    ctx.beginPath();
                    ctx.arc( widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2 );
                    ctx.fill();
                    if (show_text) {
                        ctx.fillStyle = secondary_text_color;
                        if (w.name != null) {
                            ctx.fillText(w.name, margin * 2, y + H * 0.7);
                        }
                        ctx.fillStyle = w.value ? text_color : secondary_text_color;
                        ctx.textAlign = "right";
                        ctx.fillText(
                            w.value
                                ? w.options.on || "true"
                                : w.options.off || "false",
                            widget_width - 40,
                            y + H * 0.7
                        );
                    }
                    break;
                case "slider":
                    ctx.fillStyle = background_color;
                    ctx.fillRect(margin, y, widget_width - margin * 2, H);
                    var range = w.options.max - w.options.min;
                    var nvalue = (w.value - w.options.min) / range;
                    ctx.fillStyle = active_widget == w ? "#89A" : "#678";
                    ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);
					if(show_text && !w.disabled)
	                    ctx.strokeRect(margin, y, widget_width - margin * 2, H);
                    if (w.marker) {
                        var marker_nvalue = (w.marker - w.options.min) / range;
                        ctx.fillStyle = "#AA9";
                        ctx.fillRect( margin + marker_nvalue * (widget_width - margin * 2), y, 2, H );
                    }
                    if (show_text) {
                        ctx.textAlign = "center";
                        ctx.fillStyle = text_color;
                        ctx.fillText(
                            w.name + "  " + Number(w.value).toFixed(3),
                            widget_width * 0.5,
                            y + H * 0.7
                        );
                    }
                    break;
                case "number":
                case "combo":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
					if(show_text)
	                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);
					else
	                    ctx.rect(margin, posY, widget_width - margin * 2, H );
                    ctx.fill();
                    if (show_text) {
						if(!w.disabled)
		                    ctx.stroke();
                        ctx.fillStyle = text_color;
						if(!w.disabled)
						{
							ctx.beginPath();
							ctx.moveTo(margin + 16, posY + 5);
							ctx.lineTo(margin + 6, posY + H * 0.5);
							ctx.lineTo(margin + 16, posY + H - 5);
							ctx.fill();
							ctx.beginPath();
							ctx.moveTo(widget_width - margin - 16, posY + 5);
							ctx.lineTo(widget_width - margin - 6, posY + H * 0.5);
							ctx.lineTo(widget_width - margin - 16, posY + H - 5);
							ctx.fill();
						}
                        ctx.fillStyle = secondary_text_color;
                        ctx.fillText(w.name, margin * 2 + 5, y + H * 0.7);
                        ctx.fillStyle = text_color;
                        ctx.textAlign = "right";
                        if (w.type == "number") {
                            ctx.fillText(
                                Number(w.value).toFixed(
                                    w.options.precision !== undefined
                                        ? w.options.precision
                                        : 3
                                ),
                                widget_width - margin * 2 - 20,
                                y + H * 0.7
                            );
                        } else {
							var v = w.value;
							if( w.options.values )
							{
								var values = w.options.values;
								if( values.constructor === Function )
									values = values();
								if(values && values.constructor !== Array)
									v = values[ w.value ];
							}
                            ctx.fillText(
                                v,
                                widget_width - margin * 2 - 20,
                                y + H * 0.7
                            );
                        }
                    }
                    break;
                case "string":
                case "text":
                    ctx.textAlign = "left";
                    ctx.strokeStyle = outline_color;
                    ctx.fillStyle = background_color;
                    ctx.beginPath();
                    if (show_text)
	                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);
					else
	                    ctx.rect( margin, posY, widget_width - margin * 2, H );
                    ctx.fill();
	                if (show_text) {
						if(!w.disabled)
							ctx.stroke();
    					ctx.save();
						ctx.beginPath();
						ctx.rect(margin, posY, widget_width - margin * 2, H);
						ctx.clip();

	                    //ctx.stroke();
                        ctx.fillStyle = secondary_text_color;
                        if (w.name != null) {
                            ctx.fillText(w.name, margin * 2, y + H * 0.7);
                        }
                        ctx.fillStyle = text_color;
                        ctx.textAlign = "right";
                        ctx.fillText(String(w.value).substr(0,30), widget_width - margin * 2, y + H * 0.7); //30 chars max
						ctx.restore();
                    }
                    break;
                default:
                    if (w.draw) {
                        w.draw(ctx, node, widget_width, y, H);
                    }
                    break;
            }
            posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;
			ctx.globalAlpha = this.editor_alpha;

        }
        ctx.restore();
		ctx.textAlign = "left";
    };

    /**
     * process an event on widgets
     * @method processNodeWidgets
     **/
    LGraphCanvas.prototype.processNodeWidgets = function(
        node,
        pos,
        event,
        active_widget
    ) {
        if (!node.widgets || !node.widgets.length) {
            return null;
        }

        var x = pos[0] - node.pos[0];
        var y = pos[1] - node.pos[1];
        var width = node.size[0];
        var that = this;
        var ref_window = this.getCanvasWindow();

        for (var i = 0; i < node.widgets.length; ++i) {
            var w = node.widgets[i];
			if(!w || w.disabled)
				continue;
			var widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;
			var widget_width = w.width || width;
			//outside
			if ( w != active_widget && 
				(x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === undefined) ) 
				continue;

			var old_value = w.value;

            //if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y < w.last_y + widget_height) ) {
			//inside widget
			switch (w.type) {
				case "button":
					if (event.type === "mousedown") {
                        if (w.callback) {
                            setTimeout(function() {
                                w.callback(w, that, node, pos, event);
                            }, 20);
                        }
                        w.clicked = true;
                        this.dirty_canvas = true;
                    }
					break;
				case "slider":
					var range = w.options.max - w.options.min;
					var nvalue = Math.clamp((x - 15) / (widget_width - 30), 0, 1);
					w.value = w.options.min + (w.options.max - w.options.min) * nvalue;
					if (w.callback) {
						setTimeout(function() {
							inner_value_change(w, w.value);
						}, 20);
					}
					this.dirty_canvas = true;
					break;
				case "number":
				case "combo":
					var old_value = w.value;
					if (event.type == "mousemove" && w.type == "number") {
						w.value += event.deltaX * 0.1 * (w.options.step || 1);
						if ( w.options.min != null && w.value < w.options.min ) {
							w.value = w.options.min;
						}
						if ( w.options.max != null && w.value > w.options.max ) {
							w.value = w.options.max;
						}
					} else if (event.type == "mousedown") {
						var values = w.options.values;
						if (values && values.constructor === Function) {
							values = w.options.values(w, node);
						}
						var values_list = null;
						
						if( w.type != "number")
							values_list = values.constructor === Array ? values : Object.keys(values);

						var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
						if (w.type == "number") {
							w.value += delta * 0.1 * (w.options.step || 1);
							if ( w.options.min != null && w.value < w.options.min ) {
								w.value = w.options.min;
							}
							if ( w.options.max != null && w.value > w.options.max ) {
								w.value = w.options.max;
							}
						} else if (delta) { //clicked in arrow, used for combos 
							var index = -1;
							this.last_mouseclick = 0; //avoids dobl click event
							if(values.constructor === Object)
								index = values_list.indexOf( String( w.value ) ) + delta;
							else
								index = values_list.indexOf( w.value ) + delta;
							if (index >= values_list.length) {
								index = values_list.length - 1;
							}
							if (index < 0) {
								index = 0;
							}
							if( values.constructor === Array )
								w.value = values[index];
							else
								w.value = index;
						} else { //combo clicked 
							var text_values = values != values_list ? Object.values(values) : values;
							var menu = new LiteGraph.ContextMenu(text_values, {
									scale: Math.max(1, this.ds.scale),
									event: event,
									className: "dark",
									callback: inner_clicked.bind(w)
								},
								ref_window);
							function inner_clicked(v, option, event) {
								if(values != values_list)
									v = text_values.indexOf(v);
								this.value = v;
								inner_value_change(this, v);
								that.dirty_canvas = true;
								return false;
							}
						}
					} //end mousedown
					else if(event.type == "mouseup" && w.type == "number")
					{
						var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
						if (event.click_time < 200 && delta == 0) {
							this.prompt("Value",w.value,function(v) {
									this.value = Number(v);
									inner_value_change(this, this.value);
								}.bind(w),
								event);
						}
					}

					if( old_value != w.value )
						setTimeout(
							function() {
								inner_value_change(this, this.value);
							}.bind(w),
							20
						);
					this.dirty_canvas = true;
					break;
				case "toggle":
					if (event.type == "mousedown") {
						w.value = !w.value;
						setTimeout(function() {
							inner_value_change(w, w.value);
						}, 20);
					}
					break;
				case "string":
				case "text":
					if (event.type == "mousedown") {
						this.prompt("Value",w.value,function(v) {
								this.value = v;
								inner_value_change(this, v);
							}.bind(w),
							event,w.options ? w.options.multiline : false );
					}
					break;
				default:
					if (w.mouse) {
						this.dirty_canvas = w.mouse(event, [x, y], node);
					}
					break;
			} //end switch

			//value changed
			if( old_value != w.value )
			{
				if(node.onWidgetChanged)
					node.onWidgetChanged( w.name,w.value,old_value,w );
                node.graph._version++;
			}

			return w;
        }//end for

        function inner_value_change(widget, value) {
            widget.value = value;
            if ( widget.options && widget.options.property && node.properties[widget.options.property] !== undefined ) {
                node.setProperty( widget.options.property, value );
            }
            if (widget.callback) {
                widget.callback(widget.value, that, node, pos, event);
            }
        }

        return null;
    };

    /**
     * draws every group area in the background
     * @method drawGroups
     **/
    LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {
        if (!this.graph) {
            return;
        }

        var groups = this.graph._groups;

        ctx.save();
        ctx.globalAlpha = 0.5 * this.editor_alpha;

        for (var i = 0; i < groups.length; ++i) {
            var group = groups[i];

            if (!overlapBounding(this.visible_area, group._bounding)) {
                continue;
            } //out of the visible area

            ctx.fillStyle = group.color || "#335";
            ctx.strokeStyle = group.color || "#335";
            var pos = group._pos;
            var size = group._size;
            ctx.globalAlpha = 0.25 * this.editor_alpha;
            ctx.beginPath();
            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);
            ctx.fill();
            ctx.globalAlpha = this.editor_alpha;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);
            ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);
            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);
            ctx.fill();

            var font_size =
                group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
            ctx.font = font_size + "px Arial";
            ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);
        }

        ctx.restore();
    };

    LGraphCanvas.prototype.adjustNodesSize = function() {
        var nodes = this.graph._nodes;
        for (var i = 0; i < nodes.length; ++i) {
            nodes[i].size = nodes[i].computeSize();
        }
        this.setDirty(true, true);
    };

    /**
     * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode
     * @method resize
     **/
    LGraphCanvas.prototype.resize = function(width, height) {
        if (!width && !height) {
            var parent = this.canvas.parentNode;
            width = parent.offsetWidth;
            height = parent.offsetHeight;
        }

        if (this.canvas.width == width && this.canvas.height == height) {
            return;
        }

        this.canvas.width = width;
        this.canvas.height = height;
        this.bgcanvas.width = this.canvas.width;
        this.bgcanvas.height = this.canvas.height;
        this.setDirty(true, true);
    };

    /**
     * switches to live mode (node shapes are not rendered, only the content)
     * this feature was designed when graphs where meant to create user interfaces
     * @method switchLiveMode
     **/
    LGraphCanvas.prototype.switchLiveMode = function(transition) {
        if (!transition) {
            this.live_mode = !this.live_mode;
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
            return;
        }

        var self = this;
        var delta = this.live_mode ? 1.1 : 0.9;
        if (this.live_mode) {
            this.live_mode = false;
            this.editor_alpha = 0.1;
        }

        var t = setInterval(function() {
            self.editor_alpha *= delta;
            self.dirty_canvas = true;
            self.dirty_bgcanvas = true;

            if (delta < 1 && self.editor_alpha < 0.01) {
                clearInterval(t);
                if (delta < 1) {
                    self.live_mode = true;
                }
            }
            if (delta > 1 && self.editor_alpha > 0.99) {
                clearInterval(t);
                self.editor_alpha = 1;
            }
        }, 1);
    };

    LGraphCanvas.prototype.onNodeSelectionChange = function(node) {
        return; //disabled
    };

    LGraphCanvas.prototype.touchHandler = function(event) {
        //alert("foo");
        var touches = event.changedTouches,
            first = touches[0],
            type = "";

        switch (event.type) {
            case "touchstart":
                type = "mousedown";
                break;
            case "touchmove":
                type = "mousemove";
                break;
            case "touchend":
                type = "mouseup";
                break;
            default:
                return;
        }

        //initMouseEvent(type, canBubble, cancelable, view, clickCount,
        //           screenX, screenY, clientX, clientY, ctrlKey,
        //           altKey, shiftKey, metaKey, button, relatedTarget);

        var window = this.getCanvasWindow();
        var document = window.document;

        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(
            type,
            true,
            true,
            window,
            1,
            first.screenX,
            first.screenY,
            first.clientX,
            first.clientY,
            false,
            false,
            false,
            false,
            0 /*left*/,
            null
        );
        first.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
    };

    /* CONTEXT MENU ********************/

    LGraphCanvas.onGroupAdd = function(info, entry, mouse_event) {
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var group = new LiteGraph.LGraphGroup();
        group.pos = canvas.convertEventToCanvasOffset(mouse_event);
        canvas.graph.add(group);
    };

    LGraphCanvas.onMenuAdd = function (node, options, e, prev_menu, callback) {

        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();
        var graph = canvas.graph;
        if (!graph)
            return;

        function inner_onMenuAdded(base_category ,prev_menu){
    
            var categories  = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category){return category.startsWith(base_category)});
            var entries = [];
    
            categories.map(function(category){
    
                if (!category) 
                    return;
    
                var base_category_regex = new RegExp('^(' + base_category + ')');
                var category_name = category.replace(base_category_regex,"").split('/')[0];
                var category_path = base_category  === '' ? category_name + '/' : base_category + category_name + '/';
    
                var name = category_name;
                if(name.indexOf("::") != -1) //in case it has a namespace like "shader::math/rand" it hides the namespace
                    name = name.split("::")[1];
                        
                var index = entries.findIndex(function(entry){return entry.value === category_path});
                if (index === -1) {
                    entries.push({ value: category_path, content: name, has_submenu: true, callback : function(value, event, mouseEvent, contextMenu){
                        inner_onMenuAdded(value.value, contextMenu)
                    }});
                }
                
            });
    
            var nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter );
            nodes.map(function(node){
    
                if (node.skip_list)
                    return;
    
                var entry = { value: node.type, content: node.title, has_submenu: false , callback : function(value, event, mouseEvent, contextMenu){
                    
                        var first_event = contextMenu.getFirstEvent();
                        canvas.graph.beforeChange();
                        var node = LiteGraph.createNode(value.value);
                        if (node) {
                            node.pos = canvas.convertEventToCanvasOffset(first_event);
                            canvas.graph.add(node);
                        }
                        if(callback)
                            callback(node);
                        canvas.graph.afterChange();
                    
                    }
                }
    
                entries.push(entry);
    
            });
    
            new LiteGraph.ContextMenu( entries, { event: e, parentMenu: prev_menu }, ref_window );
    
        }
    
        inner_onMenuAdded('',prev_menu);
        return false;
    
    };

    LGraphCanvas.onMenuCollapseAll = function() {};

    LGraphCanvas.onMenuNodeEdit = function() {};

    LGraphCanvas.showMenuNodeOptionalInputs = function(
        v,
        options,
        e,
        prev_menu,
        node
    ) {
        if (!node) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var options = node.optional_inputs;
        if (node.onGetInputs) {
            options = node.onGetInputs();
        }

        var entries = [];
        if (options) {
            for (var i=0; i < options.length; i++) {
                var entry = options[i];
                if (!entry) {
                    entries.push(null);
                    continue;
                }
                var label = entry[0];
                if (entry[2] && entry[2].label) {
                    label = entry[2].label;
                }
                var data = { content: label, value: entry };
                if (entry[1] == LiteGraph.ACTION) {
                    data.className = "event";
                }
                entries.push(data);
            }
        }

        if (this.onMenuNodeInputs) {
            entries = this.onMenuNodeInputs(entries);
        }

        if (!entries.length) {
			console.log("no input entries");
            return;
        }

        var menu = new LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                node: node
            },
            ref_window
        );

        function inner_clicked(v, e, prev) {
            if (!node) {
                return;
            }

            if (v.callback) {
                v.callback.call(that, node, v, e, prev);
            }

            if (v.value) {
				node.graph.beforeChange();
                node.addInput(v.value[0], v.value[1], v.value[2]);
                node.setDirtyCanvas(true, true);
				node.graph.afterChange();
            }
        }

        return false;
    };

    LGraphCanvas.showMenuNodeOptionalOutputs = function(
        v,
        options,
        e,
        prev_menu,
        node
    ) {
        if (!node) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var options = node.optional_outputs;
        if (node.onGetOutputs) {
            options = node.onGetOutputs();
        }

        var entries = [];
        if (options) {
            for (var i=0; i < options.length; i++) {
                var entry = options[i];
                if (!entry) {
                    //separator?
                    entries.push(null);
                    continue;
                }

                if (
                    node.flags &&
                    node.flags.skip_repeated_outputs &&
                    node.findOutputSlot(entry[0]) != -1
                ) {
                    continue;
                } //skip the ones already on
                var label = entry[0];
                if (entry[2] && entry[2].label) {
                    label = entry[2].label;
                }
                var data = { content: label, value: entry };
                if (entry[1] == LiteGraph.EVENT) {
                    data.className = "event";
                }
                entries.push(data);
            }
        }

        if (this.onMenuNodeOutputs) {
            entries = this.onMenuNodeOutputs(entries);
        }

        if (!entries.length) {
            return;
        }

        var menu = new LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                node: node
            },
            ref_window
        );

        function inner_clicked(v, e, prev) {
            if (!node) {
                return;
            }

            if (v.callback) {
                v.callback.call(that, node, v, e, prev);
            }

            if (!v.value) {
                return;
            }

            var value = v.value[1];

            if (
                value &&
                (value.constructor === Object || value.constructor === Array)
            ) {
                //submenu why?
                var entries = [];
                for (var i in value) {
                    entries.push({ content: i, value: value[i] });
                }
                new LiteGraph.ContextMenu(entries, {
                    event: e,
                    callback: inner_clicked,
                    parentMenu: prev_menu,
                    node: node
                });
                return false;
            } else {
				node.graph.beforeChange();
                node.addOutput(v.value[0], v.value[1], v.value[2]);
                node.setDirtyCanvas(true, true);
				node.graph.afterChange();
            }
        }

        return false;
    };

    LGraphCanvas.onShowMenuNodeProperties = function(
        value,
        options,
        e,
        prev_menu,
        node
    ) {
        if (!node || !node.properties) {
            return;
        }

        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var entries = [];
        for (var i in node.properties) {
            var value = node.properties[i] !== undefined ? node.properties[i] : " ";
			if( typeof value == "object" )
				value = JSON.stringify(value);
			var info = node.getPropertyInfo(i);
			if(info.type == "enum" || info.type == "combo")
				value = LGraphCanvas.getPropertyPrintableValue( value, info.values );

            //value could contain invalid html characters, clean that
            value = LGraphCanvas.decodeHTML(value);
            entries.push({
                content:
                    "<span class='property_name'>" +
                    (info.label ? info.label : i) +
                    "</span>" +
                    "<span class='property_value'>" +
                    value +
                    "</span>",
                value: i
            });
        }
        if (!entries.length) {
            return;
        }

        var menu = new LiteGraph.ContextMenu(
            entries,
            {
                event: e,
                callback: inner_clicked,
                parentMenu: prev_menu,
                allow_html: true,
                node: node
            },
            ref_window
        );

        function inner_clicked(v, options, e, prev) {
            if (!node) {
                return;
            }
            var rect = this.getBoundingClientRect();
            canvas.showEditPropertyValue(node, v.value, {
                position: [rect.left, rect.top]
            });
        }

        return false;
    };

    LGraphCanvas.decodeHTML = function(str) {
        var e = document.createElement("div");
        e.innerText = str;
        return e.innerHTML;
    };

    LGraphCanvas.onResizeNode = function(value, options, e, menu, node) {
        if (!node) {
            return;
        }
        node.size = node.computeSize();
        if (node.onResize)
            node.onResize(node.size);
        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.prototype.showLinkMenu = function(link, e) {
        var that = this;
		console.log(link);
		var options = ["Add Node",null,"Delete"];
        var menu = new LiteGraph.ContextMenu(options, {
            event: e,
			title: link.data != null ? link.data.constructor.name : null,
            callback: inner_clicked
        });

        function inner_clicked(v,options,e) {
            switch (v) {
                case "Add Node":
					LGraphCanvas.onMenuAdd(null, null, e, menu, function(node){
						console.log("node autoconnect");
						var node_left = that.graph.getNodeById( link.origin_id );
						var node_right = that.graph.getNodeById( link.target_id );
						if(!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length)
							return;
						if( node_left.outputs[ link.origin_slot ].type == node.inputs[0].type && node.outputs[0].type == node_right.inputs[0].type )
						{
							node_left.connect( link.origin_slot, node, 0 );
							node.connect( 0, node_right, link.target_slot );
							node.pos[0] -= node.size[0] * 0.5;
						}
					});
					break;
                case "Delete":
                    that.graph.removeLink(link.id);
                    break;
                default:
            }
        }

        return false;
    };

    LGraphCanvas.onShowPropertyEditor = function(item, options, e, menu, node) {
        var input_html = "";
        var property = item.property || "title";
        var value = node[property];

        var dialog = document.createElement("div");
        dialog.className = "graphdialog";
        dialog.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
		//dialog.innerHTML = "<span class='name'></span><textarea autofocus class='value'></textarea><button>OK</button>";
        var title = dialog.querySelector(".name");
        title.innerText = property;
        var input = dialog.querySelector(".value");
        if (input) {
            input.value = value;
            input.addEventListener("blur", function(e) {
                this.focus();
            });
            input.addEventListener("keydown", function(e) {
                if (e.keyCode != 13 && e.target.localName != "textarea") {
                    return;
                }
                inner();
                e.preventDefault();
                e.stopPropagation();
            });
        }

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;

        var rect = canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }

        var button = dialog.querySelector("button");
        button.addEventListener("click", inner);
        canvas.parentNode.appendChild(dialog);

        function inner() {
            setValue(input.value);
        }

        function setValue(value) {
            if (item.type == "Number") {
                value = Number(value);
            } else if (item.type == "Boolean") {
                value = Boolean(value);
            }
            node[property] = value;
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
            node.setDirtyCanvas(true, true);
        }
    };

    LGraphCanvas.prototype.prompt = function(title, value, callback, event, multiline) {
        var that = this;
        var input_html = "";
        title = title || "";

        var modified = false;

        var dialog = document.createElement("div");
        dialog.className = "graphdialog rounded";
		if(multiline)
	        dialog.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>";
		else
	        dialog.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
        dialog.close = function() {
            that.prompt_box = null;
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        if (this.ds.scale > 1) {
            dialog.style.transform = "scale(" + this.ds.scale + ")";
        }

        dialog.addEventListener("mouseleave", function(e) {
            if (!modified) {
                dialog.close();
            }
        });

        if (that.prompt_box) {
            that.prompt_box.close();
        }
        that.prompt_box = dialog;

        var first = null;
        var timeout = null;
        var selected = null;

        var name_element = dialog.querySelector(".name");
        name_element.innerText = title;
        var value_element = dialog.querySelector(".value");
        value_element.value = value;

        var input = value_element;
        input.addEventListener("keydown", function(e) {
            modified = true;
            if (e.keyCode == 27) {
                //ESC
                dialog.close();
            } else if (e.keyCode == 13 && e.target.localName != "textarea") {
                if (callback) {
                    callback(this.value);
                }
                dialog.close();
            } else {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
        });

        var button = dialog.querySelector("button");
        button.addEventListener("click", function(e) {
            if (callback) {
                callback(input.value);
            }
            that.setDirty(true);
            dialog.close();
        });

        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;

        var rect = canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }

        canvas.parentNode.appendChild(dialog);
        setTimeout(function() {
            input.focus();
        }, 10);

        return dialog;
    };

    LGraphCanvas.search_limit = -1;
    LGraphCanvas.prototype.showSearchBox = function(event) {
        var that = this;
        var input_html = "";
        var graphcanvas = LGraphCanvas.active_canvas;
        var canvas = graphcanvas.canvas;
        var root_document = canvas.ownerDocument || document;

        var dialog = document.createElement("div");
        dialog.className = "litegraph litesearchbox graphdialog rounded";
        dialog.innerHTML =
            "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>";
        dialog.close = function() {
            that.search_box = null;
            root_document.body.focus();
			root_document.body.style.overflow = "";

            setTimeout(function() {
                that.canvas.focus();
            }, 20); //important, if canvas loses focus keys wont be captured
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        var timeout_close = null;

        if (this.ds.scale > 1) {
            dialog.style.transform = "scale(" + this.ds.scale + ")";
        }

        dialog.addEventListener("mouseenter", function(e) {
            if (timeout_close) {
                clearTimeout(timeout_close);
                timeout_close = null;
            }
        });

        dialog.addEventListener("mouseleave", function(e) {
            //dialog.close();
            timeout_close = setTimeout(function() {
                dialog.close();
            }, 500);
        });

        if (that.search_box) {
            that.search_box.close();
        }
        that.search_box = dialog;

        var helper = dialog.querySelector(".helper");

        var first = null;
        var timeout = null;
        var selected = null;

        var input = dialog.querySelector("input");
        if (input) {
            input.addEventListener("blur", function(e) {
                this.focus();
            });
            input.addEventListener("keydown", function(e) {
                if (e.keyCode == 38) {
                    //UP
                    changeSelection(false);
                } else if (e.keyCode == 40) {
                    //DOWN
                    changeSelection(true);
                } else if (e.keyCode == 27) {
                    //ESC
                    dialog.close();
                } else if (e.keyCode == 13) {
                    if (selected) {
                        select(selected.innerHTML);
                    } else if (first) {
                        select(first);
                    } else {
                        dialog.close();
                    }
                } else {
                    if (timeout) {
                        clearInterval(timeout);
                    }
                    timeout = setTimeout(refreshHelper, 10);
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
				e.stopImmediatePropagation();
				return true;
            });
        }

		if( root_document.fullscreenElement )
	        root_document.fullscreenElement.appendChild(dialog);
		else
		{
		    root_document.body.appendChild(dialog);
			root_document.body.style.overflow = "hidden";
		}

        //compute best position
        var rect = canvas.getBoundingClientRect();

        var left = ( event ? event.clientX : (rect.left + rect.width * 0.5) ) - 80;
        var top = ( event ? event.clientY : (rect.top + rect.height * 0.5) ) - 20;
        dialog.style.left = left + "px";
        dialog.style.top = top + "px";

		//To avoid out of screen problems
		if(event.layerY > (rect.height - 200)) 
            helper.style.maxHeight = (rect.height - event.layerY - 20) + "px";

		/*
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (event) {
            dialog.style.left = event.clientX + offsetx + "px";
            dialog.style.top = event.clientY + offsety + "px";
        } else {
            dialog.style.left = canvas.width * 0.5 + offsetx + "px";
            dialog.style.top = canvas.height * 0.5 + offsety + "px";
        }
        canvas.parentNode.appendChild(dialog);
		*/

        input.focus();

        function select(name) {
            if (name) {
                if (that.onSearchBoxSelection) {
                    that.onSearchBoxSelection(name, event, graphcanvas);
                } else {
                    var extra = LiteGraph.searchbox_extras[name.toLowerCase()];
                    if (extra) {
                        name = extra.type;
                    }

					graphcanvas.graph.beforeChange();
                    var node = LiteGraph.createNode(name);
                    if (node) {
                        node.pos = graphcanvas.convertEventToCanvasOffset(
                            event
                        );
                        graphcanvas.graph.add(node);
                    }

                    if (extra && extra.data) {
                        if (extra.data.properties) {
                            for (var i in extra.data.properties) {
                                node.addProperty( i, extra.data.properties[i] );
                            }
                        }
                        if (extra.data.inputs) {
                            node.inputs = [];
                            for (var i in extra.data.inputs) {
                                node.addOutput(
                                    extra.data.inputs[i][0],
                                    extra.data.inputs[i][1]
                                );
                            }
                        }
                        if (extra.data.outputs) {
                            node.outputs = [];
                            for (var i in extra.data.outputs) {
                                node.addOutput(
                                    extra.data.outputs[i][0],
                                    extra.data.outputs[i][1]
                                );
                            }
                        }
                        if (extra.data.title) {
                            node.title = extra.data.title;
                        }
                        if (extra.data.json) {
                            node.configure(extra.data.json);
                        }

						graphcanvas.graph.afterChange();
                    }
                }
            }

            dialog.close();
        }

        function changeSelection(forward) {
            var prev = selected;
            if (selected) {
                selected.classList.remove("selected");
            }
            if (!selected) {
                selected = forward
                    ? helper.childNodes[0]
                    : helper.childNodes[helper.childNodes.length];
            } else {
                selected = forward
                    ? selected.nextSibling
                    : selected.previousSibling;
                if (!selected) {
                    selected = prev;
                }
            }
            if (!selected) {
                return;
            }
            selected.classList.add("selected");
            selected.scrollIntoView({block: "end", behavior: "smooth"});
        }

        function refreshHelper() {
            timeout = null;
            var str = input.value;
            first = null;
            helper.innerHTML = "";
            if (!str) {
                return;
            }

            if (that.onSearchBox) {
                var list = that.onSearchBox(helper, str, graphcanvas);
                if (list) {
                    for (var i = 0; i < list.length; ++i) {
                        addResult(list[i]);
                    }
                }
            } else {
                var c = 0;
                str = str.toLowerCase();
				var filter = graphcanvas.filter || graphcanvas.graph.filter;

                //extras
                for (var i in LiteGraph.searchbox_extras) {
                    var extra = LiteGraph.searchbox_extras[i];
                    if (extra.desc.toLowerCase().indexOf(str) === -1) {
                        continue;
                    }
					var ctor = LiteGraph.registered_node_types[ extra.type ];
					if( ctor && ctor.filter != filter )
						continue;
                    addResult( extra.desc, "searchbox_extra" );
                    if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
                        break;
                    }
                }

				var filtered = null;
                if (Array.prototype.filter) { //filter supported
                    var keys = Object.keys( LiteGraph.registered_node_types ); //types
                    var filtered = keys.filter( inner_test_filter );
                } else {
					filtered = [];
                    for (var i in LiteGraph.registered_node_types) {
						if( inner_test_filter(i) )
							filtered.push(i);
                    }
                }

				for (var i = 0; i < filtered.length; i++) {
					addResult(filtered[i]);
					if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {
						break;
					}
				}

				function inner_test_filter( type )
				{
					var ctor = LiteGraph.registered_node_types[ type ];
					if(filter && ctor.filter != filter )
						return false;
					return type.toLowerCase().indexOf(str) !== -1;
				}
            }

            function addResult(type, className) {
                var help = document.createElement("div");
                if (!first) {
                    first = type;
                }
                help.innerText = type;
                help.dataset["type"] = escape(type);
                help.className = "litegraph lite-search-item";
                if (className) {
                    help.className += " " + className;
                }
                help.addEventListener("click", function(e) {
                    select(unescape(this.dataset["type"]));
                });
                helper.appendChild(help);
            }
        }

        return dialog;
    };

    LGraphCanvas.prototype.showEditPropertyValue = function( node, property, options ) {
        if (!node || node.properties[property] === undefined) {
            return;
        }

        options = options || {};
        var that = this;

        var info = node.getPropertyInfo(property);
		var type = info.type;

        var input_html = "";

        if (type == "string" || type == "number" || type == "array" || type == "object") {
            input_html = "<input autofocus type='text' class='value'/>";
        } else if ( (type == "enum" || type == "combo") && info.values) {
            input_html = "<select autofocus type='text' class='value'>";
            for (var i in info.values) {
                var v = i;
				if( info.values.constructor === Array )
					v = info.values[i];

                input_html +=
                    "<option value='" +
                    v +
                    "' " +
                    (v == node.properties[property] ? "selected" : "") +
                    ">" +
                    info.values[i] +
                    "</option>";
            }
            input_html += "</select>";
        } else if (type == "boolean") {
            input_html =
                "<input autofocus type='checkbox' class='value' " +
                (node.properties[property] ? "checked" : "") +
                "/>";
        } else {
            console.warn("unknown type: " + type);
            return;
        }

        var dialog = this.createDialog(
            "<span class='name'>" +
                (info.label ? info.label : property) +
                "</span>" +
                input_html +
                "<button>OK</button>",
            options
        );

        if ((type == "enum" || type == "combo") && info.values) {
            var input = dialog.querySelector("select");
            input.addEventListener("change", function(e) {
                setValue(e.target.value);
                //var index = e.target.value;
                //setValue( e.options[e.selectedIndex].value );
            });
        } else if (type == "boolean") {
            var input = dialog.querySelector("input");
            if (input) {
                input.addEventListener("click", function(e) {
                    setValue(!!input.checked);
                });
            }
        } else {
            var input = dialog.querySelector("input");
            if (input) {
                input.addEventListener("blur", function(e) {
                    this.focus();
                });

				var v = node.properties[property] !== undefined ? node.properties[property] : "";
				if (type !== 'string') {
                    v = JSON.stringify(v);
                }

                input.value = v;
                input.addEventListener("keydown", function(e) {
                    if (e.keyCode != 13) {
                        return;
                    }
                    inner();
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
        }

        var button = dialog.querySelector("button");
        button.addEventListener("click", inner);

        function inner() {
            setValue(input.value);
        }

        function setValue(value) {

			if(info && info.values && info.values.constructor === Object && info.values[value] != undefined )
				value = info.values[value];

            if (typeof node.properties[property] == "number") {
                value = Number(value);
            }
            if (type == "array" || type == "object") {
                value = JSON.parse(value);
            }
            node.properties[property] = value;
            if (node.graph) {
                node.graph._version++;
            }
            if (node.onPropertyChanged) {
                node.onPropertyChanged(property, value);
            }
			if(options.onclose)
				options.onclose();
            dialog.close();
            node.setDirtyCanvas(true, true);
        }

		return dialog;
    };

    LGraphCanvas.prototype.createDialog = function(html, options) {
        options = options || {};

        var dialog = document.createElement("div");
        dialog.className = "graphdialog";
        dialog.innerHTML = html;

        var rect = this.canvas.getBoundingClientRect();
        var offsetx = -20;
        var offsety = -20;
        if (rect) {
            offsetx -= rect.left;
            offsety -= rect.top;
        }

        if (options.position) {
            offsetx += options.position[0];
            offsety += options.position[1];
        } else if (options.event) {
            offsetx += options.event.clientX;
            offsety += options.event.clientY;
        } //centered
        else {
            offsetx += this.canvas.width * 0.5;
            offsety += this.canvas.height * 0.5;
        }

        dialog.style.left = offsetx + "px";
        dialog.style.top = offsety + "px";

        this.canvas.parentNode.appendChild(dialog);

        dialog.close = function() {
            if (this.parentNode) {
                this.parentNode.removeChild(this);
            }
        };

        return dialog;
    };

	LGraphCanvas.prototype.createPanel = function(title, options) {
		options = options || {};

		var ref_window = options.window || window;
		var root = document.createElement("div");
		root.className = "litegraph dialog";
		root.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>";
		root.header = root.querySelector(".dialog-header");

		if(options.width)
			root.style.width = options.width + (options.width.constructor === Number ? "px" : "");
		if(options.height)
			root.style.height = options.height + (options.height.constructor === Number ? "px" : "");
		if(options.closable)
		{
			var close = document.createElement("span");
			close.innerHTML = "&#10005;";
			close.classList.add("close");
			close.addEventListener("click",function(){
				root.close();
			});
			root.header.appendChild(close);
		}
		root.title_element = root.querySelector(".dialog-title");
		root.title_element.innerText = title;
		root.content = root.querySelector(".dialog-content");
		root.footer = root.querySelector(".dialog-footer");

		root.close = function()
		{
			if(this.parentNode)
				this.parentNode.removeChild(this);
		}

		root.clear = function()
		{
			this.content.innerHTML = "";
		}

		root.addHTML = function(code, classname, on_footer)
		{
			var elem = document.createElement("div");
			if(classname)
				elem.className = classname;
			elem.innerHTML = code;
			if(on_footer)
				root.footer.appendChild(elem);
			else
				root.content.appendChild(elem);
			return elem;
		}

		root.addButton = function( name, callback, options )
		{
			var elem = document.createElement("button");
			elem.innerText = name;
			elem.options = options;
			elem.classList.add("btn");
			elem.addEventListener("click",callback);
			root.footer.appendChild(elem);
			return elem;
		}

		root.addSeparator = function()
		{
			var elem = document.createElement("div");
			elem.className = "separator";
			root.content.appendChild(elem);
		}

		root.addWidget = function( type, name, value, options, callback )
		{
			options = options || {};
			var str_value = String(value);
			type = type.toLowerCase();
			if(type == "number")
				str_value = value.toFixed(3);

			var elem = document.createElement("div");
			elem.className = "property";
			elem.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
			elem.querySelector(".property_name").innerText = options.label || name;
			var value_element = elem.querySelector(".property_value");
			value_element.innerText = str_value;
			elem.dataset["property"] = name;
			elem.dataset["type"] = options.type || type;
			elem.options = options;
			elem.value = value;

			//if( type == "code" )
			//	elem.addEventListener("click", function(){ inner_showCodePad( node, this.dataset["property"] ); });
			if (type == "boolean")
			{
				elem.classList.add("boolean");
				if(value)
					elem.classList.add("bool-on");
				elem.addEventListener("click", function(){ 
					//var v = node.properties[this.dataset["property"]]; 
					//node.setProperty(this.dataset["property"],!v); this.innerText = v ? "true" : "false"; 
					var propname = this.dataset["property"];
					this.value = !this.value;
					this.classList.toggle("bool-on");
					this.querySelector(".property_value").innerText = this.value ? "true" : "false";
					innerChange(propname, this.value );
				});
			}
			else if (type == "string" || type == "number")
			{
				value_element.setAttribute("contenteditable",true);
				value_element.addEventListener("keydown", function(e){ 
					if(e.code == "Enter")
					{
						e.preventDefault();
						this.blur();
					}
				});
				value_element.addEventListener("blur", function(){ 
					var v = this.innerText;
					var propname = this.parentNode.dataset["property"];
					var proptype = this.parentNode.dataset["type"];
					if( proptype == "number")
						v = Number(v);
					innerChange(propname, v);
				});
			}
			else if (type == "enum" || type == "combo") {
				var str_value = LGraphCanvas.getPropertyPrintableValue( value, options.values );
				value_element.innerText = str_value;

				value_element.addEventListener("click", function(event){ 
					var values = options.values || [];
					var propname = this.parentNode.dataset["property"];
					var elem_that = this;
					var menu = new LiteGraph.ContextMenu(values,{
							event: event,
							className: "dark",
							callback: inner_clicked
						},
						ref_window);
					function inner_clicked(v, option, event) {
						//node.setProperty(propname,v); 
						//graphcanvas.dirty_canvas = true;
						elem_that.innerText = v;
						innerChange(propname,v);
						return false;
					}
				});
            }

			root.content.appendChild(elem);

			function innerChange(name, value)
			{
				console.log("change",name,value);
				//that.dirty_canvas = true;
				if(options.callback)
					options.callback(name,value);
				if(callback)
					callback(name,value);
			}

			return elem;
		}

		return root;
	};

	LGraphCanvas.getPropertyPrintableValue = function(value, values)
	{
		if(!values)
			return String(value);

		if(values.constructor === Array)
		{
			return String(value);			
		}

		if(values.constructor === Object)
		{
			var desc_value = "";
			for(var k in values)
			{
				if(values[k] != value)
					continue;
				desc_value = k;
				break;
			}
			return String(value) + " ("+desc_value+")";
		}
	}

	LGraphCanvas.prototype.showShowNodePanel = function( node )
	{
		window.SELECTED_NODE = node;
		var panel = document.querySelector("#node-panel");
		if(panel)
			panel.close();
		var ref_window = this.getCanvasWindow();
		panel = this.createPanel(node.title || "",{closable: true, window: ref_window });
		panel.id = "node-panel";
		panel.node = node;
		panel.classList.add("settings");
		var that = this;
		var graphcanvas = this;

		function inner_refresh()
		{
			panel.content.innerHTML = ""; //clear
			panel.addHTML("<span class='node_type'>"+node.type+"</span><span class='node_desc'>"+(node.constructor.desc || "")+"</span><span class='separator'></span>");

			panel.addHTML("<h3>Properties</h3>");

			for(var i in node.properties)
			{
				var value = node.properties[i];
				var info = node.getPropertyInfo(i);
				var type = info.type || "string";

				//in case the user wants control over the side panel widget
				if( node.onAddPropertyToPanel && node.onAddPropertyToPanel(i,panel) )
					continue;

				panel.addWidget( info.widget || info.type, i, value, info, function(name,value){
					graphcanvas.graph.beforeChange(node);
					node.setProperty(name,value);
					graphcanvas.graph.afterChange();
					graphcanvas.dirty_canvas = true;
				});
			}

			panel.addSeparator();

			if(node.onShowCustomPanelInfo)
				node.onShowCustomPanelInfo(panel);

			/*
			panel.addHTML("<h3>Connections</h3>");
			var connection_containers = panel.addHTML("<div class='inputs connections_side'></div><div class='outputs connections_side'></div>","connections");
			var inputs = connection_containers.querySelector(".inputs");
			var outputs = connection_containers.querySelector(".outputs");
			*/

			panel.addButton("Delete",function(){
				if(node.block_delete)
					return;
				node.graph.remove(node);
				panel.close();
			}).classList.add("delete");
		}

		function inner_showCodePad( node, propname )
		{
			panel.style.top = "calc( 50% - 250px)";
			panel.style.left = "calc( 50% - 400px)";
			panel.style.width = "800px";
			panel.style.height = "500px";

			if(window.CodeFlask) //disabled for now
			{
				panel.content.innerHTML = "<div class='code'></div>";
				var flask = new CodeFlask( "div.code", { language: 'js' });
				flask.updateCode(node.properties[propname]);
				flask.onUpdate( function(code) {
					node.setProperty(propname, code);
				});
			}
			else
			{
				panel.content.innerHTML = "<textarea class='code'></textarea>";
				var textarea = panel.content.querySelector("textarea");
				textarea.value = node.properties[propname];
				textarea.addEventListener("keydown", function(e){
					//console.log(e);
					if(e.code == "Enter" && e.ctrlKey )
					{
						console.log("Assigned");
						node.setProperty(propname, textarea.value);
					}
				});
				textarea.style.height = "calc(100% - 40px)";
			}
			var assign = that.createButton( "Assign", null, function(){
				node.setProperty(propname, textarea.value);
			});
			panel.content.appendChild(assign);
			var button = that.createButton( "Close", null, function(){
				panel.style.height = "";
				inner_refresh();
			});
			button.style.float = "right";
			panel.content.appendChild(button);
		}

		inner_refresh();

		this.canvas.parentNode.appendChild( panel );
	}
	
	LGraphCanvas.prototype.showSubgraphPropertiesDialog = function(node)
	{
		console.log("showing subgraph properties dialog");

		var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
		if(old_panel)
			old_panel.close();

		var panel = this.createPanel("Subgraph Inputs",{closable:true, width: 500});
		panel.node = node;
		panel.classList.add("subgraph_dialog");

		function inner_refresh()
		{
			panel.clear();

			//show currents
			if(node.inputs)
				for(var i = 0; i < node.inputs.length; ++i)
				{
					var input = node.inputs[i];
					if(input.not_subgraph_input)
						continue;
					var html = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
					var elem = panel.addHTML(html,"subgraph_property");
					elem.dataset["name"] = input.name;
					elem.dataset["slot"] = i;
					elem.querySelector(".name").innerText = input.name;
					elem.querySelector(".type").innerText = input.type;
					elem.querySelector("button").addEventListener("click",function(e){
						node.removeInput( Number( this.parentNode.dataset["slot"] ) );
						inner_refresh();
					});
				}
		}

		//add extra
		var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
		var elem = panel.addHTML(html,"subgraph_property extra", true);
		elem.querySelector("button").addEventListener("click", function(e){
			var elem = this.parentNode;
			var name = elem.querySelector(".name").value;
			var type = elem.querySelector(".type").value;
			if(!name || node.findInputSlot(name) != -1)
				return;
			node.addInput(name,type);
			elem.querySelector(".name").value = "";
			elem.querySelector(".type").value = "";
			inner_refresh();
		});

		inner_refresh();
	    this.canvas.parentNode.appendChild(panel);
		return panel;
	}

	LGraphCanvas.prototype.checkPanels = function()
	{
		if(!this.canvas)
			return;
		var panels = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
		for(var i = 0; i < panels.length; ++i)
		{
			var panel = panels[i];
			if( !panel.node )
				continue;
			if( !panel.node.graph || panel.graph != this.graph )
				panel.close();
		}
	}

    LGraphCanvas.onMenuNodeCollapse = function(value, options, e, menu, node) {
		node.graph.beforeChange(node);
        node.collapse();
		node.graph.afterChange(node);
    };

    LGraphCanvas.onMenuNodePin = function(value, options, e, menu, node) {
        node.pin();
    };

    LGraphCanvas.onMenuNodeMode = function(value, options, e, menu, node) {
        new LiteGraph.ContextMenu(
            ["Always", "On Event", "On Trigger", "Never"],
            { event: e, callback: inner_clicked, parentMenu: menu, node: node }
        );

        function inner_clicked(v) {
            if (!node) {
                return;
            }
            switch (v) {
                case "On Event":
                    node.mode = LiteGraph.ON_EVENT;
                    break;
                case "On Trigger":
                    node.mode = LiteGraph.ON_TRIGGER;
                    break;
                case "Never":
                    node.mode = LiteGraph.NEVER;
                    break;
                case "Always":
                default:
                    node.mode = LiteGraph.ALWAYS;
                    break;
            }
        }

        return false;
    };

    LGraphCanvas.onMenuNodeColors = function(value, options, e, menu, node) {
        if (!node) {
            throw "no node for color";
        }

        var values = [];
        values.push({
            value: null,
            content:
                "<span style='display: block; padding-left: 4px;'>No color</span>"
        });

        for (var i in LGraphCanvas.node_colors) {
            var color = LGraphCanvas.node_colors[i];
            var value = {
                value: i,
                content:
                    "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " +
                    color.color +
                    "; background-color:" +
                    color.bgcolor +
                    "'>" +
                    i +
                    "</span>"
            };
            values.push(value);
        }
        new LiteGraph.ContextMenu(values, {
            event: e,
            callback: inner_clicked,
            parentMenu: menu,
            node: node
        });

        function inner_clicked(v) {
            if (!node) {
                return;
            }

            var color = v.value ? LGraphCanvas.node_colors[v.value] : null;
            if (color) {
                if (node.constructor === LiteGraph.LGraphGroup) {
                    node.color = color.groupcolor;
                } else {
                    node.color = color.color;
                    node.bgcolor = color.bgcolor;
                }
            } else {
                delete node.color;
                delete node.bgcolor;
            }
            node.setDirtyCanvas(true, true);
        }

        return false;
    };

    LGraphCanvas.onMenuNodeShapes = function(value, options, e, menu, node) {
        if (!node) {
            throw "no node passed";
        }

        new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
            event: e,
            callback: inner_clicked,
            parentMenu: menu,
            node: node
        });

        function inner_clicked(v) {
            if (!node) {
                return;
            }
			node.graph.beforeChange(node);
            node.shape = v;
			node.graph.afterChange(node);
            node.setDirtyCanvas(true);
        }

        return false;
    };

    LGraphCanvas.onMenuNodeRemove = function(value, options, e, menu, node) {
        if (!node) {
            throw "no node passed";
        }

        if (node.removable === false) {
            return;
        }

		var graph = node.graph;
		graph.beforeChange();
        graph.remove(node);
		graph.afterChange();
        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.onMenuNodeToSubgraph = function(value, options, e, menu, node) {
		var graph = node.graph;
		var graphcanvas = LGraphCanvas.active_canvas;
		if(!graphcanvas) //??
			return;

		var nodes_list = Object.values( graphcanvas.selected_nodes || {} );
		if( !nodes_list.length )
			nodes_list = [ node ];

		var subgraph_node = LiteGraph.createNode("graph/subgraph");
		subgraph_node.pos = node.pos.concat();
		graph.add(subgraph_node);

		subgraph_node.buildFromNodes( nodes_list );

		graphcanvas.deselectAllNodes();
        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.onMenuNodeClone = function(value, options, e, menu, node) {
        if (node.clonable == false) {
            return;
        }
        var newnode = node.clone();
        if (!newnode) {
            return;
        }
        newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];

		node.graph.beforeChange();
        node.graph.add(newnode);
		node.graph.afterChange();

        node.setDirtyCanvas(true, true);
    };

    LGraphCanvas.node_colors = {
        red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
        brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
        green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
        blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
        pale_blue: {
            color: "#2a363b",
            bgcolor: "#3f5159",
            groupcolor: "#3f789e"
        },
        cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
        purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
        yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
        black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }
    };

    LGraphCanvas.prototype.getCanvasMenuOptions = function() {
        var options = null;
        if (this.getMenuOptions) {
            options = this.getMenuOptions();
        } else {
            options = [
                {
                    content: "Add Node",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuAdd
                },
                { content: "Add Group", callback: LGraphCanvas.onGroupAdd }
                //{content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
            ];

            if (this._graph_stack && this._graph_stack.length > 0) {
                options.push(null, {
                    content: "Close subgraph",
                    callback: this.closeSubgraph.bind(this)
                });
            }
        }

        if (this.getExtraMenuOptions) {
            var extra = this.getExtraMenuOptions(this, options);
            if (extra) {
                options = options.concat(extra);
            }
        }

        return options;
    };

    //called by processContextMenu to extract the menu list
    LGraphCanvas.prototype.getNodeMenuOptions = function(node) {
        var options = null;

        if (node.getMenuOptions) {
            options = node.getMenuOptions(this);
        } else {
            options = [
                {
                    content: "Inputs",
                    has_submenu: true,
                    disabled: true,
                    callback: LGraphCanvas.showMenuNodeOptionalInputs
                },
                {
                    content: "Outputs",
                    has_submenu: true,
                    disabled: true,
                    callback: LGraphCanvas.showMenuNodeOptionalOutputs
                },
                null,
                {
                    content: "Properties",
                    has_submenu: true,
                    callback: LGraphCanvas.onShowMenuNodeProperties
                },
                null,
                {
                    content: "Title",
                    callback: LGraphCanvas.onShowPropertyEditor
                },
                {
                    content: "Mode",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeMode
                },
                {
                    content: "Resize", callback: function() {
                        if(node.resizable) 
                            return LGraphCanvas.onResizeNode;
                    }
                },
                {
                    content: "Collapse",
                    callback: LGraphCanvas.onMenuNodeCollapse
                },
                { content: "Pin", callback: LGraphCanvas.onMenuNodePin },
                {
                    content: "Colors",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeColors
                },
                {
                    content: "Shapes",
                    has_submenu: true,
                    callback: LGraphCanvas.onMenuNodeShapes
                },
                null
            ];
        }

        if (node.onGetInputs) {
            var inputs = node.onGetInputs();
            if (inputs && inputs.length) {
                options[0].disabled = false;
            }
        }

        if (node.onGetOutputs) {
            var outputs = node.onGetOutputs();
            if (outputs && outputs.length) {
                options[1].disabled = false;
            }
        }

        if (node.getExtraMenuOptions) {
            var extra = node.getExtraMenuOptions(this, options);
            if (extra) {
                extra.push(null);
                options = extra.concat(options);
            }
        }

        if (node.clonable !== false) {
            options.push({
                content: "Clone",
                callback: LGraphCanvas.onMenuNodeClone
            });
        }

		if(false) //TODO
		{}

		options.push(null, {
			content: "Remove",
			disabled: !(node.removable !== false && !node.block_delete ),
			callback: LGraphCanvas.onMenuNodeRemove
		});

        if (node.graph && node.graph.onGetNodeMenuOptions) {
            node.graph.onGetNodeMenuOptions(options, node);
        }

        return options;
    };

    LGraphCanvas.prototype.getGroupMenuOptions = function(node) {
        var o = [
            { content: "Title", callback: LGraphCanvas.onShowPropertyEditor },
            {
                content: "Color",
                has_submenu: true,
                callback: LGraphCanvas.onMenuNodeColors
            },
            {
                content: "Font size",
                property: "font_size",
                type: "Number",
                callback: LGraphCanvas.onShowPropertyEditor
            },
            null,
            { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }
        ];

        return o;
    };

    LGraphCanvas.prototype.processContextMenu = function(node, event) {
        var that = this;
        var canvas = LGraphCanvas.active_canvas;
        var ref_window = canvas.getCanvasWindow();

        var menu_info = null;
        var options = {
            event: event,
            callback: inner_option_clicked,
            extra: node
        };

		if(node)
			options.title = node.type;

        //check if mouse is in input
        var slot = null;
        if (node) {
            slot = node.getSlotInPosition(event.canvasX, event.canvasY);
            LGraphCanvas.active_node = node;
        }

        if (slot) {
            //on slot
            menu_info = [];
            if (node.getSlotMenuOptions) {
                menu_info = node.getSlotMenuOptions(slot);
            } else {
                if (
                    slot &&
                    slot.output &&
                    slot.output.links &&
                    slot.output.links.length
                ) {
                    menu_info.push({ content: "Disconnect Links", slot: slot });
                }
                var _slot = slot.input || slot.output;
                menu_info.push(
                    _slot.locked
                        ? "Cannot remove"
                        : { content: "Remove Slot", slot: slot }
                );
                menu_info.push(
                    _slot.nameLocked
                        ? "Cannot rename"
                        : { content: "Rename Slot", slot: slot }
                );
    
            }
            options.title =
                (slot.input ? slot.input.type : slot.output.type) || "*";
            if (slot.input && slot.input.type == LiteGraph.ACTION) {
                options.title = "Action";
            }
            if (slot.output && slot.output.type == LiteGraph.EVENT) {
                options.title = "Event";
            }
        } else {
            if (node) {
                //on node
                menu_info = this.getNodeMenuOptions(node);
            } else {
                menu_info = this.getCanvasMenuOptions();
                var group = this.graph.getGroupOnPos(
                    event.canvasX,
                    event.canvasY
                );
                if (group) {
                    //on group
                    menu_info.push(null, {
                        content: "Edit Group",
                        has_submenu: true,
                        submenu: {
                            title: "Group",
                            extra: group,
                            options: this.getGroupMenuOptions(group)
                        }
                    });
                }
            }
        }

        //show menu
        if (!menu_info) {
            return;
        }

        var menu = new LiteGraph.ContextMenu(menu_info, options, ref_window);

        function inner_option_clicked(v, options, e) {
            if (!v) {
                return;
            }

            if (v.content == "Remove Slot") {
                var info = v.slot;
                if (info.input) {
                    node.removeInput(info.slot);
                } else if (info.output) {
                    node.removeOutput(info.slot);
                }
                return;
            } else if (v.content == "Disconnect Links") {
                var info = v.slot;
                if (info.output) {
                    node.disconnectOutput(info.slot);
                } else if (info.input) {
                    node.disconnectInput(info.slot);
                }
                return;
            } else if (v.content == "Rename Slot") {
                var info = v.slot;
                var slot_info = info.input
                    ? node.getInputInfo(info.slot)
                    : node.getOutputInfo(info.slot);
                var dialog = that.createDialog(
                    "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
                    options
                );
                var input = dialog.querySelector("input");
                if (input && slot_info) {
                    input.value = slot_info.label || "";
                }
                dialog
                    .querySelector("button")
                    .addEventListener("click", function(e) {
                        if (input.value) {
                            if (slot_info) {
                                slot_info.label = input.value;
                            }
                            that.setDirty(true);
                        }
                        dialog.close();
                    });
            }

            //if(v.callback)
            //	return v.callback.call(that, node, options, e, menu, that, event );
        }
    };

    //API *************************************************
    //like rect but rounded corners
    if (typeof(window) != "undefined" && window.CanvasRenderingContext2D && !window.CanvasRenderingContext2D.prototype.roundRect) {
        window.CanvasRenderingContext2D.prototype.roundRect = function(
		x,
		y,
		w,
		h,
		radius,
		radius_low
	) {
		var top_left_radius = 0;
		var top_right_radius = 0;
		var bottom_left_radius = 0;
		var bottom_right_radius = 0;

		if ( radius === 0 )
		{
			this.rect(x,y,w,h);
			return;
		}

		if(radius_low === undefined)
			radius_low = radius;

		//make it compatible with official one
		if(radius != null && radius.constructor === Array)
		{
			if(radius.length == 1)
				top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0];
			else if(radius.length == 2)
			{
				top_left_radius = bottom_right_radius = radius[0];
				top_right_radius = bottom_left_radius = radius[1];
			}
			else if(radius.length == 4)
			{
				top_left_radius = radius[0];
				top_right_radius = radius[1];
				bottom_left_radius = radius[2];
				bottom_right_radius = radius[3];
			}
			else
				return;
		}
		else //old using numbers
		{
			top_left_radius = radius || 0;
			top_right_radius = radius || 0;
			bottom_left_radius = radius_low || 0;
			bottom_right_radius = radius_low || 0;
		}

		//top right
		this.moveTo(x + top_left_radius, y);
		this.lineTo(x + w - top_right_radius, y);
		this.quadraticCurveTo(x + w, y, x + w, y + top_right_radius);

		//bottom right
		this.lineTo(x + w, y + h - bottom_right_radius);
		this.quadraticCurveTo(
			x + w,
			y + h,
			x + w - bottom_right_radius,
			y + h
		);

		//bottom left
		this.lineTo(x + bottom_right_radius, y + h);
		this.quadraticCurveTo(x, y + h, x, y + h - bottom_left_radius);

		//top left
		this.lineTo(x, y + bottom_left_radius);
		this.quadraticCurveTo(x, y, x + top_left_radius, y);
	};
	}//if

    function compareObjects(a, b) {
        for (var i in a) {
            if (a[i] != b[i]) {
                return false;
            }
        }
        return true;
    }
    LiteGraph.compareObjects = compareObjects;

    function distance(a, b) {
        return Math.sqrt(
            (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
        );
    }
    LiteGraph.distance = distance;

    function colorToString(c) {
        return (
            "rgba(" +
            Math.round(c[0] * 255).toFixed() +
            "," +
            Math.round(c[1] * 255).toFixed() +
            "," +
            Math.round(c[2] * 255).toFixed() +
            "," +
            (c.length == 4 ? c[3].toFixed(2) : "1.0") +
            ")"
        );
    }
    LiteGraph.colorToString = colorToString;

    function isInsideRectangle(x, y, left, top, width, height) {
        if (left < x && left + width > x && top < y && top + height > y) {
            return true;
        }
        return false;
    }
    LiteGraph.isInsideRectangle = isInsideRectangle;

    //[minx,miny,maxx,maxy]
    function growBounding(bounding, x, y) {
        if (x < bounding[0]) {
            bounding[0] = x;
        } else if (x > bounding[2]) {
            bounding[2] = x;
        }

        if (y < bounding[1]) {
            bounding[1] = y;
        } else if (y > bounding[3]) {
            bounding[3] = y;
        }
    }
    LiteGraph.growBounding = growBounding;

    //point inside bounding box
    function isInsideBounding(p, bb) {
        if (
            p[0] < bb[0][0] ||
            p[1] < bb[0][1] ||
            p[0] > bb[1][0] ||
            p[1] > bb[1][1]
        ) {
            return false;
        }
        return true;
    }
    LiteGraph.isInsideBounding = isInsideBounding;

    //bounding overlap, format: [ startx, starty, width, height ]
    function overlapBounding(a, b) {
        var A_end_x = a[0] + a[2];
        var A_end_y = a[1] + a[3];
        var B_end_x = b[0] + b[2];
        var B_end_y = b[1] + b[3];

        if (
            a[0] > B_end_x ||
            a[1] > B_end_y ||
            A_end_x < b[0] ||
            A_end_y < b[1]
        ) {
            return false;
        }
        return true;
    }
    LiteGraph.overlapBounding = overlapBounding;

    //Convert a hex value to its decimal value - the inputted hex must be in the
    //	format of a hex triplet - the kind we use for HTML colours. The function
    //	will return an array with three values.
    function hex2num(hex) {
        if (hex.charAt(0) == "#") {
            hex = hex.slice(1);
        } //Remove the '#' char - if there is one.
        hex = hex.toUpperCase();
        var hex_alphabets = "0123456789ABCDEF";
        var value = new Array(3);
        var k = 0;
        var int1, int2;
        for (var i = 0; i < 6; i += 2) {
            int1 = hex_alphabets.indexOf(hex.charAt(i));
            int2 = hex_alphabets.indexOf(hex.charAt(i + 1));
            value[k] = int1 * 16 + int2;
            k++;
        }
        return value;
    }

    LiteGraph.hex2num = hex2num;

    //Give a array with three values as the argument and the function will return
    //	the corresponding hex triplet.
    function num2hex(triplet) {
        var hex_alphabets = "0123456789ABCDEF";
        var hex = "#";
        var int1, int2;
        for (var i = 0; i < 3; i++) {
            int1 = triplet[i] / 16;
            int2 = triplet[i] % 16;

            hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);
        }
        return hex;
    }

    LiteGraph.num2hex = num2hex;

    /* LiteGraph GUI elements used for canvas editing *************************************/

    /**
     * ContextMenu from LiteGUI
     *
     * @class ContextMenu
     * @constructor
     * @param {Array} values (allows object { title: "Nice text", callback: function ... })
     * @param {Object} options [optional] Some options:\
     * - title: title to show on top of the menu
     * - callback: function to call when an option is clicked, it receives the item information
     * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback
     * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position
     */
    function ContextMenu(values, options) {
        options = options || {};
        this.options = options;
        var that = this;

        //to link a menu with its parent
        if (options.parentMenu) {
            if (options.parentMenu.constructor !== this.constructor) {
                console.error(
                    "parentMenu must be of class ContextMenu, ignoring it"
                );
                options.parentMenu = null;
            } else {
                this.parentMenu = options.parentMenu;
                this.parentMenu.lock = true;
                this.parentMenu.current_submenu = this;
            }
        }

		var eventClass = null;
		if(options.event) //use strings because comparing classes between windows doesnt work
			eventClass = options.event.constructor.name;
        if ( eventClass !== "MouseEvent" &&
            eventClass !== "CustomEvent" &&
			eventClass !== "PointerEvent"
        ) {
            console.error(
                "Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it."
            );
            options.event = null;
        }

        var root = document.createElement("div");
        root.className = "litegraph litecontextmenu litemenubar-panel";
        if (options.className) {
            root.className += " " + options.className;
        }
        root.style.minWidth = 100;
        root.style.minHeight = 100;
        root.style.pointerEvents = "none";
        setTimeout(function() {
            root.style.pointerEvents = "auto";
        }, 100); //delay so the mouse up event is not caught by this element

        //this prevents the default context browser menu to open in case this menu was created when pressing right button
        root.addEventListener(
            "mouseup",
            function(e) {
                e.preventDefault();
                return true;
            },
            true
        );
        root.addEventListener(
            "contextmenu",
            function(e) {
                if (e.button != 2) {
                    //right button
                    return false;
                }
                e.preventDefault();
                return false;
            },
            true
        );

        root.addEventListener(
            "mousedown",
            function(e) {
                if (e.button == 2) {
                    that.close();
                    e.preventDefault();
                    return true;
                }
            },
            true
        );

        function on_mouse_wheel(e) {
            var pos = parseInt(root.style.top);
            root.style.top =
                (pos + e.deltaY * options.scroll_speed).toFixed() + "px";
            e.preventDefault();
            return true;
        }

        if (!options.scroll_speed) {
            options.scroll_speed = 0.1;
        }

        root.addEventListener("wheel", on_mouse_wheel, true);
        root.addEventListener("mousewheel", on_mouse_wheel, true);

        this.root = root;

        //title
        if (options.title) {
            var element = document.createElement("div");
            element.className = "litemenu-title";
            element.innerHTML = options.title;
            root.appendChild(element);
        }

        //entries
        var num = 0;
        for (var i=0; i < values.length; i++) {
            var name = values.constructor == Array ? values[i] : i;
            if (name != null && name.constructor !== String) {
                name = name.content === undefined ? String(name) : name.content;
            }
            var value = values[i];
            this.addItem(name, value, options);
            num++;
        }

        //close on leave
        root.addEventListener("mouseleave", function(e) {
            if (that.lock) {
                return;
            }
            if (root.closing_timer) {
                clearTimeout(root.closing_timer);
            }
            root.closing_timer = setTimeout(that.close.bind(that, e), 500);
            //that.close(e);
        });

        root.addEventListener("mouseenter", function(e) {
            if (root.closing_timer) {
                clearTimeout(root.closing_timer);
            }
        });

        //insert before checking position
        var root_document = document;
        if (options.event) {
            root_document = options.event.target.ownerDocument;
        }

        if (!root_document) {
            root_document = document;
        }

		if( root_document.fullscreenElement )
	        root_document.fullscreenElement.appendChild(root);
		else
		    root_document.body.appendChild(root);

        //compute best position
        var left = options.left || 0;
        var top = options.top || 0;
        if (options.event) {
            left = options.event.clientX - 10;
            top = options.event.clientY - 10;
            if (options.title) {
                top -= 20;
            }

            if (options.parentMenu) {
                var rect = options.parentMenu.root.getBoundingClientRect();
                left = rect.left + rect.width;
            }

            var body_rect = document.body.getBoundingClientRect();
            var root_rect = root.getBoundingClientRect();
			if(body_rect.height == 0)
				console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");

            if (body_rect.width && left > body_rect.width - root_rect.width - 10) {
                left = body_rect.width - root_rect.width - 10;
            }
            if (body_rect.height && top > body_rect.height - root_rect.height - 10) {
                top = body_rect.height - root_rect.height - 10;
            }
        }

        root.style.left = left + "px";
        root.style.top = top + "px";

        if (options.scale) {
            root.style.transform = "scale(" + options.scale + ")";
        }
    }

    ContextMenu.prototype.addItem = function(name, value, options) {
        var that = this;
        options = options || {};

        var element = document.createElement("div");
        element.className = "litemenu-entry submenu";

        var disabled = false;

        if (value === null) {
            element.classList.add("separator");
            //element.innerHTML = "<hr/>"
            //continue;
        } else {
            element.innerHTML = value && value.title ? value.title : name;
            element.value = value;

            if (value) {
                if (value.disabled) {
                    disabled = true;
                    element.classList.add("disabled");
                }
                if (value.submenu || value.has_submenu) {
                    element.classList.add("has_submenu");
                }
            }

            if (typeof value == "function") {
                element.dataset["value"] = name;
                element.onclick_callback = value;
            } else {
                element.dataset["value"] = value;
            }

            if (value.className) {
                element.className += " " + value.className;
            }
        }

        this.root.appendChild(element);
        if (!disabled) {
            element.addEventListener("click", inner_onclick);
        }
        if (options.autoopen) {
            element.addEventListener("mouseenter", inner_over);
        }

        function inner_over(e) {
            var value = this.value;
            if (!value || !value.has_submenu) {
                return;
            }
            //if it is a submenu, autoopen like the item was clicked
            inner_onclick.call(this, e);
        }

        //menu option clicked
        function inner_onclick(e) {
            var value = this.value;
            var close_parent = true;

            if (that.current_submenu) {
                that.current_submenu.close(e);
            }

            //global callback
            if (options.callback) {
                var r = options.callback.call(
                    this,
                    value,
                    options,
                    e,
                    that,
                    options.node
                );
                if (r === true) {
                    close_parent = false;
                }
            }

            //special cases
            if (value) {
                if (
                    value.callback &&
                    !options.ignore_item_callbacks &&
                    value.disabled !== true
                ) {
                    //item callback
                    var r = value.callback.call(
                        this,
                        value,
                        options,
                        e,
                        that,
                        options.extra
                    );
                    if (r === true) {
                        close_parent = false;
                    }
                }
                if (value.submenu) {
                    if (!value.submenu.options) {
                        throw "ContextMenu submenu needs options";
                    }
                    var submenu = new that.constructor(value.submenu.options, {
                        callback: value.submenu.callback,
                        event: e,
                        parentMenu: that,
                        ignore_item_callbacks:
                            value.submenu.ignore_item_callbacks,
                        title: value.submenu.title,
                        extra: value.submenu.extra,
                        autoopen: options.autoopen
                    });
                    close_parent = false;
                }
            }

            if (close_parent && !that.lock) {
                that.close();
            }
        }

        return element;
    };

    ContextMenu.prototype.close = function(e, ignore_parent_menu) {
        if (this.root.parentNode) {
            this.root.parentNode.removeChild(this.root);
        }
        if (this.parentMenu && !ignore_parent_menu) {
            this.parentMenu.lock = false;
            this.parentMenu.current_submenu = null;
            if (e === undefined) {
                this.parentMenu.close();
            } else if (
                e &&
                !ContextMenu.isCursorOverElement(e, this.parentMenu.root)
            ) {
                ContextMenu.trigger(this.parentMenu.root, "mouseleave", e);
            }
        }
        if (this.current_submenu) {
            this.current_submenu.close(e, true);
        }

        if (this.root.closing_timer) {
            clearTimeout(this.root.closing_timer);
        }
    };

    //this code is used to trigger events easily (used in the context menu mouseleave
    ContextMenu.trigger = function(element, event_name, params, origin) {
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event_name, true, true, params); //canBubble, cancelable, detail
        evt.srcElement = origin;
        if (element.dispatchEvent) {
            element.dispatchEvent(evt);
        } else if (element.__events) {
            element.__events.dispatchEvent(evt);
        }
        //else nothing seems binded here so nothing to do
        return evt;
    };

    //returns the top most menu
    ContextMenu.prototype.getTopMenu = function() {
        if (this.options.parentMenu) {
            return this.options.parentMenu.getTopMenu();
        }
        return this;
    };

    ContextMenu.prototype.getFirstEvent = function() {
        if (this.options.parentMenu) {
            return this.options.parentMenu.getFirstEvent();
        }
        return this.options.event;
    };

    ContextMenu.isCursorOverElement = function(event, element) {
        var left = event.clientX;
        var top = event.clientY;
        var rect = element.getBoundingClientRect();
        if (!rect) {
            return false;
        }
        if (
            top > rect.top &&
            top < rect.top + rect.height &&
            left > rect.left &&
            left < rect.left + rect.width
        ) {
            return true;
        }
        return false;
    };

    LiteGraph.ContextMenu = ContextMenu;

    LiteGraph.closeAllContextMenus = function(ref_window) {
        ref_window = ref_window || window;

        var elements = ref_window.document.querySelectorAll(".litecontextmenu");
        if (!elements.length) {
            return;
        }

        var result = [];
        for (var i = 0; i < elements.length; i++) {
            result.push(elements[i]);
        }

        for (var i=0; i < result.length; i++) {
            if (result[i].close) {
                result[i].close();
            } else if (result[i].parentNode) {
                result[i].parentNode.removeChild(result[i]);
            }
        }
    };

    LiteGraph.extendClass = function(target, origin) {
        for (var i in origin) {
            //copy class properties
            if (target.hasOwnProperty(i)) {
                continue;
            }
            target[i] = origin[i];
        }

        if (origin.prototype) {
            //copy prototype properties
            for (var i in origin.prototype) {
                //only enumerable
                if (!origin.prototype.hasOwnProperty(i)) {
                    continue;
                }

                if (target.prototype.hasOwnProperty(i)) {
                    //avoid overwriting existing ones
                    continue;
                }

                //copy getters
                if (origin.prototype.__lookupGetter__(i)) {
                    target.prototype.__defineGetter__(
                        i,
                        origin.prototype.__lookupGetter__(i)
                    );
                } else {
                    target.prototype[i] = origin.prototype[i];
                }

                //and setters
                if (origin.prototype.__lookupSetter__(i)) {
                    target.prototype.__defineSetter__(
                        i,
                        origin.prototype.__lookupSetter__(i)
                    );
                }
            }
        }
    };

	//used by some widgets to render a curve editor
	function CurveEditor( points )
	{
		this.points = points;
		this.selected = -1;
		this.nearest = -1;
		this.size = null; //stores last size used
		this.must_update = true;
		this.margin = 5;
	}

	CurveEditor.sampleCurve = function(f,points)
	{
		if(!points)
			return;
		for(var i = 0; i < points.length - 1; ++i)
		{
			var p = points[i];
			var pn = points[i+1];
			if(pn[0] < f)
				continue;
			var r = (pn[0] - p[0]);
			if( Math.abs(r) < 0.00001 )
				return p[1];
			var local_f = (f - p[0]) / r;
			return p[1] * (1.0 - local_f) + pn[1] * local_f;
		}
		return 0;
	}

	CurveEditor.prototype.draw = function( ctx, size, graphcanvas, background_color, line_color, inactive )
	{
		var points = this.points;
		if(!points)
			return;
		this.size = size;
		var w = size[0] - this.margin * 2;
		var h = size[1] - this.margin * 2;

		line_color = line_color || "#666";

		ctx.save();
		ctx.translate(this.margin,this.margin);

		if(background_color)
		{
			ctx.fillStyle = "#111";
			ctx.fillRect(0,0,w,h);
			ctx.fillStyle = "#222";
			ctx.fillRect(w*0.5,0,1,h);
			ctx.strokeStyle = "#333";
			ctx.strokeRect(0,0,w,h);
		}
		ctx.strokeStyle = line_color;
		if(inactive)
			ctx.globalAlpha = 0.5;
		ctx.beginPath();
		for(var i = 0; i < points.length; ++i)
		{
			var p = points[i];
			ctx.lineTo( p[0] * w, (1.0 - p[1]) * h );
		}
		ctx.stroke();
		ctx.globalAlpha = 1;
		if(!inactive)
			for(var i = 0; i < points.length; ++i)
			{
				var p = points[i];
				ctx.fillStyle = this.selected == i ? "#FFF" : (this.nearest == i ? "#DDD" : "#AAA");
				ctx.beginPath();
				ctx.arc( p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2 );
				ctx.fill();
			}
		ctx.restore();
	}

	//localpos is mouse in curve editor space
	CurveEditor.prototype.onMouseDown = function( localpos, graphcanvas )
	{
		var points = this.points;
		if(!points)
			return;
		if( localpos[1] < 0 )
			return;

		//this.captureInput(true);
		var w = this.size[0] - this.margin * 2;
		var h = this.size[1] - this.margin * 2;
		var x = localpos[0] - this.margin;
		var y = localpos[1] - this.margin;
		var pos = [x,y];
		var max_dist = 30 / graphcanvas.ds.scale;
		//search closer one
		this.selected = this.getCloserPoint(pos, max_dist);
		//create one
		if(this.selected == -1)
		{
			var point = [x / w, 1 - y / h];
			points.push(point);
			points.sort(function(a,b){ return a[0] - b[0]; });
			this.selected = points.indexOf(point);
			this.must_update = true;
		}
		if(this.selected != -1)
			return true;
	}

	CurveEditor.prototype.onMouseMove = function( localpos, graphcanvas )
	{
		var points = this.points;
		if(!points)
			return;
		var s = this.selected;
		if(s < 0)
			return;
		var x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2 );
		var y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2 );
		var curvepos = [(localpos[0] - this.margin),(localpos[1] - this.margin)];
		var max_dist = 30 / graphcanvas.ds.scale;
		this._nearest = this.getCloserPoint(curvepos, max_dist);
		var point = points[s];
		if(point)
		{
			var is_edge_point = s == 0 || s == points.length - 1;
			if( !is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10) )
			{
				points.splice(s,1);
				this.selected = -1;
				return;
			}
			if( !is_edge_point ) //not edges
				point[0] = Math.clamp(x,0,1);
			else
				point[0] = s == 0 ? 0 : 1;
			point[1] = 1.0 - Math.clamp(y,0,1);
			points.sort(function(a,b){ return a[0] - b[0]; });
			this.selected = points.indexOf(point);
			this.must_update = true;
		}
	}

	CurveEditor.prototype.onMouseUp = function( localpos, graphcanvas )
	{
		this.selected = -1;
		return false;
	}

	CurveEditor.prototype.getCloserPoint = function(pos, max_dist)
	{
		var points = this.points;
		if(!points)
			return -1;
		max_dist = max_dist || 30;
		var w = (this.size[0] - this.margin * 2);
		var h = (this.size[1] - this.margin * 2);
		var num = points.length;
		var p2 = [0,0];
		var min_dist = 1000000;
		var closest = -1;
		var last_valid = -1;
		for(var i = 0; i < num; ++i)
		{
			var p = points[i];
			p2[0] = p[0] * w;
			p2[1] = (1.0 - p[1]) * h;
			if(p2[0] < pos[0])
				last_valid = i;
			var dist = vec2.distance(pos,p2);
			if(dist > min_dist || dist > max_dist)
				continue;
			closest = i;
			min_dist = dist;
		}
		return closest;
	}

	LiteGraph.CurveEditor = CurveEditor;

    //used to create nodes from wrapping functions
    LiteGraph.getParameterNames = function(func) {
        return (func + "")
            .replace(/[/][/].*$/gm, "") // strip single-line comments
            .replace(/\s+/g, "") // strip white space
            .replace(/[/][*][^/*]*[*][/]/g, "") // strip multi-line comments  /**/
            .split("){", 1)[0]
            .replace(/^[^(]*[(]/, "") // extract the parameters
            .replace(/=[^,]+/g, "") // strip any ES6 defaults
            .split(",")
            .filter(Boolean); // split & filter [""]
    };

    Math.clamp = function(v, a, b) {
        return a > v ? a : b < v ? b : v;
    };

    if (typeof window != "undefined" && !window["requestAnimationFrame"]) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    }
})(this);

if (true) {
    exports.LiteGraph = this.LiteGraph;
}

//basic nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    //Constant
    function Time() {
        this.addOutput("in ms", "number");
        this.addOutput("in sec", "number");
    }

    Time.title = "Time";
    Time.desc = "Time";

    Time.prototype.onExecute = function() {
        this.setOutputData(0, this.graph.globaltime * 1000);
        this.setOutputData(1, this.graph.globaltime);
    };

    LiteGraph.registerNodeType("basic/time", Time);

    //Subgraph: a node that contains a graph
    function Subgraph() {
        var that = this;
        this.size = [140, 80];
        this.properties = { enabled: true };
        this.enabled = true;

        //create inner graph
        this.subgraph = new LiteGraph.LGraph();
        this.subgraph._subgraph_node = this;
        this.subgraph._is_subgraph = true;

        this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);

		//nodes input node added inside
        this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);
        this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);
        this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);
        this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);

        this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);
        this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);
        this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);
        this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
    }

    Subgraph.title = "Subgraph";
    Subgraph.desc = "Graph inside a node";
    Subgraph.title_color = "#334";

    Subgraph.prototype.onGetInputs = function() {
        return [["enabled", "boolean"]];
    };

	/*
    Subgraph.prototype.onDrawTitle = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.fillStyle = "#555";
        var w = LiteGraph.NODE_TITLE_HEIGHT;
        var x = this.size[0] - w;
        ctx.fillRect(x, -w, w, w);
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(x + w * 0.2, -w * 0.6);
        ctx.lineTo(x + w * 0.8, -w * 0.6);
        ctx.lineTo(x + w * 0.5, -w * 0.3);
        ctx.fill();
    };
	*/

    Subgraph.prototype.onDblClick = function(e, pos, graphcanvas) {
        var that = this;
        setTimeout(function() {
            graphcanvas.openSubgraph(that.subgraph);
        }, 10);
    };

	/*
    Subgraph.prototype.onMouseDown = function(e, pos, graphcanvas) {
        if (
            !this.flags.collapsed &&
            pos[0] > this.size[0] - LiteGraph.NODE_TITLE_HEIGHT &&
            pos[1] < 0
        ) {
            var that = this;
            setTimeout(function() {
                graphcanvas.openSubgraph(that.subgraph);
            }, 10);
        }
    };
	*/

    Subgraph.prototype.onAction = function(action, param) {
        this.subgraph.onAction(action, param);
    };

    Subgraph.prototype.onExecute = function() {
        this.enabled = this.getInputOrProperty("enabled");
        if (!this.enabled) {
            return;
        }

        //send inputs to subgraph global inputs
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var value = this.getInputData(i);
                this.subgraph.setInputData(input.name, value);
            }
        }

        //execute
        this.subgraph.runStep();

        //send subgraph global outputs to outputs
        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                var value = this.subgraph.getOutputData(output.name);
                this.setOutputData(i, value);
            }
        }
    };

    Subgraph.prototype.sendEventToAllNodes = function(eventname, param, mode) {
        if (this.enabled) {
            this.subgraph.sendEventToAllNodes(eventname, param, mode);
        }
    };

	Subgraph.prototype.onDrawBackground = function(ctx, graphcanvas, canvas, pos)
	{
		if(this.flags.collapsed)
			return;

		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;

		//button
		var over = LiteGraph.isInsideRectangle(pos[0],pos[1],this.pos[0],this.pos[1] + y,this.size[0],LiteGraph.NODE_TITLE_HEIGHT);
		ctx.fillStyle = over ? "#555" : "#222";
		ctx.beginPath();
		if (this._shape == LiteGraph.BOX_SHAPE)
			ctx.rect(0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT);
		else
			ctx.roundRect( 0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT, 0, 8);
		ctx.fill();

		//button
		ctx.textAlign = "center";
		ctx.font = "24px Arial";
		ctx.fillStyle = over ? "#DDD" : "#999";
		ctx.fillText( "+", this.size[0] * 0.5, y + 24 );
	}

	Subgraph.prototype.onMouseDown = function(e, localpos, graphcanvas)
	{
		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
		if(localpos[1] > y)
		{
			graphcanvas.showSubgraphPropertiesDialog(this);
		}
	}

	Subgraph.prototype.computeSize = function()
	{
		var num_inputs = this.inputs ? this.inputs.length : 0;
		var num_outputs = this.outputs ? this.outputs.length : 0;
		return [ 200, Math.max(num_inputs,num_outputs) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT ];
	}

    //**** INPUTS ***********************************
    Subgraph.prototype.onSubgraphTrigger = function(event, param) {
        var slot = this.findOutputSlot(event);
        if (slot != -1) {
            this.triggerSlot(slot);
        }
    };

    Subgraph.prototype.onSubgraphNewInput = function(name, type) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            //add input to the node
            this.addInput(name, type);
        }
    };

    Subgraph.prototype.onSubgraphRenamedInput = function(oldname, name) {
        var slot = this.findInputSlot(oldname);
        if (slot == -1) {
            return;
        }
        var info = this.getInputInfo(slot);
        info.name = name;
    };

    Subgraph.prototype.onSubgraphTypeChangeInput = function(name, type) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        var info = this.getInputInfo(slot);
        info.type = type;
    };

    Subgraph.prototype.onSubgraphRemovedInput = function(name) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        this.removeInput(slot);
    };

    //**** OUTPUTS ***********************************
    Subgraph.prototype.onSubgraphNewOutput = function(name, type) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            this.addOutput(name, type);
        }
    };

    Subgraph.prototype.onSubgraphRenamedOutput = function(oldname, name) {
        var slot = this.findOutputSlot(oldname);
        if (slot == -1) {
            return;
        }
        var info = this.getOutputInfo(slot);
        info.name = name;
    };

    Subgraph.prototype.onSubgraphTypeChangeOutput = function(name, type) {
        var slot = this.findOutputSlot(name);
        if (slot == -1) {
            return;
        }
        var info = this.getOutputInfo(slot);
        info.type = type;
    };

    Subgraph.prototype.onSubgraphRemovedOutput = function(name) {
        var slot = this.findInputSlot(name);
        if (slot == -1) {
            return;
        }
        this.removeOutput(slot);
    };
    // *****************************************************

    Subgraph.prototype.getExtraMenuOptions = function(graphcanvas) {
        var that = this;
        return [
            {
                content: "Open",
                callback: function() {
                    graphcanvas.openSubgraph(that.subgraph);
                }
            }
        ];
    };

    Subgraph.prototype.onResize = function(size) {
        size[1] += 20;
    };

    Subgraph.prototype.serialize = function() {
        var data = LiteGraph.LGraphNode.prototype.serialize.call(this);
        data.subgraph = this.subgraph.serialize();
        return data;
    };
    //no need to define node.configure, the default method detects node.subgraph and passes the object to node.subgraph.configure()

    Subgraph.prototype.clone = function() {
        var node = LiteGraph.createNode(this.type);
        var data = this.serialize();
        delete data["id"];
        delete data["inputs"];
        delete data["outputs"];
        node.configure(data);
        return node;
    };

	Subgraph.prototype.buildFromNodes = function(nodes)
	{
		//clear all?
		//TODO

		//nodes that connect data between parent graph and subgraph
		var subgraph_inputs = [];
		var subgraph_outputs = [];

		//mark inner nodes
		var ids = {};
		var min_x = 0;
		var max_x = 0;
		for(var i = 0; i < nodes.length; ++i)
		{
			var node = nodes[i];
			ids[ node.id ] = node;
			min_x = Math.min( node.pos[0], min_x );
			max_x = Math.max( node.pos[0], min_x );
		}
		
		var last_input_y = 0;
		var last_output_y = 0;

		for(var i = 0; i < nodes.length; ++i)
		{
			var node = nodes[i];
			//check inputs
			if( node.inputs )
				for(var j = 0; j < node.inputs.length; ++j)
				{
					var input = node.inputs[j];
					if( !input || !input.link )
						continue;
					var link = node.graph.links[ input.link ];
					if(!link)
						continue;
					if( ids[ link.origin_id ] )
						continue;
					//this.addInput(input.name,link.type);
					this.subgraph.addInput(input.name,link.type);
					/*
					var input_node = LiteGraph.createNode("graph/input");
					this.subgraph.add( input_node );
					input_node.pos = [min_x - 200, last_input_y ];
					last_input_y += 100;
					*/
				}

			//check outputs
			if( node.outputs )
				for(var j = 0; j < node.outputs.length; ++j)
				{
					var output = node.outputs[j];
					if( !output || !output.links || !output.links.length )
						continue;
					var is_external = false;
					for(var k = 0; k < output.links.length; ++k)
					{
						var link = node.graph.links[ output.links[k] ];
						if(!link)
							continue;
						if( ids[ link.target_id ] )
							continue;
						is_external = true;
						break;
					}
					if(!is_external)
						continue;
					//this.addOutput(output.name,output.type);
					/*
					var output_node = LiteGraph.createNode("graph/output");
					this.subgraph.add( output_node );
					output_node.pos = [max_x + 50, last_output_y ];
					last_output_y += 100;
					*/
				}
		}

		//detect inputs and outputs
			//split every connection in two data_connection nodes
			//keep track of internal connections
			//connect external connections

		//clone nodes inside subgraph and try to reconnect them

		//connect edge subgraph nodes to extarnal connections nodes
	}

    LiteGraph.Subgraph = Subgraph;
    LiteGraph.registerNodeType("graph/subgraph", Subgraph);

    //Input for a subgraph
    function GraphInput() {
        this.addOutput("", "number");

        this.name_in_graph = "";
        this.properties = {
			name: "",
			type: "number",
			value: 0
		}; 

        var that = this;

        this.name_widget = this.addWidget(
            "text",
            "Name",
            this.properties.name,
            function(v) {
                if (!v) {
                    return;
                }
                that.setProperty("name",v);
            }
        );
        this.type_widget = this.addWidget(
            "text",
            "Type",
            this.properties.type,
            function(v) {
				that.setProperty("type",v);
            }
        );

        this.value_widget = this.addWidget(
            "number",
            "Value",
            this.properties.value,
            function(v) {
                that.setProperty("value",v);
            }
        );

        this.widgets_up = true;
        this.size = [180, 90];
    }

    GraphInput.title = "Input";
    GraphInput.desc = "Input of the graph";

	GraphInput.prototype.onConfigure = function()
	{
		this.updateType();
	}

	//ensures the type in the node output and the type in the associated graph input are the same
	GraphInput.prototype.updateType = function()
	{
		var type = this.properties.type;
		this.type_widget.value = type;

		//update output
		if(this.outputs[0].type != type)
		{
	        if (!LiteGraph.isValidConnection(this.outputs[0].type,type))
				this.disconnectOutput(0);
			this.outputs[0].type = type;
		}

		//update widget
		if(type == "number")
		{
			this.value_widget.type = "number";
			this.value_widget.value = 0;
		}
		else if(type == "boolean")
		{
			this.value_widget.type = "toggle";
			this.value_widget.value = true;
		}
		else if(type == "string")
		{
			this.value_widget.type = "text";
			this.value_widget.value = "";
		}
		else
		{
			this.value_widget.type = null;
			this.value_widget.value = null;
		}
		this.properties.value = this.value_widget.value;

		//update graph
		if (this.graph && this.name_in_graph) {
			this.graph.changeInputType(this.name_in_graph, type);
		}
	}

	//this is executed AFTER the property has changed
	GraphInput.prototype.onPropertyChanged = function(name,v)
	{
		if( name == "name" )
		{
			if (v == "" || v == this.name_in_graph || v == "enabled") {
				return false;
			}
			if(this.graph)
			{
				if (this.name_in_graph) {
					//already added
					this.graph.renameInput( this.name_in_graph, v );
				} else {
					this.graph.addInput( v, this.properties.type );
				}
			} //what if not?!
			this.name_widget.value = v;
			this.name_in_graph = v;
		}
		else if( name == "type" )
		{
			this.updateType();
		}
		else if( name == "value" )
		{
		}
	}

    GraphInput.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.name;
        }
        return this.title;
    };

    GraphInput.prototype.onAction = function(action, param) {
        if (this.properties.type == LiteGraph.EVENT) {
            this.triggerSlot(0, param);
        }
    };

    GraphInput.prototype.onExecute = function() {
        var name = this.properties.name;
        //read from global input
        var data = this.graph.inputs[name];
        if (!data) {
            this.setOutputData(0, this.properties.value );
			return;
        }

        this.setOutputData(0, data.value !== undefined ? data.value : this.properties.value );
    };

    GraphInput.prototype.onRemoved = function() {
        if (this.name_in_graph) {
            this.graph.removeInput(this.name_in_graph);
        }
    };

    LiteGraph.GraphInput = GraphInput;
    LiteGraph.registerNodeType("graph/input", GraphInput);

    //Output for a subgraph
    function GraphOutput() {
        this.addInput("", "");

        this.name_in_graph = "";
        this.properties = {};
        var that = this;

        Object.defineProperty(this.properties, "name", {
            get: function() {
                return that.name_in_graph;
            },
            set: function(v) {
                if (v == "" || v == that.name_in_graph) {
                    return;
                }
                if (that.name_in_graph) {
                    //already added
                    that.graph.renameOutput(that.name_in_graph, v);
                } else {
                    that.graph.addOutput(v, that.properties.type);
                }
                that.name_widget.value = v;
                that.name_in_graph = v;
            },
            enumerable: true
        });

        Object.defineProperty(this.properties, "type", {
            get: function() {
                return that.inputs[0].type;
            },
            set: function(v) {
                if (v == "action" || v == "event") {
                    v = LiteGraph.ACTION;
                }
		        if (!LiteGraph.isValidConnection(that.inputs[0].type,v))
					that.disconnectInput(0);
                that.inputs[0].type = v;
                if (that.name_in_graph) {
                    //already added
                    that.graph.changeOutputType(
                        that.name_in_graph,
                        that.inputs[0].type
                    );
                }
                that.type_widget.value = v || "";
            },
            enumerable: true
        });

        this.name_widget = this.addWidget("text","Name",this.properties.name,"name");
        this.type_widget = this.addWidget("text","Type",this.properties.type,"type");
        this.widgets_up = true;
        this.size = [180, 60];
    }

    GraphOutput.title = "Output";
    GraphOutput.desc = "Output of the graph";

    GraphOutput.prototype.onExecute = function() {
        this._value = this.getInputData(0);
        this.graph.setOutputData(this.properties.name, this._value);
    };

    GraphOutput.prototype.onAction = function(action, param) {
        if (this.properties.type == LiteGraph.ACTION) {
            this.graph.trigger(this.properties.name, param);
        }
    };

    GraphOutput.prototype.onRemoved = function() {
        if (this.name_in_graph) {
            this.graph.removeOutput(this.name_in_graph);
        }
    };

    GraphOutput.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.name;
        }
        return this.title;
    };

    LiteGraph.GraphOutput = GraphOutput;
    LiteGraph.registerNodeType("graph/output", GraphOutput);

    //Constant
    function ConstantNumber() {
        this.addOutput("value", "number");
        this.addProperty("value", 1.0);
        this.widget = this.addWidget("number","value",1,"value");
        this.widgets_up = true;
        this.size = [180, 30];
    }

    ConstantNumber.title = "Const Number";
    ConstantNumber.desc = "Constant number";

    ConstantNumber.prototype.onExecute = function() {
        this.setOutputData(0, parseFloat(this.properties["value"]));
    };

    ConstantNumber.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.value;
        }
        return this.title;
    };

	ConstantNumber.prototype.setValue = function(v)
	{
		this.setProperty("value",v);
	}

    ConstantNumber.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.outputs[0].label = this.properties["value"].toFixed(3);
    };

    LiteGraph.registerNodeType("basic/const", ConstantNumber);

    function ConstantBoolean() {
        this.addOutput("", "boolean");
        this.addProperty("value", true);
        this.widget = this.addWidget("toggle","value",true,"value");
        this.widgets_up = true;
        this.size = [140, 30];
    }

    ConstantBoolean.title = "Const Boolean";
    ConstantBoolean.desc = "Constant boolean";
    ConstantBoolean.prototype.getTitle = ConstantNumber.prototype.getTitle;

    ConstantBoolean.prototype.onExecute = function() {
        this.setOutputData(0, this.properties["value"]);
    };

	ConstantBoolean.prototype.setValue = ConstantNumber.prototype.setValue;

	ConstantBoolean.prototype.onGetInputs = function() {
		return [["toggle", LiteGraph.ACTION]];
	};

	ConstantBoolean.prototype.onAction = function(action)
	{
		this.setValue( !this.properties.value );
	}

    LiteGraph.registerNodeType("basic/boolean", ConstantBoolean);

    function ConstantString() {
        this.addOutput("", "string");
        this.addProperty("value", "");
        this.widget = this.addWidget("text","value","","value");  //link to property value
        this.widgets_up = true;
        this.size = [180, 30];
    }

    ConstantString.title = "Const String";
    ConstantString.desc = "Constant string";

    ConstantString.prototype.getTitle = ConstantNumber.prototype.getTitle;

    ConstantString.prototype.onExecute = function() {
        this.setOutputData(0, this.properties["value"]);
    };

	ConstantString.prototype.setValue = ConstantNumber.prototype.setValue;

	ConstantString.prototype.onDropFile = function(file)
	{
		var that = this;
		var reader = new FileReader();
		reader.onload = function(e)
		{
			that.setProperty("value",e.target.result);
		}
		reader.readAsText(file);
	}

    LiteGraph.registerNodeType("basic/string", ConstantString);

    function ConstantObject() {
        this.addOutput("obj", "object");
        this.size = [120, 30];
		this._object = {};
    }

    ConstantObject.title = "Const Object";
    ConstantObject.desc = "Constant Object";

    ConstantObject.prototype.onExecute = function() {
        this.setOutputData(0, this._object);
    };

    LiteGraph.registerNodeType( "basic/object", ConstantObject );

    function ConstantFile() {
        this.addInput("url", "");
        this.addOutput("", "");
        this.addProperty("url", "");
        this.addProperty("type", "text");
        this.widget = this.addWidget("text","url","","url");
        this._data = null;
    }

    ConstantFile.title = "Const File";
    ConstantFile.desc = "Fetches a file from an url";
    ConstantFile["@type"] = { type: "enum", values: ["text","arraybuffer","blob","json"] };

    ConstantFile.prototype.onPropertyChanged = function(name, value) {
        if (name == "url")
		{
			if( value == null || value == "")
				this._data = null;
			else
			{
				this.fetchFile(value);
			}
		}
	}

    ConstantFile.prototype.onExecute = function() {
		var url = this.getInputData(0) || this.properties.url;
		if(url && (url != this._url || this._type != this.properties.type))
			this.fetchFile(url);
        this.setOutputData(0, this._data );
    };

	ConstantFile.prototype.setValue = ConstantNumber.prototype.setValue;

    ConstantFile.prototype.fetchFile = function(url) {
		var that = this;
		if(!url || url.constructor !== String)
		{
			that._data = null;
            that.boxcolor = null;
			return;
		}

		this._url = url;
		this._type = this.properties.type;
        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }
		fetch(url)
		.then(function(response) {
			if(!response.ok)
				 throw new Error("File not found");

			if(that.properties.type == "arraybuffer")
				return response.arrayBuffer();
			else if(that.properties.type == "text")
				return response.text();
			else if(that.properties.type == "json")
				return response.json();
			else if(that.properties.type == "blob")
				return response.blob();
		})
		.then(function(data) {
			that._data = data;
            that.boxcolor = "#AEA";
		})
		.catch(function(error) {
			that._data = null;
            that.boxcolor = "red";
			console.error("error fetching file:",url);
		});
    };

	ConstantFile.prototype.onDropFile = function(file)
	{
		var that = this;
		this._url = file.name;
		this._type = this.properties.type;
		this.properties.url = file.name;
		var reader = new FileReader();
		reader.onload = function(e)
		{
            that.boxcolor = "#AEA";
			var v = e.target.result;
			if( that.properties.type == "json" )
				v = JSON.parse(v);
			that._data = v;
		}
		if(that.properties.type == "arraybuffer")
			reader.readAsArrayBuffer(file);
		else if(that.properties.type == "text" || that.properties.type == "json")
			reader.readAsText(file);
		else if(that.properties.type == "blob")
			return reader.readAsBinaryString(file);
	}

    LiteGraph.registerNodeType("basic/file", ConstantFile);

	//to store json objects
    function ConstantData() {
        this.addOutput("", "");
        this.addProperty("value", "");
        this.widget = this.addWidget("text","json","","value");
        this.widgets_up = true;
        this.size = [140, 30];
        this._value = null;
    }

    ConstantData.title = "Const Data";
    ConstantData.desc = "Constant Data";

    ConstantData.prototype.onPropertyChanged = function(name, value) {
        this.widget.value = value;
        if (value == null || value == "") {
            return;
        }

        try {
            this._value = JSON.parse(value);
            this.boxcolor = "#AEA";
        } catch (err) {
            this.boxcolor = "red";
        }
    };

    ConstantData.prototype.onExecute = function() {
        this.setOutputData(0, this._value);
    };

	ConstantData.prototype.setValue = ConstantNumber.prototype.setValue;

    LiteGraph.registerNodeType("basic/data", ConstantData);

	//to store json objects
    function ConstantArray() {
        this._value = [];
        this.addInput("", "");
        this.addOutput("", "array");
        this.addOutput("length", "number");
        this.addProperty("value", "[]");
        this.widget = this.addWidget("text","array",this.properties.value,"value");
        this.widgets_up = true;
        this.size = [140, 50];
    }

    ConstantArray.title = "Const Array";
    ConstantArray.desc = "Constant Array";

    ConstantArray.prototype.onPropertyChanged = function(name, value) {
        this.widget.value = value;
        if (value == null || value == "") {
            return;
        }

        try {
			if(value[0] != "[")
	            this._value = JSON.parse("[" + value + "]");
			else
	            this._value = JSON.parse(value);
            this.boxcolor = "#AEA";
        } catch (err) {
            this.boxcolor = "red";
        }
    };

    ConstantArray.prototype.onExecute = function() {
        var v = this.getInputData(0);
		if(v && v.length) //clone
		{
			if(!this._value)
				this._value = new Array();
			this._value.length = v.length;
			for(var i = 0; i < v.length; ++i)
				this._value[i] = v[i];
		}
		this.setOutputData(0, this._value );
		this.setOutputData(1, this._value ? ( this._value.length || 0) : 0 );
    };

	ConstantArray.prototype.setValue = ConstantNumber.prototype.setValue;

    LiteGraph.registerNodeType("basic/array", ConstantArray);

	function SetArray()
	{
        this.addInput("arr", "array");
        this.addInput("value", "");
        this.addOutput("arr", "array");
		this.properties = { index: 0 };
        this.widget = this.addWidget("number","i",this.properties.index,"index");
	}

    SetArray.title = "Set Array";
    SetArray.desc = "Sets index of array";

    SetArray.prototype.onExecute = function() {
        var arr = this.getInputData(0);
		if(!arr)
			return;
        var v = this.getInputData(1);
		if(v === undefined )
			return;
		if(this.properties.index)
			arr[ Math.floor(this.properties.index) ] = v;
		this.setOutputData(0,arr);
    };

    LiteGraph.registerNodeType("basic/set_array", SetArray );

    function ArrayElement() {
        this.addInput("array", "array,table,string");
        this.addInput("index", "number");
        this.addOutput("value", "");
		this.addProperty("index",0);
    }

    ArrayElement.title = "Array[i]";
    ArrayElement.desc = "Returns an element from an array";

    ArrayElement.prototype.onExecute = function() {
        var array = this.getInputData(0);
        var index = this.getInputData(1);
		if(index == null)
			index = this.properties.index;
		if(array == null || index == null )
			return;
        this.setOutputData(0, array[Math.floor(Number(index))] );
    };

    LiteGraph.registerNodeType("basic/array[]", ArrayElement);

    function TableElement() {
        this.addInput("table", "table");
        this.addInput("row", "number");
        this.addInput("col", "number");
        this.addOutput("value", "");
		this.addProperty("row",0);
		this.addProperty("column",0);
    }

    TableElement.title = "Table[row][col]";
    TableElement.desc = "Returns an element from a table";

    TableElement.prototype.onExecute = function() {
        var table = this.getInputData(0);
        var row = this.getInputData(1);
        var col = this.getInputData(2);
		if(row == null)
			row = this.properties.row;
		if(col == null)
			col = this.properties.column;
		if(table == null || row == null || col == null)
			return;
		var row = table[Math.floor(Number(row))];
		if(row)
	        this.setOutputData(0, row[Math.floor(Number(col))] );
		else
	        this.setOutputData(0, null );
    };

    LiteGraph.registerNodeType("basic/table[][]", TableElement);

    function ObjectProperty() {
        this.addInput("obj", "");
        this.addOutput("", "");
        this.addProperty("value", "");
        this.widget = this.addWidget("text","prop.","",this.setValue.bind(this) );
        this.widgets_up = true;
        this.size = [140, 30];
        this._value = null;
    }

    ObjectProperty.title = "Object property";
    ObjectProperty.desc = "Outputs the property of an object";

    ObjectProperty.prototype.setValue = function(v) {
        this.properties.value = v;
        this.widget.value = v;
    };

    ObjectProperty.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return "in." + this.properties.value;
        }
        return this.title;
    };

    ObjectProperty.prototype.onPropertyChanged = function(name, value) {
        this.widget.value = value;
    };

    ObjectProperty.prototype.onExecute = function() {
        var data = this.getInputData(0);
        if (data != null) {
            this.setOutputData(0, data[this.properties.value]);
        }
    };

    LiteGraph.registerNodeType("basic/object_property", ObjectProperty);

    function ObjectKeys() {
        this.addInput("obj", "");
        this.addOutput("keys", "array");
        this.size = [140, 30];
    }

    ObjectKeys.title = "Object keys";
    ObjectKeys.desc = "Outputs an array with the keys of an object";

    ObjectKeys.prototype.onExecute = function() {
        var data = this.getInputData(0);
        if (data != null) {
            this.setOutputData(0, Object.keys(data) );
        }
    };

    LiteGraph.registerNodeType("basic/object_keys", ObjectKeys);


	function SetObject()
	{
        this.addInput("obj", "");
        this.addInput("value", "");
        this.addOutput("obj", "");
		this.properties = { property: "" };
        this.name_widget = this.addWidget("text","prop.",this.properties.property,"property");
	}

    SetObject.title = "Set Object";
    SetObject.desc = "Adds propertiesrty to object";

    SetObject.prototype.onExecute = function() {
        var obj = this.getInputData(0);
		if(!obj)
			return;
        var v = this.getInputData(1);
		if(v === undefined )
			return;
		if(this.properties.property)
			obj[ this.properties.property ] = v;
		this.setOutputData(0,obj);
    };

    LiteGraph.registerNodeType("basic/set_object", SetObject );


    function MergeObjects() {
        this.addInput("A", "");
        this.addInput("B", "");
        this.addOutput("", "");
		this._result = {};
		var that = this;
		this.addWidget("button","clear","",function(){
			that._result = {};
		});
		this.size = this.computeSize();
    }

    MergeObjects.title = "Merge Objects";
    MergeObjects.desc = "Creates an object copying properties from others";

    MergeObjects.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
		var C = this._result;
		if(A)
			for(var i in A)
				C[i] = A[i];
		if(B)
			for(var i in B)
				C[i] = B[i];
		this.setOutputData(0,C);
    };

    LiteGraph.registerNodeType("basic/merge_objects", MergeObjects );

    //Store as variable
    function Variable() {
        this.size = [60, 30];
        this.addInput("in");
        this.addOutput("out");
		this.properties = { varname: "myname", container: Variable.LITEGRAPH };
        this.value = null;
    }

    Variable.title = "Variable";
    Variable.desc = "store/read variable value";

	Variable.LITEGRAPH = 0; //between all graphs
	Variable.GRAPH = 1;	//only inside this graph
	Variable.GLOBALSCOPE = 2;	//attached to Window

    Variable["@container"] = { type: "enum", values: {"litegraph":Variable.LITEGRAPH, "graph":Variable.GRAPH,"global": Variable.GLOBALSCOPE} };

    Variable.prototype.onExecute = function() {
		var container = this.getContainer();

		if(this.isInputConnected(0))
		{
			this.value = this.getInputData(0);
			container[ this.properties.varname ] = this.value;
			this.setOutputData(0, this.value );
			return;
		}

		this.setOutputData( 0, container[ this.properties.varname ] );
    };

	Variable.prototype.getContainer = function()
	{
		switch(this.properties.container)
		{
			case Variable.GRAPH:
				if(this.graph)
					return this.graph.vars;
				return {};
				break;
			case Variable.GLOBALSCOPE:
				return global;
				break;
			case Variable.LITEGRAPH:
			default:
				return LiteGraph.Globals;
				break;
		}
	}

    Variable.prototype.getTitle = function() {
        return this.properties.varname;
    };

    LiteGraph.registerNodeType("basic/variable", Variable);

    function length(v) {
        if(v && v.length != null)
			return Number(v.length);
		return 0;
    }

    LiteGraph.wrapFunctionAsNode(
        "basic/length",
        length,
        [""],
        "number"
    );

	function DownloadData() {
        this.size = [60, 30];
        this.addInput("data", 0 );
        this.addInput("download", LiteGraph.ACTION );
		this.properties = { filename: "data.json" };
        this.value = null;
		var that = this;
		this.addWidget("button","Download","", function(v){
			if(!that.value)
				return;
			that.downloadAsFile();
		});
    }

    DownloadData.title = "Download";
    DownloadData.desc = "Download some data";

	DownloadData.prototype.downloadAsFile = function()
	{
		if(this.value == null)
			return;

		var str = null;
		if(this.value.constructor === String)
			str = this.value;
		else
			str = JSON.stringify(this.value);

		var file = new Blob([str]);
		var url = URL.createObjectURL( file );
		var element = document.createElement("a");
		element.setAttribute('href', url);
		element.setAttribute('download', this.properties.filename );
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
		setTimeout( function(){ URL.revokeObjectURL( url ); }, 1000*60 ); //wait one minute to revoke url
	}

    DownloadData.prototype.onAction = function(action, param) {
		var that = this;
		setTimeout( function(){ that.downloadAsFile(); }, 100); //deferred to avoid blocking the renderer with the popup
	}

    DownloadData.prototype.onExecute = function() {
        if (this.inputs[0]) {
            this.value = this.getInputData(0);
        }
    };

    DownloadData.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.properties.filename;
        }
        return this.title;
    };

    LiteGraph.registerNodeType("basic/download", DownloadData);



    //Watch a value in the editor
    function Watch() {
        this.size = [60, 30];
        this.addInput("value", 0, { label: "" });
        this.value = 0;
    }

    Watch.title = "Watch";
    Watch.desc = "Show value of input";

    Watch.prototype.onExecute = function() {
        if (this.inputs[0]) {
            this.value = this.getInputData(0);
        }
    };

    Watch.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this.inputs[0].label;
        }
        return this.title;
    };

    Watch.toString = function(o) {
        if (o == null) {
            return "null";
        } else if (o.constructor === Number) {
            return o.toFixed(3);
        } else if (o.constructor === Array) {
            var str = "[";
            for (var i = 0; i < o.length; ++i) {
                str += Watch.toString(o[i]) + (i + 1 != o.length ? "," : "");
            }
            str += "]";
            return str;
        } else {
            return String(o);
        }
    };

    Watch.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.inputs[0].label = Watch.toString(this.value);
    };

    LiteGraph.registerNodeType("basic/watch", Watch);

    //in case one type doesnt match other type but you want to connect them anyway
    function Cast() {
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.size = [40, 30];
    }

    Cast.title = "Cast";
    Cast.desc = "Allows to connect different types";

    Cast.prototype.onExecute = function() {
        this.setOutputData(0, this.getInputData(0));
    };

    LiteGraph.registerNodeType("basic/cast", Cast);

    //Show value inside the debug console
    function Console() {
        this.mode = LiteGraph.ON_EVENT;
        this.size = [80, 30];
        this.addProperty("msg", "");
        this.addInput("log", LiteGraph.EVENT);
        this.addInput("msg", 0);
    }

    Console.title = "Console";
    Console.desc = "Show value inside the console";

    Console.prototype.onAction = function(action, param) {
        if (action == "log") {
            console.log(param);
        } else if (action == "warn") {
            console.warn(param);
        } else if (action == "error") {
            console.error(param);
        }
    };

    Console.prototype.onExecute = function() {
        var msg = this.getInputData(1);
        if (msg !== null) {
            this.properties.msg = msg;
        }
        console.log(msg);
    };

    Console.prototype.onGetInputs = function() {
        return [
            ["log", LiteGraph.ACTION],
            ["warn", LiteGraph.ACTION],
            ["error", LiteGraph.ACTION]
        ];
    };

    LiteGraph.registerNodeType("basic/console", Console);

    //Show value inside the debug console
    function Alert() {
        this.mode = LiteGraph.ON_EVENT;
        this.addProperty("msg", "");
        this.addInput("", LiteGraph.EVENT);
        var that = this;
        this.widget = this.addWidget("text", "Text", "", "msg");
        this.widgets_up = true;
        this.size = [200, 30];
    }

    Alert.title = "Alert";
    Alert.desc = "Show an alert window";
    Alert.color = "#510";

    Alert.prototype.onConfigure = function(o) {
        this.widget.value = o.properties.msg;
    };

    Alert.prototype.onAction = function(action, param) {
        var msg = this.properties.msg;
        setTimeout(function() {
            alert(msg);
        }, 10);
    };

    LiteGraph.registerNodeType("basic/alert", Alert);

    //Execites simple code
    function NodeScript() {
        this.size = [60, 30];
        this.addProperty("onExecute", "return A;");
        this.addInput("A", "");
        this.addInput("B", "");
        this.addOutput("out", "");

        this._func = null;
        this.data = {};
    }

    NodeScript.prototype.onConfigure = function(o) {
        if (o.properties.onExecute && LiteGraph.allow_scripts)
            this.compileCode(o.properties.onExecute);
		else
			console.warn("Script not compiled, LiteGraph.allow_scripts is false");
    };

    NodeScript.title = "Script";
    NodeScript.desc = "executes a code (max 100 characters)";

    NodeScript.widgets_info = {
        onExecute: { type: "code" }
    };

    NodeScript.prototype.onPropertyChanged = function(name, value) {
        if (name == "onExecute" && LiteGraph.allow_scripts)
            this.compileCode(value);
		else
			console.warn("Script not compiled, LiteGraph.allow_scripts is false");
    };

    NodeScript.prototype.compileCode = function(code) {
        this._func = null;
        if (code.length > 256) {
            console.warn("Script too long, max 256 chars");
        } else {
            var code_low = code.toLowerCase();
            var forbidden_words = [
                "script",
                "body",
                "document",
                "eval",
                "nodescript",
                "function"
            ]; //bad security solution
            for (var i = 0; i < forbidden_words.length; ++i) {
                if (code_low.indexOf(forbidden_words[i]) != -1) {
                    console.warn("invalid script");
                    return;
                }
            }
            try {
                this._func = new Function("A", "B", "C", "DATA", "node", code);
            } catch (err) {
                console.error("Error parsing script");
                console.error(err);
            }
        }
    };

    NodeScript.prototype.onExecute = function() {
        if (!this._func) {
            return;
        }

        try {
            var A = this.getInputData(0);
            var B = this.getInputData(1);
            var C = this.getInputData(2);
            this.setOutputData(0, this._func(A, B, C, this.data, this));
        } catch (err) {
            console.error("Error in script");
            console.error(err);
        }
    };

    NodeScript.prototype.onGetOutputs = function() {
        return [["C", ""]];
    };

    LiteGraph.registerNodeType("basic/script", NodeScript);
})(this);

//event related nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    //Show value inside the debug console
    function LogEvent() {
        this.size = [60, 30];
        this.addInput("event", LiteGraph.ACTION);
    }

    LogEvent.title = "Log Event";
    LogEvent.desc = "Log event in console";

    LogEvent.prototype.onAction = function(action, param) {
        console.log(action, param);
    };

    LiteGraph.registerNodeType("events/log", LogEvent);

    //convert to Event if the value is true
    function TriggerEvent() {
        this.size = [60, 30];
        this.addInput("if", "");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("change", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
		this.properties = { only_on_change: true };
		this.prev = 0;
    }

    TriggerEvent.title = "TriggerEvent";
    TriggerEvent.desc = "Triggers event if input evaluates to true";

    TriggerEvent.prototype.onExecute = function(action, param) {
		var v = this.getInputData(0);
		var changed = (v != this.prev);
		if(this.prev === 0)
			changed = false;
		var must_resend = (changed && this.properties.only_on_change) || (!changed && !this.properties.only_on_change);
		if(v && must_resend )
	        this.triggerSlot(0, param);
		if(!v && must_resend)
	        this.triggerSlot(2, param);
		if(changed)
	        this.triggerSlot(1, param);
		this.prev = v;
    };

    LiteGraph.registerNodeType("events/trigger", TriggerEvent);

    //Sequencer for events
    function Sequencer() {
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addInput("", LiteGraph.ACTION);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", LiteGraph.EVENT);
        this.size = [120, 30];
        this.flags = { horizontal: true, render_box: false };
    }

    Sequencer.title = "Sequencer";
    Sequencer.desc = "Trigger events when an event arrives";

    Sequencer.prototype.getTitle = function() {
        return "";
    };

    Sequencer.prototype.onAction = function(action, param) {
        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; ++i) {
                this.triggerSlot(i, param);
            }
        }
    };

    LiteGraph.registerNodeType("events/sequencer", Sequencer);

    //Filter events
    function FilterEvent() {
        this.size = [60, 30];
        this.addInput("event", LiteGraph.ACTION);
        this.addOutput("event", LiteGraph.EVENT);
        this.properties = {
            equal_to: "",
            has_property: "",
            property_equal_to: ""
        };
    }

    FilterEvent.title = "Filter Event";
    FilterEvent.desc = "Blocks events that do not match the filter";

    FilterEvent.prototype.onAction = function(action, param) {
        if (param == null) {
            return;
        }

        if (this.properties.equal_to && this.properties.equal_to != param) {
            return;
        }

        if (this.properties.has_property) {
            var prop = param[this.properties.has_property];
            if (prop == null) {
                return;
            }

            if (
                this.properties.property_equal_to &&
                this.properties.property_equal_to != prop
            ) {
                return;
            }
        }

        this.triggerSlot(0, param);
    };

    LiteGraph.registerNodeType("events/filter", FilterEvent);


    function EventBranch() {
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("cond", "boolean");
        this.addOutput("true", LiteGraph.EVENT);
        this.addOutput("false", LiteGraph.EVENT);
        this.size = [120, 60];
		this._value = false;
    }

    EventBranch.title = "Branch";
    EventBranch.desc = "If condition is true, outputs triggers true, otherwise false";

    EventBranch.prototype.onExecute = function() {
		this._value = this.getInputData(1);
	}

    EventBranch.prototype.onAction = function(action, param) {
		this.triggerSlot(this._value ? 0 : 1);
	}

    LiteGraph.registerNodeType("events/branch", EventBranch);

    //Show value inside the debug console
    function EventCounter() {
        this.addInput("inc", LiteGraph.ACTION);
        this.addInput("dec", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("change", LiteGraph.EVENT);
        this.addOutput("num", "number");
        this.num = 0;
    }

    EventCounter.title = "Counter";
    EventCounter.desc = "Counts events";

    EventCounter.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return String(this.num);
        }
        return this.title;
    };

    EventCounter.prototype.onAction = function(action, param) {
        var v = this.num;
        if (action == "inc") {
            this.num += 1;
        } else if (action == "dec") {
            this.num -= 1;
        } else if (action == "reset") {
            this.num = 0;
        }
        if (this.num != v) {
            this.trigger("change", this.num);
        }
    };

    EventCounter.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        ctx.fillStyle = "#AAA";
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.num, this.size[0] * 0.5, this.size[1] * 0.5);
    };

    EventCounter.prototype.onExecute = function() {
        this.setOutputData(1, this.num);
    };

    LiteGraph.registerNodeType("events/counter", EventCounter);

    //Show value inside the debug console
    function DelayEvent() {
        this.size = [60, 30];
        this.addProperty("time_in_ms", 1000);
        this.addInput("event", LiteGraph.ACTION);
        this.addOutput("on_time", LiteGraph.EVENT);

        this._pending = [];
    }

    DelayEvent.title = "Delay";
    DelayEvent.desc = "Delays one event";

    DelayEvent.prototype.onAction = function(action, param) {
        var time = this.properties.time_in_ms;
        if (time <= 0) {
            this.trigger(null, param);
        } else {
            this._pending.push([time, param]);
        }
    };

    DelayEvent.prototype.onExecute = function() {
        var dt = this.graph.elapsed_time * 1000; //in ms

        if (this.isInputConnected(1)) {
            this.properties.time_in_ms = this.getInputData(1);
        }

        for (var i = 0; i < this._pending.length; ++i) {
            var action = this._pending[i];
            action[0] -= dt;
            if (action[0] > 0) {
                continue;
            }

            //remove
            this._pending.splice(i, 1);
            --i;

            //trigger
            this.trigger(null, action[1]);
        }
    };

    DelayEvent.prototype.onGetInputs = function() {
        return [["event", LiteGraph.ACTION], ["time_in_ms", "number"]];
    };

    LiteGraph.registerNodeType("events/delay", DelayEvent);

    //Show value inside the debug console
    function TimerEvent() {
        this.addProperty("interval", 1000);
        this.addProperty("event", "tick");
        this.addOutput("on_tick", LiteGraph.EVENT);
        this.time = 0;
        this.last_interval = 1000;
        this.triggered = false;
    }

    TimerEvent.title = "Timer";
    TimerEvent.desc = "Sends an event every N milliseconds";

    TimerEvent.prototype.onStart = function() {
        this.time = 0;
    };

    TimerEvent.prototype.getTitle = function() {
        return "Timer: " + this.last_interval.toString() + "ms";
    };

    TimerEvent.on_color = "#AAA";
    TimerEvent.off_color = "#222";

    TimerEvent.prototype.onDrawBackground = function() {
        this.boxcolor = this.triggered
            ? TimerEvent.on_color
            : TimerEvent.off_color;
        this.triggered = false;
    };

    TimerEvent.prototype.onExecute = function() {
        var dt = this.graph.elapsed_time * 1000; //in ms

        var trigger = this.time == 0;

        this.time += dt;
        this.last_interval = Math.max(
            1,
            this.getInputOrProperty("interval") | 0
        );

        if (
            !trigger &&
            (this.time < this.last_interval || isNaN(this.last_interval))
        ) {
            if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {
                this.setOutputData(1, false);
            }
            return;
        }

        this.triggered = true;
        this.time = this.time % this.last_interval;
        this.trigger("on_tick", this.properties.event);
        if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {
            this.setOutputData(1, true);
        }
    };

    TimerEvent.prototype.onGetInputs = function() {
        return [["interval", "number"]];
    };

    TimerEvent.prototype.onGetOutputs = function() {
        return [["tick", "boolean"]];
    };

    LiteGraph.registerNodeType("events/timer", TimerEvent);

    function DataStore() {
        this.addInput("data", "");
        this.addInput("assign", LiteGraph.ACTION);
        this.addOutput("data", "");
		this._last_value = null;
		this.properties = { data: null, serialize: true };
		var that = this;
		this.addWidget("button","store","",function(){
			that.properties.data = that._last_value;
		});
    }

    DataStore.title = "Data Store";
    DataStore.desc = "Stores data and only changes when event is received";

	DataStore.prototype.onExecute = function()
	{
		this._last_value = this.getInputData(0);
		this.setOutputData(0, this.properties.data );
	}

    DataStore.prototype.onAction = function(action, param) {
		this.properties.data = this._last_value;
    };

	DataStore.prototype.onSerialize = function(o)
	{
		if(o.data == null)
			return;
		if(this.properties.serialize == false || (o.data.constructor !== String && o.data.constructor !== Number && o.data.constructor !== Boolean && o.data.constructor !== Array && o.data.constructor !== Object ))
			o.data = null;
	}

    LiteGraph.registerNodeType("basic/data_store", DataStore);
})(this);

//widgets
(function(global) {
    var LiteGraph = global.LiteGraph;

    /* Button ****************/

    function WidgetButton() {
        this.addOutput("", LiteGraph.EVENT);
        this.addOutput("", "boolean");
        this.addProperty("text", "click me");
        this.addProperty("font_size", 30);
        this.addProperty("message", "");
        this.size = [164, 84];
        this.clicked = false;
    }

    WidgetButton.title = "Button";
    WidgetButton.desc = "Triggers an event";

    WidgetButton.font = "Arial";
    WidgetButton.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        var margin = 10;
        ctx.fillStyle = "black";
        ctx.fillRect(
            margin + 1,
            margin + 1,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2
        );
        ctx.fillStyle = "#AAF";
        ctx.fillRect(
            margin - 1,
            margin - 1,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2
        );
        ctx.fillStyle = this.clicked
            ? "white"
            : this.mouseOver
            ? "#668"
            : "#334";
        ctx.fillRect(
            margin,
            margin,
            this.size[0] - margin * 2,
            this.size[1] - margin * 2
        );

        if (this.properties.text || this.properties.text === 0) {
            var font_size = this.properties.font_size || 30;
            ctx.textAlign = "center";
            ctx.fillStyle = this.clicked ? "black" : "white";
            ctx.font = font_size + "px " + WidgetButton.font;
            ctx.fillText(
                this.properties.text,
                this.size[0] * 0.5,
                this.size[1] * 0.5 + font_size * 0.3
            );
            ctx.textAlign = "left";
        }
    };

    WidgetButton.prototype.onMouseDown = function(e, local_pos) {
        if (
            local_pos[0] > 1 &&
            local_pos[1] > 1 &&
            local_pos[0] < this.size[0] - 2 &&
            local_pos[1] < this.size[1] - 2
        ) {
            this.clicked = true;
            this.triggerSlot(0, this.properties.message);
            return true;
        }
    };

    WidgetButton.prototype.onExecute = function() {
        this.setOutputData(1, this.clicked);
    };

    WidgetButton.prototype.onMouseUp = function(e) {
        this.clicked = false;
    };

    LiteGraph.registerNodeType("widget/button", WidgetButton);

    function WidgetToggle() {
        this.addInput("", "boolean");
        this.addInput("e", LiteGraph.ACTION);
        this.addOutput("v", "boolean");
        this.addOutput("e", LiteGraph.EVENT);
        this.properties = { font: "", value: false };
        this.size = [160, 44];
    }

    WidgetToggle.title = "Toggle";
    WidgetToggle.desc = "Toggles between true or false";

    WidgetToggle.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size[1] * 0.5;
        var margin = 0.25;
        var h = this.size[1] * 0.8;
        ctx.font = this.properties.font || (size * 0.8).toFixed(0) + "px Arial";
        var w = ctx.measureText(this.title).width;
        var x = (this.size[0] - (w + size)) * 0.5;

        ctx.fillStyle = "#AAA";
        ctx.fillRect(x, h - size, size, size);

        ctx.fillStyle = this.properties.value ? "#AEF" : "#000";
        ctx.fillRect(
            x + size * margin,
            h - size + size * margin,
            size * (1 - margin * 2),
            size * (1 - margin * 2)
        );

        ctx.textAlign = "left";
        ctx.fillStyle = "#AAA";
        ctx.fillText(this.title, size * 1.2 + x, h * 0.85);
        ctx.textAlign = "left";
    };

    WidgetToggle.prototype.onAction = function(action) {
        this.properties.value = !this.properties.value;
        this.trigger("e", this.properties.value);
    };

    WidgetToggle.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v != null) {
            this.properties.value = v;
        }
        this.setOutputData(0, this.properties.value);
    };

    WidgetToggle.prototype.onMouseDown = function(e, local_pos) {
        if (
            local_pos[0] > 1 &&
            local_pos[1] > 1 &&
            local_pos[0] < this.size[0] - 2 &&
            local_pos[1] < this.size[1] - 2
        ) {
            this.properties.value = !this.properties.value;
            this.graph._version++;
            this.trigger("e", this.properties.value);
            return true;
        }
    };

    LiteGraph.registerNodeType("widget/toggle", WidgetToggle);

    /* Number ****************/

    function WidgetNumber() {
        this.addOutput("", "number");
        this.size = [80, 60];
        this.properties = { min: -1000, max: 1000, value: 1, step: 1 };
        this.old_y = -1;
        this._remainder = 0;
        this._precision = 0;
        this.mouse_captured = false;
    }

    WidgetNumber.title = "Number";
    WidgetNumber.desc = "Widget to select number value";

    WidgetNumber.pixels_threshold = 10;
    WidgetNumber.markers_color = "#666";

    WidgetNumber.prototype.onDrawForeground = function(ctx) {
        var x = this.size[0] * 0.5;
        var h = this.size[1];
        if (h > 30) {
            ctx.fillStyle = WidgetNumber.markers_color;
            ctx.beginPath();
            ctx.moveTo(x, h * 0.1);
            ctx.lineTo(x + h * 0.1, h * 0.2);
            ctx.lineTo(x + h * -0.1, h * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x, h * 0.9);
            ctx.lineTo(x + h * 0.1, h * 0.8);
            ctx.lineTo(x + h * -0.1, h * 0.8);
            ctx.fill();
            ctx.font = (h * 0.7).toFixed(1) + "px Arial";
        } else {
            ctx.font = (h * 0.8).toFixed(1) + "px Arial";
        }

        ctx.textAlign = "center";
        ctx.font = (h * 0.7).toFixed(1) + "px Arial";
        ctx.fillStyle = "#EEE";
        ctx.fillText(
            this.properties.value.toFixed(this._precision),
            x,
            h * 0.75
        );
    };

    WidgetNumber.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
    };

    WidgetNumber.prototype.onPropertyChanged = function(name, value) {
        var t = (this.properties.step + "").split(".");
        this._precision = t.length > 1 ? t[1].length : 0;
    };

    WidgetNumber.prototype.onMouseDown = function(e, pos) {
        if (pos[1] < 0) {
            return;
        }

        this.old_y = e.canvasY;
        this.captureInput(true);
        this.mouse_captured = true;

        return true;
    };

    WidgetNumber.prototype.onMouseMove = function(e) {
        if (!this.mouse_captured) {
            return;
        }

        var delta = this.old_y - e.canvasY;
        if (e.shiftKey) {
            delta *= 10;
        }
        if (e.metaKey || e.altKey) {
            delta *= 0.1;
        }
        this.old_y = e.canvasY;

        var steps = this._remainder + delta / WidgetNumber.pixels_threshold;
        this._remainder = steps % 1;
        steps = steps | 0;

        var v = Math.clamp(
            this.properties.value + steps * this.properties.step,
            this.properties.min,
            this.properties.max
        );
        this.properties.value = v;
        this.graph._version++;
        this.setDirtyCanvas(true);
    };

    WidgetNumber.prototype.onMouseUp = function(e, pos) {
        if (e.click_time < 200) {
            var steps = pos[1] > this.size[1] * 0.5 ? -1 : 1;
            this.properties.value = Math.clamp(
                this.properties.value + steps * this.properties.step,
                this.properties.min,
                this.properties.max
            );
            this.graph._version++;
            this.setDirtyCanvas(true);
        }

        if (this.mouse_captured) {
            this.mouse_captured = false;
            this.captureInput(false);
        }
    };

    LiteGraph.registerNodeType("widget/number", WidgetNumber);


    /* Combo ****************/

    function WidgetCombo() {
        this.addOutput("", "string");
        this.addOutput("change", LiteGraph.EVENT);
        this.size = [80, 60];
        this.properties = { value: "A", values:"A;B;C" };
        this.old_y = -1;
        this.mouse_captured = false;
		this._values = this.properties.values.split(";");
		var that = this;
        this.widgets_up = true;
		this.widget = this.addWidget("combo","", this.properties.value, function(v){
			that.properties.value = v;
            that.triggerSlot(1, v);
		}, { property: "value", values: this._values } );
    }

    WidgetCombo.title = "Combo";
    WidgetCombo.desc = "Widget to select from a list";

    WidgetCombo.prototype.onExecute = function() {
        this.setOutputData( 0, this.properties.value );
    };

    WidgetCombo.prototype.onPropertyChanged = function(name, value) {
		if(name == "values")
		{
			this._values = value.split(";");
			this.widget.options.values = this._values;
		}
		else if(name == "value")
		{
			this.widget.value = value;
		}
	};

    LiteGraph.registerNodeType("widget/combo", WidgetCombo);


    /* Knob ****************/

    function WidgetKnob() {
        this.addOutput("", "number");
        this.size = [64, 84];
        this.properties = {
            min: 0,
            max: 1,
            value: 0.5,
            color: "#7AF",
            precision: 2
        };
        this.value = -1;
    }

    WidgetKnob.title = "Knob";
    WidgetKnob.desc = "Circular controller";
    WidgetKnob.size = [80, 100];

    WidgetKnob.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (this.value == -1) {
            this.value =
                (this.properties.value - this.properties.min) /
                (this.properties.max - this.properties.min);
        }

        var center_x = this.size[0] * 0.5;
        var center_y = this.size[1] * 0.5;
        var radius = Math.min(this.size[0], this.size[1]) * 0.5 - 5;
        var w = Math.floor(radius * 0.05);

        ctx.globalAlpha = 1;
        ctx.save();
        ctx.translate(center_x, center_y);
        ctx.rotate(Math.PI * 0.75);

        //bg
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, radius, 0, Math.PI * 1.5);
        ctx.fill();

        //value
        ctx.strokeStyle = "black";
        ctx.fillStyle = this.properties.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(
            0,
            0,
            radius - 4,
            0,
            Math.PI * 1.5 * Math.max(0.01, this.value)
        );
        ctx.closePath();
        ctx.fill();
        //ctx.stroke();
        ctx.lineWidth = 1;
        ctx.globalAlpha = 1;
        ctx.restore();

        //inner
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(center_x, center_y, radius * 0.75, 0, Math.PI * 2, true);
        ctx.fill();

        //miniball
        ctx.fillStyle = this.mouseOver ? "white" : this.properties.color;
        ctx.beginPath();
        var angle = this.value * Math.PI * 1.5 + Math.PI * 0.75;
        ctx.arc(
            center_x + Math.cos(angle) * radius * 0.65,
            center_y + Math.sin(angle) * radius * 0.65,
            radius * 0.05,
            0,
            Math.PI * 2,
            true
        );
        ctx.fill();

        //text
        ctx.fillStyle = this.mouseOver ? "white" : "#AAA";
        ctx.font = Math.floor(radius * 0.5) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.value.toFixed(this.properties.precision),
            center_x,
            center_y + radius * 0.15
        );
    };

    WidgetKnob.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
        this.boxcolor = LiteGraph.colorToString([
            this.value,
            this.value,
            this.value
        ]);
    };

    WidgetKnob.prototype.onMouseDown = function(e) {
        this.center = [this.size[0] * 0.5, this.size[1] * 0.5 + 20];
        this.radius = this.size[0] * 0.5;
        if (
            e.canvasY - this.pos[1] < 20 ||
            LiteGraph.distance(
                [e.canvasX, e.canvasY],
                [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]
            ) > this.radius
        ) {
            return false;
        }
        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];
        this.captureInput(true);
        return true;
    };

    WidgetKnob.prototype.onMouseMove = function(e) {
        if (!this.oldmouse) {
            return;
        }

        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];

        var v = this.value;
        v -= (m[1] - this.oldmouse[1]) * 0.01;
        if (v > 1.0) {
            v = 1.0;
        } else if (v < 0.0) {
            v = 0.0;
        }
        this.value = v;
        this.properties.value =
            this.properties.min +
            (this.properties.max - this.properties.min) * this.value;
        this.oldmouse = m;
        this.setDirtyCanvas(true);
    };

    WidgetKnob.prototype.onMouseUp = function(e) {
        if (this.oldmouse) {
            this.oldmouse = null;
            this.captureInput(false);
        }
    };

    WidgetKnob.prototype.onPropertyChanged = function(name, value) {
        if (name == "min" || name == "max" || name == "value") {
            this.properties[name] = parseFloat(value);
            return true; //block
        }
    };

    LiteGraph.registerNodeType("widget/knob", WidgetKnob);

    //Show value inside the debug console
    function WidgetSliderGUI() {
        this.addOutput("", "number");
        this.properties = {
            value: 0.5,
            min: 0,
            max: 1,
            text: "V"
        };
        var that = this;
        this.size = [140, 40];
        this.slider = this.addWidget(
            "slider",
            "V",
            this.properties.value,
            function(v) {
                that.properties.value = v;
            },
            this.properties
        );
        this.widgets_up = true;
    }

    WidgetSliderGUI.title = "Inner Slider";

    WidgetSliderGUI.prototype.onPropertyChanged = function(name, value) {
        if (name == "value") {
            this.slider.value = value;
        }
    };

    WidgetSliderGUI.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
    };

    LiteGraph.registerNodeType("widget/internal_slider", WidgetSliderGUI);

    //Widget H SLIDER
    function WidgetHSlider() {
        this.size = [160, 26];
        this.addOutput("", "number");
        this.properties = { color: "#7AF", min: 0, max: 1, value: 0.5 };
        this.value = -1;
    }

    WidgetHSlider.title = "H.Slider";
    WidgetHSlider.desc = "Linear slider controller";

    WidgetHSlider.prototype.onDrawForeground = function(ctx) {
        if (this.value == -1) {
            this.value =
                (this.properties.value - this.properties.min) /
                (this.properties.max - this.properties.min);
        }

        //border
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.fillStyle = "#000";
        ctx.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4);

        ctx.fillStyle = this.properties.color;
        ctx.beginPath();
        ctx.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8);
        ctx.fill();
    };

    WidgetHSlider.prototype.onExecute = function() {
        this.properties.value =
            this.properties.min +
            (this.properties.max - this.properties.min) * this.value;
        this.setOutputData(0, this.properties.value);
        this.boxcolor = LiteGraph.colorToString([
            this.value,
            this.value,
            this.value
        ]);
    };

    WidgetHSlider.prototype.onMouseDown = function(e) {
        if (e.canvasY - this.pos[1] < 0) {
            return false;
        }

        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];
        this.captureInput(true);
        return true;
    };

    WidgetHSlider.prototype.onMouseMove = function(e) {
        if (!this.oldmouse) {
            return;
        }

        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];

        var v = this.value;
        var delta = m[0] - this.oldmouse[0];
        v += delta / this.size[0];
        if (v > 1.0) {
            v = 1.0;
        } else if (v < 0.0) {
            v = 0.0;
        }

        this.value = v;

        this.oldmouse = m;
        this.setDirtyCanvas(true);
    };

    WidgetHSlider.prototype.onMouseUp = function(e) {
        this.oldmouse = null;
        this.captureInput(false);
    };

    WidgetHSlider.prototype.onMouseLeave = function(e) {
        //this.oldmouse = null;
    };

    LiteGraph.registerNodeType("widget/hslider", WidgetHSlider);

    function WidgetProgress() {
        this.size = [160, 26];
        this.addInput("", "number");
        this.properties = { min: 0, max: 1, value: 0, color: "#AAF" };
    }

    WidgetProgress.title = "Progress";
    WidgetProgress.desc = "Shows data in linear progress";

    WidgetProgress.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v != undefined) {
            this.properties["value"] = v;
        }
    };

    WidgetProgress.prototype.onDrawForeground = function(ctx) {
        //border
        ctx.lineWidth = 1;
        ctx.fillStyle = this.properties.color;
        var v =
            (this.properties.value - this.properties.min) /
            (this.properties.max - this.properties.min);
        v = Math.min(1, v);
        v = Math.max(0, v);
        ctx.fillRect(2, 2, (this.size[0] - 4) * v, this.size[1] - 4);
    };

    LiteGraph.registerNodeType("widget/progress", WidgetProgress);

    function WidgetText() {
        this.addInputs("", 0);
        this.properties = {
            value: "...",
            font: "Arial",
            fontsize: 18,
            color: "#AAA",
            align: "left",
            glowSize: 0,
            decimals: 1
        };
    }

    WidgetText.title = "Text";
    WidgetText.desc = "Shows the input value";
    WidgetText.widgets = [
        { name: "resize", text: "Resize box", type: "button" },
        { name: "led_text", text: "LED", type: "minibutton" },
        { name: "normal_text", text: "Normal", type: "minibutton" }
    ];

    WidgetText.prototype.onDrawForeground = function(ctx) {
        //ctx.fillStyle="#000";
        //ctx.fillRect(0,0,100,60);
        ctx.fillStyle = this.properties["color"];
        var v = this.properties["value"];

        if (this.properties["glowSize"]) {
            ctx.shadowColor = this.properties.color;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = this.properties["glowSize"];
        } else {
            ctx.shadowColor = "transparent";
        }

        var fontsize = this.properties["fontsize"];

        ctx.textAlign = this.properties["align"];
        ctx.font = fontsize.toString() + "px " + this.properties["font"];
        this.str =
            typeof v == "number" ? v.toFixed(this.properties["decimals"]) : v;

        if (typeof this.str == "string") {
            var lines = this.str.split("\\n");
            for (var i=0; i < lines.length; i++) {
                ctx.fillText(
                    lines[i],
                    this.properties["align"] == "left" ? 15 : this.size[0] - 15,
                    fontsize * -0.15 + fontsize * (parseInt(i) + 1)
                );
            }
        }

        ctx.shadowColor = "transparent";
        this.last_ctx = ctx;
        ctx.textAlign = "left";
    };

    WidgetText.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v != null) {
            this.properties["value"] = v;
        }
        //this.setDirtyCanvas(true);
    };

    WidgetText.prototype.resize = function() {
        if (!this.last_ctx) {
            return;
        }

        var lines = this.str.split("\\n");
        this.last_ctx.font =
            this.properties["fontsize"] + "px " + this.properties["font"];
        var max = 0;
        for (var i=0; i < lines.length; i++) {
            var w = this.last_ctx.measureText(lines[i]).width;
            if (max < w) {
                max = w;
            }
        }
        this.size[0] = max + 20;
        this.size[1] = 4 + lines.length * this.properties["fontsize"];

        this.setDirtyCanvas(true);
    };

    WidgetText.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;
        this.str = typeof value == "number" ? value.toFixed(3) : value;
        //this.resize();
        return true;
    };

    LiteGraph.registerNodeType("widget/text", WidgetText);

    function WidgetPanel() {
        this.size = [200, 100];
        this.properties = {
            borderColor: "#ffffff",
            bgcolorTop: "#f0f0f0",
            bgcolorBottom: "#e0e0e0",
            shadowSize: 2,
            borderRadius: 3
        };
    }

    WidgetPanel.title = "Panel";
    WidgetPanel.desc = "Non interactive panel";
    WidgetPanel.widgets = [{ name: "update", text: "Update", type: "button" }];

    WidgetPanel.prototype.createGradient = function(ctx) {
        if (
            this.properties["bgcolorTop"] == "" ||
            this.properties["bgcolorBottom"] == ""
        ) {
            this.lineargradient = 0;
            return;
        }

        this.lineargradient = ctx.createLinearGradient(0, 0, 0, this.size[1]);
        this.lineargradient.addColorStop(0, this.properties["bgcolorTop"]);
        this.lineargradient.addColorStop(1, this.properties["bgcolorBottom"]);
    };

    WidgetPanel.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        if (this.lineargradient == null) {
            this.createGradient(ctx);
        }

        if (!this.lineargradient) {
            return;
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = this.properties["borderColor"];
        //ctx.fillStyle = "#ebebeb";
        ctx.fillStyle = this.lineargradient;

        if (this.properties["shadowSize"]) {
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = this.properties["shadowSize"];
        } else {
            ctx.shadowColor = "transparent";
        }

        ctx.roundRect(
            0,
            0,
            this.size[0] - 1,
            this.size[1] - 1,
            this.properties["shadowSize"]
        );
        ctx.fill();
        ctx.shadowColor = "transparent";
        ctx.stroke();
    };

    LiteGraph.registerNodeType("widget/panel", WidgetPanel);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    function GamepadInput() {
        this.addOutput("left_x_axis", "number");
        this.addOutput("left_y_axis", "number");
        this.addOutput("button_pressed", LiteGraph.EVENT);
        this.properties = { gamepad_index: 0, threshold: 0.1 };

        this._left_axis = new Float32Array(2);
        this._right_axis = new Float32Array(2);
        this._triggers = new Float32Array(2);
        this._previous_buttons = new Uint8Array(17);
        this._current_buttons = new Uint8Array(17);
    }

    GamepadInput.title = "Gamepad";
    GamepadInput.desc = "gets the input of the gamepad";

    GamepadInput.CENTER = 0;
    GamepadInput.LEFT = 1;
    GamepadInput.RIGHT = 2;
    GamepadInput.UP = 4;
    GamepadInput.DOWN = 8;

    GamepadInput.zero = new Float32Array(2);
    GamepadInput.buttons = [
        "a",
        "b",
        "x",
        "y",
        "lb",
        "rb",
        "lt",
        "rt",
        "back",
        "start",
        "ls",
        "rs",
        "home"
    ];

    GamepadInput.prototype.onExecute = function() {
        //get gamepad
        var gamepad = this.getGamepad();
        var threshold = this.properties.threshold || 0.0;

        if (gamepad) {
            this._left_axis[0] =
                Math.abs(gamepad.xbox.axes["lx"]) > threshold
                    ? gamepad.xbox.axes["lx"]
                    : 0;
            this._left_axis[1] =
                Math.abs(gamepad.xbox.axes["ly"]) > threshold
                    ? gamepad.xbox.axes["ly"]
                    : 0;
            this._right_axis[0] =
                Math.abs(gamepad.xbox.axes["rx"]) > threshold
                    ? gamepad.xbox.axes["rx"]
                    : 0;
            this._right_axis[1] =
                Math.abs(gamepad.xbox.axes["ry"]) > threshold
                    ? gamepad.xbox.axes["ry"]
                    : 0;
            this._triggers[0] =
                Math.abs(gamepad.xbox.axes["ltrigger"]) > threshold
                    ? gamepad.xbox.axes["ltrigger"]
                    : 0;
            this._triggers[1] =
                Math.abs(gamepad.xbox.axes["rtrigger"]) > threshold
                    ? gamepad.xbox.axes["rtrigger"]
                    : 0;
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                if (!output.links || !output.links.length) {
                    continue;
                }
                var v = null;

                if (gamepad) {
                    switch (output.name) {
                        case "left_axis":
                            v = this._left_axis;
                            break;
                        case "right_axis":
                            v = this._right_axis;
                            break;
                        case "left_x_axis":
                            v = this._left_axis[0];
                            break;
                        case "left_y_axis":
                            v = this._left_axis[1];
                            break;
                        case "right_x_axis":
                            v = this._right_axis[0];
                            break;
                        case "right_y_axis":
                            v = this._right_axis[1];
                            break;
                        case "trigger_left":
                            v = this._triggers[0];
                            break;
                        case "trigger_right":
                            v = this._triggers[1];
                            break;
                        case "a_button":
                            v = gamepad.xbox.buttons["a"] ? 1 : 0;
                            break;
                        case "b_button":
                            v = gamepad.xbox.buttons["b"] ? 1 : 0;
                            break;
                        case "x_button":
                            v = gamepad.xbox.buttons["x"] ? 1 : 0;
                            break;
                        case "y_button":
                            v = gamepad.xbox.buttons["y"] ? 1 : 0;
                            break;
                        case "lb_button":
                            v = gamepad.xbox.buttons["lb"] ? 1 : 0;
                            break;
                        case "rb_button":
                            v = gamepad.xbox.buttons["rb"] ? 1 : 0;
                            break;
                        case "ls_button":
                            v = gamepad.xbox.buttons["ls"] ? 1 : 0;
                            break;
                        case "rs_button":
                            v = gamepad.xbox.buttons["rs"] ? 1 : 0;
                            break;
                        case "hat_left":
                            v = gamepad.xbox.hatmap & GamepadInput.LEFT;
                            break;
                        case "hat_right":
                            v = gamepad.xbox.hatmap & GamepadInput.RIGHT;
                            break;
                        case "hat_up":
                            v = gamepad.xbox.hatmap & GamepadInput.UP;
                            break;
                        case "hat_down":
                            v = gamepad.xbox.hatmap & GamepadInput.DOWN;
                            break;
                        case "hat":
                            v = gamepad.xbox.hatmap;
                            break;
                        case "start_button":
                            v = gamepad.xbox.buttons["start"] ? 1 : 0;
                            break;
                        case "back_button":
                            v = gamepad.xbox.buttons["back"] ? 1 : 0;
                            break;
                        case "button_pressed":
                            for (
                                var j = 0;
                                j < this._current_buttons.length;
                                ++j
                            ) {
                                if (
                                    this._current_buttons[j] &&
                                    !this._previous_buttons[j]
                                ) {
                                    this.triggerSlot(
                                        i,
                                        GamepadInput.buttons[j]
                                    );
                                }
                            }
                            break;
                        default:
                            break;
                    }
                } else {
                    //if no gamepad is connected, output 0
                    switch (output.name) {
                        case "button_pressed":
                            break;
                        case "left_axis":
                        case "right_axis":
                            v = GamepadInput.zero;
                            break;
                        default:
                            v = 0;
                    }
                }
                this.setOutputData(i, v);
            }
        }
    };

	GamepadInput.mapping = {a:0,b:1,x:2,y:3,lb:4,rb:5,lt:6,rt:7,back:8,start:9,ls:10,rs:11 };
	GamepadInput.mapping_array = ["a","b","x","y","lb","rb","lt","rt","back","start","ls","rs"];

    GamepadInput.prototype.getGamepad = function() {
        var getGamepads =
            navigator.getGamepads ||
            navigator.webkitGetGamepads ||
            navigator.mozGetGamepads;
        if (!getGamepads) {
            return null;
        }
        var gamepads = getGamepads.call(navigator);
        var gamepad = null;

        this._previous_buttons.set(this._current_buttons);

        //pick the first connected
        for (var i = this.properties.gamepad_index; i < 4; i++) {
            if (!gamepads[i]) {
                continue;
            }
            gamepad = gamepads[i];

            //xbox controller mapping
            var xbox = this.xbox_mapping;
            if (!xbox) {
                xbox = this.xbox_mapping = {
                    axes: [],
                    buttons: {},
                    hat: "",
                    hatmap: GamepadInput.CENTER
                };
            }

            xbox.axes["lx"] = gamepad.axes[0];
            xbox.axes["ly"] = gamepad.axes[1];
            xbox.axes["rx"] = gamepad.axes[2];
            xbox.axes["ry"] = gamepad.axes[3];
            xbox.axes["ltrigger"] = gamepad.buttons[6].value;
            xbox.axes["rtrigger"] = gamepad.buttons[7].value;
            xbox.hat = "";
            xbox.hatmap = GamepadInput.CENTER;

            for (var j = 0; j < gamepad.buttons.length; j++) {
                this._current_buttons[j] = gamepad.buttons[j].pressed;

				if(j < 12)
				{
					xbox.buttons[ GamepadInput.mapping_array[j] ] = gamepad.buttons[j].pressed;
					if(gamepad.buttons[j].was_pressed)
						this.trigger( GamepadInput.mapping_array[j] + "_button_event" );
				}
				else //mapping of XBOX
					switch ( j ) //I use a switch to ensure that a player with another gamepad could play
					{
						case 12:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "up";
								xbox.hatmap |= GamepadInput.UP;
							}
							break;
						case 13:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "down";
								xbox.hatmap |= GamepadInput.DOWN;
							}
							break;
						case 14:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "left";
								xbox.hatmap |= GamepadInput.LEFT;
							}
							break;
						case 15:
							if (gamepad.buttons[j].pressed) {
								xbox.hat += "right";
								xbox.hatmap |= GamepadInput.RIGHT;
							}
							break;
						case 16:
							xbox.buttons["home"] = gamepad.buttons[j].pressed;
							break;
						default:
					}
            }
            gamepad.xbox = xbox;
            return gamepad;
        }
    };

    GamepadInput.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        //render gamepad state?
        var la = this._left_axis;
        var ra = this._right_axis;
        ctx.strokeStyle = "#88A";
        ctx.strokeRect(
            (la[0] + 1) * 0.5 * this.size[0] - 4,
            (la[1] + 1) * 0.5 * this.size[1] - 4,
            8,
            8
        );
        ctx.strokeStyle = "#8A8";
        ctx.strokeRect(
            (ra[0] + 1) * 0.5 * this.size[0] - 4,
            (ra[1] + 1) * 0.5 * this.size[1] - 4,
            8,
            8
        );
        var h = this.size[1] / this._current_buttons.length;
        ctx.fillStyle = "#AEB";
        for (var i = 0; i < this._current_buttons.length; ++i) {
            if (this._current_buttons[i]) {
                ctx.fillRect(0, h * i, 6, h);
            }
        }
    };

    GamepadInput.prototype.onGetOutputs = function() {
        return [
            ["left_axis", "vec2"],
            ["right_axis", "vec2"],
            ["left_x_axis", "number"],
            ["left_y_axis", "number"],
            ["right_x_axis", "number"],
            ["right_y_axis", "number"],
            ["trigger_left", "number"],
            ["trigger_right", "number"],
            ["a_button", "number"],
            ["b_button", "number"],
            ["x_button", "number"],
            ["y_button", "number"],
            ["lb_button", "number"],
            ["rb_button", "number"],
            ["ls_button", "number"],
            ["rs_button", "number"],
            ["start_button", "number"],
            ["back_button", "number"],
            ["a_button_event", LiteGraph.EVENT ],
            ["b_button_event", LiteGraph.EVENT ],
            ["x_button_event", LiteGraph.EVENT ],
            ["y_button_event", LiteGraph.EVENT ],
            ["lb_button_event", LiteGraph.EVENT ],
            ["rb_button_event", LiteGraph.EVENT ],
            ["ls_button_event", LiteGraph.EVENT ],
            ["rs_button_event", LiteGraph.EVENT ],
            ["start_button_event", LiteGraph.EVENT ],
            ["back_button_event", LiteGraph.EVENT ],
            ["hat_left", "number"],
            ["hat_right", "number"],
            ["hat_up", "number"],
            ["hat_down", "number"],
            ["hat", "number"],
            ["button_pressed", LiteGraph.EVENT]
        ];
    };

    LiteGraph.registerNodeType("input/gamepad", GamepadInput);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    //Converter
    function Converter() {
        this.addInput("in", "");
	this.addOutput("out");
        this.size = [80, 30];
    }

    Converter.title = "Converter";
    Converter.desc = "type A to type B";

    Converter.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; i++) {
                var output = this.outputs[i];
                if (!output.links || !output.links.length) {
                    continue;
                }

                var result = null;
                switch (output.name) {
                    case "number":
                        result = v.length ? v[0] : parseFloat(v);
                        break;
                    case "vec2":
                    case "vec3":
                    case "vec4":
                        var result = null;
                        var count = 1;
                        switch (output.name) {
                            case "vec2":
                                count = 2;
                                break;
                            case "vec3":
                                count = 3;
                                break;
                            case "vec4":
                                count = 4;
                                break;
                        }

                        var result = new Float32Array(count);
                        if (v.length) {
                            for (
                                var j = 0;
                                j < v.length && j < result.length;
                                j++
                            ) {
                                result[j] = v[j];
                            }
                        } else {
                            result[0] = parseFloat(v);
                        }
                        break;
                }
                this.setOutputData(i, result);
            }
        }
    };

    Converter.prototype.onGetOutputs = function() {
        return [
            ["number", "number"],
            ["vec2", "vec2"],
            ["vec3", "vec3"],
            ["vec4", "vec4"]
        ];
    };

    LiteGraph.registerNodeType("math/converter", Converter);

    //Bypass
    function Bypass() {
        this.addInput("in");
        this.addOutput("out");
        this.size = [80, 30];
    }

    Bypass.title = "Bypass";
    Bypass.desc = "removes the type";

    Bypass.prototype.onExecute = function() {
        var v = this.getInputData(0);
        this.setOutputData(0, v);
    };

    LiteGraph.registerNodeType("math/bypass", Bypass);

    function ToNumber() {
        this.addInput("in");
        this.addOutput("out");
    }

    ToNumber.title = "to Number";
    ToNumber.desc = "Cast to number";

    ToNumber.prototype.onExecute = function() {
        var v = this.getInputData(0);
        this.setOutputData(0, Number(v));
    };

    LiteGraph.registerNodeType("math/to_number", ToNumber);

    function MathRange() {
        this.addInput("in", "number", { locked: true });
        this.addOutput("out", "number", { locked: true });
        this.addOutput("clamped", "number", { locked: true });

        this.addProperty("in", 0);
        this.addProperty("in_min", 0);
        this.addProperty("in_max", 1);
        this.addProperty("out_min", 0);
        this.addProperty("out_max", 1);

        this.size = [120, 50];
    }

    MathRange.title = "Range";
    MathRange.desc = "Convert a number from one range to another";

    MathRange.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return (this._last_v || 0).toFixed(2);
        }
        return this.title;
    };

    MathRange.prototype.onExecute = function() {
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                this.properties[input.name] = v;
            }
        }

        var v = this.properties["in"];
        if (v === undefined || v === null || v.constructor !== Number) {
            v = 0;
        }

        var in_min = this.properties.in_min;
        var in_max = this.properties.in_max;
        var out_min = this.properties.out_min;
        var out_max = this.properties.out_max;
		/*
		if( in_min > in_max )
		{
			in_min = in_max;
			in_max = this.properties.in_min;
		}
		if( out_min > out_max )
		{
			out_min = out_max;
			out_max = this.properties.out_min;
		}
		*/

        this._last_v = ((v - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;
        this.setOutputData(0, this._last_v);
        this.setOutputData(1, Math.clamp( this._last_v, out_min, out_max ));
    };

    MathRange.prototype.onDrawBackground = function(ctx) {
        //show the current value
        if (this._last_v) {
            this.outputs[0].label = this._last_v.toFixed(3);
        } else {
            this.outputs[0].label = "?";
        }
    };

    MathRange.prototype.onGetInputs = function() {
        return [
            ["in_min", "number"],
            ["in_max", "number"],
            ["out_min", "number"],
            ["out_max", "number"]
        ];
    };

    LiteGraph.registerNodeType("math/range", MathRange);

    function MathRand() {
        this.addOutput("value", "number");
        this.addProperty("min", 0);
        this.addProperty("max", 1);
        this.size = [80, 30];
    }

    MathRand.title = "Rand";
    MathRand.desc = "Random number";

    MathRand.prototype.onExecute = function() {
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                this.properties[input.name] = v;
            }
        }

        var min = this.properties.min;
        var max = this.properties.max;
        this._last_v = Math.random() * (max - min) + min;
        this.setOutputData(0, this._last_v);
    };

    MathRand.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.outputs[0].label = (this._last_v || 0).toFixed(3);
    };

    MathRand.prototype.onGetInputs = function() {
        return [["min", "number"], ["max", "number"]];
    };

    LiteGraph.registerNodeType("math/rand", MathRand);

    //basic continuous noise
    function MathNoise() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.addProperty("min", 0);
        this.addProperty("max", 1);
        this.addProperty("smooth", true);
        this.addProperty("seed", 0);
        this.addProperty("octaves", 1);
        this.addProperty("persistence", 0.8);
        this.addProperty("speed", 1);
        this.size = [90, 30];
    }

    MathNoise.title = "Noise";
    MathNoise.desc = "Random number with temporal continuity";
    MathNoise.data = null;

    MathNoise.getValue = function(f, smooth) {
        if (!MathNoise.data) {
            MathNoise.data = new Float32Array(1024);
            for (var i = 0; i < MathNoise.data.length; ++i) {
                MathNoise.data[i] = Math.random();
            }
        }
        f = f % 1024;
        if (f < 0) {
            f += 1024;
        }
        var f_min = Math.floor(f);
        var f = f - f_min;
        var r1 = MathNoise.data[f_min];
        var r2 = MathNoise.data[f_min == 1023 ? 0 : f_min + 1];
        if (smooth) {
            f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        }
        return r1 * (1 - f) + r2 * f;
    };

    MathNoise.prototype.onExecute = function() {
        var f = this.getInputData(0) || 0;
		var iterations = this.properties.octaves || 1;
		var r = 0;
		var amp = 1;
		var seed = this.properties.seed || 0;
		f += seed;
		var speed = this.properties.speed || 1;
		var total_amp = 0;
		for(var i = 0; i < iterations; ++i)
		{
			r += MathNoise.getValue(f * (1+i) * speed, this.properties.smooth) * amp;
			total_amp += amp;
			amp *= this.properties.persistence;
			if(amp < 0.001)
				break;
		}
		r /= total_amp;
        var min = this.properties.min;
        var max = this.properties.max;
        this._last_v = r * (max - min) + min;
        this.setOutputData(0, this._last_v);
    };

    MathNoise.prototype.onDrawBackground = function(ctx) {
        //show the current value
        this.outputs[0].label = (this._last_v || 0).toFixed(3);
    };

    LiteGraph.registerNodeType("math/noise", MathNoise);

    //generates spikes every random time
    function MathSpikes() {
        this.addOutput("out", "number");
        this.addProperty("min_time", 1);
        this.addProperty("max_time", 2);
        this.addProperty("duration", 0.2);
        this.size = [90, 30];
        this._remaining_time = 0;
        this._blink_time = 0;
    }

    MathSpikes.title = "Spikes";
    MathSpikes.desc = "spike every random time";

    MathSpikes.prototype.onExecute = function() {
        var dt = this.graph.elapsed_time; //in secs

        this._remaining_time -= dt;
        this._blink_time -= dt;

        var v = 0;
        if (this._blink_time > 0) {
            var f = this._blink_time / this.properties.duration;
            v = 1 / (Math.pow(f * 8 - 4, 4) + 1);
        }

        if (this._remaining_time < 0) {
            this._remaining_time =
                Math.random() *
                    (this.properties.max_time - this.properties.min_time) +
                this.properties.min_time;
            this._blink_time = this.properties.duration;
            this.boxcolor = "#FFF";
        } else {
            this.boxcolor = "#000";
        }
        this.setOutputData(0, v);
    };

    LiteGraph.registerNodeType("math/spikes", MathSpikes);

    //Math clamp
    function MathClamp() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.addProperty("min", 0);
        this.addProperty("max", 1);
    }

    MathClamp.title = "Clamp";
    MathClamp.desc = "Clamp number between min and max";
    //MathClamp.filter = "shader";

    MathClamp.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        v = Math.max(this.properties.min, v);
        v = Math.min(this.properties.max, v);
        this.setOutputData(0, v);
    };

    MathClamp.prototype.getCode = function(lang) {
        var code = "";
        if (this.isInputConnected(0)) {
            code +=
                "clamp({{0}}," +
                this.properties.min +
                "," +
                this.properties.max +
                ")";
        }
        return code;
    };

    LiteGraph.registerNodeType("math/clamp", MathClamp);

    //Math ABS
    function MathLerp() {
        this.properties = { f: 0.5 };
        this.addInput("A", "number");
        this.addInput("B", "number");

        this.addOutput("out", "number");
    }

    MathLerp.title = "Lerp";
    MathLerp.desc = "Linear Interpolation";

    MathLerp.prototype.onExecute = function() {
        var v1 = this.getInputData(0);
        if (v1 == null) {
            v1 = 0;
        }
        var v2 = this.getInputData(1);
        if (v2 == null) {
            v2 = 0;
        }

        var f = this.properties.f;

        var _f = this.getInputData(2);
        if (_f !== undefined) {
            f = _f;
        }

        this.setOutputData(0, v1 * (1 - f) + v2 * f);
    };

    MathLerp.prototype.onGetInputs = function() {
        return [["f", "number"]];
    };

    LiteGraph.registerNodeType("math/lerp", MathLerp);

    //Math ABS
    function MathAbs() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    MathAbs.title = "Abs";
    MathAbs.desc = "Absolute";

    MathAbs.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, Math.abs(v));
    };

    LiteGraph.registerNodeType("math/abs", MathAbs);

    //Math Floor
    function MathFloor() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    MathFloor.title = "Floor";
    MathFloor.desc = "Floor number to remove fractional part";

    MathFloor.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, Math.floor(v));
    };

    LiteGraph.registerNodeType("math/floor", MathFloor);

    //Math frac
    function MathFrac() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
    }

    MathFrac.title = "Frac";
    MathFrac.desc = "Returns fractional part";

    MathFrac.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        this.setOutputData(0, v % 1);
    };

    LiteGraph.registerNodeType("math/frac", MathFrac);

    //Math Floor
    function MathSmoothStep() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.properties = { A: 0, B: 1 };
    }

    MathSmoothStep.title = "Smoothstep";
    MathSmoothStep.desc = "Smoothstep";

    MathSmoothStep.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v === undefined) {
            return;
        }

        var edge0 = this.properties.A;
        var edge1 = this.properties.B;

        // Scale, bias and saturate x to 0..1 range
        v = Math.clamp((v - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        v = v * v * (3 - 2 * v);

        this.setOutputData(0, v);
    };

    LiteGraph.registerNodeType("math/smoothstep", MathSmoothStep);

    //Math scale
    function MathScale() {
        this.addInput("in", "number", { label: "" });
        this.addOutput("out", "number", { label: "" });
        this.size = [80, 30];
        this.addProperty("factor", 1);
    }

    MathScale.title = "Scale";
    MathScale.desc = "v * factor";

    MathScale.prototype.onExecute = function() {
        var value = this.getInputData(0);
        if (value != null) {
            this.setOutputData(0, value * this.properties.factor);
        }
    };

    LiteGraph.registerNodeType("math/scale", MathScale);

	//Gate
	function Gate() {
		this.addInput("v","boolean");
		this.addInput("A");
		this.addInput("B");
		this.addOutput("out");
	}

	Gate.title = "Gate";
	Gate.desc = "if v is true, then outputs A, otherwise B";

	Gate.prototype.onExecute = function() {
		var v = this.getInputData(0);
		this.setOutputData(0, this.getInputData( v ? 1 : 2 ));
	};

	LiteGraph.registerNodeType("math/gate", Gate);


    //Math Average
    function MathAverageFilter() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.size = [80, 30];
        this.addProperty("samples", 10);
        this._values = new Float32Array(10);
        this._current = 0;
    }

    MathAverageFilter.title = "Average";
    MathAverageFilter.desc = "Average Filter";

    MathAverageFilter.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }

        var num_samples = this._values.length;

        this._values[this._current % num_samples] = v;
        this._current += 1;
        if (this._current > num_samples) {
            this._current = 0;
        }

        var avr = 0;
        for (var i = 0; i < num_samples; ++i) {
            avr += this._values[i];
        }

        this.setOutputData(0, avr / num_samples);
    };

    MathAverageFilter.prototype.onPropertyChanged = function(name, value) {
        if (value < 1) {
            value = 1;
        }
        this.properties.samples = Math.round(value);
        var old = this._values;

        this._values = new Float32Array(this.properties.samples);
        if (old.length <= this._values.length) {
            this._values.set(old);
        } else {
            this._values.set(old.subarray(0, this._values.length));
        }
    };

    LiteGraph.registerNodeType("math/average", MathAverageFilter);

    //Math
    function MathTendTo() {
        this.addInput("in", "number");
        this.addOutput("out", "number");
        this.addProperty("factor", 0.1);
        this.size = [80, 30];
        this._value = null;
    }

    MathTendTo.title = "TendTo";
    MathTendTo.desc = "moves the output value always closer to the input";

    MathTendTo.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }
        var f = this.properties.factor;
        if (this._value == null) {
            this._value = v;
        } else {
            this._value = this._value * (1 - f) + v * f;
        }
        this.setOutputData(0, this._value);
    };

    LiteGraph.registerNodeType("math/tendTo", MathTendTo);

    //Math operation
    function MathOperation() {
        this.addInput("A", "number,array,object");
        this.addInput("B", "number");
        this.addOutput("=", "number");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", "+", "enum", { values: MathOperation.values });
		this._func = function(A,B) { return A + B; };
		this._result = []; //only used for arrays
    }

    MathOperation.values = ["+", "-", "*", "/", "%", "^", "max", "min"];

	MathOperation.title = "Operation";
    MathOperation.desc = "Easy math operators";
    MathOperation["@OP"] = {
        type: "enum",
        title: "operation",
        values: MathOperation.values
    };
    MathOperation.size = [100, 60];

    MathOperation.prototype.getTitle = function() {
		if(this.properties.OP == "max" || this.properties.OP == "min")
			return this.properties.OP + "(A,B)";
        return "A " + this.properties.OP + " B";
    };

    MathOperation.prototype.setValue = function(v) {
        if (typeof v == "string") {
            v = parseFloat(v);
        }
        this.properties["value"] = v;
    };

    MathOperation.prototype.onPropertyChanged = function(name, value)
	{
		if (name != "OP")
			return;
        switch (this.properties.OP) {
            case "+": this._func = function(A,B) { return A + B; }; break;
            case "-": this._func = function(A,B) { return A - B; }; break;
            case "x":
            case "X":
            case "*": this._func = function(A,B) { return A * B; }; break;
            case "/": this._func = function(A,B) { return A / B; }; break;
            case "%": this._func = function(A,B) { return A % B; }; break;
            case "^": this._func = function(A,B) { return Math.pow(A, B); }; break;
            case "max": this._func = function(A,B) { return Math.max(A, B); }; break;
            case "min": this._func = function(A,B) { return Math.min(A, B); }; break;
			default: 
				console.warn("Unknown operation: " + this.properties.OP);
				this._func = function(A) { return A; };
				break;
        }
	}

    MathOperation.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        if ( A != null ) {
			if( A.constructor === Number )
	            this.properties["A"] = A;
        } else {
            A = this.properties["A"];
        }

        if (B != null) {
            this.properties["B"] = B;
        } else {
            B = this.properties["B"];
        }

		var result;
		if(A.constructor === Number)
		{
	        result = 0;
			result = this._func(A,B);
		}
		else if(A.constructor === Array)
		{
			result = this._result;
			result.length = A.length;
			for(var i = 0; i < A.length; ++i)
				result[i] = this._func(A[i],B);
		}
		else
		{
			result = {};
			for(var i in A)
				result[i] = this._func(A[i],B);
		}
	    this.setOutputData(0, result);
    };

    MathOperation.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.font = "40px Arial";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.OP,
            this.size[0] * 0.5,
            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5
        );
        ctx.textAlign = "left";
    };

    LiteGraph.registerNodeType("math/operation", MathOperation);

    LiteGraph.registerSearchboxExtra("math/operation", "MAX", {
        properties: {OP:"max"},
        title: "MAX()"
    });

    LiteGraph.registerSearchboxExtra("math/operation", "MIN", {
        properties: {OP:"min"},
        title: "MIN()"
    });


    //Math compare
    function MathCompare() {
        this.addInput("A", "number");
        this.addInput("B", "number");
        this.addOutput("A==B", "boolean");
        this.addOutput("A!=B", "boolean");
        this.addProperty("A", 0);
        this.addProperty("B", 0);
    }

    MathCompare.title = "Compare";
    MathCompare.desc = "compares between two values";

    MathCompare.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
        if (A !== undefined) {
            this.properties["A"] = A;
        } else {
            A = this.properties["A"];
        }

        if (B !== undefined) {
            this.properties["B"] = B;
        } else {
            B = this.properties["B"];
        }

        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            var output = this.outputs[i];
            if (!output.links || !output.links.length) {
                continue;
            }
            var value;
            switch (output.name) {
                case "A==B":
                    value = A == B;
                    break;
                case "A!=B":
                    value = A != B;
                    break;
                case "A>B":
                    value = A > B;
                    break;
                case "A<B":
                    value = A < B;
                    break;
                case "A<=B":
                    value = A <= B;
                    break;
                case "A>=B":
                    value = A >= B;
                    break;
            }
            this.setOutputData(i, value);
        }
    };

    MathCompare.prototype.onGetOutputs = function() {
        return [
            ["A==B", "boolean"],
            ["A!=B", "boolean"],
            ["A>B", "boolean"],
            ["A<B", "boolean"],
            ["A>=B", "boolean"],
            ["A<=B", "boolean"]
        ];
    };

    LiteGraph.registerNodeType("math/compare", MathCompare);

    LiteGraph.registerSearchboxExtra("math/compare", "==", {
        outputs: [["A==B", "boolean"]],
        title: "A==B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", "!=", {
        outputs: [["A!=B", "boolean"]],
        title: "A!=B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", ">", {
        outputs: [["A>B", "boolean"]],
        title: "A>B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", "<", {
        outputs: [["A<B", "boolean"]],
        title: "A<B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", ">=", {
        outputs: [["A>=B", "boolean"]],
        title: "A>=B"
    });
    LiteGraph.registerSearchboxExtra("math/compare", "<=", {
        outputs: [["A<=B", "boolean"]],
        title: "A<=B"
    });

    function MathCondition() {
        this.addInput("A", "number");
        this.addInput("B", "number");
        this.addOutput("true", "boolean");
        this.addOutput("false", "boolean");
        this.addProperty("A", 1);
        this.addProperty("B", 1);
        this.addProperty("OP", ">", "enum", { values: MathCondition.values });
		this.addWidget("combo","Cond.",this.properties.OP,{ property: "OP", values: MathCondition.values } );

        this.size = [80, 60];
    }

    MathCondition.values = [">", "<", "==", "!=", "<=", ">=", "||", "&&" ];
    MathCondition["@OP"] = {
        type: "enum",
        title: "operation",
        values: MathCondition.values
    };

    MathCondition.title = "Condition";
    MathCondition.desc = "evaluates condition between A and B";

    MathCondition.prototype.getTitle = function() {
        return "A " + this.properties.OP + " B";
    };

    MathCondition.prototype.onExecute = function() {
        var A = this.getInputData(0);
        if (A === undefined) {
            A = this.properties.A;
        } else {
            this.properties.A = A;
        }

        var B = this.getInputData(1);
        if (B === undefined) {
            B = this.properties.B;
        } else {
            this.properties.B = B;
        }

        var result = true;
        switch (this.properties.OP) {
            case ">":
                result = A > B;
                break;
            case "<":
                result = A < B;
                break;
            case "==":
                result = A == B;
                break;
            case "!=":
                result = A != B;
                break;
            case "<=":
                result = A <= B;
                break;
            case ">=":
                result = A >= B;
                break;
            case "||":
                result = A || B;
                break;
            case "&&":
                result = A && B;
                break;
        }

        this.setOutputData(0, result);
        this.setOutputData(1, !result);
    };

    LiteGraph.registerNodeType("math/condition", MathCondition);


    function MathBranch() {
        this.addInput("in", "");
        this.addInput("cond", "boolean");
        this.addOutput("true", "");
        this.addOutput("false", "");
        this.size = [80, 60];
    }

    MathBranch.title = "Branch";
    MathBranch.desc = "If condition is true, outputs IN in true, otherwise in false";

    MathBranch.prototype.onExecute = function() {
        var V = this.getInputData(0);
        var cond = this.getInputData(1);

		if(cond)
		{
			this.setOutputData(0, V);
			this.setOutputData(1, null);
		}
		else
		{
			this.setOutputData(0, null);
			this.setOutputData(1, V);
		}
	}

    LiteGraph.registerNodeType("math/branch", MathBranch);


    function MathAccumulate() {
        this.addInput("inc", "number");
        this.addOutput("total", "number");
        this.addProperty("increment", 1);
        this.addProperty("value", 0);
    }

    MathAccumulate.title = "Accumulate";
    MathAccumulate.desc = "Increments a value every time";

    MathAccumulate.prototype.onExecute = function() {
        if (this.properties.value === null) {
            this.properties.value = 0;
        }

        var inc = this.getInputData(0);
        if (inc !== null) {
            this.properties.value += inc;
        } else {
            this.properties.value += this.properties.increment;
        }
        this.setOutputData(0, this.properties.value);
    };

    LiteGraph.registerNodeType("math/accumulate", MathAccumulate);

    //Math Trigonometry
    function MathTrigonometry() {
        this.addInput("v", "number");
        this.addOutput("sin", "number");

        this.addProperty("amplitude", 1);
        this.addProperty("offset", 0);
        this.bgImageUrl = "nodes/imgs/icon-sin.png";
    }

    MathTrigonometry.title = "Trigonometry";
    MathTrigonometry.desc = "Sin Cos Tan";
    //MathTrigonometry.filter = "shader";

    MathTrigonometry.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            v = 0;
        }
        var amplitude = this.properties["amplitude"];
        var slot = this.findInputSlot("amplitude");
        if (slot != -1) {
            amplitude = this.getInputData(slot);
        }
        var offset = this.properties["offset"];
        slot = this.findInputSlot("offset");
        if (slot != -1) {
            offset = this.getInputData(slot);
        }

        for (var i = 0, l = this.outputs.length; i < l; ++i) {
            var output = this.outputs[i];
            var value;
            switch (output.name) {
                case "sin":
                    value = Math.sin(v);
                    break;
                case "cos":
                    value = Math.cos(v);
                    break;
                case "tan":
                    value = Math.tan(v);
                    break;
                case "asin":
                    value = Math.asin(v);
                    break;
                case "acos":
                    value = Math.acos(v);
                    break;
                case "atan":
                    value = Math.atan(v);
                    break;
            }
            this.setOutputData(i, amplitude * value + offset);
        }
    };

    MathTrigonometry.prototype.onGetInputs = function() {
        return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];
    };

    MathTrigonometry.prototype.onGetOutputs = function() {
        return [
            ["sin", "number"],
            ["cos", "number"],
            ["tan", "number"],
            ["asin", "number"],
            ["acos", "number"],
            ["atan", "number"]
        ];
    };

    LiteGraph.registerNodeType("math/trigonometry", MathTrigonometry);

    LiteGraph.registerSearchboxExtra("math/trigonometry", "SIN()", {
        outputs: [["sin", "number"]],
        title: "SIN()"
    });
    LiteGraph.registerSearchboxExtra("math/trigonometry", "COS()", {
        outputs: [["cos", "number"]],
        title: "COS()"
    });
    LiteGraph.registerSearchboxExtra("math/trigonometry", "TAN()", {
        outputs: [["tan", "number"]],
        title: "TAN()"
    });

    //math library for safe math operations without eval
    function MathFormula() {
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.addOutput("", "number");
        this.properties = { x: 1.0, y: 1.0, formula: "x+y" };
        this.code_widget = this.addWidget(
            "text",
            "F(x,y)",
            this.properties.formula,
            function(v, canvas, node) {
                node.properties.formula = v;
            }
        );
        this.addWidget("toggle", "allow", LiteGraph.allow_scripts, function(v) {
            LiteGraph.allow_scripts = v;
        });
        this._func = null;
    }

    MathFormula.title = "Formula";
    MathFormula.desc = "Compute formula";
    MathFormula.size = [160, 100];

    MathAverageFilter.prototype.onPropertyChanged = function(name, value) {
        if (name == "formula") {
            this.code_widget.value = value;
        }
    };

    MathFormula.prototype.onExecute = function() {
        if (!LiteGraph.allow_scripts) {
            return;
        }

        var x = this.getInputData(0);
        var y = this.getInputData(1);
        if (x != null) {
            this.properties["x"] = x;
        } else {
            x = this.properties["x"];
        }

        if (y != null) {
            this.properties["y"] = y;
        } else {
            y = this.properties["y"];
        }

        var f = this.properties["formula"];

        var value;
        try {
            if (!this._func || this._func_code != this.properties.formula) {
                this._func = new Function(
                    "x",
                    "y",
                    "TIME",
                    "return " + this.properties.formula
                );
                this._func_code = this.properties.formula;
            }
            value = this._func(x, y, this.graph.globaltime);
            this.boxcolor = null;
        } catch (err) {
            this.boxcolor = "red";
        }
        this.setOutputData(0, value);
    };

    MathFormula.prototype.getTitle = function() {
        return this._func_code || "Formula";
    };

    MathFormula.prototype.onDrawBackground = function() {
        var f = this.properties["formula"];
        if (this.outputs && this.outputs.length) {
            this.outputs[0].label = f;
        }
    };

    LiteGraph.registerNodeType("math/formula", MathFormula);

    function Math3DVec2ToXY() {
        this.addInput("vec2", "vec2");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
    }

    Math3DVec2ToXY.title = "Vec2->XY";
    Math3DVec2ToXY.desc = "vector 2 to components";

    Math3DVec2ToXY.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
    };

    LiteGraph.registerNodeType("math3d/vec2-to-xy", Math3DVec2ToXY);

    function Math3DXYToVec2() {
        this.addInputs([["x", "number"], ["y", "number"]]);
        this.addOutput("vec2", "vec2");
        this.properties = { x: 0, y: 0 };
        this._data = new Float32Array(2);
    }

    Math3DXYToVec2.title = "XY->Vec2";
    Math3DXYToVec2.desc = "components to vector2";

    Math3DXYToVec2.prototype.onExecute = function() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/xy-to-vec2", Math3DXYToVec2);

    function Math3DVec3ToXYZ() {
        this.addInput("vec3", "vec3");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
        this.addOutput("z", "number");
    }

    Math3DVec3ToXYZ.title = "Vec3->XYZ";
    Math3DVec3ToXYZ.desc = "vector 3 to components";

    Math3DVec3ToXYZ.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
        this.setOutputData(2, v[2]);
    };

    LiteGraph.registerNodeType("math3d/vec3-to-xyz", Math3DVec3ToXYZ);

    function Math3DXYZToVec3() {
        this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);
        this.addOutput("vec3", "vec3");
        this.properties = { x: 0, y: 0, z: 0 };
        this._data = new Float32Array(3);
    }

    Math3DXYZToVec3.title = "XYZ->Vec3";
    Math3DXYZToVec3.desc = "components to vector3";

    Math3DXYZToVec3.prototype.onExecute = function() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }
        var z = this.getInputData(2);
        if (z == null) {
            z = this.properties.z;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;
        data[2] = z;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/xyz-to-vec3", Math3DXYZToVec3);

    function Math3DVec4ToXYZW() {
        this.addInput("vec4", "vec4");
        this.addOutput("x", "number");
        this.addOutput("y", "number");
        this.addOutput("z", "number");
        this.addOutput("w", "number");
    }

    Math3DVec4ToXYZW.title = "Vec4->XYZW";
    Math3DVec4ToXYZW.desc = "vector 4 to components";

    Math3DVec4ToXYZW.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }

        this.setOutputData(0, v[0]);
        this.setOutputData(1, v[1]);
        this.setOutputData(2, v[2]);
        this.setOutputData(3, v[3]);
    };

    LiteGraph.registerNodeType("math3d/vec4-to-xyzw", Math3DVec4ToXYZW);

    function Math3DXYZWToVec4() {
        this.addInputs([
            ["x", "number"],
            ["y", "number"],
            ["z", "number"],
            ["w", "number"]
        ]);
        this.addOutput("vec4", "vec4");
        this.properties = { x: 0, y: 0, z: 0, w: 0 };
        this._data = new Float32Array(4);
    }

    Math3DXYZWToVec4.title = "XYZW->Vec4";
    Math3DXYZWToVec4.desc = "components to vector4";

    Math3DXYZWToVec4.prototype.onExecute = function() {
        var x = this.getInputData(0);
        if (x == null) {
            x = this.properties.x;
        }
        var y = this.getInputData(1);
        if (y == null) {
            y = this.properties.y;
        }
        var z = this.getInputData(2);
        if (z == null) {
            z = this.properties.z;
        }
        var w = this.getInputData(3);
        if (w == null) {
            w = this.properties.w;
        }

        var data = this._data;
        data[0] = x;
        data[1] = y;
        data[2] = z;
        data[3] = w;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/xyzw-to-vec4", Math3DXYZWToVec4);

})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;


	function Math3DMat4()
	{
        this.addInput("T", "vec3");
        this.addInput("R", "vec3");
        this.addInput("S", "vec3");
        this.addOutput("mat4", "mat4");
		this.properties = {
			"T":[0,0,0],
			"R":[0,0,0],
			"S":[1,1,1],
			R_in_degrees: true
		};
		this._result = mat4.create();
		this._must_update = true;
	}

	Math3DMat4.title = "mat4";
	Math3DMat4.temp_quat = new Float32Array([0,0,0,1]);
	Math3DMat4.temp_mat4 = new Float32Array(16);
	Math3DMat4.temp_vec3 = new Float32Array(3);

	Math3DMat4.prototype.onPropertyChanged = function(name, value)
	{
		this._must_update = true;
	}

	Math3DMat4.prototype.onExecute = function()
	{
		var M = this._result;
		var Q = Math3DMat4.temp_quat;
		var temp_mat4 = Math3DMat4.temp_mat4;
		var temp_vec3 = Math3DMat4.temp_vec3;

		var T = this.getInputData(0);
		var R = this.getInputData(1);
		var S = this.getInputData(2);

		if( this._must_update || T || R || S )
		{
			T = T || this.properties.T;
			R = R || this.properties.R;
			S = S || this.properties.S;
			mat4.identity( M );
			mat4.translate( M, M, T );
			if(this.properties.R_in_degrees)
			{
				temp_vec3.set( R );
				vec3.scale(temp_vec3,temp_vec3,DEG2RAD);
				quat.fromEuler( Q, temp_vec3 );
			}
			else
				quat.fromEuler( Q, R );
			mat4.fromQuat( temp_mat4, Q );
			mat4.multiply( M, M, temp_mat4 );
			mat4.scale( M, M, S );
		}

		this.setOutputData(0, M);		
	}

    LiteGraph.registerNodeType("math3d/mat4", Math3DMat4);

    //Math 3D operation
    function Math3DOperation() {
        this.addInput("A", "number,vec3");
        this.addInput("B", "number,vec3");
        this.addOutput("=", "number,vec3");
        this.addProperty("OP", "+", "enum", { values: Math3DOperation.values });
		this._result = vec3.create();
    }

    Math3DOperation.values = ["+", "-", "*", "/", "%", "^", "max", "min","dot","cross"];

    LiteGraph.registerSearchboxExtra("math3d/operation", "CROSS()", {
        properties: {"OP":"cross"},
        title: "CROSS()"
    });

    LiteGraph.registerSearchboxExtra("math3d/operation", "DOT()", {
        properties: {"OP":"dot"},
        title: "DOT()"
    });

	Math3DOperation.title = "Operation";
    Math3DOperation.desc = "Easy math 3D operators";
    Math3DOperation["@OP"] = {
        type: "enum",
        title: "operation",
        values: Math3DOperation.values
    };
    Math3DOperation.size = [100, 60];

    Math3DOperation.prototype.getTitle = function() {
		if(this.properties.OP == "max" || this.properties.OP == "min" )
			return this.properties.OP + "(A,B)";
        return "A " + this.properties.OP + " B";
    };

    Math3DOperation.prototype.onExecute = function() {
        var A = this.getInputData(0);
        var B = this.getInputData(1);
		if(A == null || B == null)
			return;
		if(A.constructor === Number)
			A = [A,A,A];
		if(B.constructor === Number)
			B = [B,B,B];

        var result = this._result;
        switch (this.properties.OP) {
            case "+":
                result = vec3.add(result,A,B);
                break;
            case "-":
                result = vec3.sub(result,A,B);
                break;
            case "x":
            case "X":
            case "*":
                result = vec3.mul(result,A,B);
                break;
            case "/":
                result = vec3.div(result,A,B);
                break;
            case "%":
                result[0] = A[0]%B[0];
                result[1] = A[1]%B[1];
                result[2] = A[2]%B[2];
                break;
            case "^":
                result[0] = Math.pow(A[0],B[0]);
                result[1] = Math.pow(A[1],B[1]);
                result[2] = Math.pow(A[2],B[2]);
                break;
            case "max":
                result[0] = Math.max(A[0],B[0]);
                result[1] = Math.max(A[1],B[1]);
                result[2] = Math.max(A[2],B[2]);
                break;
            case "min":
                result[0] = Math.min(A[0],B[0]);
                result[1] = Math.min(A[1],B[1]);
                result[2] = Math.min(A[2],B[2]);
            case "dot":
                result = vec3.dot(A,B);
                break;
            case "cross":
                vec3.cross(result,A,B);
                break;
            default:
                console.warn("Unknown operation: " + this.properties.OP);
        }
        this.setOutputData(0, result);
    };

    Math3DOperation.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        ctx.font = "40px Arial";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.fillText(
            this.properties.OP,
            this.size[0] * 0.5,
            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5
        );
        ctx.textAlign = "left";
    };

    LiteGraph.registerNodeType("math3d/operation", Math3DOperation);

    function Math3DVec3Scale() {
        this.addInput("in", "vec3");
        this.addInput("f", "number");
        this.addOutput("out", "vec3");
        this.properties = { f: 1 };
        this._data = new Float32Array(3);
    }

    Math3DVec3Scale.title = "vec3_scale";
    Math3DVec3Scale.desc = "scales the components of a vec3";

    Math3DVec3Scale.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var f = this.getInputData(1);
        if (f == null) {
            f = this.properties.f;
        }

        var data = this._data;
        data[0] = v[0] * f;
        data[1] = v[1] * f;
        data[2] = v[2] * f;
        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/vec3-scale", Math3DVec3Scale);

    function Math3DVec3Length() {
        this.addInput("in", "vec3");
        this.addOutput("out", "number");
    }

    Math3DVec3Length.title = "vec3_length";
    Math3DVec3Length.desc = "returns the module of a vector";

    Math3DVec3Length.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        this.setOutputData(0, dist);
    };

    LiteGraph.registerNodeType("math3d/vec3-length", Math3DVec3Length);

    function Math3DVec3Normalize() {
        this.addInput("in", "vec3");
        this.addOutput("out", "vec3");
        this._data = new Float32Array(3);
    }

    Math3DVec3Normalize.title = "vec3_normalize";
    Math3DVec3Normalize.desc = "returns the vector normalized";

    Math3DVec3Normalize.prototype.onExecute = function() {
        var v = this.getInputData(0);
        if (v == null) {
            return;
        }
        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        var data = this._data;
        data[0] = v[0] / dist;
        data[1] = v[1] / dist;
        data[2] = v[2] / dist;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/vec3-normalize", Math3DVec3Normalize);

    function Math3DVec3Lerp() {
        this.addInput("A", "vec3");
        this.addInput("B", "vec3");
        this.addInput("f", "vec3");
        this.addOutput("out", "vec3");
        this.properties = { f: 0.5 };
        this._data = new Float32Array(3);
    }

    Math3DVec3Lerp.title = "vec3_lerp";
    Math3DVec3Lerp.desc = "returns the interpolated vector";

    Math3DVec3Lerp.prototype.onExecute = function() {
        var A = this.getInputData(0);
        if (A == null) {
            return;
        }
        var B = this.getInputData(1);
        if (B == null) {
            return;
        }
        var f = this.getInputOrProperty("f");

        var data = this._data;
        data[0] = A[0] * (1 - f) + B[0] * f;
        data[1] = A[1] * (1 - f) + B[1] * f;
        data[2] = A[2] * (1 - f) + B[2] * f;

        this.setOutputData(0, data);
    };

    LiteGraph.registerNodeType("math3d/vec3-lerp", Math3DVec3Lerp);

    function Math3DVec3Dot() {
        this.addInput("A", "vec3");
        this.addInput("B", "vec3");
        this.addOutput("out", "number");
    }

    Math3DVec3Dot.title = "vec3_dot";
    Math3DVec3Dot.desc = "returns the dot product";

    Math3DVec3Dot.prototype.onExecute = function() {
        var A = this.getInputData(0);
        if (A == null) {
            return;
        }
        var B = this.getInputData(1);
        if (B == null) {
            return;
        }

        var dot = A[0] * B[0] + A[1] * B[1] + A[2] * B[2];
        this.setOutputData(0, dot);
    };

    LiteGraph.registerNodeType("math3d/vec3-dot", Math3DVec3Dot);

    //if glMatrix is installed...
    if (global.glMatrix) {
        function Math3DQuaternion() {
            this.addOutput("quat", "quat");
            this.properties = { x: 0, y: 0, z: 0, w: 1, normalize: false };
            this._value = quat.create();
        }

        Math3DQuaternion.title = "Quaternion";
        Math3DQuaternion.desc = "quaternion";

        Math3DQuaternion.prototype.onExecute = function() {
            this._value[0] = this.getInputOrProperty("x");
            this._value[1] = this.getInputOrProperty("y");
            this._value[2] = this.getInputOrProperty("z");
            this._value[3] = this.getInputOrProperty("w");
            if (this.properties.normalize) {
                quat.normalize(this._value, this._value);
            }
            this.setOutputData(0, this._value);
        };

        Math3DQuaternion.prototype.onGetInputs = function() {
            return [
                ["x", "number"],
                ["y", "number"],
                ["z", "number"],
                ["w", "number"]
            ];
        };

        LiteGraph.registerNodeType("math3d/quaternion", Math3DQuaternion);

        function Math3DRotation() {
            this.addInputs([["degrees", "number"], ["axis", "vec3"]]);
            this.addOutput("quat", "quat");
            this.properties = { angle: 90.0, axis: vec3.fromValues(0, 1, 0) };

            this._value = quat.create();
        }

        Math3DRotation.title = "Rotation";
        Math3DRotation.desc = "quaternion rotation";

        Math3DRotation.prototype.onExecute = function() {
            var angle = this.getInputData(0);
            if (angle == null) {
                angle = this.properties.angle;
            }
            var axis = this.getInputData(1);
            if (axis == null) {
                axis = this.properties.axis;
            }

            var R = quat.setAxisAngle(this._value, axis, angle * 0.0174532925);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/rotation", Math3DRotation);


        function MathEulerToQuat() {
            this.addInput("euler", "vec3");
            this.addOutput("quat", "quat");
            this.properties = { euler:[0,0,0], use_yaw_pitch_roll: false };
			this._degs = vec3.create();
            this._value = quat.create();
        }

        MathEulerToQuat.title = "Euler->Quat";
        MathEulerToQuat.desc = "Converts euler angles (in degrees) to quaternion";

        MathEulerToQuat.prototype.onExecute = function() {
            var euler = this.getInputData(0);
            if (euler == null) {
                euler = this.properties.euler;
            }
			vec3.scale( this._degs, euler, DEG2RAD );
			if(this.properties.use_yaw_pitch_roll)
				this._degs = [this._degs[2],this._degs[0],this._degs[1]];
            var R = quat.fromEuler(this._value, this._degs);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/euler_to_quat", MathEulerToQuat);

        function MathQuatToEuler() {
            this.addInput(["quat", "quat"]);
            this.addOutput("euler", "vec3");
			this._value = vec3.create();
        }

        MathQuatToEuler.title = "Euler->Quat";
        MathQuatToEuler.desc = "Converts rotX,rotY,rotZ in degrees to quat";

        MathQuatToEuler.prototype.onExecute = function() {
            var q = this.getInputData(0);
			if(!q)
				return;
            var R = quat.toEuler(this._value, q);
			vec3.scale( this._value, this._value, DEG2RAD );
            this.setOutputData(0, this._value);
        };

        LiteGraph.registerNodeType("math3d/quat_to_euler", MathQuatToEuler);


        //Math3D rotate vec3
        function Math3DRotateVec3() {
            this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);
            this.addOutput("result", "vec3");
            this.properties = { vec: [0, 0, 1] };
        }

        Math3DRotateVec3.title = "Rot. Vec3";
        Math3DRotateVec3.desc = "rotate a point";

        Math3DRotateVec3.prototype.onExecute = function() {
            var vec = this.getInputData(0);
            if (vec == null) {
                vec = this.properties.vec;
            }
            var quat = this.getInputData(1);
            if (quat == null) {
                this.setOutputData(vec);
            } else {
                this.setOutputData(
                    0,
                    vec3.transformQuat(vec3.create(), vec, quat)
                );
            }
        };

        LiteGraph.registerNodeType("math3d/rotate_vec3", Math3DRotateVec3);

        function Math3DMultQuat() {
            this.addInputs([["A", "quat"], ["B", "quat"]]);
            this.addOutput("A*B", "quat");

            this._value = quat.create();
        }

        Math3DMultQuat.title = "Mult. Quat";
        Math3DMultQuat.desc = "rotate quaternion";

        Math3DMultQuat.prototype.onExecute = function() {
            var A = this.getInputData(0);
            if (A == null) {
                return;
            }
            var B = this.getInputData(1);
            if (B == null) {
                return;
            }

            var R = quat.multiply(this._value, A, B);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/mult-quat", Math3DMultQuat);

        function Math3DQuatSlerp() {
            this.addInputs([
                ["A", "quat"],
                ["B", "quat"],
                ["factor", "number"]
            ]);
            this.addOutput("slerp", "quat");
            this.addProperty("factor", 0.5);

            this._value = quat.create();
        }

        Math3DQuatSlerp.title = "Quat Slerp";
        Math3DQuatSlerp.desc = "quaternion spherical interpolation";

        Math3DQuatSlerp.prototype.onExecute = function() {
            var A = this.getInputData(0);
            if (A == null) {
                return;
            }
            var B = this.getInputData(1);
            if (B == null) {
                return;
            }
            var factor = this.properties.factor;
            if (this.getInputData(2) != null) {
                factor = this.getInputData(2);
            }

            var R = quat.slerp(this._value, A, B, factor);
            this.setOutputData(0, R);
        };

        LiteGraph.registerNodeType("math3d/quat-slerp", Math3DQuatSlerp);


        //Math3D rotate vec3
        function Math3DRemapRange() {
            this.addInput("vec3", "vec3");
            this.addOutput("remap", "vec3");
			this.addOutput("clamped", "vec3");
            this.properties = { clamp: true, range_min: [-1, -1, 0], range_max: [1, 1, 0], target_min: [-1,-1,0], target_max:[1,1,0] };
			this._value = vec3.create();
			this._clamped = vec3.create();
        }

        Math3DRemapRange.title = "Remap Range";
        Math3DRemapRange.desc = "remap a 3D range";

        Math3DRemapRange.prototype.onExecute = function() {
            var vec = this.getInputData(0);
			if(vec)
				this._value.set(vec);
			var range_min = this.properties.range_min;
			var range_max = this.properties.range_max;
			var target_min = this.properties.target_min;
			var target_max = this.properties.target_max;

			//swap to avoid errors
			/*
			if(range_min > range_max)
			{
				range_min = range_max;
				range_max = this.properties.range_min;
			}

			if(target_min > target_max)
			{
				target_min = target_max;
				target_max = this.properties.target_min;
			}
			*/

			for(var i = 0; i < 3; ++i)
			{
				var r = range_max[i] - range_min[i];
				this._clamped[i] = Math.clamp( this._value[i], range_min[i], range_max[i] );
				if(r == 0)
				{
					this._value[i] = (target_min[i] + target_max[i]) * 0.5;
					continue;
				}

				var n = (this._value[i] - range_min[i]) / r;
				if(this.properties.clamp)
					n = Math.clamp(n,0,1);
				var t = target_max[i] - target_min[i];
				this._value[i] = target_min[i] + n * t;
			}

			this.setOutputData(0,this._value);
			this.setOutputData(1,this._clamped);
        };

        LiteGraph.registerNodeType("math3d/remap_range", Math3DRemapRange);



    } //glMatrix
	else
		console.warn("No glmatrix found, some Math3D nodes may not work");

})(this);

//basic nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    function toString(a) {
		if(a && a.constructor === Object)
		{
			try
			{
				return JSON.stringify(a);
			}
			catch (err)
			{
				return String(a);
			}
		}
        return String(a);
    }

    LiteGraph.wrapFunctionAsNode("string/toString", toString, [""], "String");

    function compare(a, b) {
        return a == b;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/compare",
        compare,
        ["string", "string"],
        "boolean"
    );

    function concatenate(a, b) {
        if (a === undefined) {
            return b;
        }
        if (b === undefined) {
            return a;
        }
        return a + b;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/concatenate",
        concatenate,
        ["string", "string"],
        "string"
    );

    function contains(a, b) {
        if (a === undefined || b === undefined) {
            return false;
        }
        return a.indexOf(b) != -1;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/contains",
        contains,
        ["string", "string"],
        "boolean"
    );

    function toUpperCase(a) {
        if (a != null && a.constructor === String) {
            return a.toUpperCase();
        }
        return a;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/toUpperCase",
        toUpperCase,
        ["string"],
        "string"
    );

    function split(str, separator) {
		if(separator == null)
			separator = this.properties.separator;
        if (str == null )
	        return [];
		if( str.constructor === String )
			return str.split(separator || " ");
		else if( str.constructor === Array )
		{
			var r = [];
			for(var i = 0; i < str.length; ++i)
				r[i] = str[i].split(separator || " ");
			return r;
		}
        return null;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/split",
        split,
        ["string,array", "string"],
        "array",
		{ separator: "," }
    );

    function toFixed(a) {
        if (a != null && a.constructor === Number) {
            return a.toFixed(this.properties.precision);
        }
        return a;
    }

    LiteGraph.wrapFunctionAsNode(
        "string/toFixed",
        toFixed,
        ["number"],
        "string",
        { precision: 0 }
    );


    function StringToTable() {
        this.addInput("", "string");
        this.addOutput("table", "table");
        this.addOutput("rows", "number");
        this.addProperty("value", "");
        this.addProperty("separator", ",");
		this._table = null;
    }

    StringToTable.title = "toTable";
    StringToTable.desc = "Splits a string to table";

    StringToTable.prototype.onExecute = function() {
        var input = this.getInputData(0);
		if(!input)
			return;
		var separator = this.properties.separator || ",";
		if(input != this._str || separator != this._last_separator )
		{
			this._last_separator = separator;
			this._str = input;
			this._table = input.split("\n").map(function(a){ return a.trim().split(separator)});
		}
        this.setOutputData(0, this._table );
        this.setOutputData(1, this._table ? this._table.length : 0 );
    };

    LiteGraph.registerNodeType("string/toTable", StringToTable);

})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    function Selector() {
        this.addInput("sel", "number");
        this.addInput("A");
        this.addInput("B");
        this.addInput("C");
        this.addInput("D");
        this.addOutput("out");

        this.selected = 0;
    }

    Selector.title = "Selector";
    Selector.desc = "selects an output";

    Selector.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        ctx.fillStyle = "#AFB";
        var y = (this.selected + 1) * LiteGraph.NODE_SLOT_HEIGHT + 6;
        ctx.beginPath();
        ctx.moveTo(50, y);
        ctx.lineTo(50, y + LiteGraph.NODE_SLOT_HEIGHT);
        ctx.lineTo(34, y + LiteGraph.NODE_SLOT_HEIGHT * 0.5);
        ctx.fill();
    };

    Selector.prototype.onExecute = function() {
        var sel = this.getInputData(0);
        if (sel == null || sel.constructor !== Number)
            sel = 0;
        this.selected = sel = Math.round(sel) % (this.inputs.length - 1);
        var v = this.getInputData(sel + 1);
        if (v !== undefined) {
            this.setOutputData(0, v);
        }
    };

    Selector.prototype.onGetInputs = function() {
        return [["E", 0], ["F", 0], ["G", 0], ["H", 0]];
    };

    LiteGraph.registerNodeType("logic/selector", Selector);

    function Sequence() {
        this.properties = {
            sequence: "A,B,C"
        };
        this.addInput("index", "number");
        this.addInput("seq");
        this.addOutput("out");

        this.index = 0;
        this.values = this.properties.sequence.split(",");
    }

    Sequence.title = "Sequence";
    Sequence.desc = "select one element from a sequence from a string";

    Sequence.prototype.onPropertyChanged = function(name, value) {
        if (name == "sequence") {
            this.values = value.split(",");
        }
    };

    Sequence.prototype.onExecute = function() {
        var seq = this.getInputData(1);
        if (seq && seq != this.current_sequence) {
            this.values = seq.split(",");
            this.current_sequence = seq;
        }
        var index = this.getInputData(0);
        if (index == null) {
            index = 0;
        }
        this.index = index = Math.round(index) % this.values.length;

        this.setOutputData(0, this.values[index]);
    };

    LiteGraph.registerNodeType("logic/sequence", Sequence);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    function GraphicsPlot() {
        this.addInput("A", "Number");
        this.addInput("B", "Number");
        this.addInput("C", "Number");
        this.addInput("D", "Number");

        this.values = [[], [], [], []];
        this.properties = { scale: 2 };
    }

    GraphicsPlot.title = "Plot";
    GraphicsPlot.desc = "Plots data over time";
    GraphicsPlot.colors = ["#FFF", "#F99", "#9F9", "#99F"];

    GraphicsPlot.prototype.onExecute = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size;

        for (var i = 0; i < 4; ++i) {
            var v = this.getInputData(i);
            if (v == null) {
                continue;
            }
            var values = this.values[i];
            values.push(v);
            if (values.length > size[0]) {
                values.shift();
            }
        }
    };

    GraphicsPlot.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var size = this.size;

        var scale = (0.5 * size[1]) / this.properties.scale;
        var colors = GraphicsPlot.colors;
        var offset = size[1] * 0.5;

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, size[0], size[1]);
        ctx.strokeStyle = "#555";
        ctx.beginPath();
        ctx.moveTo(0, offset);
        ctx.lineTo(size[0], offset);
        ctx.stroke();

        if (this.inputs) {
            for (var i = 0; i < 4; ++i) {
                var values = this.values[i];
                if (!this.inputs[i] || !this.inputs[i].link) {
                    continue;
                }
                ctx.strokeStyle = colors[i];
                ctx.beginPath();
                var v = values[0] * scale * -1 + offset;
                ctx.moveTo(0, Math.clamp(v, 0, size[1]));
                for (var j = 1; j < values.length && j < size[0]; ++j) {
                    var v = values[j] * scale * -1 + offset;
                    ctx.lineTo(j, Math.clamp(v, 0, size[1]));
                }
                ctx.stroke();
            }
        }
    };

    LiteGraph.registerNodeType("graphics/plot", GraphicsPlot);

    function GraphicsImage() {
        this.addOutput("frame", "image");
        this.properties = { url: "" };
    }

    GraphicsImage.title = "Image";
    GraphicsImage.desc = "Image loader";
    GraphicsImage.widgets = [{ name: "load", text: "Load", type: "button" }];

    GraphicsImage.supported_extensions = ["jpg", "jpeg", "png", "gif"];

    GraphicsImage.prototype.onAdded = function() {
        if (this.properties["url"] != "" && this.img == null) {
            this.loadImage(this.properties["url"]);
        }
    };

    GraphicsImage.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        if (this.img && this.size[0] > 5 && this.size[1] > 5 && this.img.width) {
            ctx.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
        }
    };

    GraphicsImage.prototype.onExecute = function() {
        if (!this.img) {
            this.boxcolor = "#000";
        }
        if (this.img && this.img.width) {
            this.setOutputData(0, this.img);
        } else {
            this.setOutputData(0, null);
        }
        if (this.img && this.img.dirty) {
            this.img.dirty = false;
        }
    };

    GraphicsImage.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;
        if (name == "url" && value != "") {
            this.loadImage(value);
        }

        return true;
    };

    GraphicsImage.prototype.loadImage = function(url, callback) {
        if (url == "") {
            this.img = null;
            return;
        }

        this.img = document.createElement("img");

        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }

        this.img.src = url;
        this.boxcolor = "#F95";
        var that = this;
        this.img.onload = function() {
            if (callback) {
                callback(this);
            }
            console.log( "Image loaded, size: " + that.img.width + "x" + that.img.height );
            this.dirty = true;
            that.boxcolor = "#9F9";
            that.setDirtyCanvas(true);
        };
        this.img.onerror = function() {
			console.log("error loading the image:" + url);
		}
    };

    GraphicsImage.prototype.onWidget = function(e, widget) {
        if (widget.name == "load") {
            this.loadImage(this.properties["url"]);
        }
    };

    GraphicsImage.prototype.onDropFile = function(file) {
        var that = this;
        if (this._url) {
            URL.revokeObjectURL(this._url);
        }
        this._url = URL.createObjectURL(file);
        this.properties.url = this._url;
        this.loadImage(this._url, function(img) {
            that.size[1] = (img.height / img.width) * that.size[0];
        });
    };

    LiteGraph.registerNodeType("graphics/image", GraphicsImage);

    function ColorPalette() {
        this.addInput("f", "number");
        this.addOutput("Color", "color");
        this.properties = {
            colorA: "#444444",
            colorB: "#44AAFF",
            colorC: "#44FFAA",
            colorD: "#FFFFFF"
        };
    }

    ColorPalette.title = "Palette";
    ColorPalette.desc = "Generates a color";

    ColorPalette.prototype.onExecute = function() {
        var c = [];

        if (this.properties.colorA != null) {
            c.push(hex2num(this.properties.colorA));
        }
        if (this.properties.colorB != null) {
            c.push(hex2num(this.properties.colorB));
        }
        if (this.properties.colorC != null) {
            c.push(hex2num(this.properties.colorC));
        }
        if (this.properties.colorD != null) {
            c.push(hex2num(this.properties.colorD));
        }

        var f = this.getInputData(0);
        if (f == null) {
            f = 0.5;
        }
        if (f > 1.0) {
            f = 1.0;
        } else if (f < 0.0) {
            f = 0.0;
        }

        if (c.length == 0) {
            return;
        }

        var result = [0, 0, 0];
        if (f == 0) {
            result = c[0];
        } else if (f == 1) {
            result = c[c.length - 1];
        } else {
            var pos = (c.length - 1) * f;
            var c1 = c[Math.floor(pos)];
            var c2 = c[Math.floor(pos) + 1];
            var t = pos - Math.floor(pos);
            result[0] = c1[0] * (1 - t) + c2[0] * t;
            result[1] = c1[1] * (1 - t) + c2[1] * t;
            result[2] = c1[2] * (1 - t) + c2[2] * t;
        }

        /*
	c[0] = 1.0 - Math.abs( Math.sin( 0.1 * reModular.getTime() * Math.PI) );
	c[1] = Math.abs( Math.sin( 0.07 * reModular.getTime() * Math.PI) );
	c[2] = Math.abs( Math.sin( 0.01 * reModular.getTime() * Math.PI) );
	*/

        for (var i=0; i < result.length; i++) {
            result[i] /= 255;
        }

        this.boxcolor = colorToString(result);
        this.setOutputData(0, result);
    };

    LiteGraph.registerNodeType("color/palette", ColorPalette);

    function ImageFrame() {
        this.addInput("", "image,canvas");
        this.size = [200, 200];
    }

    ImageFrame.title = "Frame";
    ImageFrame.desc = "Frame viewerew";
    ImageFrame.widgets = [
        { name: "resize", text: "Resize box", type: "button" },
        { name: "view", text: "View Image", type: "button" }
    ];

    ImageFrame.prototype.onDrawBackground = function(ctx) {
        if (this.frame && !this.flags.collapsed) {
            ctx.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
        }
    };

    ImageFrame.prototype.onExecute = function() {
        this.frame = this.getInputData(0);
        this.setDirtyCanvas(true);
    };

    ImageFrame.prototype.onWidget = function(e, widget) {
        if (widget.name == "resize" && this.frame) {
            var width = this.frame.width;
            var height = this.frame.height;

            if (!width && this.frame.videoWidth != null) {
                width = this.frame.videoWidth;
                height = this.frame.videoHeight;
            }

            if (width && height) {
                this.size = [width, height];
            }
            this.setDirtyCanvas(true, true);
        } else if (widget.name == "view") {
            this.show();
        }
    };

    ImageFrame.prototype.show = function() {
        //var str = this.canvas.toDataURL("image/png");
        if (showElement && this.frame) {
            showElement(this.frame);
        }
    };

    LiteGraph.registerNodeType("graphics/frame", ImageFrame);

    function ImageFade() {
        this.addInputs([
            ["img1", "image"],
            ["img2", "image"],
            ["fade", "number"]
        ]);
        this.addOutput("", "image");
        this.properties = { fade: 0.5, width: 512, height: 512 };
    }

    ImageFade.title = "Image fade";
    ImageFade.desc = "Fades between images";
    ImageFade.widgets = [
        { name: "resizeA", text: "Resize to A", type: "button" },
        { name: "resizeB", text: "Resize to B", type: "button" }
    ];

    ImageFade.prototype.onAdded = function() {
        this.createCanvas();
        var ctx = this.canvas.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, this.properties["width"], this.properties["height"]);
    };

    ImageFade.prototype.createCanvas = function() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.properties["width"];
        this.canvas.height = this.properties["height"];
    };

    ImageFade.prototype.onExecute = function() {
        var ctx = this.canvas.getContext("2d");
        this.canvas.width = this.canvas.width;

        var A = this.getInputData(0);
        if (A != null) {
            ctx.drawImage(A, 0, 0, this.canvas.width, this.canvas.height);
        }

        var fade = this.getInputData(2);
        if (fade == null) {
            fade = this.properties["fade"];
        } else {
            this.properties["fade"] = fade;
        }

        ctx.globalAlpha = fade;
        var B = this.getInputData(1);
        if (B != null) {
            ctx.drawImage(B, 0, 0, this.canvas.width, this.canvas.height);
        }
        ctx.globalAlpha = 1.0;

        this.setOutputData(0, this.canvas);
        this.setDirtyCanvas(true);
    };

    LiteGraph.registerNodeType("graphics/imagefade", ImageFade);

    function ImageCrop() {
        this.addInput("", "image");
        this.addOutput("", "image");
        this.properties = { width: 256, height: 256, x: 0, y: 0, scale: 1.0 };
        this.size = [50, 20];
    }

    ImageCrop.title = "Crop";
    ImageCrop.desc = "Crop Image";

    ImageCrop.prototype.onAdded = function() {
        this.createCanvas();
    };

    ImageCrop.prototype.createCanvas = function() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.properties["width"];
        this.canvas.height = this.properties["height"];
    };

    ImageCrop.prototype.onExecute = function() {
        var input = this.getInputData(0);
        if (!input) {
            return;
        }

        if (input.width) {
            var ctx = this.canvas.getContext("2d");

            ctx.drawImage(
                input,
                -this.properties["x"],
                -this.properties["y"],
                input.width * this.properties["scale"],
                input.height * this.properties["scale"]
            );
            this.setOutputData(0, this.canvas);
        } else {
            this.setOutputData(0, null);
        }
    };

    ImageCrop.prototype.onDrawBackground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }
        if (this.canvas) {
            ctx.drawImage(
                this.canvas,
                0,
                0,
                this.canvas.width,
                this.canvas.height,
                0,
                0,
                this.size[0],
                this.size[1]
            );
        }
    };

    ImageCrop.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;

        if (name == "scale") {
            this.properties[name] = parseFloat(value);
            if (this.properties[name] == 0) {
                console.error("Error in scale");
                this.properties[name] = 1.0;
            }
        } else {
            this.properties[name] = parseInt(value);
        }

        this.createCanvas();

        return true;
    };

    LiteGraph.registerNodeType("graphics/cropImage", ImageCrop);

    //CANVAS stuff

    function CanvasNode() {
        this.addInput("clear", LiteGraph.ACTION);
        this.addOutput("", "canvas");
        this.properties = { width: 512, height: 512, autoclear: true };

        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
    }

    CanvasNode.title = "Canvas";
    CanvasNode.desc = "Canvas to render stuff";

    CanvasNode.prototype.onExecute = function() {
        var canvas = this.canvas;
        var w = this.properties.width | 0;
        var h = this.properties.height | 0;
        if (canvas.width != w) {
            canvas.width = w;
        }
        if (canvas.height != h) {
            canvas.height = h;
        }

        if (this.properties.autoclear) {
            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        this.setOutputData(0, canvas);
    };

    CanvasNode.prototype.onAction = function(action, param) {
        if (action == "clear") {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
    };

    LiteGraph.registerNodeType("graphics/canvas", CanvasNode);

    function DrawImageNode() {
        this.addInput("canvas", "canvas");
        this.addInput("img", "image,canvas");
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.properties = { x: 0, y: 0, opacity: 1 };
    }

    DrawImageNode.title = "DrawImage";
    DrawImageNode.desc = "Draws image into a canvas";

    DrawImageNode.prototype.onExecute = function() {
        var canvas = this.getInputData(0);
        if (!canvas) {
            return;
        }

        var img = this.getInputOrProperty("img");
        if (!img) {
            return;
        }

        var x = this.getInputOrProperty("x");
        var y = this.getInputOrProperty("y");
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, x, y);
    };

    LiteGraph.registerNodeType("graphics/drawImage", DrawImageNode);

    function DrawRectangleNode() {
        this.addInput("canvas", "canvas");
        this.addInput("x", "number");
        this.addInput("y", "number");
        this.addInput("w", "number");
        this.addInput("h", "number");
        this.properties = {
            x: 0,
            y: 0,
            w: 10,
            h: 10,
            color: "white",
            opacity: 1
        };
    }

    DrawRectangleNode.title = "DrawRectangle";
    DrawRectangleNode.desc = "Draws rectangle in canvas";

    DrawRectangleNode.prototype.onExecute = function() {
        var canvas = this.getInputData(0);
        if (!canvas) {
            return;
        }

        var x = this.getInputOrProperty("x");
        var y = this.getInputOrProperty("y");
        var w = this.getInputOrProperty("w");
        var h = this.getInputOrProperty("h");
        var ctx = canvas.getContext("2d");
        ctx.fillRect(x, y, w, h);
    };

    LiteGraph.registerNodeType("graphics/drawRectangle", DrawRectangleNode);

    function ImageVideo() {
        this.addInput("t", "number");
        this.addOutputs([["frame", "image"], ["t", "number"], ["d", "number"]]);
        this.properties = { url: "", use_proxy: true };
    }

    ImageVideo.title = "Video";
    ImageVideo.desc = "Video playback";
    ImageVideo.widgets = [
        { name: "play", text: "PLAY", type: "minibutton" },
        { name: "stop", text: "STOP", type: "minibutton" },
        { name: "demo", text: "Demo video", type: "button" },
        { name: "mute", text: "Mute video", type: "button" }
    ];

    ImageVideo.prototype.onExecute = function() {
        if (!this.properties.url) {
            return;
        }

        if (this.properties.url != this._video_url) {
            this.loadVideo(this.properties.url);
        }

        if (!this._video || this._video.width == 0) {
            return;
        }

        var t = this.getInputData(0);
        if (t && t >= 0 && t <= 1.0) {
            this._video.currentTime = t * this._video.duration;
            this._video.pause();
        }

        this._video.dirty = true;
        this.setOutputData(0, this._video);
        this.setOutputData(1, this._video.currentTime);
        this.setOutputData(2, this._video.duration);
        this.setDirtyCanvas(true);
    };

    ImageVideo.prototype.onStart = function() {
        this.play();
    };

    ImageVideo.prototype.onStop = function() {
        this.stop();
    };

    ImageVideo.prototype.loadVideo = function(url) {
        this._video_url = url;

		var pos = url.substr(0,10).indexOf(":");
		var protocol = "";
		if(pos != -1)
			protocol = url.substr(0,pos);

		var host = "";
		if(protocol)
		{
			host = url.substr(0,url.indexOf("/",protocol.length + 3));
			host = host.substr(protocol.length+3);
		}

        if (
            this.properties.use_proxy &&
            protocol &&
            LiteGraph.proxy &&
			host != location.host
        ) {
            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }

        this._video = document.createElement("video");
        this._video.src = url;
        this._video.type = "type=video/mp4";

        this._video.muted = true;
        this._video.autoplay = true;

        var that = this;
        this._video.addEventListener("loadedmetadata", function(e) {
            //onload
            console.log("Duration: " + this.duration + " seconds");
            console.log("Size: " + this.videoWidth + "," + this.videoHeight);
            that.setDirtyCanvas(true);
            this.width = this.videoWidth;
            this.height = this.videoHeight;
        });
        this._video.addEventListener("progress", function(e) {
            //onload
            console.log("video loading...");
        });
        this._video.addEventListener("error", function(e) {
            console.error("Error loading video: " + this.src);
            if (this.error) {
                switch (this.error.code) {
                    case this.error.MEDIA_ERR_ABORTED:
                        console.error("You stopped the video.");
                        break;
                    case this.error.MEDIA_ERR_NETWORK:
                        console.error("Network error - please try again later.");
                        break;
                    case this.error.MEDIA_ERR_DECODE:
                        console.error("Video is broken..");
                        break;
                    case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        console.error("Sorry, your browser can't play this video.");
                        break;
                }
            }
        });

        this._video.addEventListener("ended", function(e) {
            console.log("Video Ended.");
            this.play(); //loop
        });

        //document.body.appendChild(this.video);
    };

    ImageVideo.prototype.onPropertyChanged = function(name, value) {
        this.properties[name] = value;
        if (name == "url" && value != "") {
            this.loadVideo(value);
        }

        return true;
    };

    ImageVideo.prototype.play = function() {
        if (this._video && this._video.videoWidth ) { //is loaded
            this._video.play();
        }
    };

    ImageVideo.prototype.playPause = function() {
        if (!this._video) {
            return;
        }
        if (this._video.paused) {
            this.play();
        } else {
            this.pause();
        }
    };

    ImageVideo.prototype.stop = function() {
        if (!this._video) {
            return;
        }
        this._video.pause();
        this._video.currentTime = 0;
    };

    ImageVideo.prototype.pause = function() {
        if (!this._video) {
            return;
        }
        console.log("Video paused");
        this._video.pause();
    };

    ImageVideo.prototype.onWidget = function(e, widget) {
        /*
	if(widget.name == "demo")
	{
		this.loadVideo();
	}
	else if(widget.name == "play")
	{
		if(this._video)
			this.playPause();
	}
	if(widget.name == "stop")
	{
		this.stop();
	}
	else if(widget.name == "mute")
	{
		if(this._video)
			this._video.muted = !this._video.muted;
	}
	*/
    };

    LiteGraph.registerNodeType("graphics/video", ImageVideo);

    // Texture Webcam *****************************************
    function ImageWebcam() {
        this.addOutput("Webcam", "image");
        this.properties = { filterFacingMode: false, facingMode: "user" };
        this.boxcolor = "black";
        this.frame = 0;
    }

    ImageWebcam.title = "Webcam";
    ImageWebcam.desc = "Webcam image";
    ImageWebcam.is_webcam_open = false;

    ImageWebcam.prototype.openStream = function() {
        if (!navigator.mediaDevices.getUserMedia) {
            console.log('getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags');
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        var constraints = {
            audio: false,
            video: !this.properties.filterFacingMode ? true : { facingMode: this.properties.facingMode }
        };
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(e) {
            console.log("Webcam rejected", e);
            that._webcam_stream = false;
            ImageWebcam.is_webcam_open = false;
            that.boxcolor = "red";
            that.trigger("stream_error");
        }
    };

    ImageWebcam.prototype.closeStream = function() {
        if (this._webcam_stream) {
            var tracks = this._webcam_stream.getTracks();
            if (tracks.length) {
                for (var i = 0; i < tracks.length; ++i) {
                    tracks[i].stop();
                }
            }
            ImageWebcam.is_webcam_open = false;
            this._webcam_stream = null;
            this._video = null;
            this.boxcolor = "black";
            this.trigger("stream_closed");
        }
    };

    ImageWebcam.prototype.onPropertyChanged = function(name, value) {
        if (name == "facingMode") {
            this.properties.facingMode = value;
            this.closeStream();
            this.openStream();
        }
    };

    ImageWebcam.prototype.onRemoved = function() {
        this.closeStream();
    };

    ImageWebcam.prototype.streamReady = function(localMediaStream) {
        this._webcam_stream = localMediaStream;
        //this._waiting_confirmation = false;
        this.boxcolor = "green";

        var video = this._video;
        if (!video) {
            video = document.createElement("video");
            video.autoplay = true;
            video.srcObject = localMediaStream;
            this._video = video;
            //document.body.appendChild( video ); //debug
            //when video info is loaded (size and so)
            video.onloadedmetadata = function(e) {
                // Ready to go. Do some stuff.
                console.log(e);
                ImageWebcam.is_webcam_open = true;
            };
        }

        this.trigger("stream_ready", video);
    };

    ImageWebcam.prototype.onExecute = function() {
        if (this._webcam_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (!this._video || !this._video.videoWidth) {
            return;
        }

        this._video.frame = ++this.frame;
        this._video.width = this._video.videoWidth;
        this._video.height = this._video.videoHeight;
        this.setOutputData(0, this._video);
        for (var i = 1; i < this.outputs.length; ++i) {
            if (!this.outputs[i]) {
                continue;
            }
            switch (this.outputs[i].name) {
                case "width":
                    this.setOutputData(i, this._video.videoWidth);
                    break;
                case "height":
                    this.setOutputData(i, this._video.videoHeight);
                    break;
            }
        }
    };

    ImageWebcam.prototype.getExtraMenuOptions = function(graphcanvas) {
        var that = this;
        var txt = !that.properties.show ? "Show Frame" : "Hide Frame";
        return [
            {
                content: txt,
                callback: function() {
                    that.properties.show = !that.properties.show;
                }
            }
        ];
    };

    ImageWebcam.prototype.onDrawBackground = function(ctx) {
        if (
            this.flags.collapsed ||
            this.size[1] <= 20 ||
            !this.properties.show
        ) {
            return;
        }

        if (!this._video) {
            return;
        }

        //render to graph canvas
        ctx.save();
        ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);
        ctx.restore();
    };

    ImageWebcam.prototype.onGetOutputs = function() {
        return [
            ["width", "number"],
            ["height", "number"],
            ["stream_ready", LiteGraph.EVENT],
            ["stream_closed", LiteGraph.EVENT],
            ["stream_error", LiteGraph.EVENT]
        ];
    };

    LiteGraph.registerNodeType("graphics/webcam", ImageWebcam);
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;
	var LGraphCanvas = global.LGraphCanvas;

    //Works with Litegl.js to create WebGL nodes
    global.LGraphTexture = null;

    if (typeof GL == "undefined")
		return;

	LGraphCanvas.link_type_colors["Texture"] = "#987";

	function LGraphTexture() {
		this.addOutput("tex", "Texture");
		this.addOutput("name", "string");
		this.properties = { name: "", filter: true };
		this.size = [
			LGraphTexture.image_preview_size,
			LGraphTexture.image_preview_size
		];
	}

	global.LGraphTexture = LGraphTexture;

	LGraphTexture.title = "Texture";
	LGraphTexture.desc = "Texture";
	LGraphTexture.widgets_info = {
		name: { widget: "texture" },
		filter: { widget: "checkbox" }
	};

	//REPLACE THIS TO INTEGRATE WITH YOUR FRAMEWORK
	LGraphTexture.loadTextureCallback = null; //function in charge of loading textures when not present in the container
	LGraphTexture.image_preview_size = 256;

	//flags to choose output texture type
	LGraphTexture.UNDEFINED = 0; //not specified
	LGraphTexture.PASS_THROUGH = 1; //do not apply FX (like disable but passing the in to the out)
	LGraphTexture.COPY = 2; //create new texture with the same properties as the origin texture
	LGraphTexture.LOW = 3; //create new texture with low precision (byte)
	LGraphTexture.HIGH = 4; //create new texture with high precision (half-float)
	LGraphTexture.REUSE = 5; //reuse input texture
	LGraphTexture.DEFAULT = 2; //use the default

	LGraphTexture.MODE_VALUES = {
		"undefined": LGraphTexture.UNDEFINED,
		"pass through": LGraphTexture.PASS_THROUGH,
		copy: LGraphTexture.COPY,
		low: LGraphTexture.LOW,
		high: LGraphTexture.HIGH,
		reuse: LGraphTexture.REUSE,
		default: LGraphTexture.DEFAULT
	};

	//returns the container where all the loaded textures are stored (overwrite if you have a Resources Manager)
	LGraphTexture.getTexturesContainer = function() {
		return gl.textures;
	};

	//process the loading of a texture (overwrite it if you have a Resources Manager)
	LGraphTexture.loadTexture = function(name, options) {
		options = options || {};
		var url = name;
		if (url.substr(0, 7) == "http://") {
			if (LiteGraph.proxy) {
				//proxy external files
				url = LiteGraph.proxy + url.substr(7);
			}
		}

		var container = LGraphTexture.getTexturesContainer();
		var tex = (container[name] = GL.Texture.fromURL(url, options));
		return tex;
	};

	LGraphTexture.getTexture = function(name) {
		var container = this.getTexturesContainer();

		if (!container) {
			throw "Cannot load texture, container of textures not found";
		}

		var tex = container[name];
		if (!tex && name && name[0] != ":") {
			return this.loadTexture(name);
		}

		return tex;
	};

	//used to compute the appropiate output texture
	LGraphTexture.getTargetTexture = function(origin, target, mode) {
		if (!origin) {
			throw "LGraphTexture.getTargetTexture expects a reference texture";
		}

		var tex_type = null;

		switch (mode) {
			case LGraphTexture.LOW:
				tex_type = gl.UNSIGNED_BYTE;
				break;
			case LGraphTexture.HIGH:
				tex_type = gl.HIGH_PRECISION_FORMAT;
				break;
			case LGraphTexture.REUSE:
				return origin;
				break;
			case LGraphTexture.COPY:
			default:
				tex_type = origin ? origin.type : gl.UNSIGNED_BYTE;
				break;
		}

		if (
			!target ||
			target.width != origin.width ||
			target.height != origin.height ||
			target.type != tex_type ||
			target.format != origin.format 
		) {
			target = new GL.Texture(origin.width, origin.height, {
				type: tex_type,
				format: origin.format,
				filter: gl.LINEAR
			});
		}

		return target;
	};

	LGraphTexture.getTextureType = function(precision, ref_texture) {
		var type = ref_texture ? ref_texture.type : gl.UNSIGNED_BYTE;
		switch (precision) {
			case LGraphTexture.HIGH:
				type = gl.HIGH_PRECISION_FORMAT;
				break;
			case LGraphTexture.LOW:
				type = gl.UNSIGNED_BYTE;
				break;
			//no default
		}
		return type;
	};

	LGraphTexture.getWhiteTexture = function() {
		if (this._white_texture) {
			return this._white_texture;
		}
		var texture = (this._white_texture = GL.Texture.fromMemory(
			1,
			1,
			[255, 255, 255, 255],
			{ format: gl.RGBA, wrap: gl.REPEAT, filter: gl.NEAREST }
		));
		return texture;
	};

	LGraphTexture.getNoiseTexture = function() {
		if (this._noise_texture) {
			return this._noise_texture;
		}

		var noise = new Uint8Array(512 * 512 * 4);
		for (var i = 0; i < 512 * 512 * 4; ++i) {
			noise[i] = Math.random() * 255;
		}

		var texture = GL.Texture.fromMemory(512, 512, noise, {
			format: gl.RGBA,
			wrap: gl.REPEAT,
			filter: gl.NEAREST
		});
		this._noise_texture = texture;
		return texture;
	};

	LGraphTexture.prototype.onDropFile = function(data, filename, file) {
		if (!data) {
			this._drop_texture = null;
			this.properties.name = "";
		} else {
			var texture = null;
			if (typeof data == "string") {
				texture = GL.Texture.fromURL(data);
			} else if (filename.toLowerCase().indexOf(".dds") != -1) {
				texture = GL.Texture.fromDDSInMemory(data);
			} else {
				var blob = new Blob([file]);
				var url = URL.createObjectURL(blob);
				texture = GL.Texture.fromURL(url);
			}

			this._drop_texture = texture;
			this.properties.name = filename;
		}
	};

	LGraphTexture.prototype.getExtraMenuOptions = function(graphcanvas) {
		var that = this;
		if (!this._drop_texture) {
			return;
		}
		return [
			{
				content: "Clear",
				callback: function() {
					that._drop_texture = null;
					that.properties.name = "";
				}
			}
		];
	};

	LGraphTexture.prototype.onExecute = function() {
		var tex = null;
		if (this.isOutputConnected(1)) {
			tex = this.getInputData(0);
		}

		if (!tex && this._drop_texture) {
			tex = this._drop_texture;
		}

		if (!tex && this.properties.name) {
			tex = LGraphTexture.getTexture(this.properties.name);
		}

		if (!tex) {
			this.setOutputData( 0, null );
			this.setOutputData( 1, "" );
			return;
		}

		this._last_tex = tex;

		if (this.properties.filter === false) {
			tex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		} else {
			tex.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		}

		this.setOutputData( 0, tex );
		this.setOutputData( 1, tex.fullpath || tex.filename );

		for (var i = 2; i < this.outputs.length; i++) {
			var output = this.outputs[i];
			if (!output) {
				continue;
			}
			var v = null;
			if (output.name == "width") {
				v = tex.width;
			} else if (output.name == "height") {
				v = tex.height;
			} else if (output.name == "aspect") {
				v = tex.width / tex.height;
			}
			this.setOutputData(i, v);
		}
	};

	LGraphTexture.prototype.onResourceRenamed = function(
		old_name,
		new_name
	) {
		if (this.properties.name == old_name) {
			this.properties.name = new_name;
		}
	};

	LGraphTexture.prototype.onDrawBackground = function(ctx) {
		if (this.flags.collapsed || this.size[1] <= 20) {
			return;
		}

		if (this._drop_texture && ctx.webgl) {
			ctx.drawImage(
				this._drop_texture,
				0,
				0,
				this.size[0],
				this.size[1]
			);
			//this._drop_texture.renderQuad(this.pos[0],this.pos[1],this.size[0],this.size[1]);
			return;
		}

		//Different texture? then get it from the GPU
		if (this._last_preview_tex != this._last_tex) {
			if (ctx.webgl) {
				this._canvas = this._last_tex;
			} else {
				var tex_canvas = LGraphTexture.generateLowResTexturePreview(
					this._last_tex
				);
				if (!tex_canvas) {
					return;
				}

				this._last_preview_tex = this._last_tex;
				this._canvas = cloneCanvas(tex_canvas);
			}
		}

		if (!this._canvas) {
			return;
		}

		//render to graph canvas
		ctx.save();
		if (!ctx.webgl) {
			//reverse image
			ctx.translate(0, this.size[1]);
			ctx.scale(1, -1);
		}
		ctx.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]);
		ctx.restore();
	};

	//very slow, used at your own risk
	LGraphTexture.generateLowResTexturePreview = function(tex) {
		if (!tex) {
			return null;
		}

		var size = LGraphTexture.image_preview_size;
		var temp_tex = tex;

		if (tex.format == gl.DEPTH_COMPONENT) {
			return null;
		} //cannot generate from depth

		//Generate low-level version in the GPU to speed up
		if (tex.width > size || tex.height > size) {
			temp_tex = this._preview_temp_tex;
			if (!this._preview_temp_tex) {
				temp_tex = new GL.Texture(size, size, {
					minFilter: gl.NEAREST
				});
				this._preview_temp_tex = temp_tex;
			}

			//copy
			tex.copyTo(temp_tex);
			tex = temp_tex;
		}

		//create intermediate canvas with lowquality version
		var tex_canvas = this._preview_canvas;
		if (!tex_canvas) {
			tex_canvas = createCanvas(size, size);
			this._preview_canvas = tex_canvas;
		}

		if (temp_tex) {
			temp_tex.toCanvas(tex_canvas);
		}
		return tex_canvas;
	};

	LGraphTexture.prototype.getResources = function(res) {
		if(this.properties.name)
			res[this.properties.name] = GL.Texture;
		return res;
	};

	LGraphTexture.prototype.onGetInputs = function() {
		return [["in", "Texture"]];
	};

	LGraphTexture.prototype.onGetOutputs = function() {
		return [
			["width", "number"],
			["height", "number"],
			["aspect", "number"]
		];
	};

	//used to replace shader code
	LGraphTexture.replaceCode = function( code, context )
	{
		return code.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function(v){
			v = v.replace( /[\{\}]/g, "" );
			return context[v] || "";
		});
	}

	LiteGraph.registerNodeType("texture/texture", LGraphTexture);

	//**************************
	function LGraphTexturePreview() {
		this.addInput("Texture", "Texture");
		this.properties = { flipY: false };
		this.size = [
			LGraphTexture.image_preview_size,
			LGraphTexture.image_preview_size
		];
	}

	LGraphTexturePreview.title = "Preview";
	LGraphTexturePreview.desc = "Show a texture in the graph canvas";
	LGraphTexturePreview.allow_preview = false;

	LGraphTexturePreview.prototype.onDrawBackground = function(ctx) {
		if (this.flags.collapsed) {
			return;
		}

		if (!ctx.webgl && !LGraphTexturePreview.allow_preview) {
			return;
		} //not working well

		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		var tex_canvas = null;

		if (!tex.handle && ctx.webgl) {
			tex_canvas = tex;
		} else {
			tex_canvas = LGraphTexture.generateLowResTexturePreview(tex);
		}

		//render to graph canvas
		ctx.save();
		if (this.properties.flipY) {
			ctx.translate(0, this.size[1]);
			ctx.scale(1, -1);
		}
		ctx.drawImage(tex_canvas, 0, 0, this.size[0], this.size[1]);
		ctx.restore();
	};

	LiteGraph.registerNodeType("texture/preview", LGraphTexturePreview);

	//**************************************

	function LGraphTextureSave() {
		this.addInput("Texture", "Texture");
		this.addOutput("tex", "Texture");
		this.addOutput("name", "string");
		this.properties = { name: "", generate_mipmaps: false };
	}

	LGraphTextureSave.title = "Save";
	LGraphTextureSave.desc = "Save a texture in the repository";

	LGraphTextureSave.prototype.getPreviewTexture = function()
	{
		return this._texture;
	}

	LGraphTextureSave.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (this.properties.generate_mipmaps) {
			tex.bind(0);
			tex.setParameter( gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );
			gl.generateMipmap(tex.texture_type);
			tex.unbind(0);
		}

		if (this.properties.name) {
			//for cases where we want to perform something when storing it
			if (LGraphTexture.storeTexture) {
				LGraphTexture.storeTexture(this.properties.name, tex);
			} else {
				var container = LGraphTexture.getTexturesContainer();
				container[this.properties.name] = tex;
			}
		}

		this._texture = tex;
		this.setOutputData(0, tex);
		this.setOutputData(1, this.properties.name);
	};

	LiteGraph.registerNodeType("texture/save", LGraphTextureSave);

	//****************************************************

	function LGraphTextureOperation() {
		this.addInput("Texture", "Texture");
		this.addInput("TextureB", "Texture");
		this.addInput("value", "number");
		this.addOutput("Texture", "Texture");
		this.help = "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>\
		<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>";

		this.properties = {
			value: 1,
			pixelcode: "color + colorB * value",
			uvcode: "",
			precision: LGraphTexture.DEFAULT
		};

		this.has_error = false;
	}

	LGraphTextureOperation.widgets_info = {
		uvcode: { widget: "code" },
		pixelcode: { widget: "code" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureOperation.title = "Operation";
	LGraphTextureOperation.desc = "Texture shader operation";

	LGraphTextureOperation.presets = {};

	LGraphTextureOperation.prototype.getExtraMenuOptions = function(
		graphcanvas
	) {
		var that = this;
		var txt = !that.properties.show ? "Show Texture" : "Hide Texture";
		return [
			{
				content: txt,
				callback: function() {
					that.properties.show = !that.properties.show;
				}
			}
		];
	};

	LGraphTextureOperation.prototype.onPropertyChanged = function()
	{
		this.has_error = false;
	}

	LGraphTextureOperation.prototype.onDrawBackground = function(ctx) {
		if (
			this.flags.collapsed ||
			this.size[1] <= 20 ||
			!this.properties.show
		) {
			return;
		}

		if (!this._tex) {
			return;
		}

		//only works if using a webgl renderer
		if (this._tex.gl != ctx) {
			return;
		}

		//render to graph canvas
		ctx.save();
		ctx.drawImage(this._tex, 0, 0, this.size[0], this.size[1]);
		ctx.restore();
	};

	LGraphTextureOperation.prototype.onExecute = function() {
		var tex = this.getInputData(0);

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		var texB = this.getInputData(1);

		if (!this.properties.uvcode && !this.properties.pixelcode) {
			return;
		}

		var width = 512;
		var height = 512;
		if (tex) {
			width = tex.width;
			height = tex.height;
		} else if (texB) {
			width = texB.width;
			height = texB.height;
		}

		if(!texB)
			texB = GL.Texture.getWhiteTexture();

		var type = LGraphTexture.getTextureType( this.properties.precision, tex );

		if (!tex && !this._tex) {
			this._tex = new GL.Texture(width, height, { type: type, format: gl.RGBA, filter: gl.LINEAR });
		} else {
			this._tex = LGraphTexture.getTargetTexture( tex || this._tex, this._tex, this.properties.precision );
		}

		var uvcode = "";
		if (this.properties.uvcode) {
			uvcode = "uv = " + this.properties.uvcode;
			if (this.properties.uvcode.indexOf(";") != -1) {
				//there are line breaks, means multiline code
				uvcode = this.properties.uvcode;
			}
		}

		var pixelcode = "";
		if (this.properties.pixelcode) {
			pixelcode = "result = " + this.properties.pixelcode;
			if (this.properties.pixelcode.indexOf(";") != -1) {
				//there are line breaks, means multiline code
				pixelcode = this.properties.pixelcode;
			}
		}

		var shader = this._shader;

		if ( !this.has_error && (!shader || this._shader_code != uvcode + "|" + pixelcode) ) {

			var final_pixel_code = LGraphTexture.replaceCode( LGraphTextureOperation.pixel_shader, { UV_CODE:uvcode, PIXEL_CODE:pixelcode });

			try {
				shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, final_pixel_code );
				this.boxcolor = "#00FF00";
			} catch (err) {
				//console.log("Error compiling shader: ", err, final_pixel_code );
				GL.Shader.dumpErrorToConsole(err,Shader.SCREEN_VERTEX_SHADER, final_pixel_code);
				this.boxcolor = "#FF0000";
				this.has_error = true;
				return;
			}
			this._shader = shader;
			this._shader_code = uvcode + "|" + pixelcode;
		}

		if(!this._shader)
			return;

		var value = this.getInputData(2);
		if (value != null) {
			this.properties.value = value;
		} else {
			value = parseFloat(this.properties.value);
		}

		var time = this.graph.getTime();

		this._tex.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.BLEND);
			if (tex) {
				tex.bind(0);
			}
			if (texB) {
				texB.bind(1);
			}
			var mesh = Mesh.getScreenQuad();
			shader
				.uniforms({
					u_texture: 0,
					u_textureB: 1,
					value: value,
					texSize: [width, height,1/width,1/height],
					time: time
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureOperation.pixel_shader =
		"precision highp float;\n\
		\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		varying vec2 v_coord;\n\
		uniform vec4 texSize;\n\
		uniform float time;\n\
		uniform float value;\n\
		\n\
		void main() {\n\
			vec2 uv = v_coord;\n\
			{{UV_CODE}};\n\
			vec4 color4 = texture2D(u_texture, uv);\n\
			vec3 color = color4.rgb;\n\
			vec4 color4B = texture2D(u_textureB, uv);\n\
			vec3 colorB = color4B.rgb;\n\
			vec3 result = color;\n\
			float alpha = 1.0;\n\
			{{PIXEL_CODE}};\n\
			gl_FragColor = vec4(result, alpha);\n\
		}\n\
		";

	LGraphTextureOperation.registerPreset = function ( name, code )
	{
		LGraphTextureOperation.presets[name] = code;
	}

	LGraphTextureOperation.registerPreset("","");
	LGraphTextureOperation.registerPreset("bypass","color");
	LGraphTextureOperation.registerPreset("add","color + colorB * value");
	LGraphTextureOperation.registerPreset("substract","(color - colorB) * value");
	LGraphTextureOperation.registerPreset("mate","mix( color, colorB, color4B.a * value)");
	LGraphTextureOperation.registerPreset("invert","vec3(1.0) - color");
	LGraphTextureOperation.registerPreset("multiply","color * colorB * value");
	LGraphTextureOperation.registerPreset("divide","(color / colorB) / value");
	LGraphTextureOperation.registerPreset("difference","abs(color - colorB) * value");
	LGraphTextureOperation.registerPreset("max","max(color, colorB) * value");
	LGraphTextureOperation.registerPreset("min","min(color, colorB) * value");
	LGraphTextureOperation.registerPreset("displace","texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz");
	LGraphTextureOperation.registerPreset("grayscale","vec3(color.x + color.y + color.z) * value / 3.0");
	LGraphTextureOperation.registerPreset("saturation","mix( vec3(color.x + color.y + color.z) / 3.0, color, value )");
	LGraphTextureOperation.registerPreset("normalmap","\n\
		float z0 = texture2D(u_texture, uv + vec2(-texSize.z, -texSize.w) ).x;\n\
		float z1 = texture2D(u_texture, uv + vec2(0.0, -texSize.w) ).x;\n\
		float z2 = texture2D(u_texture, uv + vec2(texSize.z, -texSize.w) ).x;\n\
		float z3 = texture2D(u_texture, uv + vec2(-texSize.z, 0.0) ).x;\n\
		float z4 = color.x;\n\
		float z5 = texture2D(u_texture, uv + vec2(texSize.z, 0.0) ).x;\n\
		float z6 = texture2D(u_texture, uv + vec2(-texSize.z, texSize.w) ).x;\n\
		float z7 = texture2D(u_texture, uv + vec2(0.0, texSize.w) ).x;\n\
		float z8 = texture2D(u_texture, uv + vec2(texSize.z, texSize.w) ).x;\n\
		vec3 normal = vec3( z2 + 2.0*z4 + z7 - z0 - 2.0*z3 - z5, z5 + 2.0*z6 + z7 -z0 - 2.0*z1 - z2, 1.0 );\n\
		normal.xy *= value;\n\
		result.xyz = normalize(normal) * 0.5 + vec3(0.5);\n\
	");
	LGraphTextureOperation.registerPreset("threshold","vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)");

	//webglstudio stuff...
	LGraphTextureOperation.prototype.onInspect = function(widgets)
	{
		var that = this;
		widgets.addCombo("Presets","",{ values: Object.keys(LGraphTextureOperation.presets), callback: function(v){
			var code = LGraphTextureOperation.presets[v];
			if(!code)
				return;
			that.setProperty("pixelcode",code);
			that.title = v;
			widgets.refresh();
		}});
	}

	LiteGraph.registerNodeType("texture/operation", LGraphTextureOperation);

	//****************************************************

	function LGraphTextureShader() {
		this.addOutput("out", "Texture");
		this.properties = {
			code: "",
			u_value: 1,
			u_color: [1,1,1,1],
			width: 512,
			height: 512,
			precision: LGraphTexture.DEFAULT
		};

		this.properties.code = LGraphTextureShader.pixel_shader;
		this._uniforms = { u_value: 1, u_color: vec4.create(), in_texture: 0, texSize: vec4.create(), time: 0 };
	}

	LGraphTextureShader.title = "Shader";
	LGraphTextureShader.desc = "Texture shader";
	LGraphTextureShader.widgets_info = {
		code: { type: "code", lang: "glsl" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureShader.prototype.onPropertyChanged = function(
		name,
		value
	) {
		if (name != "code") {
			return;
		}

		var shader = this.getShader();
		if (!shader) {
			return;
		}

		//update connections
		var uniforms = shader.uniformInfo;

		//remove deprecated slots
		if (this.inputs) {
			var already = {};
			for (var i = 0; i < this.inputs.length; ++i) {
				var info = this.getInputInfo(i);
				if (!info) {
					continue;
				}

				if (uniforms[info.name] && !already[info.name]) {
					already[info.name] = true;
					continue;
				}
				this.removeInput(i);
				i--;
			}
		}

		//update existing ones
		for (var i in uniforms) {
			var info = shader.uniformInfo[i];
			if (info.loc === null) {
				continue;
			} //is an attribute, not a uniform
			if (i == "time") {
				//default one
				continue;
			}

			var type = "number";
			if (this._shader.samplers[i]) {
				type = "texture";
			} else {
				switch (info.size) {
					case 1:
						type = "number";
						break;
					case 2:
						type = "vec2";
						break;
					case 3:
						type = "vec3";
						break;
					case 4:
						type = "vec4";
						break;
					case 9:
						type = "mat3";
						break;
					case 16:
						type = "mat4";
						break;
					default:
						continue;
				}
			}

			var slot = this.findInputSlot(i);
			if (slot == -1) {
				this.addInput(i, type);
				continue;
			}

			var input_info = this.getInputInfo(slot);
			if (!input_info) {
				this.addInput(i, type);
			} else {
				if (input_info.type == type) {
					continue;
				}
				this.removeInput(slot, type);
				this.addInput(i, type);
			}
		}
	};

	LGraphTextureShader.prototype.getShader = function() {
		//replug
		if (this._shader && this._shader_code == this.properties.code) {
			return this._shader;
		}

		this._shader_code = this.properties.code;
		this._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, this.properties.code );
		if (!this._shader) {
			this.boxcolor = "red";
			return null;
		} else {
			this.boxcolor = "green";
		}
		return this._shader;
	};

	LGraphTextureShader.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var shader = this.getShader();
		if (!shader) {
			return;
		}

		var tex_slot = 0;
		var in_tex = null;

		//set uniforms
		if(this.inputs)
		for (var i = 0; i < this.inputs.length; ++i) {
			var info = this.getInputInfo(i);
			var data = this.getInputData(i);
			if (data == null) {
				continue;
			}

			if (data.constructor === GL.Texture) {
				data.bind(tex_slot);
				if (!in_tex) {
					in_tex = data;
				}
				data = tex_slot;
				tex_slot++;
			}
			shader.setUniform(info.name, data); //data is tex_slot
		}

		var uniforms = this._uniforms;
		var type = LGraphTexture.getTextureType( this.properties.precision, in_tex );

		//render to texture
		var w = this.properties.width | 0;
		var h = this.properties.height | 0;
		if (w == 0) {
			w = in_tex ? in_tex.width : gl.canvas.width;
		}
		if (h == 0) {
			h = in_tex ? in_tex.height : gl.canvas.height;
		}
		uniforms.texSize[0] = w;
		uniforms.texSize[1] = h;
		uniforms.texSize[2] = 1/w;
		uniforms.texSize[3] = 1/h;
		uniforms.time = this.graph.getTime();
		uniforms.u_value = this.properties.u_value;
		uniforms.u_color.set( this.properties.u_color );

		if ( !this._tex || this._tex.type != type ||  this._tex.width != w || this._tex.height != h ) {
			this._tex = new GL.Texture(w, h, {  type: type, format: gl.RGBA, filter: gl.LINEAR });
		}
		var tex = this._tex;
		tex.drawTo(function() {
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureShader.pixel_shader =
"precision highp float;\n\
\n\
varying vec2 v_coord;\n\
uniform float time; //time in seconds\n\
uniform vec4 texSize; //tex resolution\n\
uniform float u_value;\n\
uniform vec4 u_color;\n\n\
void main() {\n\
	vec2 uv = v_coord;\n\
	vec3 color = vec3(0.0);\n\
	//your code here\n\
	color.xy=uv;\n\n\
	gl_FragColor = vec4(color, 1.0);\n\
}\n\
";

	LiteGraph.registerNodeType("texture/shader", LGraphTextureShader);

	// Texture Scale Offset

	function LGraphTextureScaleOffset() {
		this.addInput("in", "Texture");
		this.addInput("scale", "vec2");
		this.addInput("offset", "vec2");
		this.addOutput("out", "Texture");
		this.properties = {
			offset: vec2.fromValues(0, 0),
			scale: vec2.fromValues(1, 1),
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureScaleOffset.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureScaleOffset.title = "Scale/Offset";
	LGraphTextureScaleOffset.desc = "Applies an scaling and offseting";

	LGraphTextureScaleOffset.prototype.onExecute = function() {
		var tex = this.getInputData(0);

		if (!this.isOutputConnected(0) || !tex) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		var width = tex.width;
		var height = tex.height;
		var type =  this.precision === LGraphTexture.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;
		if (this.precision === LGraphTexture.DEFAULT) {
			type = tex.type;
		}

		if (
			!this._tex ||
			this._tex.width != width ||
			this._tex.height != height ||
			this._tex.type != type
		) {
			this._tex = new GL.Texture(width, height, {
				type: type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		var shader = this._shader;

		if (!shader) {
			shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureScaleOffset.pixel_shader
			);
		}

		var scale = this.getInputData(1);
		if (scale) {
			this.properties.scale[0] = scale[0];
			this.properties.scale[1] = scale[1];
		} else {
			scale = this.properties.scale;
		}

		var offset = this.getInputData(2);
		if (offset) {
			this.properties.offset[0] = offset[0];
			this.properties.offset[1] = offset[1];
		} else {
			offset = this.properties.offset;
		}

		this._tex.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.BLEND);
			tex.bind(0);
			var mesh = Mesh.getScreenQuad();
			shader
				.uniforms({
					u_texture: 0,
					u_scale: scale,
					u_offset: offset
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureScaleOffset.pixel_shader =
		"precision highp float;\n\
		\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		varying vec2 v_coord;\n\
		uniform vec2 u_scale;\n\
		uniform vec2 u_offset;\n\
		\n\
		void main() {\n\
			vec2 uv = v_coord;\n\
			uv = uv / u_scale - u_offset;\n\
			gl_FragColor = texture2D(u_texture, uv);\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/scaleOffset",
		LGraphTextureScaleOffset
	);

	// Warp (distort a texture) *************************

	function LGraphTextureWarp() {
		this.addInput("in", "Texture");
		this.addInput("warp", "Texture");
		this.addInput("factor", "number");
		this.addOutput("out", "Texture");
		this.properties = {
			factor: 0.01,
			scale: [1,1],
			offset: [0,0],
			precision: LGraphTexture.DEFAULT
		};

		this._uniforms = { 
			u_texture: 0, 
			u_textureB: 1, 
			u_factor: 1, 
			u_scale: vec2.create(),
			u_offset: vec2.create()
		};
	}

	LGraphTextureWarp.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureWarp.title = "Warp";
	LGraphTextureWarp.desc = "Texture warp operation";

	LGraphTextureWarp.prototype.onExecute = function() {
		var tex = this.getInputData(0);

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		var texB = this.getInputData(1);

		var width = 512;
		var height = 512;
		var type = gl.UNSIGNED_BYTE;
		if (tex) {
			width = tex.width;
			height = tex.height;
			type = tex.type;
		} else if (texB) {
			width = texB.width;
			height = texB.height;
			type = texB.type;
		}

		if (!tex && !this._tex) {
			this._tex = new GL.Texture(width, height, {
				type:
					this.precision === LGraphTexture.LOW
						? gl.UNSIGNED_BYTE
						: gl.HIGH_PRECISION_FORMAT,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		} else {
			this._tex = LGraphTexture.getTargetTexture(
				tex || this._tex,
				this._tex,
				this.properties.precision
			);
		}

		var shader = this._shader;

		if (!shader) {
			shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureWarp.pixel_shader
			);
		}

		var factor = this.getInputData(2);
		if (factor != null) {
			this.properties.factor = factor;
		} else {
			factor = parseFloat(this.properties.factor);
		}
		var uniforms = this._uniforms;
		uniforms.u_factor = factor;
		uniforms.u_scale.set( this.properties.scale );
		uniforms.u_offset.set( this.properties.offset );

		this._tex.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.BLEND);
			if (tex) {
				tex.bind(0);
			}
			if (texB) {
				texB.bind(1);
			}
			var mesh = Mesh.getScreenQuad();
			shader
				.uniforms( uniforms )
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureWarp.pixel_shader =
		"precision highp float;\n\
		\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		varying vec2 v_coord;\n\
		uniform float u_factor;\n\
		uniform vec2 u_scale;\n\
		uniform vec2 u_offset;\n\
		\n\
		void main() {\n\
			vec2 uv = v_coord;\n\
			uv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;\n\
			gl_FragColor = texture2D(u_texture, uv);\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/warp", LGraphTextureWarp);

	//****************************************************

	// Texture to Viewport *****************************************
	function LGraphTextureToViewport() {
		this.addInput("Texture", "Texture");
		this.properties = {
			additive: false,
			antialiasing: false,
			filter: true,
			disable_alpha: false,
			gamma: 1.0,
			viewport: [0,0,1,1]
		};
		this.size[0] = 130;
	}

	LGraphTextureToViewport.title = "to Viewport";
	LGraphTextureToViewport.desc = "Texture to viewport";

	LGraphTextureToViewport._prev_viewport = new Float32Array(4);

	LGraphTextureToViewport.prototype.onDrawBackground = function( ctx )
	{
		if ( this.flags.collapsed || this.size[1] <= 40 )
			return;

		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		ctx.drawImage( ctx == gl ? tex : gl.canvas, 10,30, this.size[0] -20, this.size[1] -40);
	}

	LGraphTextureToViewport.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (this.properties.disable_alpha) {
			gl.disable(gl.BLEND);
		} else {
			gl.enable(gl.BLEND);
			if (this.properties.additive) {
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			} else {
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			}
		}

		gl.disable(gl.DEPTH_TEST);
		var gamma = this.properties.gamma || 1.0;
		if (this.isInputConnected(1)) {
			gamma = this.getInputData(1);
		}

		tex.setParameter(
			gl.TEXTURE_MAG_FILTER,
			this.properties.filter ? gl.LINEAR : gl.NEAREST
		);

		var old_viewport = LGraphTextureToViewport._prev_viewport;
		old_viewport.set( gl.viewport_data );
		var new_view = this.properties.viewport;
		gl.viewport( old_viewport[0] + old_viewport[2] * new_view[0], old_viewport[1] + old_viewport[3] * new_view[1], old_viewport[2] * new_view[2], old_viewport[3] * new_view[3] );
		var viewport = gl.getViewport(); //gl.getParameter(gl.VIEWPORT);

		if (this.properties.antialiasing) {
			if (!LGraphTextureToViewport._shader) {
				LGraphTextureToViewport._shader = new GL.Shader(
					GL.Shader.SCREEN_VERTEX_SHADER,
					LGraphTextureToViewport.aa_pixel_shader
				);
			}

			var mesh = Mesh.getScreenQuad();
			tex.bind(0);
			LGraphTextureToViewport._shader
				.uniforms({
					u_texture: 0,
					uViewportSize: [tex.width, tex.height],
					u_igamma: 1 / gamma,
					inverseVP: [1 / tex.width, 1 / tex.height]
				})
				.draw(mesh);
		} else {
			if (gamma != 1.0) {
				if (!LGraphTextureToViewport._gamma_shader) {
					LGraphTextureToViewport._gamma_shader = new GL.Shader(
						Shader.SCREEN_VERTEX_SHADER,
						LGraphTextureToViewport.gamma_pixel_shader
					);
				}
				tex.toViewport(LGraphTextureToViewport._gamma_shader, {
					u_texture: 0,
					u_igamma: 1 / gamma
				});
			} else {
				tex.toViewport();
			}
		}

		gl.viewport( old_viewport[0], old_viewport[1], old_viewport[2], old_viewport[3] );
	};

	LGraphTextureToViewport.prototype.onGetInputs = function() {
		return [["gamma", "number"]];
	};

	LGraphTextureToViewport.aa_pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 uViewportSize;\n\
		uniform vec2 inverseVP;\n\
		uniform float u_igamma;\n\
		#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\
		#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\
		#define FXAA_SPAN_MAX     8.0\n\
		\n\
		/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\n\
		vec4 applyFXAA(sampler2D tex, vec2 fragCoord)\n\
		{\n\
			vec4 color = vec4(0.0);\n\
			/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\n\
			vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\n\
			vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\n\
			vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\n\
			vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\n\
			vec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\n\
			vec3 luma = vec3(0.299, 0.587, 0.114);\n\
			float lumaNW = dot(rgbNW, luma);\n\
			float lumaNE = dot(rgbNE, luma);\n\
			float lumaSW = dot(rgbSW, luma);\n\
			float lumaSE = dot(rgbSE, luma);\n\
			float lumaM  = dot(rgbM,  luma);\n\
			float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\
			float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\
			\n\
			vec2 dir;\n\
			dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\
			dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\
			\n\
			float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\
			\n\
			float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\
			dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n\
			\n\
			vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \n\
				texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n\
			vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \n\
				texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\
			\n\
			//return vec4(rgbA,1.0);\n\
			float lumaB = dot(rgbB, luma);\n\
			if ((lumaB < lumaMin) || (lumaB > lumaMax))\n\
				color = vec4(rgbA, 1.0);\n\
			else\n\
				color = vec4(rgbB, 1.0);\n\
			if(u_igamma != 1.0)\n\
				color.xyz = pow( color.xyz, vec3(u_igamma) );\n\
			return color;\n\
		}\n\
		\n\
		void main() {\n\
		   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\n\
		}\n\
		";

	LGraphTextureToViewport.gamma_pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_igamma;\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord);\n\
			color.xyz = pow(color.xyz, vec3(u_igamma) );\n\
		   gl_FragColor = color;\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/toviewport",
		LGraphTextureToViewport
	);

	// Texture Copy *****************************************
	function LGraphTextureCopy() {
		this.addInput("Texture", "Texture");
		this.addOutput("", "Texture");
		this.properties = {
			size: 0,
			generate_mipmaps: false,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureCopy.title = "Copy";
	LGraphTextureCopy.desc = "Copy Texture";
	LGraphTextureCopy.widgets_info = {
		size: {
			widget: "combo",
			values: [0, 32, 64, 128, 256, 512, 1024, 2048]
		},
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureCopy.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex && !this._temp_texture) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		//copy the texture
		if (tex) {
			var width = tex.width;
			var height = tex.height;

			if (this.properties.size != 0) {
				width = this.properties.size;
				height = this.properties.size;
			}

			var temp = this._temp_texture;

			var type = tex.type;
			if (this.properties.precision === LGraphTexture.LOW) {
				type = gl.UNSIGNED_BYTE;
			} else if (this.properties.precision === LGraphTexture.HIGH) {
				type = gl.HIGH_PRECISION_FORMAT;
			}

			if (
				!temp ||
				temp.width != width ||
				temp.height != height ||
				temp.type != type
			) {
				var minFilter = gl.LINEAR;
				if (
					this.properties.generate_mipmaps &&
					isPowerOfTwo(width) &&
					isPowerOfTwo(height)
				) {
					minFilter = gl.LINEAR_MIPMAP_LINEAR;
				}
				this._temp_texture = new GL.Texture(width, height, {
					type: type,
					format: gl.RGBA,
					minFilter: minFilter,
					magFilter: gl.LINEAR
				});
			}
			tex.copyTo(this._temp_texture);

			if (this.properties.generate_mipmaps) {
				this._temp_texture.bind(0);
				gl.generateMipmap(this._temp_texture.texture_type);
				this._temp_texture.unbind(0);
			}
		}

		this.setOutputData(0, this._temp_texture);
	};

	LiteGraph.registerNodeType("texture/copy", LGraphTextureCopy);

	// Texture Downsample *****************************************
	function LGraphTextureDownsample() {
		this.addInput("Texture", "Texture");
		this.addOutput("", "Texture");
		this.properties = {
			iterations: 1,
			generate_mipmaps: false,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureDownsample.title = "Downsample";
	LGraphTextureDownsample.desc = "Downsample Texture";
	LGraphTextureDownsample.widgets_info = {
		iterations: { type: "number", step: 1, precision: 0, min: 0 },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureDownsample.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex && !this._temp_texture) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		//we do not allow any texture different than texture 2D
		if (!tex || tex.texture_type !== GL.TEXTURE_2D) {
			return;
		}

		if (this.properties.iterations < 1) {
			this.setOutputData(0, tex);
			return;
		}

		var shader = LGraphTextureDownsample._shader;
		if (!shader) {
			LGraphTextureDownsample._shader = shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureDownsample.pixel_shader
			);
		}

		var width = tex.width | 0;
		var height = tex.height | 0;
		var type = tex.type;
		if (this.properties.precision === LGraphTexture.LOW) {
			type = gl.UNSIGNED_BYTE;
		} else if (this.properties.precision === LGraphTexture.HIGH) {
			type = gl.HIGH_PRECISION_FORMAT;
		}
		var iterations = this.properties.iterations || 1;

		var origin = tex;
		var target = null;

		var temp = [];
		var options = {
			type: type,
			format: tex.format
		};

		var offset = vec2.create();
		var uniforms = {
			u_offset: offset
		};

		if (this._texture) {
			GL.Texture.releaseTemporary(this._texture);
		}

		for (var i = 0; i < iterations; ++i) {
			offset[0] = 1 / width;
			offset[1] = 1 / height;
			width = width >> 1 || 0;
			height = height >> 1 || 0;
			target = GL.Texture.getTemporary(width, height, options);
			temp.push(target);
			origin.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
			origin.copyTo(target, shader, uniforms);
			if (width == 1 && height == 1) {
				break;
			} //nothing else to do
			origin = target;
		}

		//keep the last texture used
		this._texture = temp.pop();

		//free the rest
		for (var i = 0; i < temp.length; ++i) {
			GL.Texture.releaseTemporary(temp[i]);
		}

		if (this.properties.generate_mipmaps) {
			this._texture.bind(0);
			gl.generateMipmap(this._texture.texture_type);
			this._texture.unbind(0);
		}

		this.setOutputData(0, this._texture);
	};

	LGraphTextureDownsample.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_offset;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = texture2D(u_texture, v_coord );\n\
			color += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\n\
			color += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\n\
			color += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\n\
		   gl_FragColor = color * 0.25;\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/downsample",
		LGraphTextureDownsample
	);



	function LGraphTextureResize() {
		this.addInput("Texture", "Texture");
		this.addOutput("", "Texture");
		this.properties = {
			size: [512,512],
			generate_mipmaps: false,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureResize.title = "Resize";
	LGraphTextureResize.desc = "Resize Texture";
	LGraphTextureResize.widgets_info = {
		iterations: { type: "number", step: 1, precision: 0, min: 0 },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureResize.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex && !this._temp_texture) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		//we do not allow any texture different than texture 2D
		if (!tex || tex.texture_type !== GL.TEXTURE_2D) {
			return;
		}

		var width = this.properties.size[0] | 0;
		var height = this.properties.size[1] | 0;
		if(width == 0)
			width = tex.width;
		if(height == 0)
			height = tex.height;
		var type = tex.type;
		if (this.properties.precision === LGraphTexture.LOW) {
			type = gl.UNSIGNED_BYTE;
		} else if (this.properties.precision === LGraphTexture.HIGH) {
			type = gl.HIGH_PRECISION_FORMAT;
		}

		if( !this._texture || this._texture.width != width || this._texture.height != height || this._texture.type != type )
			this._texture = new GL.Texture( width, height, { type: type } );

		tex.copyTo( this._texture );

		if (this.properties.generate_mipmaps) {
			this._texture.bind(0);
			gl.generateMipmap(this._texture.texture_type);
			this._texture.unbind(0);
		}

		this.setOutputData(0, this._texture);
	};

	LiteGraph.registerNodeType( "texture/resize", LGraphTextureResize );

	// Texture Average  *****************************************
	function LGraphTextureAverage() {
		this.addInput("Texture", "Texture");
		this.addOutput("tex", "Texture");
		this.addOutput("avg", "vec4");
		this.addOutput("lum", "number");
		this.properties = {
			use_previous_frame: true, //to avoid stalls 
			high_quality: false //to use as much pixels as possible
		};

		this._uniforms = {
			u_texture: 0,
			u_mipmap_offset: 0
		};
		this._luminance = new Float32Array(4);
	}

	LGraphTextureAverage.title = "Average";
	LGraphTextureAverage.desc =
		"Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.\n If high_quality is true, then it generates the mipmaps first and reads from the lower one.";

	LGraphTextureAverage.prototype.onExecute = function() {
		if (!this.properties.use_previous_frame) {
			this.updateAverage();
		}

		var v = this._luminance;
		this.setOutputData(0, this._temp_texture);
		this.setOutputData(1, v);
		this.setOutputData(2, (v[0] + v[1] + v[2]) / 3);
	};

	//executed before rendering the frame
	LGraphTextureAverage.prototype.onPreRenderExecute = function() {
		this.updateAverage();
	};

	LGraphTextureAverage.prototype.updateAverage = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (
			!this.isOutputConnected(0) &&
			!this.isOutputConnected(1) &&
			!this.isOutputConnected(2)
		) {
			return;
		} //saves work

		if (!LGraphTextureAverage._shader) {
			LGraphTextureAverage._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureAverage.pixel_shader
			);
			//creates 256 random numbers and stores them in two mat4
			var samples = new Float32Array(16);
			for (var i = 0; i < samples.length; ++i) {
				samples[i] = Math.random(); //poorly distributed samples
			}
			//upload only once
			LGraphTextureAverage._shader.uniforms({
				u_samples_a: samples.subarray(0, 16),
				u_samples_b: samples.subarray(16, 32)
			});
		}

		var temp = this._temp_texture;
		var type = gl.UNSIGNED_BYTE;
		if (tex.type != type) {
			//force floats, half floats cannot be read with gl.readPixels
			type = gl.FLOAT;
		}

		if (!temp || temp.type != type) {
			this._temp_texture = new GL.Texture(1, 1, {
				type: type,
				format: gl.RGBA,
				filter: gl.NEAREST
			});
		}

		this._uniforms.u_mipmap_offset = 0;

		if(this.properties.high_quality)
		{
			if( !this._temp_pot2_texture || this._temp_pot2_texture.type != type )
				this._temp_pot2_texture = new GL.Texture(512, 512, {
					type: type,
					format: gl.RGBA,
					minFilter: gl.LINEAR_MIPMAP_LINEAR,
					magFilter: gl.LINEAR
				});

			tex.copyTo( this._temp_pot2_texture );
			tex = this._temp_pot2_texture;
			tex.bind(0);
			gl.generateMipmap(GL.TEXTURE_2D);
			this._uniforms.u_mipmap_offset = 9;
		}

		var shader = LGraphTextureAverage._shader;
		var uniforms = this._uniforms;
		uniforms.u_mipmap_offset = this.properties.mipmap_offset;
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);
		this._temp_texture.drawTo(function() {
			tex.toViewport(shader, uniforms);
		});

		if (this.isOutputConnected(1) || this.isOutputConnected(2)) {
			var pixel = this._temp_texture.getPixels();
			if (pixel) {
				var v = this._luminance;
				var type = this._temp_texture.type;
				v.set(pixel);
				if (type == gl.UNSIGNED_BYTE) {
					vec4.scale(v, v, 1 / 255);
				} else if (
					type == GL.HALF_FLOAT ||
					type == GL.HALF_FLOAT_OES
				) {
					//no half floats possible, hard to read back unless copyed to a FLOAT texture, so temp_texture is always forced to FLOAT
				}
			}
		}
	};

	LGraphTextureAverage.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform mat4 u_samples_a;\n\
		uniform mat4 u_samples_b;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_mipmap_offset;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = vec4(0.0);\n\
			//random average\n\
			for(int i = 0; i < 4; ++i)\n\
				for(int j = 0; j < 4; ++j)\n\
				{\n\
					color += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\
					color += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\
				}\n\
		   gl_FragColor = color * 0.03125;\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/average", LGraphTextureAverage);



	// Computes operation between pixels (max, min)  *****************************************
	function LGraphTextureMinMax() {
		this.addInput("Texture", "Texture");
		this.addOutput("min_t", "Texture");
		this.addOutput("max_t", "Texture");
		this.addOutput("min", "vec4");
		this.addOutput("max", "vec4");
		this.properties = {
			mode: "max",
			use_previous_frame: true //to avoid stalls 
		};

		this._uniforms = {
			u_texture: 0
		};

		this._max = new Float32Array(4);
		this._min = new Float32Array(4);

		this._textures_chain = [];
	}

	LGraphTextureMinMax.widgets_info = {
		mode: { widget: "combo", values: ["min","max","avg"] }
	};

	LGraphTextureMinMax.title = "MinMax";
	LGraphTextureMinMax.desc = "Compute the scene min max";

	LGraphTextureMinMax.prototype.onExecute = function() {
		if (!this.properties.use_previous_frame) {
			this.update();
		}

		this.setOutputData(0, this._temp_texture);
		this.setOutputData(1, this._luminance);
	};

	//executed before rendering the frame
	LGraphTextureMinMax.prototype.onPreRenderExecute = function() {
		this.update();
	};

	LGraphTextureMinMax.prototype.update = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if ( !this.isOutputConnected(0) && !this.isOutputConnected(1) ) {
			return;
		} //saves work

		if (!LGraphTextureMinMax._shader) {
			LGraphTextureMinMax._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureMinMax.pixel_shader );
		}

		var temp = this._temp_texture;
		var type = gl.UNSIGNED_BYTE;
		if (tex.type != type) {
			//force floats, half floats cannot be read with gl.readPixels
			type = gl.FLOAT;
		}

		var size = 512;

		if( !this._textures_chain.length || this._textures_chain[0].type != type )
		{
			var index = 0;
			while(i)
			{
				this._textures_chain[i] = new GL.Texture( size, size, {
					type: type,
					format: gl.RGBA,
					filter: gl.NEAREST
				});
				size = size >> 2;
				i++;
				if(size == 1)
					break;
			}
		}

		tex.copyTo( this._textures_chain[0] );
		var prev = this._textures_chain[0];
		for(var i = 1; i <= this._textures_chain.length; ++i)
		{
			var tex = this._textures_chain[i];

			prev = tex;				
		}

		var shader = LGraphTextureMinMax._shader;
		var uniforms = this._uniforms;
		uniforms.u_mipmap_offset = this.properties.mipmap_offset;
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);
		this._temp_texture.drawTo(function() {
			tex.toViewport(shader, uniforms);
		});
	};

	LGraphTextureMinMax.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform mat4 u_samples_a;\n\
		uniform mat4 u_samples_b;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_mipmap_offset;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = vec4(0.0);\n\
			//random average\n\
			for(int i = 0; i < 4; ++i)\n\
				for(int j = 0; j < 4; ++j)\n\
				{\n\
					color += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\
					color += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\
				}\n\
		   gl_FragColor = color * 0.03125;\n\
		}\n\
		";

	//LiteGraph.registerNodeType("texture/clustered_operation", LGraphTextureClusteredOperation);


	function LGraphTextureTemporalSmooth() {
		this.addInput("in", "Texture");
		this.addInput("factor", "Number");
		this.addOutput("out", "Texture");
		this.properties = { factor: 0.5 };
		this._uniforms = {
			u_texture: 0,
			u_textureB: 1,
			u_factor: this.properties.factor
		};
	}

	LGraphTextureTemporalSmooth.title = "Smooth";
	LGraphTextureTemporalSmooth.desc = "Smooth texture over time";

	LGraphTextureTemporalSmooth.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex || !this.isOutputConnected(0)) {
			return;
		}

		if (!LGraphTextureTemporalSmooth._shader) {
			LGraphTextureTemporalSmooth._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureTemporalSmooth.pixel_shader
			);
		}

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.type != tex.type ||
			temp.width != tex.width ||
			temp.height != tex.height
		) {
			var options = {
				type: tex.type,
				format: gl.RGBA,
				filter: gl.NEAREST
			};
			this._temp_texture = new GL.Texture(tex.width, tex.height, options );
			this._temp_texture2 = new GL.Texture(tex.width, tex.height, options );
			tex.copyTo(this._temp_texture2);
		}

		var tempA = this._temp_texture;
		var tempB = this._temp_texture2;

		var shader = LGraphTextureTemporalSmooth._shader;
		var uniforms = this._uniforms;
		uniforms.u_factor = 1.0 - this.getInputOrProperty("factor");

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		tempA.drawTo(function() {
			tempB.bind(1);
			tex.toViewport(shader, uniforms);
		});

		this.setOutputData(0, tempA);

		//swap
		this._temp_texture = tempB;
		this._temp_texture2 = tempA;
	};

	LGraphTextureTemporalSmooth.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_factor;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			gl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );\n\
		}\n\
		";

	LiteGraph.registerNodeType( "texture/temporal_smooth", LGraphTextureTemporalSmooth );


	function LGraphTextureLinearAvgSmooth() {
		this.addInput("in", "Texture");
		this.addOutput("avg", "Texture");
		this.addOutput("array", "Texture");
		this.properties = { samples: 64, frames_interval: 1 };
		this._uniforms = {
			u_texture: 0,
			u_textureB: 1,
			u_samples: this.properties.samples,
			u_isamples: 1/this.properties.samples
		};
		this.frame = 0;
	}

	LGraphTextureLinearAvgSmooth.title = "Lineal Avg Smooth";
	LGraphTextureLinearAvgSmooth.desc = "Smooth texture linearly over time";

	LGraphTextureLinearAvgSmooth["@samples"] = { type: "number", min: 1, max: 64, step: 1, precision: 1 };

	LGraphTextureLinearAvgSmooth.prototype.getPreviewTexture = function()
	{
		return this._temp_texture2;
	}

	LGraphTextureLinearAvgSmooth.prototype.onExecute = function() {

		var tex = this.getInputData(0);
		if (!tex || !this.isOutputConnected(0)) {
			return;
		}

		if (!LGraphTextureLinearAvgSmooth._shader) {
			LGraphTextureLinearAvgSmooth._shader_copy = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearAvgSmooth.pixel_shader_copy );
			LGraphTextureLinearAvgSmooth._shader_avg = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearAvgSmooth.pixel_shader_avg );
		}

		var samples = Math.clamp(this.properties.samples,0,64);
		var frame = this.frame;
		var interval = this.properties.frames_interval;

		if( interval == 0 || frame % interval == 0 )
		{
			var temp = this._temp_texture;
			if ( !temp || temp.type != tex.type || temp.width != samples ) {
				var options = {
					type: tex.type,
					format: gl.RGBA,
					filter: gl.NEAREST
				};
				this._temp_texture = new GL.Texture( samples, 1, options );
				this._temp_texture2 = new GL.Texture( samples, 1, options );
				this._temp_texture_out = new GL.Texture( 1, 1, options );
			}

			var tempA = this._temp_texture;
			var tempB = this._temp_texture2;

			var shader_copy = LGraphTextureLinearAvgSmooth._shader_copy;
			var shader_avg = LGraphTextureLinearAvgSmooth._shader_avg;
			var uniforms = this._uniforms;
			uniforms.u_samples = samples;
			uniforms.u_isamples = 1.0 / samples;

			gl.disable(gl.BLEND);
			gl.disable(gl.DEPTH_TEST);
			tempA.drawTo(function() {
				tempB.bind(1);
				tex.toViewport( shader_copy, uniforms );
			});

			this._temp_texture_out.drawTo(function() {
				tempA.toViewport( shader_avg, uniforms );
			});

			this.setOutputData( 0, this._temp_texture_out );

			//swap
			this._temp_texture = tempB;
			this._temp_texture2 = tempA;
		}
		else
			this.setOutputData(0, this._temp_texture_out);
		this.setOutputData(1, this._temp_texture2);
		this.frame++;
	};

	LGraphTextureLinearAvgSmooth.pixel_shader_copy =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_isamples;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			if( v_coord.x <= u_isamples )\n\
				gl_FragColor = texture2D( u_texture, vec2(0.5) );\n\
			else\n\
				gl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );\n\
		}\n\
		";

	LGraphTextureLinearAvgSmooth.pixel_shader_avg =
		"precision highp float;\n\
		precision highp float;\n\
		uniform sampler2D u_texture;\n\
		uniform int u_samples;\n\
		uniform float u_isamples;\n\
		varying vec2 v_coord;\n\
		\n\
		void main() {\n\
			vec4 color = vec4(0.0);\n\
			for(int i = 0; i < 64; ++i)\n\
			{\n\
				color += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );\n\
				if(i == (u_samples - 1))\n\
					break;\n\
			}\n\
			gl_FragColor = color * u_isamples;\n\
		}\n\
		";


	LiteGraph.registerNodeType( "texture/linear_avg_smooth", LGraphTextureLinearAvgSmooth );

	// Image To Texture *****************************************
	function LGraphImageToTexture() {
		this.addInput("Image", "image");
		this.addOutput("", "Texture");
		this.properties = {};
	}

	LGraphImageToTexture.title = "Image to Texture";
	LGraphImageToTexture.desc = "Uploads an image to the GPU";
	//LGraphImageToTexture.widgets_info = { size: { widget:"combo", values:[0,32,64,128,256,512,1024,2048]} };

	LGraphImageToTexture.prototype.onExecute = function() {
		var img = this.getInputData(0);
		if (!img) {
			return;
		}

		var width = img.videoWidth || img.width;
		var height = img.videoHeight || img.height;

		//this is in case we are using a webgl canvas already, no need to reupload it
		if (img.gltexture) {
			this.setOutputData(0, img.gltexture);
			return;
		}

		var temp = this._temp_texture;
		if (!temp || temp.width != width || temp.height != height) {
			this._temp_texture = new GL.Texture(width, height, {
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		try {
			this._temp_texture.uploadImage(img);
		} catch (err) {
			console.error(
				"image comes from an unsafe location, cannot be uploaded to webgl: " +
					err
			);
			return;
		}

		this.setOutputData(0, this._temp_texture);
	};

	LiteGraph.registerNodeType(
		"texture/imageToTexture",
		LGraphImageToTexture
	);

	// Texture LUT *****************************************
	function LGraphTextureLUT() {
		this.addInput("Texture", "Texture");
		this.addInput("LUT", "Texture");
		this.addInput("Intensity", "number");
		this.addOutput("", "Texture");
		this.properties = { enabled: true, intensity: 1, precision: LGraphTexture.DEFAULT, texture: null };

		if (!LGraphTextureLUT._shader) {
			LGraphTextureLUT._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, LGraphTextureLUT.pixel_shader );
		}
	}

	LGraphTextureLUT.widgets_info = {
		texture: { widget: "texture" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureLUT.title = "LUT";
	LGraphTextureLUT.desc = "Apply LUT to Texture";

	LGraphTextureLUT.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === false) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		var lut_tex = this.getInputData(1);

		if (!lut_tex) {
			lut_tex = LGraphTexture.getTexture(this.properties.texture);
		}

		if (!lut_tex) {
			this.setOutputData(0, tex);
			return;
		}

		lut_tex.bind(0);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(
			gl.TEXTURE_2D,
			gl.TEXTURE_WRAP_S,
			gl.CLAMP_TO_EDGE
		);
		gl.texParameteri(
			gl.TEXTURE_2D,
			gl.TEXTURE_WRAP_T,
			gl.CLAMP_TO_EDGE
		);
		gl.bindTexture(gl.TEXTURE_2D, null);

		var intensity = this.properties.intensity;
		if (this.isInputConnected(2)) {
			this.properties.intensity = intensity = this.getInputData(2);
		}

		this._tex = LGraphTexture.getTargetTexture(
			tex,
			this._tex,
			this.properties.precision
		);

		//var mesh = Mesh.getScreenQuad();

		this._tex.drawTo(function() {
			lut_tex.bind(1);
			tex.toViewport(LGraphTextureLUT._shader, {
				u_texture: 0,
				u_textureB: 1,
				u_amount: intensity
			});
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureLUT.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_amount;\n\
		\n\
		void main() {\n\
			 lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\
			 mediump float blueColor = textureColor.b * 63.0;\n\
			 mediump vec2 quad1;\n\
			 quad1.y = floor(floor(blueColor) / 8.0);\n\
			 quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\
			 mediump vec2 quad2;\n\
			 quad2.y = floor(ceil(blueColor) / 8.0);\n\
			 quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\
			 highp vec2 texPos1;\n\
			 texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\
			 texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\
			 highp vec2 texPos2;\n\
			 texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\
			 texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\
			 lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\
			 lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\
			 lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\
			 gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/LUT", LGraphTextureLUT);


	// Texture LUT *****************************************
	function LGraphTextureEncode() {
		this.addInput("Texture", "Texture");
		this.addInput("Atlas", "Texture");
		this.addOutput("", "Texture");
		this.properties = { enabled: true, num_row_symbols: 4, symbol_size: 16, brightness: 1, colorize: false, filter: false, invert: false, precision: LGraphTexture.DEFAULT, generate_mipmaps: false, texture: null };

		if (!LGraphTextureEncode._shader) {
			LGraphTextureEncode._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, LGraphTextureEncode.pixel_shader );
		}

		this._uniforms = {
				u_texture: 0,
				u_textureB: 1,
				u_row_simbols: 4,
				u_simbol_size: 16,
				u_res: vec2.create()
		};
	}

	LGraphTextureEncode.widgets_info = {
		texture: { widget: "texture" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureEncode.title = "Encode";
	LGraphTextureEncode.desc = "Apply a texture atlas to encode a texture";

	LGraphTextureEncode.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === false) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		var symbols_tex = this.getInputData(1);

		if (!symbols_tex) {
			symbols_tex = LGraphTexture.getTexture(this.properties.texture);
		}

		if (!symbols_tex) {
			this.setOutputData(0, tex);
			return;
		}

		symbols_tex.bind(0);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.bindTexture(gl.TEXTURE_2D, null);

		var uniforms = this._uniforms;
		uniforms.u_row_simbols = Math.floor(this.properties.num_row_symbols);
		uniforms.u_symbol_size = this.properties.symbol_size;
		uniforms.u_brightness = this.properties.brightness;
		uniforms.u_invert = this.properties.invert ? 1 : 0;
		uniforms.u_colorize = this.properties.colorize ? 1 : 0;

		this._tex = LGraphTexture.getTargetTexture( tex, this._tex, this.properties.precision );
		uniforms.u_res[0] = this._tex.width;
		uniforms.u_res[1] = this._tex.height;
		this._tex.bind(0);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		this._tex.drawTo(function() {
			symbols_tex.bind(1);
			tex.toViewport(LGraphTextureEncode._shader, uniforms);
		});

		if (this.properties.generate_mipmaps) {
			this._tex.bind(0);
			gl.generateMipmap(this._tex.texture_type);
			this._tex.unbind(0);
		}

		this.setOutputData(0, this._tex);
	};

	LGraphTextureEncode.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_textureB;\n\
		uniform float u_row_simbols;\n\
		uniform float u_symbol_size;\n\
		uniform float u_brightness;\n\
		uniform float u_invert;\n\
		uniform float u_colorize;\n\
		uniform vec2 u_res;\n\
		\n\
		void main() {\n\
			vec2 total_symbols = u_res / u_symbol_size;\n\
			vec2 uv = floor(v_coord * total_symbols) / total_symbols; //pixelate \n\
			vec2 local_uv = mod(v_coord * u_res, u_symbol_size) / u_symbol_size;\n\
			lowp vec4 textureColor = texture2D(u_texture, uv );\n\
			float lum = clamp(u_brightness * (textureColor.x + textureColor.y + textureColor.z)/3.0,0.0,1.0);\n\
			if( u_invert == 1.0 ) lum = 1.0 - lum;\n\
			float index = floor( lum * (u_row_simbols * u_row_simbols - 1.0));\n\
			float col = mod( index, u_row_simbols );\n\
			float row = u_row_simbols - floor( index / u_row_simbols ) - 1.0;\n\
			vec2 simbol_uv = ( vec2( col, row ) + local_uv ) / u_row_simbols;\n\
			vec4 color = texture2D( u_textureB, simbol_uv );\n\
			if(u_colorize == 1.0)\n\
				color *= textureColor;\n\
			gl_FragColor = color;\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/encode", LGraphTextureEncode);

	// Texture Channels *****************************************
	function LGraphTextureChannels() {
		this.addInput("Texture", "Texture");

		this.addOutput("R", "Texture");
		this.addOutput("G", "Texture");
		this.addOutput("B", "Texture");
		this.addOutput("A", "Texture");

		//this.properties = { use_single_channel: true };
		if (!LGraphTextureChannels._shader) {
			LGraphTextureChannels._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureChannels.pixel_shader
			);
		}
	}

	LGraphTextureChannels.title = "Texture to Channels";
	LGraphTextureChannels.desc = "Split texture channels";

	LGraphTextureChannels.prototype.onExecute = function() {
		var texA = this.getInputData(0);
		if (!texA) {
			return;
		}

		if (!this._channels) {
			this._channels = Array(4);
		}

		//var format = this.properties.use_single_channel ? gl.LUMINANCE : gl.RGBA; //not supported by WebGL1
		var format = gl.RGB;
		var connections = 0;
		for (var i = 0; i < 4; i++) {
			if (this.isOutputConnected(i)) {
				if (
					!this._channels[i] ||
					this._channels[i].width != texA.width ||
					this._channels[i].height != texA.height ||
					this._channels[i].type != texA.type ||
					this._channels[i].format != format
				) {
					this._channels[i] = new GL.Texture(
						texA.width,
						texA.height,
						{
							type: texA.type,
							format: format,
							filter: gl.LINEAR
						}
					);
				}
				connections++;
			} else {
				this._channels[i] = null;
			}
		}

		if (!connections) {
			return;
		}

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		var shader = LGraphTextureChannels._shader;
		var masks = [
			[1, 0, 0, 0],
			[0, 1, 0, 0],
			[0, 0, 1, 0],
			[0, 0, 0, 1]
		];

		for (var i = 0; i < 4; i++) {
			if (!this._channels[i]) {
				continue;
			}

			this._channels[i].drawTo(function() {
				texA.bind(0);
				shader
					.uniforms({ u_texture: 0, u_mask: masks[i] })
					.draw(mesh);
			});
			this.setOutputData(i, this._channels[i]);
		}
	};

	LGraphTextureChannels.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec4 u_mask;\n\
		\n\
		void main() {\n\
		   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/textureChannels",
		LGraphTextureChannels
	);

	// Texture Channels to Texture *****************************************
	function LGraphChannelsTexture() {
		this.addInput("R", "Texture");
		this.addInput("G", "Texture");
		this.addInput("B", "Texture");
		this.addInput("A", "Texture");

		this.addOutput("Texture", "Texture");

		this.properties = {
			precision: LGraphTexture.DEFAULT,
			R: 1,
			G: 1,
			B: 1,
			A: 1
		};
		this._color = vec4.create();
		this._uniforms = {
			u_textureR: 0,
			u_textureG: 1,
			u_textureB: 2,
			u_textureA: 3,
			u_color: this._color
		};
	}

	LGraphChannelsTexture.title = "Channels to Texture";
	LGraphChannelsTexture.desc = "Split texture channels";
	LGraphChannelsTexture.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphChannelsTexture.prototype.onExecute = function() {
		var white = LGraphTexture.getWhiteTexture();
		var texR = this.getInputData(0) || white;
		var texG = this.getInputData(1) || white;
		var texB = this.getInputData(2) || white;
		var texA = this.getInputData(3) || white;

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		if (!LGraphChannelsTexture._shader) {
			LGraphChannelsTexture._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphChannelsTexture.pixel_shader
			);
		}
		var shader = LGraphChannelsTexture._shader;

		var w = Math.max(texR.width, texG.width, texB.width, texA.width);
		var h = Math.max(
			texR.height,
			texG.height,
			texB.height,
			texA.height
		);
		var type =
			this.properties.precision == LGraphTexture.HIGH
				? LGraphTexture.HIGH_PRECISION_FORMAT
				: gl.UNSIGNED_BYTE;

		if (
			!this._texture ||
			this._texture.width != w ||
			this._texture.height != h ||
			this._texture.type != type
		) {
			this._texture = new GL.Texture(w, h, {
				type: type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		var color = this._color;
		color[0] = this.properties.R;
		color[1] = this.properties.G;
		color[2] = this.properties.B;
		color[3] = this.properties.A;
		var uniforms = this._uniforms;

		this._texture.drawTo(function() {
			texR.bind(0);
			texG.bind(1);
			texB.bind(2);
			texA.bind(3);
			shader.uniforms(uniforms).draw(mesh);
		});
		this.setOutputData(0, this._texture);
	};

	LGraphChannelsTexture.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_textureR;\n\
		uniform sampler2D u_textureG;\n\
		uniform sampler2D u_textureB;\n\
		uniform sampler2D u_textureA;\n\
		uniform vec4 u_color;\n\
		\n\
		void main() {\n\
		   gl_FragColor = u_color * vec4( \
					texture2D(u_textureR, v_coord).r,\
					texture2D(u_textureG, v_coord).r,\
					texture2D(u_textureB, v_coord).r,\
					texture2D(u_textureA, v_coord).r);\n\
		}\n\
		";

	LiteGraph.registerNodeType(
		"texture/channelsTexture",
		LGraphChannelsTexture
	);

	// Texture Color *****************************************
	function LGraphTextureColor() {
		this.addOutput("Texture", "Texture");

		this._tex_color = vec4.create();
		this.properties = {
			color: vec4.create(),
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureColor.title = "Color";
	LGraphTextureColor.desc =
		"Generates a 1x1 texture with a constant color";

	LGraphTextureColor.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureColor.prototype.onDrawBackground = function(ctx) {
		var c = this.properties.color;
		ctx.fillStyle =
			"rgb(" +
			Math.floor(Math.clamp(c[0], 0, 1) * 255) +
			"," +
			Math.floor(Math.clamp(c[1], 0, 1) * 255) +
			"," +
			Math.floor(Math.clamp(c[2], 0, 1) * 255) +
			")";
		if (this.flags.collapsed) {
			this.boxcolor = ctx.fillStyle;
		} else {
			ctx.fillRect(0, 0, this.size[0], this.size[1]);
		}
	};

	LGraphTextureColor.prototype.onExecute = function() {
		var type =
			this.properties.precision == LGraphTexture.HIGH
				? LGraphTexture.HIGH_PRECISION_FORMAT
				: gl.UNSIGNED_BYTE;

		if (!this._tex || this._tex.type != type) {
			this._tex = new GL.Texture(1, 1, {
				format: gl.RGBA,
				type: type,
				minFilter: gl.NEAREST
			});
		}
		var color = this.properties.color;

		if (this.inputs) {
			for (var i = 0; i < this.inputs.length; i++) {
				var input = this.inputs[i];
				var v = this.getInputData(i);
				if (v === undefined) {
					continue;
				}
				switch (input.name) {
					case "RGB":
					case "RGBA":
						color.set(v);
						break;
					case "R":
						color[0] = v;
						break;
					case "G":
						color[1] = v;
						break;
					case "B":
						color[2] = v;
						break;
					case "A":
						color[3] = v;
						break;
				}
			}
		}

		if (vec4.sqrDist(this._tex_color, color) > 0.001) {
			this._tex_color.set(color);
			this._tex.fill(color);
		}
		this.setOutputData(0, this._tex);
	};

	LGraphTextureColor.prototype.onGetInputs = function() {
		return [
			["RGB", "vec3"],
			["RGBA", "vec4"],
			["R", "number"],
			["G", "number"],
			["B", "number"],
			["A", "number"]
		];
	};

	LiteGraph.registerNodeType("texture/color", LGraphTextureColor);

	// Texture Channels to Texture *****************************************
	function LGraphTextureGradient() {
		this.addInput("A", "color");
		this.addInput("B", "color");
		this.addOutput("Texture", "Texture");

		this.properties = {
			angle: 0,
			scale: 1,
			A: [0, 0, 0],
			B: [1, 1, 1],
			texture_size: 32
		};
		if (!LGraphTextureGradient._shader) {
			LGraphTextureGradient._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureGradient.pixel_shader
			);
		}

		this._uniforms = {
			u_angle: 0,
			u_colorA: vec3.create(),
			u_colorB: vec3.create()
		};
	}

	LGraphTextureGradient.title = "Gradient";
	LGraphTextureGradient.desc = "Generates a gradient";
	LGraphTextureGradient["@A"] = { type: "color" };
	LGraphTextureGradient["@B"] = { type: "color" };
	LGraphTextureGradient["@texture_size"] = {
		type: "enum",
		values: [32, 64, 128, 256, 512]
	};

	LGraphTextureGradient.prototype.onExecute = function() {
		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = GL.Mesh.getScreenQuad();
		var shader = LGraphTextureGradient._shader;

		var A = this.getInputData(0);
		if (!A) {
			A = this.properties.A;
		}
		var B = this.getInputData(1);
		if (!B) {
			B = this.properties.B;
		}

		//angle and scale
		for (var i = 2; i < this.inputs.length; i++) {
			var input = this.inputs[i];
			var v = this.getInputData(i);
			if (v === undefined) {
				continue;
			}
			this.properties[input.name] = v;
		}

		var uniforms = this._uniforms;
		this._uniforms.u_angle = this.properties.angle * DEG2RAD;
		this._uniforms.u_scale = this.properties.scale;
		vec3.copy(uniforms.u_colorA, A);
		vec3.copy(uniforms.u_colorB, B);

		var size = parseInt(this.properties.texture_size);
		if (!this._tex || this._tex.width != size) {
			this._tex = new GL.Texture(size, size, {
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		this._tex.drawTo(function() {
			shader.uniforms(uniforms).draw(mesh);
		});
		this.setOutputData(0, this._tex);
	};

	LGraphTextureGradient.prototype.onGetInputs = function() {
		return [["angle", "number"], ["scale", "number"]];
	};

	LGraphTextureGradient.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform float u_angle;\n\
		uniform float u_scale;\n\
		uniform vec3 u_colorA;\n\
		uniform vec3 u_colorB;\n\
		\n\
		vec2 rotate(vec2 v, float angle)\n\
		{\n\
			vec2 result;\n\
			float _cos = cos(angle);\n\
			float _sin = sin(angle);\n\
			result.x = v.x * _cos - v.y * _sin;\n\
			result.y = v.x * _sin + v.y * _cos;\n\
			return result;\n\
		}\n\
		void main() {\n\
			float f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\
			vec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\
		   gl_FragColor = vec4(color,1.0);\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/gradient", LGraphTextureGradient);

	// Texture Mix *****************************************
	function LGraphTextureMix() {
		this.addInput("A", "Texture");
		this.addInput("B", "Texture");
		this.addInput("Mixer", "Texture");

		this.addOutput("Texture", "Texture");
		this.properties = { factor: 0.5, size_from_biggest: true, invert: false, precision: LGraphTexture.DEFAULT };
		this._uniforms = {
			u_textureA: 0,
			u_textureB: 1,
			u_textureMix: 2,
			u_mix: vec4.create()
		};
	}

	LGraphTextureMix.title = "Mix";
	LGraphTextureMix.desc = "Generates a texture mixing two textures";

	LGraphTextureMix.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureMix.prototype.onExecute = function() {
		var texA = this.getInputData(0);

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, texA);
			return;
		}

		var texB = this.getInputData(1);
		if (!texA || !texB) {
			return;
		}

		var texMix = this.getInputData(2);

		var factor = this.getInputData(3);

		this._tex = LGraphTexture.getTargetTexture(
			this.properties.size_from_biggest && texB.width > texA.width ? texB : texA,
			this._tex,
			this.properties.precision
		);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		var shader = null;
		var uniforms = this._uniforms;
		if (texMix) {
			shader = LGraphTextureMix._shader_tex;
			if (!shader) {
				shader = LGraphTextureMix._shader_tex = new GL.Shader(
					Shader.SCREEN_VERTEX_SHADER,
					LGraphTextureMix.pixel_shader,
					{ MIX_TEX: "" }
				);
			}
		} else {
			shader = LGraphTextureMix._shader_factor;
			if (!shader) {
				shader = LGraphTextureMix._shader_factor = new GL.Shader(
					Shader.SCREEN_VERTEX_SHADER,
					LGraphTextureMix.pixel_shader
				);
			}
			var f = factor == null ? this.properties.factor : factor;
			uniforms.u_mix.set([f, f, f, f]);
		}

		var invert = this.properties.invert;

		this._tex.drawTo(function() {
			texA.bind( invert ? 1 : 0 );
			texB.bind( invert ? 0 : 1 );
			if (texMix) {
				texMix.bind(2);
			}
			shader.uniforms(uniforms).draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureMix.prototype.onGetInputs = function() {
		return [["factor", "number"]];
	};

	LGraphTextureMix.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_textureA;\n\
		uniform sampler2D u_textureB;\n\
		#ifdef MIX_TEX\n\
			uniform sampler2D u_textureMix;\n\
		#else\n\
			uniform vec4 u_mix;\n\
		#endif\n\
		\n\
		void main() {\n\
			#ifdef MIX_TEX\n\
			   vec4 f = texture2D(u_textureMix, v_coord);\n\
			#else\n\
			   vec4 f = u_mix;\n\
			#endif\n\
		   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/mix", LGraphTextureMix);

	// Texture Edges detection *****************************************
	function LGraphTextureEdges() {
		this.addInput("Tex.", "Texture");

		this.addOutput("Edges", "Texture");
		this.properties = {
			invert: true,
			threshold: false,
			factor: 1,
			precision: LGraphTexture.DEFAULT
		};

		if (!LGraphTextureEdges._shader) {
			LGraphTextureEdges._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureEdges.pixel_shader
			);
		}
	}

	LGraphTextureEdges.title = "Edges";
	LGraphTextureEdges.desc = "Detects edges";

	LGraphTextureEdges.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureEdges.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		this._tex = LGraphTexture.getTargetTexture(
			tex,
			this._tex,
			this.properties.precision
		);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		var mesh = Mesh.getScreenQuad();
		var shader = LGraphTextureEdges._shader;
		var invert = this.properties.invert;
		var factor = this.properties.factor;
		var threshold = this.properties.threshold ? 1 : 0;

		this._tex.drawTo(function() {
			tex.bind(0);
			shader
				.uniforms({
					u_texture: 0,
					u_isize: [1 / tex.width, 1 / tex.height],
					u_factor: factor,
					u_threshold: threshold,
					u_invert: invert ? 1 : 0
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureEdges.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_isize;\n\
		uniform int u_invert;\n\
		uniform float u_factor;\n\
		uniform float u_threshold;\n\
		\n\
		void main() {\n\
			vec4 center = texture2D(u_texture, v_coord);\n\
			vec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\
			vec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\
			vec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\
			vec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\
			vec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\
			diff *= u_factor;\n\
			if(u_invert == 1)\n\
				diff.xyz = vec3(1.0) - diff.xyz;\n\
			if( u_threshold == 0.0 )\n\
				gl_FragColor = vec4( diff.xyz, center.a );\n\
			else\n\
				gl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\n\
		}\n\
		";

	LiteGraph.registerNodeType("texture/edges", LGraphTextureEdges);

	// Texture Depth *****************************************
	function LGraphTextureDepthRange() {
		this.addInput("Texture", "Texture");
		this.addInput("Distance", "number");
		this.addInput("Range", "number");
		this.addOutput("Texture", "Texture");
		this.properties = {
			distance: 100,
			range: 50,
			only_depth: false,
			high_precision: false
		};
		this._uniforms = {
			u_texture: 0,
			u_distance: 100,
			u_range: 50,
			u_camera_planes: null
		};
	}

	LGraphTextureDepthRange.title = "Depth Range";
	LGraphTextureDepthRange.desc = "Generates a texture with a depth range";

	LGraphTextureDepthRange.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		var precision = gl.UNSIGNED_BYTE;
		if (this.properties.high_precision) {
			precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
		}

		if (
			!this._temp_texture ||
			this._temp_texture.type != precision ||
			this._temp_texture.width != tex.width ||
			this._temp_texture.height != tex.height
		) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: precision,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		var uniforms = this._uniforms;

		//iterations
		var distance = this.properties.distance;
		if (this.isInputConnected(1)) {
			distance = this.getInputData(1);
			this.properties.distance = distance;
		}

		var range = this.properties.range;
		if (this.isInputConnected(2)) {
			range = this.getInputData(2);
			this.properties.range = range;
		}

		uniforms.u_distance = distance;
		uniforms.u_range = range;

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		var mesh = Mesh.getScreenQuad();
		if (!LGraphTextureDepthRange._shader) {
			LGraphTextureDepthRange._shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureDepthRange.pixel_shader
			);
			LGraphTextureDepthRange._shader_onlydepth = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureDepthRange.pixel_shader,
				{ ONLY_DEPTH: "" }
			);
		}
		var shader = this.properties.only_depth
			? LGraphTextureDepthRange._shader_onlydepth
			: LGraphTextureDepthRange._shader;

		//NEAR AND FAR PLANES
		var planes = null;
		if (tex.near_far_planes) {
			planes = tex.near_far_planes;
		} else if (window.LS && LS.Renderer._main_camera) {
			planes = LS.Renderer._main_camera._uniforms.u_camera_planes;
		} else {
			planes = [0.1, 1000];
		} //hardcoded
		uniforms.u_camera_planes = planes;

		this._temp_texture.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(mesh);
		});

		this._temp_texture.near_far_planes = planes;
		this.setOutputData(0, this._temp_texture);
	};

	LGraphTextureDepthRange.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_camera_planes;\n\
		uniform float u_distance;\n\
		uniform float u_range;\n\
		\n\
		float LinearDepth()\n\
		{\n\
			float zNear = u_camera_planes.x;\n\
			float zFar = u_camera_planes.y;\n\
			float depth = texture2D(u_texture, v_coord).x;\n\
			depth = depth * 2.0 - 1.0;\n\
			return zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\
		}\n\
		\n\
		void main() {\n\
			float depth = LinearDepth();\n\
			#ifdef ONLY_DEPTH\n\
			   gl_FragColor = vec4(depth);\n\
			#else\n\
				float diff = abs(depth * u_camera_planes.y - u_distance);\n\
				float dof = 1.0;\n\
				if(diff <= u_range)\n\
					dof = diff / u_range;\n\
			   gl_FragColor = vec4(dof);\n\
			#endif\n\
		}\n\
		";

	LiteGraph.registerNodeType( "texture/depth_range", LGraphTextureDepthRange );


	// Texture Depth *****************************************
	function LGraphTextureLinearDepth() {
		this.addInput("Texture", "Texture");
		this.addOutput("Texture", "Texture");
		this.properties = {
			precision: LGraphTexture.DEFAULT,
			invert: false
		};
		this._uniforms = {
			u_texture: 0,
			u_camera_planes: null, //filled later
			u_ires: vec2.create()
		};
	}

	LGraphTextureLinearDepth.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureLinearDepth.title = "Linear Depth";
	LGraphTextureLinearDepth.desc = "Creates a color texture with linear depth";

	LGraphTextureLinearDepth.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);
		if (!tex || (tex.format != gl.DEPTH_COMPONENT && tex.format != gl.DEPTH_STENCIL) ) {
			return;
		}

		var precision = this.properties.precision == LGraphTexture.HIGH ? gl.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;

		if ( !this._temp_texture || this._temp_texture.type != precision || this._temp_texture.width != tex.width || this._temp_texture.height != tex.height ) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: precision,
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		var uniforms = this._uniforms;
		uniforms.u_invert = this.properties.invert ? 1 : 0;

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		var mesh = Mesh.getScreenQuad();
		if(!LGraphTextureLinearDepth._shader)
			LGraphTextureLinearDepth._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearDepth.pixel_shader);
		var shader = LGraphTextureLinearDepth._shader;

		//NEAR AND FAR PLANES
		var planes = null;
		if (tex.near_far_planes) {
			planes = tex.near_far_planes;
		} else if (window.LS && LS.Renderer._main_camera) {
			planes = LS.Renderer._main_camera._uniforms.u_camera_planes;
		} else {
			planes = [0.1, 1000];
		} //hardcoded
		uniforms.u_camera_planes = planes;
		//uniforms.u_ires.set([1/tex.width, 1/tex.height]);
		uniforms.u_ires.set([0,0]);

		this._temp_texture.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(mesh);
		});

		this._temp_texture.near_far_planes = planes;
		this.setOutputData(0, this._temp_texture);
	};

	LGraphTextureLinearDepth.pixel_shader =
		"precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_camera_planes;\n\
		uniform int u_invert;\n\
		uniform vec2 u_ires;\n\
		\n\
		void main() {\n\
			float zNear = u_camera_planes.x;\n\
			float zFar = u_camera_planes.y;\n\
			float depth = texture2D(u_texture, v_coord + u_ires*0.5).x * 2.0 - 1.0;\n\
			float f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\
			if( u_invert == 1 )\n\
				f = 1.0 - f;\n\
			gl_FragColor = vec4(vec3(f),1.0);\n\
		}\n\
		";

	LiteGraph.registerNodeType( "texture/linear_depth", LGraphTextureLinearDepth );

	// Texture Blur *****************************************
	function LGraphTextureBlur() {
		this.addInput("Texture", "Texture");
		this.addInput("Iterations", "number");
		this.addInput("Intensity", "number");
		this.addOutput("Blurred", "Texture");
		this.properties = {
			intensity: 1,
			iterations: 1,
			preserve_aspect: false,
			scale: [1, 1],
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureBlur.title = "Blur";
	LGraphTextureBlur.desc = "Blur a texture";

	LGraphTextureBlur.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureBlur.max_iterations = 20;

	LGraphTextureBlur.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._final_texture;

		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			//we need two textures to do the blurring
			//this._temp_texture = new GL.Texture( tex.width, tex.height, { type: tex.type, format: gl.RGBA, filter: gl.LINEAR });
			temp = this._final_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		//iterations
		var iterations = this.properties.iterations;
		if (this.isInputConnected(1)) {
			iterations = this.getInputData(1);
			this.properties.iterations = iterations;
		}
		iterations = Math.min(
			Math.floor(iterations),
			LGraphTextureBlur.max_iterations
		);
		if (iterations == 0) {
			//skip blurring
			this.setOutputData(0, tex);
			return;
		}

		var intensity = this.properties.intensity;
		if (this.isInputConnected(2)) {
			intensity = this.getInputData(2);
			this.properties.intensity = intensity;
		}

		//blur sometimes needs an aspect correction
		var aspect = LiteGraph.camera_aspect;
		if (!aspect && window.gl !== undefined) {
			aspect = gl.canvas.height / gl.canvas.width;
		}
		if (!aspect) {
			aspect = 1;
		}
		aspect = this.properties.preserve_aspect ? aspect : 1;

		var scale = this.properties.scale || [1, 1];
		tex.applyBlur(aspect * scale[0], scale[1], intensity, temp);
		for (var i = 1; i < iterations; ++i) {
			temp.applyBlur(
				aspect * scale[0] * (i + 1),
				scale[1] * (i + 1),
				intensity
			);
		}

		this.setOutputData(0, temp);
	};

	/*
LGraphTextureBlur.pixel_shader = "precision highp float;\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec2 u_offset;\n\
		uniform float u_intensity;\n\
		void main() {\n\
		   vec4 sum = vec4(0.0);\n\
		   vec4 center = texture2D(u_texture, v_coord);\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\n\
		   sum += center * 0.16/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\n\
		   sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\n\
		   gl_FragColor = u_intensity * sum;\n\
		}\n\
		";
*/

	LiteGraph.registerNodeType("texture/blur", LGraphTextureBlur);

	//Independent glow FX
	//based on https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/
	function FXGlow()
	{
		this.intensity = 0.5;
		this.persistence = 0.6;
		this.iterations = 8;
		this.threshold = 0.8;
		this.scale = 1;

		this.dirt_texture = null;
		this.dirt_factor = 0.5;

		this._textures = [];
		this._uniforms = {
			u_intensity: 1,
			u_texture: 0,
			u_glow_texture: 1,
			u_threshold: 0,
			u_texel_size: vec2.create()
		};
	}

	FXGlow.prototype.applyFX = function( tex, output_texture, glow_texture, average_texture ) {

		var width = tex.width;
		var height = tex.height;

		var texture_info = {
			format: tex.format,
			type: tex.type,
			minFilter: GL.LINEAR,
			magFilter: GL.LINEAR,
			wrap: gl.CLAMP_TO_EDGE
		};

		var uniforms = this._uniforms;
		var textures = this._textures;

		//cut
		var shader = FXGlow._cut_shader;
		if (!shader) {
			shader = FXGlow._cut_shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				FXGlow.cut_pixel_shader
			);
		}

		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);

		uniforms.u_threshold = this.threshold;
		var currentDestination = (textures[0] = GL.Texture.getTemporary(
			width,
			height,
			texture_info
		));
		tex.blit( currentDestination, shader.uniforms(uniforms) );
		var currentSource = currentDestination;

		var iterations = this.iterations;
		iterations = Math.clamp(iterations, 1, 16) | 0;
		var texel_size = uniforms.u_texel_size;
		var intensity = this.intensity;

		uniforms.u_intensity = 1;
		uniforms.u_delta = this.scale; //1

		//downscale/upscale shader
		var shader = FXGlow._shader;
		if (!shader) {
			shader = FXGlow._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				FXGlow.scale_pixel_shader
			);
		}

		var i = 1;
		//downscale
		for (; i < iterations; i++) {
			width = width >> 1;
			if ((height | 0) > 1) {
				height = height >> 1;
			}
			if (width < 2) {
				break;
			}
			currentDestination = textures[i] = GL.Texture.getTemporary(
				width,
				height,
				texture_info
			);
			texel_size[0] = 1 / currentSource.width;
			texel_size[1] = 1 / currentSource.height;
			currentSource.blit(
				currentDestination,
				shader.uniforms(uniforms)
			);
			currentSource = currentDestination;
		}

		//average
		if (average_texture) {
			texel_size[0] = 1 / currentSource.width;
			texel_size[1] = 1 / currentSource.height;
			uniforms.u_intensity = intensity;
			uniforms.u_delta = 1;
			currentSource.blit(average_texture, shader.uniforms(uniforms));
		}

		//upscale and blend
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.ONE, gl.ONE);
		uniforms.u_intensity = this.persistence;
		uniforms.u_delta = 0.5;

		// i-=2 => -1 to point to last element in array, -1 to go to texture above
		for ( i -= 2; i >= 0; i-- ) 
		{
			currentDestination = textures[i];
			textures[i] = null;
			texel_size[0] = 1 / currentSource.width;
			texel_size[1] = 1 / currentSource.height;
			currentSource.blit(
				currentDestination,
				shader.uniforms(uniforms)
			);
			GL.Texture.releaseTemporary(currentSource);
			currentSource = currentDestination;
		}
		gl.disable(gl.BLEND);

		//glow
		if (glow_texture) {
			currentSource.blit(glow_texture);
		}

		//final composition
		if ( output_texture ) {
			var final_texture = output_texture;
			var dirt_texture = this.dirt_texture;
			var dirt_factor = this.dirt_factor;
			uniforms.u_intensity = intensity;

			shader = dirt_texture
				? FXGlow._dirt_final_shader
				: FXGlow._final_shader;
			if (!shader) {
				if (dirt_texture) {
					shader = FXGlow._dirt_final_shader = new GL.Shader(
						GL.Shader.SCREEN_VERTEX_SHADER,
						FXGlow.final_pixel_shader,
						{ USE_DIRT: "" }
					);
				} else {
					shader = FXGlow._final_shader = new GL.Shader(
						GL.Shader.SCREEN_VERTEX_SHADER,
						FXGlow.final_pixel_shader
					);
				}
			}

			final_texture.drawTo(function() {
				tex.bind(0);
				currentSource.bind(1);
				if (dirt_texture) {
					shader.setUniform("u_dirt_factor", dirt_factor);
					shader.setUniform(
						"u_dirt_texture",
						dirt_texture.bind(2)
					);
				}
				shader.toViewport(uniforms);
			});
		}

		GL.Texture.releaseTemporary(currentSource);
	};

	FXGlow.cut_pixel_shader =
		"precision highp float;\n\
	varying vec2 v_coord;\n\
	uniform sampler2D u_texture;\n\
	uniform float u_threshold;\n\
	void main() {\n\
		gl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\n\
	}";

	FXGlow.scale_pixel_shader =
		"precision highp float;\n\
	varying vec2 v_coord;\n\
	uniform sampler2D u_texture;\n\
	uniform vec2 u_texel_size;\n\
	uniform float u_delta;\n\
	uniform float u_intensity;\n\
	\n\
	vec4 sampleBox(vec2 uv) {\n\
		vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\
		vec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\n\
		return s * 0.25;\n\
	}\n\
	void main() {\n\
		gl_FragColor = u_intensity * sampleBox( v_coord );\n\
	}";

	FXGlow.final_pixel_shader =
		"precision highp float;\n\
	varying vec2 v_coord;\n\
	uniform sampler2D u_texture;\n\
	uniform sampler2D u_glow_texture;\n\
	#ifdef USE_DIRT\n\
		uniform sampler2D u_dirt_texture;\n\
	#endif\n\
	uniform vec2 u_texel_size;\n\
	uniform float u_delta;\n\
	uniform float u_intensity;\n\
	uniform float u_dirt_factor;\n\
	\n\
	vec4 sampleBox(vec2 uv) {\n\
		vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\
		vec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\n\
		return s * 0.25;\n\
	}\n\
	void main() {\n\
		vec4 glow = sampleBox( v_coord );\n\
		#ifdef USE_DIRT\n\
			glow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\n\
		#endif\n\
		gl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\n\
	}";


	// Texture Glow *****************************************
	function LGraphTextureGlow() {
		this.addInput("in", "Texture");
		this.addInput("dirt", "Texture");
		this.addOutput("out", "Texture");
		this.addOutput("glow", "Texture");
		this.properties = {
			enabled: true,
			intensity: 1,
			persistence: 0.99,
			iterations: 16,
			threshold: 0,
			scale: 1,
			dirt_factor: 0.5,
			precision: LGraphTexture.DEFAULT
		};

		this.fx = new FXGlow();
	}

	LGraphTextureGlow.title = "Glow";
	LGraphTextureGlow.desc = "Filters a texture giving it a glow effect";

	LGraphTextureGlow.widgets_info = {
		iterations: {
			type: "number",
			min: 0,
			max: 16,
			step: 1,
			precision: 0
		},
		threshold: {
			type: "number",
			min: 0,
			max: 10,
			step: 0.01,
			precision: 2
		},
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureGlow.prototype.onGetInputs = function() {
		return [
			["enabled", "boolean"],
			["threshold", "number"],
			["intensity", "number"],
			["persistence", "number"],
			["iterations", "number"],
			["dirt_factor", "number"]
		];
	};

	LGraphTextureGlow.prototype.onGetOutputs = function() {
		return [["average", "Texture"]];
	};

	LGraphTextureGlow.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isAnyOutputConnected()) {
			return;
		} //saves work

		if (
			this.properties.precision === LGraphTexture.PASS_THROUGH ||
			this.getInputOrProperty("enabled") === false
		) {
			this.setOutputData(0, tex);
			return;
		}

		var width = tex.width;
		var height = tex.height;

		var fx = this.fx;
		fx.threshold = this.getInputOrProperty("threshold");
		fx.iterations = this.getInputOrProperty("iterations");
		fx.intensity = this.getInputOrProperty("intensity");
		fx.persistence = this.getInputOrProperty("persistence");
		fx.dirt_texture = this.getInputData(1);
		fx.dirt_factor = this.getInputOrProperty("dirt_factor");
		fx.scale = this.properties.scale;

		var type = LGraphTexture.getTextureType( this.properties.precision, tex );

		var average_texture = null;
		if (this.isOutputConnected(2)) {
			average_texture = this._average_texture;
			if (
				!average_texture ||
				average_texture.type != tex.type ||
				average_texture.format != tex.format
			) {
				average_texture = this._average_texture = new GL.Texture(
					1,
					1,
					{
						type: tex.type,
						format: tex.format,
						filter: gl.LINEAR
					}
				);
			}
		}

		var glow_texture = null;
		if (this.isOutputConnected(1)) {
			glow_texture = this._glow_texture;
			if (
				!glow_texture ||
				glow_texture.width != tex.width ||
				glow_texture.height != tex.height ||
				glow_texture.type != type ||
				glow_texture.format != tex.format
			) {
				glow_texture = this._glow_texture = new GL.Texture(
					tex.width,
					tex.height,
					{ type: type, format: tex.format, filter: gl.LINEAR }
				);
			}
		}

		var final_texture = null;
		if (this.isOutputConnected(0)) {
			final_texture = this._final_texture;
			if (
				!final_texture ||
				final_texture.width != tex.width ||
				final_texture.height != tex.height ||
				final_texture.type != type ||
				final_texture.format != tex.format
			) {
				final_texture = this._final_texture = new GL.Texture(
					tex.width,
					tex.height,
					{ type: type, format: tex.format, filter: gl.LINEAR }
				);
			}

		}

		//apply FX
		fx.applyFX(tex, final_texture, glow_texture, average_texture );

		if (this.isOutputConnected(0))
			this.setOutputData(0, final_texture);

		if (this.isOutputConnected(1))
			this.setOutputData(1, average_texture);

		if (this.isOutputConnected(2))
			this.setOutputData(2, glow_texture);
	};

	LiteGraph.registerNodeType("texture/glow", LGraphTextureGlow);

	// Texture Filter *****************************************
	function LGraphTextureKuwaharaFilter() {
		this.addInput("Texture", "Texture");
		this.addOutput("Filtered", "Texture");
		this.properties = { intensity: 1, radius: 5 };
	}

	LGraphTextureKuwaharaFilter.title = "Kuwahara Filter";
	LGraphTextureKuwaharaFilter.desc =
		"Filters a texture giving an artistic oil canvas painting";

	LGraphTextureKuwaharaFilter.max_radius = 10;
	LGraphTextureKuwaharaFilter._shaders = [];

	LGraphTextureKuwaharaFilter.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._temp_texture;

		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: tex.type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		//iterations
		var radius = this.properties.radius;
		radius = Math.min(
			Math.floor(radius),
			LGraphTextureKuwaharaFilter.max_radius
		);
		if (radius == 0) {
			//skip blurring
			this.setOutputData(0, tex);
			return;
		}

		var intensity = this.properties.intensity;

		//blur sometimes needs an aspect correction
		var aspect = LiteGraph.camera_aspect;
		if (!aspect && window.gl !== undefined) {
			aspect = gl.canvas.height / gl.canvas.width;
		}
		if (!aspect) {
			aspect = 1;
		}
		aspect = this.properties.preserve_aspect ? aspect : 1;

		if (!LGraphTextureKuwaharaFilter._shaders[radius]) {
			LGraphTextureKuwaharaFilter._shaders[radius] = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureKuwaharaFilter.pixel_shader,
				{ RADIUS: radius.toFixed(0) }
			);
		}

		var shader = LGraphTextureKuwaharaFilter._shaders[radius];
		var mesh = GL.Mesh.getScreenQuad();
		tex.bind(0);

		this._temp_texture.drawTo(function() {
			shader
				.uniforms({
					u_texture: 0,
					u_intensity: intensity,
					u_resolution: [tex.width, tex.height],
					u_iResolution: [1 / tex.width, 1 / tex.height]
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._temp_texture);
	};

	//from https://www.shadertoy.com/view/MsXSz4
	LGraphTextureKuwaharaFilter.pixel_shader =
		"\n\
precision highp float;\n\
varying vec2 v_coord;\n\
uniform sampler2D u_texture;\n\
uniform float u_intensity;\n\
uniform vec2 u_resolution;\n\
uniform vec2 u_iResolution;\n\
#ifndef RADIUS\n\
	#define RADIUS 7\n\
#endif\n\
void main() {\n\
\n\
	const int radius = RADIUS;\n\
	vec2 fragCoord = v_coord;\n\
	vec2 src_size = u_iResolution;\n\
	vec2 uv = v_coord;\n\
	float n = float((radius + 1) * (radius + 1));\n\
	int i;\n\
	int j;\n\
	vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\
	vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\
	vec3 c;\n\
	\n\
	for (int j = -radius; j <= 0; ++j)  {\n\
		for (int i = -radius; i <= 0; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m0 += c;\n\
			s0 += c * c;\n\
		}\n\
	}\n\
	\n\
	for (int j = -radius; j <= 0; ++j)  {\n\
		for (int i = 0; i <= radius; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m1 += c;\n\
			s1 += c * c;\n\
		}\n\
	}\n\
	\n\
	for (int j = 0; j <= radius; ++j)  {\n\
		for (int i = 0; i <= radius; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m2 += c;\n\
			s2 += c * c;\n\
		}\n\
	}\n\
	\n\
	for (int j = 0; j <= radius; ++j)  {\n\
		for (int i = -radius; i <= 0; ++i)  {\n\
			c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\
			m3 += c;\n\
			s3 += c * c;\n\
		}\n\
	}\n\
	\n\
	float min_sigma2 = 1e+2;\n\
	m0 /= n;\n\
	s0 = abs(s0 / n - m0 * m0);\n\
	\n\
	float sigma2 = s0.r + s0.g + s0.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m0, 1.0);\n\
	}\n\
	\n\
	m1 /= n;\n\
	s1 = abs(s1 / n - m1 * m1);\n\
	\n\
	sigma2 = s1.r + s1.g + s1.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m1, 1.0);\n\
	}\n\
	\n\
	m2 /= n;\n\
	s2 = abs(s2 / n - m2 * m2);\n\
	\n\
	sigma2 = s2.r + s2.g + s2.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m2, 1.0);\n\
	}\n\
	\n\
	m3 /= n;\n\
	s3 = abs(s3 / n - m3 * m3);\n\
	\n\
	sigma2 = s3.r + s3.g + s3.b;\n\
	if (sigma2 < min_sigma2) {\n\
		min_sigma2 = sigma2;\n\
		gl_FragColor = vec4(m3, 1.0);\n\
	}\n\
}\n\
";

	LiteGraph.registerNodeType(
		"texture/kuwahara",
		LGraphTextureKuwaharaFilter
	);

	// Texture  *****************************************
	function LGraphTextureXDoGFilter() {
		this.addInput("Texture", "Texture");
		this.addOutput("Filtered", "Texture");
		this.properties = {
			sigma: 1.4,
			k: 1.6,
			p: 21.7,
			epsilon: 79,
			phi: 0.017
		};
	}

	LGraphTextureXDoGFilter.title = "XDoG Filter";
	LGraphTextureXDoGFilter.desc =
		"Filters a texture giving an artistic ink style";

	LGraphTextureXDoGFilter.max_radius = 10;
	LGraphTextureXDoGFilter._shaders = [];

	LGraphTextureXDoGFilter.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			this._temp_texture = new GL.Texture(tex.width, tex.height, {
				type: tex.type,
				format: gl.RGBA,
				filter: gl.LINEAR
			});
		}

		if (!LGraphTextureXDoGFilter._xdog_shader) {
			LGraphTextureXDoGFilter._xdog_shader = new GL.Shader(
				Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureXDoGFilter.xdog_pixel_shader
			);
		}
		var shader = LGraphTextureXDoGFilter._xdog_shader;
		var mesh = GL.Mesh.getScreenQuad();

		var sigma = this.properties.sigma;
		var k = this.properties.k;
		var p = this.properties.p;
		var epsilon = this.properties.epsilon;
		var phi = this.properties.phi;
		tex.bind(0);
		this._temp_texture.drawTo(function() {
			shader
				.uniforms({
					src: 0,
					sigma: sigma,
					k: k,
					p: p,
					epsilon: epsilon,
					phi: phi,
					cvsWidth: tex.width,
					cvsHeight: tex.height
				})
				.draw(mesh);
		});

		this.setOutputData(0, this._temp_texture);
	};

	//from https://github.com/RaymondMcGuire/GPU-Based-Image-Processing-Tools/blob/master/lib_webgl/scripts/main.js
	LGraphTextureXDoGFilter.xdog_pixel_shader =
		"\n\
precision highp float;\n\
uniform sampler2D src;\n\n\
uniform float cvsHeight;\n\
uniform float cvsWidth;\n\n\
uniform float sigma;\n\
uniform float k;\n\
uniform float p;\n\
uniform float epsilon;\n\
uniform float phi;\n\
varying vec2 v_coord;\n\n\
float cosh(float val)\n\
{\n\
	float tmp = exp(val);\n\
	float cosH = (tmp + 1.0 / tmp) / 2.0;\n\
	return cosH;\n\
}\n\n\
float tanh(float val)\n\
{\n\
	float tmp = exp(val);\n\
	float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n\
	return tanH;\n\
}\n\n\
float sinh(float val)\n\
{\n\
	float tmp = exp(val);\n\
	float sinH = (tmp - 1.0 / tmp) / 2.0;\n\
	return sinH;\n\
}\n\n\
void main(void){\n\
	vec3 destColor = vec3(0.0);\n\
	float tFrag = 1.0 / cvsHeight;\n\
	float sFrag = 1.0 / cvsWidth;\n\
	vec2 Frag = vec2(sFrag,tFrag);\n\
	vec2 uv = gl_FragCoord.st;\n\
	float twoSigmaESquared = 2.0 * sigma * sigma;\n\
	float twoSigmaRSquared = twoSigmaESquared * k * k;\n\
	int halfWidth = int(ceil( 1.0 * sigma * k ));\n\n\
	const int MAX_NUM_ITERATION = 99999;\n\
	vec2 sum = vec2(0.0);\n\
	vec2 norm = vec2(0.0);\n\n\
	for(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){\n\
		if(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}\n\
		int i = int(cnt / (2*halfWidth+1)) - halfWidth;\n\
		int j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);\n\n\
		float d = length(vec2(i,j));\n\
		vec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), \n\
							exp( -d * d / twoSigmaRSquared ));\n\n\
		vec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;\n\n\
		norm += kernel;\n\
		sum += kernel * L;\n\
	}\n\n\
	sum /= norm;\n\n\
	float H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);\n\
	float edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));\n\
	destColor = vec3(edge);\n\
	gl_FragColor = vec4(destColor, 1.0);\n\
}";

	LiteGraph.registerNodeType("texture/xDoG", LGraphTextureXDoGFilter);

	// Texture Webcam *****************************************
	function LGraphTextureWebcam() {
		this.addOutput("Webcam", "Texture");
		this.properties = { texture_name: "", facingMode: "user" };
		this.boxcolor = "black";
		this.version = 0;
	}

	LGraphTextureWebcam.title = "Webcam";
	LGraphTextureWebcam.desc = "Webcam texture";

	LGraphTextureWebcam.is_webcam_open = false;

	LGraphTextureWebcam.prototype.openStream = function() {
		if (!navigator.getUserMedia) {
			//console.log('getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags');
			return;
		}

		this._waiting_confirmation = true;

		// Not showing vendor prefixes.
		var constraints = {
			audio: false,
			video: { facingMode: this.properties.facingMode }
		};
		navigator.mediaDevices
			.getUserMedia(constraints)
			.then(this.streamReady.bind(this))
			.catch(onFailSoHard);

		var that = this;
		function onFailSoHard(e) {
			LGraphTextureWebcam.is_webcam_open = false;
			console.log("Webcam rejected", e);
			that._webcam_stream = false;
			that.boxcolor = "red";
			that.trigger("stream_error");
		}
	};

	LGraphTextureWebcam.prototype.closeStream = function() {
		if (this._webcam_stream) {
			var tracks = this._webcam_stream.getTracks();
			if (tracks.length) {
				for (var i = 0; i < tracks.length; ++i) {
					tracks[i].stop();
				}
			}
			LGraphTextureWebcam.is_webcam_open = false;
			this._webcam_stream = null;
			this._video = null;
			this.boxcolor = "black";
			this.trigger("stream_closed");
		}
	};

	LGraphTextureWebcam.prototype.streamReady = function(localMediaStream) {
		this._webcam_stream = localMediaStream;
		//this._waiting_confirmation = false;
		this.boxcolor = "green";
		var video = this._video;
		if (!video) {
			video = document.createElement("video");
			video.autoplay = true;
			video.srcObject = localMediaStream;
			this._video = video;
			//document.body.appendChild( video ); //debug
			//when video info is loaded (size and so)
			video.onloadedmetadata = function(e) {
				// Ready to go. Do some stuff.
				LGraphTextureWebcam.is_webcam_open = true;
				console.log(e);
			};
		}
		this.trigger("stream_ready", video);
	};

	LGraphTextureWebcam.prototype.onPropertyChanged = function(
		name,
		value
	) {
		if (name == "facingMode") {
			this.properties.facingMode = value;
			this.closeStream();
			this.openStream();
		}
	};

	LGraphTextureWebcam.prototype.onRemoved = function() {
		if (!this._webcam_stream) {
			return;
		}

		var tracks = this._webcam_stream.getTracks();
		if (tracks.length) {
			for (var i = 0; i < tracks.length; ++i) {
				tracks[i].stop();
			}
		}

		this._webcam_stream = null;
		this._video = null;
	};

	LGraphTextureWebcam.prototype.onDrawBackground = function(ctx) {
		if (this.flags.collapsed || this.size[1] <= 20) {
			return;
		}

		if (!this._video) {
			return;
		}

		//render to graph canvas
		ctx.save();
		if (!ctx.webgl) {
			//reverse image
			ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);
		} else {
			if (this._video_texture) {
				ctx.drawImage(
					this._video_texture,
					0,
					0,
					this.size[0],
					this.size[1]
				);
			}
		}
		ctx.restore();
	};

	LGraphTextureWebcam.prototype.onExecute = function() {
		if (this._webcam_stream == null && !this._waiting_confirmation) {
			this.openStream();
		}

		if (!this._video || !this._video.videoWidth) {
			return;
		}

		var width = this._video.videoWidth;
		var height = this._video.videoHeight;

		var temp = this._video_texture;
		if (!temp || temp.width != width || temp.height != height) {
			this._video_texture = new GL.Texture(width, height, {
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		this._video_texture.uploadImage(this._video);
		this._video_texture.version = ++this.version;

		if (this.properties.texture_name) {
			var container = LGraphTexture.getTexturesContainer();
			container[this.properties.texture_name] = this._video_texture;
		}

		this.setOutputData(0, this._video_texture);
		for (var i = 1; i < this.outputs.length; ++i) {
			if (!this.outputs[i]) {
				continue;
			}
			switch (this.outputs[i].name) {
				case "width":
					this.setOutputData(i, this._video.videoWidth);
					break;
				case "height":
					this.setOutputData(i, this._video.videoHeight);
					break;
			}
		}
	};

	LGraphTextureWebcam.prototype.onGetOutputs = function() {
		return [
			["width", "number"],
			["height", "number"],
			["stream_ready", LiteGraph.EVENT],
			["stream_closed", LiteGraph.EVENT],
			["stream_error", LiteGraph.EVENT]
		];
	};

	LiteGraph.registerNodeType("texture/webcam", LGraphTextureWebcam);

	//from https://github.com/spite/Wagner
	function LGraphLensFX() {
		this.addInput("in", "Texture");
		this.addInput("f", "number");
		this.addOutput("out", "Texture");
		this.properties = {
			enabled: true,
			factor: 1,
			precision: LGraphTexture.LOW
		};

		this._uniforms = { u_texture: 0, u_factor: 1 };
	}

	LGraphLensFX.title = "Lens FX";
	LGraphLensFX.desc = "distortion and chromatic aberration";

	LGraphLensFX.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphLensFX.prototype.onGetInputs = function() {
		return [["enabled", "boolean"]];
	};

	LGraphLensFX.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (
			this.properties.precision === LGraphTexture.PASS_THROUGH ||
			this.getInputOrProperty("enabled") === false
		) {
			this.setOutputData(0, tex);
			return;
		}

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			temp = this._temp_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		var shader = LGraphLensFX._shader;
		if (!shader) {
			shader = LGraphLensFX._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphLensFX.pixel_shader
			);
		}

		var factor = this.getInputData(1);
		if (factor == null) {
			factor = this.properties.factor;
		}

		var uniforms = this._uniforms;
		uniforms.u_factor = factor;

		//apply shader
		gl.disable(gl.DEPTH_TEST);
		temp.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	};

	LGraphLensFX.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_factor;\n\
		vec2 barrelDistortion(vec2 coord, float amt) {\n\
			vec2 cc = coord - 0.5;\n\
			float dist = dot(cc, cc);\n\
			return coord + cc * dist * amt;\n\
		}\n\
		\n\
		float sat( float t )\n\
		{\n\
			return clamp( t, 0.0, 1.0 );\n\
		}\n\
		\n\
		float linterp( float t ) {\n\
			return sat( 1.0 - abs( 2.0*t - 1.0 ) );\n\
		}\n\
		\n\
		float remap( float t, float a, float b ) {\n\
			return sat( (t - a) / (b - a) );\n\
		}\n\
		\n\
		vec4 spectrum_offset( float t ) {\n\
			vec4 ret;\n\
			float lo = step(t,0.5);\n\
			float hi = 1.0-lo;\n\
			float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\
			ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\
		\n\
			return pow( ret, vec4(1.0/2.2) );\n\
		}\n\
		\n\
		const float max_distort = 2.2;\n\
		const int num_iter = 12;\n\
		const float reci_num_iter_f = 1.0 / float(num_iter);\n\
		\n\
		void main()\n\
		{	\n\
			vec2 uv=v_coord;\n\
			vec4 sumcol = vec4(0.0);\n\
			vec4 sumw = vec4(0.0);	\n\
			for ( int i=0; i<num_iter;++i )\n\
			{\n\
				float t = float(i) * reci_num_iter_f;\n\
				vec4 w = spectrum_offset( t );\n\
				sumw += w;\n\
				sumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\n\
			}\n\
			gl_FragColor = sumcol / sumw;\n\
		}";

	LiteGraph.registerNodeType("texture/lensfx", LGraphLensFX);


	function LGraphTextureFromData() {
		this.addInput("in", "");
		this.properties = { precision: LGraphTexture.LOW, width: 0, height: 0, channels: 1 };
		this.addOutput("out", "Texture");
	}

	LGraphTextureFromData.title = "Data->Tex";
	LGraphTextureFromData.desc = "Generates or applies a curve to a texture";
	LGraphTextureFromData.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureFromData.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var data = this.getInputData(0);
		if(!data)
			return;

		var channels = this.properties.channels;
		var w = this.properties.width;
		var h = this.properties.height;
		if(!w || !h)
		{
			w = Math.floor(data.length / channels);
			h = 1;
		}
		var format = gl.RGBA;
		if( channels == 3 )
			format = gl.RGB;
		else if( channels == 1 )
			format = gl.LUMINANCE;

		var temp = this._temp_texture;
		var type = LGraphTexture.getTextureType( this.properties.precision );
		if ( !temp || temp.width != w || temp.height != h || temp.type != type ) {
			temp = this._temp_texture = new GL.Texture( w, h, { type: type, format: format, filter: gl.LINEAR } );
		}

		temp.uploadData( data );
		this.setOutputData(0, temp);
	}

	LiteGraph.registerNodeType("texture/fromdata", LGraphTextureFromData);

	//applies a curve (or generates one)
	function LGraphTextureCurve() {
		this.addInput("in", "Texture");
		this.addOutput("out", "Texture");
		this.properties = { precision: LGraphTexture.LOW, split_channels: false };
		this._values = new Uint8Array(256*4);
		this._values.fill(255);
		this._curve_texture = null;
		this._uniforms = { u_texture: 0, u_curve: 1, u_range: 1.0 };
		this._must_update = true;
		this._points = {
			RGB: [[0,0],[1,1]],
			R: [[0,0],[1,1]],
			G: [[0,0],[1,1]],
			B: [[0,0],[1,1]]
		};
		this.curve_editor = null;
		this.addWidget("toggle","Split Channels",false,"split_channels");
		this.addWidget("combo","Channel","RGB",{ values:["RGB","R","G","B"]});
		this.curve_offset = 68;
		this.size = [ 240, 160 ];
	}

	LGraphTextureCurve.title = "Curve";
	LGraphTextureCurve.desc = "Generates or applies a curve to a texture";
	LGraphTextureCurve.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureCurve.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		var temp = this._temp_texture;
		if(!tex) //generate one texture, nothing else
		{
			if(this._must_update || !this._curve_texture )
				this.updateCurve();
			this.setOutputData(0, this._curve_texture);
			return;
		}

		var type = LGraphTexture.getTextureType( this.properties.precision, tex );
		
		//apply curve to input texture
		if ( !temp || temp.type != type || temp.width != tex.width || temp.height != tex.height || temp.format != tex.format)
			temp = this._temp_texture = new GL.Texture( tex.width, tex.height, { type: type, format: tex.format, filter: gl.LINEAR } );

		var shader = LGraphTextureCurve._shader;
		if (!shader) {
			shader = LGraphTextureCurve._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureCurve.pixel_shader );
		}

		if(this._must_update || !this._curve_texture )
			this.updateCurve();

		var uniforms = this._uniforms;
		var curve_texture = this._curve_texture;

		//apply shader
		temp.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			tex.bind(0);
			curve_texture.bind(1);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	}

	LGraphTextureCurve.prototype.sampleCurve = function(f,points)
	{
		var points = points || this._points.RGB;
		if(!points)
			return;
		for(var i = 0; i < points.length - 1; ++i)
		{
			var p = points[i];
			var pn = points[i+1];
			if(pn[0] < f)
				continue;
			var r = (pn[0] - p[0]);
			if( Math.abs(r) < 0.00001 )
				return p[1];
			var local_f = (f - p[0]) / r;
			return p[1] * (1.0 - local_f) + pn[1] * local_f;
		}
		return 0;
	}

	LGraphTextureCurve.prototype.updateCurve = function()
	{
		var values = this._values;
		var num = values.length / 4;
		var split = this.properties.split_channels;
		for(var i = 0; i < num; ++i)
		{
			if(split)
			{
				values[i*4] = Math.clamp( this.sampleCurve(i/num,this._points.R)*255,0,255);
				values[i*4+1] = Math.clamp( this.sampleCurve(i/num,this._points.G)*255,0,255);
				values[i*4+2] = Math.clamp( this.sampleCurve(i/num,this._points.B)*255,0,255);
			}
			else
			{
				var v = this.sampleCurve(i/num);//sample curve
				values[i*4] = values[i*4+1] = values[i*4+2] = Math.clamp(v*255,0,255);
			}
			values[i*4+3] = 255; //alpha fixed
		}
		if(!this._curve_texture)
			this._curve_texture = new GL.Texture(256,1,{ format: gl.RGBA, magFilter: gl.LINEAR, wrap: gl.CLAMP_TO_EDGE });
		this._curve_texture.uploadData(values,null,true);
	}

	LGraphTextureCurve.prototype.onSerialize = function(o)
	{
		var curves = {};
		for(var i in this._points)
			curves[i] = this._points[i].concat();
		o.curves = curves;
	}

	LGraphTextureCurve.prototype.onConfigure = function(o)
	{
		this._points = o.curves;
		if(this.curve_editor)
			curve_editor.points = this._points;
		this._must_update = true;
	}

	LGraphTextureCurve.prototype.onMouseDown = function(e, localpos, graphcanvas)
	{
		if(this.curve_editor)
		{
			var r = this.curve_editor.onMouseDown([localpos[0],localpos[1]-this.curve_offset], graphcanvas);
			if(r)
				this.captureInput(true);
			return r;
		}
	}

	LGraphTextureCurve.prototype.onMouseMove = function(e, localpos, graphcanvas)
	{
		if(this.curve_editor)
			return this.curve_editor.onMouseMove([localpos[0],localpos[1]-this.curve_offset], graphcanvas);
	}

	LGraphTextureCurve.prototype.onMouseUp = function(e, localpos, graphcanvas)
	{
		if(this.curve_editor)
			return this.curve_editor.onMouseUp([localpos[0],localpos[1]-this.curve_offset], graphcanvas);
		this.captureInput(false);
	}

	LGraphTextureCurve.channel_line_colors = { "RGB":"#666","R":"#F33","G":"#3F3","B":"#33F" };

	LGraphTextureCurve.prototype.onDrawBackground = function(ctx, graphcanvas)
	{
		if(this.flags.collapsed)
			return;

		if(!this.curve_editor)
			this.curve_editor = new LiteGraph.CurveEditor(this._points.R);
		ctx.save();
		ctx.translate(0,this.curve_offset);
		var channel = this.widgets[1].value;

		if(this.properties.split_channels)
		{
			if(channel == "RGB")
			{
				this.widgets[1].value = channel = "R";
				this.widgets[1].disabled = false;
			}
			this.curve_editor.points = this._points.R;
			this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, "#111", LGraphTextureCurve.channel_line_colors.R, true );
			ctx.globalCompositeOperation = "lighten";
			this.curve_editor.points = this._points.G;
			this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, null, LGraphTextureCurve.channel_line_colors.G, true );
			this.curve_editor.points = this._points.B;
			this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, null, LGraphTextureCurve.channel_line_colors.B, true );
			ctx.globalCompositeOperation = "source-over";
		}
		else
		{
			this.widgets[1].value = channel = "RGB";
			this.widgets[1].disabled = true;
		}

		this.curve_editor.points = this._points[channel];
		this.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, this.properties.split_channels ? null : "#111", LGraphTextureCurve.channel_line_colors[channel]  );
		ctx.restore();
	}

	LGraphTextureCurve.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform sampler2D u_curve;\n\
		uniform float u_range;\n\
		\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord ) * u_range;\n\
			color.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;\n\
			color.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;\n\
			color.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;\n\
			//color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;\n\
			gl_FragColor = color;\n\
		}";

	LiteGraph.registerNodeType("texture/curve", LGraphTextureCurve);

	//simple exposition, but plan to expand it to support different gamma curves
	function LGraphExposition() {
		this.addInput("in", "Texture");
		this.addInput("exp", "number");
		this.addOutput("out", "Texture");
		this.properties = { exposition: 1, precision: LGraphTexture.LOW };
		this._uniforms = { u_texture: 0, u_exposition: 1 };
	}

	LGraphExposition.title = "Exposition";
	LGraphExposition.desc = "Controls texture exposition";

	LGraphExposition.widgets_info = {
		exposition: { widget: "slider", min: 0, max: 3 },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphExposition.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var temp = this._temp_texture;
		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			temp = this._temp_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		var shader = LGraphExposition._shader;
		if (!shader) {
			shader = LGraphExposition._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphExposition.pixel_shader
			);
		}

		var exp = this.properties.exposition;
		var exp_input = this.getInputData(1);
		if (exp_input != null) {
			exp = this.properties.exposition = exp_input;
		}
		var uniforms = this._uniforms;

		//apply shader
		temp.drawTo(function() {
			gl.disable(gl.DEPTH_TEST);
			tex.bind(0);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	};

	LGraphExposition.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_exposition;\n\
		\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord );\n\
			gl_FragColor = vec4( color.xyz * u_exposition, color.a );\n\
		}";

	LiteGraph.registerNodeType("texture/exposition", LGraphExposition);

	function LGraphToneMapping() {
		this.addInput("in", "Texture");
		this.addInput("avg", "number,Texture");
		this.addOutput("out", "Texture");
		this.properties = {
			enabled: true,
			scale: 1,
			gamma: 1,
			average_lum: 1,
			lum_white: 1,
			precision: LGraphTexture.LOW
		};

		this._uniforms = {
			u_texture: 0,
			u_lumwhite2: 1,
			u_igamma: 1,
			u_scale: 1,
			u_average_lum: 1
		};
	}

	LGraphToneMapping.title = "Tone Mapping";
	LGraphToneMapping.desc =
		"Applies Tone Mapping to convert from high to low";

	LGraphToneMapping.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphToneMapping.prototype.onGetInputs = function() {
		return [["enabled", "boolean"]];
	};

	LGraphToneMapping.prototype.onExecute = function() {
		var tex = this.getInputData(0);
		if (!tex) {
			return;
		}

		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		if (
			this.properties.precision === LGraphTexture.PASS_THROUGH ||
			this.getInputOrProperty("enabled") === false
		) {
			this.setOutputData(0, tex);
			return;
		}

		var temp = this._temp_texture;

		if (
			!temp ||
			temp.width != tex.width ||
			temp.height != tex.height ||
			temp.type != tex.type
		) {
			temp = this._temp_texture = new GL.Texture(
				tex.width,
				tex.height,
				{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }
			);
		}

		var avg = this.getInputData(1);
		if (avg == null) {
			avg = this.properties.average_lum;
		}

		var uniforms = this._uniforms;
		var shader = null;

		if (avg.constructor === Number) {
			this.properties.average_lum = avg;
			uniforms.u_average_lum = this.properties.average_lum;
			shader = LGraphToneMapping._shader;
			if (!shader) {
				shader = LGraphToneMapping._shader = new GL.Shader(
					GL.Shader.SCREEN_VERTEX_SHADER,
					LGraphToneMapping.pixel_shader
				);
			}
		} else if (avg.constructor === GL.Texture) {
			uniforms.u_average_texture = avg.bind(1);
			shader = LGraphToneMapping._shader_texture;
			if (!shader) {
				shader = LGraphToneMapping._shader_texture = new GL.Shader(
					GL.Shader.SCREEN_VERTEX_SHADER,
					LGraphToneMapping.pixel_shader,
					{ AVG_TEXTURE: "" }
				);
			}
		}

		uniforms.u_lumwhite2 =
			this.properties.lum_white * this.properties.lum_white;
		uniforms.u_scale = this.properties.scale;
		uniforms.u_igamma = 1 / this.properties.gamma;

		//apply shader
		gl.disable(gl.DEPTH_TEST);
		temp.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, this._temp_texture);
	};

	LGraphToneMapping.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform float u_scale;\n\
		#ifdef AVG_TEXTURE\n\
			uniform sampler2D u_average_texture;\n\
		#else\n\
			uniform float u_average_lum;\n\
		#endif\n\
		uniform float u_lumwhite2;\n\
		uniform float u_igamma;\n\
		vec3 RGB2xyY (vec3 rgb)\n\
		{\n\
			 const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\n\
									   0.2126, 0.7152, 0.0722,\n\
									   0.0193, 0.1192, 0.9505);\n\
			vec3 XYZ = RGB2XYZ * rgb;\n\
			\n\
			float f = (XYZ.x + XYZ.y + XYZ.z);\n\
			return vec3(XYZ.x / f,\n\
						XYZ.y / f,\n\
						XYZ.y);\n\
		}\n\
		\n\
		void main() {\n\
			vec4 color = texture2D( u_texture, v_coord );\n\
			vec3 rgb = color.xyz;\n\
			float average_lum = 0.0;\n\
			#ifdef AVG_TEXTURE\n\
				vec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;\n\
				average_lum = (pixel.x + pixel.y + pixel.z) / 3.0;\n\
			#else\n\
				average_lum = u_average_lum;\n\
			#endif\n\
			//Ld - this part of the code is the same for both versions\n\
			float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n\
			float L = (u_scale / average_lum) * lum;\n\
			float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\n\
			//first\n\
			//vec3 xyY = RGB2xyY(rgb);\n\
			//xyY.z *= Ld;\n\
			//rgb = xyYtoRGB(xyY);\n\
			//second\n\
			rgb = (rgb / lum) * Ld;\n\
			rgb = max(rgb,vec3(0.001));\n\
			rgb = pow( rgb, vec3( u_igamma ) );\n\
			gl_FragColor = vec4( rgb, color.a );\n\
		}";

	LiteGraph.registerNodeType("texture/tonemapping", LGraphToneMapping);

	function LGraphTexturePerlin() {
		this.addOutput("out", "Texture");
		this.properties = {
			width: 512,
			height: 512,
			seed: 0,
			persistence: 0.1,
			octaves: 8,
			scale: 1,
			offset: [0, 0],
			amplitude: 1,
			precision: LGraphTexture.DEFAULT
		};
		this._key = 0;
		this._texture = null;
		this._uniforms = {
			u_persistence: 0.1,
			u_seed: 0,
			u_offset: vec2.create(),
			u_scale: 1,
			u_viewport: vec2.create()
		};
	}

	LGraphTexturePerlin.title = "Perlin";
	LGraphTexturePerlin.desc = "Generates a perlin noise texture";

	LGraphTexturePerlin.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
		width: { type: "number", precision: 0, step: 1 },
		height: { type: "number", precision: 0, step: 1 },
		octaves: { type: "number", precision: 0, step: 1, min: 1, max: 50 }
	};

	LGraphTexturePerlin.prototype.onGetInputs = function() {
		return [
			["seed", "number"],
			["persistence", "number"],
			["octaves", "number"],
			["scale", "number"],
			["amplitude", "number"],
			["offset", "vec2"]
		];
	};

	LGraphTexturePerlin.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var w = this.properties.width | 0;
		var h = this.properties.height | 0;
		if (w == 0) {
			w = gl.viewport_data[2];
		} //0 means default
		if (h == 0) {
			h = gl.viewport_data[3];
		} //0 means default
		var type = LGraphTexture.getTextureType(this.properties.precision);

		var temp = this._texture;
		if (
			!temp ||
			temp.width != w ||
			temp.height != h ||
			temp.type != type
		) {
			temp = this._texture = new GL.Texture(w, h, {
				type: type,
				format: gl.RGB,
				filter: gl.LINEAR
			});
		}

		var persistence = this.getInputOrProperty("persistence");
		var octaves = this.getInputOrProperty("octaves");
		var offset = this.getInputOrProperty("offset");
		var scale = this.getInputOrProperty("scale");
		var amplitude = this.getInputOrProperty("amplitude");
		var seed = this.getInputOrProperty("seed");

		//reusing old texture
		var key =
			"" +
			w +
			h +
			type +
			persistence +
			octaves +
			scale +
			seed +
			offset[0] +
			offset[1] +
			amplitude;
		if (key == this._key) {
			this.setOutputData(0, temp);
			return;
		}
		this._key = key;

		//gather uniforms
		var uniforms = this._uniforms;
		uniforms.u_persistence = persistence;
		uniforms.u_octaves = octaves;
		uniforms.u_offset.set(offset);
		uniforms.u_scale = scale;
		uniforms.u_amplitude = amplitude;
		uniforms.u_seed = seed * 128;
		uniforms.u_viewport[0] = w;
		uniforms.u_viewport[1] = h;

		//render
		var shader = LGraphTexturePerlin._shader;
		if (!shader) {
			shader = LGraphTexturePerlin._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTexturePerlin.pixel_shader
			);
		}

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		temp.drawTo(function() {
			shader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());
		});

		this.setOutputData(0, temp);
	};

	LGraphTexturePerlin.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform vec2 u_offset;\n\
		uniform float u_scale;\n\
		uniform float u_persistence;\n\
		uniform int u_octaves;\n\
		uniform float u_amplitude;\n\
		uniform vec2 u_viewport;\n\
		uniform float u_seed;\n\
		#define M_PI 3.14159265358979323846\n\
		\n\
		float rand(vec2 c){	return fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\n\
		\n\
		float noise(vec2 p, float freq ){\n\
			float unit = u_viewport.x/freq;\n\
			vec2 ij = floor(p/unit);\n\
			vec2 xy = mod(p,unit)/unit;\n\
			//xy = 3.*xy*xy-2.*xy*xy*xy;\n\
			xy = .5*(1.-cos(M_PI*xy));\n\
			float a = rand((ij+vec2(0.,0.)));\n\
			float b = rand((ij+vec2(1.,0.)));\n\
			float c = rand((ij+vec2(0.,1.)));\n\
			float d = rand((ij+vec2(1.,1.)));\n\
			float x1 = mix(a, b, xy.x);\n\
			float x2 = mix(c, d, xy.x);\n\
			return mix(x1, x2, xy.y);\n\
		}\n\
		\n\
		float pNoise(vec2 p, int res){\n\
			float persistance = u_persistence;\n\
			float n = 0.;\n\
			float normK = 0.;\n\
			float f = 4.;\n\
			float amp = 1.0;\n\
			int iCount = 0;\n\
			for (int i = 0; i<50; i++){\n\
				n+=amp*noise(p, f);\n\
				f*=2.;\n\
				normK+=amp;\n\
				amp*=persistance;\n\
				if (iCount >= res)\n\
					break;\n\
				iCount++;\n\
			}\n\
			float nf = n/normK;\n\
			return nf*nf*nf*nf;\n\
		}\n\
		void main() {\n\
			vec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\n\
			vec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\n\
			gl_FragColor = color;\n\
		}";

	LiteGraph.registerNodeType("texture/perlin", LGraphTexturePerlin);

	function LGraphTextureCanvas2D() {
		this.addInput("v");
		this.addOutput("out", "Texture");
		this.properties = {
			code: LGraphTextureCanvas2D.default_code,
			width: 512,
			height: 512,
			clear: true,
			precision: LGraphTexture.DEFAULT,
			use_html_canvas: false
		};
		this._func = null;
		this._temp_texture = null;
		this.compileCode();
	}

	LGraphTextureCanvas2D.title = "Canvas2D";
	LGraphTextureCanvas2D.desc = "Executes Canvas2D code inside a texture or the viewport.";
	LGraphTextureCanvas2D.help = "Set width and height to 0 to match viewport size.";

	LGraphTextureCanvas2D.default_code = "//vars: canvas,ctx,time\nctx.fillStyle='red';\nctx.fillRect(0,0,50,50);\n";

	LGraphTextureCanvas2D.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
		code: { type: "code" },
		width: { type: "number", precision: 0, step: 1 },
		height: { type: "number", precision: 0, step: 1 }
	};

	LGraphTextureCanvas2D.prototype.onPropertyChanged = function( name, value ) {
		if (name == "code" )
			this.compileCode( value );
	}
	
	LGraphTextureCanvas2D.prototype.compileCode = function( code ) {
		this._func = null;
		if( !LiteGraph.allow_scripts )
			return;

		try {
			this._func = new Function( "canvas", "ctx", "time", "script","v", code );
			this.boxcolor = "#00FF00";
		} catch (err) {
			this.boxcolor = "#FF0000";
			console.error("Error parsing script");
			console.error(err);
		}
	};

	LGraphTextureCanvas2D.prototype.onExecute = function() {
		var func = this._func;
		if (!func || !this.isOutputConnected(0)) {
			return;
		}
		this.executeDraw( func );
	}

	LGraphTextureCanvas2D.prototype.executeDraw = function( func_context ) {

		var width = this.properties.width || gl.canvas.width;
		var height = this.properties.height || gl.canvas.height;
		var temp = this._temp_texture;
		var type = LGraphTexture.getTextureType( this.properties.precision );
		if (!temp || temp.width != width || temp.height != height || temp.type != type ) {
			temp = this._temp_texture = new GL.Texture(width, height, {
				format: gl.RGBA,
				filter: gl.LINEAR,
				type: type
			});
		}

		var v = this.getInputData(0);

		var properties = this.properties;
		var that = this;
		var time = this.graph.getTime();
		var ctx = gl;
		var canvas = gl.canvas;
		if( this.properties.use_html_canvas || !global.enableWebGLCanvas )
		{
			if(!this._canvas)
			{
				canvas = this._canvas = createCanvas(width.height);
				ctx = this._ctx = canvas.getContext("2d");
			}
			else
			{
				canvas = this._canvas;
				ctx = this._ctx;
			}
			canvas.width = width;
			canvas.height = height;
		}

		if(ctx == gl) //using Canvas2DtoWebGL
			temp.drawTo(function() {
				gl.start2D();
				if(properties.clear)
				{
					gl.clearColor(0,0,0,0);
					gl.clear( gl.COLOR_BUFFER_BIT );
				}

				try {
					if (func_context.draw) {
						func_context.draw.call(that, canvas, ctx, time, func_context, v);
					} else {
						func_context.call(that, canvas, ctx, time, func_context,v);
					}
					that.boxcolor = "#00FF00";
				} catch (err) {
					that.boxcolor = "#FF0000";
					console.error("Error executing script");
					console.error(err);
				}
				gl.finish2D();
			});
		else //rendering to offscren canvas and uploading to texture
		{
			if(properties.clear)
				ctx.clearRect(0,0,canvas.width,canvas.height);

			try {
				if (func_context.draw) {
					func_context.draw.call(this, canvas, ctx, time, func_context, v);
				} else {
					func_context.call(this, canvas, ctx, time, func_context,v);
				}
				this.boxcolor = "#00FF00";
			} catch (err) {
				this.boxcolor = "#FF0000";
				console.error("Error executing script");
				console.error(err);
			}
			temp.uploadImage( canvas );
		}

		this.setOutputData(0, temp);
	};

	LiteGraph.registerNodeType("texture/canvas2D", LGraphTextureCanvas2D);

	// To do chroma keying *****************

	function LGraphTextureMatte() {
		this.addInput("in", "Texture");

		this.addOutput("out", "Texture");
		this.properties = {
			key_color: vec3.fromValues(0, 1, 0),
			threshold: 0.8,
			slope: 0.2,
			precision: LGraphTexture.DEFAULT
		};
	}

	LGraphTextureMatte.title = "Matte";
	LGraphTextureMatte.desc = "Extracts background";

	LGraphTextureMatte.widgets_info = {
		key_color: { widget: "color" },
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphTextureMatte.prototype.onExecute = function() {
		if (!this.isOutputConnected(0)) {
			return;
		} //saves work

		var tex = this.getInputData(0);

		if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
			this.setOutputData(0, tex);
			return;
		}

		if (!tex) {
			return;
		}

		this._tex = LGraphTexture.getTargetTexture(
			tex,
			this._tex,
			this.properties.precision
		);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);

		if (!this._uniforms) {
			this._uniforms = {
				u_texture: 0,
				u_key_color: this.properties.key_color,
				u_threshold: 1,
				u_slope: 1
			};
		}
		var uniforms = this._uniforms;

		var mesh = Mesh.getScreenQuad();
		var shader = LGraphTextureMatte._shader;
		if (!shader) {
			shader = LGraphTextureMatte._shader = new GL.Shader(
				GL.Shader.SCREEN_VERTEX_SHADER,
				LGraphTextureMatte.pixel_shader
			);
		}

		uniforms.u_key_color = this.properties.key_color;
		uniforms.u_threshold = this.properties.threshold;
		uniforms.u_slope = this.properties.slope;

		this._tex.drawTo(function() {
			tex.bind(0);
			shader.uniforms(uniforms).draw(mesh);
		});

		this.setOutputData(0, this._tex);
	};

	LGraphTextureMatte.pixel_shader =
		"precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		uniform vec3 u_key_color;\n\
		uniform float u_threshold;\n\
		uniform float u_slope;\n\
		\n\
		void main() {\n\
			vec3 color = texture2D( u_texture, v_coord ).xyz;\n\
			float diff = length( normalize(color) - normalize(u_key_color) );\n\
			float edge = u_threshold * (1.0 - u_slope);\n\
			float alpha = smoothstep( edge, u_threshold, diff);\n\
			gl_FragColor = vec4( color, alpha );\n\
		}";

	LiteGraph.registerNodeType("texture/matte", LGraphTextureMatte);

	//***********************************
	function LGraphCubemapToTexture2D() {
		this.addInput("in", "texture");
		this.addInput("yaw", "number");
		this.addOutput("out", "texture");
		this.properties = { yaw: 0 };
	}

	LGraphCubemapToTexture2D.title = "CubemapToTexture2D";
	LGraphCubemapToTexture2D.desc = "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation";

	LGraphCubemapToTexture2D.prototype.onExecute = function() {
		if (!this.isOutputConnected(0))
			return;

		var tex = this.getInputData(0);
		if ( !tex || tex.texture_type != GL.TEXTURE_CUBE_MAP )
			return;
		if( this._last_tex && ( this._last_tex.height != tex.height || this._last_tex.type != tex.type ))
			this._last_tex = null;
		var yaw = this.getInputOrProperty("yaw");
		this._last_tex = GL.Texture.cubemapToTexture2D( tex, tex.height, this._last_tex, true, yaw );
		this.setOutputData( 0, this._last_tex );
	};

	LiteGraph.registerNodeType( "texture/cubemapToTexture2D", LGraphCubemapToTexture2D );
})(this);

(function(global) {

    if (typeof GL == "undefined")
		return;

    var LiteGraph = global.LiteGraph;
	var LGraphCanvas = global.LGraphCanvas;

	var SHADERNODES_COLOR = "#345";

	var LGShaders = LiteGraph.Shaders = {};

	var GLSL_types = LGShaders.GLSL_types = ["float","vec2","vec3","vec4","mat3","mat4","sampler2D","samplerCube"];
	var GLSL_types_const = LGShaders.GLSL_types_const = ["float","vec2","vec3","vec4"];

	var GLSL_functions_desc = {
		"radians": "T radians(T degrees)",
		"degrees": "T degrees(T radians)",
		"sin": "T sin(T angle)",
		"cos": "T cos(T angle)",
		"tan": "T tan(T angle)",
		"asin": "T asin(T x)",
		"acos": "T acos(T x)",
		"atan": "T atan(T x)",
		"atan2": "T atan(T x,T y)",
		"pow": "T pow(T x,T y)",
		"exp": "T exp(T x)",
		"log": "T log(T x)",
		"exp2": "T exp2(T x)",
		"log2": "T log2(T x)",
		"sqrt": "T sqrt(T x)",
		"inversesqrt": "T inversesqrt(T x)",
		"abs": "T abs(T x)",
		"sign": "T sign(T x)",
		"floor": "T floor(T x)",
		"round": "T round(T x)",
		"ceil": "T ceil(T x)",
		"fract": "T fract(T x)",
		"mod": "T mod(T x,T y)", //"T mod(T x,float y)"
		"min": "T min(T x,T y)",
		"max": "T max(T x,T y)",
		"clamp": "T clamp(T x,T minVal = 0.0,T maxVal = 1.0)",
		"mix": "T mix(T x,T y,T a)", //"T mix(T x,T y,float a)"
		"step": "T step(T edge, T edge2, T x)", //"T step(float edge, T x)"
		"smoothstep": "T smoothstep(T edge, T edge2, T x)", //"T smoothstep(float edge, T x)"
		"length":"float length(T x)",
		"distance":"float distance(T p0, T p1)",
		"normalize":"T normalize(T x)",
		"dot": "float dot(T x,T y)",
		"cross": "vec3 cross(vec3 x,vec3 y)",
		"reflect": "vec3 reflect(vec3 V,vec3 N)",
		"refract": "vec3 refract(vec3 V,vec3 N, float IOR)"
	};

	//parse them
	var GLSL_functions = {};
	var GLSL_functions_name = [];
	parseGLSLDescriptions();

	LGShaders.ALL_TYPES = "float,vec2,vec3,vec4";

	function parseGLSLDescriptions()
	{
		GLSL_functions_name.length = 0;

		for(var i in GLSL_functions_desc)
		{
			var op = GLSL_functions_desc[i];
			var index = op.indexOf(" ");
			var return_type = op.substr(0,index);
			var index2 = op.indexOf("(",index);
			var func_name = op.substr(index,index2-index).trim();
			var params = op.substr(index2 + 1, op.length - index2 - 2).split(",");
			for(var j in params)
			{
				var p = params[j].split(" ").filter(function(a){ return a; });
				params[j] = { type: p[0].trim(), name: p[1].trim() };
				if(p[2] == "=")
					params[j].value = p[3].trim();
			}
			GLSL_functions[i] = { return_type: return_type, func: func_name, params: params };
			GLSL_functions_name.push( func_name );
			//console.log( GLSL_functions[i] );
		}
	}

	//common actions to all shader node classes
	function registerShaderNode( type, node_ctor )
	{
		//static attributes
		node_ctor.color = SHADERNODES_COLOR;
		node_ctor.filter = "shader";

		//common methods
		node_ctor.prototype.clearDestination = function(){ this.shader_destination = {};  }
		node_ctor.prototype.propagateDestination = function propagateDestination( dest_name )
		{
			this.shader_destination[ dest_name ] = true;
			if(this.inputs)
			for(var i = 0; i < this.inputs.length; ++i)
			{
				var origin_node = this.getInputNode(i);
				if(origin_node)
					origin_node.propagateDestination( dest_name );
			}
		}
		if(!node_ctor.prototype.onPropertyChanged)
			node_ctor.prototype.onPropertyChanged = function()
			{
				if(this.graph)
					 this.graph._version++;
			}

		/*
		if(!node_ctor.prototype.onGetCode)
			node_ctor.prototype.onGetCode = function()
			{
				//check destination to avoid lonely nodes
				if(!this.shader_destination)
					return;
				//grab inputs with types
				var inputs = [];
				if(this.inputs)
				for(var i = 0; i < this.inputs.length; ++i)
					inputs.push({ type: this.getInputData(i), name: getInputLinkID(this,i) });
				var outputs = [];
				if(this.outputs)
				for(var i = 0; i < this.outputs.length; ++i)
					outputs.push({ name: getOutputLinkID(this,i) });
				//pass to code func
				var results = this.extractCode(inputs);
				//grab output, pass to next
				if(results)
				for(var i = 0; i < results.length; ++i)
				{
					var r = results[i];
					if(!r)
						continue;
					this.setOutputData(i,r.value);
				}
			}
		*/

		LiteGraph.registerNodeType( "shader::" + type, node_ctor );
	}

	function getShaderNodeVarName( node, name )
	{
		return "VAR_" + (name || "TEMP") + "_" + node.id;
	}

	function getInputLinkID( node, slot )
	{
		if(!node.inputs)
			return null;
		var link = node.getInputLink( slot );
		if( !link )
			return null;
		var origin_node = node.graph.getNodeById( link.origin_id );
		if( !origin_node )
			return null;
		if(origin_node.getOutputVarName)
			return origin_node.getOutputVarName(link.origin_slot);
		//generate
		return "link_" + origin_node.id + "_" + link.origin_slot;
	}

	function getOutputLinkID( node, slot )
	{
		if (!node.isOutputConnected(slot))
			return null;
		return "link_" + node.id + "_" + slot;
	}

	LGShaders.registerShaderNode = registerShaderNode;
	LGShaders.getInputLinkID = getInputLinkID;
	LGShaders.getOutputLinkID = getOutputLinkID;
	LGShaders.getShaderNodeVarName = getShaderNodeVarName;
	LGShaders.parseGLSLDescriptions = parseGLSLDescriptions;

	//given a const number, it transform it to a string that matches a type
	var valueToGLSL = LiteGraph.valueToGLSL = function valueToGLSL( v, type, precision )
	{
		var n = 5; //num decimals
		if(precision != null)
			n = precision;
		if(!type)
		{
			if(v.constructor === Number)
				type = "float";
			else if(v.length)
			{
				switch(v.length)
				{
					case 2: type = "vec2"; break;
					case 3: type = "vec3"; break;
					case 4: type = "vec4"; break;
					case 9: type = "mat3"; break;
					case 16: type = "mat4"; break;
					default:
						throw("unknown type for glsl value size");
				}
			}
			else
				throw("unknown type for glsl value: " + v.constructor);
		}
		switch(type)
		{
			case 'float': return v.toFixed(n); break;
			case 'vec2': return "vec2(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + ")"; break;
			case 'color3':
			case 'vec3': return "vec3(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + "," + v[2].toFixed(n) + ")"; break;
			case 'color4':
			case 'vec4': return "vec4(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + "," + v[2].toFixed(n) + "," + v[3].toFixed(n) + ")"; break;
			case 'mat3': return "mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)"; break; //not fully supported yet
			case 'mat4': return "mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0)"; break;//not fully supported yet
			default:
				throw("unknown glsl type in valueToGLSL:", type);
		}

		return "";
	}

	//makes sure that a var is of a type, and if not, it converts it
	var varToTypeGLSL = LiteGraph.varToTypeGLSL = function varToTypeGLSL( v, input_type, output_type )
	{
		if(input_type == output_type)
			return v;
		if(v == null)
			switch(output_type)
			{
				case "float": return "0.0";
				case "vec2":  return "vec2(0.0)";
				case "vec3":  return "vec3(0.0)";
				case "vec4":  return "vec4(0.0,0.0,0.0,1.0)";
				default: //null
					return null;
			}

		if(!output_type)
			throw("error: no output type specified");
		if(output_type == "float")
		{
			switch(input_type)
			{
				//case "float":
				case "vec2":
				case "vec3":
				case "vec4":
					return v + ".x";
					break;
				default: //null
					return "0.0";
					break;
			}
		}
		else if(output_type == "vec2")
		{
			switch(input_type)
			{
				case "float":
					return "vec2("+v+")";
				//case "vec2":
				case "vec3":
				case "vec4":
					return v + ".xy";
				default: //null
					return "vec2(0.0)";
			}
		}
		else if(output_type == "vec3")
		{
			switch(input_type)
			{
				case "float":
					return "vec3("+v+")";
				case "vec2":
					return "vec3(" + v + ",0.0)";
				//case "vec3":
				case "vec4":
					return v + ".xyz";
				default: //null
					return "vec3(0.0)";
			}
		}
		else if(output_type == "vec4")
		{
			switch(input_type)
			{
				case "float":
					return "vec4("+v+")";
				case "vec2":
					return "vec4(" + v + ",0.0,1.0)";
				case "vec3":
					return "vec4(" + v + ",1.0)";
				default: //null
					return "vec4(0.0,0.0,0.0,1.0)";
			}
		}
		throw("type cannot be converted");
	}


	//used to plug incompatible stuff
	var convertVarToGLSLType = LiteGraph.convertVarToGLSLType = function convertVarToGLSLType( varname, type, target_type )
	{
		if(type == target_type)
			return varname;
		if(type == "float")
			return target_type + "(" + varname + ")";
		if(target_type == "vec2") //works for vec2,vec3 and vec4
			return "vec2(" + varname + ".xy)";
		if(target_type == "vec3") //works for vec2,vec3 and vec4
		{
			if(type == "vec2")
				return "vec3(" + varname + ",0.0)";
			if(type == "vec4")
				return "vec4(" + varname + ".xyz)";
		}
		if(target_type == "vec4")
		{
			if(type == "vec2")
				return "vec4(" + varname + ",0.0,0.0)";
			if(target_type == "vec3")
				return "vec4(" + varname + ",1.0)";
		}
		return null;
	}

	//used to host a shader body **************************************
	function LGShaderContext()
	{
		//to store the code template
		this.vs_template = "";
		this.fs_template = "";

		//required so nodes now where to fetch the input data
		this.buffer_names = {
			uvs: "v_coord"
		};

		this.extra = {}; //to store custom info from the nodes (like if this shader supports a feature, etc)

		this._functions = {};
		this._uniforms = {};
		this._codeparts = {};
		this._uniform_value = null;
	}

	LGShaderContext.prototype.clear = function()
	{
		this._uniforms = {};
		this._functions = {};
		this._codeparts = {};
		this._uniform_value = null;

		this.extra = {};
	}

	LGShaderContext.prototype.addUniform = function( name, type, value )
	{
		this._uniforms[ name ] = type;
		if(value != null)
		{
			if(!this._uniform_value)
				this._uniform_value = {};
			this._uniform_value[name] = value;
		}
	}

	LGShaderContext.prototype.addFunction = function( name, code )
	{
		this._functions[name] = code;
	}

	LGShaderContext.prototype.addCode = function( hook, code, destinations )
	{
		destinations = destinations || {"":""};
		for(var i in destinations)
		{
			var h = i ? i + "_" + hook : hook;
			if(!this._codeparts[ h ])
				this._codeparts[ h ] = code + "\n";
			else
				this._codeparts[ h ] += code + "\n";
		}
	}

	//the system works by grabbing code fragments from every node and concatenating them in blocks depending on where must they be attached
	LGShaderContext.prototype.computeCodeBlocks = function( graph, extra_uniforms )
	{
		//prepare context
		this.clear();

		//grab output nodes
		var vertexout = graph.findNodesByType("shader::output/vertex");
		vertexout = vertexout && vertexout.length ? vertexout[0] : null;
		var fragmentout = graph.findNodesByType("shader::output/fragcolor");
		fragmentout = fragmentout && fragmentout.length ? fragmentout[0] : null;
		if(!fragmentout) //??
			return null; 

		//propagate back destinations
		graph.sendEventToAllNodes( "clearDestination" );
		if(vertexout)
			vertexout.propagateDestination("vs");
		if(fragmentout)
			fragmentout.propagateDestination("fs");

		//gets code from graph
		graph.sendEventToAllNodes("onGetCode", this );

		var uniforms = "";
		for(var i in this._uniforms)
			uniforms += "uniform " + this._uniforms[i] + " " + i + ";\n";
		if(extra_uniforms)
			for(var i in extra_uniforms)
				uniforms += "uniform " + extra_uniforms[i] + " " + i + ";\n";

		var functions = "";
		for(var i in this._functions)
			functions += "//" + i + "\n" + this._functions[i] + "\n";

		var blocks = this._codeparts;
		blocks.uniforms = uniforms;
		blocks.functions = functions;
		return blocks;
	}

	//replaces blocks using the vs and fs template and returns the final codes
	LGShaderContext.prototype.computeShaderCode = function( graph )
	{
		var blocks = this.computeCodeBlocks( graph );
		var vs_code = GL.Shader.replaceCodeUsingContext( this.vs_template, blocks );
		var fs_code = GL.Shader.replaceCodeUsingContext( this.fs_template, blocks );
		return {
			vs_code: vs_code,
			fs_code: fs_code
		};
	}

	//generates the shader code from the template and the 
	LGShaderContext.prototype.computeShader = function( graph, shader )
	{
		var finalcode = this.computeShaderCode( graph );
		console.log( finalcode.vs_code, finalcode.fs_code );

		if(!LiteGraph.catch_exceptions)
		{
			this._shader_error = true;
			if(shader)
				shader.updateShader( finalcode.vs_code, finalcode.fs_code );
			else
				shader = new GL.Shader( finalcode.vs_code, finalcode.fs_code );
			this._shader_error = false;
			return shader;
		}

		try
		{
			if(shader)
				shader.updateShader( finalcode.vs_code, finalcode.fs_code );
			else
				shader = new GL.Shader( finalcode.vs_code, finalcode.fs_code );
			this._shader_error = false;
			return shader;
		}
		catch (err)
		{
			if(!this._shader_error)
			{
				console.error(err);
				if(err.indexOf("Fragment shader") != -1)
					console.log( finalcode.fs_code.split("\n").map(function(v,i){ return i + ".- " + v; }).join("\n") );
				else
					console.log( finalcode.vs_code );
			}
			this._shader_error = true;
			return null;
		}

		return null;//never here
	}

	LGShaderContext.prototype.getShader = function( graph )
	{
		//if graph not changed?
		if(this._shader && this._shader._version == graph._version)
			return this._shader;

		//compile shader
		var shader = this.computeShader( graph, this._shader );
		if(!shader)
			return null;
		
		this._shader = shader;
		shader._version = graph._version;
		return shader;
	}

	//some shader nodes could require to fill the box with some uniforms
	LGShaderContext.prototype.fillUniforms = function( uniforms, param )
	{
		if(!this._uniform_value)
			return;

		for(var i in this._uniform_value)
		{
			var v = this._uniform_value[i];
			if(v == null)
				continue;
			if(v.constructor === Function)
				uniforms[i] = v.call( this, param );
			else if(v.constructor === GL.Texture)
			{
				//todo...
			}
			else
				uniforms[i] = v;
		}
	}

	LiteGraph.ShaderContext = LiteGraph.Shaders.Context = LGShaderContext;

	// LGraphShaderGraph *****************************
	// applies a shader graph to texture, it can be uses as an example

	function LGraphShaderGraph() {

		//before inputs
        this.subgraph = new LiteGraph.LGraph();
        this.subgraph._subgraph_node = this;
        this.subgraph._is_subgraph = true;
		this.subgraph.filter = "shader";

		this.addInput("in", "texture");
		this.addOutput("out", "texture");
		this.properties = { width: 0, height: 0, alpha: false, precision: typeof(LGraphTexture) != "undefined" ? LGraphTexture.DEFAULT : 2 };

		var inputNode = this.subgraph.findNodesByType("shader::input/uniform")[0];
		inputNode.pos = [200,300];

		var sampler = LiteGraph.createNode("shader::texture/sampler2D");
		sampler.pos = [400,300];
		this.subgraph.add( sampler );

		var outnode = LiteGraph.createNode("shader::output/fragcolor");
		outnode.pos = [600,300];
		this.subgraph.add( outnode );

		inputNode.connect( 0, sampler );
		sampler.connect( 0, outnode );

		this.size = [180,60];
		this.redraw_on_mouse = true; //force redraw

		this._uniforms = {};
		this._shader = null;
		this._context = new LGShaderContext();
		this._context.vs_template = "#define VERTEX\n" + GL.Shader.SCREEN_VERTEX_SHADER;
		this._context.fs_template = LGraphShaderGraph.template;
	}

	LGraphShaderGraph.template = "\n\
#define FRAGMENT\n\
precision highp float;\n\
varying vec2 v_coord;\n\
{{varying}}\n\
{{uniforms}}\n\
{{functions}}\n\
{{fs_functions}}\n\
void main() {\n\n\
vec2 uv = v_coord;\n\
vec4 fragcolor = vec4(0.0);\n\
vec4 fragcolor1 = vec4(0.0);\n\
{{fs_code}}\n\
gl_FragColor = fragcolor;\n\
}\n\
	";

	LGraphShaderGraph.widgets_info = {
		precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
	};

	LGraphShaderGraph.title = "ShaderGraph";
	LGraphShaderGraph.desc = "Builds a shader using a graph";
	LGraphShaderGraph.input_node_type = "input/uniform";
	LGraphShaderGraph.output_node_type = "output/fragcolor";
	LGraphShaderGraph.title_color = SHADERNODES_COLOR;

	LGraphShaderGraph.prototype.onSerialize = function(o)
	{
		o.subgraph = this.subgraph.serialize();
	}

	LGraphShaderGraph.prototype.onConfigure = function(o)
	{
		this.subgraph.configure(o.subgraph);
	}

	LGraphShaderGraph.prototype.onExecute = function() {
		if (!this.isOutputConnected(0))
			return;

		//read input texture
		var intex = this.getInputData(0);
		if(intex && intex.constructor != GL.Texture)
			intex = null;

		var w = this.properties.width | 0;
		var h = this.properties.height | 0;
		if (w == 0) {
			w = intex ? intex.width : gl.viewport_data[2];
		} //0 means default
		if (h == 0) {
			h = intex ? intex.height : gl.viewport_data[3];
		} //0 means default

		var type = LGraphTexture.getTextureType( this.properties.precision, intex );

		var texture = this._texture;
		if ( !texture || texture.width != w || texture.height != h || texture.type != type ) {
			texture = this._texture = new GL.Texture(w, h, {
				type: type,
				format: this.alpha ? gl.RGBA : gl.RGB,
				filter: gl.LINEAR
			});
		}
		
		var shader = this.getShader( this.subgraph );
		if(!shader)
			return;

		var uniforms = this._uniforms;
		this._context.fillUniforms( uniforms );

		var tex_slot = 0;
		if(this.inputs)
		for(var i = 0; i < this.inputs.length; ++i)
		{
			var input = this.inputs[i];
			var data = this.getInputData(i);
			if(input.type == "texture")
			{
				if(!data)
					data = GL.Texture.getWhiteTexture();
				data = data.bind(tex_slot++);
			}

			if(data != null)
				uniforms[ "u_" + input.name ] = data;
		}

		var mesh = GL.Mesh.getScreenQuad();

		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.BLEND );

		texture.drawTo(function(){
			shader.uniforms( uniforms );
			shader.draw( mesh );
		});

		//use subgraph output 
		this.setOutputData(0, texture );
	};

	//add input node inside subgraph
	LGraphShaderGraph.prototype.onInputAdded = function( slot_info )
	{
		var subnode = LiteGraph.createNode("shader::input/uniform");
		subnode.setProperty("name",slot_info.name);
		subnode.setProperty("type",slot_info.type);
		this.subgraph.add( subnode );
	}

	//remove all
	LGraphShaderGraph.prototype.onInputRemoved = function( slot, slot_info )
	{
		var nodes = this.subgraph.findNodesByType("shader::input/uniform");
		for(var i = 0; i < nodes.length; ++i)
		{
			var node = nodes[i];
			if(node.properties.name == slot_info.name )
				this.subgraph.remove( node );
		}
	}

	LGraphShaderGraph.prototype.computeSize = function()
	{
		var num_inputs = this.inputs ? this.inputs.length : 0;
		var num_outputs = this.outputs ? this.outputs.length : 0;
		return [ 200, Math.max(num_inputs,num_outputs) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT + 10];
	}

	LGraphShaderGraph.prototype.getShader = function()
	{
		var shader = this._context.getShader( this.subgraph );
		if(!shader)
			this.boxcolor = "red";
		else
			this.boxcolor = null;
		return shader;
	}

	LGraphShaderGraph.prototype.onDrawBackground = function(ctx, graphcanvas, canvas, pos)
	{
		if(this.flags.collapsed)
			return;

		//allows to preview the node if the canvas is a webgl canvas
		var tex = this.getOutputData(0);
		var inputs_y = this.inputs ? this.inputs.length * LiteGraph.NODE_SLOT_HEIGHT : 0;
		if (tex && ctx == tex.gl && this.size[1] > inputs_y + LiteGraph.NODE_TITLE_HEIGHT ) {
			ctx.drawImage( tex, 10,y, this.size[0] - 20, this.size[1] - inputs_y - LiteGraph.NODE_TITLE_HEIGHT );
		}

		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;

		//button
		var over = LiteGraph.isInsideRectangle(pos[0],pos[1],this.pos[0],this.pos[1] + y,this.size[0],LiteGraph.NODE_TITLE_HEIGHT);
		ctx.fillStyle = over ? "#555" : "#222";
		ctx.beginPath();
		if (this._shape == LiteGraph.BOX_SHAPE)
			ctx.rect(0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT);
		else
			ctx.roundRect( 0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT, 0, 8);
		ctx.fill();

		//button
		ctx.textAlign = "center";
		ctx.font = "24px Arial";
		ctx.fillStyle = over ? "#DDD" : "#999";
		ctx.fillText( "+", this.size[0] * 0.5, y + 24 );
	}

	LGraphShaderGraph.prototype.onMouseDown = function(e, localpos, graphcanvas)
	{
		var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
		if(localpos[1] > y)
		{
			graphcanvas.showSubgraphPropertiesDialog(this);
		}
	}

	LGraphShaderGraph.prototype.onDrawSubgraphBackground = function(graphcanvas)
	{
		//TODO
	}

	LGraphShaderGraph.prototype.getExtraMenuOptions = function(graphcanvas)
	{
		var that = this;
		var options = [{ content: "Print Code", callback: function(){
			var code = that._context.computeShaderCode();
			console.log( code.vs_code, code.fs_code );
		}}];

		return options;
	}

	LiteGraph.registerNodeType( "texture/shaderGraph", LGraphShaderGraph );

	function shaderNodeFromFunction( classname, params, return_type, code )
	{
		//TODO
	}

	//Shader Nodes ***********************************************************

	//applies a shader graph to a code
	function LGraphShaderUniform() {
		this.addOutput("out", "");
		this.properties = { name: "", type: "" };
	}

	LGraphShaderUniform.title = "Uniform";
	LGraphShaderUniform.desc = "Input data for the shader";

	LGraphShaderUniform.prototype.getTitle = function()
	{
		if( this.properties.name && this.flags.collapsed)
			return this.properties.type + " " + this.properties.name;
		return "Uniform";
	}

	LGraphShaderUniform.prototype.onPropertyChanged = function(name,value)
	{
		this.outputs[0].name = this.properties.type + " " + this.properties.name;
	}

	LGraphShaderUniform.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var type = this.properties.type;
		if( !type )
		{
			if( !context.onGetPropertyInfo )
				return;
			var info = context.onGetPropertyInfo( this.property.name );
			if(!info)
				return;
			type = info.type;
		}
		if(type == "number")
			type = "float";
		else if(type == "texture")
			type = "sampler2D";
		if ( LGShaders.GLSL_types.indexOf(type) == -1 )
			return;

		context.addUniform( "u_" + this.properties.name, type );
		this.setOutputData( 0, type );
	}

	LGraphShaderUniform.prototype.getOutputVarName = function(slot)
	{
		return "u_" + this.properties.name;
	}

	registerShaderNode( "input/uniform", LGraphShaderUniform );


	function LGraphShaderAttribute() {
		this.addOutput("out", "vec2");
		this.properties = { name: "coord", type: "vec2" };
	}

	LGraphShaderAttribute.title = "Attribute";
	LGraphShaderAttribute.desc = "Input data from mesh attribute";

	LGraphShaderAttribute.prototype.getTitle = function()
	{
		return "att. " + this.properties.name;
	}

	LGraphShaderAttribute.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var type = this.properties.type;
		if( !type || LGShaders.GLSL_types.indexOf(type) == -1 )
			return;
		if(type == "number")
			type = "float";
		if( this.properties.name != "coord")
		{
			context.addCode( "varying", " varying " + type +" v_" + this.properties.name + ";" );
			//if( !context.varyings[ this.properties.name ] )
			//context.addCode( "vs_code", "v_" + this.properties.name + " = " + input_name + ";" );
		}
		this.setOutputData( 0, type );
	}

	LGraphShaderAttribute.prototype.getOutputVarName = function(slot)
	{
		return "v_" + this.properties.name;
	}

	registerShaderNode( "input/attribute", LGraphShaderAttribute );

	function LGraphShaderSampler2D() {
		this.addInput("tex", "sampler2D");
		this.addInput("uv", "vec2");
		this.addOutput("rgba", "vec4");
		this.addOutput("rgb", "vec3");
	}

	LGraphShaderSampler2D.title = "Sampler2D";
	LGraphShaderSampler2D.desc = "Reads a pixel from a texture";

	LGraphShaderSampler2D.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var texname = getInputLinkID( this, 0 );
		var varname = getShaderNodeVarName(this);
		var code = "vec4 " + varname + " = vec4(0.0);\n";
		if(texname)
		{
			var uvname = getInputLinkID( this, 1 ) || context.buffer_names.uvs;
			code += varname + " = texture2D("+texname+","+uvname+");\n";
		}

		var link0 = getOutputLinkID( this, 0 );
		if(link0)
			code += "vec4 " + getOutputLinkID( this, 0 ) + " = "+varname+";\n";

		var link1 = getOutputLinkID( this, 1 );
		if(link1)
			code += "vec3 " + getOutputLinkID( this, 1 ) + " = "+varname+".xyz;\n";

		context.addCode( "code", code, this.shader_destination );
		this.setOutputData( 0, "vec4" );
		this.setOutputData( 1, "vec3" );
	}

	registerShaderNode( "texture/sampler2D", LGraphShaderSampler2D );

	//*********************************

	function LGraphShaderConstant()
	{
		this.addOutput("","float");

		this.properties = {
			type: "float",
			value: 0
		};

		this.addWidget("combo","type","float",null, { values: GLSL_types_const, property: "type" } );
		this.updateWidgets();
	}

	LGraphShaderConstant.title = "const";

	LGraphShaderConstant.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return valueToGLSL( this.properties.value, this.properties.type, 2 );
		return "Const";
	}

	LGraphShaderConstant.prototype.onPropertyChanged = function(name,value)
	{
		var that = this;
		if(name == "type")
		{
			if(this.outputs[0].type != value)
			{
				this.disconnectOutput(0);
				this.outputs[0].type = value;
			}
			this.widgets.length = 1; //remove extra widgets
			this.updateWidgets();
		}
		if(name == "value")
		{
			if(!value.length)
				this.widgets[1].value = value;
			else
			{
				this.widgets[1].value = value[1];
				if(value.length > 2)
					this.widgets[2].value = value[2];
				if(value.length > 3)
					this.widgets[3].value = value[3];
			}
		}
	}

	LGraphShaderConstant.prototype.updateWidgets = function( old_value )
	{
		var that = this;
		var old_value = this.properties.value;
		var options = { step: 0.01 };
		switch(this.properties.type)
		{
			case 'float': 
				this.properties.value = 0;
				this.addWidget("number","v",0,{ step:0.01, property: "value" });
				break;
			case 'vec2': 
				this.properties.value = old_value && old_value.length == 2 ? [old_value[0],old_value[1]] : [0,0,0];
				this.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); 
				this.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); 
				break;
			case 'vec3': 
				this.properties.value = old_value && old_value.length == 3 ? [old_value[0],old_value[1],old_value[2]] : [0,0,0];
				this.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); 
				this.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); 
				this.addWidget("number","z",this.properties.value[2], function(v){ that.properties.value[2] = v; },options); 
				break;
			case 'vec4': 
				this.properties.value = old_value && old_value.length == 4 ? [old_value[0],old_value[1],old_value[2],old_value[3]] : [0,0,0,0];
				this.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); 
				this.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); 
				this.addWidget("number","z",this.properties.value[2], function(v){ that.properties.value[2] = v; },options); 
				this.addWidget("number","w",this.properties.value[3], function(v){ that.properties.value[3] = v; },options); 
				break;
			default:
				console.error("unknown type for constant");
		}
	}

	LGraphShaderConstant.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var value = valueToGLSL( this.properties.value, this.properties.type );
		var link_name = getOutputLinkID(this,0);
		if(!link_name) //not connected
			return;

		var code = "	" + this.properties.type + " " + link_name + " = " + value + ";";
		context.addCode( "code", code, this.shader_destination );

		this.setOutputData( 0, this.properties.type );
	}

	registerShaderNode( "const/const", LGraphShaderConstant );

	function LGraphShaderVec2()
	{
		this.addInput("xy","vec2");
		this.addInput("x","float");
		this.addInput("y","float");
		this.addOutput("xy","vec2");
		this.addOutput("x","float");
		this.addOutput("y","float");

		this.properties = { x: 0, y: 0 };
	}

	LGraphShaderVec2.title = "vec2";
	LGraphShaderVec2.varmodes = ["xy","x","y"];

	LGraphShaderVec2.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			 this.graph._version++;
	}

	LGraphShaderVec2.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var props = this.properties;

		var varname = getShaderNodeVarName(this);
		var code = "	vec2 " + varname + " = " + valueToGLSL([props.x,props.y]) + ";\n";

		for(var i = 0;i < LGraphShaderVec2.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec2.varmodes[i];
			var inlink = getInputLinkID(this,i);
			if(!inlink)
				continue;
			code += "	" + varname + "."+varmode+" = " + inlink + ";\n";
		}

		for(var i = 0;i < LGraphShaderVec2.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec2.varmodes[i];
			var outlink = getOutputLinkID(this,i);
			if(!outlink)
				continue;
			var type = GLSL_types_const[varmode.length - 1];
			code += "	"+type+" " + outlink + " = " + varname + "." + varmode + ";\n";
			this.setOutputData( i, type );
		}

		context.addCode( "code", code, this.shader_destination );
	}

	registerShaderNode( "const/vec2", LGraphShaderVec2 );	

	function LGraphShaderVec3()
	{
		this.addInput("xyz","vec3");
		this.addInput("x","float");
		this.addInput("y","float");
		this.addInput("z","float");
		this.addInput("xy","vec2");
		this.addInput("xz","vec2");
		this.addInput("yz","vec2");
		this.addOutput("xyz","vec3");
		this.addOutput("x","float");
		this.addOutput("y","float");
		this.addOutput("z","float");
		this.addOutput("xy","vec2");
		this.addOutput("xz","vec2");
		this.addOutput("yz","vec2");

		this.properties = { x:0, y: 0, z: 0 };
	}

	LGraphShaderVec3.title = "vec3";
	LGraphShaderVec3.varmodes = ["xyz","x","y","z","xy","xz","yz"];

	LGraphShaderVec3.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			this.graph._version++;
	}

	LGraphShaderVec3.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var props = this.properties;

		var varname = getShaderNodeVarName(this);
		var code = "vec3 " + varname + " = " + valueToGLSL([props.x,props.y,props.z]) + ";\n";

		for(var i = 0;i < LGraphShaderVec3.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec3.varmodes[i];
			var inlink = getInputLinkID(this,i);
			if(!inlink)
				continue;
			code += "	" + varname + "."+varmode+" = " + inlink + ";\n";
		}

		for(var i = 0; i < LGraphShaderVec3.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec3.varmodes[i];
			var outlink = getOutputLinkID(this,i);
			if(!outlink)
				continue;
			var type = GLSL_types_const[varmode.length - 1];
			code += "	"+type+" " + outlink + " = " + varname + "." + varmode + ";\n";
			this.setOutputData( i, type );
		}

		context.addCode( "code", code, this.shader_destination );
	}

	registerShaderNode( "const/vec3", LGraphShaderVec3 );	


	function LGraphShaderVec4()
	{
		this.addInput("xyzw","vec4");
		this.addInput("xyz","vec3");
		this.addInput("x","float");
		this.addInput("y","float");
		this.addInput("z","float");
		this.addInput("w","float");
		this.addInput("xy","vec2");
		this.addInput("yz","vec2");
		this.addInput("zw","vec2");
		this.addOutput("xyzw","vec4");
		this.addOutput("xyz","vec3");
		this.addOutput("x","float");
		this.addOutput("y","float");
		this.addOutput("z","float");
		this.addOutput("xy","vec2");
		this.addOutput("yz","vec2");
		this.addOutput("zw","vec2");

		this.properties = { x:0, y: 0, z: 0, w: 0 };
	}

	LGraphShaderVec4.title = "vec4";
	LGraphShaderVec4.varmodes = ["xyzw","xyz","x","y","z","w","xy","yz","zw"];

	LGraphShaderVec4.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			this.graph._version++;
	}

	LGraphShaderVec4.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		var props = this.properties;

		var varname = getShaderNodeVarName(this);
		var code = "vec4 " + varname + " = " + valueToGLSL([props.x,props.y,props.z,props.w]) + ";\n";

		for(var i = 0;i < LGraphShaderVec4.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec4.varmodes[i];
			var inlink = getInputLinkID(this,i);
			if(!inlink)
				continue;
			code += "	" + varname + "."+varmode+" = " + inlink + ";\n";
		}

		for(var i = 0;i < LGraphShaderVec4.varmodes.length; ++i)
		{
			var varmode = LGraphShaderVec4.varmodes[i];
			var outlink = getOutputLinkID(this,i);
			if(!outlink)
				continue;
			var type = GLSL_types_const[varmode.length - 1];
			code += "	"+type+" " + outlink + " = " + varname + "." + varmode + ";\n";
			this.setOutputData( i, type );
		}

		context.addCode( "code", code, this.shader_destination );

	}

	registerShaderNode( "const/vec4", LGraphShaderVec4 );	
	
	//*********************************

	function LGraphShaderFragColor() {
		this.addInput("color", LGShaders.ALL_TYPES );
		this.block_delete = true;
	}

	LGraphShaderFragColor.title = "FragColor";
	LGraphShaderFragColor.desc = "Pixel final color";

	LGraphShaderFragColor.prototype.onGetCode = function( context )
	{
		var link_name = getInputLinkID( this, 0 );
		if(!link_name)
			return;
		var type = this.getInputData(0);
		var code = varToTypeGLSL( link_name, type, "vec4" );
		context.addCode("fs_code", "fragcolor = " + code + ";");
	}

	registerShaderNode( "output/fragcolor", LGraphShaderFragColor );


	/*
	function LGraphShaderDiscard()
	{
		this.addInput("v","T");
		this.addInput("min","T");
		this.properties = { min_value: 0.0 };
		this.addWidget("number","min",0,{ step: 0.01, property: "min_value" });
	}

	LGraphShaderDiscard.title = "Discard";

	LGraphShaderDiscard.prototype.onGetCode = function( context )
	{
		if(!this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var inlink1 = getInputLinkID(this,1);

		if(!inlink && !inlink1) //not connected
			return;
		context.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "output/discard", LGraphShaderDiscard );
	*/


	// *************************************************

	function LGraphShaderOperation()
	{
		this.addInput("A", LGShaders.ALL_TYPES );
		this.addInput("B", LGShaders.ALL_TYPES );
		this.addOutput("out","");
		this.properties = {
			operation: "*"
		};
		this.addWidget("combo","op.",this.properties.operation,{ property: "operation", values: LGraphShaderOperation.operations });
	}

	LGraphShaderOperation.title = "Operation";
	LGraphShaderOperation.operations = ["+","-","*","/"];

	LGraphShaderOperation.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return "A" + this.properties.operation + "B";
		else
			return "Operation";
	}

	LGraphShaderOperation.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		if(!this.isOutputConnected(0))
			return;

		var inlinks = [];
		for(var i = 0; i < 3; ++i)
			inlinks.push( { name: getInputLinkID(this,i), type: this.getInputData(i) || "float" } );

		var outlink = getOutputLinkID(this,0);
		if(!outlink) //not connected
			return;

		//func_desc
		var base_type = inlinks[0].type;
		var return_type = base_type;
		var op = this.properties.operation;

		var params = [];
		for(var i = 0; i < 2; ++i)
		{
			var param_code = inlinks[i].name;
			if(param_code == null) //not plugged
			{
				param_code = p.value != null ? p.value : "(1.0)";
				inlinks[i].type = "float";
			}

			//convert
			if( inlinks[i].type != base_type ) 
			{
				if( inlinks[i].type == "float" && (op == "*" || op == "/") )
				{
					//I find hard to create the opposite condition now, so I prefeer an else
				}
				else
					param_code = convertVarToGLSLType( param_code, inlinks[i].type, base_type );
			}
			params.push( param_code );
		}
		
		context.addCode("code", return_type + " " + outlink + " = "+ params[0] + op + params[1] + ";", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "math/operation", LGraphShaderOperation );


	function LGraphShaderFunc()
	{
		this.addInput("A", LGShaders.ALL_TYPES );
		this.addInput("B", LGShaders.ALL_TYPES );
		this.addOutput("out","");
		this.properties = {
			func: "floor"
		};
		this._current = "floor";
		this.addWidget("combo","func",this.properties.func,{ property: "func", values: GLSL_functions_name });
	}

	LGraphShaderFunc.title = "Func";

	LGraphShaderFunc.prototype.onPropertyChanged = function(name,value)
	{
		if(this.graph)
			this.graph._version++;

		if(name == "func")
		{
			var func_desc = GLSL_functions[ value ];
			if(!func_desc)
				return;

			//remove extra inputs
			for(var i = func_desc.params.length; i < this.inputs.length; ++i)
				this.removeInput(i);

			//add and update inputs
			for(var i = 0; i < func_desc.params.length; ++i)
			{
				var p = func_desc.params[i];
				if( this.inputs[i] )
					this.inputs[i].name = p.name + (p.value ? " (" + p.value + ")" : "");
				else
					this.addInput( p.name, LGShaders.ALL_TYPES );
			}
		}
	}

	LGraphShaderFunc.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return this.properties.func;
		else
			return "Func";
	}

	LGraphShaderFunc.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination)
			return;

		if(!this.isOutputConnected(0))
			return;

		var inlinks = [];
		for(var i = 0; i < 3; ++i)
			inlinks.push( { name: getInputLinkID(this,i), type: this.getInputData(i) || "float" } );

		var outlink = getOutputLinkID(this,0);
		if(!outlink) //not connected
			return;

		var func_desc = GLSL_functions[ this.properties.func ];
		if(!func_desc)
			return;

		//func_desc
		var base_type = inlinks[0].type;
		var return_type = func_desc.return_type;
		if( return_type == "T" )
			return_type = base_type;

		var params = [];
		for(var i = 0; i < func_desc.params.length; ++i)
		{
			var p = func_desc.params[i];
			var param_code = inlinks[i].name;
			if(param_code == null) //not plugged
			{
				param_code = p.value != null ? p.value : "(1.0)";
				inlinks[i].type = "float";
			}
			if( (p.type == "T" && inlinks[i].type != base_type) ||
				(p.type != "T" && inlinks[i].type != base_type) )
				param_code = convertVarToGLSLType( param_code, inlinks[i].type, base_type );
			params.push( param_code );
		}
		
		context.addFunction("round","float round(float v){ return floor(v+0.5); }\nvec2 round(vec2 v){ return floor(v+vec2(0.5));}\nvec3 round(vec3 v){ return floor(v+vec3(0.5));}\nvec4 round(vec4 v){ return floor(v+vec4(0.5)); }\n");
		context.addCode("code", return_type + " " + outlink + " = "+func_desc.func+"("+params.join(",")+");", this.shader_destination );

		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "math/func", LGraphShaderFunc );



	function LGraphShaderSnippet()
	{
		this.addInput("A", LGShaders.ALL_TYPES );
		this.addInput("B", LGShaders.ALL_TYPES );
		this.addOutput("C","vec4");
		this.properties = {
			code:"C = A+B",
			type: "vec4"
		}
		this.addWidget("text","code",this.properties.code,{ property: "code" });
		this.addWidget("combo","type",this.properties.type,{ values:["float","vec2","vec3","vec4"], property: "type" });
	}

	LGraphShaderSnippet.title = "Snippet";

	LGraphShaderSnippet.prototype.onPropertyChanged = function(name,value)
	{
		if(this.graph)
			this.graph._version++;

		if(name == "type"&& this.outputs[0].type != value)
		{
			this.disconnectOutput(0);
			this.outputs[0].type = value;
		}
	}

	LGraphShaderSnippet.prototype.getTitle = function()
	{
		if(this.flags.collapsed)
			return this.properties.code;
		else
			return "Snippet";
	}

	LGraphShaderSnippet.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlinkA = getInputLinkID(this,0);
		if(!inlinkA)
			inlinkA = "1.0";
		var inlinkB = getInputLinkID(this,1);
		if(!inlinkB)
			inlinkB = "1.0";
		var outlink = getOutputLinkID(this,0);
		if(!outlink) //not connected
			return;

		var inA_type = this.getInputData(0) || "float";
		var inB_type = this.getInputData(1) || "float";
		var return_type = this.properties.type;

		//cannot resolve input
		if(inA_type == "T" || inB_type == "T")
		{
			return null;
		}

		var funcname = "funcSnippet" + this.id;

		var func_code = "\n" + return_type + " " + funcname + "( " + inA_type + " A, " + inB_type + " B) {\n";
		func_code += "	" + return_type + " C = " + return_type + "(0.0);\n";
		func_code += "	" + this.properties.code + ";\n";
		func_code += "	return C;\n}\n";

		context.addCode("functions", func_code, this.shader_destination );
		context.addCode("code", return_type + " " + outlink + " = "+funcname+"("+inlinkA+","+inlinkB+");", this.shader_destination );

		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "utils/snippet", LGraphShaderSnippet );

	//************************************

	function LGraphShaderRand()
	{
		this.addOutput("out","float");
	}

	LGraphShaderRand.title = "Rand";

	LGraphShaderRand.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var outlink = getOutputLinkID(this,0);

		context.addUniform( "u_rand" + this.id, "float", function(){ return Math.random(); });
		context.addCode("code", "float " + outlink + " = u_rand" + this.id +";", this.shader_destination );
		this.setOutputData( 0, "float" );
	}

	registerShaderNode( "input/rand", LGraphShaderRand );

	//noise
	//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
	function LGraphShaderNoise()
	{
		this.addInput("out", LGShaders.ALL_TYPES );
		this.addInput("scale", "float" );
		this.addOutput("out","float");
		this.properties = {
			type: "noise",
			scale: 1
		};
		this.addWidget("combo","type", this.properties.type, { property: "type", values: LGraphShaderNoise.NOISE_TYPES });
		this.addWidget("number","scale", this.properties.scale, { property: "scale" });
	}

	LGraphShaderNoise.NOISE_TYPES = ["noise","rand"];

	LGraphShaderNoise.title = "noise";

	LGraphShaderNoise.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var outlink = getOutputLinkID(this,0);

		var intype = this.getInputData(0);
		if(!inlink)
		{
			intype = "vec2";
			inlink = context.buffer_names.uvs;
		}

		context.addFunction("noise",LGraphShaderNoise.shader_functions);
		context.addUniform( "u_noise_scale" + this.id, "float", this.properties.scale );
		if( intype == "float" )
			context.addCode("code", "float " + outlink + " = snoise( vec2(" + inlink +") * u_noise_scale" + this.id +");", this.shader_destination );
		else if( intype == "vec2" || intype == "vec3" )
			context.addCode("code", "float " + outlink + " = snoise(" + inlink +" * u_noise_scale" + this.id +");", this.shader_destination );
		else if( intype == "vec4" )
			context.addCode("code", "float " + outlink + " = snoise(" + inlink +".xyz * u_noise_scale" + this.id +");", this.shader_destination );
		this.setOutputData( 0, "float" );
	}

	registerShaderNode( "math/noise", LGraphShaderNoise );

LGraphShaderNoise.shader_functions = "\n\
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\
\n\
float snoise(vec2 v){\n\
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,-0.577350269189626, 0.024390243902439);\n\
  vec2 i  = floor(v + dot(v, C.yy) );\n\
  vec2 x0 = v -   i + dot(i, C.xx);\n\
  vec2 i1;\n\
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\
  vec4 x12 = x0.xyxy + C.xxzz;\n\
  x12.xy -= i1;\n\
  i = mod(i, 289.0);\n\
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\
  + i.x + vec3(0.0, i1.x, 1.0 ));\n\
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)), 0.0);\n\
  m = m*m ;\n\
  m = m*m ;\n\
  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n\
  vec3 h = abs(x) - 0.5;\n\
  vec3 ox = floor(x + 0.5);\n\
  vec3 a0 = x - ox;\n\
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\
  vec3 g;\n\
  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n\
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\
  return 130.0 * dot(m, g);\n\
}\n\
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\
\n\
float snoise(vec3 v){ \n\
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\
\n\
// First corner\n\
  vec3 i  = floor(v + dot(v, C.yyy) );\n\
  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\
\n\
// Other corners\n\
  vec3 g = step(x0.yzx, x0.xyz);\n\
  vec3 l = 1.0 - g;\n\
  vec3 i1 = min( g.xyz, l.zxy );\n\
  vec3 i2 = max( g.xyz, l.zxy );\n\
\n\
  //  x0 = x0 - 0. + 0.0 * C \n\
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n\
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n\
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\
\n\
// Permutations\n\
  i = mod(i, 289.0 ); \n\
  vec4 p = permute( permute( permute( \n\
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\
\n\
// Gradients\n\
// ( N*N points uniformly over a square, mapped onto an octahedron.)\n\
  float n_ = 1.0/7.0; // N=7\n\
  vec3  ns = n_ * D.wyz - D.xzx;\n\
\n\
  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\
\n\
  vec4 x_ = floor(j * ns.z);\n\
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\
\n\
  vec4 x = x_ *ns.x + ns.yyyy;\n\
  vec4 y = y_ *ns.x + ns.yyyy;\n\
  vec4 h = 1.0 - abs(x) - abs(y);\n\
\n\
  vec4 b0 = vec4( x.xy, y.xy );\n\
  vec4 b1 = vec4( x.zw, y.zw );\n\
\n\
  vec4 s0 = floor(b0)*2.0 + 1.0;\n\
  vec4 s1 = floor(b1)*2.0 + 1.0;\n\
  vec4 sh = -step(h, vec4(0.0));\n\
\n\
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\
\n\
  vec3 p0 = vec3(a0.xy,h.x);\n\
  vec3 p1 = vec3(a0.zw,h.y);\n\
  vec3 p2 = vec3(a1.xy,h.z);\n\
  vec3 p3 = vec3(a1.zw,h.w);\n\
\n\
//Normalise gradients\n\
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\
  p0 *= norm.x;\n\
  p1 *= norm.y;\n\
  p2 *= norm.z;\n\
  p3 *= norm.w;\n\
\n\
// Mix final noise value\n\
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\
  m = m * m;\n\
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n\
}\n\
\n\
vec3 hash3( vec2 p ){\n\
    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\
				   dot(p,vec2(269.5,183.3)), \n\
				   dot(p,vec2(419.2,371.9)) );\n\
	return fract(sin(q)*43758.5453);\n\
}\n\
vec4 hash4( vec3 p ){\n\
    vec4 q = vec4( dot(p,vec3(127.1,311.7,257.3)), \n\
				   dot(p,vec3(269.5,183.3,335.1)), \n\
				   dot(p,vec3(314.5,235.1,467.3)), \n\
				   dot(p,vec3(419.2,371.9,114.9)) );\n\
	return fract(sin(q)*43758.5453);\n\
}\n\
\n\
float iqnoise( in vec2 x, float u, float v ){\n\
    vec2 p = floor(x);\n\
    vec2 f = fract(x);\n\
	\n\
	float k = 1.0+63.0*pow(1.0-v,4.0);\n\
	\n\
	float va = 0.0;\n\
	float wt = 0.0;\n\
    for( int j=-2; j<=2; j++ )\n\
    for( int i=-2; i<=2; i++ )\n\
    {\n\
        vec2 g = vec2( float(i),float(j) );\n\
		vec3 o = hash3( p + g )*vec3(u,u,1.0);\n\
		vec2 r = g - f + o.xy;\n\
		float d = dot(r,r);\n\
		float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\
		va += o.z*ww;\n\
		wt += ww;\n\
    }\n\
	\n\
    return va/wt;\n\
}\n\
"

	function LGraphShaderTime()
	{
		this.addOutput("out","float");
	}

	LGraphShaderTime.title = "Time";

	LGraphShaderTime.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var outlink = getOutputLinkID(this,0);

		context.addUniform( "u_time" + this.id, "float", function(){ return getTime() * 0.001; });
		context.addCode("code", "float " + outlink + " = u_time" + this.id +";", this.shader_destination );
		this.setOutputData( 0, "float" );
	}

	registerShaderNode( "input/time", LGraphShaderTime );


	function LGraphShaderDither()
	{
		this.addInput("in","T");
		this.addOutput("out","float");
	}

	LGraphShaderDither.title = "Dither";

	LGraphShaderDither.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var return_type = "float";
		var outlink = getOutputLinkID(this,0);
		var intype = this.getInputData(0);
		inlink = varToTypeGLSL( inlink, intype, "float" );
		context.addFunction("dither8x8", LGraphShaderDither.dither_func);
		context.addCode("code", return_type + " " + outlink + " = dither8x8("+ inlink +");", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	LGraphShaderDither.dither_values = [0.515625,0.140625,0.640625,0.046875,0.546875,0.171875,0.671875,0.765625,0.265625,0.890625,0.390625,0.796875,0.296875,0.921875,0.421875,0.203125,0.703125,0.078125,0.578125,0.234375,0.734375,0.109375,0.609375,0.953125,0.453125,0.828125,0.328125,0.984375,0.484375,0.859375,0.359375,0.0625,0.5625,0.1875,0.6875,0.03125,0.53125,0.15625,0.65625,0.8125,0.3125,0.9375,0.4375,0.78125,0.28125,0.90625,0.40625,0.25,0.75,0.125,0.625,0.21875,0.71875,0.09375,0.59375,1.0001,0.5,0.875,0.375,0.96875,0.46875,0.84375,0.34375];
	
	LGraphShaderDither.dither_func = "\n\
		float dither8x8(float brightness) {\n\
		  vec2 position = vec2(0.0);\n\
		  #ifdef FRAGMENT\n\
			position = gl_FragCoord.xy;\n\
		  #endif\n\
		  int x = int(mod(position.x, 8.0));\n\
		  int y = int(mod(position.y, 8.0));\n\
		  int index = x + y * 8;\n\
		  float limit = 0.0;\n\
		  if (x < 8) {\n\
			if(index==0) limit = 0.015625;\n\
			"+(LGraphShaderDither.dither_values.map( function(v,i){ return "else if(index== "+(i+1)+") limit = " + v + ";"}).join("\n"))+"\n\
		  }\n\
		  return brightness < limit ? 0.0 : 1.0;\n\
		}\n",

	registerShaderNode( "math/dither", LGraphShaderDither );

	function LGraphShaderRemap()
	{
		this.addInput("", LGShaders.ALL_TYPES );
		this.addOutput("","");
		this.properties = {
			min_value: 0,
			max_value: 1,
			min_value2: 0,
			max_value2: 1
		};
		this.addWidget("number","min",0,{ step: 0.1, property: "min_value" });
		this.addWidget("number","max",1,{ step: 0.1, property: "max_value" });
		this.addWidget("number","min2",0,{ step: 0.1, property: "min_value2"});
		this.addWidget("number","max2",1,{ step: 0.1, property: "max_value2"});
	}

	LGraphShaderRemap.title = "Remap";

	LGraphShaderRemap.prototype.onPropertyChanged = function()
	{
		if(this.graph)
			this.graph._version++;
	}

	LGraphShaderRemap.prototype.onConnectionsChange = function()
	{
		var return_type = this.getInputDataType(0);
		this.outputs[0].type = return_type || "T";
	}

	LGraphShaderRemap.prototype.onGetCode = function( context )
	{
		if(!this.shader_destination || !this.isOutputConnected(0))
			return;

		var inlink = getInputLinkID(this,0);
		var outlink = getOutputLinkID(this,0);
		if(!inlink && !outlink) //not connected
			return;

		var return_type = this.getInputDataType(0);
		this.outputs[0].type = return_type;
		if(return_type == "T")
		{
			console.warn("node type is T and cannot be resolved");
			return;
		}

		if(!inlink)
		{
			context.addCode("code","	" + return_type + " " + outlink + " = " + return_type + "(0.0);\n");
			return;
		}

		var minv = valueToGLSL( this.properties.min_value );
		var maxv = valueToGLSL( this.properties.max_value );
		var minv2 = valueToGLSL( this.properties.min_value2 );
		var maxv2 = valueToGLSL( this.properties.max_value2 );

		context.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );
		this.setOutputData( 0, return_type );
	}

	registerShaderNode( "math/remap", LGraphShaderRemap );

})(this);



(function(global) {
    var LiteGraph = global.LiteGraph;

	var view_matrix = new Float32Array(16);
	var projection_matrix = new Float32Array(16);
	var viewprojection_matrix = new Float32Array(16);
	var model_matrix = new Float32Array(16);
	var global_uniforms = {
		u_view: view_matrix,
		u_projection: projection_matrix,
		u_viewprojection: viewprojection_matrix,
		u_model: model_matrix 
	};

	LiteGraph.LGraphRender = {
		onRequestCameraMatrices: null //overwrite with your 3D engine specifics, it will receive (view_matrix, projection_matrix,viewprojection_matrix) and must be filled
	};

	function generateGeometryId() {
		return (Math.random() * 100000)|0;
	}

	function LGraphPoints3D() {

		this.addInput("obj", "");
		this.addInput("radius", "number");

		this.addOutput("out", "geometry");
		this.addOutput("points", "[vec3]");
		this.properties = {
			radius: 1,
			num_points: 4096,
			generate_normals: true,
			regular: false,
			mode: LGraphPoints3D.SPHERE,
			force_update: false
		};

		this.points = new Float32Array( this.properties.num_points * 3 );
		this.normals = new Float32Array( this.properties.num_points * 3 );
		this.must_update = true;
		this.version = 0;

		var that = this;
		this.addWidget("button","update",null, function(){ that.must_update = true; });

		this.geometry = {
			vertices: null,
			_id: generateGeometryId()
		}

		this._old_obj = null;
		this._last_radius = null;
	}

	global.LGraphPoints3D = LGraphPoints3D;

	LGraphPoints3D.RECTANGLE = 1;
	LGraphPoints3D.CIRCLE = 2;

	LGraphPoints3D.CUBE = 10;
	LGraphPoints3D.SPHERE = 11;
	LGraphPoints3D.HEMISPHERE = 12;
	LGraphPoints3D.INSIDE_SPHERE = 13;

	LGraphPoints3D.OBJECT = 20;
	LGraphPoints3D.OBJECT_UNIFORMLY = 21;
	LGraphPoints3D.OBJECT_INSIDE = 22;

	LGraphPoints3D.MODE_VALUES = { "rectangle":LGraphPoints3D.RECTANGLE, "circle":LGraphPoints3D.CIRCLE, "cube":LGraphPoints3D.CUBE, "sphere":LGraphPoints3D.SPHERE, "hemisphere":LGraphPoints3D.HEMISPHERE, "inside_sphere":LGraphPoints3D.INSIDE_SPHERE, "object":LGraphPoints3D.OBJECT, "object_uniformly":LGraphPoints3D.OBJECT_UNIFORMLY, "object_inside":LGraphPoints3D.OBJECT_INSIDE };

	LGraphPoints3D.widgets_info = {
		mode: { widget: "combo", values: LGraphPoints3D.MODE_VALUES }
	};

	LGraphPoints3D.title = "list of points";
	LGraphPoints3D.desc = "returns an array of points";

	LGraphPoints3D.prototype.onPropertyChanged = function(name,value)
	{
		this.must_update = true;
	}

	LGraphPoints3D.prototype.onExecute = function() {

		var obj = this.getInputData(0);
		if( obj != this._old_obj || (obj && obj._version != this._old_obj_version) )
		{
			this._old_obj = obj;
			this.must_update = true;
		}

		var radius = this.getInputData(1);
		if(radius == null)
			radius = this.properties.radius;
		if( this._last_radius != radius )
		{
			this._last_radius = radius;
			this.must_update = true;
		}

		if(this.must_update || this.properties.force_update )
		{
			this.must_update = false;
			this.updatePoints();
		}

		this.geometry.vertices = this.points;
		this.geometry.normals = this.normals;
		this.geometry._version = this.version;

		this.setOutputData( 0, this.geometry );
	}

	LGraphPoints3D.prototype.updatePoints = function() {
		var num_points = this.properties.num_points|0;
		if(num_points < 1)
			num_points = 1;

		if(!this.points || this.points.length != num_points * 3)
			this.points = new Float32Array( num_points * 3 );

		if(this.properties.generate_normals)
		{
			if (!this.normals || this.normals.length != this.points.length)
				this.normals = new Float32Array( this.points.length );
		}
		else
			this.normals = null;

		var radius = this._last_radius || this.properties.radius;
		var mode = this.properties.mode;

		var obj = this.getInputData(0);
		this._old_obj_version = obj ? obj._version : null;

		this.points = LGraphPoints3D.generatePoints( radius, num_points, mode, this.points, this.normals, this.properties.regular, obj );

		this.version++;
	}

	//global
	LGraphPoints3D.generatePoints = function( radius, num_points, mode, points, normals, regular, obj )
	{
		var size = num_points * 3;
		if(!points || points.length != size)
			points = new Float32Array( size );
		var temp = new Float32Array(3);
		var UP = new Float32Array([0,1,0]);

		if(regular)
		{
			if( mode == LGraphPoints3D.RECTANGLE)
			{
				var side = Math.floor(Math.sqrt(num_points));
				for(var i = 0; i < side; ++i)
				for(var j = 0; j < side; ++j)
				{
					var pos = i*3 + j*3*side;
					points[pos] = ((i/side) - 0.5) * radius * 2;
					points[pos+1] = 0;
					points[pos+2] = ((j/side) - 0.5) * radius * 2;
				}
				points = new Float32Array( points.subarray(0,side*side*3) );
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
			else if( mode == LGraphPoints3D.SPHERE)
			{
				var side = Math.floor(Math.sqrt(num_points));
				for(var i = 0; i < side; ++i)
				for(var j = 0; j < side; ++j)
				{
					var pos = i*3 + j*3*side;
					polarToCartesian( temp, (i/side) * 2 * Math.PI, ((j/side) - 0.5) * 2 * Math.PI, radius );
					points[pos] = temp[0];
					points[pos+1] = temp[1];
					points[pos+2] = temp[2];
				}
				points = new Float32Array( points.subarray(0,side*side*3) );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.CIRCLE)
			{
				for(var i = 0; i < size; i+=3)
				{
					var angle = 2 * Math.PI * (i/size);
					points[i] = Math.cos( angle ) * radius;
					points[i+1] = 0;
					points[i+2] = Math.sin( angle ) * radius;
				}
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
		}
		else //non regular
		{
			if( mode == LGraphPoints3D.RECTANGLE)
			{
				for(var i = 0; i < size; i+=3)
				{
					points[i] = (Math.random() - 0.5) * radius * 2;
					points[i+1] = 0;
					points[i+2] = (Math.random() - 0.5) * radius * 2;
				}
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
			else if( mode == LGraphPoints3D.CUBE)
			{
				for(var i = 0; i < size; i+=3)
				{
					points[i] = (Math.random() - 0.5) * radius * 2;
					points[i+1] = (Math.random() - 0.5) * radius * 2;
					points[i+2] = (Math.random() - 0.5) * radius * 2;
				}
				if(normals)
				{
					for(var i = 0; i < normals.length; i+=3)
						normals.set(UP, i);
				}
			}
			else if( mode == LGraphPoints3D.SPHERE)
			{
				LGraphPoints3D.generateSphere( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.HEMISPHERE)
			{
				LGraphPoints3D.generateHemisphere( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.CIRCLE)
			{
				LGraphPoints3D.generateInsideCircle( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.INSIDE_SPHERE)
			{
				LGraphPoints3D.generateInsideSphere( points, size, radius );
				if(normals)
					LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else if( mode == LGraphPoints3D.OBJECT)
			{
				LGraphPoints3D.generateFromObject( points, normals, size, obj, false );
			}
			else if( mode == LGraphPoints3D.OBJECT_UNIFORMLY)
			{
				LGraphPoints3D.generateFromObject( points, normals, size, obj, true );
			}
			else if( mode == LGraphPoints3D.OBJECT_INSIDE)
			{
				LGraphPoints3D.generateFromInsideObject( points, size, obj );
				//if(normals)
				//	LGraphPoints3D.generateSphericalNormals( points, normals );
			}
			else
				console.warn("wrong mode in LGraphPoints3D");
		}

		return points;
	}

	LGraphPoints3D.generateSphericalNormals = function(points, normals)
	{
		var temp = new Float32Array(3);
		for(var i = 0; i < normals.length; i+=3)
		{
			temp[0] = points[i];
			temp[1] = points[i+1];
			temp[2] = points[i+2];
			vec3.normalize(temp,temp);
			normals.set(temp,i);
		}
	}

	LGraphPoints3D.generateSphere = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var r1 = Math.random();
			var r2 = Math.random();
			var x = 2 * Math.cos( 2 * Math.PI * r1 ) * Math.sqrt( r2 * (1-r2) );
			var y = 1 - 2 * r2;
			var z = 2 * Math.sin( 2 * Math.PI * r1 ) * Math.sqrt( r2 * (1-r2) );
			points[i] = x * radius;
			points[i+1] = y * radius;
			points[i+2] = z * radius;
		}			
	}

	LGraphPoints3D.generateHemisphere = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var r1 = Math.random();
			var r2 = Math.random();
			var x = Math.cos( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			var y = r2;
			var z = Math.sin( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			points[i] = x * radius;
			points[i+1] = y * radius;
			points[i+2] = z * radius;
		}
	}

	LGraphPoints3D.generateInsideCircle = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var r1 = Math.random();
			var r2 = Math.random();
			var x = Math.cos( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			var y = r2;
			var z = Math.sin( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );
			points[i] = x * radius;
			points[i+1] = 0;
			points[i+2] = z * radius;
		}
	}

	LGraphPoints3D.generateInsideSphere = function (points, size, radius)
	{
		for(var i = 0; i < size; i+=3)
		{
			var u = Math.random();
			var v = Math.random();
			var theta = u * 2.0 * Math.PI;
			var phi = Math.acos(2.0 * v - 1.0);
			var r = Math.cbrt(Math.random()) * radius;
			var sinTheta = Math.sin(theta);
			var cosTheta = Math.cos(theta);
			var sinPhi = Math.sin(phi);
			var cosPhi = Math.cos(phi);
			points[i] = r * sinPhi * cosTheta;
			points[i+1] = r * sinPhi * sinTheta;
			points[i+2] = r * cosPhi;
		}	
	}

	function findRandomTriangle( areas, f )
	{
		var l = areas.length;
		var imin = 0;
		var imid = 0;
		var imax = l;

		if(l == 0)
			return -1;
		if(l == 1)
			return 0;
		//dichotimic search
		while (imax >= imin)
		{
			imid = ((imax + imin)*0.5)|0;
			var t = areas[ imid ];
			if( t == f )
				return imid; 
			if( imin == (imax - 1) )
				return imin;
			if (t < f)
				imin = imid;
			else         
				imax = imid;
		}
		return imid;		
	}

	LGraphPoints3D.generateFromObject = function( points, normals, size, obj, evenly )
	{
		if(!obj)
			return;

		var vertices = null;
		var mesh_normals = null;
		var indices = null;
		var areas = null;
		if( obj.constructor === GL.Mesh )
		{
			vertices = obj.vertexBuffers.vertices.data;
			mesh_normals = obj.vertexBuffers.normals ? obj.vertexBuffers.normals.data : null;
			indices = obj.indexBuffers.indices ? obj.indexBuffers.indices.data : null;
			if(!indices)
				indices = obj.indexBuffers.triangles ? obj.indexBuffers.triangles.data : null;
		}
		if(!vertices)
			return null;
		var num_triangles = indices ? indices.length / 3 : vertices.length / (3*3);
		var total_area = 0; //sum of areas of all triangles

		if(evenly)
		{
			areas = new Float32Array(num_triangles); //accum
			for(var i = 0; i < num_triangles; ++i)
			{
				if(indices)
				{
					a = indices[i*3]*3;
					b = indices[i*3+1]*3;
					c = indices[i*3+2]*3;
				}
				else
				{
					a = i*9;
					b = i*9+3;
					c = i*9+6;
				}
				var P1 = vertices.subarray(a,a+3);
				var P2 = vertices.subarray(b,b+3);
				var P3 = vertices.subarray(c,c+3);
				var aL = vec3.distance( P1, P2 );
				var bL = vec3.distance( P2, P3 );
				var cL = vec3.distance( P3, P1 );
				var s = (aL + bL+ cL) / 2;
				total_area += Math.sqrt(s * (s - aL) * (s - bL) * (s - cL));
				areas[i] = total_area;
			}			
			for(var i = 0; i < num_triangles; ++i) //normalize
				areas[i] /= total_area;
		}

		for(var i = 0; i < size; i+=3)
		{
			var r = Math.random();
			var index = evenly ? findRandomTriangle( areas, r ) : Math.floor(r * num_triangles );
			//get random triangle
			var a = 0;
			var b = 0;
			var c = 0;
			if(indices)
			{
				a = indices[index*3]*3;
				b = indices[index*3+1]*3;
				c = indices[index*3+2]*3;
			}
			else
			{
				a = index*9;
				b = index*9+3;
				c = index*9+6;
			}
			var s = Math.random();
			var t = Math.random();
			var sqrt_s = Math.sqrt(s);
			var af = 1 - sqrt_s;
			var bf = sqrt_s * ( 1 - t);
			var cf = t * sqrt_s;
			points[i] = af * vertices[a] + bf*vertices[b] + cf*vertices[c];
			points[i+1] = af * vertices[a+1] + bf*vertices[b+1] + cf*vertices[c+1];
			points[i+2] = af * vertices[a+2] + bf*vertices[b+2] + cf*vertices[c+2];
			if(normals && mesh_normals)
			{
				normals[i] = af * mesh_normals[a] + bf*mesh_normals[b] + cf*mesh_normals[c];
				normals[i+1] = af * mesh_normals[a+1] + bf*mesh_normals[b+1] + cf*mesh_normals[c+1];
				normals[i+2] = af * mesh_normals[a+2] + bf*mesh_normals[b+2] + cf*mesh_normals[c+2];
				var N = normals.subarray(i,i+3);
				vec3.normalize(N,N);
			}
		}
	}

	LGraphPoints3D.generateFromInsideObject = function( points, size, mesh )
	{
		if(!mesh || mesh.constructor !== GL.Mesh)
			return;

		var aabb = mesh.getBoundingBox();
		if(!mesh.octree)
			mesh.octree = new GL.Octree( mesh );
		var octree = mesh.octree;
		var origin = vec3.create();
		var direction = vec3.fromValues(1,0,0);
		var temp = vec3.create();
		var i = 0;
		var tries = 0;
		while(i < size && tries < points.length * 10) //limit to avoid problems
		{
			tries += 1
			var r = vec3.random(temp); //random point inside the aabb
			r[0] = (r[0] * 2 - 1) * aabb[3] + aabb[0];
			r[1] = (r[1] * 2 - 1) * aabb[4] + aabb[1];
			r[2] = (r[2] * 2 - 1) * aabb[5] + aabb[2];
			origin.set(r);
			var hit = octree.testRay( origin, direction, 0, 10000, true, GL.Octree.ALL );
			if(!hit || hit.length % 2 == 0) //not inside
				continue;
			points.set( r, i );
			i+=3;
		}
	}

	LiteGraph.registerNodeType( "geometry/points3D", LGraphPoints3D );



	function LGraphPointsToInstances() {
		this.addInput("points", "geometry");
		this.addOutput("instances", "[mat4]");
		this.properties = {
			mode: 1,
			autoupdate: true
		};

		this.must_update = true;
		this.matrices = [];
		this.first_time = true;
	}

	LGraphPointsToInstances.NORMAL = 0;
	LGraphPointsToInstances.VERTICAL = 1;
	LGraphPointsToInstances.SPHERICAL = 2;
	LGraphPointsToInstances.RANDOM = 3;
	LGraphPointsToInstances.RANDOM_VERTICAL = 4;

	LGraphPointsToInstances.modes = {"normal":0,"vertical":1,"spherical":2,"random":3,"random_vertical":4};
	LGraphPointsToInstances.widgets_info = {
		mode: { widget: "combo", values: LGraphPointsToInstances.modes }
	};

	LGraphPointsToInstances.title = "points to inst";

	LGraphPointsToInstances.prototype.onExecute = function()
	{
		var geo = this.getInputData(0);
		if( !geo )
		{
			this.setOutputData(0,null);
			return;
		}

		if( !this.isOutputConnected(0) )
			return;

		var has_changed = (geo._version != this._version || geo._id != this._geometry_id);

		if( has_changed && this.properties.autoupdate || this.first_time )
		{
			this.first_time = false;
			this.updateInstances( geo );
		}

		this.setOutputData( 0, this.matrices );
	}

	LGraphPointsToInstances.prototype.updateInstances = function( geometry )
	{
		var vertices = geometry.vertices;
		if(!vertices)
			return null;
		var normals = geometry.normals;

		var matrices = this.matrices;
		var num_points = vertices.length / 3;
		if( matrices.length != num_points)
			matrices.length = num_points;
		var identity = mat4.create();
		var temp = vec3.create();
		var zero = vec3.create();
		var UP = vec3.fromValues(0,1,0);
		var FRONT = vec3.fromValues(0,0,-1);
		var RIGHT = vec3.fromValues(1,0,0);
		var R = quat.create();

		var front = vec3.create();
		var right = vec3.create();
		var top = vec3.create();

		for(var i = 0; i < vertices.length; i += 3)
		{
			var index = i/3;
			var m = matrices[index];
			if(!m)
				m = matrices[index] = mat4.create();
			m.set( identity );
			var point = vertices.subarray(i,i+3);

			switch(this.properties.mode)
			{
				case LGraphPointsToInstances.NORMAL: 
					mat4.setTranslation( m, point );
					if(normals)
					{
						var normal = normals.subarray(i,i+3);
						top.set( normal );
						vec3.normalize( top, top );
						vec3.cross( right, FRONT, top );
						vec3.normalize( right, right );
						vec3.cross( front, right, top );
						vec3.normalize( front, front );
						m.set(right,0);
						m.set(top,4);
						m.set(front,8);
						mat4.setTranslation( m, point );
					}
					break;
				case LGraphPointsToInstances.VERTICAL: 
					mat4.setTranslation( m, point );
					break;
				case LGraphPointsToInstances.SPHERICAL: 
					front.set( point );
					vec3.normalize( front, front );
					vec3.cross( right, UP, front );
					vec3.normalize( right, right );
					vec3.cross( top, front, right );
					vec3.normalize( top, top );
					m.set(right,0);
					m.set(top,4);
					m.set(front,8);
					mat4.setTranslation( m, point );
					break;
				case LGraphPointsToInstances.RANDOM:
					temp[0] = Math.random()*2 - 1;
					temp[1] = Math.random()*2 - 1;
					temp[2] = Math.random()*2 - 1;
					vec3.normalize( temp, temp );
					quat.setAxisAngle( R, temp, Math.random() * 2 * Math.PI );
					mat4.fromQuat(m, R);
					mat4.setTranslation( m, point );
					break;
				case LGraphPointsToInstances.RANDOM_VERTICAL:
					quat.setAxisAngle( R, UP, Math.random() * 2 * Math.PI );
					mat4.fromQuat(m, R);
					mat4.setTranslation( m, point );
					break;
			}
		}

		this._version = geometry._version;
		this._geometry_id = geometry._id;
	}

	LiteGraph.registerNodeType( "geometry/points_to_instances", LGraphPointsToInstances );


	function LGraphGeometryTransform() {
		this.addInput("in", "geometry,[mat4]");
		this.addInput("mat4", "mat4");
		this.addOutput("out", "geometry");
		this.properties = {};

		this.geometry = {
			type: "triangles",
			vertices: null,
			_id: generateGeometryId(),
			_version: 0
		};

		this._last_geometry_id = -1;
		this._last_version = -1;
		this._last_key = "";

		this.must_update = true;
	}

	LGraphGeometryTransform.title = "Transform";

	LGraphGeometryTransform.prototype.onExecute = function() {

		var input = this.getInputData(0);
		var model = this.getInputData(1);

		if(!input)
			return;

		//array of matrices
		if(input.constructor === Array)
		{
			if(input.length == 0)
				return;
			this.outputs[0].type = "[mat4]";
			if( !this.isOutputConnected(0) )
				return;

			if(!model)
			{
				this.setOutputData(0,input);
				return;
			}

			if(!this._output)
				this._output = new Array();
			if(this._output.length != input.length)
				this._output.length = input.length;
			for(var i = 0; i < input.length; ++i)
			{
				var m = this._output[i];
				if(!m)
					m = this._output[i] = mat4.create();
				mat4.multiply(m,input[i],model);
			}
			this.setOutputData(0,this._output);
			return;
		}

		//geometry
		if(!input.vertices || !input.vertices.length)
			return;
		var geo = input;
		this.outputs[0].type = "geometry";
		if( !this.isOutputConnected(0) )
			return;
		if(!model)
		{
			this.setOutputData(0,geo);
			return;
		}

		var key = typedArrayToArray(model).join(",");

		if( this.must_update || geo._id != this._last_geometry_id || geo._version != this._last_version || key != this._last_key )
		{
			this.updateGeometry(geo, model);
			this._last_key = key;
			this._last_version = geo._version;
			this._last_geometry_id = geo._id;
			this.must_update = false;
		}

		this.setOutputData(0,this.geometry);
	}

	LGraphGeometryTransform.prototype.updateGeometry = function(geometry, model) {
		var old_vertices = geometry.vertices;
		var vertices = this.geometry.vertices;
		if( !vertices || vertices.length != old_vertices.length )
			vertices = this.geometry.vertices = new Float32Array( old_vertices.length );
		var temp = vec3.create();

		for(var i = 0, l = vertices.length; i < l; i+=3)
		{
			temp[0] = old_vertices[i]; temp[1] = old_vertices[i+1]; temp[2] = old_vertices[i+2]; 
			mat4.multiplyVec3( temp, model, temp );
			vertices[i] = temp[0]; vertices[i+1] = temp[1]; vertices[i+2] = temp[2];
		}

		if(geometry.normals)
		{
			if( !this.geometry.normals || this.geometry.normals.length != geometry.normals.length )
				this.geometry.normals = new Float32Array( geometry.normals.length );
			var normals = this.geometry.normals;
			var normal_model = mat4.invert(mat4.create(), model);
			if(normal_model)
				mat4.transpose(normal_model, normal_model);
			var old_normals = geometry.normals;
			for(var i = 0, l = normals.length; i < l; i+=3)
			{
				temp[0] = old_normals[i]; temp[1] = old_normals[i+1]; temp[2] = old_normals[i+2]; 
				mat4.multiplyVec3( temp, normal_model, temp );
				normals[i] = temp[0]; normals[i+1] = temp[1]; normals[i+2] = temp[2];
			}
		}

		this.geometry.type = geometry.type;
		this.geometry._version++;
	}

	LiteGraph.registerNodeType( "geometry/transform", LGraphGeometryTransform );


	function LGraphGeometryPolygon() {
		this.addInput("sides", "number");
		this.addInput("radius", "number");
		this.addOutput("out", "geometry");
		this.properties = { sides: 6, radius: 1, uvs: false }

		this.geometry = {
			type: "line_loop",
			vertices: null,
			_id: generateGeometryId()
		};
		this.geometry_id = -1;
		this.version = -1;
		this.must_update = true;

		this.last_info = { sides: -1, radius: -1 };
	}

	LGraphGeometryPolygon.title = "Polygon";

	LGraphGeometryPolygon.prototype.onExecute = function() {

		if( !this.isOutputConnected(0) )
			return;

		var sides = this.getInputOrProperty("sides");
		var radius = this.getInputOrProperty("radius");
		sides = Math.max(3,sides)|0;

		//update
		if( this.last_info.sides != sides || this.last_info.radius != radius )
			this.updateGeometry(sides, radius);

		this.setOutputData(0,this.geometry);
	}

	LGraphGeometryPolygon.prototype.updateGeometry = function(sides, radius) {
		var num = 3*sides;
		var vertices = this.geometry.vertices;
		if( !vertices || vertices.length != num )
			vertices = this.geometry.vertices = new Float32Array( 3*sides );
		var delta = (Math.PI * 2) / sides;
		var gen_uvs = this.properties.uvs;
		if(gen_uvs)
		{
			uvs = this.geometry.coords = new Float32Array( 3*sides );
		}


		for(var i = 0; i < sides; ++i)
		{
			var angle = delta * -i;
			var x = Math.cos( angle ) * radius;
			var y = 0;
			var z = Math.sin( angle ) * radius;
			vertices[i*3] = x;
			vertices[i*3+1] = y;
			vertices[i*3+2] = z;

			if(gen_uvs)
			{
				

			}
		}
		this.geometry._id = ++this.geometry_id;
		this.geometry._version = ++this.version;
		this.last_info.sides = sides;
		this.last_info.radius = radius;
	}

	LiteGraph.registerNodeType( "geometry/polygon", LGraphGeometryPolygon );


	function LGraphGeometryExtrude() {

		this.addInput("", "geometry");
		this.addOutput("", "geometry");
		this.properties = { top_cap: true, bottom_cap: true, offset: [0,100,0] };
		this.version = -1;

		this._last_geo_version = -1;
		this._must_update = true;
	}

	LGraphGeometryExtrude.title = "extrude";

	LGraphGeometryExtrude.prototype.onPropertyChanged = function(name, value)
	{
		this._must_update = true;
	}

	LGraphGeometryExtrude.prototype.onExecute = function()
	{
		var geo = this.getInputData(0);
		if( !geo || !this.isOutputConnected(0) )
			return;

		if(geo.version != this._last_geo_version || this._must_update)
		{
			this._geo = this.extrudeGeometry( geo, this._geo );
			if(this._geo)
				this._geo.version = this.version++;
			this._must_update = false;
		}

		this.setOutputData(0, this._geo);
	}

	LGraphGeometryExtrude.prototype.extrudeGeometry = function( geo )
	{
		//for every pair of vertices
		var vertices = geo.vertices;
		var num_points = vertices.length / 3;

		var tempA = vec3.create();
		var tempB = vec3.create();
		var tempC = vec3.create();
		var tempD = vec3.create();
		var offset = new Float32Array( this.properties.offset );

		if(geo.type == "line_loop")
		{
			var new_vertices = new Float32Array( num_points * 6 * 3 ); //every points become 6 ( caps not included )
			var npos = 0;
			for(var i = 0, l = vertices.length; i < l; i += 3)
			{
				tempA[0] = vertices[i]; tempA[1] = vertices[i+1]; tempA[2] = vertices[i+2];

				if( i+3 < l ) //loop
				{
					tempB[0] = vertices[i+3]; tempB[1] = vertices[i+4]; tempB[2] = vertices[i+5];
				}
				else
				{
					tempB[0] = vertices[0]; tempB[1] = vertices[1]; tempB[2] = vertices[2];
				}

				vec3.add( tempC, tempA, offset );
				vec3.add( tempD, tempB, offset );

				new_vertices.set( tempA, npos ); npos += 3;
				new_vertices.set( tempB, npos ); npos += 3;
				new_vertices.set( tempC, npos ); npos += 3;

				new_vertices.set( tempB, npos ); npos += 3;
				new_vertices.set( tempD, npos ); npos += 3;
				new_vertices.set( tempC, npos ); npos += 3;
			}
		}

		var out_geo = {
			_id: generateGeometryId(),
			type: "triangles",
			vertices: new_vertices
		};

		return out_geo;
	}

	LiteGraph.registerNodeType( "geometry/extrude", LGraphGeometryExtrude );


	function LGraphGeometryEval() {
		this.addInput("in", "geometry");
		this.addOutput("out", "geometry");

		this.properties = {
			code: "V[1] += 0.01 * Math.sin(I + T*0.001);",
			execute_every_frame: false
		};

		this.geometry = null;
		this.geometry_id = -1;
		this.version = -1;
		this.must_update = true;

		this.vertices = null;
		this.func = null;
	}

	LGraphGeometryEval.title = "geoeval";
	LGraphGeometryEval.desc = "eval code";

	LGraphGeometryEval.widgets_info = {
		code: { widget: "code" }
	};

	LGraphGeometryEval.prototype.onConfigure = function(o)
	{
		this.compileCode();
	}

	LGraphGeometryEval.prototype.compileCode = function()
	{
		if(!this.properties.code)
			return;

		try
		{
			this.func = new Function("V","I","T", this.properties.code); 
			this.boxcolor = "#AFA";
			this.must_update = true;
		}
		catch (err)
		{
			this.boxcolor = "red";
		}
	}

	LGraphGeometryEval.prototype.onPropertyChanged = function(name, value)
	{
		if(name == "code")
		{
			this.properties.code = value;
			this.compileCode();
		}
	}

	LGraphGeometryEval.prototype.onExecute = function() {
		var geometry = this.getInputData(0);
		if(!geometry)
			return;

		if(!this.func)
		{
			this.setOutputData(0,geometry);
			return;
		}

		if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update || this.properties.execute_every_frame )
		{
			this.must_update = false;
			this.geometry_id = geometry._id;
			if(this.properties.execute_every_frame)
				this.version++;
			else
				this.version = geometry._version;
			var func = this.func;
			var T = getTime();

			//clone
			if(!this.geometry)
				this.geometry = {};
			for(var i in geometry)
			{
				if(geometry[i] == null)
					continue;
				if( geometry[i].constructor == Float32Array )
					this.geometry[i] = new Float32Array( geometry[i] );
				else
					this.geometry[i] = geometry[i];
			}
			this.geometry._id = geometry._id;
			if(this.properties.execute_every_frame)
				this.geometry._version = this.version;
			else
				this.geometry._version = geometry._version + 1;

			var V = vec3.create();
			var vertices = this.vertices;
			if(!vertices || this.vertices.length != geometry.vertices.length)
				vertices = this.vertices = new Float32Array( geometry.vertices );
			else
				vertices.set( geometry.vertices );
			for(var i = 0; i < vertices.length; i+=3)
			{
				V[0] = vertices[i];
				V[1] = vertices[i+1];
				V[2] = vertices[i+2];
				func(V,i/3,T);
				vertices[i] = V[0];
				vertices[i+1] = V[1];
				vertices[i+2] = V[2];
			}
			this.geometry.vertices = vertices;
		}

		this.setOutputData(0,this.geometry);
	}

	LiteGraph.registerNodeType( "geometry/eval", LGraphGeometryEval );

/*
function LGraphGeometryDisplace() {
		this.addInput("in", "geometry");
		this.addInput("img", "image");
		this.addOutput("out", "geometry");

		this.properties = {
			grid_size: 1
		};

		this.geometry = null;
		this.geometry_id = -1;
		this.version = -1;
		this.must_update = true;

		this.vertices = null;
	}

	LGraphGeometryDisplace.title = "displace";
	LGraphGeometryDisplace.desc = "displace points";

	LGraphGeometryDisplace.prototype.onExecute = function() {
		var geometry = this.getInputData(0);
		var image = this.getInputData(1);
		if(!geometry)
			return;

		if(!image)
		{
			this.setOutputData(0,geometry);
			return;
		}

		if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )
		{
			this.must_update = false;
			this.geometry_id = geometry._id;
			this.version = geometry._version;

			//copy
			this.geometry = {};
			for(var i in geometry)
				this.geometry[i] = geometry[i];
			this.geometry._id = geometry._id;
			this.geometry._version = geometry._version + 1;

			var grid_size = this.properties.grid_size;
			if(grid_size != 0)
			{
				var vertices = this.vertices;
				if(!vertices || this.vertices.length != this.geometry.vertices.length)
					vertices = this.vertices = new Float32Array( this.geometry.vertices );
				for(var i = 0; i < vertices.length; i+=3)
				{
					vertices[i] = Math.round(vertices[i]/grid_size) * grid_size;
					vertices[i+1] = Math.round(vertices[i+1]/grid_size) * grid_size;
					vertices[i+2] = Math.round(vertices[i+2]/grid_size) * grid_size;
				}
				this.geometry.vertices = vertices;
			}
		}

		this.setOutputData(0,this.geometry);
	}

	LiteGraph.registerNodeType( "geometry/displace", LGraphGeometryDisplace );
*/

	function LGraphConnectPoints() {
		this.addInput("in", "geometry");
		this.addOutput("out", "geometry");

		this.properties = {
			min_dist: 0.4,
			max_dist: 0.5,
			max_connections: 0,
			probability: 1
		};

		this.geometry_id = -1;
		this.version = -1;
		this.my_version = 1;
		this.must_update = true;
	}

	LGraphConnectPoints.title = "connect points";
	LGraphConnectPoints.desc = "adds indices between near points";

	LGraphConnectPoints.prototype.onPropertyChanged = function(name,value)
	{
		this.must_update = true;
	}

	LGraphConnectPoints.prototype.onExecute = function() {
		var geometry = this.getInputData(0);
		if(!geometry)
			return;

		if( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )
		{
			this.must_update = false;
			this.geometry_id = geometry._id;
			this.version = geometry._version;

			//copy
			this.geometry = {};
			for(var i in geometry)
				this.geometry[i] = geometry[i];
			this.geometry._id = generateGeometryId();
			this.geometry._version = this.my_version++;

			var vertices = geometry.vertices;
			var l = vertices.length;
			var min_dist = this.properties.min_dist;
			var max_dist = this.properties.max_dist;
			var probability = this.properties.probability;
			var max_connections = this.properties.max_connections;
			var indices = [];
			
			for(var i = 0; i < l; i+=3)
			{
				var x = vertices[i];
				var y = vertices[i+1];
				var z = vertices[i+2];
				var connections = 0;
				for(var j = i+3; j < l; j+=3)
				{
					var x2 = vertices[j];
					var y2 = vertices[j+1];
					var z2 = vertices[j+2];
					var dist = Math.sqrt( (x-x2)*(x-x2) + (y-y2)*(y-y2) + (z-z2)*(z-z2));
					if(dist > max_dist || dist < min_dist || (probability < 1 && probability < Math.random()) )
						continue;
					indices.push(i/3,j/3);
					connections += 1;
					if(max_connections && connections > max_connections)
						break;
				}
			}
			this.geometry.indices = this.indices = new Uint32Array(indices);
		}

		if(this.indices && this.indices.length)
		{
			this.geometry.indices = this.indices;
			this.setOutputData( 0, this.geometry );
		}
		else
			this.setOutputData( 0, null );
	}

	LiteGraph.registerNodeType( "geometry/connectPoints", LGraphConnectPoints );

    //Works with Litegl.js to create WebGL nodes
    if (typeof GL == "undefined") //LiteGL RELATED **********************************************
		return;

	function LGraphToGeometry() {
		this.addInput("mesh", "mesh");
		this.addOutput("out", "geometry");

		this.geometry = {};
		this.last_mesh = null;
	}

	LGraphToGeometry.title = "to geometry";
	LGraphToGeometry.desc = "converts a mesh to geometry";

	LGraphToGeometry.prototype.onExecute = function() {
		var mesh = this.getInputData(0);
		if(!mesh)
			return;

		if(mesh != this.last_mesh)
		{
			this.last_mesh = mesh;
			for(i in mesh.vertexBuffers)
			{
				var buffer = mesh.vertexBuffers[i];
				this.geometry[i] = buffer.data
			}
			if(mesh.indexBuffers["triangles"])
				this.geometry.indices = mesh.indexBuffers["triangles"].data;

			this.geometry._id = generateGeometryId();
			this.geometry._version = 0;
		}

		this.setOutputData(0,this.geometry);
		if(this.geometry)
			this.setOutputData(1,this.geometry.vertices);
	}

	LiteGraph.registerNodeType( "geometry/toGeometry", LGraphToGeometry );

	function LGraphGeometryToMesh() {
		this.addInput("in", "geometry");
		this.addOutput("mesh", "mesh");
		this.properties = {};
		this.version = -1;
		this.mesh = null;
	}

	LGraphGeometryToMesh.title = "Geo to Mesh";

	LGraphGeometryToMesh.prototype.updateMesh = function(geometry)
	{
		if(!this.mesh)
			this.mesh = new GL.Mesh();

		for(var i in geometry)
		{
			if(i[0] == "_")
				continue;

			var buffer_data = geometry[i];

			var info = GL.Mesh.common_buffers[i];
			if(!info && i != "indices") //unknown buffer
				continue;
			var spacing = info ? info.spacing : 3;
			var mesh_buffer = this.mesh.vertexBuffers[i];

			if(!mesh_buffer || mesh_buffer.data.length != buffer_data.length)
			{
				mesh_buffer = new GL.Buffer( i == "indices" ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER, buffer_data, spacing, GL.DYNAMIC_DRAW );
			}
			else
			{
				mesh_buffer.data.set( buffer_data );
				mesh_buffer.upload(GL.DYNAMIC_DRAW);
			}

			this.mesh.addBuffer( i, mesh_buffer );
		}

		if(this.mesh.vertexBuffers.normals &&this.mesh.vertexBuffers.normals.data.length != this.mesh.vertexBuffers.vertices.data.length )
		{
			var n = new Float32Array([0,1,0]);
			var normals = new Float32Array( this.mesh.vertexBuffers.vertices.data.length );
			for(var i = 0; i < normals.length; i+= 3)
				normals.set( n, i );
			mesh_buffer = new GL.Buffer( GL.ARRAY_BUFFER, normals, 3 );
			this.mesh.addBuffer( "normals", mesh_buffer );
		}

		this.mesh.updateBoundingBox();
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
		return this.mesh;
	}

	LGraphGeometryToMesh.prototype.onExecute = function() {

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if( this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );
		this.setOutputData(0, this.mesh);
	}

	LiteGraph.registerNodeType( "geometry/toMesh", LGraphGeometryToMesh );

	function LGraphRenderMesh() {
		this.addInput("mesh", "mesh");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");

		this.properties = {
			enabled: true,
			primitive: GL.TRIANGLES,
			additive: false,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);
		this.model_matrix = mat4.create();
		this.uniforms = {
			u_color: this.color,
			u_model: this.model_matrix
		};
	}

	LGraphRenderMesh.title = "Render Mesh";
	LGraphRenderMesh.desc = "renders a mesh flat";

	LGraphRenderMesh.PRIMITIVE_VALUES = { "points":GL.POINTS, "lines":GL.LINES, "line_loop":GL.LINE_LOOP,"line_strip":GL.LINE_STRIP, "triangles":GL.TRIANGLES, "triangle_fan":GL.TRIANGLE_FAN, "triangle_strip":GL.TRIANGLE_STRIP };

	LGraphRenderMesh.widgets_info = {
		primitive: { widget: "combo", values: LGraphRenderMesh.PRIMITIVE_VALUES },
		color: { widget: "color" }
	};

	LGraphRenderMesh.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var mesh = this.getInputData(0);
		if(!mesh)
			return;

		if(!LiteGraph.LGraphRender.onRequestCameraMatrices)
		{
			console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;
		var texture = this.getInputData(2);
		if(texture)
		{
			shader = gl.shaders["textured"];
			if(!shader)
				shader = gl.shaders["textured"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_TEXTURE:"" });
		}
		else
		{
			shader = gl.shaders["flat"];
			if(!shader)
				shader = gl.shaders["flat"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code );
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var model_matrix = this.model_matrix;
		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = 1;
		var primitive = this.properties.primitive;

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );
		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		var indices = "indices";
		if( mesh.indexBuffers.triangles )
			indices = "triangles";
		shader.draw( mesh, primitive, indices );
		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_mesh", LGraphRenderMesh );

	//**************************


	function LGraphGeometryPrimitive() {
		this.addInput("size", "number");
		this.addOutput("out", "mesh");
		this.properties = { type: 1, size: 1, subdivisions: 32 };

		this.version = (Math.random() * 100000)|0;
		this.last_info = { type: -1, size: -1, subdivisions: -1 };
	}

	LGraphGeometryPrimitive.title = "Primitive";

	LGraphGeometryPrimitive.VALID = { "CUBE":1, "PLANE":2, "CYLINDER":3, "SPHERE":4, "CIRCLE":5, "HEMISPHERE":6, "ICOSAHEDRON":7, "CONE":8, "QUAD":9 };
	LGraphGeometryPrimitive.widgets_info = {
		type: { widget: "combo", values: LGraphGeometryPrimitive.VALID }
	};

	LGraphGeometryPrimitive.prototype.onExecute = function() {

		if( !this.isOutputConnected(0) )
			return;

		var size = this.getInputOrProperty("size");

		//update
		if( this.last_info.type != this.properties.type || this.last_info.size != size || this.last_info.subdivisions != this.properties.subdivisions )
			this.updateMesh( this.properties.type, size, this.properties.subdivisions );

		this.setOutputData(0,this._mesh);
	}

	LGraphGeometryPrimitive.prototype.updateMesh = function(type, size, subdivisions)
	{
		subdivisions = Math.max(0,subdivisions)|0;

		switch (type)
		{
			case 1: //CUBE: 
				this._mesh = GL.Mesh.cube({size: size, normals:true,coords:true});
				break;
			case 2: //PLANE:
				this._mesh = GL.Mesh.plane({size: size, xz: true, detail: subdivisions, normals:true,coords:true});
				break;
			case 3: //CYLINDER:
				this._mesh = GL.Mesh.cylinder({size: size, subdivisions: subdivisions, normals:true,coords:true});
				break;
			case 4: //SPHERE:
				this._mesh = GL.Mesh.sphere({size: size, "long": subdivisions, lat: subdivisions, normals:true,coords:true});
				break;
			case 5: //CIRCLE:
				this._mesh = GL.Mesh.circle({size: size, slices: subdivisions, normals:true, coords:true});
				break;
			case 6: //HEMISPHERE:
				this._mesh = GL.Mesh.sphere({size: size, "long": subdivisions, lat: subdivisions, normals:true, coords:true, hemi: true});
				break;
			case 7: //ICOSAHEDRON:
				this._mesh = GL.Mesh.icosahedron({size: size, subdivisions:subdivisions });
				break;
			case 8: //CONE:
				this._mesh = GL.Mesh.cone({radius: size, height: size, subdivisions:subdivisions });
				break;
			case 9: //QUAD:
				this._mesh = GL.Mesh.plane({size: size, xz: false, detail: subdivisions, normals:true, coords:true });
				break;
		}

		this.last_info.type = type;
		this.last_info.size = size;
		this.last_info.subdivisions = subdivisions;
		this._mesh.version = this.version++;
	}

	LiteGraph.registerNodeType( "geometry/mesh_primitive", LGraphGeometryPrimitive );


	function LGraphRenderPoints() {
		this.addInput("in", "geometry");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");
		this.properties = {
			enabled: true,
			point_size: 0.1,
			fixed_size: false,
			additive: true,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);

		this.uniforms = {
			u_point_size: 1,
			u_perspective: 1,
			u_point_perspective: 1,
			u_color: this.color
		};

		this.geometry_id = -1;
		this.version = -1;
		this.mesh = null;
	}

	LGraphRenderPoints.title = "renderPoints";
	LGraphRenderPoints.desc = "render points with a texture";

	LGraphRenderPoints.widgets_info = {
		color: { widget: "color" }
	};

	LGraphRenderPoints.prototype.updateMesh = function(geometry)
	{
		var buffer = this.buffer;
		if(!this.buffer || !this.buffer.data || this.buffer.data.length != geometry.vertices.length)
			this.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);
		else
		{
			this.buffer.data.set( geometry.vertices );
			this.buffer.upload(GL.DYNAMIC_DRAW);
		}

		if(!this.mesh)
			this.mesh = new GL.Mesh();

		this.mesh.addBuffer("vertices",this.buffer);
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
	}

	LGraphRenderPoints.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if(this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );

		if(!LiteGraph.LGraphRender.onRequestCameraMatrices)
		{
			console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;

		var texture = this.getInputData(2);
		
		if(texture)
		{
			shader = gl.shaders["textured_points"];
			if(!shader)
				shader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_TEXTURED_POINTS:"" });
		}
		else
		{
			shader = gl.shaders["points"];
			if(!shader)
				shader = gl.shaders["points"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_POINTS: "" });
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = this.properties.point_size;
		this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
		this.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );

		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		shader.draw( this.mesh, GL.POINTS );

		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_points", LGraphRenderPoints );

	LGraphRenderPoints.vertex_shader_code = '\
		precision mediump float;\n\
		attribute vec3 a_vertex;\n\
		varying vec3 v_vertex;\n\
		attribute vec3 a_normal;\n\
		varying vec3 v_normal;\n\
		#ifdef USE_COLOR\n\
			attribute vec4 a_color;\n\
			varying vec4 v_color;\n\
		#endif\n\
		attribute vec2 a_coord;\n\
		varying vec2 v_coord;\n\
		#ifdef USE_SIZE\n\
			attribute float a_extra;\n\
		#endif\n\
		#ifdef USE_INSTANCING\n\
			attribute mat4 u_model;\n\
		#else\n\
			uniform mat4 u_model;\n\
		#endif\n\
		uniform mat4 u_viewprojection;\n\
		uniform float u_point_size;\n\
		uniform float u_perspective;\n\
		uniform float u_point_perspective;\n\
		float computePointSize(float radius, float w)\n\
		{\n\
			if(radius < 0.0)\n\
				return -radius;\n\
			return u_perspective * radius / w;\n\
		}\n\
		void main() {\n\
			v_coord = a_coord;\n\
			#ifdef USE_COLOR\n\
				v_color = a_color;\n\
			#endif\n\
			v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\n\
			v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\n\
			gl_Position = u_viewprojection * vec4(v_vertex,1.0);\n\
			gl_PointSize = u_point_size;\n\
			#ifdef USE_SIZE\n\
				gl_PointSize = a_extra;\n\
			#endif\n\
			if(u_point_perspective != 0.0)\n\
				gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\n\
		}\
	';

	LGraphRenderPoints.fragment_shader_code = '\
		precision mediump float;\n\
		uniform vec4 u_color;\n\
		#ifdef USE_COLOR\n\
			varying vec4 v_color;\n\
		#endif\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		void main() {\n\
			vec4 color = u_color;\n\
			#ifdef USE_TEXTURED_POINTS\n\
				color *= texture2D(u_texture, gl_PointCoord.xy);\n\
			#else\n\
				#ifdef USE_TEXTURE\n\
				  color *= texture2D(u_texture, v_coord);\n\
				  if(color.a < 0.1)\n\
					discard;\n\
				#endif\n\
				#ifdef USE_POINTS\n\
					float dist = length( gl_PointCoord.xy - vec2(0.5) );\n\
					if( dist > 0.45 )\n\
						discard;\n\
				#endif\n\
			#endif\n\
			#ifdef USE_COLOR\n\
				color *= v_color;\n\
			#endif\n\
			gl_FragColor = color;\n\
		}\
	';

	//based on https://inconvergent.net/2019/depth-of-field/
	/*
	function LGraphRenderGeometryDOF() {
		this.addInput("in", "geometry");
		this.addInput("mat4", "mat4");
		this.addInput("tex", "texture");
		this.properties = {
			enabled: true,
			lines: true,
			point_size: 0.1,
			fixed_size: false,
			additive: true,
			color: [1,1,1],
			opacity: 1
		};

		this.color = vec4.create([1,1,1,1]);

		this.uniforms = {
			u_point_size: 1,
			u_perspective: 1,
			u_point_perspective: 1,
			u_color: this.color
		};

		this.geometry_id = -1;
		this.version = -1;
		this.mesh = null;
	}

	LGraphRenderGeometryDOF.widgets_info = {
		color: { widget: "color" }
	};

	LGraphRenderGeometryDOF.prototype.updateMesh = function(geometry)
	{
		var buffer = this.buffer;
		if(!this.buffer || this.buffer.data.length != geometry.vertices.length)
			this.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);
		else
		{
			this.buffer.data.set( geometry.vertices );
			this.buffer.upload(GL.DYNAMIC_DRAW);
		}

		if(!this.mesh)
			this.mesh = new GL.Mesh();

		this.mesh.addBuffer("vertices",this.buffer);
		this.geometry_id = this.mesh.id = geometry._id;
		this.version = this.mesh.version = geometry._version;
	}

	LGraphRenderGeometryDOF.prototype.onExecute = function() {

		if(!this.properties.enabled)
			return;

		var geometry = this.getInputData(0);
		if(!geometry)
			return;
		if(this.version != geometry._version || this.geometry_id != geometry._id )
			this.updateMesh( geometry );

		if(!LiteGraph.LGraphRender.onRequestCameraMatrices)
		{
			console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
			return;
		}

		LiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );
		var shader = null;

		var texture = this.getInputData(2);
		
		if(texture)
		{
			shader = gl.shaders["textured_points"];
			if(!shader)
				shader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_TEXTURED_POINTS:"" });
		}
		else
		{
			shader = gl.shaders["points"];
			if(!shader)
				shader = gl.shaders["points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_POINTS: "" });
		}

		this.color.set( this.properties.color );
		this.color[3] = this.properties.opacity;

		var m = this.getInputData(1);
		if(m)
			model_matrix.set(m);
		else
			mat4.identity( model_matrix );

		this.uniforms.u_point_size = this.properties.point_size;
		this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
		this.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];

		shader.uniforms( global_uniforms );
		shader.uniforms( this.uniforms );

		if(this.properties.opacity >= 1)
			gl.disable( gl.BLEND );
		else
			gl.enable( gl.BLEND );

		gl.enable( gl.DEPTH_TEST );
		if( this.properties.additive )
		{
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
			gl.depthMask( false );
		}
		else
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		shader.draw( this.mesh, GL.POINTS );

		gl.disable( gl.BLEND );
		gl.depthMask( true );
	}

	LiteGraph.registerNodeType( "geometry/render_dof", LGraphRenderGeometryDOF );

	LGraphRenderGeometryDOF.vertex_shader_code = '\
		precision mediump float;\n\
		attribute vec3 a_vertex;\n\
		varying vec3 v_vertex;\n\
		attribute vec3 a_normal;\n\
		varying vec3 v_normal;\n\
		#ifdef USE_COLOR\n\
			attribute vec4 a_color;\n\
			varying vec4 v_color;\n\
		#endif\n\
		attribute vec2 a_coord;\n\
		varying vec2 v_coord;\n\
		#ifdef USE_SIZE\n\
			attribute float a_extra;\n\
		#endif\n\
		#ifdef USE_INSTANCING\n\
			attribute mat4 u_model;\n\
		#else\n\
			uniform mat4 u_model;\n\
		#endif\n\
		uniform mat4 u_viewprojection;\n\
		uniform float u_point_size;\n\
		uniform float u_perspective;\n\
		uniform float u_point_perspective;\n\
		float computePointSize(float radius, float w)\n\
		{\n\
			if(radius < 0.0)\n\
				return -radius;\n\
			return u_perspective * radius / w;\n\
		}\n\
		void main() {\n\
			v_coord = a_coord;\n\
			#ifdef USE_COLOR\n\
				v_color = a_color;\n\
			#endif\n\
			v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\n\
			v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\n\
			gl_Position = u_viewprojection * vec4(v_vertex,1.0);\n\
			gl_PointSize = u_point_size;\n\
			#ifdef USE_SIZE\n\
				gl_PointSize = a_extra;\n\
			#endif\n\
			if(u_point_perspective != 0.0)\n\
				gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\n\
		}\
	';

	LGraphRenderGeometryDOF.fragment_shader_code = '\
		precision mediump float;\n\
		uniform vec4 u_color;\n\
		#ifdef USE_COLOR\n\
			varying vec4 v_color;\n\
		#endif\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture;\n\
		void main() {\n\
			vec4 color = u_color;\n\
			#ifdef USE_TEXTURED_POINTS\n\
				color *= texture2D(u_texture, gl_PointCoord.xy);\n\
			#else\n\
				#ifdef USE_TEXTURE\n\
				  color *= texture2D(u_texture, v_coord);\n\
				  if(color.a < 0.1)\n\
					discard;\n\
				#endif\n\
				#ifdef USE_POINTS\n\
					float dist = length( gl_PointCoord.xy - vec2(0.5) );\n\
					if( dist > 0.45 )\n\
						discard;\n\
				#endif\n\
			#endif\n\
			#ifdef USE_COLOR\n\
				color *= v_color;\n\
			#endif\n\
			gl_FragColor = color;\n\
		}\
	';
	*/



})(this);
(function(global) {
    var LiteGraph = global.LiteGraph;
    var LGraphTexture = global.LGraphTexture;

    //Works with Litegl.js to create WebGL nodes
    if (typeof GL != "undefined") {
        // Texture Lens *****************************************
        function LGraphFXLens() {
            this.addInput("Texture", "Texture");
            this.addInput("Aberration", "number");
            this.addInput("Distortion", "number");
            this.addInput("Blur", "number");
            this.addOutput("Texture", "Texture");
            this.properties = {
                aberration: 1.0,
                distortion: 1.0,
                blur: 1.0,
                precision: LGraphTexture.DEFAULT
            };

            if (!LGraphFXLens._shader) {
                LGraphFXLens._shader = new GL.Shader(
                    GL.Shader.SCREEN_VERTEX_SHADER,
                    LGraphFXLens.pixel_shader
                );
                LGraphFXLens._texture = new GL.Texture(3, 1, {
                    format: gl.RGB,
                    wrap: gl.CLAMP_TO_EDGE,
                    magFilter: gl.LINEAR,
                    minFilter: gl.LINEAR,
                    pixel_data: [255, 0, 0, 0, 255, 0, 0, 0, 255]
                });
            }
        }

        LGraphFXLens.title = "Lens";
        LGraphFXLens.desc = "Camera Lens distortion";
        LGraphFXLens.widgets_info = {
            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
        };

        LGraphFXLens.prototype.onExecute = function() {
            var tex = this.getInputData(0);
            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
                this.setOutputData(0, tex);
                return;
            }

            if (!tex) {
                return;
            }

            this._tex = LGraphTexture.getTargetTexture(
                tex,
                this._tex,
                this.properties.precision
            );

            var aberration = this.properties.aberration;
            if (this.isInputConnected(1)) {
                aberration = this.getInputData(1);
                this.properties.aberration = aberration;
            }

            var distortion = this.properties.distortion;
            if (this.isInputConnected(2)) {
                distortion = this.getInputData(2);
                this.properties.distortion = distortion;
            }

            var blur = this.properties.blur;
            if (this.isInputConnected(3)) {
                blur = this.getInputData(3);
                this.properties.blur = blur;
            }

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var mesh = Mesh.getScreenQuad();
            var shader = LGraphFXLens._shader;
            //var camera = LS.Renderer._current_camera;

            this._tex.drawTo(function() {
                tex.bind(0);
                shader
                    .uniforms({
                        u_texture: 0,
                        u_aberration: aberration,
                        u_distortion: distortion,
                        u_blur: blur
                    })
                    .draw(mesh);
            });

            this.setOutputData(0, this._tex);
        };

        LGraphFXLens.pixel_shader =
            "precision highp float;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform float u_aberration;\n\
			uniform float u_distortion;\n\
			uniform float u_blur;\n\
			\n\
			void main() {\n\
				vec2 coord = v_coord;\n\
				float dist = distance(vec2(0.5), coord);\n\
				vec2 dist_coord = coord - vec2(0.5);\n\
				float percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\n\
				dist_coord *= percent;\n\
				coord = dist_coord + vec2(0.5);\n\
				vec4 color = texture2D(u_texture,coord, u_blur * dist);\n\
				color.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\n\
				color.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\n\
				gl_FragColor = color;\n\
			}\n\
			";
        /*
			float normalized_tunable_sigmoid(float xs, float k)\n\
			{\n\
				xs = xs * 2.0 - 1.0;\n\
				float signx = sign(xs);\n\
				float absx = abs(xs);\n\
				return signx * ((-k - 1.0)*absx)/(2.0*(-2.0*k*absx+k-1.0)) + 0.5;\n\
			}\n\
		*/

        LiteGraph.registerNodeType("fx/lens", LGraphFXLens);
        global.LGraphFXLens = LGraphFXLens;

        /* not working yet
	function LGraphDepthOfField()
	{
		this.addInput("Color","Texture");
		this.addInput("Linear Depth","Texture");
		this.addInput("Camera","camera");
		this.addOutput("Texture","Texture");
		this.properties = { high_precision: false };
	}

	LGraphDepthOfField.title = "Depth Of Field";
	LGraphDepthOfField.desc = "Applies a depth of field effect";

	LGraphDepthOfField.prototype.onExecute = function()
	{
		var tex = this.getInputData(0);
		var depth = this.getInputData(1);
		var camera = this.getInputData(2);

		if(!tex || !depth || !camera) 
		{
			this.setOutputData(0, tex);
			return;
		}

		var precision = gl.UNSIGNED_BYTE;
		if(this.properties.high_precision)
			precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;			
		if(!this._temp_texture || this._temp_texture.type != precision ||
			this._temp_texture.width != tex.width || this._temp_texture.height != tex.height)
			this._temp_texture = new GL.Texture( tex.width, tex.height, { type: precision, format: gl.RGBA, filter: gl.LINEAR });

		var shader = LGraphDepthOfField._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphDepthOfField._pixel_shader );

		var screen_mesh = Mesh.getScreenQuad();

		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.BLEND );

		var camera_position = camera.getEye();
		var focus_point = camera.getCenter();
		var distance = vec3.distance( camera_position, focus_point );
		var far = camera.far;
		var focus_range = distance * 0.5;

		this._temp_texture.drawTo( function() {
			tex.bind(0);
			depth.bind(1);
			shader.uniforms({u_texture:0, u_depth_texture:1, u_resolution: [1/tex.width, 1/tex.height], u_far: far, u_focus_point: distance, u_focus_scale: focus_range }).draw(screen_mesh);
		});

		this.setOutputData(0, this._temp_texture);
	}

	//from http://tuxedolabs.blogspot.com.es/2018/05/bokeh-depth-of-field-in-single-pass.html
	LGraphDepthOfField._pixel_shader = "\n\
		precision highp float;\n\
		varying vec2 v_coord;\n\
		uniform sampler2D u_texture; //Image to be processed\n\
		uniform sampler2D u_depth_texture; //Linear depth, where 1.0 == far plane\n\
		uniform vec2 u_iresolution; //The size of a pixel: vec2(1.0/width, 1.0/height)\n\
		uniform float u_far; // Far plane\n\
		uniform float u_focus_point;\n\
		uniform float u_focus_scale;\n\
		\n\
		const float GOLDEN_ANGLE = 2.39996323;\n\
		const float MAX_BLUR_SIZE = 20.0;\n\
		const float RAD_SCALE = 0.5; // Smaller = nicer blur, larger = faster\n\
		\n\
		float getBlurSize(float depth, float focusPoint, float focusScale)\n\
		{\n\
		 float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\
		 return abs(coc) * MAX_BLUR_SIZE;\n\
		}\n\
		\n\
		vec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n\
		{\n\
		 float centerDepth = texture2D(u_depth_texture, texCoord).r * u_far;\n\
		 float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n\
		 vec3 color = texture2D(u_texture, v_coord).rgb;\n\
		 float tot = 1.0;\n\
		\n\
		 float radius = RAD_SCALE;\n\
		 for (float ang = 0.0; ang < 100.0; ang += GOLDEN_ANGLE)\n\
		 {\n\
		  vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * u_iresolution * radius;\n\
			\n\
		  vec3 sampleColor = texture2D(u_texture, tc).rgb;\n\
		  float sampleDepth = texture2D(u_depth_texture, tc).r * u_far;\n\
		  float sampleSize = getBlurSize( sampleDepth, focusPoint, focusScale );\n\
		  if (sampleDepth > centerDepth)\n\
		   sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n\
			\n\
		  float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n\
		  color += mix(color/tot, sampleColor, m);\n\
		  tot += 1.0;\n\
		  radius += RAD_SCALE/radius;\n\
		  if(radius>=MAX_BLUR_SIZE)\n\
			 return color / tot;\n\
		 }\n\
		 return color / tot;\n\
		}\n\
		void main()\n\
		{\n\
			gl_FragColor = vec4( depthOfField( v_coord, u_focus_point, u_focus_scale ), 1.0 );\n\
			//gl_FragColor = vec4( texture2D(u_depth_texture, v_coord).r );\n\
		}\n\
		";

	LiteGraph.registerNodeType("fx/DOF", LGraphDepthOfField );
	global.LGraphDepthOfField = LGraphDepthOfField;
	*/

        //*******************************************************

        function LGraphFXBokeh() {
            this.addInput("Texture", "Texture");
            this.addInput("Blurred", "Texture");
            this.addInput("Mask", "Texture");
            this.addInput("Threshold", "number");
            this.addOutput("Texture", "Texture");
            this.properties = {
                shape: "",
                size: 10,
                alpha: 1.0,
                threshold: 1.0,
                high_precision: false
            };
        }

        LGraphFXBokeh.title = "Bokeh";
        LGraphFXBokeh.desc = "applies an Bokeh effect";

        LGraphFXBokeh.widgets_info = { shape: { widget: "texture" } };

        LGraphFXBokeh.prototype.onExecute = function() {
            var tex = this.getInputData(0);
            var blurred_tex = this.getInputData(1);
            var mask_tex = this.getInputData(2);
            if (!tex || !mask_tex || !this.properties.shape) {
                this.setOutputData(0, tex);
                return;
            }

            if (!blurred_tex) {
                blurred_tex = tex;
            }

            var shape_tex = LGraphTexture.getTexture(this.properties.shape);
            if (!shape_tex) {
                return;
            }

            var threshold = this.properties.threshold;
            if (this.isInputConnected(3)) {
                threshold = this.getInputData(3);
                this.properties.threshold = threshold;
            }

            var precision = gl.UNSIGNED_BYTE;
            if (this.properties.high_precision) {
                precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;
            }
            if (
                !this._temp_texture ||
                this._temp_texture.type != precision ||
                this._temp_texture.width != tex.width ||
                this._temp_texture.height != tex.height
            ) {
                this._temp_texture = new GL.Texture(tex.width, tex.height, {
                    type: precision,
                    format: gl.RGBA,
                    filter: gl.LINEAR
                });
            }

            //iterations
            var size = this.properties.size;

            var first_shader = LGraphFXBokeh._first_shader;
            if (!first_shader) {
                first_shader = LGraphFXBokeh._first_shader = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    LGraphFXBokeh._first_pixel_shader
                );
            }

            var second_shader = LGraphFXBokeh._second_shader;
            if (!second_shader) {
                second_shader = LGraphFXBokeh._second_shader = new GL.Shader(
                    LGraphFXBokeh._second_vertex_shader,
                    LGraphFXBokeh._second_pixel_shader
                );
            }

            var points_mesh = this._points_mesh;
            if (
                !points_mesh ||
                points_mesh._width != tex.width ||
                points_mesh._height != tex.height ||
                points_mesh._spacing != 2
            ) {
                points_mesh = this.createPointsMesh(tex.width, tex.height, 2);
            }

            var screen_mesh = Mesh.getScreenQuad();

            var point_size = this.properties.size;
            var min_light = this.properties.min_light;
            var alpha = this.properties.alpha;

            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);

            this._temp_texture.drawTo(function() {
                tex.bind(0);
                blurred_tex.bind(1);
                mask_tex.bind(2);
                first_shader
                    .uniforms({
                        u_texture: 0,
                        u_texture_blur: 1,
                        u_mask: 2,
                        u_texsize: [tex.width, tex.height]
                    })
                    .draw(screen_mesh);
            });

            this._temp_texture.drawTo(function() {
                //clear because we use blending
                //gl.clearColor(0.0,0.0,0.0,1.0);
                //gl.clear( gl.COLOR_BUFFER_BIT );
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);

                tex.bind(0);
                shape_tex.bind(3);
                second_shader
                    .uniforms({
                        u_texture: 0,
                        u_mask: 2,
                        u_shape: 3,
                        u_alpha: alpha,
                        u_threshold: threshold,
                        u_pointSize: point_size,
                        u_itexsize: [1.0 / tex.width, 1.0 / tex.height]
                    })
                    .draw(points_mesh, gl.POINTS);
            });

            this.setOutputData(0, this._temp_texture);
        };

        LGraphFXBokeh.prototype.createPointsMesh = function(
            width,
            height,
            spacing
        ) {
            var nwidth = Math.round(width / spacing);
            var nheight = Math.round(height / spacing);

            var vertices = new Float32Array(nwidth * nheight * 2);

            var ny = -1;
            var dx = (2 / width) * spacing;
            var dy = (2 / height) * spacing;
            for (var y = 0; y < nheight; ++y) {
                var nx = -1;
                for (var x = 0; x < nwidth; ++x) {
                    var pos = y * nwidth * 2 + x * 2;
                    vertices[pos] = nx;
                    vertices[pos + 1] = ny;
                    nx += dx;
                }
                ny += dy;
            }

            this._points_mesh = GL.Mesh.load({ vertices2D: vertices });
            this._points_mesh._width = width;
            this._points_mesh._height = height;
            this._points_mesh._spacing = spacing;

            return this._points_mesh;
        };

        /*
	LGraphTextureBokeh._pixel_shader = "precision highp float;\n\
			varying vec2 a_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_shape;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D( u_texture, gl_PointCoord );\n\
				color *= v_color * u_alpha;\n\
				gl_FragColor = color;\n\
			}\n";
	*/

        LGraphFXBokeh._first_pixel_shader =
            "precision highp float;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_texture_blur;\n\
			uniform sampler2D u_mask;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				vec4 blurred_color = texture2D(u_texture_blur, v_coord);\n\
				float mask = texture2D(u_mask, v_coord).x;\n\
			   gl_FragColor = mix(color, blurred_color, mask);\n\
			}\n\
			";

        LGraphFXBokeh._second_vertex_shader =
            "precision highp float;\n\
			attribute vec2 a_vertex2D;\n\
			varying vec4 v_color;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_mask;\n\
			uniform vec2 u_itexsize;\n\
			uniform float u_pointSize;\n\
			uniform float u_threshold;\n\
			void main() {\n\
				vec2 coord = a_vertex2D * 0.5 + 0.5;\n\
				v_color = texture2D( u_texture, coord );\n\
				v_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\n\
				v_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\n\
				v_color += texture2D( u_texture, coord + u_itexsize);\n\
				v_color *= 0.25;\n\
				float mask = texture2D(u_mask, coord).x;\n\
				float luminance = length(v_color) * mask;\n\
				/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\n\
				luminance -= u_threshold;\n\
				if(luminance < 0.0)\n\
				{\n\
					gl_Position.x = -100.0;\n\
					return;\n\
				}\n\
				gl_PointSize = u_pointSize;\n\
				gl_Position = vec4(a_vertex2D,0.0,1.0);\n\
			}\n\
			";

        LGraphFXBokeh._second_pixel_shader =
            "precision highp float;\n\
			varying vec4 v_color;\n\
			uniform sampler2D u_shape;\n\
			uniform float u_alpha;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D( u_shape, gl_PointCoord );\n\
				color *= v_color * u_alpha;\n\
				gl_FragColor = color;\n\
			}\n";

        LiteGraph.registerNodeType("fx/bokeh", LGraphFXBokeh);
        global.LGraphFXBokeh = LGraphFXBokeh;

        //************************************************

        function LGraphFXGeneric() {
            this.addInput("Texture", "Texture");
            this.addInput("value1", "number");
            this.addInput("value2", "number");
            this.addOutput("Texture", "Texture");
            this.properties = {
                fx: "halftone",
                value1: 1,
                value2: 1,
                precision: LGraphTexture.DEFAULT
            };
        }

        LGraphFXGeneric.title = "FX";
        LGraphFXGeneric.desc = "applies an FX from a list";

        LGraphFXGeneric.widgets_info = {
            fx: {
                widget: "combo",
                values: ["halftone", "pixelate", "lowpalette", "noise", "gamma"]
            },
            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
        };
        LGraphFXGeneric.shaders = {};

        LGraphFXGeneric.prototype.onExecute = function() {
            if (!this.isOutputConnected(0)) {
                return;
            } //saves work

            var tex = this.getInputData(0);
            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
                this.setOutputData(0, tex);
                return;
            }

            if (!tex) {
                return;
            }

            this._tex = LGraphTexture.getTargetTexture(
                tex,
                this._tex,
                this.properties.precision
            );

            //iterations
            var value1 = this.properties.value1;
            if (this.isInputConnected(1)) {
                value1 = this.getInputData(1);
                this.properties.value1 = value1;
            }

            var value2 = this.properties.value2;
            if (this.isInputConnected(2)) {
                value2 = this.getInputData(2);
                this.properties.value2 = value2;
            }

            var fx = this.properties.fx;
            var shader = LGraphFXGeneric.shaders[fx];
            if (!shader) {
                var pixel_shader_code = LGraphFXGeneric["pixel_shader_" + fx];
                if (!pixel_shader_code) {
                    return;
                }

                shader = LGraphFXGeneric.shaders[fx] = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    pixel_shader_code
                );
            }

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var mesh = Mesh.getScreenQuad();
            var camera = global.LS ? LS.Renderer._current_camera : null;
            var camera_planes;
            if (camera) {
                camera_planes = [
                    LS.Renderer._current_camera.near,
                    LS.Renderer._current_camera.far
                ];
            } else {
                camera_planes = [1, 100];
            }

            var noise = null;
            if (fx == "noise") {
                noise = LGraphTexture.getNoiseTexture();
            }

            this._tex.drawTo(function() {
                tex.bind(0);
                if (fx == "noise") {
                    noise.bind(1);
                }

                shader
                    .uniforms({
                        u_texture: 0,
                        u_noise: 1,
                        u_size: [tex.width, tex.height],
                        u_rand: [Math.random(), Math.random()],
                        u_value1: value1,
                        u_value2: value2,
                        u_camera_planes: camera_planes
                    })
                    .draw(mesh);
            });

            this.setOutputData(0, this._tex);
        };

        LGraphFXGeneric.pixel_shader_halftone =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			\n\
			float pattern() {\n\
				float s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\n\
				vec2 tex = v_coord * u_size.xy;\n\
				vec2 point = vec2(\n\
				   c * tex.x - s * tex.y ,\n\
				   s * tex.x + c * tex.y \n\
				) * u_value2;\n\
				return (sin(point.x) * sin(point.y)) * 4.0;\n\
			}\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				float average = (color.r + color.g + color.b) / 3.0;\n\
				gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\
			}\n";

        LGraphFXGeneric.pixel_shader_pixelate =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			\n\
			void main() {\n\
				vec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\n\
				vec4 color = texture2D(u_texture, coord);\n\
				gl_FragColor = color;\n\
			}\n";

        LGraphFXGeneric.pixel_shader_lowpalette =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_camera_planes;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				gl_FragColor = floor(color * u_value1) / u_value1;\n\
			}\n";

        LGraphFXGeneric.pixel_shader_noise =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform sampler2D u_noise;\n\
			uniform vec2 u_size;\n\
			uniform float u_value1;\n\
			uniform float u_value2;\n\
			uniform vec2 u_rand;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				vec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\n\
				gl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\n\
			}\n";

        LGraphFXGeneric.pixel_shader_gamma =
            "precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform float u_value1;\n\
			\n\
			void main() {\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				float gamma = 1.0 / u_value1;\n\
				gl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\n\
			}\n";

        LiteGraph.registerNodeType("fx/generic", LGraphFXGeneric);
        global.LGraphFXGeneric = LGraphFXGeneric;

        // Vigneting ************************************

        function LGraphFXVigneting() {
            this.addInput("Tex.", "Texture");
            this.addInput("intensity", "number");

            this.addOutput("Texture", "Texture");
            this.properties = {
                intensity: 1,
                invert: false,
                precision: LGraphTexture.DEFAULT
            };

            if (!LGraphFXVigneting._shader) {
                LGraphFXVigneting._shader = new GL.Shader(
                    Shader.SCREEN_VERTEX_SHADER,
                    LGraphFXVigneting.pixel_shader
                );
            }
        }

        LGraphFXVigneting.title = "Vigneting";
        LGraphFXVigneting.desc = "Vigneting";

        LGraphFXVigneting.widgets_info = {
            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
        };

        LGraphFXVigneting.prototype.onExecute = function() {
            var tex = this.getInputData(0);

            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
                this.setOutputData(0, tex);
                return;
            }

            if (!tex) {
                return;
            }

            this._tex = LGraphTexture.getTargetTexture(
                tex,
                this._tex,
                this.properties.precision
            );

            var intensity = this.properties.intensity;
            if (this.isInputConnected(1)) {
                intensity = this.getInputData(1);
                this.properties.intensity = intensity;
            }

            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);

            var mesh = Mesh.getScreenQuad();
            var shader = LGraphFXVigneting._shader;
            var invert = this.properties.invert;

            this._tex.drawTo(function() {
                tex.bind(0);
                shader
                    .uniforms({
                        u_texture: 0,
                        u_intensity: intensity,
                        u_isize: [1 / tex.width, 1 / tex.height],
                        u_invert: invert ? 1 : 0
                    })
                    .draw(mesh);
            });

            this.setOutputData(0, this._tex);
        };

        LGraphFXVigneting.pixel_shader =
            "precision highp float;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform float u_intensity;\n\
			uniform int u_invert;\n\
			\n\
			void main() {\n\
				float luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\n\
				vec4 color = texture2D(u_texture, v_coord);\n\
				if(u_invert == 1)\n\
					luminance = 1.0 - luminance;\n\
				luminance = mix(1.0, luminance, u_intensity);\n\
			   gl_FragColor = vec4( luminance * color.xyz, color.a);\n\
			}\n\
			";

        LiteGraph.registerNodeType("fx/vigneting", LGraphFXVigneting);
        global.LGraphFXVigneting = LGraphFXVigneting;
    }
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;
    var MIDI_COLOR = "#243";

    function MIDIEvent(data) {
        this.channel = 0;
        this.cmd = 0;
        this.data = new Uint32Array(3);

        if (data) {
            this.setup(data);
        }
    }

    LiteGraph.MIDIEvent = MIDIEvent;

    MIDIEvent.prototype.fromJSON = function(o) {
        this.setup(o.data);
    };

    MIDIEvent.prototype.setup = function(data) {
        var raw_data = data;
        if (data.constructor === Object) {
            raw_data = data.data;
        }

        this.data.set(raw_data);

        var midiStatus = raw_data[0];
        this.status = midiStatus;

        var midiCommand = midiStatus & 0xf0;

        if (midiStatus >= 0xf0) {
            this.cmd = midiStatus;
        } else {
            this.cmd = midiCommand;
        }

        if (this.cmd == MIDIEvent.NOTEON && this.velocity == 0) {
            this.cmd = MIDIEvent.NOTEOFF;
        }

        this.cmd_str = MIDIEvent.commands[this.cmd] || "";

        if (
            midiCommand >= MIDIEvent.NOTEON ||
            midiCommand <= MIDIEvent.NOTEOFF
        ) {
            this.channel = midiStatus & 0x0f;
        }
    };

    Object.defineProperty(MIDIEvent.prototype, "velocity", {
        get: function() {
            if (this.cmd == MIDIEvent.NOTEON) {
                return this.data[2];
            }
            return -1;
        },
        set: function(v) {
            this.data[2] = v; //  v / 127;
        },
        enumerable: true
    });

    MIDIEvent.notes = [
        "A",
        "A#",
        "B",
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#"
    ];
    MIDIEvent.note_to_index = {
        A: 0,
        "A#": 1,
        B: 2,
        C: 3,
        "C#": 4,
        D: 5,
        "D#": 6,
        E: 7,
        F: 8,
        "F#": 9,
        G: 10,
        "G#": 11
    };

    Object.defineProperty(MIDIEvent.prototype, "note", {
        get: function() {
            if (this.cmd != MIDIEvent.NOTEON) {
                return -1;
            }
            return MIDIEvent.toNoteString(this.data[1], true);
        },
        set: function(v) {
            throw "notes cannot be assigned this way, must modify the data[1]";
        },
        enumerable: true
    });

    Object.defineProperty(MIDIEvent.prototype, "octave", {
        get: function() {
            if (this.cmd != MIDIEvent.NOTEON) {
                return -1;
            }
            var octave = this.data[1] - 24;
            return Math.floor(octave / 12 + 1);
        },
        set: function(v) {
            throw "octave cannot be assigned this way, must modify the data[1]";
        },
        enumerable: true
    });

    //returns HZs
    MIDIEvent.prototype.getPitch = function() {
        return Math.pow(2, (this.data[1] - 69) / 12) * 440;
    };

    MIDIEvent.computePitch = function(note) {
        return Math.pow(2, (note - 69) / 12) * 440;
    };

    MIDIEvent.prototype.getCC = function() {
        return this.data[1];
    };

    MIDIEvent.prototype.getCCValue = function() {
        return this.data[2];
    };

    //not tested, there is a formula missing here
    MIDIEvent.prototype.getPitchBend = function() {
        return this.data[1] + (this.data[2] << 7) - 8192;
    };

    MIDIEvent.computePitchBend = function(v1, v2) {
        return v1 + (v2 << 7) - 8192;
    };

    MIDIEvent.prototype.setCommandFromString = function(str) {
        this.cmd = MIDIEvent.computeCommandFromString(str);
    };

    MIDIEvent.computeCommandFromString = function(str) {
        if (!str) {
            return 0;
        }

        if (str && str.constructor === Number) {
            return str;
        }

        str = str.toUpperCase();
        switch (str) {
            case "NOTE ON":
            case "NOTEON":
                return MIDIEvent.NOTEON;
                break;
            case "NOTE OFF":
            case "NOTEOFF":
                return MIDIEvent.NOTEON;
                break;
            case "KEY PRESSURE":
            case "KEYPRESSURE":
                return MIDIEvent.KEYPRESSURE;
                break;
            case "CONTROLLER CHANGE":
            case "CONTROLLERCHANGE":
            case "CC":
                return MIDIEvent.CONTROLLERCHANGE;
                break;
            case "PROGRAM CHANGE":
            case "PROGRAMCHANGE":
            case "PC":
                return MIDIEvent.PROGRAMCHANGE;
                break;
            case "CHANNEL PRESSURE":
            case "CHANNELPRESSURE":
                return MIDIEvent.CHANNELPRESSURE;
                break;
            case "PITCH BEND":
            case "PITCHBEND":
                return MIDIEvent.PITCHBEND;
                break;
            case "TIME TICK":
            case "TIMETICK":
                return MIDIEvent.TIMETICK;
                break;
            default:
                return Number(str); //asume its a hex code
        }
    };

    //transform from a pitch number to string like "C4"
    MIDIEvent.toNoteString = function(d, skip_octave) {
        d = Math.round(d); //in case it has decimals
        var note = d - 21;
        var octave = Math.floor((d - 24) / 12 + 1);
        note = note % 12;
        if (note < 0) {
            note = 12 + note;
        }
        return MIDIEvent.notes[note] + (skip_octave ? "" : octave);
    };

    MIDIEvent.NoteStringToPitch = function(str) {
        str = str.toUpperCase();
        var note = str[0];
        var octave = 4;

        if (str[1] == "#") {
            note += "#";
            if (str.length > 2) {
                octave = Number(str[2]);
            }
        } else {
            if (str.length > 1) {
                octave = Number(str[1]);
            }
        }
        var pitch = MIDIEvent.note_to_index[note];
        if (pitch == null) {
            return null;
        }
        return (octave - 1) * 12 + pitch + 21;
    };

    MIDIEvent.prototype.toString = function() {
        var str = "" + this.channel + ". ";
        switch (this.cmd) {
            case MIDIEvent.NOTEON:
                str += "NOTEON " + MIDIEvent.toNoteString(this.data[1]);
                break;
            case MIDIEvent.NOTEOFF:
                str += "NOTEOFF " + MIDIEvent.toNoteString(this.data[1]);
                break;
            case MIDIEvent.CONTROLLERCHANGE:
                str += "CC " + this.data[1] + " " + this.data[2];
                break;
            case MIDIEvent.PROGRAMCHANGE:
                str += "PC " + this.data[1];
                break;
            case MIDIEvent.PITCHBEND:
                str += "PITCHBEND " + this.getPitchBend();
                break;
            case MIDIEvent.KEYPRESSURE:
                str += "KEYPRESS " + this.data[1];
                break;
        }

        return str;
    };

    MIDIEvent.prototype.toHexString = function() {
        var str = "";
        for (var i = 0; i < this.data.length; i++) {
            str += this.data[i].toString(16) + " ";
        }
    };

    MIDIEvent.prototype.toJSON = function() {
        return {
            data: [this.data[0], this.data[1], this.data[2]],
            object_class: "MIDIEvent"
        };
    };

    MIDIEvent.NOTEOFF = 0x80;
    MIDIEvent.NOTEON = 0x90;
    MIDIEvent.KEYPRESSURE = 0xa0;
    MIDIEvent.CONTROLLERCHANGE = 0xb0;
    MIDIEvent.PROGRAMCHANGE = 0xc0;
    MIDIEvent.CHANNELPRESSURE = 0xd0;
    MIDIEvent.PITCHBEND = 0xe0;
    MIDIEvent.TIMETICK = 0xf8;

    MIDIEvent.commands = {
        0x80: "note off",
        0x90: "note on",
        0xa0: "key pressure",
        0xb0: "controller change",
        0xc0: "program change",
        0xd0: "channel pressure",
        0xe0: "pitch bend",
        0xf0: "system",
        0xf2: "Song pos",
        0xf3: "Song select",
        0xf6: "Tune request",
        0xf8: "time tick",
        0xfa: "Start Song",
        0xfb: "Continue Song",
        0xfc: "Stop Song",
        0xfe: "Sensing",
        0xff: "Reset"
    };

    MIDIEvent.commands_short = {
        0x80: "NOTEOFF",
        0x90: "NOTEOFF",
        0xa0: "KEYP",
        0xb0: "CC",
        0xc0: "PC",
        0xd0: "CP",
        0xe0: "PB",
        0xf0: "SYS",
        0xf2: "POS",
        0xf3: "SELECT",
        0xf6: "TUNEREQ",
        0xf8: "TT",
        0xfa: "START",
        0xfb: "CONTINUE",
        0xfc: "STOP",
        0xfe: "SENS",
        0xff: "RESET"
    };

    MIDIEvent.commands_reversed = {};
    for (var i in MIDIEvent.commands) {
        MIDIEvent.commands_reversed[MIDIEvent.commands[i]] = i;
    }

    //MIDI wrapper, instantiate by MIDIIn and MIDIOut
    function MIDIInterface(on_ready, on_error) {
        if (!navigator.requestMIDIAccess) {
            this.error = "not suppoorted";
            if (on_error) {
                on_error("Not supported");
            } else {
                console.error("MIDI NOT SUPPORTED, enable by chrome://flags");
            }
            return;
        }

        this.on_ready = on_ready;

        this.state = {
            note: [],
            cc: []
        };

		this.input_ports = null;
		this.input_ports_info = [];
		this.output_ports = null;
		this.output_ports_info = [];

        navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));
    }

    MIDIInterface.input = null;

    MIDIInterface.MIDIEvent = MIDIEvent;

    MIDIInterface.prototype.onMIDISuccess = function(midiAccess) {
        console.log("MIDI ready!");
        console.log(midiAccess);
        this.midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
        this.updatePorts();

        if (this.on_ready) {
            this.on_ready(this);
        }
    };

    MIDIInterface.prototype.updatePorts = function() {
        var midi = this.midi;
        this.input_ports = midi.inputs;
		this.input_ports_info = [];
        this.output_ports = midi.outputs;
		this.output_ports_info = [];

        var num = 0;

        var it = this.input_ports.values();
        var it_value = it.next();
        while (it_value && it_value.done === false) {
            var port_info = it_value.value;
			this.input_ports_info.push(port_info);
            console.log( "Input port [type:'" + port_info.type + "'] id:'" + port_info.id + "' manufacturer:'" + port_info.manufacturer + "' name:'" + port_info.name + "' version:'" + port_info.version + "'" );
            num++;
            it_value = it.next();
        }
        this.num_input_ports = num;

        num = 0;
        var it = this.output_ports.values();
        var it_value = it.next();
        while (it_value && it_value.done === false) {
            var port_info = it_value.value;
			this.output_ports_info.push(port_info);
            console.log( "Output port [type:'" + port_info.type + "'] id:'" + port_info.id + "' manufacturer:'" + port_info.manufacturer + "' name:'" + port_info.name + "' version:'" + port_info.version + "'" );
            num++;
            it_value = it.next();
        }
        this.num_output_ports = num;
    };

    MIDIInterface.prototype.onMIDIFailure = function(msg) {
        console.error("Failed to get MIDI access - " + msg);
    };

    MIDIInterface.prototype.openInputPort = function(port, callback) {
        var input_port = this.input_ports.get("input-" + port);
        if (!input_port) {
            return false;
        }
        MIDIInterface.input = this;
        var that = this;

        input_port.onmidimessage = function(a) {
            var midi_event = new MIDIEvent(a.data);
            that.updateState(midi_event);
            if (callback) {
                callback(a.data, midi_event);
            }
            if (MIDIInterface.on_message) {
                MIDIInterface.on_message(a.data, midi_event);
            }
        };
        console.log("port open: ", input_port);
        return true;
    };

    MIDIInterface.parseMsg = function(data) {};

    MIDIInterface.prototype.updateState = function(midi_event) {
        switch (midi_event.cmd) {
            case MIDIEvent.NOTEON:
                this.state.note[midi_event.value1 | 0] = midi_event.value2;
                break;
            case MIDIEvent.NOTEOFF:
                this.state.note[midi_event.value1 | 0] = 0;
                break;
            case MIDIEvent.CONTROLLERCHANGE:
                this.state.cc[midi_event.getCC()] = midi_event.getCCValue();
                break;
        }
    };

    MIDIInterface.prototype.sendMIDI = function(port, midi_data) {
        if (!midi_data) {
            return;
        }

        var output_port = this.output_ports_info[port];//this.output_ports.get("output-" + port);
        if (!output_port) {
            return;
        }

        MIDIInterface.output = this;

        if (midi_data.constructor === MIDIEvent) {
            output_port.send(midi_data.data);
        } else {
            output_port.send(midi_data);
        }
    };

    function LGMIDIIn() {
        this.addOutput("on_midi", LiteGraph.EVENT);
        this.addOutput("out", "midi");
        this.properties = { port: 0 };
        this._last_midi_event = null;
        this._current_midi_event = null;
        this.boxcolor = "#AAA";
        this._last_time = 0;

        var that = this;
        new MIDIInterface(function(midi) {
            //open
            that._midi = midi;
            if (that._waiting) {
                that.onStart();
            }
            that._waiting = false;
        });
    }

    LGMIDIIn.MIDIInterface = MIDIInterface;

    LGMIDIIn.title = "MIDI Input";
    LGMIDIIn.desc = "Reads MIDI from a input port";
    LGMIDIIn.color = MIDI_COLOR;

    LGMIDIIn.prototype.getPropertyInfo = function(name) {
        if (!this._midi) {
            return;
        }

        if (name == "port") {
            var values = {};
            for (var i = 0; i < this._midi.input_ports_info.length; ++i) {
                var input = this._midi.input_ports_info[i];
                values[i] = i + ".- " + input.name + " version:" + input.version;
            }
            return { type: "enum", values: values };
        }
    };

    LGMIDIIn.prototype.onStart = function() {
        if (this._midi) {
            this._midi.openInputPort(
                this.properties.port,
                this.onMIDIEvent.bind(this)
            );
        } else {
            this._waiting = true;
        }
    };

    LGMIDIIn.prototype.onMIDIEvent = function(data, midi_event) {
        this._last_midi_event = midi_event;
        this.boxcolor = "#AFA";
        this._last_time = LiteGraph.getTime();
        this.trigger("on_midi", midi_event);
        if (midi_event.cmd == MIDIEvent.NOTEON) {
            this.trigger("on_noteon", midi_event);
        } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {
            this.trigger("on_noteoff", midi_event);
        } else if (midi_event.cmd == MIDIEvent.CONTROLLERCHANGE) {
            this.trigger("on_cc", midi_event);
        } else if (midi_event.cmd == MIDIEvent.PROGRAMCHANGE) {
            this.trigger("on_pc", midi_event);
        } else if (midi_event.cmd == MIDIEvent.PITCHBEND) {
            this.trigger("on_pitchbend", midi_event);
        }
    };

    LGMIDIIn.prototype.onDrawBackground = function(ctx) {
        this.boxcolor = "#AAA";
        if (!this.flags.collapsed && this._last_midi_event) {
            ctx.fillStyle = "white";
            var now = LiteGraph.getTime();
            var f = 1.0 - Math.max(0, (now - this._last_time) * 0.001);
            if (f > 0) {
                var t = ctx.globalAlpha;
                ctx.globalAlpha *= f;
                ctx.font = "12px Tahoma";
                ctx.fillText(
                    this._last_midi_event.toString(),
                    2,
                    this.size[1] * 0.5 + 3
                );
                //ctx.fillRect(0,0,this.size[0],this.size[1]);
                ctx.globalAlpha = t;
            }
        }
    };

    LGMIDIIn.prototype.onExecute = function() {
        if (this.outputs) {
            var last = this._last_midi_event;
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                var v = null;
                switch (output.name) {
                    case "midi":
                        v = this._midi;
                        break;
                    case "last_midi":
                        v = last;
                        break;
                    default:
                        continue;
                }
                this.setOutputData(i, v);
            }
        }
    };

    LGMIDIIn.prototype.onGetOutputs = function() {
        return [
            ["last_midi", "midi"],
            ["on_midi", LiteGraph.EVENT],
            ["on_noteon", LiteGraph.EVENT],
            ["on_noteoff", LiteGraph.EVENT],
            ["on_cc", LiteGraph.EVENT],
            ["on_pc", LiteGraph.EVENT],
            ["on_pitchbend", LiteGraph.EVENT]
        ];
    };

    LiteGraph.registerNodeType("midi/input", LGMIDIIn);

    function LGMIDIOut() {
        this.addInput("send", LiteGraph.EVENT);
        this.properties = { port: 0 };

        var that = this;
        new MIDIInterface(function(midi) {
            that._midi = midi;
			that.widget.options.values = that.getMIDIOutputs();
        });
		this.widget = this.addWidget("combo","Device",this.properties.port,{ property: "port", values: this.getMIDIOutputs.bind(this) });
		this.size = [340,60];
    }

    LGMIDIOut.MIDIInterface = MIDIInterface;

    LGMIDIOut.title = "MIDI Output";
    LGMIDIOut.desc = "Sends MIDI to output channel";
    LGMIDIOut.color = MIDI_COLOR;

    LGMIDIOut.prototype.onGetPropertyInfo = function(name) {
        if (!this._midi) {
            return;
        }

        if (name == "port") {
			var values = this.getMIDIOutputs();
            return { type: "enum", values: values };
        }
    };
	LGMIDIOut.default_ports = {0:"unknown"};

	LGMIDIOut.prototype.getMIDIOutputs = function()
	{
		var values = {};
		if(!this._midi)
			return LGMIDIOut.default_ports;
		if(this._midi.output_ports_info)
		for (var i = 0; i < this._midi.output_ports_info.length; ++i) {
			var output = this._midi.output_ports_info[i];
			if(!output)
				continue;
			var name = i + ".- " + output.name + " version:" + output.version;
			values[i] = name;
		}
		return values;
	}

    LGMIDIOut.prototype.onAction = function(event, midi_event) {
        //console.log(midi_event);
        if (!this._midi) {
            return;
        }
        if (event == "send") {
            this._midi.sendMIDI(this.properties.port, midi_event);
        }
        this.trigger("midi", midi_event);
    };

    LGMIDIOut.prototype.onGetInputs = function() {
        return [["send", LiteGraph.ACTION]];
    };

    LGMIDIOut.prototype.onGetOutputs = function() {
        return [["on_midi", LiteGraph.EVENT]];
    };

    LiteGraph.registerNodeType("midi/output", LGMIDIOut);


    function LGMIDIShow() {
        this.addInput("on_midi", LiteGraph.EVENT);
        this._str = "";
        this.size = [200, 40];
    }

    LGMIDIShow.title = "MIDI Show";
    LGMIDIShow.desc = "Shows MIDI in the graph";
    LGMIDIShow.color = MIDI_COLOR;

    LGMIDIShow.prototype.getTitle = function() {
        if (this.flags.collapsed) {
            return this._str;
        }
        return this.title;
    };

    LGMIDIShow.prototype.onAction = function(event, midi_event) {
        if (!midi_event) {
            return;
        }
        if (midi_event.constructor === MIDIEvent) {
            this._str = midi_event.toString();
        } else {
            this._str = "???";
        }
    };

    LGMIDIShow.prototype.onDrawForeground = function(ctx) {
        if (!this._str || this.flags.collapsed) {
            return;
        }

        ctx.font = "30px Arial";
        ctx.fillText(this._str, 10, this.size[1] * 0.8);
    };

    LGMIDIShow.prototype.onGetInputs = function() {
        return [["in", LiteGraph.ACTION]];
    };

    LGMIDIShow.prototype.onGetOutputs = function() {
        return [["on_midi", LiteGraph.EVENT]];
    };

    LiteGraph.registerNodeType("midi/show", LGMIDIShow);

    function LGMIDIFilter() {
        this.properties = {
            channel: -1,
            cmd: -1,
            min_value: -1,
            max_value: -1
        };

        var that = this;
        this._learning = false;
        this.addWidget("button", "Learn", "", function() {
            that._learning = true;
            that.boxcolor = "#FA3";
        });

        this.addInput("in", LiteGraph.EVENT);
        this.addOutput("on_midi", LiteGraph.EVENT);
        this.boxcolor = "#AAA";
    }

    LGMIDIFilter.title = "MIDI Filter";
    LGMIDIFilter.desc = "Filters MIDI messages";
    LGMIDIFilter.color = MIDI_COLOR;

    LGMIDIFilter["@cmd"] = {
        type: "enum",
        title: "Command",
        values: MIDIEvent.commands_reversed
    };

    LGMIDIFilter.prototype.getTitle = function() {
        var str = null;
        if (this.properties.cmd == -1) {
            str = "Nothing";
        } else {
            str = MIDIEvent.commands_short[this.properties.cmd] || "Unknown";
        }

        if (
            this.properties.min_value != -1 &&
            this.properties.max_value != -1
        ) {
            str +=
                " " +
                (this.properties.min_value == this.properties.max_value
                    ? this.properties.max_value
                    : this.properties.min_value +
                      ".." +
                      this.properties.max_value);
        }

        return "Filter: " + str;
    };

    LGMIDIFilter.prototype.onPropertyChanged = function(name, value) {
        if (name == "cmd") {
            var num = Number(value);
            if (isNaN(num)) {
                num = MIDIEvent.commands[value] || 0;
            }
            this.properties.cmd = num;
        }
    };

    LGMIDIFilter.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (this._learning) {
            this._learning = false;
            this.boxcolor = "#AAA";
            this.properties.channel = midi_event.channel;
            this.properties.cmd = midi_event.cmd;
            this.properties.min_value = this.properties.max_value =
                midi_event.data[1];
        } else {
            if (
                this.properties.channel != -1 &&
                midi_event.channel != this.properties.channel
            ) {
                return;
            }
            if (
                this.properties.cmd != -1 &&
                midi_event.cmd != this.properties.cmd
            ) {
                return;
            }
            if (
                this.properties.min_value != -1 &&
                midi_event.data[1] < this.properties.min_value
            ) {
                return;
            }
            if (
                this.properties.max_value != -1 &&
                midi_event.data[1] > this.properties.max_value
            ) {
                return;
            }
        }

        this.trigger("on_midi", midi_event);
    };

    LiteGraph.registerNodeType("midi/filter", LGMIDIFilter);

    function LGMIDIEvent() {
        this.properties = {
            channel: 0,
            cmd: 144, //0x90
            value1: 1,
            value2: 1
        };

        this.addInput("send", LiteGraph.EVENT);
        this.addInput("assign", LiteGraph.EVENT);
        this.addOutput("on_midi", LiteGraph.EVENT);

        this.midi_event = new MIDIEvent();
        this.gate = false;
    }

    LGMIDIEvent.title = "MIDIEvent";
    LGMIDIEvent.desc = "Create a MIDI Event";
    LGMIDIEvent.color = MIDI_COLOR;

    LGMIDIEvent.prototype.onAction = function(event, midi_event) {
        if (event == "assign") {
            this.properties.channel = midi_event.channel;
            this.properties.cmd = midi_event.cmd;
            this.properties.value1 = midi_event.data[1];
            this.properties.value2 = midi_event.data[2];
            if (midi_event.cmd == MIDIEvent.NOTEON) {
                this.gate = true;
            } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {
                this.gate = false;
            }
            return;
        }

        //send
        var midi_event = this.midi_event;
        midi_event.channel = this.properties.channel;
        if (this.properties.cmd && this.properties.cmd.constructor === String) {
            midi_event.setCommandFromString(this.properties.cmd);
        } else {
            midi_event.cmd = this.properties.cmd;
        }
        midi_event.data[0] = midi_event.cmd | midi_event.channel;
        midi_event.data[1] = Number(this.properties.value1);
        midi_event.data[2] = Number(this.properties.value2);

        this.trigger("on_midi", midi_event);
    };

    LGMIDIEvent.prototype.onExecute = function() {
        var props = this.properties;

        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == -1) {
                    continue;
                }
                switch (input.name) {
                    case "note":
                        var v = this.getInputData(i);
                        if (v != null) {
                            if (v.constructor === String) {
                                v = MIDIEvent.NoteStringToPitch(v);
                            }
                            this.properties.value1 = (v | 0) % 255;
                        }
                        break;
                    case "cmd":
                        var v = this.getInputData(i);
                        if (v != null) {
                            this.properties.cmd = v;
                        }
                        break;
                    case "value1":
                        var v = this.getInputData(i);
                        if (v != null) {
                            this.properties.value1 = Math.clamp(v|0,0,127);
                        }
                        break;
                    case "value2":
                        var v = this.getInputData(i);
                        if (v != null) {
                            this.properties.value2 = Math.clamp(v|0,0,127);
                        }
                        break;
                }
            }
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                var v = null;
                switch (output.name) {
                    case "midi":
                        v = new MIDIEvent();
                        v.setup([props.cmd, props.value1, props.value2]);
                        v.channel = props.channel;
                        break;
                    case "command":
                        v = props.cmd;
                        break;
                    case "cc":
                        v = props.value1;
                        break;
                    case "cc_value":
                        v = props.value2;
                        break;
                    case "note":
                        v =
                            props.cmd == MIDIEvent.NOTEON ||
                            props.cmd == MIDIEvent.NOTEOFF
                                ? props.value1
                                : null;
                        break;
                    case "velocity":
                        v = props.cmd == MIDIEvent.NOTEON ? props.value2 : null;
                        break;
                    case "pitch":
                        v =
                            props.cmd == MIDIEvent.NOTEON
                                ? MIDIEvent.computePitch(props.value1)
                                : null;
                        break;
                    case "pitchbend":
                        v =
                            props.cmd == MIDIEvent.PITCHBEND
                                ? MIDIEvent.computePitchBend(
                                      props.value1,
                                      props.value2
                                  )
                                : null;
                        break;
                    case "gate":
                        v = this.gate;
                        break;
                    default:
                        continue;
                }
                if (v !== null) {
                    this.setOutputData(i, v);
                }
            }
        }
    };

    LGMIDIEvent.prototype.onPropertyChanged = function(name, value) {
        if (name == "cmd") {
            this.properties.cmd = MIDIEvent.computeCommandFromString(value);
        }
    };

    LGMIDIEvent.prototype.onGetInputs = function() {
        return [["cmd", "number"],["note", "number"],["value1", "number"],["value2", "number"]];
    };

    LGMIDIEvent.prototype.onGetOutputs = function() {
        return [
            ["midi", "midi"],
            ["on_midi", LiteGraph.EVENT],
            ["command", "number"],
            ["note", "number"],
            ["velocity", "number"],
            ["cc", "number"],
            ["cc_value", "number"],
            ["pitch", "number"],
            ["gate", "bool"],
            ["pitchbend", "number"]
        ];
    };

    LiteGraph.registerNodeType("midi/event", LGMIDIEvent);

    function LGMIDICC() {
        this.properties = {
            //		channel: 0,
            cc: 1,
            value: 0
        };

        this.addOutput("value", "number");
    }

    LGMIDICC.title = "MIDICC";
    LGMIDICC.desc = "gets a Controller Change";
    LGMIDICC.color = MIDI_COLOR;

    LGMIDICC.prototype.onExecute = function() {
        var props = this.properties;
        if (MIDIInterface.input) {
            this.properties.value =
                MIDIInterface.input.state.cc[this.properties.cc];
        }
        this.setOutputData(0, this.properties.value);
    };

    LiteGraph.registerNodeType("midi/cc", LGMIDICC);

    function LGMIDIGenerator() {
        this.addInput("generate", LiteGraph.ACTION);
        this.addInput("scale", "string");
        this.addInput("octave", "number");
        this.addOutput("note", LiteGraph.EVENT);
        this.properties = {
            notes: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#",
            octave: 2,
            duration: 0.5,
            mode: "sequence"
        };

        this.notes_pitches = LGMIDIGenerator.processScale(
            this.properties.notes
        );
        this.sequence_index = 0;
    }

    LGMIDIGenerator.title = "MIDI Generator";
    LGMIDIGenerator.desc = "Generates a random MIDI note";
    LGMIDIGenerator.color = MIDI_COLOR;

    LGMIDIGenerator.processScale = function(scale) {
        var notes = scale.split(",");
        for (var i = 0; i < notes.length; ++i) {
            var n = notes[i];
            if ((n.length == 2 && n[1] != "#") || n.length > 2) {
                notes[i] = -LiteGraph.MIDIEvent.NoteStringToPitch(n);
            } else {
                notes[i] = MIDIEvent.note_to_index[n] || 0;
            }
        }
        return notes;
    };

    LGMIDIGenerator.prototype.onPropertyChanged = function(name, value) {
        if (name == "notes") {
            this.notes_pitches = LGMIDIGenerator.processScale(value);
        }
    };

    LGMIDIGenerator.prototype.onExecute = function() {
        var octave = this.getInputData(2);
        if (octave != null) {
            this.properties.octave = octave;
        }

        var scale = this.getInputData(1);
        if (scale) {
            this.notes_pitches = LGMIDIGenerator.processScale(scale);
        }
    };

    LGMIDIGenerator.prototype.onAction = function(event, midi_event) {
        //var range = this.properties.max - this.properties.min;
        //var pitch = this.properties.min + ((Math.random() * range)|0);
        var pitch = 0;
        var range = this.notes_pitches.length;
        var index = 0;

        if (this.properties.mode == "sequence") {
            index = this.sequence_index = (this.sequence_index + 1) % range;
        } else if (this.properties.mode == "random") {
            index = Math.floor(Math.random() * range);
        }

        var note = this.notes_pitches[index];
        if (note >= 0) {
            pitch = note + (this.properties.octave - 1) * 12 + 33;
        } else {
            pitch = -note;
        }

        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 10]);
        var duration = this.properties.duration || 1;
        this.trigger("note", midi_event);

        //noteoff
        setTimeout(
            function() {
                var midi_event = new MIDIEvent();
                midi_event.setup([MIDIEvent.NOTEOFF, pitch, 0]);
                this.trigger("note", midi_event);
            }.bind(this),
            duration * 1000
        );
    };

    LiteGraph.registerNodeType("midi/generator", LGMIDIGenerator);

    function LGMIDITranspose() {
        this.properties = {
            amount: 0
        };
        this.addInput("in", LiteGraph.ACTION);
        this.addInput("amount", "number");
        this.addOutput("out", LiteGraph.EVENT);

        this.midi_event = new MIDIEvent();
    }

    LGMIDITranspose.title = "MIDI Transpose";
    LGMIDITranspose.desc = "Transpose a MIDI note";
    LGMIDITranspose.color = MIDI_COLOR;

    LGMIDITranspose.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (
            midi_event.data[0] == MIDIEvent.NOTEON ||
            midi_event.data[0] == MIDIEvent.NOTEOFF
        ) {
            this.midi_event = new MIDIEvent();
            this.midi_event.setup(midi_event.data);
            this.midi_event.data[1] = Math.round(
                this.midi_event.data[1] + this.properties.amount
            );
            this.trigger("out", this.midi_event);
        } else {
            this.trigger("out", midi_event);
        }
    };

    LGMIDITranspose.prototype.onExecute = function() {
        var amount = this.getInputData(1);
        if (amount != null) {
            this.properties.amount = amount;
        }
    };

    LiteGraph.registerNodeType("midi/transpose", LGMIDITranspose);

    function LGMIDIQuantize() {
        this.properties = {
            scale: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#"
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("scale", "string");
        this.addOutput("out", LiteGraph.EVENT);

        this.valid_notes = new Array(12);
        this.offset_notes = new Array(12);
        this.processScale(this.properties.scale);
    }

    LGMIDIQuantize.title = "MIDI Quantize Pitch";
    LGMIDIQuantize.desc = "Transpose a MIDI note tp fit an scale";
    LGMIDIQuantize.color = MIDI_COLOR;

    LGMIDIQuantize.prototype.onPropertyChanged = function(name, value) {
        if (name == "scale") {
            this.processScale(value);
        }
    };

    LGMIDIQuantize.prototype.processScale = function(scale) {
        this._current_scale = scale;
        this.notes_pitches = LGMIDIGenerator.processScale(scale);
        for (var i = 0; i < 12; ++i) {
            this.valid_notes[i] = this.notes_pitches.indexOf(i) != -1;
        }
        for (var i = 0; i < 12; ++i) {
            if (this.valid_notes[i]) {
                this.offset_notes[i] = 0;
                continue;
            }
            for (var j = 1; j < 12; ++j) {
                if (this.valid_notes[(i - j) % 12]) {
                    this.offset_notes[i] = -j;
                    break;
                }
                if (this.valid_notes[(i + j) % 12]) {
                    this.offset_notes[i] = j;
                    break;
                }
            }
        }
    };

    LGMIDIQuantize.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (
            midi_event.data[0] == MIDIEvent.NOTEON ||
            midi_event.data[0] == MIDIEvent.NOTEOFF
        ) {
            this.midi_event = new MIDIEvent();
            this.midi_event.setup(midi_event.data);
            var note = midi_event.note;
            var index = MIDIEvent.note_to_index[note];
            var offset = this.offset_notes[index];
            this.midi_event.data[1] += offset;
            this.trigger("out", this.midi_event);
        } else {
            this.trigger("out", midi_event);
        }
    };

    LGMIDIQuantize.prototype.onExecute = function() {
        var scale = this.getInputData(1);
        if (scale != null && scale != this._current_scale) {
            this.processScale(scale);
        }
    };

    LiteGraph.registerNodeType("midi/quantize", LGMIDIQuantize);

	function LGMIDIFromFile() {
        this.properties = {
            url: "",
			autoplay: true
        };

        this.addInput("play", LiteGraph.ACTION);
        this.addInput("pause", LiteGraph.ACTION);
        this.addOutput("note", LiteGraph.EVENT);
		this._midi = null;
		this._current_time = 0;
		this._playing = false;

        if (typeof MidiParser == "undefined") {
            console.error(
                "midi-parser.js not included, LGMidiPlay requires that library: https://raw.githubusercontent.com/colxi/midi-parser-js/master/src/main.js"
            );
            this.boxcolor = "red";
		}

	}

    LGMIDIFromFile.title = "MIDI fromFile";
    LGMIDIFromFile.desc = "Plays a MIDI file";
    LGMIDIFromFile.color = MIDI_COLOR;

	LGMIDIFromFile.prototype.onAction = function( name )
	{
		if(name == "play")
			this.play();
		else if(name == "pause")
			this._playing = !this._playing;
	}

	LGMIDIFromFile.prototype.onPropertyChanged = function(name,value)
	{
		if(name == "url")
			this.loadMIDIFile(value);
	}

    LGMIDIFromFile.prototype.onExecute = function() {
		if(!this._midi)
			return;

		if(!this._playing)
			return;

		this._current_time += this.graph.elapsed_time;
		var current_time = this._current_time * 100;

		for(var i = 0; i < this._midi.tracks; ++i)
		{
			var track = this._midi.track[i];
			if(!track._last_pos)
			{
				track._last_pos = 0;
				track._time = 0;
			}

			var elem = track.event[ track._last_pos ];
			if(elem && (track._time + elem.deltaTime) <= current_time )
			{
				track._last_pos++;
				track._time += elem.deltaTime;

				if(elem.data)
				{
					var midi_cmd = elem.type << 4 + elem.channel;
					var midi_event = new MIDIEvent();
					midi_event.setup([midi_cmd, elem.data[0], elem.data[1]]);
					this.trigger("note", midi_event);
				}
			}
			
		}
    };

	LGMIDIFromFile.prototype.play = function()
	{
		this._playing = true;
		this._current_time = 0;
		if(!this._midi)
			return;

		for(var i = 0; i < this._midi.tracks; ++i)
		{
			var track = this._midi.track[i];
			track._last_pos = 0;
			track._time = 0;
		}		
	}

	LGMIDIFromFile.prototype.loadMIDIFile = function(url)
	{
		var that = this;
		LiteGraph.fetchFile( url, "arraybuffer", function(data)
		{
			that.boxcolor = "#AFA";
			that._midi = MidiParser.parse( new Uint8Array(data) );
			if(that.properties.autoplay)
				that.play();
		}, function(err){
			that.boxcolor = "#FAA";
			that._midi = null;
		});
	}

	LGMIDIFromFile.prototype.onDropFile = function(file)
	{
		this.properties.url = "";
		this.loadMIDIFile( file );
	}

    LiteGraph.registerNodeType("midi/fromFile", LGMIDIFromFile);


    function LGMIDIPlay() {
        this.properties = {
            volume: 0.5,
            duration: 1
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("volume", "number");
        this.addInput("duration", "number");
        this.addOutput("note", LiteGraph.EVENT);

        if (typeof AudioSynth == "undefined") {
            console.error(
                "Audiosynth.js not included, LGMidiPlay requires that library"
            );
            this.boxcolor = "red";
        } else {
            var Synth = (this.synth = new AudioSynth());
            this.instrument = Synth.createInstrument("piano");
        }
    }

    LGMIDIPlay.title = "MIDI Play";
    LGMIDIPlay.desc = "Plays a MIDI note";
    LGMIDIPlay.color = MIDI_COLOR;

    LGMIDIPlay.prototype.onAction = function(event, midi_event) {
        if (!midi_event || midi_event.constructor !== MIDIEvent) {
            return;
        }

        if (this.instrument && midi_event.data[0] == MIDIEvent.NOTEON) {
            var note = midi_event.note; //C#
            if (!note || note == "undefined" || note.constructor !== String) {
                return;
            }
            this.instrument.play(
                note,
                midi_event.octave,
                this.properties.duration,
                this.properties.volume
            );
        }
        this.trigger("note", midi_event);
    };

    LGMIDIPlay.prototype.onExecute = function() {
        var volume = this.getInputData(1);
        if (volume != null) {
            this.properties.volume = volume;
        }

        var duration = this.getInputData(2);
        if (duration != null) {
            this.properties.duration = duration;
        }
    };

    LiteGraph.registerNodeType("midi/play", LGMIDIPlay);

    function LGMIDIKeys() {
        this.properties = {
            num_octaves: 2,
            start_octave: 2
        };
        this.addInput("note", LiteGraph.ACTION);
        this.addInput("reset", LiteGraph.ACTION);
        this.addOutput("note", LiteGraph.EVENT);
        this.size = [400, 100];
        this.keys = [];
        this._last_key = -1;
    }

    LGMIDIKeys.title = "MIDI Keys";
    LGMIDIKeys.desc = "Keyboard to play notes";
    LGMIDIKeys.color = MIDI_COLOR;

    LGMIDIKeys.keys = [
        { x: 0, w: 1, h: 1, t: 0 },
        { x: 0.75, w: 0.5, h: 0.6, t: 1 },
        { x: 1, w: 1, h: 1, t: 0 },
        { x: 1.75, w: 0.5, h: 0.6, t: 1 },
        { x: 2, w: 1, h: 1, t: 0 },
        { x: 2.75, w: 0.5, h: 0.6, t: 1 },
        { x: 3, w: 1, h: 1, t: 0 },
        { x: 4, w: 1, h: 1, t: 0 },
        { x: 4.75, w: 0.5, h: 0.6, t: 1 },
        { x: 5, w: 1, h: 1, t: 0 },
        { x: 5.75, w: 0.5, h: 0.6, t: 1 },
        { x: 6, w: 1, h: 1, t: 0 }
    ];

    LGMIDIKeys.prototype.onDrawForeground = function(ctx) {
        if (this.flags.collapsed) {
            return;
        }

        var num_keys = this.properties.num_octaves * 12;
        this.keys.length = num_keys;
        var key_width = this.size[0] / (this.properties.num_octaves * 7);
        var key_height = this.size[1];

        ctx.globalAlpha = 1;

        for (
            var k = 0;
            k < 2;
            k++ //draw first whites (0) then blacks (1)
        ) {
            for (var i = 0; i < num_keys; ++i) {
                var key_info = LGMIDIKeys.keys[i % 12];
                if (key_info.t != k) {
                    continue;
                }
                var octave = Math.floor(i / 12);
                var x = octave * 7 * key_width + key_info.x * key_width;
                if (k == 0) {
                    ctx.fillStyle = this.keys[i] ? "#CCC" : "white";
                } else {
                    ctx.fillStyle = this.keys[i] ? "#333" : "black";
                }
                ctx.fillRect(
                    x + 1,
                    0,
                    key_width * key_info.w - 2,
                    key_height * key_info.h
                );
            }
        }
    };

    LGMIDIKeys.prototype.getKeyIndex = function(pos) {
        var num_keys = this.properties.num_octaves * 12;
        var key_width = this.size[0] / (this.properties.num_octaves * 7);
        var key_height = this.size[1];

        for (
            var k = 1;
            k >= 0;
            k-- //test blacks first (1) then whites (0)
        ) {
            for (var i = 0; i < this.keys.length; ++i) {
                var key_info = LGMIDIKeys.keys[i % 12];
                if (key_info.t != k) {
                    continue;
                }
                var octave = Math.floor(i / 12);
                var x = octave * 7 * key_width + key_info.x * key_width;
                var w = key_width * key_info.w;
                var h = key_height * key_info.h;
                if (pos[0] < x || pos[0] > x + w || pos[1] > h) {
                    continue;
                }
                return i;
            }
        }
        return -1;
    };

    LGMIDIKeys.prototype.onAction = function(event, params) {
        if (event == "reset") {
            for (var i = 0; i < this.keys.length; ++i) {
                this.keys[i] = false;
            }
            return;
        }

        if (!params || params.constructor !== MIDIEvent) {
            return;
        }
        var midi_event = params;
        var start_note = (this.properties.start_octave - 1) * 12 + 29;
        var index = midi_event.data[1] - start_note;
        if (index >= 0 && index < this.keys.length) {
            if (midi_event.data[0] == MIDIEvent.NOTEON) {
                this.keys[index] = true;
            } else if (midi_event.data[0] == MIDIEvent.NOTEOFF) {
                this.keys[index] = false;
            }
        }

        this.trigger("note", midi_event);
    };

    LGMIDIKeys.prototype.onMouseDown = function(e, pos) {
        if (pos[1] < 0) {
            return;
        }
        var index = this.getKeyIndex(pos);
        this.keys[index] = true;
        this._last_key = index;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);
        this.trigger("note", midi_event);
        return true;
    };

    LGMIDIKeys.prototype.onMouseMove = function(e, pos) {
        if (pos[1] < 0 || this._last_key == -1) {
            return;
        }
        this.setDirtyCanvas(true);
        var index = this.getKeyIndex(pos);
        if (this._last_key == index) {
            return true;
        }
        this.keys[this._last_key] = false;
        var pitch =
            (this.properties.start_octave - 1) * 12 + 29 + this._last_key;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);
        this.trigger("note", midi_event);

        this.keys[index] = true;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);
        this.trigger("note", midi_event);

        this._last_key = index;
        return true;
    };

    LGMIDIKeys.prototype.onMouseUp = function(e, pos) {
        if (pos[1] < 0) {
            return;
        }
        var index = this.getKeyIndex(pos);
        this.keys[index] = false;
        this._last_key = -1;
        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;
        var midi_event = new MIDIEvent();
        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);
        this.trigger("note", midi_event);
        return true;
    };

    LiteGraph.registerNodeType("midi/keys", LGMIDIKeys);

    function now() {
        return window.performance.now();
    }
})(this);

(function(global) {
    var LiteGraph = global.LiteGraph;

    var LGAudio = {};
    global.LGAudio = LGAudio;

    LGAudio.getAudioContext = function() {
        if (!this._audio_context) {
            window.AudioContext =
                window.AudioContext || window.webkitAudioContext;
            if (!window.AudioContext) {
                console.error("AudioContext not supported by browser");
                return null;
            }
            this._audio_context = new AudioContext();
            this._audio_context.onmessage = function(msg) {
                console.log("msg", msg);
            };
            this._audio_context.onended = function(msg) {
                console.log("ended", msg);
            };
            this._audio_context.oncomplete = function(msg) {
                console.log("complete", msg);
            };
        }

        //in case it crashes
        //if(this._audio_context.state == "suspended")
        //	this._audio_context.resume();
        return this._audio_context;
    };

    LGAudio.connect = function(audionodeA, audionodeB) {
        try {
            audionodeA.connect(audionodeB);
        } catch (err) {
            console.warn("LGraphAudio:", err);
        }
    };

    LGAudio.disconnect = function(audionodeA, audionodeB) {
        try {
            audionodeA.disconnect(audionodeB);
        } catch (err) {
            console.warn("LGraphAudio:", err);
        }
    };

    LGAudio.changeAllAudiosConnections = function(node, connect) {
        if (node.inputs) {
            for (var i = 0; i < node.inputs.length; ++i) {
                var input = node.inputs[i];
                var link_info = node.graph.links[input.link];
                if (!link_info) {
                    continue;
                }

                var origin_node = node.graph.getNodeById(link_info.origin_id);
                var origin_audionode = null;
                if (origin_node.getAudioNodeInOutputSlot) {
                    origin_audionode = origin_node.getAudioNodeInOutputSlot(
                        link_info.origin_slot
                    );
                } else {
                    origin_audionode = origin_node.audionode;
                }

                var target_audionode = null;
                if (node.getAudioNodeInInputSlot) {
                    target_audionode = node.getAudioNodeInInputSlot(i);
                } else {
                    target_audionode = node.audionode;
                }

                if (connect) {
                    LGAudio.connect(origin_audionode, target_audionode);
                } else {
                    LGAudio.disconnect(origin_audionode, target_audionode);
                }
            }
        }

        if (node.outputs) {
            for (var i = 0; i < node.outputs.length; ++i) {
                var output = node.outputs[i];
                for (var j = 0; j < output.links.length; ++j) {
                    var link_info = node.graph.links[output.links[j]];
                    if (!link_info) {
                        continue;
                    }

                    var origin_audionode = null;
                    if (node.getAudioNodeInOutputSlot) {
                        origin_audionode = node.getAudioNodeInOutputSlot(i);
                    } else {
                        origin_audionode = node.audionode;
                    }

                    var target_node = node.graph.getNodeById(
                        link_info.target_id
                    );
                    var target_audionode = null;
                    if (target_node.getAudioNodeInInputSlot) {
                        target_audionode = target_node.getAudioNodeInInputSlot(
                            link_info.target_slot
                        );
                    } else {
                        target_audionode = target_node.audionode;
                    }

                    if (connect) {
                        LGAudio.connect(origin_audionode, target_audionode);
                    } else {
                        LGAudio.disconnect(origin_audionode, target_audionode);
                    }
                }
            }
        }
    };

    //used by many nodes
    LGAudio.onConnectionsChange = function(
        connection,
        slot,
        connected,
        link_info
    ) {
        //only process the outputs events
        if (connection != LiteGraph.OUTPUT) {
            return;
        }

        var target_node = null;
        if (link_info) {
            target_node = this.graph.getNodeById(link_info.target_id);
        }

        if (!target_node) {
            return;
        }

        //get origin audionode
        var local_audionode = null;
        if (this.getAudioNodeInOutputSlot) {
            local_audionode = this.getAudioNodeInOutputSlot(slot);
        } else {
            local_audionode = this.audionode;
        }

        //get target audionode
        var target_audionode = null;
        if (target_node.getAudioNodeInInputSlot) {
            target_audionode = target_node.getAudioNodeInInputSlot(
                link_info.target_slot
            );
        } else {
            target_audionode = target_node.audionode;
        }

        //do the connection/disconnection
        if (connected) {
            LGAudio.connect(local_audionode, target_audionode);
        } else {
            LGAudio.disconnect(local_audionode, target_audionode);
        }
    };

    //this function helps creating wrappers to existing classes
    LGAudio.createAudioNodeWrapper = function(class_object) {
        var old_func = class_object.prototype.onPropertyChanged;

        class_object.prototype.onPropertyChanged = function(name, value) {
            if (old_func) {
                old_func.call(this, name, value);
            }

            if (!this.audionode) {
                return;
            }

            if (this.audionode[name] === undefined) {
                return;
            }

            if (this.audionode[name].value !== undefined) {
                this.audionode[name].value = value;
            } else {
                this.audionode[name] = value;
            }
        };

        class_object.prototype.onConnectionsChange =
            LGAudio.onConnectionsChange;
    };

    //contains the samples decoded of the loaded audios in AudioBuffer format
    LGAudio.cached_audios = {};

    LGAudio.loadSound = function(url, on_complete, on_error) {
        if (LGAudio.cached_audios[url] && url.indexOf("blob:") == -1) {
            if (on_complete) {
                on_complete(LGAudio.cached_audios[url]);
            }
            return;
        }

        if (LGAudio.onProcessAudioURL) {
            url = LGAudio.onProcessAudioURL(url);
        }

        //load new sample
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = "arraybuffer";

        var context = LGAudio.getAudioContext();

        // Decode asynchronously
        request.onload = function() {
            console.log("AudioSource loaded");
            context.decodeAudioData(
                request.response,
                function(buffer) {
                    console.log("AudioSource decoded");
                    LGAudio.cached_audios[url] = buffer;
                    if (on_complete) {
                        on_complete(buffer);
                    }
                },
                onError
            );
        };
        request.send();

        function onError(err) {
            console.log("Audio loading sample error:", err);
            if (on_error) {
                on_error(err);
            }
        }

        return request;
    };

    //****************************************************

    function LGAudioSource() {
        this.properties = {
            src: "",
            gain: 0.5,
            loop: true,
            autoplay: true,
            playbackRate: 1
        };

        this._loading_audio = false;
        this._audiobuffer = null; //points to AudioBuffer with the audio samples decoded
        this._audionodes = [];
        this._last_sourcenode = null; //the last AudioBufferSourceNode (there could be more if there are several sounds playing)

        this.addOutput("out", "audio");
        this.addInput("gain", "number");

        //init context
        var context = LGAudio.getAudioContext();

        //create gain node to control volume
        this.audionode = context.createGain();
        this.audionode.graphnode = this;
        this.audionode.gain.value = this.properties.gain;

        //debug
        if (this.properties.src) {
            this.loadSound(this.properties.src);
        }
    }

	LGAudioSource.desc = "Plays an audio file";
    LGAudioSource["@src"] = { widget: "resource" };
    LGAudioSource.supported_extensions = ["wav", "ogg", "mp3"];

    LGAudioSource.prototype.onAdded = function(graph) {
        if (graph.status === LGraph.STATUS_RUNNING) {
            this.onStart();
        }
    };

    LGAudioSource.prototype.onStart = function() {
        if (!this._audiobuffer) {
            return;
        }

        if (this.properties.autoplay) {
			this.playBuffer(this._audiobuffer);
        }
    };

    LGAudioSource.prototype.onStop = function() {
        this.stopAllSounds();
    };

    LGAudioSource.prototype.onPause = function() {
        this.pauseAllSounds();
    };

    LGAudioSource.prototype.onUnpause = function() {
        this.unpauseAllSounds();
        //this.onStart();
    };

    LGAudioSource.prototype.onRemoved = function() {
        this.stopAllSounds();
        if (this._dropped_url) {
            URL.revokeObjectURL(this._url);
        }
    };

    LGAudioSource.prototype.stopAllSounds = function() {
        //iterate and stop
        for (var i = 0; i < this._audionodes.length; ++i) {
            if (this._audionodes[i].started) {
                this._audionodes[i].started = false;
                this._audionodes[i].stop();
            }
            //this._audionodes[i].disconnect( this.audionode );
        }
        this._audionodes.length = 0;
    };

    LGAudioSource.prototype.pauseAllSounds = function() {
        LGAudio.getAudioContext().suspend();
    };

    LGAudioSource.prototype.unpauseAllSounds = function() {
        LGAudio.getAudioContext().resume();
    };

    LGAudioSource.prototype.onExecute = function() {
        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == null) {
                    continue;
                }
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                if (input.name == "gain")
                    this.audionode.gain.value = v;
                else if (input.name == "src") {
                    this.setProperty("src",v);
                } else if (input.name == "playbackRate") {
                    this.properties.playbackRate = v;
                    for (var j = 0; j < this._audionodes.length; ++j) {
                        this._audionodes[j].playbackRate.value = v;
                    }
                }
            }
        }

        if (this.outputs) {
            for (var i = 0; i < this.outputs.length; ++i) {
                var output = this.outputs[i];
                if (output.name == "buffer" && this._audiobuffer) {
                    this.setOutputData(i, this._audiobuffer);
                }
            }
        }
    };

    LGAudioSource.prototype.onAction = function(event) {
        if (this._audiobuffer) {
            if (event == "Play") {
                this.playBuffer(this._audiobuffer);
            } else if (event == "Stop") {
                this.stopAllSounds();
            }
        }
    };

    LGAudioSource.prototype.onPropertyChanged = function(name, value) {
        if (name == "src") {
            this.loadSound(value);
        } else if (name == "gain") {
            this.audionode.gain.value = value;
        } else if (name == "playbackRate") {
            for (var j = 0; j < this._audionodes.length; ++j) {
                this._audionodes[j].playbackRate.value = value;
            }
        }
    };

    LGAudioSource.prototype.playBuffer = function(buffer) {
        var that = this;
        var context = LGAudio.getAudioContext();

        //create a new audionode (this is mandatory, AudioAPI doesnt like to reuse old ones)
        var audionode = context.createBufferSource(); //create a AudioBufferSourceNode
        this._last_sourcenode = audionode;
        audionode.graphnode = this;
        audionode.buffer = buffer;
        audionode.loop = this.properties.loop;
        audionode.playbackRate.value = this.properties.playbackRate;
        this._audionodes.push(audionode);
        audionode.connect(this.audionode); //connect to gain

		this._audionodes.push(audionode);

		this.trigger("start");

        audionode.onended = function() {
            //console.log("ended!");
            that.trigger("ended");
            //remove
            var index = that._audionodes.indexOf(audionode);
            if (index != -1) {
                that._audionodes.splice(index, 1);
            }
        };

        if (!audionode.started) {
            audionode.started = true;
            audionode.start();
        }
        return audionode;
    };

    LGAudioSource.prototype.loadSound = function(url) {
        var that = this;

        //kill previous load
        if (this._request) {
            this._request.abort();
            this._request = null;
        }

        this._audiobuffer = null; //points to the audiobuffer once the audio is loaded
        this._loading_audio = false;

        if (!url) {
            return;
        }

        this._request = LGAudio.loadSound(url, inner);

        this._loading_audio = true;
        this.boxcolor = "#AA4";

        function inner(buffer) {
            this.boxcolor = LiteGraph.NODE_DEFAULT_BOXCOLOR;
            that._audiobuffer = buffer;
            that._loading_audio = false;
            //if is playing, then play it
            if (that.graph && that.graph.status === LGraph.STATUS_RUNNING) {
                that.onStart();
            } //this controls the autoplay already
        }
    };

    //Helps connect/disconnect AudioNodes when new connections are made in the node
    LGAudioSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;

    LGAudioSource.prototype.onGetInputs = function() {
        return [
            ["playbackRate", "number"],
			["src","string"],
            ["Play", LiteGraph.ACTION],
            ["Stop", LiteGraph.ACTION]
        ];
    };

    LGAudioSource.prototype.onGetOutputs = function() {
        return [["buffer", "audiobuffer"], ["start", LiteGraph.EVENT], ["ended", LiteGraph.EVENT]];
    };

    LGAudioSource.prototype.onDropFile = function(file) {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
        var url = URL.createObjectURL(file);
        this.properties.src = url;
        this.loadSound(url);
        this._dropped_url = url;
    };

    LGAudioSource.title = "Source";
    LGAudioSource.desc = "Plays audio";
    LiteGraph.registerNodeType("audio/source", LGAudioSource);

    //****************************************************

    function LGAudioMediaSource() {
        this.properties = {
            gain: 0.5
        };

        this._audionodes = [];
        this._media_stream = null;

        this.addOutput("out", "audio");
        this.addInput("gain", "number");

        //create gain node to control volume
        var context = LGAudio.getAudioContext();
        this.audionode = context.createGain();
        this.audionode.graphnode = this;
        this.audionode.gain.value = this.properties.gain;
    }

    LGAudioMediaSource.prototype.onAdded = function(graph) {
        if (graph.status === LGraph.STATUS_RUNNING) {
            this.onStart();
        }
    };

    LGAudioMediaSource.prototype.onStart = function() {
        if (this._media_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }
    };

    LGAudioMediaSource.prototype.onStop = function() {
        this.audionode.gain.value = 0;
    };

    LGAudioMediaSource.prototype.onPause = function() {
        this.audionode.gain.value = 0;
    };

    LGAudioMediaSource.prototype.onUnpause = function() {
        this.audionode.gain.value = this.properties.gain;
    };

    LGAudioMediaSource.prototype.onRemoved = function() {
        this.audionode.gain.value = 0;
        if (this.audiosource_node) {
            this.audiosource_node.disconnect(this.audionode);
            this.audiosource_node = null;
        }
        if (this._media_stream) {
            var tracks = this._media_stream.getTracks();
            if (tracks.length) {
                tracks[0].stop();
            }
        }
    };

    LGAudioMediaSource.prototype.openStream = function() {
        if (!navigator.mediaDevices) {
            console.log(
                "getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags"
            );
            return;
        }

        this._waiting_confirmation = true;

        // Not showing vendor prefixes.
        navigator.mediaDevices
            .getUserMedia({ audio: true, video: false })
            .then(this.streamReady.bind(this))
            .catch(onFailSoHard);

        var that = this;
        function onFailSoHard(err) {
            console.log("Media rejected", err);
            that._media_stream = false;
            that.boxcolor = "red";
        }
    };

    LGAudioMediaSource.prototype.streamReady = function(localMediaStream) {
        this._media_stream = localMediaStream;
        //this._waiting_confirmation = false;

        //init context
        if (this.audiosource_node) {
            this.audiosource_node.disconnect(this.audionode);
        }
        var context = LGAudio.getAudioContext();
        this.audiosource_node = context.createMediaStreamSource(
            localMediaStream
        );
        this.audiosource_node.graphnode = this;
        this.audiosource_node.connect(this.audionode);
        this.boxcolor = "white";
    };

    LGAudioMediaSource.prototype.onExecute = function() {
        if (this._media_stream == null && !this._waiting_confirmation) {
            this.openStream();
        }

        if (this.inputs) {
            for (var i = 0; i < this.inputs.length; ++i) {
                var input = this.inputs[i];
                if (input.link == null) {
                    continue;
                }
                var v = this.getInputData(i);
                if (v === undefined) {
                    continue;
                }
                if (input.name == "gain") {
                    this.audionode.gain.value = this.properties.gain = v;
                }
            }
        }
    };

    LGAudioMediaSource.prototype.onAction = function(event) {
        if (event == "Play") {
            this.audionode.gain.value = this.properties.gain;
        } else if (event == "Stop") {
            this.audionode.gain.value = 0;
        }
    };

    LGAudioMediaSource.prototype.onPropertyChanged = function(name, value) {
        if (name == "gain") {
            this.audionode.gain.value = value;
        }
    };

    //Helps connect/disconnect AudioNodes when new connections are made in the node
    LGAudioMediaSource.prototype.onConnectionsChange =
        LGAudio.onConnectionsChange;

    LGAudioMediaSource.prototype.onGetInputs = function() {
        return [
            ["playbackRate", "number"],
            ["Play", LiteGraph.ACTION],
            ["Stop", LiteGraph.ACTION]
        ];
    };

    LGAudioMediaSource.title = "MediaSource";
    LGAudioMediaSource.desc = "Plays microphone";
    LiteGraph.registerNodeType("audio/media_source", LGAudioMediaSource);

    //*****************************************************

    function LGAudioAnalyser() {
        this.properties = {
            fftSize: 2048,
            minDecibels: -100,
            maxDecibels: -10,
            smoothingTimeConstant: 0.5
        };

        var context = LGAudio.getAudioContext();

        this.audionode = context.createAnalyser();
        this.audionode.graphnode = this;
        this.audionode.fftSize = this.properties.fftSize;
        this.audionode.minDecibels = this.properties.minDecibels;
        this.audionode.maxDecibels = this.properties.maxDecibels;
        this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;

        this.addInput("in", "audio");
        this.addOutput("freqs", "array");
        this.addOutput("samples", "array");

        this._freq_bin = null;
        this._time_bin = null;
    }

    LGAudioAnalyser.prototype.onPropertyChanged = function(name, value) {
        this.audionode[name] = value;
    };

    LGAudioAnalyser.prototype.onExecute = function() {
        if (this.isOutputConnected(0)) {
            //send FFT
            var bufferLength = this.audionode.frequencyBinCount;
            if (!this._freq_bin || this._freq_bin.length != bufferLength) {
                this._freq_bin = new Uint8Array(bufferLength);
            }
            this.audionode.getByteFrequencyData(this._freq_bin);
            this.setOutputData(0, this._freq_bin);
        }

        //send analyzer
        if (this.isOutputConnected(1)) {
            //send Samples
            var bufferLength = this.audionode.frequencyBinCount;
            if (!this._time_bin || this._time_bin.length != bufferLength) {
                this._time_bin = new Uint8Array(bufferLength);
            }
            this.audionode.getByteTimeDomainData(this._time_bin);
            this.setOutputData(1, this._time_bin);
        }

        //properties
        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }

        //time domain
        //this.audionode.getFloatTimeDomainData( dataArray );
    };

    LGAudioAnalyser.prototype.onGetInputs = function() {
        return [
            ["minDecibels", "number"],
            ["maxDecibels", "number"],
            ["smoothingTimeConstant", "number"]
        ];
    };

    LGAudioAnalyser.prototype.onGetOutputs = function() {
        return [["freqs", "array"], ["samples", "array"]];
    };

    LGAudioAnalyser.title = "Analyser";
    LGAudioAnalyser.desc = "Audio Analyser";
    LiteGraph.registerNodeType("audio/analyser", LGAudioAnalyser);

    //*****************************************************

    function LGAudioGain() {
        //default
        this.properties = {
            gain: 1
        };

        this.audionode = LGAudio.getAudioContext().createGain();
        this.addInput("in", "audio");
        this.addInput("gain", "number");
        this.addOutput("out", "audio");
    }

    LGAudioGain.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudio.createAudioNodeWrapper(LGAudioGain);

    LGAudioGain.title = "Gain";
    LGAudioGain.desc = "Audio gain";
    LiteGraph.registerNodeType("audio/gain", LGAudioGain);

    function LGAudioConvolver() {
        //default
        this.properties = {
            impulse_src: "",
            normalize: true
        };

        this.audionode = LGAudio.getAudioContext().createConvolver();
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudio.createAudioNodeWrapper(LGAudioConvolver);

    LGAudioConvolver.prototype.onRemove = function() {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
    };

    LGAudioConvolver.prototype.onPropertyChanged = function(name, value) {
        if (name == "impulse_src") {
            this.loadImpulse(value);
        } else if (name == "normalize") {
            this.audionode.normalize = value;
        }
    };

    LGAudioConvolver.prototype.onDropFile = function(file) {
        if (this._dropped_url) {
            URL.revokeObjectURL(this._dropped_url);
        }
        this._dropped_url = URL.createObjectURL(file);
        this.properties.impulse_src = this._dropped_url;
        this.loadImpulse(this._dropped_url);
    };

    LGAudioConvolver.prototype.loadImpulse = function(url) {
        var that = this;

        //kill previous load
        if (this._request) {
            this._request.abort();
            this._request = null;
        }

        this._impulse_buffer = null;
        this._loading_impulse = false;

        if (!url) {
            return;
        }

        //load new sample
        this._request = LGAudio.loadSound(url, inner);
        this._loading_impulse = true;

        // Decode asynchronously
        function inner(buffer) {
            that._impulse_buffer = buffer;
            that.audionode.buffer = buffer;
            console.log("Impulse signal set");
            that._loading_impulse = false;
        }
    };

    LGAudioConvolver.title = "Convolver";
    LGAudioConvolver.desc = "Convolves the signal (used for reverb)";
    LiteGraph.registerNodeType("audio/convolver", LGAudioConvolver);

    function LGAudioDynamicsCompressor() {
        //default
        this.properties = {
            threshold: -50,
            knee: 40,
            ratio: 12,
            reduction: -20,
            attack: 0,
            release: 0.25
        };

        this.audionode = LGAudio.getAudioContext().createDynamicsCompressor();
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudio.createAudioNodeWrapper(LGAudioDynamicsCompressor);

    LGAudioDynamicsCompressor.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }
        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudioDynamicsCompressor.prototype.onGetInputs = function() {
        return [
            ["threshold", "number"],
            ["knee", "number"],
            ["ratio", "number"],
            ["reduction", "number"],
            ["attack", "number"],
            ["release", "number"]
        ];
    };

    LGAudioDynamicsCompressor.title = "DynamicsCompressor";
    LGAudioDynamicsCompressor.desc = "Dynamics Compressor";
    LiteGraph.registerNodeType(
        "audio/dynamicsCompressor",
        LGAudioDynamicsCompressor
    );

    function LGAudioWaveShaper() {
        //default
        this.properties = {};

        this.audionode = LGAudio.getAudioContext().createWaveShaper();
        this.addInput("in", "audio");
        this.addInput("shape", "waveshape");
        this.addOutput("out", "audio");
    }

    LGAudioWaveShaper.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }
        var v = this.getInputData(1);
        if (v === undefined) {
            return;
        }
        this.audionode.curve = v;
    };

    LGAudioWaveShaper.prototype.setWaveShape = function(shape) {
        this.audionode.curve = shape;
    };

    LGAudio.createAudioNodeWrapper(LGAudioWaveShaper);

    /* disabled till I dont find a way to do a wave shape
LGAudioWaveShaper.title = "WaveShaper";
LGAudioWaveShaper.desc = "Distortion using wave shape";
LiteGraph.registerNodeType("audio/waveShaper", LGAudioWaveShaper);
*/

    function LGAudioMixer() {
        //default
        this.properties = {
            gain1: 0.5,
            gain2: 0.5
        };

        this.audionode = LGAudio.getAudioContext().createGain();

        this.audionode1 = LGAudio.getAudioContext().createGain();
        this.audionode1.gain.value = this.properties.gain1;
        this.audionode2 = LGAudio.getAudioContext().createGain();
        this.audionode2.gain.value = this.properties.gain2;

        this.audionode1.connect(this.audionode);
        this.audionode2.connect(this.audionode);

        this.addInput("in1", "audio");
        this.addInput("in1 gain", "number");
        this.addInput("in2", "audio");
        this.addInput("in2 gain", "number");

        this.addOutput("out", "audio");
    }

    LGAudioMixer.prototype.getAudioNodeInInputSlot = function(slot) {
        if (slot == 0) {
            return this.audionode1;
        } else if (slot == 2) {
            return this.audionode2;
        }
    };

    LGAudioMixer.prototype.onPropertyChanged = function(name, value) {
        if (name == "gain1") {
            this.audionode1.gain.value = value;
        } else if (name == "gain2") {
            this.audionode2.gain.value = value;
        }
    };

    LGAudioMixer.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];

            if (input.link == null || input.type == "audio") {
                continue;
            }

            var v = this.getInputData(i);
            if (v === undefined) {
                continue;
            }

            if (i == 1) {
                this.audionode1.gain.value = v;
            } else if (i == 3) {
                this.audionode2.gain.value = v;
            }
        }
    };

    LGAudio.createAudioNodeWrapper(LGAudioMixer);

    LGAudioMixer.title = "Mixer";
    LGAudioMixer.desc = "Audio mixer";
    LiteGraph.registerNodeType("audio/mixer", LGAudioMixer);

    function LGAudioADSR() {
        //default
        this.properties = {
            A: 0.1,
            D: 0.1,
            S: 0.1,
            R: 0.1
        };

        this.audionode = LGAudio.getAudioContext().createGain();
        this.audionode.gain.value = 0;
        this.addInput("in", "audio");
        this.addInput("gate", "bool");
        this.addOutput("out", "audio");
        this.gate = false;
    }

    LGAudioADSR.prototype.onExecute = function() {
        var audioContext = LGAudio.getAudioContext();
        var now = audioContext.currentTime;
        var node = this.audionode;
        var gain = node.gain;
        var current_gate = this.getInputData(1);

        var A = this.getInputOrProperty("A");
        var D = this.getInputOrProperty("D");
        var S = this.getInputOrProperty("S");
        var R = this.getInputOrProperty("R");

        if (!this.gate && current_gate) {
            gain.cancelScheduledValues(0);
            gain.setValueAtTime(0, now);
            gain.linearRampToValueAtTime(1, now + A);
            gain.linearRampToValueAtTime(S, now + A + D);
        } else if (this.gate && !current_gate) {
            gain.cancelScheduledValues(0);
            gain.setValueAtTime(gain.value, now);
            gain.linearRampToValueAtTime(0, now + R);
        }

        this.gate = current_gate;
    };

    LGAudioADSR.prototype.onGetInputs = function() {
        return [
            ["A", "number"],
            ["D", "number"],
            ["S", "number"],
            ["R", "number"]
        ];
    };

    LGAudio.createAudioNodeWrapper(LGAudioADSR);

    LGAudioADSR.title = "ADSR";
    LGAudioADSR.desc = "Audio envelope";
    LiteGraph.registerNodeType("audio/adsr", LGAudioADSR);

    function LGAudioDelay() {
        //default
        this.properties = {
            delayTime: 0.5
        };

        this.audionode = LGAudio.getAudioContext().createDelay(10);
        this.audionode.delayTime.value = this.properties.delayTime;
        this.addInput("in", "audio");
        this.addInput("time", "number");
        this.addOutput("out", "audio");
    }

    LGAudio.createAudioNodeWrapper(LGAudioDelay);

    LGAudioDelay.prototype.onExecute = function() {
        var v = this.getInputData(1);
        if (v !== undefined) {
            this.audionode.delayTime.value = v;
        }
    };

    LGAudioDelay.title = "Delay";
    LGAudioDelay.desc = "Audio delay";
    LiteGraph.registerNodeType("audio/delay", LGAudioDelay);

    function LGAudioBiquadFilter() {
        //default
        this.properties = {
            frequency: 350,
            detune: 0,
            Q: 1
        };
        this.addProperty("type", "lowpass", "enum", {
            values: [
                "lowpass",
                "highpass",
                "bandpass",
                "lowshelf",
                "highshelf",
                "peaking",
                "notch",
                "allpass"
            ]
        });

        //create node
        this.audionode = LGAudio.getAudioContext().createBiquadFilter();

        //slots
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudioBiquadFilter.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 1; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudioBiquadFilter.prototype.onGetInputs = function() {
        return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];
    };

    LGAudio.createAudioNodeWrapper(LGAudioBiquadFilter);

    LGAudioBiquadFilter.title = "BiquadFilter";
    LGAudioBiquadFilter.desc = "Audio filter";
    LiteGraph.registerNodeType("audio/biquadfilter", LGAudioBiquadFilter);

    function LGAudioOscillatorNode() {
        //default
        this.properties = {
            frequency: 440,
            detune: 0,
            type: "sine"
        };
        this.addProperty("type", "sine", "enum", {
            values: ["sine", "square", "sawtooth", "triangle", "custom"]
        });

        //create node
        this.audionode = LGAudio.getAudioContext().createOscillator();

        //slots
        this.addOutput("out", "audio");
    }

    LGAudioOscillatorNode.prototype.onStart = function() {
        if (!this.audionode.started) {
            this.audionode.started = true;
            try {
                this.audionode.start();
            } catch (err) {}
        }
    };

    LGAudioOscillatorNode.prototype.onStop = function() {
        if (this.audionode.started) {
            this.audionode.started = false;
            this.audionode.stop();
        }
    };

    LGAudioOscillatorNode.prototype.onPause = function() {
        this.onStop();
    };

    LGAudioOscillatorNode.prototype.onUnpause = function() {
        this.onStart();
    };

    LGAudioOscillatorNode.prototype.onExecute = function() {
        if (!this.inputs || !this.inputs.length) {
            return;
        }

        for (var i = 0; i < this.inputs.length; ++i) {
            var input = this.inputs[i];
            if (input.link == null) {
                continue;
            }
            var v = this.getInputData(i);
            if (v !== undefined) {
                this.audionode[input.name].value = v;
            }
        }
    };

    LGAudioOscillatorNode.prototype.onGetInputs = function() {
        return [
            ["frequency", "number"],
            ["detune", "number"],
            ["type", "string"]
        ];
    };

    LGAudio.createAudioNodeWrapper(LGAudioOscillatorNode);

    LGAudioOscillatorNode.title = "Oscillator";
    LGAudioOscillatorNode.desc = "Oscillator";
    LiteGraph.registerNodeType("audio/oscillator", LGAudioOscillatorNode);

    //*****************************************************

    //EXTRA

    function LGAudioVisualization() {
        this.properties = {
            continuous: true,
            mark: -1
        };

        this.addInput("data", "array");
        this.addInput("mark", "number");
        this.size = [300, 200];
        this._last_buffer = null;
    }

    LGAudioVisualization.prototype.onExecute = function() {
        this._last_buffer = this.getInputData(0);
        var v = this.getInputData(1);
        if (v !== undefined) {
            this.properties.mark = v;
        }
        this.setDirtyCanvas(true, false);
    };

    LGAudioVisualization.prototype.onDrawForeground = function(ctx) {
        if (!this._last_buffer) {
            return;
        }

        var buffer = this._last_buffer;

        //delta represents how many samples we advance per pixel
        var delta = buffer.length / this.size[0];
        var h = this.size[1];

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, this.size[0], this.size[1]);
        ctx.strokeStyle = "white";
        ctx.beginPath();
        var x = 0;

        if (this.properties.continuous) {
            ctx.moveTo(x, h);
            for (var i = 0; i < buffer.length; i += delta) {
                ctx.lineTo(x, h - (buffer[i | 0] / 255) * h);
                x++;
            }
        } else {
            for (var i = 0; i < buffer.length; i += delta) {
                ctx.moveTo(x + 0.5, h);
                ctx.lineTo(x + 0.5, h - (buffer[i | 0] / 255) * h);
                x++;
            }
        }
        ctx.stroke();

        if (this.properties.mark >= 0) {
            var samplerate = LGAudio.getAudioContext().sampleRate;
            var binfreq = samplerate / buffer.length;
            var x = (2 * (this.properties.mark / binfreq)) / delta;
            if (x >= this.size[0]) {
                x = this.size[0] - 1;
            }
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.moveTo(x, h);
            ctx.lineTo(x, 0);
            ctx.stroke();
        }
    };

    LGAudioVisualization.title = "Visualization";
    LGAudioVisualization.desc = "Audio Visualization";
    LiteGraph.registerNodeType("audio/visualization", LGAudioVisualization);

    function LGAudioBandSignal() {
        //default
        this.properties = {
            band: 440,
            amplitude: 1
        };

        this.addInput("freqs", "array");
        this.addOutput("signal", "number");
    }

    LGAudioBandSignal.prototype.onExecute = function() {
        this._freqs = this.getInputData(0);
        if (!this._freqs) {
            return;
        }

        var band = this.properties.band;
        var v = this.getInputData(1);
        if (v !== undefined) {
            band = v;
        }

        var samplerate = LGAudio.getAudioContext().sampleRate;
        var binfreq = samplerate / this._freqs.length;
        var index = 2 * (band / binfreq);
        var v = 0;
        if (index < 0) {
            v = this._freqs[0];
        }
        if (index >= this._freqs.length) {
            v = this._freqs[this._freqs.length - 1];
        } else {
            var pos = index | 0;
            var v0 = this._freqs[pos];
            var v1 = this._freqs[pos + 1];
            var f = index - pos;
            v = v0 * (1 - f) + v1 * f;
        }

        this.setOutputData(0, (v / 255) * this.properties.amplitude);
    };

    LGAudioBandSignal.prototype.onGetInputs = function() {
        return [["band", "number"]];
    };

    LGAudioBandSignal.title = "Signal";
    LGAudioBandSignal.desc = "extract the signal of some frequency";
    LiteGraph.registerNodeType("audio/signal", LGAudioBandSignal);

    function LGAudioScript() {
        if (!LGAudioScript.default_code) {
            var code = LGAudioScript.default_function.toString();
            var index = code.indexOf("{") + 1;
            var index2 = code.lastIndexOf("}");
            LGAudioScript.default_code = code.substr(index, index2 - index);
        }

        //default
        this.properties = {
            code: LGAudioScript.default_code
        };

        //create node
        var ctx = LGAudio.getAudioContext();
        if (ctx.createScriptProcessor) {
            this.audionode = ctx.createScriptProcessor(4096, 1, 1);
        }
        //buffer size, input channels, output channels
        else {
            console.warn("ScriptProcessorNode deprecated");
            this.audionode = ctx.createGain(); //bypass audio
        }

        this.processCode();
        if (!LGAudioScript._bypass_function) {
            LGAudioScript._bypass_function = this.audionode.onaudioprocess;
        }

        //slots
        this.addInput("in", "audio");
        this.addOutput("out", "audio");
    }

    LGAudioScript.prototype.onAdded = function(graph) {
        if (graph.status == LGraph.STATUS_RUNNING) {
            this.audionode.onaudioprocess = this._callback;
        }
    };

    LGAudioScript["@code"] = { widget: "code", type: "code" };

    LGAudioScript.prototype.onStart = function() {
        this.audionode.onaudioprocess = this._callback;
    };

    LGAudioScript.prototype.onStop = function() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    };

    LGAudioScript.prototype.onPause = function() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    };

    LGAudioScript.prototype.onUnpause = function() {
        this.audionode.onaudioprocess = this._callback;
    };

    LGAudioScript.prototype.onExecute = function() {
        //nothing! because we need an onExecute to receive onStart... fix that
    };

    LGAudioScript.prototype.onRemoved = function() {
        this.audionode.onaudioprocess = LGAudioScript._bypass_function;
    };

    LGAudioScript.prototype.processCode = function() {
        try {
            var func = new Function("properties", this.properties.code);
            this._script = new func(this.properties);
            this._old_code = this.properties.code;
            this._callback = this._script.onaudioprocess;
        } catch (err) {
            console.error("Error in onaudioprocess code", err);
            this._callback = LGAudioScript._bypass_function;
            this.audionode.onaudioprocess = this._callback;
        }
    };

    LGAudioScript.prototype.onPropertyChanged = function(name, value) {
        if (name == "code") {
            this.properties.code = value;
            this.processCode();
            if (this.graph && this.graph.status == LGraph.STATUS_RUNNING) {
                this.audionode.onaudioprocess = this._callback;
            }
        }
    };

    LGAudioScript.default_function = function() {
        this.onaudioprocess = function(audioProcessingEvent) {
            // The input buffer is the song we loaded earlier
            var inputBuffer = audioProcessingEvent.inputBuffer;

            // The output buffer contains the samples that will be modified and played
            var outputBuffer = audioProcessingEvent.outputBuffer;

            // Loop through the output channels (in this case there is only one)
            for (
                var channel = 0;
                channel < outputBuffer.numberOfChannels;
                channel++
            ) {
                var inputData = inputBuffer.getChannelData(channel);
                var outputData = outputBuffer.getChannelData(channel);

                // Loop through the 4096 samples
                for (var sample = 0; sample < inputBuffer.length; sample++) {
                    // make output equal to the same as the input
                    outputData[sample] = inputData[sample];
                }
            }
        };
    };

    LGAudio.createAudioNodeWrapper(LGAudioScript);

    LGAudioScript.title = "Script";
    LGAudioScript.desc = "apply script to signal";
    LiteGraph.registerNodeType("audio/script", LGAudioScript);

    function LGAudioDestination() {
        this.audionode = LGAudio.getAudioContext().destination;
        this.addInput("in", "audio");
    }

    LGAudioDestination.title = "Destination";
    LGAudioDestination.desc = "Audio output";
    LiteGraph.registerNodeType("audio/destination", LGAudioDestination);
})(this);

//event related nodes
(function(global) {
    var LiteGraph = global.LiteGraph;

    function LGWebSocket() {
        this.size = [60, 20];
        this.addInput("send", LiteGraph.ACTION);
        this.addOutput("received", LiteGraph.EVENT);
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.properties = {
            url: "",
            room: "lgraph", //allows to filter messages,
            only_send_changes: true
        };
        this._ws = null;
        this._last_sent_data = [];
        this._last_received_data = [];
    }

    LGWebSocket.title = "WebSocket";
    LGWebSocket.desc = "Send data through a websocket";

    LGWebSocket.prototype.onPropertyChanged = function(name, value) {
        if (name == "url") {
            this.connectSocket();
        }
    };

    LGWebSocket.prototype.onExecute = function() {
        if (!this._ws && this.properties.url) {
            this.connectSocket();
        }

        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {
            return;
        }

        var room = this.properties.room;
        var only_changes = this.properties.only_send_changes;

        for (var i = 1; i < this.inputs.length; ++i) {
            var data = this.getInputData(i);
            if (data == null) {
                continue;
            }
            var json;
            try {
                json = JSON.stringify({
                    type: 0,
                    room: room,
                    channel: i,
                    data: data
                });
            } catch (err) {
                continue;
            }
            if (only_changes && this._last_sent_data[i] == json) {
                continue;
            }

            this._last_sent_data[i] = json;
            this._ws.send(json);
        }

        for (var i = 1; i < this.outputs.length; ++i) {
            this.setOutputData(i, this._last_received_data[i]);
        }

        if (this.boxcolor == "#AFA") {
            this.boxcolor = "#6C6";
        }
    };

    LGWebSocket.prototype.connectSocket = function() {
        var that = this;
        var url = this.properties.url;
        if (url.substr(0, 2) != "ws") {
            url = "ws://" + url;
        }
        this._ws = new WebSocket(url);
        this._ws.onopen = function() {
            console.log("ready");
            that.boxcolor = "#6C6";
        };
        this._ws.onmessage = function(e) {
            that.boxcolor = "#AFA";
            var data = JSON.parse(e.data);
            if (data.room && data.room != that.properties.room) {
                return;
            }
            if (data.type == 1) {
                if (
                    data.data.object_class &&
                    LiteGraph[data.data.object_class]
                ) {
                    var obj = null;
                    try {
                        obj = new LiteGraph[data.data.object_class](data.data);
                        that.triggerSlot(0, obj);
                    } catch (err) {
                        return;
                    }
                } else {
                    that.triggerSlot(0, data.data);
                }
            } else {
                that._last_received_data[data.channel || 0] = data.data;
            }
        };
        this._ws.onerror = function(e) {
            console.log("couldnt connect to websocket");
            that.boxcolor = "#E88";
        };
        this._ws.onclose = function(e) {
            console.log("connection closed");
            that.boxcolor = "#000";
        };
    };

    LGWebSocket.prototype.send = function(data) {
        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {
            return;
        }
        this._ws.send(JSON.stringify({ type: 1, msg: data }));
    };

    LGWebSocket.prototype.onAction = function(action, param) {
        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {
            return;
        }
        this._ws.send({
            type: 1,
            room: this.properties.room,
            action: action,
            data: param
        });
    };

    LGWebSocket.prototype.onGetInputs = function() {
        return [["in", 0]];
    };

    LGWebSocket.prototype.onGetOutputs = function() {
        return [["out", 0]];
    };

    LiteGraph.registerNodeType("network/websocket", LGWebSocket);

    //It is like a websocket but using the SillyServer.js server that bounces packets back to all clients connected:
    //For more information: https://github.com/jagenjo/SillyServer.js

    function LGSillyClient() {
        //this.size = [60,20];
        this.room_widget = this.addWidget(
            "text",
            "Room",
            "lgraph",
            this.setRoom.bind(this)
        );
        this.addWidget(
            "button",
            "Reconnect",
            null,
            this.connectSocket.bind(this)
        );

        this.addInput("send", LiteGraph.ACTION);
        this.addOutput("received", LiteGraph.EVENT);
        this.addInput("in", 0);
        this.addOutput("out", 0);
        this.properties = {
            url: "tamats.com:55000",
            room: "lgraph",
            only_send_changes: true
        };

        this._server = null;
        this.connectSocket();
        this._last_sent_data = [];
        this._last_received_data = [];

		if(typeof(SillyClient) == "undefined")
			console.warn("remember to add SillyClient.js to your project: https://tamats.com/projects/sillyserver/src/sillyclient.js");
    }

    LGSillyClient.title = "SillyClient";
    LGSillyClient.desc = "Connects to SillyServer to broadcast messages";

    LGSillyClient.prototype.onPropertyChanged = function(name, value) {
        if (name == "room") {
            this.room_widget.value = value;
        }
        this.connectSocket();
    };

    LGSillyClient.prototype.setRoom = function(room_name) {
        this.properties.room = room_name;
        this.room_widget.value = room_name;
        this.connectSocket();
    };

    //force label names
    LGSillyClient.prototype.onDrawForeground = function() {
        for (var i = 1; i < this.inputs.length; ++i) {
            var slot = this.inputs[i];
            slot.label = "in_" + i;
        }
        for (var i = 1; i < this.outputs.length; ++i) {
            var slot = this.outputs[i];
            slot.label = "out_" + i;
        }
    };

    LGSillyClient.prototype.onExecute = function() {
        if (!this._server || !this._server.is_connected) {
            return;
        }

        var only_send_changes = this.properties.only_send_changes;

        for (var i = 1; i < this.inputs.length; ++i) {
            var data = this.getInputData(i);
			var prev_data = this._last_sent_data[i];
            if (data != null) {
                if (only_send_changes)
				{	
					var is_equal = true;
					if( data && data.length && prev_data && prev_data.length == data.length && data.constructor !== String)
					{
						for(var j = 0; j < data.length; ++j)
							if( prev_data[j] != data[j] )
							{
								is_equal = false;
								break;
							}
					}
					else if(this._last_sent_data[i] != data)
						is_equal = false;
					if(is_equal)
							continue;
                }
                this._server.sendMessage({ type: 0, channel: i, data: data });
				if( data.length && data.constructor !== String )
				{
					if( this._last_sent_data[i] )
					{
						this._last_sent_data[i].length = data.length;
						for(var j = 0; j < data.length; ++j)
							this._last_sent_data[i][j] = data[j];
					}
					else //create
					{
						if(data.constructor === Array)
							this._last_sent_data[i] = data.concat();
						else
							this._last_sent_data[i] = new data.constructor( data );
					}
				}
				else
	                this._last_sent_data[i] = data; //should be cloned
            }
        }

        for (var i = 1; i < this.outputs.length; ++i) {
            this.setOutputData(i, this._last_received_data[i]);
        }

        if (this.boxcolor == "#AFA") {
            this.boxcolor = "#6C6";
        }
    };

    LGSillyClient.prototype.connectSocket = function() {
        var that = this;
        if (typeof SillyClient == "undefined") {
            if (!this._error) {
                console.error(
                    "SillyClient node cannot be used, you must include SillyServer.js"
                );
            }
            this._error = true;
            return;
        }

        this._server = new SillyClient();
        this._server.on_ready = function() {
            console.log("ready");
            that.boxcolor = "#6C6";
        };
        this._server.on_message = function(id, msg) {
            var data = null;
            try {
                data = JSON.parse(msg);
            } catch (err) {
                return;
            }

            if (data.type == 1) {
                //EVENT slot
                if (
                    data.data.object_class &&
                    LiteGraph[data.data.object_class]
                ) {
                    var obj = null;
                    try {
                        obj = new LiteGraph[data.data.object_class](data.data);
                        that.triggerSlot(0, obj);
                    } catch (err) {
                        return;
                    }
                } else {
                    that.triggerSlot(0, data.data);
                }
            } //for FLOW slots
            else {
                that._last_received_data[data.channel || 0] = data.data;
            }
            that.boxcolor = "#AFA";
        };
        this._server.on_error = function(e) {
            console.log("couldnt connect to websocket");
            that.boxcolor = "#E88";
        };
        this._server.on_close = function(e) {
            console.log("connection closed");
            that.boxcolor = "#000";
        };

        if (this.properties.url && this.properties.room) {
            try {
                this._server.connect(this.properties.url, this.properties.room);
            } catch (err) {
                console.error("SillyServer error: " + err);
                this._server = null;
                return;
            }
            this._final_url = this.properties.url + "/" + this.properties.room;
        }
    };

    LGSillyClient.prototype.send = function(data) {
        if (!this._server || !this._server.is_connected) {
            return;
        }
        this._server.sendMessage({ type: 1, data: data });
    };

    LGSillyClient.prototype.onAction = function(action, param) {
        if (!this._server || !this._server.is_connected) {
            return;
        }
        this._server.sendMessage({ type: 1, action: action, data: param });
    };

    LGSillyClient.prototype.onGetInputs = function() {
        return [["in", 0]];
    };

    LGSillyClient.prototype.onGetOutputs = function() {
        return [["out", 0]];
    };

    LiteGraph.registerNodeType("network/sillyclient", LGSillyClient);
})(this);



/***/ }),

/***/ "./src/main/UI/GraphManager.ts":
/*!*************************************!*\
  !*** ./src/main/UI/GraphManager.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphManager": () => (/* binding */ GraphManager)
/* harmony export */ });
/* harmony import */ var deepslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepslate */ "./node_modules/deepslate/dist/deepslate.esm.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/density_function_output */ "./src/main/nodes/density_function_output.ts");
/* harmony import */ var _nodes_register__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nodes/register */ "./src/main/nodes/register.ts");
/* harmony import */ var _MenuManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MenuManager */ "./src/main/UI/MenuManager.ts");





var GraphManager = /** @class */ (function () {
    function GraphManager() {
    }
    GraphManager.init = function () {
        var _this = this;
        litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.clearRegisteredTypes(); // don't use default node types
        (0,_nodes_register__WEBPACK_IMPORTED_MODULE_3__.registerNodes)();
        this.graph = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraph();
        this.canvas = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraphCanvas("#mycanvas", this.graph);
        this.canvas.autoresize = true;
        this.canvas.canvas.onresize = function () {
            _this.canvas.dirty_canvas = true;
        };
        this.canvas.onDrawLinkTooltip = function (ctx, link, canvas) {
            return true;
        };
        this.canvas.onShowNodePanel = function (n) { };
        this.output_node = new _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__.DensityFunctionOutput(); // not registered as only one exists
        this.output_node.pos = [900, 400];
        this.graph.add(this.output_node);
        this.graph.start();
        document.onkeydown = function (ev) {
            if ((ev.ctrlKey || ev.metaKey) && ev.key === "s") {
                ev.preventDefault();
                _MenuManager__WEBPACK_IMPORTED_MODULE_4__.MenuManager.save();
            }
            else {
                _this.canvas.processKey(ev);
            }
        };
    };
    GraphManager.clear = function () {
        this.graph.clear();
        this.named_nodes = {};
        this.output_node = new _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__.DensityFunctionOutput(); // not registered as only one exists
        this.output_node.pos = [900, 400];
        this.graph.add(this.output_node);
        this.graph.runStep();
    };
    GraphManager.getJSON = function () {
        var _a;
        this.graph.runStep();
        return (_a = this.output_node.getInputDataByName("result")) !== null && _a !== void 0 ? _a : {};
    };
    GraphManager.loadJSON = function (json) {
        var _this = this;
        if (json.noise_router !== undefined) {
            var menu_info = [];
            Object.keys(json.noise_router).forEach(function (element) { return menu_info.push({
                content: element,
                callback: function () {
                    _this.loadJSON(json.noise_router[element]);
                    _MenuManager__WEBPACK_IMPORTED_MODULE_4__.MenuManager.fileName = element + ".json";
                }
            }); });
            var options = { top: 200, left: 200 };
            var e = console.error;
            console.error = function () { };
            var menu = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.ContextMenu(menu_info, options, this.canvas.getCanvasWindow());
            console.error = e;
            return false;
        }
        else {
            this.graph.clear();
            this.named_nodes = {};
            this.output_node = new _nodes_density_function_output__WEBPACK_IMPORTED_MODULE_2__.DensityFunctionOutput(); // not registered as only one exists
            this.graph.add(this.output_node);
            var _a = this.createNodeFromJson(json, [900 - 250, 400]), n = _a[0], y = _a[1];
            n.connect(0, this.output_node, 0);
            this.output_node.pos = [900, y / 2];
            this.graph.runStep();
            _MenuManager__WEBPACK_IMPORTED_MODULE_4__.MenuManager.setEdited(false);
            return true;
        }
    };
    GraphManager.createNodeFromJson = function (json, pos) {
        var _a, _b;
        if (typeof json === "string") {
            if (json in this.named_nodes && this.named_nodes[json].pos[0] <= pos[0] + 400) {
                return [this.named_nodes[json], pos[1]];
            }
            else {
                var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/named");
                node.properties.id = json;
                node.updateWidgets();
                node.pos = pos;
                this.graph.add(node);
                node.collapse(false);
                this.named_nodes[json] = node;
                return [node, pos[1] + 150];
            }
        }
        else if (typeof json === "number") {
            var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/constant");
            node.properties.value = json;
            node.updateWidgets();
            node.pos = pos;
            this.graph.add(node);
            node.collapse(false);
            return [node, pos[1] + 150];
        }
        else if (json.type === "minecraft:spline") {
            var y = pos[1];
            var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/spline");
            node.properties.min_value = json.min_value;
            node.properties.max_value = json.max_value;
            var locations = [];
            var values = [];
            var derivatives = [];
            var _loop_1 = function (point) {
                if (typeof point.value !== "number") {
                    alert("Multidimenional Splines are not supported (yet)");
                    throw Error("Multidimenional Splines are not supported (yet)");
                }
                locations.push(point.location);
                values.push(function () { return point.value; });
                derivatives.push(point.derivative);
            };
            for (var _i = 0, _c = json.spline.points; _i < _c.length; _i++) {
                var point = _c[_i];
                _loop_1(point);
            }
            node.splineWidget.value = new deepslate__WEBPACK_IMPORTED_MODULE_0__.Spline("spine", function (c) { return c; }, locations, values, derivatives);
            node.splineWidget.min_input = locations[0] - 0.1;
            node.splineWidget.max_input = locations[locations.length - 1] + 0.1;
            node.updateWidgets();
            var n;
            _a = this.createNodeFromJson(json.spline.coordinate, [pos[0] - 250, y]), n = _a[0], y = _a[1];
            n.connect(0, node, "coordinate");
            node.pos = [pos[0], (pos[1] + y - 150) / 2];
            this.graph.add(node);
            return [node, y];
        }
        else if (json.type) {
            var node = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.createNode("density_function/" + (json.type.replace("minecraft:", "")));
            var y = pos[1];
            if (node) {
                for (var property in node.properties) {
                    if (json[property] !== undefined) {
                        node.properties[property] = json[property];
                    }
                    else {
                        console.warn("missing property " + property);
                    }
                }
                node.updateWidgets();
                for (var i = 0; i < node.input_names.length; i++) {
                    var input = node.input_names[i];
                    if (json[input] !== undefined) {
                        var n;
                        _b = this.createNodeFromJson(json[input], [pos[0] - 250, y]), n = _b[0], y = _b[1];
                        n.connect(0, node, input);
                    }
                    else {
                        console.warn("missing density function " + input);
                    }
                }
            }
            node.pos = [pos[0], (pos[1] + y - 150) / 2];
            this.graph.add(node);
            return [node, y];
        }
        else {
            throw new Error("could not load density function " + JSON.stringify(json));
        }
    };
    return GraphManager;
}());



/***/ }),

/***/ "./src/main/UI/MenuManager.ts":
/*!************************************!*\
  !*** ./src/main/UI/MenuManager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MenuManager": () => (/* binding */ MenuManager)
/* harmony export */ });
/* harmony import */ var _GraphManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphManager */ "./src/main/UI/GraphManager.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var MenuManager = /** @class */ (function () {
    function MenuManager() {
    }
    MenuManager.addHandlers = function () {
        var _this = this;
        this.save_button = document.getElementById("menu-button-save");
        document.getElementById("menu-button-new").onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.edited && !confirm("You have unsaved changes, continue?")) {
                    return [2 /*return*/];
                }
                _GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.clear();
                this.fileHandle = undefined;
                this.fileName = "density_function.json";
                this.save_button.classList.add("disabled");
                this.edited = false;
                return [2 /*return*/];
            });
        }); };
        document.getElementById("menu-button-open").onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, file, jsonString, input;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.edited && !confirm("You have unsaved changes, continue?")) {
                            return [2 /*return*/];
                        }
                        if (!("showOpenFilePicker" in window)) return [3 /*break*/, 4];
                        _a = this;
                        return [4 /*yield*/, window.showOpenFilePicker({
                                types: [
                                    {
                                        description: "All JSON files",
                                        accept: {
                                            "application/json": [".json"]
                                        }
                                    }
                                ]
                            })];
                    case 1:
                        _a.fileHandle = (_b.sent())[0];
                        return [4 /*yield*/, this.fileHandle.getFile()];
                    case 2:
                        file = _b.sent();
                        return [4 /*yield*/, file.text()];
                    case 3:
                        jsonString = _b.sent();
                        if (_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.loadJSON(JSON.parse(jsonString))) {
                            this.fileName = this.fileHandle.name;
                            this.save_button.classList.remove("disabled");
                        }
                        else {
                            this.fileHandle = undefined;
                            this.fileName = "density_function.json";
                            this.save_button.classList.add("disabled");
                        }
                        this.edited = false;
                        return [3 /*break*/, 5];
                    case 4:
                        input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.onchange = function (evt) {
                            var file = evt.target.files[0];
                            var reader = new FileReader();
                            reader.readAsText(file, 'UTF-8');
                            reader.onload = function (evt) {
                                var jsonString = evt.target.result;
                                _this.fileHandle = undefined;
                                if (_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.loadJSON(JSON.parse(jsonString))) {
                                    _this.fileName = file.name;
                                }
                                else {
                                    _this.fileName = "density_function.json";
                                }
                                _this.edited = false;
                            };
                        };
                        input.click();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        document.getElementById("menu-button-save-as").onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.saveAs()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        this.save_button.onclick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.save()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    MenuManager.save = function () {
        return __awaiter(this, void 0, void 0, function () {
            var jsonString, writable;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.fileHandle) return [3 /*break*/, 4];
                        jsonString = JSON.stringify(_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.getJSON(), null, 2);
                        return [4 /*yield*/, this.fileHandle.createWritable()];
                    case 1:
                        writable = _a.sent();
                        return [4 /*yield*/, writable.write(jsonString)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, writable.close()];
                    case 3:
                        _a.sent();
                        this.edited = false;
                        return [3 /*break*/, 5];
                    case 4:
                        this.saveAs();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    MenuManager.saveAs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var jsonString, _a, writable, bb, a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        jsonString = JSON.stringify(_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.getJSON(), null, 2);
                        if (!("showSaveFilePicker" in window)) return [3 /*break*/, 5];
                        _a = this;
                        return [4 /*yield*/, window.showSaveFilePicker({ types: [
                                    {
                                        description: "All JSON files",
                                        accept: {
                                            "application/json": [".json"]
                                        }
                                    }
                                ], suggestedName: this.fileName
                            })];
                    case 1:
                        _a.fileHandle = _b.sent();
                        this.fileName = this.fileHandle.name;
                        return [4 /*yield*/, this.fileHandle.createWritable()];
                    case 2:
                        writable = _b.sent();
                        return [4 /*yield*/, writable.write(jsonString)];
                    case 3:
                        _b.sent();
                        return [4 /*yield*/, writable.close()];
                    case 4:
                        _b.sent();
                        this.edited = false;
                        this.save_button.classList.remove("disabled");
                        return [3 /*break*/, 6];
                    case 5:
                        bb = new Blob([jsonString], { type: 'text/plain' });
                        a = document.createElement('a');
                        a.download = this.fileName;
                        a.href = window.URL.createObjectURL(bb);
                        a.click();
                        this.edited = false;
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    MenuManager.setEdited = function (force) {
        if (force === void 0) { force = true; }
        this.edited = force;
    };
    MenuManager.fileName = "density_function.json";
    MenuManager.edited = false;
    return MenuManager;
}());



/***/ }),

/***/ "./src/main/nodes/LGraphNodeFixed.ts":
/*!*******************************************!*\
  !*** ./src/main/nodes/LGraphNodeFixed.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LGraphNodeFixed": () => (/* binding */ LGraphNodeFixed)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UI/MenuManager */ "./src/main/UI/MenuManager.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var LGraphNodeFixed = /** @class */ (function (_super) {
    __extends(LGraphNodeFixed, _super);
    function LGraphNodeFixed() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LGraphNodeFixed.prototype.onPropertyChanged = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
        return false;
    };
    LGraphNodeFixed.prototype.onConnectionsChange = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
    };
    LGraphNodeFixed.prototype.onAdded = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
    };
    LGraphNodeFixed.prototype.onRemoved = function () {
        _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.setEdited();
    };
    LGraphNodeFixed.prototype.getMenuOptions = function (onExecute) {
        return [];
    };
    LGraphNodeFixed.prototype.updateWidgets = function () { };
    return LGraphNodeFixed;
}(litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode));



/***/ }),

/***/ "./src/main/nodes/constant_density_function.ts":
/*!*****************************************************!*\
  !*** ./src/main/nodes/constant_density_function.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstantDensityFunction": () => (/* binding */ ConstantDensityFunction)
/* harmony export */ });
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ConstantDensityFunction = /** @class */ (function (_super) {
    __extends(ConstantDensityFunction, _super);
    function ConstantDensityFunction() {
        var _this = _super.call(this) || this;
        var output = _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.addProperty("value", 0, "number");
        _this.wdgt = _this.addWidget("number", "Value", 0, function (value) { _this.properties.value = value; });
        _this.title = "Constant";
        _this.color = "#003333";
        return _this;
    }
    ConstantDensityFunction.prototype.updateWidgets = function () {
        this.wdgt.value = this.properties.value;
    };
    ConstantDensityFunction.prototype.getTitle = function () {
        if (this.flags.collapsed) {
            return this.properties.value;
        }
        return this.title;
    };
    ;
    ConstantDensityFunction.prototype.onExecute = function () {
        this.setOutputData(0, this.properties.value);
    };
    ConstantDensityFunction.title = "constant";
    return ConstantDensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/density_function.ts":
/*!********************************************!*\
  !*** ./src/main/nodes/density_function.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DensityFunction": () => (/* binding */ DensityFunction)
/* harmony export */ });
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var spline_values = ["offset", "factor", "jaggedness"];
var sampler_types = ["type_1", "type_2"];
var DensityFunction = /** @class */ (function (_super) {
    __extends(DensityFunction, _super);
    function DensityFunction(name, args) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.wdgs = {};
        _this.input_names = [];
        args.forEach(function (type, argument) {
            if (type === "densityFunction") {
                _this.addInput(argument, "densityFunction", { label: argument, locked: true, nameLocked: true });
                _this.input_names.push(argument);
            }
            else if (type === "number") {
                _this.addProperty(argument, 0, "number");
                _this.wdgs[argument] = _this.addWidget("number", argument, 0, function (value) { _this.properties[argument] = value; });
            }
            else if (type === "spline") {
                _this.addProperty(argument, 0, "string");
                _this.wdgs[argument] = _this.addWidget("combo", argument, "offset", function (value) { _this.properties[argument] = value; }, { values: spline_values });
            }
            else if (type === "noise") {
                _this.addProperty(argument, 0, "string");
                _this.wdgs[argument] = _this.addWidget("text", argument, "minecraft:", function (value) { _this.properties[argument] = value; });
            }
            else if (type === "sampler_type") {
                _this.addProperty(argument, 0, "string");
                _this.wdgs[argument] = _this.addWidget("combo", argument, "type_1", function (value) { _this.properties[argument] = value; }, { values: sampler_types });
            }
        });
        _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.title = name.replace("minecraft:", "");
        _this.color = "#000033";
        return _this;
    }
    DensityFunction.prototype.updateWidgets = function () {
        for (var property in this.properties) {
            this.wdgs[property].value = this.properties[property];
        }
    };
    DensityFunction.prototype.onExecute = function () {
        var _this = this;
        var inputs = {};
        this.input_names.forEach(function (input) { return inputs[input] = _this.getInputDataByName(input); });
        this.setOutputData(0, __assign(__assign({ type: this.name }, this.properties), inputs));
    };
    return DensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/density_function_output.ts":
/*!***************************************************!*\
  !*** ./src/main/nodes/density_function_output.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DensityFunctionOutput": () => (/* binding */ DensityFunctionOutput)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var DensityFunctionOutput = /** @class */ (function (_super) {
    __extends(DensityFunctionOutput, _super);
    //static removable = false
    function DensityFunctionOutput() {
        var _this = _super.call(this) || this;
        _this.title = "Output";
        _this.color = "#333300";
        _this.addInput("result", "densityFunction", { label: "result", locked: true, nameLocked: true });
        _this.removable = false;
        _this.clonable = false;
        return _this;
    }
    DensityFunctionOutput.prototype.getMenuOptions = function (onExecute) {
        return [];
    };
    DensityFunctionOutput.title = "Output";
    return DensityFunctionOutput;
}(litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LGraphNode));



/***/ }),

/***/ "./src/main/nodes/density_function_spline.ts":
/*!***************************************************!*\
  !*** ./src/main/nodes/density_function_spline.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SplineDensityFunction": () => (/* binding */ SplineDensityFunction)
/* harmony export */ });
/* harmony import */ var _widgets_SplineWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../widgets/SplineWidget */ "./src/main/widgets/SplineWidget.ts");
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var spline_values = ["offset", "factor", "jaggedness"];
var sampler_types = ["type_1", "type_2"];
var SplineDensityFunction = /** @class */ (function (_super) {
    __extends(SplineDensityFunction, _super);
    function SplineDensityFunction() {
        var _this = _super.call(this) || this;
        _this.wdgs = {};
        _this.addInput("coordinate", "densityFunction", { label: "coordinate", locked: true, nameLocked: true });
        _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.splineWidget = _this.addCustomWidget(new _widgets_SplineWidget__WEBPACK_IMPORTED_MODULE_0__.SplineWidget());
        _this.addProperty("min_value", -1, "number");
        _this.wdgs.min_value = _this.addWidget("number", "min_value", -1, function (value) {
            _this.properties.min_value = value;
            _this.splineWidget.min_value = value;
        });
        _this.addProperty("max_value", 1, "number");
        _this.wdgs.max_value = _this.addWidget("number", "max_value", 1, function (value) {
            _this.properties.max_value = value;
            _this.splineWidget.max_value = value;
        });
        _this.title = "spline";
        _this.color = "#000033";
        return _this;
    }
    SplineDensityFunction.prototype.updateWidgets = function () {
        this.wdgs.min_value.value = this.properties.min_value;
        this.wdgs.max_value.value = this.properties.max_value;
        this.splineWidget.min_value = this.properties.min_value;
        this.splineWidget.max_value = this.properties.max_value;
    };
    SplineDensityFunction.prototype.onExecute = function () {
        var points = [];
        for (var i = 0; i < this.splineWidget.value.locations.length; i++) {
            points.push({
                location: this.splineWidget.value.locations[i],
                value: this.splineWidget.value.values[i](0),
                derivative: this.splineWidget.value.derivatives[i]
            });
        }
        this.setOutputData(0, {
            type: "minecraft:spline",
            min_value: this.properties.min_value,
            max_value: this.properties.max_value,
            spline: {
                coordinate: this.getInputDataByName("coordinate"),
                points: points
            }
        });
    };
    SplineDensityFunction.title = "spline";
    return SplineDensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_1__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/named_density_function.ts":
/*!**************************************************!*\
  !*** ./src/main/nodes/named_density_function.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NamedDensityFunction": () => (/* binding */ NamedDensityFunction)
/* harmony export */ });
/* harmony import */ var _LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LGraphNodeFixed */ "./src/main/nodes/LGraphNodeFixed.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var NamedDensityFunction = /** @class */ (function (_super) {
    __extends(NamedDensityFunction, _super);
    function NamedDensityFunction() {
        var _this = _super.call(this) || this;
        _this.getTitle = function () {
            if (this.flags.collapsed) {
                var id = this.properties.id;
                if (id.length > 20) {
                    id = id.substring(id.lastIndexOf("/") + 1);
                }
                return id;
            }
            return this.title;
        };
        _this.addOutput("output", "densityFunction", { locked: true, nameLocked: true });
        _this.addProperty("id", "", "string");
        _this.wdgt = _this.addWidget("text", "Id", "", function (value) { _this.properties.id = value; });
        _this.title = "Named Density Function";
        _this.color = "#330000";
        return _this;
    }
    NamedDensityFunction.prototype.updateWidgets = function () {
        this.wdgt.value = this.properties.id;
    };
    NamedDensityFunction.prototype.onExecute = function () {
        this.setOutputData(0, this.properties.id);
    };
    NamedDensityFunction.title = "Named Density Function";
    return NamedDensityFunction;
}(_LGraphNodeFixed__WEBPACK_IMPORTED_MODULE_0__.LGraphNodeFixed));



/***/ }),

/***/ "./src/main/nodes/register.ts":
/*!************************************!*\
  !*** ./src/main/nodes/register.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerNodes": () => (/* binding */ registerNodes)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "./node_modules/litegraph.js/build/litegraph.js");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vanilla_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vanilla/schemas */ "./src/main/vanilla/schemas.ts");
/* harmony import */ var _constant_density_function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant_density_function */ "./src/main/nodes/constant_density_function.ts");
/* harmony import */ var _density_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./density_function */ "./src/main/nodes/density_function.ts");
/* harmony import */ var _density_function_spline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./density_function_spline */ "./src/main/nodes/density_function_spline.ts");
/* harmony import */ var _named_density_function__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./named_density_function */ "./src/main/nodes/named_density_function.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






function registerNodes() {
    litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/named", _named_density_function__WEBPACK_IMPORTED_MODULE_5__.NamedDensityFunction);
    litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/constant", _constant_density_function__WEBPACK_IMPORTED_MODULE_2__.ConstantDensityFunction);
    litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/spline", _density_function_spline__WEBPACK_IMPORTED_MODULE_4__.SplineDensityFunction);
    _vanilla_schemas__WEBPACK_IMPORTED_MODULE_1__.schemas.forEach(function (schema, n) {
        var f = /** @class */ (function (_super) {
            __extends(f, _super);
            function f() {
                return _super.call(this, n, new Map(Object.entries(schema))) || this;
            }
            f.title = n.replace("minecraft:", "");
            return f;
        }(_density_function__WEBPACK_IMPORTED_MODULE_3__.DensityFunction));
        litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.registerNodeType("density_function/" + (n.replace("minecraft:", "")), f);
    });
}


/***/ }),

/***/ "./src/main/vanilla/schemas.ts":
/*!*************************************!*\
  !*** ./src/main/vanilla/schemas.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "schemas": () => (/* binding */ schemas),
/* harmony export */   "noise_router_fields": () => (/* binding */ noise_router_fields)
/* harmony export */ });
var schemas = new Map(Object.entries({
    'minecraft:abs': {
        argument: "densityFunction",
    },
    'minecraft:add': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:beardifier': {},
    'minecraft:blend_alpha': {},
    'minecraft:blend_density': {
        argument: "densityFunction",
    },
    'minecraft:blend_offset': {},
    'minecraft:cache_2d': {
        argument: "densityFunction",
    },
    'minecraft:cache_all_in_cell': {
        argument: "densityFunction",
    },
    'minecraft:cache_once': {
        argument: "densityFunction",
    },
    'minecraft:clamp': {
        input: "densityFunction",
        min: "number",
        max: "number",
    },
    'minecraft:cube': {
        argument: "densityFunction",
    },
    "minecraft:end_islands": {},
    'minecraft:flat_cache': {
        argument: "densityFunction",
    },
    'minecraft:half_negative': {
        argument: "densityFunction",
    },
    'minecraft:interpolated': {
        argument: "densityFunction",
    },
    'minecraft:max': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:min': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:mul': {
        argument1: "densityFunction",
        argument2: "densityFunction",
    },
    'minecraft:noise': {
        noise: "noise",
        xz_scale: "number",
        y_scale: "number",
    },
    "minecraft:old_blended_noise": {},
    'minecraft:quarter_negative': {
        argument: "densityFunction",
    },
    'minecraft:range_choice': {
        input: "densityFunction",
        min_inclusive: "number",
        max_exclusive: "number",
        when_in_range: "densityFunction",
        when_out_of_range: "densityFunction",
    },
    'minecraft:shift': {
        argument: "densityFunction",
    },
    'minecraft:shift_a': {
        argument: "densityFunction",
    },
    'minecraft:shift_b': {
        argument: "densityFunction",
    },
    'minecraft:shifted_noise': {
        shift_x: "densityFunction",
        shift_y: "densityFunction",
        shift_z: "densityFunction",
        noise: "noise",
        xz_scale: "number",
        y_scale: "number",
    },
    'minecraft:slide': {
        argument: "densityFunction",
    },
    'minecraft:square': {
        argument: "densityFunction",
    },
    'minecraft:squeeze': {
        argument: "densityFunction",
    },
    'minecraft:terrain_shaper_spline': {
        spline: "spline",
        min_value: "number",
        max_value: "number",
        continentalness: "densityFunction",
        erosion: "densityFunction",
        weirdness: "densityFunction",
    },
    'minecraft:weird_scaled_sampler': {
        rarity_value_mapper: "sampler_type",
        noise: "noise",
        input: "densityFunction",
    },
    'minecraft:y_clamped_gradient': {
        from_y: "number",
        to_y: "number",
        from_value: "number",
        to_value: "number",
    }
}));
var noise_router_fields = [
    "final_density",
    "vein_toggle",
    "vein_ridged",
    "vein_gap",
    "erosion",
    "depth",
    "ridges",
    "initial_density_without_jaggedness",
    "lava",
    "temperature",
    "vegetation",
    "continents",
    "barrier",
    "fluid_level_floodedness",
    "fluid_level_spread"
];


/***/ }),

/***/ "./src/main/widgets/SplineWidget.ts":
/*!******************************************!*\
  !*** ./src/main/widgets/SplineWidget.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SplineWidget": () => (/* binding */ SplineWidget)
/* harmony export */ });
/* harmony import */ var deepslate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepslate */ "./node_modules/deepslate/dist/deepslate.esm.js");

var SplineWidget = /** @class */ (function () {
    function SplineWidget() {
        this.value = new deepslate__WEBPACK_IMPORTED_MODULE_0__.Spline("spine", function (c) { return c; }, [-1, 1], [function () { return -1; }, function () { return 1; }], [1, 1]);
        this.min_input = -1;
        this.max_input = 1;
        this.min_value = -1;
        this.max_value = 1;
        this.options = {};
        this.dragging_id = -1;
        this.selected_id = -1;
        this.dragging_derivative = false;
        this.last_click_time = 0;
        this.expand_timer = undefined;
        this.shrink_timer = undefined;
    }
    SplineWidget.prototype.draw = function (ctx, node, width, posY, _height) {
        this.node = node;
        ctx.save();
        width -= 20;
        this.widged_width = width;
        this.widget_posy = posY;
        ctx.fillStyle = "black";
        ctx.rect(10, posY, width, width);
        ctx.clip();
        ctx.fillRect(10, posY, width, width);
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = "gray";
        for (var location = Math.floor(this.min_input / 2) * 2; location <= this.max_input; location += 0.5) {
            ctx.beginPath();
            var x_1 = this.inputToPos(location, width);
            ctx.lineTo(x_1, posY);
            ctx.lineTo(x_1, posY + width);
            ctx.stroke();
        }
        for (var value = Math.floor(this.min_value / 2) * 2; value <= this.max_value; value += 0.5) {
            ctx.beginPath();
            var y = this.outputToPos(value, width);
            ctx.lineTo(10, y);
            ctx.lineTo(10 + width, y);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        ctx.beginPath();
        var step = 5;
        for (var x = 0; x <= width; x += step) {
            ctx.lineTo(x + 10, this.outputToPos(this.value.apply(this.posToInput(x + 10, width)), width));
        }
        ctx.lineTo(width + 10, this.outputToPos(this.value.apply(this.posToInput(width + 10, width)), width));
        ctx.stroke();
        for (var i = 0; i < this.value.locations.length; i++) {
            var x_2 = this.inputToPos(this.value.locations[i], width);
            var y = this.outputToPos(this.value.values[i](0), width);
            ctx.fillStyle = i == this.selected_id ? "orange" : "white";
            ctx.beginPath();
            ctx.arc(x_2, y, i == this.selected_id ? 3 : 2, 0, 2 * Math.PI);
            ctx.fill();
            if (i == this.selected_id) {
                ctx.strokeStyle = "orange";
                ctx.lineWidth = 0.5;
                var derivative = this.value.derivatives[i] * (this.max_input - this.min_input) / (this.max_value - this.min_value);
                var angle = Math.atan(derivative);
                ctx.beginPath();
                ctx.lineTo(x_2 - 30 * Math.cos(angle), y + 30 * Math.sin(angle));
                ctx.lineTo(x_2 + 30 * Math.cos(angle), y - 30 * Math.sin(angle));
                ctx.stroke();
            }
        }
        //ctx.fillText(this.max_value.toFixed(2), 10, posY+12)
        //ctx.fillText(this.min_value.toFixed(2), 10, posY+width-1)
        ctx.restore();
        ctx.fillStyle = "white";
        ctx.fillText(this.min_input.toFixed(2), 10, posY + width + 12);
        ctx.fillText(this.max_input.toFixed(2), 10 + width - ctx.measureText(this.max_input.toFixed(2)).width, posY + width + 12);
        if (this.selected_id >= 0) {
            ctx.fillStyle = "orange";
            var text = "(" + this.value.locations[this.selected_id].toFixed(2) + ", " + this.value.values[this.selected_id](0).toFixed(2) + ")";
            ctx.fillText(text, 10 + width / 2 - ctx.measureText(text).width / 2, posY + width + 12);
        }
    };
    SplineWidget.prototype.posToInput = function (pos, width) {
        return (pos - 10) / width * (this.max_input - this.min_input) + this.min_input;
    };
    SplineWidget.prototype.inputToPos = function (input, width) {
        return (input - this.min_input) / (this.max_input - this.min_input) * width + 10;
    };
    SplineWidget.prototype.posToOutput = function (pos, width) {
        return (1 - ((pos - this.widget_posy) / width)) * (this.max_value - this.min_value) + this.min_value;
    };
    SplineWidget.prototype.outputToPos = function (output, height) {
        return (1 - ((output - this.min_value) / (this.max_value - this.min_value))) * height + this.widget_posy;
    };
    SplineWidget.prototype.mouse = function (event, pos, node) {
        if (event.type === "mousedown") {
            for (var i = 0; i < this.value.locations.length; i++) {
                var x = this.inputToPos(this.value.locations[i], this.widged_width);
                var y = this.outputToPos(this.value.values[i](0), this.widged_width);
                var distance = (x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1]);
                if (distance < 100) {
                    if (this.selected_id == i && (new Date().getTime() - this.last_click_time) < 500 && this.value.locations.length > 1) {
                        this.value.locations.splice(i, 1);
                        this.value.values.splice(i, 1);
                        this.value.derivatives.splice(i, 1);
                        this.dragging_id = -1;
                        this.selected_id = -1;
                        return false;
                    }
                    else {
                        this.dragging_id = i;
                        this.selected_id = i;
                        this.dragging_derivative = false;
                        this.last_click_time = new Date().getTime();
                        this.stopShrink();
                        return false;
                    }
                }
                else if (distance < 1000 && i == this.selected_id) {
                    var derivative = this.value.derivatives[i] * (this.max_input - this.min_input) / (this.max_value - this.min_value);
                    var mouse_angle = Math.atan((y - pos[1]) / (-x + pos[0]));
                    var derivative_angle = Math.atan(derivative);
                    if (Math.abs(mouse_angle - derivative_angle) < 0.1) {
                        this.dragging_id = i;
                        this.dragging_derivative = true;
                        this.stopShrink();
                        return false;
                    }
                }
            }
            var location_1 = this.posToInput(pos[0], this.widged_width);
            var value_1 = this.posToOutput(pos[1], this.widged_width);
            if (Math.abs(this.outputToPos(this.value.apply(location_1), this.widged_width) - pos[1]) < 10) {
                var index = this.value.locations.findIndex(function (loc) { return loc > location_1; });
                if (index === -1)
                    index = this.value.locations.length;
                this.value.locations.splice(index, 0, location_1);
                this.value.values.splice(index, 0, function () { return value_1; });
                this.value.derivatives.splice(index, 0, 0);
                this.dragging_id = index;
                this.selected_id = index;
                this.dragging_derivative = false;
                this.stopShrink();
                return false;
            }
            this.dragging_id = -1;
            this.selected_id = -1;
        }
        else if (event.type === "mousemove" && this.dragging_id >= 0) {
            if (this.dragging_derivative) {
                var x = this.inputToPos(this.value.locations[this.dragging_id], this.widged_width);
                var y = this.outputToPos(this.value.values[this.dragging_id](0), this.widged_width);
                this.value.derivatives[this.dragging_id] = (y - pos[1]) / (-x + pos[0]) / (this.max_input - this.min_input) * (this.max_value - this.min_value);
            }
            else {
                if (pos[0] < 0) {
                    this.startExpand("left");
                }
                else if (pos[0] > this.widged_width + 20) {
                    this.startExpand("right");
                }
                else {
                    this.stopExpand();
                }
                var location_2 = Math.clamp(this.posToInput(pos[0], this.widged_width), this.min_input, this.max_input);
                var value_2 = Math.clamp(this.posToOutput(pos[1], this.widged_width), this.min_value, this.max_value);
                var derivative = this.value.derivatives[this.dragging_id];
                while (this.dragging_id > 0 && location_2 < this.value.locations[this.dragging_id - 1]) {
                    this.value.locations[this.dragging_id] = this.value.locations[this.dragging_id - 1];
                    this.value.derivatives[this.dragging_id] = this.value.derivatives[this.dragging_id - 1];
                    this.value.values[this.dragging_id] = this.value.values[this.dragging_id - 1];
                    this.dragging_id--;
                    this.selected_id--;
                }
                while (this.dragging_id < this.value.locations.length - 1 && location_2 > this.value.locations[this.dragging_id + 1]) {
                    this.value.locations[this.dragging_id] = this.value.locations[this.dragging_id + 1];
                    this.value.derivatives[this.dragging_id] = this.value.derivatives[this.dragging_id + 1];
                    this.value.values[this.dragging_id] = this.value.values[this.dragging_id + 1];
                    this.dragging_id++;
                    this.selected_id++;
                }
                this.value.locations[this.dragging_id] = location_2;
                this.value.values[this.dragging_id] = function () { return value_2; };
                this.value.derivatives[this.dragging_id] = derivative;
            }
            return false;
        }
        else if (event.type === "mouseup") {
            this.stopExpand();
            this.dragging_id = -1;
            this.startShrink();
        }
        return false;
    };
    SplineWidget.prototype.computeSize = function (width) {
        return [width, width - 20 + 15];
    };
    SplineWidget.prototype.startExpand = function (direction) {
        var _this = this;
        if (!this.expand_timer) {
            this.expand_timer = setInterval(function () {
                var _a;
                if (direction === "left") {
                    _this.min_input -= 0.02;
                    _this.value.locations[_this.dragging_id] = _this.min_input;
                }
                else {
                    _this.max_input += 0.02;
                    _this.value.locations[_this.dragging_id] = _this.max_input;
                }
                (_a = _this.node) === null || _a === void 0 ? void 0 : _a.setDirtyCanvas(true, false);
            }, 20);
        }
    };
    SplineWidget.prototype.stopExpand = function () {
        if (this.expand_timer) {
            clearInterval(this.expand_timer);
            this.expand_timer = undefined;
        }
    };
    SplineWidget.prototype.startShrink = function () {
        var _this = this;
        if (!this.shrink_timer) {
            this.shrink_timer = setInterval(function () {
                var _a;
                var changed = false;
                if (_this.min_input < _this.value.locations[0] - 0.3) {
                    _this.min_input += 0.02;
                    changed = true;
                }
                if (_this.max_input > _this.value.locations[_this.value.locations.length - 1] + 0.3) {
                    _this.max_input -= 0.02;
                    changed = true;
                }
                if (!changed) {
                    _this.stopShrink();
                }
                else {
                    (_a = _this.node) === null || _a === void 0 ? void 0 : _a.setDirtyCanvas(true, false);
                }
            }, 20);
        }
    };
    SplineWidget.prototype.stopShrink = function () {
        if (this.shrink_timer) {
            clearInterval(this.shrink_timer);
            this.shrink_timer = undefined;
        }
    };
    return SplineWidget;
}());



/***/ }),

/***/ "./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deflate": () => (/* binding */ Deflate_1),
/* harmony export */   "Inflate": () => (/* binding */ Inflate_1),
/* harmony export */   "constants": () => (/* binding */ constants_1),
/* harmony export */   "default": () => (/* binding */ pako),
/* harmony export */   "deflate": () => (/* binding */ deflate_1),
/* harmony export */   "deflateRaw": () => (/* binding */ deflateRaw_1),
/* harmony export */   "gzip": () => (/* binding */ gzip_1),
/* harmony export */   "inflate": () => (/* binding */ inflate_1),
/* harmony export */   "inflateRaw": () => (/* binding */ inflateRaw_1),
/* harmony export */   "ungzip": () => (/* binding */ ungzip_1)
/* harmony export */ });

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


const deflate$2 = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;

var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 30;       /* got a data error -- remain here until reset */
const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;

var pako = {
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
};




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./src/main/app.ts ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _UI_GraphManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI/GraphManager */ "./src/main/UI/GraphManager.ts");
/* harmony import */ var _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UI/MenuManager */ "./src/main/UI/MenuManager.ts");


onload = function () {
    _UI_MenuManager__WEBPACK_IMPORTED_MODULE_1__.MenuManager.addHandlers();
    _UI_GraphManager__WEBPACK_IMPORTED_MODULE_0__.GraphManager.init();
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RSxNQUFNLGFBQWEsb0ZBQW9GLFNBQVMsR0FBRyxTQUFTLDBHQUEwRyxNQUFNLGFBQWEsdUVBQXVFLGFBQWEsU0FBUyxlQUFlLHlCQUF5QixjQUFjLDRCQUE0Qiw2QkFBNkIseUJBQXlCLG1DQUFtQyxTQUFTLEdBQUcsU0FBUyxvSEFBb0gsc0hBQXNILFFBQVEsb0JBQW9CLHNWQUFzVixNQUFNLFlBQVksYUFBYSx3REFBd0Qsd0JBQXdCLE9BQU8sOEJBQThCLFlBQVksd0JBQXdCLFlBQVksSUFBSSx3QkFBd0IsU0FBUyxXQUFXLHdCQUF3QixZQUFZLElBQUksdUJBQXVCLFNBQVMsWUFBWSx3QkFBd0IsWUFBWSxJQUFJLHdCQUF3QixTQUFTLFNBQVMsdUVBQXVFLGtDQUFrQyxXQUFXLFFBQVEsV0FBVyw0WEFBNFgseUNBQXlDLElBQUksT0FBTyx5Q0FBeUMsWUFBWSxJQUFJLHNCQUFzQixPQUFPLGdCQUFnQixXQUFXLFdBQVcsTUFBTSxFQUFFLHVCQUF1QixtQkFBbUIsa0NBQWtDLE1BQU0sZ0JBQWdCLFVBQVUsUUFBUSxrQkFBa0IsNllBQTZZLGVBQWUsc0JBQXNCLG9DQUFvQyw2QkFBNkIsS0FBSyxJQUFJLE1BQU0sK0NBQStDLG9LQUFvSyxVQUFVLCtEQUErRCxRQUFRLGdCQUFnQixxRkFBcUYsUUFBUSw4QkFBOEIsYUFBYSxzR0FBc0csWUFBWSxtQkFBbUIsWUFBWSxXQUFXLG1CQUFtQixhQUFhLG1CQUFtQixZQUFZLFdBQVcsb0JBQW9CLFVBQVUsb0JBQW9CLGFBQWEsUUFBUSxXQUFXLGtPQUFrTyxTQUFTLElBQUksd0dBQXdHLFFBQVEsc0RBQXNELFlBQVksaUJBQWlCLDZCQUE2QixZQUFZLG9GQUFvRixrQkFBa0IsZ0JBQWdCLG1CQUFtQix5RUFBeUUsT0FBTyxvQ0FBb0MsZ0JBQWdCLFNBQVMsb0RBQVMsT0FBTyxnQkFBZ0IsMkVBQTJFLDRCQUE0QixFQUFFLDZCQUE2QixNQUFNLGNBQWMsV0FBVyxZQUFZLEtBQUssaUJBQWlCLEtBQUssTUFBTSw2QkFBNkIsdUJBQXVCLHFMQUFxTCxRQUFRLHlDQUF5QyxFQUFFLFNBQVMsa0JBQWtCLGlCQUFpQixzQkFBc0IsOEJBQThCLE1BQU0sdUJBQXVCLE1BQU0sb0RBQW9ELGNBQWMsR0FBRyxTQUFTLGdCQUFnQixpQkFBaUIsMkVBQTJFLGtCQUFrQixlQUFlLE9BQU8sNENBQUMsd0JBQXdCLGtCQUFrQix1QkFBdUIsY0FBYyxRQUFRLGtEQUFrRCw2REFBNkQsUUFBUSxrQkFBa0IsaUVBQWlFLDJGQUEyRixlQUFlLGtGQUFrRixTQUFTLG9CQUFvQixpQkFBaUIsc0JBQXNCLG1CQUFtQixNQUFNLHlCQUF5QixNQUFNLG1CQUFtQixNQUFNLG9EQUFvRCxjQUFjLEdBQUcsU0FBUyxrQkFBa0Isc0NBQXNDLG9EQUFvRCxFQUFFLElBQUksRUFBRSxJQUFJLFNBQVMsa0JBQWtCLG9DQUFvQyxHQUFHLE1BQU0sNkNBQTZDLEdBQUcsZ0JBQWdCLEVBQUUsY0FBYyxVQUFVLEdBQUcsa0JBQWtCLG9CQUFvQixzQkFBc0IsMENBQTBDLEdBQUcsa0JBQWtCLEVBQUUsZUFBZSxPQUFPLElBQUkscURBQXFELEdBQUcseUJBQXlCLEVBQUUscUJBQXFCLGVBQWUsR0FBRyxlQUFlLGdCQUFnQixJQUFJLFdBQVcsU0FBUyxVQUFVLFFBQVEsa0JBQWtCLEVBQUUsOEJBQThCLFVBQVUsaUJBQWlCLGdCQUFnQix1QkFBdUIsZUFBZSwwQkFBMEIsVUFBVSxrRUFBa0UsVUFBVSx5R0FBeUcsV0FBVyw0REFBNEQsVUFBVSxHQUFHLGtFQUFrRSxHQUFHLGtCQUFrQixrRkFBa0YsZ0VBQWdFLEtBQUssb0JBQW9CLEtBQUssRUFBRSxrQkFBa0IsbUJBQW1CLFFBQVEsbURBQW1ELGlHQUFpRyxNQUFNLG1EQUFtRCxHQUFHLG1CQUFtQiw2QkFBNkIsUUFBUSxlQUFlLDREQUE0RCxnQkFBZ0Isb0JBQW9CLGFBQWEsc0JBQXNCLHFCQUFxQixNQUFNLHdDQUF3QyxzREFBc0QsdUJBQXVCLCtDQUErQyx3RkFBd0YsMENBQTBDLFFBQVEsbUJBQW1CLHdGQUF3RixXQUFXLDZCQUE2QixpQkFBaUIsb0JBQW9CLGlCQUFpQiwwQkFBMEIsb0JBQW9CLHVDQUF1QyxtQkFBbUIsNkJBQTZCLGlCQUFpQixNQUFNLHdEQUF3RCxxRkFBcUYsbUJBQW1CLHlDQUF5Qyx1QkFBdUIsYUFBYSwwQkFBMEIsNkJBQTZCLGtDQUFrQyxzQkFBc0IsNkZBQTZGLFVBQVUsYUFBYSx1QkFBdUIsWUFBWSw0QkFBNEIsd0JBQXdCLHdCQUF3QixtREFBbUQseUJBQXlCLGVBQWUseUJBQXlCLGVBQWUseUJBQXlCLGdCQUFnQix5QkFBeUIsaUJBQWlCLFNBQVMsZUFBZSxjQUFjLDRDQUE0Qyx5QkFBeUIsa0NBQWtDLHVCQUF1Qiw4Q0FBOEMsMEJBQTBCLGtDQUFrQywyQkFBMkIsbUNBQW1DLDBDQUEwQyw0Q0FBNEMseUJBQXlCLE1BQU0seUNBQXlDLHNFQUFzRSwyQkFBMkIsYUFBYSxzQkFBc0IsU0FBUyxHQUFHLFFBQVEseUJBQXlCLDBFQUEwRSwyREFBMkQsT0FBTyx3Q0FBd0MsVUFBVSxHQUFHLDREQUE0RCxHQUFHLFVBQVUsaUJBQWlCLGtCQUFrQiw0REFBNEQsR0FBRywrQkFBK0IsVUFBVSxHQUFHLG1CQUFtQiwrQ0FBK0MsNkVBQTZFLG9CQUFvQix5RUFBeUUsb0JBQW9CLE1BQU0sWUFBWSw2QkFBNkIsZ0RBQWdELElBQUksWUFBWSxpQ0FBaUMsOEVBQThFLGtCQUFrQixPQUFPLGlEQUFpRCxZQUFZLDBGQUEwRixrQkFBa0IsdUZBQXVGLGdCQUFnQiwrQ0FBK0MsMEZBQTBGLElBQUkscUJBQXFCLGNBQWMsV0FBVyxrQkFBa0IsaUNBQWlDLGtCQUFrQixpQkFBaUIsd0JBQXdCLDhCQUE4QixrQ0FBa0MsMENBQTBDLGtCQUFrQiw0QkFBNEIsY0FBYyw2QkFBNkIsa0JBQWtCLFVBQVUsS0FBSyxJQUFJLEVBQUUsOEJBQThCLHdCQUF3QixTQUFTLFFBQVEsZUFBZSxtR0FBbUcsWUFBWSxNQUFNLGlCQUFpQixZQUFZLE1BQU0sTUFBTSxxQ0FBcUMscUNBQXFDLGNBQWMsVUFBVSw4RUFBOEUsUUFBUSxrQ0FBa0MseUpBQXlKLGtIQUFrSCxjQUFjLG1KQUFtSixnQkFBZ0IsbUxBQW1MLG9XQUFvVyxvSkFBb0osS0FBSyxxQkFBcUIsNEJBQTRCLHNCQUFzQixpREFBaUQsd0JBQXdCLHlCQUF5Qiw2QkFBNkIsOE1BQThNLFFBQVEsZUFBZSxtR0FBbUcsWUFBWSxNQUFNLDZCQUE2QixZQUFZLE1BQU0sTUFBTSxxQ0FBcUMscUNBQXFDLHNCQUFzQiw0R0FBNEcsUUFBUSxVQUFVLHNCQUFzQix5QkFBeUIsMkNBQTJDLDZCQUE2QixvWEFBb1gseUNBQXlDLEtBQUssMEJBQTBCLFFBQVEsbUJBQW1CLG9FQUFvRSxpQ0FBaUMsYUFBYSxLQUFLLHNFQUFzRSxzSUFBc0ksMkJBQTJCLGtFQUFrRSxZQUFZLDBCQUEwQixNQUFNLDRCQUE0QixxR0FBcUcsU0FBUyxrQkFBa0IscURBQXFELGVBQWUsNkNBQTZDLFFBQVEsZUFBZSxpTEFBaUwsc0JBQXNCLGNBQWMsWUFBWSxJQUFJLE1BQU0seUNBQXlDLDREQUE0RCwyQkFBMkIsS0FBSyxpQkFBaUIsWUFBWSxZQUFZLEtBQUssTUFBTSw0REFBNEQsNkpBQTZKLHlCQUF5QixRQUFRLGVBQWUsMkJBQTJCLEVBQUUsaURBQWlELGlCQUFpQixZQUFZLFdBQVcsaURBQWlELHlCQUF5Qix1QkFBdUIsY0FBYywrREFBK0QsNkVBQTZFLDhDQUE4Qyx1QkFBdUIsVUFBVSxvREFBb0QsT0FBTyxtSEFBbUgsTUFBTSxrREFBa0QsdUJBQXVCLFNBQVMsR0FBRyxRQUFRLGlCQUFpQiwwREFBMEQsdUVBQXVFLGNBQWMsSUFBSSxrRUFBa0UsMkRBQTJELDBGQUEwRixjQUFjLG9FQUFvRSxZQUFZLDBCQUEwQixNQUFNLDRCQUE0Qiw4REFBOEQsVUFBVSxRQUFRLGVBQWUsb0NBQW9DLE9BQU8sOEJBQThCLFdBQVcsd0NBQXdDLFVBQVUsNERBQTRELFdBQVcsWUFBWSxJQUFJLG9CQUFvQixRQUFRLGVBQWUsb0RBQW9ELG1DQUFtQyxXQUFXLG1DQUFtQyx5RUFBeUUsUUFBUSxLQUFLLGtDQUFrQyxFQUFFLFNBQVMsV0FBVyxnRUFBZ0UsWUFBWSx3Q0FBd0MsYUFBYSxzQkFBc0IsNkNBQTZDLGdNQUFnTSxrQkFBa0IsY0FBYyxpQ0FBaUMsV0FBVyxrQkFBa0IsUUFBUSxvQ0FBb0MsUUFBUSxnQ0FBZ0MsZ0ZBQWdGLFNBQVMsNkdBQTZHLDBFQUEwRSw0RUFBNEUsdUxBQXVMLGlDQUFpQyxrQkFBa0Isd0hBQXdILGlNQUFpTSxrU0FBa1MsTUFBTSxXQUFXLGFBQWEsMkRBQTJELGtEQUFrRCx5RkFBeUYsTUFBTSx3REFBd0Qsa0JBQWtCLE1BQU0sd0RBQXdELGtCQUFrQixPQUFPLGtCQUFrQixRQUFRLDZCQUE2Qiw0QkFBNEIsUUFBUSx3Q0FBd0MsU0FBUyxpQkFBaUIsUUFBUSw2Q0FBUSxHQUFHLFlBQVksV0FBVyx1Q0FBdUMsb0RBQWUsMENBQTBDLGFBQWEseUJBQXlCLElBQUksMENBQTBDLEdBQUcsVUFBVSw0QkFBNEIsTUFBTSw2QkFBNkIsTUFBTSw2QkFBNkIsVUFBVSw0QkFBNEIsTUFBTSw2QkFBNkIsTUFBTSw2QkFBNkIsT0FBTyw0Q0FBNEMsV0FBVyxHQUFHLFNBQVMsbUJBQW1CLDJEQUEyRCxvQkFBb0Isa0JBQWtCLHlFQUF5RSx5QkFBeUIsNEJBQTRCLGdDQUFnQyxtQkFBbUIsMkhBQTJILFNBQVMsd0JBQXdCLFlBQVkscURBQXFELGtCQUFrQixvSUFBb0ksYUFBYSxRQUFRLDZDQUFRLEdBQUcsK0NBQVUsSUFBSSxnREFBVyxjQUFjLDhDQUFTLE1BQU0sK0NBQVUsa0NBQWtDLDhDQUFTLE1BQU0sK0NBQVUsa0NBQWtDLGdEQUFXLGtDQUFrQywwR0FBMEcsUUFBUSw2Q0FBUSxHQUFHLCtDQUFVLElBQUksNENBQU8sMEJBQTBCLGlCQUFpQixnQkFBZ0IsMkNBQTJDLG9CQUFvQiwrQkFBK0Isd0JBQXdCLGdCQUFnQixHQUFHLGlCQUFpQixvRUFBb0UsVUFBVSxpRUFBaUUscUJBQXFCLHlDQUF5QyxVQUFVLHFGQUFxRixLQUFLLDhCQUE4QixzQkFBc0IscUNBQXFDLFNBQVMscUJBQXFCLDBFQUEwRSxzQkFBc0IsTUFBTSwwQkFBMEIsMERBQTBELDRDQUE0QywwR0FBMEcsT0FBTyxrREFBa0QsK0JBQStCLDRCQUE0Qix3R0FBd0csNEJBQTRCLDhGQUE4RixvVUFBb1Usa0RBQWtELHdGQUF3RixrSkFBa0osMkVBQTJFLDBxQ0FBMHFDLFFBQVEsNkNBQVEsR0FBRyxHQUFHLCtDQUFVLGdCQUFnQixRQUFRLGlEQUFZLHVCQUF1QixnREFBVyxRQUFRLDZDQUFRLEtBQUssK0NBQVUsNERBQTRELDRDQUFPLDBCQUEwQiw2Q0FBUSxNQUFNLGdEQUFXLFFBQVEsNEJBQTRCLGdCQUFnQiwyQ0FBMkMsY0FBYyxZQUFZLGtCQUFrQix5RkFBeUYsd0RBQXdELFdBQVcsTUFBTSxpQ0FBaUMscUNBQXFDLG9DQUFvQyxhQUFhLDBDQUEwQyx1RkFBdUYsb0RBQW9ELGVBQWUsbURBQW1ELHNCQUFzQixxQkFBcUIsZUFBZSw2RkFBNkYsU0FBUyxtQkFBbUIsbURBQW1ELGFBQWEsb0JBQW9CLHVCQUF1Qix3SEFBd0gsb0xBQW9MLDZCQUE2QixHQUFHLFNBQVMsZ0JBQWdCLGdDQUFnQyw2R0FBNkcsK0JBQStCLCtDQUErQyxVQUFVLDRCQUE0QixHQUFHLGdDQUFnQyxVQUFVLHVCQUF1QixtQkFBbUIsSUFBSSxVQUFVLFlBQVkscUJBQXFCLHFDQUFxQyxVQUFVLHlCQUF5Qiw0RUFBNEUsdUJBQXVCLEVBQUUsc0JBQXNCLHlCQUF5QixFQUFFLGdDQUFnQyxFQUFFLE9BQU8sR0FBRyxpQ0FBaUMsSUFBSSwyQ0FBMkMsT0FBTyw2Q0FBNkMsUUFBUSw2Q0FBNkMsT0FBTyw0Q0FBNEMsUUFBUSw2Q0FBNkMsT0FBTyw4Q0FBOEMsSUFBSSxVQUFVLCtLQUErSyxrQ0FBa0MsZUFBZSwwQkFBMEIsR0FBRyxrQ0FBa0MsSUFBSSxhQUFhLE9BQU8sYUFBYSxRQUFRLGFBQWEsT0FBTyxhQUFhLFFBQVEsYUFBYSxPQUFPLGVBQWUsSUFBSSxzQkFBc0IsNkJBQTZCLFNBQVMscUJBQXFCLFFBQVEsK1pBQStaLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLHlCQUF5Qix1QkFBdUIsbUNBQW1DLGtDQUFrQyxrQ0FBa0MsdUJBQXVCLDRDQUE0QywyQkFBMkIsNkJBQTZCLDZEQUE2RCxLQUFLLCtCQUErQixpQ0FBaUMsa0NBQWtDLGtDQUFrQyxnQ0FBZ0MsdUJBQXVCLG9EQUFvRCxvQ0FBb0MsNkVBQTZFLEtBQUssOEVBQThFLDZCQUE2Qix5QkFBeUIsdUJBQXVCLGdDQUFnQyx1QkFBdUIsNENBQTRDLHlCQUF5QixLQUFLLCtCQUErQiw4QkFBOEIsdUJBQXVCLHVDQUF1QyxLQUFLLCtFQUErRSw0QkFBNEIseUJBQXlCLHVCQUF1QixnQ0FBZ0MsdUJBQXVCLDRDQUE0QyxnQ0FBZ0MsS0FBSywrQkFBK0IsOEJBQThCLHVCQUF1Qix1Q0FBdUMsS0FBSyxxVUFBcVUsZ0JBQWdCLGlKQUFpSixhQUFhLHFPQUFxTyxrQkFBa0IsZ0NBQWdDLDZTQUE2UyxpQkFBaUIsa0ZBQWtGLDZDQUFRLEdBQUcsT0FBTyxrREFBYSxpQkFBaUIsWUFBWSxzR0FBc0csa0lBQWtJLHVHQUF1Ryx1QkFBdUIsMEJBQTBCLE1BQU0sa0JBQWtCLFFBQVEsNkNBQVEsR0FBRyxnREFBVyxpSUFBaUksWUFBWSxvQkFBb0IsT0FBTyxRQUFRLGlEQUFZLGtEQUFrRCxpREFBWSxvREFBb0QsaURBQVksa0RBQWtELCtDQUFVLFFBQVEsK0NBQVUsUUFBUSw0Q0FBTyxRQUFRLGdEQUFXLDBDQUEwQyxZQUFZLHNCQUFzQixpQ0FBaUMsOERBQThELE9BQU8scUhBQXFILE9BQU8seWtCQUF5a0IsdWZBQXVmLE1BQU0saUJBQWlCLHlCQUF5QixLQUFLLHdEQUF3RCxLQUFLLE9BQU8sMkNBQTJDLDhIQUE4SCxxQ0FBcUMsZUFBZSxHQUFHLHNIQUFzSCxrQkFBa0IsNkNBQVEsaUJBQWlCLHlCQUF5QixJQUFJLGdEQUFnRCxxTEFBcUwsd0pBQXdKLFNBQVMsdUNBQXVDLEVBQUUsTUFBTSxpQkFBaUIseUJBQXlCLEtBQUssd0RBQXdELEtBQUssT0FBTyxlQUFlLFFBQVEsMEZBQTBGLDhKQUE4SixpQkFBaUIsZ0RBQWdELGdQQUFnUCxZQUFZLEtBQUsseUJBQXlCLFlBQVksS0FBSyx5QkFBeUIsWUFBWSxRQUFRLCtCQUErQixPQUFPLDBKQUEwSixvQkFBb0IsZ0JBQWdCLGtEQUFrRCwwSkFBMEosMkJBQTJCLHdDQUF3QywyQ0FBMkMsWUFBWSxPQUFPLGlCQUFpQixPQUFPLGlCQUFpQixPQUFPLE1BQU0seUNBQXlDLDJVQUEyVSxPQUFPLDBKQUEwSixtQkFBbUIsd2NBQXdjLFlBQVksS0FBSyxrQkFBa0Isa0JBQWtCLCtCQUErQiw4RUFBOEUsb0JBQW9CLG9FQUFvRSxZQUFZLDBSQUEwUix1QkFBdUIsd1ZBQXdWLGlCQUFpQixrT0FBa08sZUFBZSxlQUFlLHNXQUFzVyxHQUFHLEdBQUcsR0FBRyx3QkFBd0IscUlBQXFJLGVBQWUsZUFBZSxrUUFBa1EsR0FBRyxHQUFHLEdBQUcsaUJBQWlCLGdLQUFnSyxRQUFRLDZDQUFRLEdBQUcsMkNBQU0sTUFBTSxnREFBVywySUFBMkkscUJBQXFCLGdFQUFnRSxhQUFhLDBDQUEwQyxxQkFBcUIsdURBQXVELG9JQUFvSSxnQkFBZ0Isd0RBQXdEO0FBQ2g3dEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLDBDQUEwQyxjQUFjLElBQUksYUFBYSxTQUFTLE1BQU0sY0FBYyxJQUFJLGNBQWMsU0FBUyxNQUFNLGNBQWMsTUFBTSxpRUFBaUUsS0FBSyxjQUFjLCtCQUErQixHQUFHLFNBQVMsaUJBQWlCLDZDQUE2QyxrQkFBa0IsZ0JBQWdCLGdCQUFnQixNQUFNLHdFQUF3RSxvQkFBb0IsMENBQTBDLDRJQUE0SSxxQkFBcUIsMkJBQTJCLDJCQUEyQixXQUFXLFFBQVEsbUZBQW1GLDhCQUE4QixnQ0FBZ0Msc0NBQXNDLHlDQUF5Qyx3Q0FBd0MsR0FBRyxlQUFlLHlDQUF5Qyx1QkFBdUIsMkJBQTJCLG1FQUFtRSxFQUFFLDZCQUE2Qix5R0FBeUcsNEJBQTRCLGFBQWEsZ0JBQWdCLGdEQUFnRCwrQkFBK0IsMEJBQTBCLHNDQUFzQyw4Q0FBOEMsV0FBVyxRQUFRLGlCQUFpQixzQkFBc0IsWUFBWSxzRkFBc0YsMkJBQTJCLFNBQVMsZ0VBQWdFLG1CQUFtQixNQUFNLHdDQUF3QywyRUFBMkUsdUNBQXVDLFVBQVUsUUFBUSwyQkFBMkIscUhBQXFILFlBQVksaVJBQWlSLFFBQVEsa0lBQWtJLG1CQUFtQixRQUFRLG9EQUFvRCwrTUFBK00sZUFBZSxRQUFRLHlCQUF5Qix1R0FBdUcsYUFBYSxTQUFTLFVBQVUsZ0hBQWdILGdCQUFnQixtQkFBbUIsZUFBZSxrQ0FBa0MsUUFBUSxxREFBcUQsUUFBUSxlQUFlLGdEQUFnRCxnQkFBZ0IsNEJBQTRCLGtDQUFrQyxtQkFBbUIsUUFBUSxZQUFZLElBQUksTUFBTSxtQkFBbUIsNkJBQTZCLE9BQU8sY0FBYyxxQ0FBcUMsT0FBTyxPQUFPLGdCQUFnQixvQkFBb0IsWUFBWSxJQUFJLEtBQUssZ0NBQWdDLFFBQVEsb0NBQW9DLGVBQWUsaUdBQWlHLG1CQUFtQixrQkFBa0IscUNBQXFDLE9BQU8sNEJBQTRCLHFDQUFxQyxPQUFPLE9BQU8sb0JBQW9CLFdBQVcsU0FBUyxxRUFBcUUsK0RBQStELHdDQUF3QyxlQUFlLFFBQVEsMENBQTBDLFNBQVMsWUFBWSxnREFBZ0QsaUNBQWlDLFFBQVEsZUFBZSxhQUFhLFlBQVksUUFBUSxZQUFZLElBQUksd0NBQXdDLFVBQVUsVUFBVSxrQkFBa0IsZUFBZSx1Q0FBdUMscUJBQXFCLCtDQUErQyxzRUFBc0UsU0FBUyxZQUFZLGlCQUFpQiw4QkFBOEIsZUFBZSxpQkFBaUIsc0NBQXNDLGdCQUFnQixVQUFVLGFBQWEsa0JBQWtCLGlCQUFpQiw4QkFBOEIsU0FBUyxhQUFhLFVBQVUsV0FBVyxHQUFHLFNBQVMsZUFBZSxhQUFhLFdBQVcsa0JBQWtCLG1CQUFtQixRQUFRLG1EQUFtRCx1RUFBdUUsa0JBQWtCLFNBQVMsZUFBZSxrQkFBa0Isa0JBQWtCLGlCQUFpQiwrQkFBK0IsbUJBQW1CLFFBQVEsbURBQW1ELHdDQUF3QyxNQUFNLFdBQVcsTUFBTSxPQUFPLDJIQUEySCw2Q0FBNkMsRUFBRSwyREFBMkQscUNBQXFDLGFBQWEsY0FBYyx1QkFBdUIsY0FBYyxrQkFBa0IsY0FBYyxrQkFBa0IsY0FBYyxxREFBcUQsNEVBQTRFLE9BQU8sZ0RBQWdELDJCQUEyQiwwQ0FBMEMsdUJBQXVCLE9BQU8saURBQWlELDhqQ0FBOGpDLG9CQUFvQixzSUFBc0ksTUFBTSw2SkFBNkosa0VBQWtFLEtBQUssNEhBQTRILGlGQUFpRixTQUFTLGdDQUFnQyx3Y0FBd2MsOEZBQThGLGdCQUFnQiwrQ0FBK0MsR0FBRyxFQUFFLEVBQUUsMERBQTBELDZDQUE2QyxJQUFJLGdCQUFnQix1REFBdUQseURBQXlELGdDQUFnQyx3REFBd0QsS0FBSyxvQkFBb0IsaUdBQWlHLFNBQVMsa0JBQWtCLGlEQUFpRCw0Q0FBNEMsb0JBQW9CLGtCQUFrQiwwQkFBMEIsdUNBQXVDLDRJQUE0SSxXQUFXLEdBQUcsU0FBUyx5QkFBeUIsa1pBQWtaLDBCQUEwQixtQkFBbUIsWUFBWSxNQUFNLHFCQUFxQixTQUFTLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLDhDQUE4QyxlQUFlLFlBQVksb0JBQW9CLHVFQUF1RSxrQkFBa0IsZ1JBQWdSLGNBQWMsZ01BQWdNLGNBQWMsZ0dBQWdHLGtCQUFrQixzQ0FBc0MsYUFBYSxxREFBcUQsU0FBUyw2QkFBNkIsNkdBQTZHLHVEQUF1RCxvYUFBb2EsNkRBQTZELEVBQUUsa0JBQWtCLHdWQUF3Vix1Q0FBdUMscUJBQXFCLGdEQUFnRCxnTkFBZ04scUJBQXFCLGlCQUFpQix3Q0FBd0MsMkJBQTJCLG1EQUFtRCwwQkFBMEIsbUxBQW1MLFlBQVksS0FBSyxNQUFNLGtMQUFrTCwyQkFBMkIsdUJBQXVCLGtCQUFrQixzRUFBc0UscUJBQXFCLGlDQUFpQyx3R0FBd0csbUJBQW1CLGdCQUFnQix5REFBeUQsa0NBQWtDLHNGQUFzRix1Q0FBdUMscUNBQXFDLDRFQUE0RSwwQ0FBMEMsU0FBUywwQ0FBMEMsd0JBQXdCLFNBQVMscUJBQXFCLHVUQUF1VCxRQUFRLHdWQUF3Viw0Q0FBNEMsWUFBWSxtQkFBbUIsTUFBTSxrQ0FBa0MsWUFBWSxtQkFBbUIsTUFBTSw4Q0FBOEMsY0FBYyxLQUFLLE1BQU0sb0NBQW9DLDRCQUE0QixLQUFLLE1BQU0sOERBQThELGdFQUFnRSwwQkFBMEIsZ0NBQWdDLFlBQVksaUJBQWlCLE1BQU0sdURBQXVELGdDQUFnQyxZQUFZLGlCQUFpQixNQUFNLHVHQUF1Ryw4Q0FBOEMsZ0NBQWdDLG1CQUFtQiwrSEFBK0gsYUFBYSx1QkFBdUIsNEJBQTRCLG9EQUFvRCxPQUFPLG0zQkFBbTNCLFdBQVcsZUFBZSx1QkFBdUIsY0FBYyxvREFBb0QsT0FBTyxvUEFBb1AsV0FBVyxlQUFlLHVCQUF1QixZQUFZLG9EQUFvRCxPQUFPLG1LQUFtSyxXQUFXLGVBQWUsdUJBQXVCLHdCQUF3QixvREFBb0QsT0FBTyxzM0JBQXMzQixXQUFXLGVBQWUsdUJBQXVCLE1BQU0sb0RBQW9ELE9BQU8sb0RBQW9ELFVBQVUsT0FBTyxxS0FBcUssMENBQTBDLE1BQU0sV0FBVyxVQUFVLE9BQU8seUtBQXlLLDZDQUE2QyxFQUFFLEtBQUssV0FBVyxlQUFlLHVCQUF1QixNQUFNLG9EQUFvRCxPQUFPLGdOQUFnTixXQUFXLEdBQXdpQztBQUMvcG5COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakR3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxnQkFBZ0Isa0RBQW1COztBQUVuQyxNQUFNLGtEQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxnQkFBZ0Isa0RBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwrQ0FBZ0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwrQ0FBZ0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1Asd0JBQXdCLGtEQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksY0FBYztBQUMxQixZQUFZLE1BQU07QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksY0FBYztBQUMxQixZQUFZLE1BQU07QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsWUFBWSxNQUFNO0FBQ2xCOztBQUVPO0FBQ1Asb0JBQW9CLGtEQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QjtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsK0NBQWdCLCtCQUErQiwrQ0FBZ0IsK0JBQStCLCtDQUFnQjtBQUMvSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFNBQVM7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFNBQVM7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCLHFFQUFxRSwrQ0FBZ0IscUVBQXFFLCtDQUFnQix1RUFBdUUsK0NBQWdCLHlFQUF5RSwrQ0FBZ0IseUVBQXlFLCtDQUFnQix5RUFBeUUsK0NBQWdCLHlFQUF5RSwrQ0FBZ0IseUVBQXlFLCtDQUFnQjtBQUMvekM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcjNEaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1AsZ0JBQWdCLGtEQUFtQjs7QUFFbkMsTUFBTSxrREFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUCxnQkFBZ0Isa0RBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQLGdCQUFnQixrREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQSxVQUFVLDhDQUFlO0FBQ3pCLFVBQVUsOENBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25COztBQUVPO0FBQ1A7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjs7QUFFTztBQUNQO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsU0FBUztBQUN0Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsU0FBUztBQUN0Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBZ0IscUVBQXFFLCtDQUFnQixxRUFBcUUsK0NBQWdCO0FBQ3hOO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7QUNseEJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx3Q0FBd0M7QUFDeEMsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWIsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDRDQUE0QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixVQUFVO0FBQzdCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFELGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0Isb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckMsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QyxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDOztBQUVsQztBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0IseUJBQXlCO0FBQ3pCO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25ELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsU0FBUzs7QUFFVDtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTywwRkFBMEY7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsR0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUSxpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixTQUFTLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxxQkFBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSw0Q0FBNEM7QUFDNUMsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25DLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUEsOEVBQThFO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNFQUFzRSxPQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTzs7QUFFckI7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDBCQUEwQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsb0RBQW9EO0FBQ3BELCtCQUErQjtBQUMvQixtRUFBbUU7O0FBRW5FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLCtFQUErRTtBQUMvRTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsc0RBQXNEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sd0JBQXdCLDRDQUE0QztBQUMxRixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFROztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixlQUFlOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FB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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLDJCQUEyQjs7QUFFM0IsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSwwQ0FBMEM7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBb0Q7QUFDOUQsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFnRDs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCwwQ0FBMEMsY0FBYztBQUN4RCw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUUsc0RBQXNELCtDQUErQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0NBQWdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUE0Qzs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQXNEO0FBQ2hFLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxrREFBa0Q7QUFDNUQsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0IsWUFBWTtBQUNaOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxlQUFlLEVBQUU7QUFDNUMsc0JBQXNCLEVBQUU7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdC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QXNDO0FBQ3RDLGdGQUFnRjtBQUNoRjtBQUNBLHdHQUF3RztBQUN4RztBQUNBLGdJQUFnSTtBQUNoSSxvRUFBb0UsT0FBTztBQUMzRSxvR0FBb0csTUFBTTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsdUJBQXVCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixFQUFFLFNBQVM7QUFDWCxFQUFFLFVBQVU7QUFDWixFQUFFLFdBQVc7QUFDYixFQUFFLGNBQWM7QUFDaEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLEVBQUUsU0FBUztBQUNYLHlCQUF5QjtBQUN6QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ3RFLG9DQUFvQyxrQ0FBa0M7QUFDdEUscUNBQXFDLGtDQUFrQztBQUN2RSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0tBQWdLO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0UsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1SSxnQkFBZ0I7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RUFBdUUsMERBQTBEO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtB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QSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDViw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFT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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsOEJBQThCO0FBQzlCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sc0RBQXNELGFBQWE7OztBQUd6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxtQ0FBbUM7OztBQUduQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCOztBQUV6QztBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQixnQkFBZ0I7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDBCQUEwQjs7QUFFL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QzlCLHFDQUFxQztBQUNyQzs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDBCQUEwQjs7O0FBR3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvRUFBb0U7QUFDcEU7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxxQ0FBcUM7O0FBRTdDLFFBQVEsdUNBQXVDOzs7O0FBSS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5Tzs7Ozs7OztVQ25qTnpPO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7OztBQ0hpRDtBQUNGO0FBRS9DLE1BQU0sR0FBRztJQUNMLG9FQUF1QixFQUFFO0lBQ3pCLCtEQUFpQixFQUFFO0FBQ3ZCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL25vZGVfbW9kdWxlcy9kZWVwc2xhdGUvZGlzdC9kZWVwc2xhdGUuZXNtLmpzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0NC5qcyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbGl0ZWdyYXBoLmpzL2J1aWxkL2xpdGVncmFwaC5qcyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL3NyYy9tYWluL1VJL0dyYXBoTWFuYWdlci50cyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL3NyYy9tYWluL1VJL01lbnVNYW5hZ2VyLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vbm9kZXMvTEdyYXBoTm9kZUZpeGVkLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vbm9kZXMvY29uc3RhbnRfZGVuc2l0eV9mdW5jdGlvbi50cyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL3NyYy9tYWluL25vZGVzL2RlbnNpdHlfZnVuY3Rpb24udHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9zcmMvbWFpbi9ub2Rlcy9kZW5zaXR5X2Z1bmN0aW9uX291dHB1dC50cyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL3NyYy9tYWluL25vZGVzL2RlbnNpdHlfZnVuY3Rpb25fc3BsaW5lLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vbm9kZXMvbmFtZWRfZGVuc2l0eV9mdW5jdGlvbi50cyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci8uL3NyYy9tYWluL25vZGVzL3JlZ2lzdGVyLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vdmFuaWxsYS9zY2hlbWFzLnRzIiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vd2lkZ2V0cy9TcGxpbmVXaWRnZXQudHMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3IvLi9ub2RlX21vZHVsZXMvcGFrby9kaXN0L3Bha28uZXNtLm1qcyIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZGVuc2l0eS1mdW5jdGlvbi1lZGl0b3Ivd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9kZW5zaXR5LWZ1bmN0aW9uLWVkaXRvci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2RlbnNpdHktZnVuY3Rpb24tZWRpdG9yLy4vc3JjL21haW4vYXBwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0IGZyb21cInBha29cIjtpbXBvcnR7dmVjMyBhcyBlLG1hdDQgYXMgcyxnbE1hdHJpeCBhcyBpfWZyb21cImdsLW1hdHJpeFwiO3ZhciBuOyFmdW5jdGlvbih0KXt0LlVQPVwidXBcIix0LkRPV049XCJkb3duXCIsdC5OT1JUSD1cIm5vcnRoXCIsdC5FQVNUPVwiZWFzdFwiLHQuU09VVEg9XCJzb3V0aFwiLHQuV0VTVD1cIndlc3RcIn0obnx8KG49e30pKTtjb25zdCByPXtbbi5VUF06WzAsMSwwXSxbbi5ET1dOXTpbMCwtMSwwXSxbbi5OT1JUSF06WzAsMCwtMV0sW24uRUFTVF06WzEsMCwwXSxbbi5TT1VUSF06WzAsMCwxXSxbbi5XRVNUXTpbLTEsMCwwXX07dmFyIG87IWZ1bmN0aW9uKHQpe3QuQUxMPVt0LlVQLHQuRE9XTix0Lk5PUlRILHQuRUFTVCx0LlNPVVRILHQuV0VTVF0sdC5ub3JtYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHJbdF19fShufHwobj17fSkpLGZ1bmN0aW9uKHQpe3QuY3JlYXRlPWZ1bmN0aW9uKHQsZSxzKXtyZXR1cm5bdCxlLHNdfSx0Lm9mZnNldD1mdW5jdGlvbih0LGUscyxpKXtyZXR1cm5bdFswXStlLHRbMV0rcyx0WzJdK2ldfSx0LnRvd2FyZHM9ZnVuY3Rpb24oZSxzKXtyZXR1cm4gdC5vZmZzZXQoZSwuLi5uLm5vcm1hbChzKSl9fShvfHwobz17fSkpO2NvbnN0IGE9e2VuZDowLGJ5dGU6MSxzaG9ydDoyLGludDozLGxvbmc6NCxmbG9hdDo1LGRvdWJsZTo2LGJ5dGVBcnJheTo3LHN0cmluZzo4LGxpc3Q6OSxjb21wb3VuZDoxMCxpbnRBcnJheToxMSxsb25nQXJyYXk6MTJ9LGw9W1wiZW5kXCIsXCJieXRlXCIsXCJzaG9ydFwiLFwiaW50XCIsXCJsb25nXCIsXCJmbG9hdFwiLFwiZG91YmxlXCIsXCJieXRlQXJyYXlcIixcInN0cmluZ1wiLFwibGlzdFwiLFwiY29tcG91bmRcIixcImludEFycmF5XCIsXCJsb25nQXJyYXlcIl07Y2xhc3MgaHtjb25zdHJ1Y3Rvcih0LGU9ITEpe3RoaXMuYnl0ZT10aGlzLnJlYWROdW0uYmluZCh0aGlzLFwiZ2V0SW50OFwiLDEpLHRoaXMuc2hvcnQ9dGhpcy5yZWFkTnVtLmJpbmQodGhpcyxcImdldEludDE2XCIsMiksdGhpcy5pbnQ9dGhpcy5yZWFkTnVtLmJpbmQodGhpcyxcImdldEludDMyXCIsNCksdGhpcy5mbG9hdD10aGlzLnJlYWROdW0uYmluZCh0aGlzLFwiZ2V0RmxvYXQzMlwiLDQpLHRoaXMuZG91YmxlPXRoaXMucmVhZE51bS5iaW5kKHRoaXMsXCJnZXRGbG9hdDY0XCIsOCksdGhpcy5vZmZzZXQ9MCx0aGlzLmxpdHRsZUVuZGlhbj1lLHRoaXMuYXJyYXlWaWV3PXQsdGhpcy5kYXRhVmlldz1uZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0KX1lbmQoKXtyZXR1cm4gbnVsbH1yZWFkTnVtKHQsZSl7Y29uc3Qgcz10aGlzLmRhdGFWaWV3W3RdKHRoaXMub2Zmc2V0LHRoaXMubGl0dGxlRW5kaWFuKTtyZXR1cm4gdGhpcy5vZmZzZXQrPWUsc31sb25nKCl7cmV0dXJuW3RoaXMuaW50KCksdGhpcy5pbnQoKV19Ynl0ZUFycmF5KCl7Y29uc3QgdD10aGlzLmludCgpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllLnB1c2godGhpcy5ieXRlKCkpO3JldHVybiBlfWludEFycmF5KCl7Y29uc3QgdD10aGlzLmludCgpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllLnB1c2godGhpcy5pbnQoKSk7cmV0dXJuIGV9bG9uZ0FycmF5KCl7Y29uc3QgdD10aGlzLmludCgpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllLnB1c2godGhpcy5sb25nKCkpO3JldHVybiBlfXN0cmluZygpe2NvbnN0IHQ9dGhpcy5zaG9ydCgpLGU9dGhpcy5hcnJheVZpZXcuc2xpY2UodGhpcy5vZmZzZXQsdGhpcy5vZmZzZXQrdCk7cmV0dXJuIHRoaXMub2Zmc2V0Kz10LGZ1bmN0aW9uKHQpe3ZhciBlLHM9W107Zm9yKGU9MDtlPHQubGVuZ3RoO2UrKykwPT0oMTI4JnRbZV0pP3MucHVzaCgxMjcmdFtlXSk6ZSsxPHQubGVuZ3RoJiYxOTI9PSgyMjQmdFtlXSkmJjEyOD09KDE5MiZ0W2UrMV0pP3MucHVzaCgoMzEmdFtlXSk8PDZ8NjMmdFtlKzFdKTplKzI8dC5sZW5ndGgmJjIyND09KDI0MCZ0W2VdKSYmMTI4PT0oMTkyJnRbZSsxXSkmJjEyOD09KDE5MiZ0W2UrMl0pP3MucHVzaCgoMTUmdFtlXSk8PDEyfCg2MyZ0W2UrMV0pPDw2fDYzJnRbZSsyXSk6ZSszPHQubGVuZ3RoJiYyNDA9PSgyNDgmdFtlXSkmJjEyOD09KDE5MiZ0W2UrMV0pJiYxMjg9PSgxOTImdFtlKzJdKSYmMTI4PT0oMTkyJnRbZSszXSkmJnMucHVzaCgoNyZ0W2VdKTw8MTh8KDYzJnRbZSsxXSk8PDEyfCg2MyZ0W2UrMl0pPDw2fDYzJnRbZSszXSk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxzKX0oZSl9bGlzdCgpe2NvbnN0IHQ9bFt0aGlzLmJ5dGUoKV0sZT10aGlzLmludCgpLHM9W107Zm9yKGxldCBpPTA7aTxlO2krKylzLnB1c2godGhpc1t0XSgpKTtyZXR1cm57dHlwZTp0LHZhbHVlOnN9fWNvbXBvdW5kKCl7Y29uc3QgdD17fTtmb3IoOzspe2NvbnN0IGU9bFt0aGlzLmJ5dGUoKV07aWYoXCJlbmRcIj09PWUpYnJlYWs7Y29uc3Qgcz10aGlzLnN0cmluZygpLGk9dGhpc1tlXSgpO3Rbc109e3R5cGU6ZSx2YWx1ZTppfX1yZXR1cm4gdH19Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0PSExKXt0aGlzLmJ5dGU9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRJbnQ4XCIsMSksdGhpcy5zaG9ydD10aGlzLndyaXRlTnVtLmJpbmQodGhpcyxcInNldEludDE2XCIsMiksdGhpcy5pbnQ9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRJbnQzMlwiLDQpLHRoaXMuZmxvYXQ9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRGbG9hdDMyXCIsNCksdGhpcy5kb3VibGU9dGhpcy53cml0ZU51bS5iaW5kKHRoaXMsXCJzZXRGbG9hdDY0XCIsOCksdGhpcy5vZmZzZXQ9MCx0aGlzLmxpdHRsZUVuZGlhbj10LHRoaXMuYnVmZmVyPW5ldyBBcnJheUJ1ZmZlcigxMDI0KSx0aGlzLmFycmF5Vmlldz1uZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlciksdGhpcy5kYXRhVmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpfWFjY29tbW9kYXRlKHQpe2NvbnN0IGU9dGhpcy5vZmZzZXQrdDtpZih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoPj1lKXJldHVybjtsZXQgcz10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2Zvcig7czxlOylzKj0yO2NvbnN0IGk9bmV3IEFycmF5QnVmZmVyKHMpLG49bmV3IFVpbnQ4QXJyYXkoaSk7bi5zZXQodGhpcy5hcnJheVZpZXcpLHRoaXMub2Zmc2V0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgmJm4uZmlsbCgwLHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsdGhpcy5vZmZzZXQpLHRoaXMuYnVmZmVyPWksdGhpcy5kYXRhVmlldz1uZXcgRGF0YVZpZXcoaSksdGhpcy5hcnJheVZpZXc9bn1nZXREYXRhKCl7cmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMCksdGhpcy5hcnJheVZpZXcuc2xpY2UoMCx0aGlzLm9mZnNldCl9ZW5kKHQpe313cml0ZU51bSh0LGUscyl7dGhpcy5hY2NvbW1vZGF0ZShlKSx0aGlzLmRhdGFWaWV3W3RdKHRoaXMub2Zmc2V0LHMsdGhpcy5saXR0bGVFbmRpYW4pLHRoaXMub2Zmc2V0Kz1lfWxvbmcodCl7dGhpcy5pbnQodFswXSksdGhpcy5pbnQodFsxXSl9Ynl0ZUFycmF5KHQpe3RoaXMuaW50KHQubGVuZ3RoKSx0aGlzLmFjY29tbW9kYXRlKHQubGVuZ3RoKSx0aGlzLmFycmF5Vmlldy5zZXQodCx0aGlzLm9mZnNldCksdGhpcy5vZmZzZXQrPXQubGVuZ3RofWludEFycmF5KHQpe3RoaXMuaW50KHQubGVuZ3RoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmludCh0W2VdKX1sb25nQXJyYXkodCl7dGhpcy5pbnQodC5sZW5ndGgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMubG9uZyh0W2VdKX1zdHJpbmcodCl7Y29uc3QgZT1mdW5jdGlvbih0KXt2YXIgZSxzLGk9W107Zm9yKGU9MDtlPHQubGVuZ3RoO2UrKykocz10LmNoYXJDb2RlQXQoZSkpPDEyOD9pLnB1c2gocyk6czwyMDQ4PyhpLnB1c2goMTkyfHM+PjYpLGkucHVzaCgxMjh8NjMmcykpOnM8NjU1MzY/KGkucHVzaCgyMjR8cz4+MTIpLGkucHVzaCgxMjh8cz4+NiY2MyksaS5wdXNoKDEyOHw2MyZzKSk6KGkucHVzaCgyNDB8cz4+MTgmNyksaS5wdXNoKDEyOHxzPj4xMiY2MyksaS5wdXNoKDEyOHxzPj42JjYzKSxpLnB1c2goMTI4fDYzJnMpKTtyZXR1cm4gaX0odCk7dGhpcy5zaG9ydChlLmxlbmd0aCksdGhpcy5hY2NvbW1vZGF0ZShlLmxlbmd0aCksdGhpcy5hcnJheVZpZXcuc2V0KGUsdGhpcy5vZmZzZXQpLHRoaXMub2Zmc2V0Kz1lLmxlbmd0aH1saXN0KHQpe3RoaXMuYnl0ZShhW3QudHlwZV0pLHRoaXMuaW50KHQudmFsdWUubGVuZ3RoKSx0LnZhbHVlO2ZvcihsZXQgZT0wO2U8dC52YWx1ZS5sZW5ndGg7ZSsrKXRoaXNbdC50eXBlXSh0LnZhbHVlW2VdKX1jb21wb3VuZCh0KXtmb3IoY29uc3QgZSBpbiB0KXRoaXMuYnl0ZShhW3RbZV0udHlwZV0pLHRoaXMuc3RyaW5nKGUpLHRoaXNbdFtlXS50eXBlXSh0W2VdLnZhbHVlKTt0aGlzLmJ5dGUoYS5lbmQpfX1mdW5jdGlvbiBjKHQsZSl7Y29uc3Qgcz1uZXcgaCh0LGUpO2lmKHMuYnl0ZSgpIT09YS5jb21wb3VuZCl0aHJvdyBuZXcgRXJyb3IoXCJUb3AgdGFnIHNob3VsZCBiZSBhIGNvbXBvdW5kXCIpO3JldHVybntuYW1lOnMuc3RyaW5nKCksdmFsdWU6cy5jb21wb3VuZCgpfX1mdW5jdGlvbiBkKGUscyl7cmV0dXJuIGModC5pbmZsYXRlKGUpLHMpfWZ1bmN0aW9uIGYodCxlKXtyZXR1cm4gMj09PShzPW5ldyBVaW50OEFycmF5KHQuc2xpY2UoMCwyKSkpLmxlbmd0aCYmMzE9PT1zWzBdJiYxMzk9PT1zWzFdP3tjb21wcmVzc2VkOiEwLHJlc3VsdDpkKHQsZSl9Ontjb21wcmVzc2VkOiExLHJlc3VsdDpjKHQsZSl9O3ZhciBzfWZ1bmN0aW9uIGcodCl7Y29uc3QgZT1bXTtmb3IobGV0IHM9MDtzPDMyO3MrPTEpZm9yKGxldCBpPTA7aTwzMjtpKz0xKXtjb25zdCBuPTQqKCgzMSZzKSszMiooMzEmaSkpO2lmKDA9PT10W24rM10pY29udGludWU7Y29uc3Qgcj0odFtuXTw8MTYpKyh0W24rMV08PDgpK3RbbisyXSxvPSh0W24rNDA5Nl08PDI0KSsodFtuKzQwOTddPDwxNikrKHRbbis0MDk4XTw8OCkrdFtuKzQwOTldLGE9NDA5NipyLGw9KHRbYV08PDI0KSsodFthKzFdPDwxNikrKHRbYSsyXTw8OCkrdFthKzNdLGg9dFthKzRdLHU9dC5zbGljZShhKzUsYSs0K2wpO2UucHVzaCh7eDpzLHo6aSx0aW1lc3RhbXA6byxjb21wcmVzc2lvbjpoLGRhdGE6dX0pfXJldHVybiBlfWZ1bmN0aW9uIHAodCxlLHMpe2NvbnN0IGk9eCh0LGUscyk7c3dpdGNoKGkuY29tcHJlc3Npb24pe2Nhc2UgMTpjYXNlIDI6aS5uYnQ9ZChpLmRhdGEpO2JyZWFrO2Nhc2UgMzppLm5idD1jKGkuZGF0YSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29tcHJlc3Npb24gbW9kZSAke2kuY29tcHJlc3Npb259YCl9cmV0dXJuIGl9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IHM9bmV3IHUoZSk7cmV0dXJuIHMuYnl0ZShhLmNvbXBvdW5kKSxzLnN0cmluZyh0Lm5hbWUpLHMuY29tcG91bmQodC52YWx1ZSkscy5nZXREYXRhKCl9ZnVuY3Rpb24gdihlLHMsaSl7Y29uc3Qgbj1tKGUscyk7cmV0dXJuIHRbaT9cImRlZmxhdGVcIjpcImd6aXBcIl0obil9ZnVuY3Rpb24gYih0LGUscyl7cmV0dXJuIGU/dih0LHMpOm0odCxzKX1mdW5jdGlvbiB3KHQpe2xldCBlPTA7Zm9yKGNvbnN0IHMgb2YgdCllKz1NYXRoLmNlaWwocy5kYXRhLmxlbmd0aC80MDk2KTtjb25zdCBzPW5ldyBVaW50OEFycmF5KDgxOTIrNDA5NiplKSxpPW5ldyBEYXRhVmlldyhzLmJ1ZmZlcik7bGV0IG49Mjtmb3IoY29uc3QgZSBvZiB0KXtjb25zdCB0PTQqKCgzMSZlLngpKzMyKigzMSZlLnopKSxyPU1hdGguY2VpbChlLmRhdGEubGVuZ3RoLzQwOTYpO2kuc2V0SW50OCh0LG4+PjE2KSxpLnNldEludDE2KHQrMSw2NTUzNSZuKSxpLnNldEludDgodCszLHIpLGkuc2V0SW50MzIodCs0MDk2LGUudGltZXN0YW1wKTtjb25zdCBvPTQwOTYqbjtpLnNldEludDMyKG8sZS5kYXRhLmxlbmd0aCsxKSxpLnNldEludDgobys0LGUuY29tcHJlc3Npb24pLHMuc2V0KGUuZGF0YSxvKzUpLG4rPXJ9cmV0dXJuIHN9ZnVuY3Rpb24gUCh0LGUscyxpKXtjb25zdCBuPXgodCxlLHMpO3N3aXRjaChuLmNvbXByZXNzaW9uKXtjYXNlIDE6bi5kYXRhPXYoaSk7YnJlYWs7Y2FzZSAyOm4uZGF0YT12KGksITEsITApO2JyZWFrO2Nhc2UgMzpuLmRhdGE9bShpKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21wcmVzc2lvbiBtb2RlICR7bi5jb21wcmVzc2lvbn1gKX1yZXR1cm4gbn1mdW5jdGlvbiB4KHQsZSxzKXtjb25zdCBpPXQuZmluZCgodD0+dC54PT09ZSYmdC56PT09cykpO2lmKHZvaWQgMD09PWkpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBjaHVuayBbJHtlfSwgJHtzfV1gKTtyZXR1cm4gaX1mdW5jdGlvbiB5KHQsZSxzKXtpZighdFtlXSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgJHtlfSB0YWdgKTtpZih0W2VdLnR5cGUhPT1zKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtlfSB0byBiZSBvZiB0eXBlICR7c30sIGJ1dCBmb3VuZCAke3RbZV0udHlwZX1gKTtyZXR1cm4gdFtlXS52YWx1ZX1mdW5jdGlvbiBBKHQsZSxzLGkpe2NvbnN0IG49eSh0LGUsXCJsaXN0XCIpO2lmKG4udHlwZSE9PXMpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2V9IHRvIGJlIGEgbGlzdCBvZiAke3N9cywgYnV0IGZvdW5kICR7bi50eXBlfXNgKTtpZihpJiZuLnZhbHVlLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2V9IHRvIGJlIGEgbGlzdCBvZiBsZW5ndGggJHtpfSwgYnV0IGZvdW5kIGxlbmd0aCAke24udmFsdWUubGVuZ3RofWApO3JldHVybiBuLnZhbHVlfWZ1bmN0aW9uIFModCxlKXt0cnl7cmV0dXJuIHQoKX1jYXRjaCh0KXtyZXR1cm4gZX19Y2xhc3MgQntjb25zdHJ1Y3Rvcih0LGU9e30pe3RoaXMubmFtZT10LHRoaXMucHJvcGVydGllcz1lfWdldE5hbWUoKXtyZXR1cm4gdGhpcy5uYW1lfWdldFByb3BlcnRpZXMoKXtyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzfWdldFByb3BlcnR5KHQpe3JldHVybiB0aGlzLnByb3BlcnRpZXNbdF19aXNGbHVpZCgpe3JldHVyblwibWluZWNyYWZ0OndhdGVyXCI9PT10aGlzLm5hbWV8fFwibWluZWNyYWZ0OmxhdmFcIj09PXRoaXMubmFtZX1lcXVhbHModCl7cmV0dXJuIHRoaXMubmFtZT09PXQubmFtZSYmT2JqZWN0LmtleXModGhpcy5wcm9wZXJ0aWVzKS5ldmVyeSgoZT0+dC5wcm9wZXJ0aWVzW2VdPT09dGhpcy5wcm9wZXJ0aWVzW2VdKSl9dG9TdHJpbmcoKXtyZXR1cm4gMD09PU9iamVjdC5rZXlzKHRoaXMucHJvcGVydGllcykubGVuZ3RoP3RoaXMubmFtZTpgJHt0aGlzLm5hbWV9WyR7T2JqZWN0LmVudHJpZXModGhpcy5wcm9wZXJ0aWVzKS5tYXAoKChbdCxlXSk9PnQrXCI9XCIrZSkpLmpvaW4oXCIsXCIpfV1gfXN0YXRpYyBmcm9tTmJ0KHQpe2NvbnN0IGU9eSh0LnZhbHVlLFwiTmFtZVwiLFwic3RyaW5nXCIpLHM9UygoKCk9PnkodC52YWx1ZSxcIlByb3BlcnRpZXNcIixcImNvbXBvdW5kXCIpKSx7fSksaT1PYmplY3Qua2V5cyhzKS5yZWR1Y2UoKCh0LGUpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tlXTp5KHMsZSxcInN0cmluZ1wiKX0pKSx7fSk7cmV0dXJuIG5ldyBCKGUsaSl9c3RhdGljIGZyb21Kc29uKHQpe3ZhciBlLHM7Y29uc3QgaT1udWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9LG49bnVsbCE9PShzPWsucmVhZFN0cmluZyhpLk5hbWUpKSYmdm9pZCAwIT09cz9zOlwibWluZWNyYWZ0OnN0b25lXCIscj1rLnJlYWRNYXAoaS5Qcm9wZXJ0aWVzLCh0PT57dmFyIGU7cmV0dXJuIG51bGwhPT0oZT1rLnJlYWRTdHJpbmcodCkpJiZ2b2lkIDAhPT1lP2U6XCJcIn0pKTtyZXR1cm4gbmV3IEIobixyKX19Qi5BSVI9bmV3IEIoXCJtaW5lY3JhZnQ6YWlyXCIpO2NsYXNzIEV7Y29uc3RydWN0b3IodCl7dGhpcy5taW5ZPXQsdGhpcy5zdG9yYWdlPUFycmF5KEUuU0laRSksdGhpcy5wYWxldHRlPVtCLkFJUl19Z2V0IG1pbkJsb2NrWSgpe3JldHVybiB0aGlzLm1pblk8PDR9aW5kZXgodCxlLHMpe3JldHVybih0PDw4KSsoZTw8NCkrc31nZXRCbG9ja1N0YXRlKHQsZSxzKXt2YXIgaTtjb25zdCBuPXRoaXMuc3RvcmFnZVt0aGlzLmluZGV4KHQsZSxzKV07cmV0dXJuIG51bGwhPT0oaT10aGlzLnBhbGV0dGVbbl0pJiZ2b2lkIDAhPT1pP2k6Qi5BSVJ9c2V0QmxvY2tTdGF0ZSh0LGUscyxpKXtsZXQgbj10aGlzLnBhbGV0dGUuZmluZEluZGV4KCh0PT50LmVxdWFscyhpKSkpOy0xPT09biYmKG49dGhpcy5wYWxldHRlLmxlbmd0aCx0aGlzLnBhbGV0dGUucHVzaChpKSksdGhpcy5zdG9yYWdlW3RoaXMuaW5kZXgodCxlLHMpXT1ufX1FLldJRFRIPTE2LEUuU0laRT1FLldJRFRIKkUuV0lEVEgqRS5XSURUSDtjbGFzcyBDe2NvbnN0cnVjdG9yKHQsZSxzKXt0aGlzLm1pblk9dCx0aGlzLmhlaWdodD1lLHRoaXMucG9zPXMsdGhpcy5zZWN0aW9ucz1BcnJheSh0aGlzLnNlY3Rpb25zQ291bnQpLmZpbGwobnVsbCl9Z2V0IG1heFkoKXtyZXR1cm4gdGhpcy5taW5ZK3RoaXMuaGVpZ2h0fWdldCBtaW5TZWN0aW9uKCl7cmV0dXJuIHRoaXMubWluWT4+NH1nZXQgbWF4U2VjdGlvbigpe3JldHVybiAxKyh0aGlzLm1heFktMT4+NCl9Z2V0IHNlY3Rpb25zQ291bnQoKXtyZXR1cm4gdGhpcy5tYXhTZWN0aW9uLXRoaXMubWluU2VjdGlvbn1nZXRTZWN0aW9uSW5kZXgodCl7cmV0dXJuKHQ+PjQpLXRoaXMubWluU2VjdGlvbn1nZXRCbG9ja1N0YXRlKHQpe3ZhciBlO2NvbnN0W3MsaSxuXT10LHI9dGhpcy5zZWN0aW9uc1t0aGlzLmdldFNlY3Rpb25JbmRleChpKV07cmV0dXJuIG51bGwhPT0oZT1udWxsPT1yP3ZvaWQgMDpyLmdldEJsb2NrU3RhdGUoMTUmcywxNSZpLDE1Jm4pKSYmdm9pZCAwIT09ZT9lOkIuQUlSfXNldEJsb2NrU3RhdGUodCxlKXtjb25zdFtzLGksbl09dCxyPXRoaXMuZ2V0U2VjdGlvbkluZGV4KGkpO2xldCBvPXRoaXMuc2VjdGlvbnNbcl07aWYobnVsbD09PW8pe2lmKGUuZXF1YWxzKEIuQUlSKSlyZXR1cm47bz10aGlzLmdldE9yQ3JlYXRlU2VjdGlvbihyKX1vLnNldEJsb2NrU3RhdGUoMTUmcywxNSZpLDE1Jm4sZSl9Z2V0T3JDcmVhdGVTZWN0aW9uKHQpe3JldHVybiBudWxsPT10aGlzLnNlY3Rpb25zW3RdJiYodGhpcy5zZWN0aW9uc1t0XT1uZXcgRSh0aGlzLm1pblNlY3Rpb24rdCkpLHRoaXMuc2VjdGlvbnNbdF19fXZhciBJLGssUjshZnVuY3Rpb24odCl7dC5jcmVhdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm5bdCxlXX0sdC5mcm9tQmxvY2tQb3M9ZnVuY3Rpb24odCl7cmV0dXJuW3RbMF0+PjQsdFsyXT4+NF19LHQuZnJvbUxvbmc9ZnVuY3Rpb24odCl7cmV0dXJuWzQyOTQ5NjcyOTUmTnVtYmVyKHQpLE51bWJlcih0Pj5CaWdJbnQoMzIpKV19LHQubWluQmxvY2tYPWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPDw0fSx0Lm1pbkJsb2NrWj1mdW5jdGlvbih0KXtyZXR1cm4gdFsxXTw8NH0sdC5tYXhCbG9ja1g9ZnVuY3Rpb24odCl7cmV0dXJuIHRbMF08PDE5fSx0Lm1heEJsb2NrWj1mdW5jdGlvbih0KXtyZXR1cm4gdFsxXTw8MTl9fShJfHwoST17fSkpLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10P3Q6dm9pZCAwfXQucmVhZE51bWJlcj1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD90OnZvaWQgMH0sdC5yZWFkSW50PWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P01hdGguZmxvb3IodCk6dm9pZCAwfSx0LnJlYWRTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDp2b2lkIDB9LHQucmVhZEJvb2xlYW49ZnVuY3Rpb24odCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0P3Q6dm9pZCAwfSx0LnJlYWRPYmplY3Q9ZSx0LnJlYWRBcnJheT1mdW5jdGlvbih0LGUpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQubWFwKCh0PT5lKHQpKSl9LHQucmVhZE1hcD1mdW5jdGlvbih0LHMpe3ZhciBpO2NvbnN0IG49bnVsbCE9PShpPWUodCkpJiZ2b2lkIDAhPT1pP2k6e307cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhuKS5tYXAoKChbdCxlXSk9Plt0LHMoZSldKSkpfSx0LmNvbXBvc2U9ZnVuY3Rpb24odCxlLHMpe2NvbnN0IGk9ZSh0KTtyZXR1cm4gaT9zKGkpOnZvaWQgMH19KGt8fChrPXt9KSk7Y2xhc3MgX3tjb25zdHJ1Y3Rvcih0LGU9W10scz1bXSl7dGhpcy5zaXplPXQsdGhpcy5wYWxldHRlPWUsdGhpcy5ibG9ja3M9cyx0aGlzLmJsb2Nrc01hcD1bXSxzLmZvckVhY2goKGU9PntpZighdGhpcy5pc0luc2lkZShlLnBvcykpdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBibG9jayBhdCAke2UucG9zfSB3aGljaCBpcyBvdXRzaWRlIHRoZSBzdHJ1Y3R1cmUgYm91bmRzICR7dGhpcy5zaXplfWApO3RoaXMuYmxvY2tzTWFwW2UucG9zWzBdKnRbMV0qdFsyXStlLnBvc1sxXSp0WzJdK2UucG9zWzJdXT1lfSkpfWdldFNpemUoKXtyZXR1cm4gdGhpcy5zaXplfWFkZEJsb2NrKHQsZSxzLGkpe2lmKCF0aGlzLmlzSW5zaWRlKHQpKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFkZCBibG9jayBhdCAke3R9IG91dHNpZGUgdGhlIHN0cnVjdHVyZSBib3VuZHMgJHt0aGlzLnNpemV9YCk7Y29uc3Qgbj1uZXcgQihlLHMpO2xldCByPXRoaXMucGFsZXR0ZS5maW5kSW5kZXgoKHQ9PnQuZXF1YWxzKG4pKSk7cmV0dXJuLTE9PT1yJiYocj10aGlzLnBhbGV0dGUubGVuZ3RoLHRoaXMucGFsZXR0ZS5wdXNoKG4pKSx0aGlzLmJsb2Nrcy5wdXNoKHtwb3M6dCxzdGF0ZTpyLG5idDppfSksdGhpcy5ibG9ja3NNYXBbdFswXSp0aGlzLnNpemVbMV0qdGhpcy5zaXplWzJdK3RbMV0qdGhpcy5zaXplWzJdK3RbMl1dPXtwb3M6dCxzdGF0ZTpyLG5idDppfSx0aGlzfWdldEJsb2Nrcygpe3JldHVybiB0aGlzLmJsb2Nrcy5tYXAoKHQ9Pih7cG9zOnQucG9zLHN0YXRlOnRoaXMucGFsZXR0ZVt0LnN0YXRlXSxuYnQ6dC5uYnR9KSkpfWdldEJsb2NrKHQpe2lmKCF0aGlzLmlzSW5zaWRlKHQpKXJldHVybiBudWxsO2NvbnN0IGU9dGhpcy5ibG9ja3NNYXBbdFswXSp0aGlzLnNpemVbMV0qdGhpcy5zaXplWzJdK3RbMV0qdGhpcy5zaXplWzJdK3RbMl1dO2lmKCFlKXJldHVybiBudWxsO3JldHVybntwb3M6ZS5wb3Msc3RhdGU6dGhpcy5wYWxldHRlW2Uuc3RhdGVdLG5idDplLm5idH19aXNJbnNpZGUodCl7cmV0dXJuIHRbMF0+PTAmJnRbMF08dGhpcy5zaXplWzBdJiZ0WzFdPj0wJiZ0WzFdPHRoaXMuc2l6ZVsxXSYmdFsyXT49MCYmdFsyXTx0aGlzLnNpemVbMl19c3RhdGljIGZyb21OYnQodCl7Y29uc3QgZT1BKHQudmFsdWUsXCJzaXplXCIsXCJpbnRcIiwzKSxzPUEodC52YWx1ZSxcInBhbGV0dGVcIixcImNvbXBvdW5kXCIpLm1hcCgodD0+Qi5mcm9tTmJ0KHtuYW1lOlwiXCIsdmFsdWU6dH0pKSksaT1BKHQudmFsdWUsXCJibG9ja3NcIixcImNvbXBvdW5kXCIpLm1hcCgodD0+KHtwb3M6QSh0LFwicG9zXCIsXCJpbnRcIiwzKSxzdGF0ZTp5KHQsXCJzdGF0ZVwiLFwiaW50XCIpLG5idDpTKCgoKT0+eSh0LFwibmJ0XCIsXCJjb21wb3VuZFwiKSksdm9pZCAwKX0pKSk7cmV0dXJuIG5ldyBfKGUscyxpKX19ZnVuY3Rpb24gRih0KXtyZXR1cm4gdCp0fWZ1bmN0aW9uIE0odCxlLHMpe3JldHVybiBNYXRoLm1heChlLE1hdGgubWluKHMsdCkpfWZ1bmN0aW9uIE4odCxlLHMpe3JldHVybiBlK3QqKHMtZSl9ZnVuY3Rpb24gVCh0LGUscyxpLG4scil7cmV0dXJuIE4oZSxOKHQscyxpKSxOKHQsbixyKSl9ZnVuY3Rpb24gTyh0LGUscyxpLG4scixvLGEsbCxoLHUpe3JldHVybiBOKHMsVCh0LGUsaSxuLHIsbyksVCh0LGUsYSxsLGgsdSkpfWZ1bmN0aW9uIFUodCxlLHMpe3JldHVybiBzPDA/dDpzPjE/ZTpOKHMsdCxlKX1mdW5jdGlvbiBEKHQpe3JldHVybiB0KnQqdCoodCooNip0LTE1KSsxMCl9ZnVuY3Rpb24gTCh0LGUscyl7bGV0IGk9ZS10O2Zvcig7aT4wOyl7Y29uc3QgZT1NYXRoLmZsb29yKGkvMiksbj10K2U7cyhuKT9pPWU6KHQ9bisxLGktPWUrMSl9cmV0dXJuIHR9Y2xhc3Mgentjb25zdHJ1Y3Rvcih0KXt0aGlzLnhvPTI1Nip0Lm5leHREb3VibGUoKSx0aGlzLnlvPTI1Nip0Lm5leHREb3VibGUoKSx0aGlzLnpvPTI1Nip0Lm5leHREb3VibGUoKSx0aGlzLnA9QXJyYXkoMjU2KTtmb3IobGV0IHQ9MDt0PDI1Njt0Kz0xKXRoaXMucFt0XT10O2ZvcihsZXQgZT0wO2U8MjU2O2UrPTEpe2NvbnN0IHM9dC5uZXh0SW50KDI1Ni1lKSxpPXRoaXMucFtlXTt0aGlzLnBbZV09dGhpcy5wW2Urc10sdGhpcy5wW2Urc109aX19c2FtcGxlMkQodCxlKXtsZXQgcyxpLG47Y29uc3Qgcj0odCtlKSp6LkYyLG89TWF0aC5mbG9vcih0K3IpLGE9dC0oby0ocz0obysoaT1NYXRoLmZsb29yKGUrcikpKSp6LkcyKSk7bGV0IGwsaDthPihuPWUtKGktcykpPyhsPTEsaD0wKToobD0wLGg9MSk7Y29uc3QgdT1hLWwrei5HMixjPW4taCt6LkcyLGQ9YS0xKzIqei5HMixmPW4tMSsyKnouRzIsZz0yNTUmbyxwPTI1NSZpLG09dGhpcy5QKGcrdGhpcy5QKHApKSUxMix2PXRoaXMuUChnK2wrdGhpcy5QKHAraCkpJTEyLGI9dGhpcy5QKGcrMSt0aGlzLlAocCsxKSklMTI7cmV0dXJuIDcwKih0aGlzLmdldENvcm5lck5vaXNlM0QobSxhLG4sMCwuNSkrdGhpcy5nZXRDb3JuZXJOb2lzZTNEKHYsdSxjLDAsLjUpK3RoaXMuZ2V0Q29ybmVyTm9pc2UzRChiLGQsZiwwLC41KSl9c2FtcGxlKHQsZSxzKXtjb25zdCBpPS4zMzMzMzMzMzMzMzMzMzMzKih0K2Urcyksbj1NYXRoLmZsb29yKHQraSkscj1NYXRoLmZsb29yKGUraSksbz1NYXRoLmZsb29yKHMraSksYT0uMTY2NjY2NjY2NjY2NjY2NjYqKG4rcitvKSxsPXQtKG4tYSksaD1lLShyLWEpLHU9cy0oby1hKTtsZXQgYyxkLGYsZyxwLG07bD49aD9oPj11PyhjPTEsZD0wLGY9MCxnPTEscD0xLG09MCk6bD49dT8oYz0xLGQ9MCxmPTAsZz0xLHA9MCxtPTEpOihjPTAsZD0wLGY9MSxnPTEscD0wLG09MSk6aDx1PyhjPTAsZD0wLGY9MSxnPTAscD0xLG09MSk6bDx1PyhjPTAsZD0xLGY9MCxnPTAscD0xLG09MSk6KGM9MCxkPTEsZj0wLGc9MSxwPTEsbT0wKTtjb25zdCB2PWwtYysuMTY2NjY2NjY2NjY2NjY2NjYsYj1oLWQrLjE2NjY2NjY2NjY2NjY2NjY2LHc9dS1mKy4xNjY2NjY2NjY2NjY2NjY2NixQPWwtZysuMzMzMzMzMzMzMzMzMzMzMyx4PWgtcCsuMzMzMzMzMzMzMzMzMzMzMyx5PXUtbSsuMzMzMzMzMzMzMzMzMzMzMyxBPWwtLjUsUz1oLS41LEI9dS0uNSxFPTI1NSZuLEM9MjU1JnIsST0yNTUmbyxrPXRoaXMuUChFK3RoaXMuUChDK3RoaXMuUChJKSkpJTEyLFI9dGhpcy5QKEUrYyt0aGlzLlAoQytkK3RoaXMuUChJK2YpKSklMTIsXz10aGlzLlAoRStnK3RoaXMuUChDK3ArdGhpcy5QKEkrbSkpKSUxMixGPXRoaXMuUChFKzErdGhpcy5QKEMrMSt0aGlzLlAoSSsxKSkpJTEyO3JldHVybiAzMioodGhpcy5nZXRDb3JuZXJOb2lzZTNEKGssbCxoLHUsLjYpK3RoaXMuZ2V0Q29ybmVyTm9pc2UzRChSLHYsYix3LC42KSt0aGlzLmdldENvcm5lck5vaXNlM0QoXyxQLHgseSwuNikrdGhpcy5nZXRDb3JuZXJOb2lzZTNEKEYsQSxTLEIsLjYpKX1QKHQpe3JldHVybiB0aGlzLnBbMjU1JnRdfWdldENvcm5lck5vaXNlM0QodCxlLHMsaSxuKXtsZXQgcixvPW4tZSplLXMqcy1pKmk7cmV0dXJuIG88MD9yPTA6KG8qPW8scj1vKm8qei5ncmFkRG90KHQsZSxzLGkpKSxyfXN0YXRpYyBncmFkRG90KHQsZSxzLGkpe2NvbnN0IG49ei5HUkFESUVOVFsxNSZ0XTtyZXR1cm4gblswXSplK25bMV0qcytuWzJdKml9fXouR1JBRElFTlQ9W1sxLDEsMF0sWy0xLDEsMF0sWzEsLTEsMF0sWy0xLC0xLDBdLFsxLDAsMV0sWy0xLDAsMV0sWzEsMCwtMV0sWy0xLDAsLTFdLFswLDEsMV0sWzAsLTEsMV0sWzAsMSwtMV0sWzAsLTEsLTFdLFsxLDEsMF0sWzAsLTEsMV0sWy0xLDEsMF0sWzAsLTEsLTFdXSx6LkYyPS41KihNYXRoLnNxcnQoMyktMSksei5HMj0oMy1NYXRoLnNxcnQoMykpLzY7Y2xhc3MgVntjb25zdHJ1Y3Rvcih0KXt0aGlzLnhvPTI1Nip0Lm5leHREb3VibGUoKSx0aGlzLnlvPTI1Nip0Lm5leHREb3VibGUoKSx0aGlzLnpvPTI1Nip0Lm5leHREb3VibGUoKSx0aGlzLnA9QXJyYXkoMjU2KTtmb3IobGV0IHQ9MDt0PDI1Njt0Kz0xKXRoaXMucFt0XT10PjEyNz90LTI1Njp0O2ZvcihsZXQgZT0wO2U8MjU2O2UrPTEpe2NvbnN0IHM9dC5uZXh0SW50KDI1Ni1lKSxpPXRoaXMucFtlXTt0aGlzLnBbZV09dGhpcy5wW2Urc10sdGhpcy5wW2Urc109aX19c2FtcGxlKHQsZSxzLGk9MCxuPTApe2NvbnN0IHI9dCt0aGlzLnhvLG89ZSt0aGlzLnlvLGE9cyt0aGlzLnpvLGw9TWF0aC5mbG9vcihyKSxoPU1hdGguZmxvb3IobyksdT1NYXRoLmZsb29yKGEpLGM9ci1sLGQ9by1oLGY9YS11O2xldCBnPTA7aWYoMCE9PWkpe2NvbnN0IHQ9bj49MCYmbjxkP246ZDtnPU1hdGguZmxvb3IodC9pKzFlLTcpKml9cmV0dXJuIHRoaXMuc2FtcGxlQW5kTGVycChsLGgsdSxjLGQtZyxmLGQpfXNhbXBsZUFuZExlcnAodCxlLHMsaSxuLHIsbyl7Y29uc3QgYT10aGlzLlAodCksbD10aGlzLlAodCsxKSxoPXRoaXMuUChhK2UpLHU9dGhpcy5QKGErZSsxKSxjPXRoaXMuUChsK2UpLGQ9dGhpcy5QKGwrZSsxKSxmPXouZ3JhZERvdCh0aGlzLlAoaCtzKSxpLG4sciksZz16LmdyYWREb3QodGhpcy5QKGMrcyksaS0xLG4scikscD16LmdyYWREb3QodGhpcy5QKHUrcyksaSxuLTEsciksbT16LmdyYWREb3QodGhpcy5QKGQrcyksaS0xLG4tMSxyKSx2PXouZ3JhZERvdCh0aGlzLlAoaCtzKzEpLGksbixyLTEpLGI9ei5ncmFkRG90KHRoaXMuUChjK3MrMSksaS0xLG4sci0xKSx3PXouZ3JhZERvdCh0aGlzLlAodStzKzEpLGksbi0xLHItMSksUD16LmdyYWREb3QodGhpcy5QKGQrcysxKSxpLTEsbi0xLHItMSk7cmV0dXJuIE8oRChpKSxEKG8pLEQociksZixnLHAsbSx2LGIsdyxQKX1QKHQpe3JldHVybiAyNTUmdGhpcy5wWzI1NSZ0XX19Y2xhc3Mgantjb25zdHJ1Y3Rvcih0LGUscyl7aWYoMS1lPHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBvc2l0aXZlIG9jdGF2ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO3RoaXMubm9pc2VMZXZlbHM9QXJyYXkocy5sZW5ndGgpO2ZvcihsZXQgaT0tZTtpPj0wO2ktPTEpaTxzLmxlbmd0aCYmMCE9PXNbaV0/dGhpcy5ub2lzZUxldmVsc1tpXT1uZXcgVih0KTp0LmNvbnN1bWUoMjYyKTt0aGlzLmFtcGxpdHVkZXM9cyx0aGlzLmxvd2VzdEZyZXFJbnB1dEZhY3Rvcj1NYXRoLnBvdygyLGUpLHRoaXMubG93ZXN0RnJlcVZhbHVlRmFjdG9yPU1hdGgucG93KDIscy5sZW5ndGgtMSkvKE1hdGgucG93KDIscy5sZW5ndGgpLTEpfXNhbXBsZSh0LGUscyxpPTAsbj0wLHI9ITEpe2xldCBvPTAsYT10aGlzLmxvd2VzdEZyZXFJbnB1dEZhY3RvcixsPXRoaXMubG93ZXN0RnJlcVZhbHVlRmFjdG9yO2ZvcihsZXQgaD0wO2g8dGhpcy5ub2lzZUxldmVscy5sZW5ndGg7aCs9MSl7Y29uc3QgdT10aGlzLm5vaXNlTGV2ZWxzW2hdO3UmJihvKz10aGlzLmFtcGxpdHVkZXNbaF0qbCp1LnNhbXBsZShqLndyYXAodCphKSxyPy11LnlvOmoud3JhcChlKmEpLGoud3JhcChzKmEpLGkqYSxuKmEpKSxhKj0yLGwvPTJ9cmV0dXJuIG99Z2V0T2N0YXZlTm9pc2UodCl7cmV0dXJuIHRoaXMubm9pc2VMZXZlbHNbdGhpcy5ub2lzZUxldmVscy5sZW5ndGgtMS10XX1zdGF0aWMgd3JhcCh0KXtyZXR1cm4gdC0zMzU1NDQzMipNYXRoLmZsb29yKHQvMzM1NTQ0MzIrLjUpfX1jbGFzcyBZe2NvbnN0cnVjdG9yKHQpe3RoaXMubWluTGltaXROb2lzZT1uZXcgaih0LC0xNSxbMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwLDAsMF0pLHRoaXMubWF4TGltaXROb2lzZT1uZXcgaih0LC0xNSxbMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwLDAsMF0pLHRoaXMubWFpbk5vaXNlPW5ldyBqKHQsLTcsWzEsMSwxLDEsMSwwLDAsMF0pfXNhbXBsZSh0LGUscyxpLG4scixvKXtsZXQgYSxsPTAsaD0xO2ZvcihsZXQgaT0wO2k8ODtpKz0xKXtpZihhPXRoaXMubWFpbk5vaXNlLmdldE9jdGF2ZU5vaXNlKGkpLGEpe2NvbnN0IGk9cipoLG49bypoLHU9ai53cmFwKHQqaSksYz1qLndyYXAoZSpuKSxkPWoud3JhcChzKmkpO2wrPWEuc2FtcGxlKHUsYyxkLG4sZSpuKS9ofWgvPTJ9bD0obC8xMCsxKS8yLGg9MTtsZXQgdT0wLGM9MDtmb3IobGV0IHI9MDtyPDE2O3IrPTEpe2NvbnN0IG89aSpoLGQ9bipoLGY9ai53cmFwKHQqbyksZz1qLndyYXAoZSpkKSxwPWoud3JhcChzKm8pO2w8MSYmKGE9dGhpcy5taW5MaW1pdE5vaXNlLmdldE9jdGF2ZU5vaXNlKHIpKSYmKHUrPWEuc2FtcGxlKGYsZyxwLGQsZSpkKS9oKSxsPjAmJihhPXRoaXMubWF4TGltaXROb2lzZS5nZXRPY3RhdmVOb2lzZShyKSkmJihjKz1hLnNhbXBsZShmLGcscCxkLGUqZCkvaCksaC89Mn1yZXR1cm4gVSh1LzUxMixjLzUxMixsKX19Y2xhc3MgWHtjb25zdHJ1Y3Rvcih0LHtmaXJzdE9jdGF2ZTplLGFtcGxpdHVkZXM6c30pe3RoaXMuZmlyc3Q9bmV3IGoodCxlLHMpLHRoaXMuc2Vjb25kPW5ldyBqKHQsZSxzKTtsZXQgaT0xLzAsbj0tMS8wO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGg7dCs9MSkwIT09c1t0XSYmKGk9TWF0aC5taW4oaSx0KSxuPU1hdGgubWF4KG4sdCkpO2NvbnN0IHI9LjEqKDErMS8obi1pKzEpKTt0aGlzLnZhbHVlRmFjdG9yPTEvNi9yfXNhbXBsZSh0LGUscyl7Y29uc3QgaT10KlguSU5QVVRfRkFDVE9SLG49ZSpYLklOUFVUX0ZBQ1RPUixyPXMqWC5JTlBVVF9GQUNUT1I7cmV0dXJuKHRoaXMuZmlyc3Quc2FtcGxlKHQsZSxzKSt0aGlzLnNlY29uZC5zYW1wbGUoaSxuLHIpKSp0aGlzLnZhbHVlRmFjdG9yfX1YLklOUFVUX0ZBQ1RPUj0xLjAxODEyNjg4ODIxNzUyMjcsZnVuY3Rpb24odCl7dC5mcm9tSnNvbj1mdW5jdGlvbih0KXt2YXIgZSxzLGk7Y29uc3Qgbj1udWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9O3JldHVybntmaXJzdE9jdGF2ZTpudWxsIT09KHM9ay5yZWFkSW50KG4uZmlyc3RPY3RhdmUpKSYmdm9pZCAwIT09cz9zOjAsYW1wbGl0dWRlczpudWxsIT09KGk9ay5yZWFkQXJyYXkobi5hbXBsaXR1ZGVzLCh0PT57dmFyIGU7cmV0dXJuIG51bGwhPT0oZT1rLnJlYWROdW1iZXIodCkpJiZ2b2lkIDAhPT1lP2U6MH0pKSkmJnZvaWQgMCE9PWk/aTpbXX19fShSfHwoUj17fSkpO2NsYXNzIEh7Y29uc3RydWN0b3IodCxlKXtjb25zdCBzPWVbZS5sZW5ndGgtMV0saT0tZVswXStzKzEsbj1uZXcgU2V0KGUpLHI9bmV3IHoodCk7dGhpcy5ub2lzZUxldmVscz1BcnJheShpKSxzPj0wJiZzPGkmJm4uaGFzKDApJiYodGhpcy5ub2lzZUxldmVsc1tzXT1yKTtmb3IobGV0IGU9cysxO2U8aTtlKz0xKWU+PTAmJm4uaGFzKHMtZSk/dGhpcy5ub2lzZUxldmVsc1tlXT1uZXcgeih0KTp0LmNvbnN1bWUoMjYyKTtpZihzPjApdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpdmUgb2N0YXZlcyBhcmUgbm90IGFsbG93ZWRcIik7dGhpcy5oaWdoZXN0RnJlcUlucHV0RmFjdG9yPU1hdGgucG93KDIscyksdGhpcy5oaWdoZXN0RnJlcVZhbHVlRmFjdG9yPTEvKE1hdGgucG93KDIsaSktMSl9c2FtcGxlKHQsZSxzKXtsZXQgaT0wLG49dGhpcy5oaWdoZXN0RnJlcUlucHV0RmFjdG9yLHI9dGhpcy5oaWdoZXN0RnJlcVZhbHVlRmFjdG9yO2ZvcihsZXQgbz0wO288dGhpcy5ub2lzZUxldmVscy5sZW5ndGg7bys9MSl7Y29uc3QgYT10aGlzLm5vaXNlTGV2ZWxzW29dO2EmJihpKz1yKmEuc2FtcGxlMkQodCpuKyhzP2EueG86MCksZSpuKyhzP2EueW86MCkpKSxuLz0yLHIqPTJ9cmV0dXJuIGl9fWNsYXNzIFd7Y29uc3RydWN0b3IodCl7dGhpcy5zZWVkPUJpZ0ludCgwKSx0aGlzLnNldFNlZWQodCl9Zm9yaygpe3JldHVybiBuZXcgVyh0aGlzLm5leHRMb25nKCkpfXNldFNlZWQodCl7dGhpcy5zZWVkPXReVy5NVUxUSVBMSUVSJlcuTU9EVUxVU19NQVNLfWFkdmFuY2UoKXt0aGlzLnNlZWQ9dGhpcy5zZWVkKlcuTVVMVElQTElFUitXLklOQ1JFTUVOVCZXLk1PRFVMVVNfTUFTS31jb25zdW1lKHQpe2ZvcihsZXQgZT0wO2U8dDtlKz0xKXRoaXMuYWR2YW5jZSgpfW5leHQodCl7dGhpcy5hZHZhbmNlKCk7Y29uc3QgZT1OdW1iZXIodGhpcy5zZWVkPj5CaWdJbnQoVy5NT0RVTFVTX0JJVFMtdCkpO3JldHVybiBlPjIxNDc0ODM2NDc/ZS00Mjk0OTY3Mjk2OmV9bmV4dEludCh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLm5leHQoMzIpO2lmKDA9PSh0JnQtMSkpcmV0dXJuIE51bWJlcihCaWdJbnQodCkqQmlnSW50KHRoaXMubmV4dCgzMSkpPj5CaWdJbnQoMzEpKTtsZXQgZSxzO2Zvcig7KGU9dGhpcy5uZXh0KDMxKSktKHM9ZSV0KSsodC0xKTwwOyk7cmV0dXJuIHN9bmV4dExvbmcoKXtyZXR1cm4oQmlnSW50KHRoaXMubmV4dCgzMikpPDxCaWdJbnQoMzIpKStCaWdJbnQodGhpcy5uZXh0KDMyKSl9bmV4dEZsb2F0KCl7cmV0dXJuIHRoaXMubmV4dCgyNCkqVy5GTE9BVF9NVUxUSVBMSUVSfW5leHREb3VibGUoKXtjb25zdCB0PXRoaXMubmV4dCgzMCk7cmV0dXJuIHRoaXMuYWR2YW5jZSgpLHQqVy5ET1VCTEVfTVVMVElQTElFUn19Vy5NT0RVTFVTX0JJVFM9NDgsVy5NT0RVTFVTX01BU0s9QmlnSW50KFwiMjgxNDc0OTc2NzEwNjU1XCIpLFcuTVVMVElQTElFUj1CaWdJbnQoXCIyNTIxNDkwMzkxN1wiKSxXLklOQ1JFTUVOVD1CaWdJbnQoXCIxMVwiKSxXLkZMT0FUX01VTFRJUExJRVI9MS9NYXRoLnBvdygyLDI0KSxXLkRPVUJMRV9NVUxUSVBMSUVSPTEvTWF0aC5wb3coMiwzMCk7Y2xhc3MgSiBleHRlbmRzIFd7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY291bnQ9MH1nZXRDb3VudCgpe3JldHVybiB0aGlzLmNvdW50fW5leHQodCl7cmV0dXJuIHRoaXMuY291bnQrPTEsc3VwZXIubmV4dCh0KX19Y2xhc3MgWntjb25zdHJ1Y3Rvcih0LGUscz1bXSxpPVtdLG49W10pe3RoaXMubmFtZT10LHRoaXMuY29vcmRpbmF0ZT1lLHRoaXMubG9jYXRpb25zPXMsdGhpcy52YWx1ZXM9aSx0aGlzLmRlcml2YXRpdmVzPW59YXBwbHkodCl7Y29uc3QgZT10aGlzLmNvb3JkaW5hdGUodCkscz1MKDAsdGhpcy5sb2NhdGlvbnMubGVuZ3RoLCh0PT5lPHRoaXMubG9jYXRpb25zW3RdKSktMSxpPXRoaXMubG9jYXRpb25zLmxlbmd0aC0xO2lmKHM8MClyZXR1cm4gdGhpcy52YWx1ZXNbMF0odCkrdGhpcy5kZXJpdmF0aXZlc1swXSooZS10aGlzLmxvY2F0aW9uc1swXSk7aWYocz09PWkpcmV0dXJuIHRoaXMudmFsdWVzW2ldKHQpK3RoaXMuZGVyaXZhdGl2ZXNbaV0qKGUtdGhpcy5sb2NhdGlvbnNbaV0pO2NvbnN0IG49dGhpcy5sb2NhdGlvbnNbc10scj10aGlzLmxvY2F0aW9uc1tzKzFdLG89dGhpcy5kZXJpdmF0aXZlc1tzXSxhPXRoaXMuZGVyaXZhdGl2ZXNbcysxXSxsPShlLW4pLyhyLW4pLGg9dGhpcy52YWx1ZXNbc10odCksdT10aGlzLnZhbHVlc1tzKzFdKHQpLGM9byooci1uKS0odS1oKSxkPS1hKihyLW4pKyh1LWgpO3JldHVybiBOKGwsaCx1KStsKigxLWwpKk4obCxjLGQpfWFkZFBvaW50KHQsZSxzPTApe3JldHVybiB0aGlzLmxvY2F0aW9ucy5wdXNoKHQpLHRoaXMudmFsdWVzLnB1c2goXCJudW1iZXJcIj09dHlwZW9mIGU/KCk9PmU6ZS5hcHBseS5iaW5kKGUpKSx0aGlzLmRlcml2YXRpdmVzLnB1c2gocyksdGhpc319Y29uc3QgJD10PT5bKHQ+PjE2JjI1NSkvMjU2LCh0Pj44JjI1NSkvMjU2LCgyNTUmdCkvMjU2XSxHPVsxMjQvMjU2LDE4OS8yNTYsMTA3LzI1Nl0scT0kKDYzOTYyNTcpLEs9JCg4NDMxNDQ1KSxRPSQoNDc2NDk1MiksdHQ9JCg0MTU5MjA0KSxldD0kKDg0MzE0NDUpLHN0PSQoMjEyOTk2OCksaXQ9dD0+W3QvOCwxLXQvMzIsNjQqdF0sbnQ9e2xhcmdlX2Zlcm46KCk9PkcsdGFsbF9ncmFzczooKT0+RyxncmFzc19ibG9jazooKT0+RyxmZXJuOigpPT5HLGdyYXNzOigpPT5HLHBvdHRlZF9mZXJuOigpPT5HLHNwcnVjZV9sZWF2ZXM6KCk9PnEsYmlyY2hfbGVhdmVzOigpPT5LLG9ha19sZWF2ZXM6KCk9PlEsanVuZ2xlX2xlYXZlczooKT0+USxhY2FjaWFfbGVhdmVzOigpPT5RLGRhcmtfb2FrX2xlYXZlczooKT0+USx2aW5lOigpPT5RLHdhdGVyOigpPT50dCxidWJibGVfY29sdW1uOigpPT50dCxjYXVsZHJvbjooKT0+dHQscmVkc3RvbmVfd2lyZTp0PT57dmFyIGU7cmV0dXJuKHQ9Pntjb25zdCBlPXQvMTU7cmV0dXJuWy42KmUrKGU+MD8uNDouMyksTShlKmUqLjctLjUsMCwxKSxNKGUqZSouNi0uNywwLDEpXX0pKHBhcnNlSW50KG51bGwhPT0oZT10LnBvd2VyKSYmdm9pZCAwIT09ZT9lOlwiMFwiKSl9LHN1Z2FyX2NhbmU6KCk9PkcsYXR0YWNoZWRfbWVsb25fc3RlbTooKT0+ZXQsYXR0YWNoZWRfcHVtcGtpbl9zdGVtOigpPT5ldCxtZWxvbl9zdGVtOnQ9Pnt2YXIgZTtyZXR1cm4gaXQocGFyc2VJbnQobnVsbCE9PShlPXQuYWdlKSYmdm9pZCAwIT09ZT9lOlwiMFwiKSl9LHB1bXBraW5fc3RlbTp0PT57dmFyIGU7cmV0dXJuIGl0KHBhcnNlSW50KG51bGwhPT0oZT10LmFnZSkmJnZvaWQgMCE9PWU/ZTpcIjBcIikpfSxsaWx5X3BhZDooKT0+c3R9O3ZhciBydDtmdW5jdGlvbiBvdCguLi50KXtsZXQgZT0wO2Zvcihjb25zdCBzIG9mIHQpZSs9cy5sZW5ndGg7Y29uc3Qgcz1uZXcgRmxvYXQzMkFycmF5KGUpO2xldCBpPTA7Zm9yKGNvbnN0IGUgb2YgdClzLnNldChlLGkpLGkrPWUubGVuZ3RoO3JldHVybiBzfWZ1bmN0aW9uIGF0KHQscyl7Y29uc3QgaT1lLmNyZWF0ZSgpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bis9MylpWzBdPXRbbl0saVsxXT10W24rMV0saVsyXT10W24rMl0sZS50cmFuc2Zvcm1NYXQ0KGksaSxzKSx0W25dPWlbMF0sdFtuKzFdPWlbMV0sdFtuKzJdPWlbMl19IWZ1bmN0aW9uKHQpe3Qucm90YXRlPWZ1bmN0aW9uKHQsZSxzKXtsZXR7dXA6aSxkb3duOm4sbm9ydGg6cixlYXN0Om8sc291dGg6YSx3ZXN0Omx9PXQ7c3dpdGNoKHMpe2Nhc2UgOTA6W3IsbyxhLGxdPVtvLGEsbCxyXTticmVhaztjYXNlIDE4MDpbcixvLGEsbF09W2EsbCxyLG9dO2JyZWFrO2Nhc2UgMjcwOltyLG8sYSxsXT1bbCxyLG8sYV19c3dpdGNoKGUpe2Nhc2UgOTA6W2kscixuLGFdPVtyLG4sYSxpXTticmVhaztjYXNlIDE4MDpbaSxyLG4sYV09W24sYSxpLHJdO2JyZWFrO2Nhc2UgMjcwOltpLHIsbixhXT1bYSxpLHIsbl19cmV0dXJue3VwOmksZG93bjpuLG5vcnRoOnIsZWFzdDpvLHNvdXRoOmEsd2VzdDpsfX19KHJ0fHwocnQ9e30pKTtjbGFzcyBsdHtjb25zdHJ1Y3Rvcih0LGUscyl7dGhpcy5pZD10LHRoaXMudmFyaWFudHM9ZSx0aGlzLm11bHRpcGFydD1zLHRoaXMudmFyaWFudHM9ZX1nZXRNb2RlbFZhcmlhbnRzKHQpe2lmKHRoaXMudmFyaWFudHMpe2NvbnN0IGU9T2JqZWN0LmtleXModGhpcy52YXJpYW50cykuZmlsdGVyKChlPT50aGlzLm1hdGNoZXNWYXJpYW50KGUsdCkpKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuW107Y29uc3Qgcz10aGlzLnZhcmlhbnRzW2VbMF1dO3JldHVybltBcnJheS5pc0FycmF5KHMpP3NbMF06c119aWYodGhpcy5tdWx0aXBhcnQpe3JldHVybiB0aGlzLm11bHRpcGFydC5maWx0ZXIoKGU9PiFlLndoZW58fHRoaXMubWF0Y2hlc0Nhc2UoZS53aGVuLHQpKSkubWFwKCh0PT5BcnJheS5pc0FycmF5KHQuYXBwbHkpP3QuYXBwbHlbMF06dC5hcHBseSkpfXJldHVybltdfWdldEJ1ZmZlcnModCxlLG4scixvLGEpe3ZhciBsLGgsdSxjO2NvbnN0IGQ9dGhpcy5nZXRNb2RlbFZhcmlhbnRzKGUpLGY9W10sZz1bXSxwPVtdLG09W107Zm9yKGNvbnN0IHYgb2YgZCl7Y29uc3QgZD1ydC5yb3RhdGUoYSxudWxsIT09KGw9di54KSYmdm9pZCAwIT09bD9sOjAsbnVsbCE9PShoPXYueSkmJnZvaWQgMCE9PWg/aDowKSxiPXIuZ2V0QmxvY2tNb2RlbCh2Lm1vZGVsKS5nZXRCdWZmZXJzKHQsZSxuLG8sZCk7aWYodi54fHx2Lnkpe2NvbnN0IHQ9cy5jcmVhdGUoKTtzLmlkZW50aXR5KHQpLHMudHJhbnNsYXRlKHQsdCxbOCw4LDhdKSxzLnJvdGF0ZVkodCx0LC1pLnRvUmFkaWFuKG51bGwhPT0odT12LnkpJiZ2b2lkIDAhPT11P3U6MCkpLHMucm90YXRlWCh0LHQsLWkudG9SYWRpYW4obnVsbCE9PShjPXYueCkmJnZvaWQgMCE9PWM/YzowKSkscy50cmFuc2xhdGUodCx0LFstOCwtOCwtOF0pLGF0KGIucG9zaXRpb24sdCl9Zi5wdXNoKGIucG9zaXRpb24pLGcucHVzaCguLi5iLnRleENvb3JkKSxwLnB1c2goLi4uYi50aW50Q29sb3IpLG0ucHVzaCguLi5iLmluZGV4KSxvKz1iLnRleENvb3JkLmxlbmd0aC8yfWNvbnN0IHY9cy5jcmVhdGUoKTtzLmlkZW50aXR5KHYpLHMuc2NhbGUodix2LFsuMDYyNSwuMDYyNSwuMDYyNV0pO2NvbnN0IGI9b3QoLi4uZik7cmV0dXJuIGF0KGIsdikse3Bvc2l0aW9uOmIsdGV4Q29vcmQ6Zyx0aW50Q29sb3I6cCxpbmRleDptfX1tYXRjaGVzVmFyaWFudCh0LGUpe3JldHVybiB0LnNwbGl0KFwiLFwiKS5ldmVyeSgodD0+e2NvbnN0W3MsaV09dC5zcGxpdChcIj1cIik7cmV0dXJuIGVbc109PT1pfSkpfW1hdGNoZXNDYXNlKHQsZSl7aWYoQXJyYXkuaXNBcnJheSh0Lk9SKSlyZXR1cm4gdC5PUi5zb21lKCh0PT50aGlzLm1hdGNoZXNDYXNlKHQsZSkpKTtjb25zdCBzPXQ7cmV0dXJuIE9iamVjdC5rZXlzKHMpLmV2ZXJ5KCh0PT5zW3RdLnNwbGl0KFwifFwiKS5pbmNsdWRlcyhlW3RdKSkpfXN0YXRpYyBmcm9tSnNvbih0LGUpe3JldHVybiBuZXcgbHQodCxlLnZhcmlhbnRzLGUubXVsdGlwYXJ0KX19Y29uc3QgaHQ9ezA6WzAsMywyLDMsMiwxLDAsMV0sOTA6WzIsMywyLDEsMCwxLDAsM10sMTgwOlsyLDEsMCwxLDAsMywyLDNdLDI3MDpbMCwxLDAsMywyLDMsMiwxXX0sdXQ9e3g6WzEsMCwwXSx5OlswLDEsMF0sejpbMCwwLDFdfSxjdD0xLjQxNDIxMzU2MjM3LGR0PXt4OlsxLGN0LGN0XSx5OltjdCwxLGN0XSx6OltjdCxjdCwxXX07Y2xhc3MgZnR7Y29uc3RydWN0b3IodCxlLHMsaSl7dGhpcy5pZD10LHRoaXMucGFyZW50PWUsdGhpcy50ZXh0dXJlcz1zLHRoaXMuZWxlbWVudHM9aSx0aGlzLmZsYXR0ZW5lZD0hMX1nZXRCdWZmZXJzKHQsZSxzLGksbil7dmFyIHI7Y29uc3Qgbz1bXSxhPVtdLGw9W10saD1bXTtmb3IoY29uc3QgdSBvZiBudWxsIT09KHI9dGhpcy5lbGVtZW50cykmJnZvaWQgMCE9PXI/cjpbXSl7Y29uc3Qgcj10aGlzLmdldEVsZW1lbnRCdWZmZXJzKHQsZSx1LGkscyxuKTtvLnB1c2goci5wb3NpdGlvbiksYS5wdXNoKC4uLnIudGV4Q29vcmQpLGwucHVzaCguLi5yLnRpbnRDb2xvciksaC5wdXNoKC4uLnIuaW5kZXgpLGkrPXIudGV4Q29vcmQubGVuZ3RoLzJ9cmV0dXJue3Bvc2l0aW9uOm90KC4uLm8pLHRleENvb3JkOmEsdGludENvbG9yOmwsaW5kZXg6aH19Z2V0RWxlbWVudEJ1ZmZlcnModCxuLHIsbyxhLGwpe3ZhciBoLHUsYyxkLGYsZyxwLG0sdixiLHcsUDtjb25zdCB4PXIuZnJvbVswXSx5PXIuZnJvbVsxXSxBPXIuZnJvbVsyXSxTPXIudG9bMF0sQj1yLnRvWzFdLEU9ci50b1syXSxDPVtdLEk9W10saz1bXSxSPVtdLF89KGUscyxpKT0+e3ZhciByLGwsaCx1LGMsZCxmLGcscCxtLHYsYjtjb25zdFt3LFAseCx5XT1hLmdldFRleHR1cmVVVih0aGlzLmdldFRleHR1cmUoZS50ZXh0dXJlKSksQT0oeC13KS8xNixTPSh5LVApLzE2LEI9QS8xNixFPVMvMTY7c1swXT0obnVsbCE9PShsPW51bGw9PT0ocj1lLnV2KXx8dm9pZCAwPT09cj92b2lkIDA6clswXSkmJnZvaWQgMCE9PWw/bDpzWzBdKSpBK0Isc1sxXT0obnVsbCE9PSh1PW51bGw9PT0oaD1lLnV2KXx8dm9pZCAwPT09aD92b2lkIDA6aFsxXSkmJnZvaWQgMCE9PXU/dTpzWzFdKSpTK0Usc1syXT0obnVsbCE9PShkPW51bGw9PT0oYz1lLnV2KXx8dm9pZCAwPT09Yz92b2lkIDA6Y1syXSkmJnZvaWQgMCE9PWQ/ZDpzWzJdKSpBLUIsc1szXT0obnVsbCE9PShnPW51bGw9PT0oZj1lLnV2KXx8dm9pZCAwPT09Zj92b2lkIDA6ZlszXSkmJnZvaWQgMCE9PWc/ZzpzWzNdKSpTLUU7Y29uc3QgXz1odFtudWxsIT09KHA9ZS5yb3RhdGlvbikmJnZvaWQgMCE9PXA/cDowXTtJLnB1c2godytzW19bMF1dLFArc1tfWzFdXSx3K3NbX1syXV0sUCtzW19bM11dLHcrc1tfWzRdXSxQK3NbX1s1XV0sdytzW19bNl1dLFArc1tfWzddXSk7Y29uc3QgRj0obnVsbCE9PShtPWUudGludGluZGV4KSYmdm9pZCAwIT09bT9tOi0xKT49MCYmbnVsbCE9PShiPW51bGw9PT0odj1udFt0LnNsaWNlKDEwKV0pfHx2b2lkIDA9PT12P3ZvaWQgMDp2LmNhbGwobnQsbikpJiZ2b2lkIDAhPT1iP2I6WzEsMSwxXTtrLnB1c2goLi4uRiwuLi5GLC4uLkYsLi4uRiksQy5wdXNoKC4uLmkpLFIucHVzaChvLG8rMSxvKzIsbyxvKzIsbyszKSxvKz00fTshKG51bGw9PT0odT1udWxsPT09KGg9ci5mYWNlcyl8fHZvaWQgMD09PWg/dm9pZCAwOmgudXApfHx2b2lkIDA9PT11P3ZvaWQgMDp1LnRleHR1cmUpfHxyLmZhY2VzLnVwLmN1bGxmYWNlJiZsW3IuZmFjZXMudXAuY3VsbGZhY2VdfHxfKHIuZmFjZXMudXAsW3gsMTYtRSxTLDE2LUFdLFt4LEIsRSxTLEIsRSxTLEIsQSx4LEIsQV0pLCEobnVsbD09PShkPW51bGw9PT0oYz1yLmZhY2VzKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5kb3duKXx8dm9pZCAwPT09ZD92b2lkIDA6ZC50ZXh0dXJlKXx8ci5mYWNlcy5kb3duLmN1bGxmYWNlJiZsW3IuZmFjZXMuZG93bi5jdWxsZmFjZV18fF8oci5mYWNlcy5kb3duLFsxNi1FLDE2LVMsMTYtQSwxNi14XSxbeCx5LEEsUyx5LEEsUyx5LEUseCx5LEVdKSwhKG51bGw9PT0oZz1udWxsPT09KGY9ci5mYWNlcyl8fHZvaWQgMD09PWY/dm9pZCAwOmYuc291dGgpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLnRleHR1cmUpfHxyLmZhY2VzLnNvdXRoLmN1bGxmYWNlJiZsW3IuZmFjZXMuc291dGguY3VsbGZhY2VdfHxfKHIuZmFjZXMuc291dGgsW3gsMTYtQixTLDE2LXldLFt4LHksRSxTLHksRSxTLEIsRSx4LEIsRV0pLCEobnVsbD09PShtPW51bGw9PT0ocD1yLmZhY2VzKXx8dm9pZCAwPT09cD92b2lkIDA6cC5ub3J0aCl8fHZvaWQgMD09PW0/dm9pZCAwOm0udGV4dHVyZSl8fHIuZmFjZXMubm9ydGguY3VsbGZhY2UmJmxbci5mYWNlcy5ub3J0aC5jdWxsZmFjZV18fF8oci5mYWNlcy5ub3J0aCxbMTYtUywxNi1CLDE2LXgsMTYteV0sW1MseSxBLHgseSxBLHgsQixBLFMsQixBXSksIShudWxsPT09KGI9bnVsbD09PSh2PXIuZmFjZXMpfHx2b2lkIDA9PT12P3ZvaWQgMDp2LmVhc3QpfHx2b2lkIDA9PT1iP3ZvaWQgMDpiLnRleHR1cmUpfHxyLmZhY2VzLmVhc3QuY3VsbGZhY2UmJmxbci5mYWNlcy5lYXN0LmN1bGxmYWNlXXx8XyhyLmZhY2VzLmVhc3QsWzE2LUUsMTYtQiwxNi1BLDE2LXldLFtTLHksRSxTLHksQSxTLEIsQSxTLEIsRV0pLCEobnVsbD09PShQPW51bGw9PT0odz1yLmZhY2VzKXx8dm9pZCAwPT09dz92b2lkIDA6dy53ZXN0KXx8dm9pZCAwPT09UD92b2lkIDA6UC50ZXh0dXJlKXx8ci5mYWNlcy53ZXN0LmN1bGxmYWNlJiZsW3IuZmFjZXMud2VzdC5jdWxsZmFjZV18fF8oci5mYWNlcy53ZXN0LFtBLDE2LUIsRSwxNi15XSxbeCx5LEEseCx5LEUseCxCLEUseCxCLEFdKTtjb25zdCBGPXMuY3JlYXRlKCk7aWYocy5pZGVudGl0eShGKSxyLnJvdGF0aW9uKXtjb25zdCB0PWUuZnJvbVZhbHVlcyguLi5yLnJvdGF0aW9uLm9yaWdpbik7cy50cmFuc2xhdGUoRixGLHQpLHMucm90YXRlKEYsRixpLnRvUmFkaWFuKHIucm90YXRpb24uYW5nbGUpLHV0W3Iucm90YXRpb24uYXhpc10pLHIucm90YXRpb24ucmVzY2FsZSYmcy5zY2FsZShGLEYsZHRbci5yb3RhdGlvbi5heGlzXSksZS5uZWdhdGUodCx0KSxzLnRyYW5zbGF0ZShGLEYsdCl9Y29uc3QgTT1uZXcgRmxvYXQzMkFycmF5KEMpO3JldHVybiBhdChNLEYpLHtwb3NpdGlvbjpNLHRleENvb3JkOkksdGludENvbG9yOmssaW5kZXg6Un19Z2V0VGV4dHVyZSh0KXtmb3IodmFyIGUsczt0LnN0YXJ0c1dpdGgoXCIjXCIpOyl0PW51bGwhPT0ocz1udWxsPT09KGU9dGhpcy50ZXh0dXJlcyl8fHZvaWQgMD09PWU/dm9pZCAwOmVbdC5zbGljZSgxKV0pJiZ2b2lkIDAhPT1zP3M6XCJcIjtyZXR1cm4gdC5zdGFydHNXaXRoKFwibWluZWNyYWZ0OlwiKXx8KHQ9XCJtaW5lY3JhZnQ6XCIrdCksdH1mbGF0dGVuKHQpe3ZhciBlO2lmKCF0aGlzLmZsYXR0ZW5lZCYmdGhpcy5wYXJlbnQpe2NvbnN0IHM9dC5nZXRCbG9ja01vZGVsKHRoaXMucGFyZW50KTtpZighcylyZXR1cm4gY29uc29sZS53YXJuKGBwYXJlbnQgJHt0aGlzLnBhcmVudH0gZG9lcyBub3QgZXhpc3QhYCksdm9pZCh0aGlzLmZsYXR0ZW5lZD0hMCk7cy5mbGF0dGVuKHQpLHRoaXMuZWxlbWVudHN8fCh0aGlzLmVsZW1lbnRzPXMuZWxlbWVudHMpLHRoaXMudGV4dHVyZXN8fCh0aGlzLnRleHR1cmVzPXt9KSxPYmplY3Qua2V5cyhudWxsIT09KGU9cy50ZXh0dXJlcykmJnZvaWQgMCE9PWU/ZTp7fSkuZm9yRWFjaCgodD0+e3RoaXMudGV4dHVyZXNbdF18fCh0aGlzLnRleHR1cmVzW3RdPXMudGV4dHVyZXNbdF0pfSkpLHRoaXMuZmxhdHRlbmVkPSEwfX1zdGF0aWMgZnJvbUpzb24odCxlKXtsZXQgcz1lLnBhcmVudDtyZXR1cm4gcyYmIXMuc3RhcnRzV2l0aChcIm1pbmVjcmFmdDpcIikmJihzPVwibWluZWNyYWZ0OlwiK3MpLG5ldyBmdCh0LHMsZS50ZXh0dXJlcyxlLmVsZW1lbnRzKX19Y2xhc3MgZ3R7Y29uc3RydWN0b3IodCxlLHMpe3RoaXMuZ2w9dCx0aGlzLnByb2dyYW09dGhpcy5pbml0U2hhZGVyUHJvZ3JhbShlLHMpfWdldFByb2dyYW0oKXtyZXR1cm4gdGhpcy5wcm9ncmFtfWluaXRTaGFkZXJQcm9ncmFtKHQsZSl7Y29uc3Qgcz10aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSLHQpLGk9dGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSLGUpLG49dGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7aWYodGhpcy5nbC5hdHRhY2hTaGFkZXIobixzKSx0aGlzLmdsLmF0dGFjaFNoYWRlcihuLGkpLHRoaXMuZ2wubGlua1Byb2dyYW0obiksIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHRoaXMuZ2wuTElOS19TVEFUVVMpKXRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxpbmsgc2hhZGVyIHByb2dyYW06ICR7dGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhuKX1gKTtyZXR1cm4gbn1sb2FkU2hhZGVyKHQsZSl7Y29uc3Qgcz10aGlzLmdsLmNyZWF0ZVNoYWRlcih0KTtpZih0aGlzLmdsLnNoYWRlclNvdXJjZShzLGUpLHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzKSwhdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIocyx0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgZT1uZXcgRXJyb3IoYENvbXBpbGluZyAke3Q9PT10aGlzLmdsLlZFUlRFWF9TSEFERVI/XCJ2ZXJ0ZXhcIjpcImZyYWdtZW50XCJ9IHNoYWRlcjogJHt0aGlzLmdsLmdldFNoYWRlckluZm9Mb2cocyl9YCk7dGhyb3cgdGhpcy5nbC5kZWxldGVTaGFkZXIocyksZX1yZXR1cm4gc319ZnVuY3Rpb24gcHQodCxlLHMsaSxuKXtjb25zdCByPW5ldyBsdChcIlwiLHtcIlwiOnttb2RlbDpcIlwifX0sdm9pZCAwKSxvPXtnZXRCbG9ja01vZGVsOigpPT5ufTtyZXR1cm4gbi5mbGF0dGVuKG8pLHIuZ2V0QnVmZmVycyh0LHt9LGUsbyxzLGkpfWZ1bmN0aW9uIG10KHQsZSxzLGkscixvKXtjb25zdCBhPXIudXA/MTY6WzE0LjIsMTIuNSwxMC41LDksNyw1LjMsMy43LDEuOSwxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNl1bc107cmV0dXJuIHB0KGBtaW5lY3JhZnQ6JHt0fWAsaSxlLHIsbmV3IGZ0KFwiXCIsXCJcIix7c3RpbGw6YG1pbmVjcmFmdDpibG9jay8ke3R9X3N0aWxsYCxmbG93OmBtaW5lY3JhZnQ6YmxvY2svJHt0fV9mbG93YH0sW3tmcm9tOlswLDAsMF0sdG86WzE2LGEsMTZdLGZhY2VzOnt1cDp7dGV4dHVyZTpcIiNzdGlsbFwiLHRpbnRpbmRleDpvLGN1bGxmYWNlOm4uVVB9LGRvd246e3RleHR1cmU6XCIjc3RpbGxcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLkRPV059LG5vcnRoOnt0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLk5PUlRIfSxlYXN0Ont0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLkVBU1R9LHNvdXRoOnt0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLlNPVVRIfSx3ZXN0Ont0ZXh0dXJlOlwiI2Zsb3dcIix0aW50aW5kZXg6byxjdWxsZmFjZTpuLldFU1R9fX1dKSl9Y29uc3QgdnQ9e1wibWluZWNyYWZ0OndhdGVyXCI6KHQsZSxzLGkpPT5tdChcIndhdGVyXCIsdCxwYXJzZUludChlLmxldmVsKSxzLGksMCksXCJtaW5lY3JhZnQ6bGF2YVwiOih0LGUscyxpKT0+bXQoXCJsYXZhXCIsdCxwYXJzZUludChlLmxldmVsKSxzLGkpLFwibWluZWNyYWZ0OmNoZXN0XCI6KHQsZSxzKT0+ZnVuY3Rpb24odCxlLHMsaSl7cmV0dXJuIHB0KFwibWluZWNyYWZ0OmNoZXN0XCIsaSx0LHt9LG5ldyBmdChcIlwiLFwiXCIsezA6XCJtaW5lY3JhZnQ6YmxvY2svY2hlc3RcIn0sW3tmcm9tOlsxLDAsMV0sdG86WzE1LDE0LDE1XSxmYWNlczp7dXA6e3RleHR1cmU6XCIjMFwifSxkb3duOnt0ZXh0dXJlOlwiIzBcIn0sbm9ydGg6e3RleHR1cmU6XCIjMFwifSxlYXN0Ont0ZXh0dXJlOlwiIzBcIn0sc291dGg6e3RleHR1cmU6XCIjMFwifSx3ZXN0Ont0ZXh0dXJlOlwiIzBcIn19fV0pKX0odCxlLmZhY2luZyxlLnR5cGUscyl9LGJ0PW5ldyBTZXQoT2JqZWN0LmtleXModnQpKTtjbGFzcyB3dHtjb25zdHJ1Y3Rvcih0LGUscyxpKXt2YXIgbixyO3RoaXMuZ2w9dCx0aGlzLnN0cnVjdHVyZT1lLHRoaXMucmVzb3VyY2VzPXMsdGhpcy5jaHVua3M9W10sKG51bGw9PWk/dm9pZCAwOmkuZmFjZXNQZXJCdWZmZXIpJiZjb25zb2xlLndhcm4oXCJ3ZWJnbCByZW5kZXIgd2FybmluZzogZmFjZXNQZXJCdWZmZXIgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQgaW4gZmF2b3Igb2YgY2h1bmtTaXplXCIpLHRoaXMuY2h1bmtTaXplPW51bGwhPT0obj1udWxsPT1pP3ZvaWQgMDppLmNodW5rU2l6ZSkmJnZvaWQgMCE9PW4/bjoxNix0aGlzLnVzZUludmlzaWJsZUJsb2NrQnVmZmVyPW51bGw9PT0ocj1udWxsPT1pP3ZvaWQgMDppLnVzZUludmlzaWJsZUJsb2NrQnVmZmVyKXx8dm9pZCAwPT09cnx8cix0aGlzLnNoYWRlclByb2dyYW09bmV3IGd0KHQsXCJcXG4gIGF0dHJpYnV0ZSB2ZWM0IHZlcnRQb3M7XFxuICBhdHRyaWJ1dGUgdmVjMiB0ZXhDb29yZDtcXG4gIGF0dHJpYnV0ZSB2ZWMzIHRpbnRDb2xvcjtcXG4gIGF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG5cXG4gIHVuaWZvcm0gbWF0NCBtVmlldztcXG4gIHVuaWZvcm0gbWF0NCBtUHJvajtcXG5cXG4gIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4Q29vcmQ7XFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdlRpbnRDb2xvcjtcXG4gIHZhcnlpbmcgaGlnaHAgZmxvYXQgdkxpZ2h0aW5nO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBtUHJvaiAqIG1WaWV3ICogdmVydFBvcztcXG4gICAgdlRleENvb3JkID0gdGV4Q29vcmQ7XFxuICAgIHZUaW50Q29sb3IgPSB0aW50Q29sb3I7XFxuICAgIHZMaWdodGluZyA9IG5vcm1hbC55ICogMC4yICsgYWJzKG5vcm1hbC56KSAqIDAuMSArIDAuODtcXG4gIH1cXG5cIixcIlxcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXhDb29yZDtcXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2VGludENvbG9yO1xcbiAgdmFyeWluZyBoaWdocCBmbG9hdCB2TGlnaHRpbmc7XFxuXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChzYW1wbGVyLCB2VGV4Q29vcmQpO1xcbiAgICBpZih0ZXhDb2xvci5hIDwgMC4wMSkgZGlzY2FyZDtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXhDb2xvci54eXogKiB2VGludENvbG9yICogdkxpZ2h0aW5nLCB0ZXhDb2xvci5hKTtcXG4gIH1cXG5cIikuZ2V0UHJvZ3JhbSgpLHRoaXMuZ3JpZFNoYWRlclByb2dyYW09bmV3IGd0KHQsXCJcXG4gIGF0dHJpYnV0ZSB2ZWM0IHZlcnRQb3M7XFxuICBhdHRyaWJ1dGUgdmVjMyB2ZXJ0Q29sb3I7XFxuXFxuICB1bmlmb3JtIG1hdDQgbVZpZXc7XFxuICB1bmlmb3JtIG1hdDQgbVByb2o7XFxuXFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkNvbG9yO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBtUHJvaiAqIG1WaWV3ICogdmVydFBvcztcXG4gICAgdkNvbG9yID0gdmVydENvbG9yO1xcbiAgfVxcblwiLFwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkNvbG9yO1xcblxcbiAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XFxuICB9XFxuXCIpLmdldFByb2dyYW0oKSx0aGlzLmNvbG9yU2hhZGVyUHJvZ3JhbT1uZXcgZ3QodCxcIlxcbiAgYXR0cmlidXRlIHZlYzQgdmVydFBvcztcXG4gIGF0dHJpYnV0ZSB2ZWMzIGJsb2NrUG9zO1xcblxcbiAgdW5pZm9ybSBtYXQ0IG1WaWV3O1xcbiAgdW5pZm9ybSBtYXQ0IG1Qcm9qO1xcblxcbiAgdmFyeWluZyBoaWdocCB2ZWMzIHZDb2xvcjtcXG5cXG4gIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gbVByb2ogKiBtVmlldyAqIHZlcnRQb3M7XFxuICAgIHZDb2xvciA9IGJsb2NrUG9zIC8gMjU2LjA7XFxuICB9XFxuXCIsXCJcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gIHZhcnlpbmcgaGlnaHAgdmVjMyB2Q29sb3I7XFxuXFxuICB2b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgMS4wKTtcXG4gIH1cXG5cIikuZ2V0UHJvZ3JhbSgpLHRoaXMudXBkYXRlU3RydWN0dXJlQnVmZmVycygpLHRoaXMuZ3JpZEJ1ZmZlcnM9dGhpcy5nZXRHcmlkQnVmZmVycygpLHRoaXMub3V0bGluZUJ1ZmZlcnM9dGhpcy5nZXRPdXRsaW5lQnVmZmVycygpLHRoaXMuaW52aXNpYmxlQmxvY2tCdWZmZXJzPXRoaXMuZ2V0SW52aXNpYmxlQmxvY2tCdWZmZXJzKCksdGhpcy5hdGxhc1RleHR1cmU9dGhpcy5nZXRCbG9ja1RleHR1cmUoKSx0aGlzLnByb2pNYXRyaXg9dGhpcy5nZXRQZXJzcGVjdGl2ZSgpLHRoaXMuYWN0aXZlU2hhZGVyPXRoaXMuc2hhZGVyUHJvZ3JhbSx0aGlzLmluaXRpYWxpemUoKX1zZXRTdHJ1Y3R1cmUodCl7dGhpcy5zdHJ1Y3R1cmU9dCx0aGlzLnVwZGF0ZVN0cnVjdHVyZUJ1ZmZlcnMoKSx0aGlzLmdyaWRCdWZmZXJzPXRoaXMuZ2V0R3JpZEJ1ZmZlcnMoKSx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycz10aGlzLmdldEludmlzaWJsZUJsb2NrQnVmZmVycygpfWluaXRpYWxpemUoKXt0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpLHRoaXMuZ2wuZGVwdGhGdW5jKHRoaXMuZ2wuTEVRVUFMKSx0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKSx0aGlzLmdsLmJsZW5kRnVuYyh0aGlzLmdsLlNSQ19BTFBIQSx0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKSx0aGlzLmdsLmN1bGxGYWNlKHRoaXMuZ2wuQkFDSyl9Z2V0QmxvY2tUZXh0dXJlKCl7Y29uc3QgdD10aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtyZXR1cm4gdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsdCksdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwwLHRoaXMuZ2wuUkdCQSx0aGlzLmdsLlJHQkEsdGhpcy5nbC5VTlNJR05FRF9CWVRFLHRoaXMucmVzb3VyY2VzLmdldFRleHR1cmVBdGxhcygpKSx0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuZ2wuVEVYVFVSRV8yRCksdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCx0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUix0aGlzLmdsLk5FQVJFU1QpLHR9Z2V0UGVyc3BlY3RpdmUoKXtjb25zdCB0PTcwKk1hdGguUEkvMTgwLGU9dGhpcy5nbC5jYW52YXMuY2xpZW50V2lkdGgvdGhpcy5nbC5jYW52YXMuY2xpZW50SGVpZ2h0LGk9cy5jcmVhdGUoKTtyZXR1cm4gcy5wZXJzcGVjdGl2ZShpLHQsZSwuMSw1MDApLGl9Z2V0Q2h1bmsodCl7Y29uc3QgZT0yKk1hdGguYWJzKHRbMF0pKyh0WzBdPDA/MTowKSxzPTIqTWF0aC5hYnModFsxXSkrKHRbMV08MD8xOjApLGk9MipNYXRoLmFicyh0WzJdKSsodFsyXTwwPzE6MCk7cmV0dXJuIHRoaXMuY2h1bmtzW2VdfHwodGhpcy5jaHVua3NbZV09W10pLHRoaXMuY2h1bmtzW2VdW3NdfHwodGhpcy5jaHVua3NbZV1bc109W10pLHRoaXMuY2h1bmtzW2VdW3NdW2ldfHwodGhpcy5jaHVua3NbZV1bc11baV09e3Bvc2l0aW9uczpbXSx0ZXh0dXJlQ29vcmRpbmF0ZXM6W10sdGludENvbG9yczpbXSxibG9ja1Bvc2l0aW9uczpbXSxub3JtYWxzOltdLGluZGljZXM6W10saW5kZXhPZmZzZXQ6MH0pLHRoaXMuY2h1bmtzW2VdW3NdW2ldfXVwZGF0ZVN0cnVjdHVyZUJ1ZmZlcnModCl7dmFyIGk7Y29uc3Qgcj0odCxpLG4pPT57Y29uc3Qgcj1zLmNyZWF0ZSgpO3MudHJhbnNsYXRlKHIscixpKSxhdCh0LnBvc2l0aW9uLHIpLG4ucG9zaXRpb25zLnB1c2godC5wb3NpdGlvbiksbi50ZXh0dXJlQ29vcmRpbmF0ZXMucHVzaCguLi50LnRleENvb3JkKSxuLnRpbnRDb2xvcnMucHVzaCguLi50LnRpbnRDb2xvcik7Zm9yKGxldCBzPTA7czx0LnBvc2l0aW9uLmxlbmd0aDtzKz0xMil7Y29uc3QgaT1lLmZyb21WYWx1ZXModC5wb3NpdGlvbltzXSx0LnBvc2l0aW9uW3MrMV0sdC5wb3NpdGlvbltzKzJdKSxyPWUuZnJvbVZhbHVlcyh0LnBvc2l0aW9uW3MrM10sdC5wb3NpdGlvbltzKzRdLHQucG9zaXRpb25bcys1XSksbz1lLmZyb21WYWx1ZXModC5wb3NpdGlvbltzKzZdLHQucG9zaXRpb25bcys3XSx0LnBvc2l0aW9uW3MrOF0pO2Uuc3VidHJhY3QocixyLGkpLGUuc3VidHJhY3QobyxvLGkpLGUuY3Jvc3MocixyLG8pLGUubm9ybWFsaXplKHIsciksbi5ub3JtYWxzLnB1c2goLi4uciwuLi5yLC4uLnIsLi4ucil9Zm9yKGxldCBlPTA7ZTx0LnRleENvb3JkLmxlbmd0aC8yO2UrPTEpbi5ibG9ja1Bvc2l0aW9ucy5wdXNoKC4uLmkpO24uaW5kaWNlcy5wdXNoKC4uLnQuaW5kZXgpLG4uaW5kZXhPZmZzZXQrPXQudGV4Q29vcmQubGVuZ3RoLzJ9LG89dD0+e3QucG9zaXRpb25zPVtdLHQudGV4dHVyZUNvb3JkaW5hdGVzPVtdLHQudGludENvbG9ycz1bXSx0LmJsb2NrUG9zaXRpb25zPVtdLHQubm9ybWFscz1bXSx0LmluZGljZXM9W10sdC5pbmRleE9mZnNldD0wfSxhPXQ9Pnt0LmJ1ZmZlcj8odGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIucG9zaXRpb24sdGhpcy5nbC5BUlJBWV9CVUZGRVIsb3QoLi4udC5wb3NpdGlvbnMpKSx0aGlzLnVwZGF0ZUJ1ZmZlcih0LmJ1ZmZlci50ZXhDb29yZCx0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQudGV4dHVyZUNvb3JkaW5hdGVzKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIudGludENvbG9yLHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC50aW50Q29sb3JzKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIubm9ybWFsLHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC5ub3JtYWxzKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIuYmxvY2tQb3MsdGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0LmJsb2NrUG9zaXRpb25zKSksdGhpcy51cGRhdGVCdWZmZXIodC5idWZmZXIuaW5kZXgsdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixuZXcgVWludDE2QXJyYXkodC5pbmRpY2VzKSksdC5idWZmZXIubGVuZ3RoPXQuaW5kaWNlcy5sZW5ndGgpOnQuYnVmZmVyPXtwb3NpdGlvbjp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixvdCguLi50LnBvc2l0aW9ucykpLHRleENvb3JkOnRoaXMuY3JlYXRlQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkodC50ZXh0dXJlQ29vcmRpbmF0ZXMpKSx0aW50Q29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0LnRpbnRDb2xvcnMpKSxibG9ja1Bvczp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KHQuYmxvY2tQb3NpdGlvbnMpKSxub3JtYWw6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0Lm5vcm1hbHMpKSxpbmRleDp0aGlzLmNyZWF0ZUJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG5ldyBVaW50MTZBcnJheSh0LmluZGljZXMpKSxsZW5ndGg6dC5pbmRpY2VzLmxlbmd0aH19O2xldCBsO3Q/dC5mb3JFYWNoKCh0PT57Y29uc3QgZT10aGlzLmdldENodW5rKHQpO28oZSl9KSk6dGhpcy5jaHVua3MuZm9yRWFjaCgodD0+dC5mb3JFYWNoKCh0PT50LmZvckVhY2goKHQ9PntvKHQpfSkpKSkpKTtmb3IoY29uc3QgcyBvZiB0aGlzLnN0cnVjdHVyZS5nZXRCbG9ja3MoKSl7Y29uc3Qgbz1zLnN0YXRlLmdldE5hbWUoKSxhPXMuc3RhdGUuZ2V0UHJvcGVydGllcygpLGg9bnVsbCE9PShpPXRoaXMucmVzb3VyY2VzLmdldERlZmF1bHRCbG9ja1Byb3BlcnRpZXMobykpJiZ2b2lkIDAhPT1pP2k6e307T2JqZWN0LmVudHJpZXMoaCkuZm9yRWFjaCgoKFt0LGVdKT0+e2FbdF18fChhW3RdPWUpfSkpO2NvbnN0IHU9W01hdGguZmxvb3Iocy5wb3NbMF0vdGhpcy5jaHVua1NpemUpLE1hdGguZmxvb3Iocy5wb3NbMV0vdGhpcy5jaHVua1NpemUpLE1hdGguZmxvb3Iocy5wb3NbMl0vdGhpcy5jaHVua1NpemUpXTtpZih0JiYhdC5zb21lKCh0PT5lLmVxdWFscyh0LHUpKSkpY29udGludWU7Y29uc3QgYz10aGlzLmdldENodW5rKHUpO3RyeXtjb25zdCB0PXRoaXMucmVzb3VyY2VzLmdldEJsb2NrRGVmaW5pdGlvbihvKSxlPXt1cDp0aGlzLm5lZWRzQ3VsbChzLG4uVVApLGRvd246dGhpcy5uZWVkc0N1bGwocyxuLkRPV04pLHdlc3Q6dGhpcy5uZWVkc0N1bGwocyxuLldFU1QpLGVhc3Q6dGhpcy5uZWVkc0N1bGwocyxuLkVBU1QpLG5vcnRoOnRoaXMubmVlZHNDdWxsKHMsbi5OT1JUSCksc291dGg6dGhpcy5uZWVkc0N1bGwocyxuLlNPVVRIKX07dCYmKGw9dC5nZXRCdWZmZXJzKG8sYSx0aGlzLnJlc291cmNlcyx0aGlzLnJlc291cmNlcyxjLmluZGV4T2Zmc2V0LGUpLHIobCxzLnBvcyxjKSksYnQuaGFzKG8pJiYobD12dFtvXShjLmluZGV4T2Zmc2V0LGEsdGhpcy5yZXNvdXJjZXMsZSkscihsLHMucG9zLGMpKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKGBFcnJvciByZW5kZXJpbmcgYmxvY2sgJHtvfWAsdCl9fXQ/dC5mb3JFYWNoKCh0PT57Y29uc3QgZT10aGlzLmdldENodW5rKHQpO2EoZSl9KSk6dGhpcy5jaHVua3MuZm9yRWFjaCgodD0+dC5mb3JFYWNoKCh0PT50LmZvckVhY2goKHQ9PnthKHQpfSkpKSkpKX1uZWVkc0N1bGwodCxlKXt2YXIgcyxpO2NvbnN0IHI9bnVsbD09PShzPXRoaXMuc3RydWN0dXJlLmdldEJsb2NrKG8udG93YXJkcyh0LnBvcyxlKSkpfHx2b2lkIDA9PT1zP3ZvaWQgMDpzLnN0YXRlO3JldHVybiEhciYmKChudWxsPT09KGk9dGhpcy5yZXNvdXJjZXMuZ2V0QmxvY2tGbGFncyhyLmdldE5hbWUoKSkpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLm9wYXF1ZSk/IShlPT09bi5VUCYmdC5zdGF0ZS5pc0ZsdWlkKCkpOnQuc3RhdGUuaXNGbHVpZCgpJiZyLmlzRmx1aWQoKSl9Z2V0R3JpZEJ1ZmZlcnMoKXtjb25zdFt0LGUsc109dGhpcy5zdHJ1Y3R1cmUuZ2V0U2l6ZSgpLGk9W10sbj1bXTtpLnB1c2goMCwwLDAsdCwwLDApLG4ucHVzaCgxLDAsMCwxLDAsMCksaS5wdXNoKDAsMCwwLDAsMCxzKSxuLnB1c2goMCwwLDEsMCwwLDEpLGkucHVzaCgwLDAsMCwwLGUsMCksaS5wdXNoKHQsMCwwLHQsZSwwKSxpLnB1c2goMCwwLHMsMCxlLHMpLGkucHVzaCh0LDAscyx0LGUscyksaS5wdXNoKDAsZSwwLDAsZSxzKSxpLnB1c2godCxlLDAsdCxlLHMpLGkucHVzaCgwLGUsMCx0LGUsMCksaS5wdXNoKDAsZSxzLHQsZSxzKTtmb3IobGV0IGU9MTtlPD10O2UrPTEpaS5wdXNoKGUsMCwwLGUsMCxzKTtmb3IobGV0IGU9MTtlPD1zO2UrPTEpaS5wdXNoKDAsMCxlLHQsMCxlKTtmb3IobGV0IGU9MDtlPDgrdCtzO2UrPTEpbi5wdXNoKC44LC44LC44LC44LC44LC44KTtyZXR1cm57cG9zaXRpb246dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShpKSksY29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShuKSksbGVuZ3RoOmkubGVuZ3RoLzN9fWdldE91dGxpbmVCdWZmZXJzKCl7Y29uc3QgdD1bXSxlPVtdO3JldHVybiB0aGlzLmFkZEN1YmUodCxlLFsxLDEsMV0sWzAsMCwwXSxbMSwxLDFdKSx7cG9zaXRpb246dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheSh0KSksY29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShlKSksbGVuZ3RoOnQubGVuZ3RoLzN9fWdldEludmlzaWJsZUJsb2NrQnVmZmVycygpe2lmKCF0aGlzLnVzZUludmlzaWJsZUJsb2NrQnVmZmVyKXJldHVybjtjb25zdCB0PXRoaXMuc3RydWN0dXJlLmdldFNpemUoKSxlPVtdLHM9W107Zm9yKGxldCBpPTA7aTx0WzBdO2krPTEpZm9yKGxldCBuPTA7bjx0WzFdO24rPTEpZm9yKGxldCByPTA7cjx0WzJdO3IrPTEpe2NvbnN0IHQ9dGhpcy5zdHJ1Y3R1cmUuZ2V0QmxvY2soW2ksbixyXSk7dm9pZCAwIT09dCYmKG51bGw9PT10P3RoaXMuYWRkQ3ViZShlLHMsWzEsLjI1LC4yNV0sW2krLjQzNzUsbisuNDM3NSxyKy40Mzc1XSxbaSsuNTYyNSxuKy41NjI1LHIrLjU2MjVdKTpcIm1pbmVjcmFmdDphaXJcIj09PXQuc3RhdGUuZ2V0TmFtZSgpP3RoaXMuYWRkQ3ViZShlLHMsWy41LC41LDFdLFtpKy4zNzUsbisuMzc1LHIrLjM3NV0sW2krLjYyNSxuKy42MjUscisuNjI1XSk6XCJtaW5lY3JhZnQ6Y2F2ZV9haXJcIj09PXQuc3RhdGUuZ2V0TmFtZSgpJiZ0aGlzLmFkZEN1YmUoZSxzLFsuNSwxLC41XSxbaSsuMzc1LG4rLjM3NSxyKy4zNzVdLFtpKy42MjUsbisuNjI1LHIrLjYyNV0pKX1yZXR1cm57cG9zaXRpb246dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShlKSksY29sb3I6dGhpcy5jcmVhdGVCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShzKSksbGVuZ3RoOmUubGVuZ3RoLzN9fWFkZEN1YmUodCxlLHMsaSxuKXt0LnB1c2goaVswXSxpWzFdLGlbMl0saVswXSxpWzFdLG5bMl0pLHQucHVzaChuWzBdLGlbMV0saVsyXSxuWzBdLGlbMV0sblsyXSksdC5wdXNoKGlbMF0saVsxXSxpWzJdLG5bMF0saVsxXSxpWzJdKSx0LnB1c2goaVswXSxpWzFdLG5bMl0sblswXSxpWzFdLG5bMl0pLHQucHVzaChpWzBdLGlbMV0saVsyXSxpWzBdLG5bMV0saVsyXSksdC5wdXNoKG5bMF0saVsxXSxpWzJdLG5bMF0sblsxXSxpWzJdKSx0LnB1c2goaVswXSxpWzFdLG5bMl0saVswXSxuWzFdLG5bMl0pLHQucHVzaChuWzBdLGlbMV0sblsyXSxuWzBdLG5bMV0sblsyXSksdC5wdXNoKGlbMF0sblsxXSxpWzJdLGlbMF0sblsxXSxuWzJdKSx0LnB1c2goblswXSxuWzFdLGlbMl0sblswXSxuWzFdLG5bMl0pLHQucHVzaChpWzBdLG5bMV0saVsyXSxuWzBdLG5bMV0saVsyXSksdC5wdXNoKGlbMF0sblsxXSxuWzJdLG5bMF0sblsxXSxuWzJdKTtmb3IobGV0IHQ9MDt0PDI0O3QrPTEpZS5wdXNoKC4uLnMpfWNyZWF0ZUJ1ZmZlcih0LGUpe2NvbnN0IHM9dGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gdGhpcy5nbC5iaW5kQnVmZmVyKHQscyksdGhpcy5nbC5idWZmZXJEYXRhKHQsZSx0aGlzLmdsLkRZTkFNSUNfRFJBVyksc311cGRhdGVCdWZmZXIodCxlLHMpe3RoaXMuZ2wuYmluZEJ1ZmZlcihlLHQpLHRoaXMuZ2wuYnVmZmVyRGF0YShlLHMsdGhpcy5nbC5TVEFUSUNfRFJBVyl9ZHJhd0dyaWQodCl7dGhpcy5zZXRTaGFkZXIodGhpcy5ncmlkU2hhZGVyUHJvZ3JhbSksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydFBvc1wiLDMsdGhpcy5ncmlkQnVmZmVycy5wb3NpdGlvbiksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydENvbG9yXCIsMyx0aGlzLmdyaWRCdWZmZXJzLmNvbG9yKSx0aGlzLnNldFVuaWZvcm0oXCJtVmlld1wiLHQpLHRoaXMuc2V0VW5pZm9ybShcIm1Qcm9qXCIsdGhpcy5wcm9qTWF0cml4KSx0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5MSU5FUywwLHRoaXMuZ3JpZEJ1ZmZlcnMubGVuZ3RoKX1kcmF3SW52aXNpYmxlQmxvY2tzKHQpe3RoaXMudXNlSW52aXNpYmxlQmxvY2tCdWZmZXImJih0aGlzLnNldFNoYWRlcih0aGlzLmdyaWRTaGFkZXJQcm9ncmFtKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycy5wb3NpdGlvbiksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidmVydENvbG9yXCIsMyx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycy5jb2xvciksdGhpcy5zZXRVbmlmb3JtKFwibVZpZXdcIix0KSx0aGlzLnNldFVuaWZvcm0oXCJtUHJvalwiLHRoaXMucHJvak1hdHJpeCksdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuTElORVMsMCx0aGlzLmludmlzaWJsZUJsb2NrQnVmZmVycy5sZW5ndGgpKX1kcmF3U3RydWN0dXJlKHQpe3RoaXMuc2V0U2hhZGVyKHRoaXMuc2hhZGVyUHJvZ3JhbSksdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTApLHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELHRoaXMuYXRsYXNUZXh0dXJlKSx0aGlzLnNldFVuaWZvcm0oXCJtVmlld1wiLHQpLHRoaXMuc2V0VW5pZm9ybShcIm1Qcm9qXCIsdGhpcy5wcm9qTWF0cml4KSx0aGlzLmNodW5rcy5mb3JFYWNoKCh0PT57dC5mb3JFYWNoKCh0PT57dC5mb3JFYWNoKCh0PT57dC5idWZmZXImJih0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0LmJ1ZmZlci5wb3NpdGlvbiksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwidGV4Q29vcmRcIiwyLHQuYnVmZmVyLnRleENvb3JkKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ0aW50Q29sb3JcIiwzLHQuYnVmZmVyLnRpbnRDb2xvciksdGhpcy5zZXRWZXJ0ZXhBdHRyKFwibm9ybWFsXCIsMyx0LmJ1ZmZlci5ub3JtYWwpLHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHQuYnVmZmVyLmluZGV4KSx0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUyx0LmJ1ZmZlci5sZW5ndGgsdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwwKSl9KSl9KSl9KSl9ZHJhd0NvbG9yZWRTdHJ1Y3R1cmUodCl7dGhpcy5zZXRTaGFkZXIodGhpcy5jb2xvclNoYWRlclByb2dyYW0pLHRoaXMuc2V0VW5pZm9ybShcIm1WaWV3XCIsdCksdGhpcy5zZXRVbmlmb3JtKFwibVByb2pcIix0aGlzLnByb2pNYXRyaXgpLHRoaXMuY2h1bmtzLmZvckVhY2goKHQ9Pnt0LmZvckVhY2goKHQ9Pnt0LmZvckVhY2goKHQ9Pnt0LmJ1ZmZlciYmKHRoaXMuc2V0VmVydGV4QXR0cihcInZlcnRQb3NcIiwzLHQuYnVmZmVyLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJibG9ja1Bvc1wiLDMsdC5idWZmZXIuYmxvY2tQb3MpLHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHQuYnVmZmVyLmluZGV4KSx0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUyx0LmJ1ZmZlci5sZW5ndGgsdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwwKSl9KSl9KSl9KSl9ZHJhd091dGxpbmUodCxlKXt0aGlzLnNldFNoYWRlcih0aGlzLmdyaWRTaGFkZXJQcm9ncmFtKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0UG9zXCIsMyx0aGlzLm91dGxpbmVCdWZmZXJzLnBvc2l0aW9uKSx0aGlzLnNldFZlcnRleEF0dHIoXCJ2ZXJ0Q29sb3JcIiwzLHRoaXMub3V0bGluZUJ1ZmZlcnMuY29sb3IpO2NvbnN0IGk9cy5jcmVhdGUoKTtzLmNvcHkoaSx0KSxzLnRyYW5zbGF0ZShpLGksZSksdGhpcy5zZXRVbmlmb3JtKFwibVZpZXdcIixpKSx0aGlzLnNldFVuaWZvcm0oXCJtUHJvalwiLHRoaXMucHJvak1hdHJpeCksdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuTElORVMsMCx0aGlzLm91dGxpbmVCdWZmZXJzLmxlbmd0aCl9c2V0Vmlld3BvcnQodCxlLHMsaSl7dGhpcy5nbC52aWV3cG9ydCh0LGUscyxpKSx0aGlzLnByb2pNYXRyaXg9dGhpcy5nZXRQZXJzcGVjdGl2ZSgpfXNldFNoYWRlcih0KXt0aGlzLmdsLnVzZVByb2dyYW0odCksdGhpcy5hY3RpdmVTaGFkZXI9dH1zZXRWZXJ0ZXhBdHRyKHQsZSxzKXtjb25zdCBpPXRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5hY3RpdmVTaGFkZXIsdCk7dGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLHMpLHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLGUsdGhpcy5nbC5GTE9BVCwhMSwwLDApLHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSl9c2V0VW5pZm9ybSh0LGUpe2NvbnN0IHM9dGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5hY3RpdmVTaGFkZXIsdCk7dGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHMsITEsZSl9fVxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovZnVuY3Rpb24gUHQodCxlLHMsaSl7cmV0dXJuIG5ldyhzfHwocz1Qcm9taXNlKSkoKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gbyh0KXt0cnl7bChpLm5leHQodCkpfWNhdGNoKHQpe3IodCl9fWZ1bmN0aW9uIGEodCl7dHJ5e2woaS50aHJvdyh0KSl9Y2F0Y2godCl7cih0KX19ZnVuY3Rpb24gbCh0KXt2YXIgZTt0LmRvbmU/bih0LnZhbHVlKTooZT10LnZhbHVlLGUgaW5zdGFuY2VvZiBzP2U6bmV3IHMoKGZ1bmN0aW9uKHQpe3QoZSl9KSkpLnRoZW4obyxhKX1sKChpPWkuYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KSl9Y2xhc3MgeHR7Y29uc3RydWN0b3IodCxlKXt0aGlzLmltZz10LHRoaXMuaWRNYXA9ZSx0aGlzLnBhcnQ9MTYvdC53aWR0aH1nZXRUZXh0dXJlQXRsYXMoKXtyZXR1cm4gdGhpcy5pbWd9Z2V0VGV4dHVyZVVWKHQpe3ZhciBlO3JldHVybiBudWxsIT09KGU9dGhpcy5pZE1hcFt0XSkmJnZvaWQgMCE9PWU/ZTpbMCwwLHRoaXMucGFydCx0aGlzLnBhcnRdfXN0YXRpYyBmcm9tQmxvYnModCl7cmV0dXJuIFB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgZT1NYXRoLnNxcnQoT2JqZWN0LmtleXModCkubGVuZ3RoKzEpLHM9TWF0aC5wb3coMixNYXRoLmNlaWwoTWF0aC5sb2coZSkvTWF0aC5sb2coMikpKSxpPTE2KnMsbj0xL3Mscj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Iud2lkdGg9aSxyLmhlaWdodD1pO2NvbnN0IG89ci5nZXRDb250ZXh0KFwiMmRcIik7dGhpcy5kcmF3SW52YWxpZFRleHR1cmUobyk7Y29uc3QgYT17fTtsZXQgbD0xO3JldHVybiB5aWVsZCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0KS5tYXAoKGU9PlB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgaT1sJXMscj1NYXRoLmZsb29yKGwvcyk7bCs9MSxhW2VdPVtuKmksbipyLG4qaStuLG4qcituXTtjb25zdCBoPXlpZWxkIGNyZWF0ZUltYWdlQml0bWFwKHRbZV0pO28uZHJhd0ltYWdlKGgsMCwwLDE2LDE2LDE2KmksMTYqciwxNiwxNil9KSkpKSksbmV3IHh0KG8uZ2V0SW1hZ2VEYXRhKDAsMCxpLGkpLGEpfSkpfXN0YXRpYyBlbXB0eSgpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTt0LndpZHRoPTE2LHQuaGVpZ2h0PTE2O2NvbnN0IGU9dC5nZXRDb250ZXh0KFwiMmRcIik7cmV0dXJuIHh0LmRyYXdJbnZhbGlkVGV4dHVyZShlKSxuZXcgeHQoZS5nZXRJbWFnZURhdGEoMCwwLDE2LDE2KSx7fSl9c3RhdGljIGRyYXdJbnZhbGlkVGV4dHVyZSh0KXt0LmZpbGxTdHlsZT1cImJsYWNrXCIsdC5maWxsUmVjdCgwLDAsMTYsMTYpLHQuZmlsbFN0eWxlPVwibWFnZW50YVwiLHQuZmlsbFJlY3QoMCwwLDgsOCksdC5maWxsUmVjdCg4LDgsOCw4KX19dmFyIHl0LEF0LFN0LEJ0LEV0LEN0LEl0LGt0OyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/bmV3IHModCxudWxsIT1lP2U6dCk6dH10LnRhcmdldD1mdW5jdGlvbih0LGUscyxpLHIsbyl7cmV0dXJuIG5ldyBuKHQsZSxzLGkscixvKX0sdC5wYXJhbWV0ZXJzPWZ1bmN0aW9uKHQscyxuLHIsbyxhLGwpe3JldHVybiBuZXcgaShlKHQpLGUocyksZShuKSxlKHIpLGUobyksZShhKSxsKX0sdC5wYXJhbT1lO2NsYXNzIHN7Y29uc3RydWN0b3IodCxlKXt0aGlzLm1pbj10LHRoaXMubWF4PWV9ZGlzdGFuY2UodCl7Y29uc3QgZT0oXCJudW1iZXJcIj09dHlwZW9mIHQ/dDp0Lm1pbiktdGhpcy5tYXgscz10aGlzLm1pbi0oXCJudW1iZXJcIj09dHlwZW9mIHQ/dDp0Lm1heCk7cmV0dXJuIGU+MD9lOk1hdGgubWF4KHMsMCl9dW5pb24odCl7cmV0dXJuIG5ldyBzKE1hdGgubWluKHRoaXMubWluLHQubWluKSxNYXRoLm1heCh0aGlzLm1heCx0Lm1heCkpfXN0YXRpYyBmcm9tSnNvbih0KXt2YXIgZTtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gbmV3IHModCx0KTtjb25zdFtpLG5dPW51bGwhPT0oZT1rLnJlYWRBcnJheSh0LCh0PT5rLnJlYWROdW1iZXIodCkpKSkmJnZvaWQgMCE9PWU/ZTpbXTtyZXR1cm4gbmV3IHMobnVsbCE9aT9pOjAsbnVsbCE9bj9uOjApfX10LlBhcmFtPXM7Y2xhc3MgaXtjb25zdHJ1Y3Rvcih0LGUscyxpLG4scixvKXt0aGlzLnRlbXBlcmF0dXJlPXQsdGhpcy5odW1pZGl0eT1lLHRoaXMuY29udGluZW50YWxuZXNzPXMsdGhpcy5lcm9zaW9uPWksdGhpcy5kZXB0aD1uLHRoaXMud2VpcmRuZXNzPXIsdGhpcy5vZmZzZXQ9b31maXR0bmVzcyh0KXtyZXR1cm4gRih0aGlzLnRlbXBlcmF0dXJlLmRpc3RhbmNlKHQudGVtcGVyYXR1cmUpKStGKHRoaXMuaHVtaWRpdHkuZGlzdGFuY2UodC5odW1pZGl0eSkpK0YodGhpcy5jb250aW5lbnRhbG5lc3MuZGlzdGFuY2UodC5jb250aW5lbnRhbG5lc3MpKStGKHRoaXMuZXJvc2lvbi5kaXN0YW5jZSh0LmVyb3Npb24pKStGKHRoaXMuZGVwdGguZGlzdGFuY2UodC5kZXB0aCkpK0YodGhpcy53ZWlyZG5lc3MuZGlzdGFuY2UodC53ZWlyZG5lc3MpKStGKHRoaXMub2Zmc2V0LXQub2Zmc2V0KX1zcGFjZSgpe3JldHVyblt0aGlzLnRlbXBlcmF0dXJlLHRoaXMuaHVtaWRpdHksdGhpcy5jb250aW5lbnRhbG5lc3MsdGhpcy5lcm9zaW9uLHRoaXMuZGVwdGgsdGhpcy53ZWlyZG5lc3MsbmV3IHModGhpcy5vZmZzZXQsdGhpcy5vZmZzZXQpXX1zdGF0aWMgZnJvbUpzb24odCl7dmFyIGUsbjtjb25zdCByPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJuIG5ldyBpKHMuZnJvbUpzb24oci50ZW1wZXJhdHVyZSkscy5mcm9tSnNvbihyLmh1bWlkaXR5KSxzLmZyb21Kc29uKHIuY29udGluZW50YWxuZXNzKSxzLmZyb21Kc29uKHIuZXJvc2lvbikscy5mcm9tSnNvbihyLmRlcHRoKSxzLmZyb21Kc29uKHIud2VpcmRuZXNzKSxudWxsIT09KG49ay5yZWFkSW50KHIub2Zmc2V0KSkmJnZvaWQgMCE9PW4/bjowKX19dC5QYXJhbVBvaW50PWk7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0LGUscyxpLG4scil7dGhpcy50ZW1wZXJhdHVyZT10LHRoaXMuaHVtaWRpdHk9ZSx0aGlzLmNvbnRpbmVudGFsbmVzcz1zLHRoaXMuZXJvc2lvbj1pLHRoaXMuZGVwdGg9bix0aGlzLndlaXJkbmVzcz1yfWdldCBvZmZzZXQoKXtyZXR1cm4gMH10b0FycmF5KCl7cmV0dXJuW3RoaXMudGVtcGVyYXR1cmUsdGhpcy5odW1pZGl0eSx0aGlzLmNvbnRpbmVudGFsbmVzcyx0aGlzLmVyb3Npb24sdGhpcy5kZXB0aCx0aGlzLndlaXJkbmVzcyx0aGlzLm9mZnNldF19fXQuVGFyZ2V0UG9pbnQ9bjt0LlBhcmFtZXRlcnM9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy50aGluZ3M9dCx0aGlzLmluZGV4PW5ldyByKHQpfWZpbmQodCl7cmV0dXJuIHRoaXMuaW5kZXguc2VhcmNoKHQsKCh0LGUpPT50LmRpc3RhbmNlKGUpKSl9fTtjbGFzcyBye2NvbnN0cnVjdG9yKHQpe3RoaXMucm9vdD1yLmJ1aWxkKHQubWFwKCgoW3QsZV0pPT5uZXcgbCh0LGUpKSkpfXN0YXRpYyBidWlsZCh0KXtpZigxPT09dC5sZW5ndGgpcmV0dXJuIHRbMF07aWYodC5sZW5ndGg8PXIuQ0hJTERSRU5fUEVSX05PREUpe2NvbnN0IGU9dC5tYXAoKHQ9PntsZXQgZT0wO2ZvcihsZXQgcz0wO3M8NztzKz0xKXtjb25zdCBpPXQuc3BhY2Vbc107ZSs9TWF0aC5hYnMoKGkubWluK2kubWF4KS8yKX1yZXR1cm57a2V5OmUsbm9kZTp0fX0pKS5zb3J0KCgodCxlKT0+dC5rZXktZS5rZXkpKS5tYXAoKCh7bm9kZTp0fSk9PnQpKTtyZXR1cm4gbmV3IGEoZSl9bGV0IGU9MS8wLHM9LTEsaT1bXTtmb3IobGV0IG49MDtuPDc7KytuKXtyLnNvcnQodCxuLCExKSxpPXIuYnVja2V0aXplKHQpO2xldCBvPTA7Zm9yKGNvbnN0IHQgb2YgaSlvKz1yLmFyZWEodC5zcGFjZSk7ZT5vJiYoZT1vLHM9bil9cmV0dXJuIHQ9ci5zb3J0KHQscywhMSksaT1yLmJ1Y2tldGl6ZSh0KSxpPXIuc29ydChpLHMsITApLG5ldyBhKGkubWFwKCh0PT5yLmJ1aWxkKHQuY2hpbGRyZW4pKSkpfXN0YXRpYyBzb3J0KHQsZSxzKXtyZXR1cm4gdC5tYXAoKHQ9Pntjb25zdCBpPXQuc3BhY2VbZV0sbj0oaS5taW4raS5tYXgpLzI7cmV0dXJue2tleTpzP01hdGguYWJzKG4pOm4sbm9kZTp0fX0pKS5zb3J0KCgodCxlKT0+dC5rZXktZS5rZXkpKS5tYXAoKCh7bm9kZTp0fSk9PnQpKX1zdGF0aWMgYnVja2V0aXplKHQpe2NvbnN0IGU9W107bGV0IHM9W107Y29uc3QgaT1NYXRoLnBvdygxMCxNYXRoLmZsb29yKE1hdGgubG9nKHQubGVuZ3RoLS4wMSkvTWF0aC5sb2coMTApKSk7Zm9yKGNvbnN0IG4gb2YgdClzLnB1c2gobikscy5sZW5ndGg8aXx8KGUucHVzaChuZXcgYShzKSkscz1bXSk7cmV0dXJuIDAhPT1zLmxlbmd0aCYmZS5wdXNoKG5ldyBhKHMpKSxlfXN0YXRpYyBhcmVhKHQpe2xldCBlPTA7Zm9yKGNvbnN0IHMgb2YgdCllKz1NYXRoLmFicyhzLm1heC1zLm1pbik7cmV0dXJuIGV9c2VhcmNoKHQsZSl7cmV0dXJuIHRoaXMucm9vdC5zZWFyY2godC50b0FycmF5KCksZSkudGhpbmcoKX19ci5DSElMRFJFTl9QRVJfTk9ERT0xMCx0LlJUcmVlPXI7Y2xhc3Mgb3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNwYWNlPXR9ZGlzdGFuY2UodCl7bGV0IGU9MDtmb3IobGV0IHM9MDtzPDc7cys9MSllKz1GKHRoaXMuc3BhY2Vbc10uZGlzdGFuY2UodFtzXSkpO3JldHVybiBlfX10LlJOb2RlPW87Y2xhc3MgYSBleHRlbmRzIG97Y29uc3RydWN0b3IodCl7c3VwZXIoYS5idWlsZFNwYWNlKHQpKSx0aGlzLmNoaWxkcmVuPXR9c3RhdGljIGJ1aWxkU3BhY2UodCl7bGV0IGU9Wy4uLkFycmF5KDcpXS5tYXAoKCgpPT5uZXcgcygxLzAsLTEvMCkpKTtmb3IoY29uc3QgcyBvZiB0KWU9Wy4uLkFycmF5KDcpXS5tYXAoKCh0LGkpPT5lW2ldLnVuaW9uKHMuc3BhY2VbaV0pKSk7cmV0dXJuIGV9c2VhcmNoKHQsZSl7bGV0IHM9MS8wLGk9bnVsbDtmb3IoY29uc3QgbiBvZiB0aGlzLmNoaWxkcmVuKXtjb25zdCByPWUobix0KTtpZihzPD1yKWNvbnRpbnVlO2NvbnN0IG89bi5zZWFyY2godCxlKSxhPW49PW8/cjplKG8sdCk7czw9YXx8KHM9YSxpPW8pfXJldHVybiBpfX10LlJTdWJUcmVlPWE7Y2xhc3MgbCBleHRlbmRzIG97Y29uc3RydWN0b3IodCxlKXtzdXBlcih0LnNwYWNlKCkpLHRoaXMudGhpbmc9ZX1zZWFyY2goKXtyZXR1cm4gdGhpc319dC5STGVhZj1sfSh5dHx8KHl0PXt9KSk7Y2xhc3MgUnR7Y29uc3RydWN0b3IodCl7dGhpcy5iaW9tZT10fWdldEJpb21lKCl7cmV0dXJuIHRoaXMuYmlvbWV9c3RhdGljIGZyb21Kc29uKHQpe3ZhciBlLHM7Y29uc3QgaT1udWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9LG49bnVsbCE9PShzPWsucmVhZFN0cmluZyhpLmJpb21lKSkmJnZvaWQgMCE9PXM/czpcIm1pbmVjcmFmdDp0aGVfdm9pZFwiO3JldHVybiBuZXcgUnQobil9fWNsYXNzIF90e2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyYW1ldGVycz10fWdldEJpb21lKHQsZSxzLGkpe2NvbnN0IG49aSh0LGUscyk7cmV0dXJuIHRoaXMucGFyYW1ldGVycy5maW5kKG4pfXN0YXRpYyBmcm9tSnNvbih0KXt2YXIgZSxzO2NvbnN0IGk9bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fSxuPShudWxsIT09KHM9ay5yZWFkQXJyYXkoaS5iaW9tZXMsKHQ9Pnt2YXIgZTtyZXR1cm4odD0+e3ZhciBlO3JldHVybntiaW9tZTpudWxsIT09KGU9ay5yZWFkU3RyaW5nKHQuYmlvbWUpKSYmdm9pZCAwIT09ZT9lOlwibWluZWNyYWZ0OnRoZV92b2lkXCIscGFyYW1ldGVyczp5dC5QYXJhbVBvaW50LmZyb21Kc29uKHQucGFyYW1ldGVycyl9fSkobnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fSl9KSkpJiZ2b2lkIDAhPT1zP3M6W10pLm1hcCgodD0+W3QucGFyYW1ldGVycywoKT0+dC5iaW9tZV0pKTtyZXR1cm4gbmV3IF90KG5ldyB5dC5QYXJhbWV0ZXJzKG4pKX19IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJuIGguYXBwbHkodCkrLjAxNX1mdW5jdGlvbiBzKHQpe3JldHVybiB1LmFwcGx5KHQpfWZ1bmN0aW9uIGkodCl7cmV0dXJuIGMuYXBwbHkodCl9ZnVuY3Rpb24gbih0KXtyZXR1cm4gMyotKE1hdGguYWJzKE1hdGguYWJzKHQpLS42NjY2NjY3KS0uMzMzMzMzMzQpfXQub2Zmc2V0PWUsdC5mYWN0b3I9cyx0LnBlYWtzPWksdC5wZWFrc0FuZFZhbGxleXM9bix0LnBvaW50PWZ1bmN0aW9uKHQsZSxzKXtyZXR1cm57Y29udGluZW50czp0LGVyb3Npb246ZSx3ZWlyZG5lc3M6cyxyaWRnZXM6bihzKX19LHQubmVhcldhdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0PC0uMikmJih0PC0uMDV8fE1hdGguYWJzKGUpPC4xNSl9LHQuc2hhcGU9ZnVuY3Rpb24odCxuKXtyZXR1cm57b2Zmc2V0OmUodCksZmFjdG9yOnModCkscGVha3M6aSh0KSxuZWFyV2F0ZXI6bn19O2NvbnN0IHI9ZihcImJlYWNoU3BsaW5lXCIsLS4xNSwtLjA1LDAsMCwuMSwwLC0uMDMsITEsITEpLG89ZihcImxvd1NwbGluZVwiLC0uMSwtLjEsLjAzLC4xLC4xLC4wMSwtLjAzLCExLCExKSxhPWYoXCJtaWRTcGxpbmVcIiwtLjEsLS4xLC4wMywuMSwuNywuMDEsLS4wMywhMCwhMCksbD1mKFwiaGlnaFNwbGluZVwiLC0uMDUsLjMsLjAzLC4xLDEsLjAxLC4wMSwhMCwhMCksaD1uZXcgWihcIm9mZnNldFNhbXBsZXJcIiwodD0+dC5jb250aW5lbnRzKSkuYWRkUG9pbnQoLTEuMSwuMDQ0KS5hZGRQb2ludCgtMS4wMiwtLjIyMjIpLmFkZFBvaW50KC0uNTEsLS4yMjIyKS5hZGRQb2ludCgtLjQ0LC0uMTIpLmFkZFBvaW50KC0uMTgsLS4xMikuYWRkUG9pbnQoLS4xNixyKS5hZGRQb2ludCgtLjE1LHIpLmFkZFBvaW50KC0uMSxvKS5hZGRQb2ludCguMjUsYSkuYWRkUG9pbnQoMSxsKSx1PW5ldyBaKFwiRmFjdG9yLUNvbnRpbmVudHNcIiwodD0+dC5jb250aW5lbnRzKSkuYWRkUG9pbnQoLS4xOSw1MDUpLmFkZFBvaW50KC0uMTUsZChcImVyb3Npb25Db2FzdFwiLDgwMCwhMCxcInJpZGdlQ29hc3QtT2xkTW91bnRhaW5zXCIpKS5hZGRQb2ludCgtLjEsZChcImVyb3Npb25JbmxhbmRcIiw3MDAsITAsXCJyaWRnZUlubGFuZC1PbGRNb3VudGFpbnNcIikpLmFkZFBvaW50KC4wMyxkKFwiZXJvc2lvbk1pZElubGFuZFwiLDY1MCwhMCxcInJpZGdlTWlkSW5sYW5kLU9sZE1vdW50YWluc1wiKSkuYWRkUG9pbnQoLjA2LGQoXCJlcm9zaW9uRmFySW5sYW5kXCIsNjAwLCExLFwicmlkZ2VGYXJJbmxhbmQtT2xkTW91bnRhaW5zXCIpKSxjPW5ldyBaKFwiUGVha3NcIiwodD0+dC5jb250aW5lbnRzKSkuYWRkUG9pbnQoLjEsMCkuYWRkUG9pbnQoLjIsbmV3IFooXCJQZWFrcy1lcm9zaW9uXCIsKHQ9PnQuZXJvc2lvbikpLmFkZFBvaW50KC0uOCxuZXcgWihcIlBlYWtzLWVyb3Npb24tcmlkZ2VzXCIsKHQ9PnQucmlkZ2VzKSkuYWRkUG9pbnQoLTEsMCkuYWRkUG9pbnQoLjIsMCkuYWRkUG9pbnQoMSxuZXcgWihcIlBlYWtzLWVyb3Npb24tcmlkZ2VzLXdlaXJkbmVzc1wiLCh0PT50LndlaXJkbmVzcykpLmFkZFBvaW50KC0uMDEsODApLmFkZFBvaW50KC4wMSwyMCkpKS5hZGRQb2ludCgtLjQsMCkpO2Z1bmN0aW9uIGQodCxlLHMsaSl7Y29uc3Qgbj1uZXcgWih0LCh0PT50LmVyb3Npb24pKS5hZGRQb2ludCgtLjYsZSkuYWRkUG9pbnQoLS41LDM0MikuYWRkUG9pbnQoLS4zNSxlKS5hZGRQb2ludCgtLjI1LGUpLmFkZFBvaW50KC0uMSwzNDIpLmFkZFBvaW50KC4wMyxlKTtpZihzKXtjb25zdCB0PW5ldyBaKFwid2VpcmRuZXNzU2hhdHRlcmVkXCIsKHQ9PnQud2VpcmRuZXNzKSkuYWRkUG9pbnQoMCxlKS5hZGRQb2ludCguMSw4MCkscz1uZXcgWihcInJpZGdlc1NoYXR0ZXJlZFwiLCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC0uOSxlKS5hZGRQb2ludCgtLjY5LHQpO24uYWRkUG9pbnQoLjM1LGUpLmFkZFBvaW50KC40NSxzKS5hZGRQb2ludCguNTUscykuYWRkUG9pbnQoLjYyLGUpfWVsc2V7Y29uc3QgdD1uZXcgWihpLCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC0uNyxlKS5hZGRQb2ludCgtLjE1LDE3NSkscz1uZXcgWihpLCh0PT50LnJpZGdlcykpLmFkZFBvaW50KC40NSxlKS5hZGRQb2ludCguNywyMDApO24uYWRkUG9pbnQoLjA1LHMpLmFkZFBvaW50KC40LHMpLmFkZFBvaW50KC40NSx0KS5hZGRQb2ludCguNTUsdCkuYWRkUG9pbnQoLjU4LGUpfXJldHVybiBufWZ1bmN0aW9uIGYodCxlLHMsaSxuLHIsbyxhLGwsaCl7Y29uc3QgdT1nKE4ociwuNiwxLjUpLGgpLGM9ZyhOKHIsLjYsMSksaCksZD1nKHIsaCksZj12KHQrXCItd2lkZVBsYXRlYXVcIixlLS4xNSwuNSpyLE4oLjUsLjUsLjUpKnIsLjUqciwuNipyLC41KSxwPXYodCtcIi1uYXJyb3dQbGF0ZWF1XCIsZSxvKnIsaSpyLC41KnIsLjYqciwuNSksbT12KHQrXCItcGxhaW5zXCIsZSxvLG8saSxuLC41KSxiPXYodCtcIi1wbGFpbnNGYXJJbmxhbmRcIixlLG8sbyxpLG4sLjUpLHc9bmV3IFoodCwodD0+dC5yaWRnZXMpKS5hZGRQb2ludCgtMSxlKS5hZGRQb2ludCgtLjQsbSkuYWRkUG9pbnQoMCxuKy4wNyksUD12KHQrXCItc3dhbXBzXCIsLS4wMixhLGEsaSxuLDApLHg9bmV3IFoodCwodD0+dC5lcm9zaW9uKSkuYWRkUG9pbnQoLS44NSx1KS5hZGRQb2ludCgtLjcsYykuYWRkUG9pbnQoLS40LGQpLmFkZFBvaW50KC0uMzUsZikuYWRkUG9pbnQoLS4xLHApLmFkZFBvaW50KC4yLG0pO3JldHVybiBsJiZ4LmFkZFBvaW50KC40LGIpLmFkZFBvaW50KC40NSx3KS5hZGRQb2ludCguNTUsdykuYWRkUG9pbnQoLjU4LGIpLHguYWRkUG9pbnQoLjcsUCkseH1mdW5jdGlvbiBnKHQsZSl7Y29uc3Qgcz1uZXcgWihgTS1zcGxpbmUgZm9yIGNvbnRpbmVudGFsbmVzczogJHt0fSAke2V9YCwodD0+dC5yaWRnZXMpKSxpPXAoLTEsdCwtLjcpLG49cCgxLHQsLS43KSxyPWZ1bmN0aW9uKHQpe3JldHVybi41KigxLXQpLyguNDYwODI5NDcqKDEtLjUqKDEtdCkpKS0xLjE3fSh0KTtpZigtLjY1PHImJnI8MSl7Y29uc3QgZT1wKC0uNjUsdCwtLjcpLG89cCgtLjc1LHQsLS43KSxhPW0oaSxvLC0xLC0uNzUpO3MuYWRkUG9pbnQoLTEsaSxhKSxzLmFkZFBvaW50KC0uNzUsbykscy5hZGRQb2ludCgtLjY1LGUpO2NvbnN0IGw9cChyLHQsLS43KSxoPW0obCxuLHIsMSk7cy5hZGRQb2ludChyLS4wMSxsKSxzLmFkZFBvaW50KHIsbCxoKSxzLmFkZFBvaW50KDEsbixoKX1lbHNle2NvbnN0IHQ9bShpLG4sLTEsMSk7ZT8ocy5hZGRQb2ludCgtMSxNYXRoLm1heCguMixpKSkscy5hZGRQb2ludCgwLE4oLjUsaSxuKSx0KSk6cy5hZGRQb2ludCgtMSxpLHQpLHMuYWRkUG9pbnQoMSxuLHQpfXJldHVybiBzfWZ1bmN0aW9uIHAodCxlLHMpe2NvbnN0IGk9LjQ2MDgyOTQ3Kih0KzEuMTcpKigxLS41KigxLWUpKS0uNSooMS1lKTtyZXR1cm4gdDxzP01hdGgubWF4KGksLS4yMjIyKTpNYXRoLm1heChpLDApfWZ1bmN0aW9uIG0odCxlLHMsaSl7cmV0dXJuKGUtdCkvKGktcyl9ZnVuY3Rpb24gdih0LGUscyxpLG4scixvKXtjb25zdCBhPU1hdGgubWF4KC41KihzLWUpLG8pLGw9NSooaS1zKTtyZXR1cm4gbmV3IFoodCwodD0+dC5yaWRnZXMpKS5hZGRQb2ludCgtMSxlLGEpLmFkZFBvaW50KC0uNCxzLE1hdGgubWluKGEsbCkpLmFkZFBvaW50KDAsaSxsKS5hZGRQb2ludCguNCxuLDIqKG4taSkpLmFkZFBvaW50KDEsciwuNyooci1uKSl9fShBdHx8KEF0PXt9KSk7Y2xhc3MgRnR7Y29uc3RydWN0b3IodCxlLHMsaSxuLHIpe3RoaXMuY2VsbENvdW50WT1lLHRoaXMuY2VsbENvdW50Wj1zLHRoaXMuY2VsbE1pblk9bix0aGlzLmZpbGxlcj1yLHRoaXMubm9pc2UwMDA9MCx0aGlzLm5vaXNlMDAxPTAsdGhpcy5ub2lzZTEwMD0wLHRoaXMubm9pc2UxMDE9MCx0aGlzLm5vaXNlMDEwPTAsdGhpcy5ub2lzZTAxMT0wLHRoaXMubm9pc2UxMTA9MCx0aGlzLm5vaXNlMTExPTAsdGhpcy52YWx1ZVhaMDA9MCx0aGlzLnZhbHVlWFoxMD0wLHRoaXMudmFsdWVYWjAxPTAsdGhpcy52YWx1ZVhaMTE9MCx0aGlzLnZhbHVlWjA9MCx0aGlzLnZhbHVlWjE9MCx0aGlzLm1pbkNlbGxYPWlbMF0qdCx0aGlzLm1pbkNlbGxaPWlbMV0qcyx0aGlzLnNsaWNlMD1GdC5hbGxvY2F0ZVNsaWNlKGUscyksdGhpcy5zbGljZTE9RnQuYWxsb2NhdGVTbGljZShlLHMpfXN0YXRpYyBhbGxvY2F0ZVNsaWNlKHQsZSl7Y29uc3Qgcz1BcnJheShlKzEpO2ZvcihsZXQgaT0wO2k8ZSsxO2krPTEpc1tpXT1BcnJheSh0KzEpO3JldHVybiBzfWluaXRpYWxpemVGb3JGaXJzdENlbGxYKCl7dGhpcy5maWxsU2xpY2UodGhpcy5zbGljZTAsdGhpcy5taW5DZWxsWCl9YWR2YW5jZUNlbGxYKHQpe3RoaXMuZmlsbFNsaWNlKHRoaXMuc2xpY2UxLHRoaXMubWluQ2VsbFgrdCsxKX1maWxsU2xpY2UodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMuY2VsbENvdW50WisxO3MrPTEpdGhpcy5maWxsZXIodFtzXSxlLHRoaXMubWluQ2VsbForcyx0aGlzLmNlbGxNaW5ZLHRoaXMuY2VsbENvdW50WSl9c2VsZWN0Q2VsbFlaKHQsZSl7dGhpcy5ub2lzZTAwMD10aGlzLnNsaWNlMFtlXVt0XSx0aGlzLm5vaXNlMDAxPXRoaXMuc2xpY2UwW2UrMV1bdF0sdGhpcy5ub2lzZTEwMD10aGlzLnNsaWNlMVtlXVt0XSx0aGlzLm5vaXNlMTAxPXRoaXMuc2xpY2UxW2UrMV1bdF0sdGhpcy5ub2lzZTAxMD10aGlzLnNsaWNlMFtlXVt0KzFdLHRoaXMubm9pc2UwMTE9dGhpcy5zbGljZTBbZSsxXVt0KzFdLHRoaXMubm9pc2UxMTA9dGhpcy5zbGljZTFbZV1bdCsxXSx0aGlzLm5vaXNlMTExPXRoaXMuc2xpY2UxW2UrMV1bdCsxXX11cGRhdGVGb3JZKHQpe3RoaXMudmFsdWVYWjAwPU4odCx0aGlzLm5vaXNlMDAwLHRoaXMubm9pc2UwMTApLHRoaXMudmFsdWVYWjEwPU4odCx0aGlzLm5vaXNlMTAwLHRoaXMubm9pc2UxMTApLHRoaXMudmFsdWVYWjAxPU4odCx0aGlzLm5vaXNlMDAxLHRoaXMubm9pc2UwMTEpLHRoaXMudmFsdWVYWjExPU4odCx0aGlzLm5vaXNlMTAxLHRoaXMubm9pc2UxMTEpfXVwZGF0ZUZvclgodCl7dGhpcy52YWx1ZVowPU4odCx0aGlzLnZhbHVlWFowMCx0aGlzLnZhbHVlWFoxMCksdGhpcy52YWx1ZVoxPU4odCx0aGlzLnZhbHVlWFowMSx0aGlzLnZhbHVlWFoxMSl9Y2FsY3VsYXRlVmFsdWUodCl7cmV0dXJuIE4odCx0aGlzLnZhbHVlWjAsdGhpcy52YWx1ZVoxKX1zd2FwU2xpY2VzKCl7W3RoaXMuc2xpY2UwLHRoaXMuc2xpY2UxXT1bdGhpcy5zbGljZTEsdGhpcy5zbGljZTBdfX1jbGFzcyBNdHtjb25zdHJ1Y3Rvcih0LGUscyxpLG4scixvLGEpe3RoaXMuY2VsbFdpZHRoPXQsdGhpcy5jZWxsSGVpZ2h0PWUsdGhpcy5jZWxsQ291bnRZPXMsdGhpcy5iaW9tZVNvdXJjZT1pLHRoaXMuc2V0dGluZ3M9bix0aGlzLnNoYXBlT3ZlcnJpZGU9YTtjb25zdCBsPW5ldyBXKG8pLGg9bi51c2VMZWdhY3lSYW5kb20/bmV3IFcobyk6bC5mb3JrKCk7dGhpcy5ibGVuZGVkTm9pc2U9bmV3IFkoaCksbC5jb25zdW1lKDgpLHRoaXMudGVtcGVyYXR1cmVOb2lzZT1uZXcgWChuZXcgSihvKSxyLnRlbXBlcmF0dXJlKSx0aGlzLmh1bWlkaXR5Tm9pc2U9bmV3IFgobmV3IEoobytCaWdJbnQoMSkpLHIuaHVtaWRpdHkpLHRoaXMuY29udGluZW50YWxuZXNzTm9pc2U9bmV3IFgobmV3IEoobytCaWdJbnQoMikpLHIuY29udGluZW50YWxuZXNzKSx0aGlzLmVyb3Npb25Ob2lzZT1uZXcgWChuZXcgSihvK0JpZ0ludCgzKSksci5lcm9zaW9uKSx0aGlzLndlaXJkbmVzc05vaXNlPW5ldyBYKG5ldyBKKG8rQmlnSW50KDQpKSxyLndlaXJkbmVzcyksdGhpcy5vZmZzZXROb2lzZT1uZXcgWChuZXcgSihvK0JpZ0ludCg1KSksci5zaGlmdCksdGhpcy5tb3VudGFpblBlYWtOb2lzZT1uZXcgWChsLmZvcmsoKSx7Zmlyc3RPY3RhdmU6LTE2LGFtcGxpdHVkZXM6WzEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdfSl9Z2V0Q2xpbWF0ZSh0LGUscyl7Y29uc3QgaT10K3RoaXMuZ2V0T2Zmc2V0KHQsMCxzKSxuPWUrdGhpcy5nZXRPZmZzZXQoZSxzLHQpLHI9cyt0aGlzLmdldE9mZnNldChzLHQsMCksbz10aGlzLnRlbXBlcmF0dXJlTm9pc2Uuc2FtcGxlKGksbixyKSxhPXRoaXMuaHVtaWRpdHlOb2lzZS5zYW1wbGUoaSxuLHIpLGw9dGhpcy5jb250aW5lbnRhbG5lc3NOb2lzZS5zYW1wbGUoaSwwLHIpLGg9dGhpcy5lcm9zaW9uTm9pc2Uuc2FtcGxlKGksMCxyKSx1PXRoaXMud2VpcmRuZXNzTm9pc2Uuc2FtcGxlKGksMCxyKSxjPUF0Lm9mZnNldChBdC5wb2ludChsLGgsdSkpLGQ9TXQuY29tcHV0ZURpbWVuc2lvbkRlbnNpdHkoMSwtLjUxODc1LDQqZSkrYztyZXR1cm4gbmV3IHl0LlRhcmdldFBvaW50KG8sYSxsLGgsZCx1KX1nZXRUZXJyYWluU2hhcGUodCxlKXtpZih0aGlzLnNoYXBlT3ZlcnJpZGUpcmV0dXJuIHRoaXMuc2hhcGVPdmVycmlkZTtjb25zdCBzPXQrdGhpcy5nZXRPZmZzZXQodCwwLGUpLGk9ZSt0aGlzLmdldE9mZnNldChlLHQsMCksbj10aGlzLmNvbnRpbmVudGFsbmVzc05vaXNlLnNhbXBsZShzLDAsaSkscj10aGlzLmVyb3Npb25Ob2lzZS5zYW1wbGUocywwLGkpLG89dGhpcy53ZWlyZG5lc3NOb2lzZS5zYW1wbGUocywwLGkpLGE9QXQucG9pbnQobixyLG8pLGw9QXQubmVhcldhdGVyKG4sbyk7cmV0dXJuIEF0LnNoYXBlKGEsbCl9Z2V0T2Zmc2V0KHQsZSxzKXtyZXR1cm4gNCp0aGlzLm9mZnNldE5vaXNlLnNhbXBsZSh0LGUscyl9ZmlsbE5vaXNlQ29sdW1uKHQsZSxzLGksbil7Y29uc3Qgcj1lKnRoaXMuY2VsbFdpZHRoPj4yLG89cyp0aGlzLmNlbGxXaWR0aD4+Mix7b2Zmc2V0OmEsZmFjdG9yOmwscGVha3M6aH09dGhpcy5nZXRUZXJyYWluU2hhcGUocixvKSx1PTY4NC40MTIqdGhpcy5zZXR0aW5ncy5zYW1wbGluZy54elNjYWxlLGM9Njg0LjQxMip0aGlzLnNldHRpbmdzLnNhbXBsaW5nLnlTY2FsZSxkPXUvdGhpcy5zZXR0aW5ncy5zYW1wbGluZy54ekZhY3RvcixmPWMvdGhpcy5zZXR0aW5ncy5zYW1wbGluZy55RmFjdG9yO2ZvcihsZXQgcj0wO3I8PW47cis9MSl7Y29uc3Qgbj1yK2ksbz10aGlzLmJsZW5kZWROb2lzZS5zYW1wbGUoZSxuLHMsdSxjLGQsZiksZz10aGlzLnNhbXBsZVBlYWtOb2lzZShoLGUqdGhpcy5jZWxsSGVpZ2h0LHMqdGhpcy5jZWxsSGVpZ2h0KS8xMjgscD10aGlzLmNvbXB1dGVJbml0aWFsRGVuc2l0eShuKnRoaXMuY2VsbEhlaWdodCxhLGwsMCxnKStvO3Rbcl09dGhpcy5hcHBseVNsaWRlKHAsbil9fXNhbXBsZVBlYWtOb2lzZSh0LGUscyl7aWYoMD09PXQpcmV0dXJuIDA7Y29uc3QgaT0zZTMvdGhpcy5jZWxsV2lkdGgsbj10aGlzLm1vdW50YWluUGVha05vaXNlLnNhbXBsZShlKmksMCxzKmkpO3JldHVybiBuPjA/dCpuOnQvMipufWNvbXB1dGVJbml0aWFsRGVuc2l0eSh0LGUscyxpLG4pe2NvbnN0IHI9KE10LmNvbXB1dGVEaW1lbnNpb25EZW5zaXR5KHRoaXMuc2V0dGluZ3MuZGVuc2l0eUZhY3Rvcix0aGlzLnNldHRpbmdzLmRlbnNpdHlPZmZzZXQsdCxpKStlK24pKnM7cmV0dXJuIHIqKHI+MD80OjEpfWFwcGx5U2xpZGUodCxlKXtjb25zdCBzPWUtTWF0aC5mbG9vcih0aGlzLnNldHRpbmdzLm1pblkvdGhpcy5jZWxsSGVpZ2h0KTtpZih0aGlzLnNldHRpbmdzLnRvcFNsaWRlLnNpemU+MCl7Y29uc3QgZT0odGhpcy5jZWxsQ291bnRZLXMtdGhpcy5zZXR0aW5ncy50b3BTbGlkZS5vZmZzZXQpL3RoaXMuc2V0dGluZ3MudG9wU2xpZGUuc2l6ZTt0PVUodGhpcy5zZXR0aW5ncy50b3BTbGlkZS50YXJnZXQsdCxlKX1pZih0aGlzLnNldHRpbmdzLmJvdHRvbVNsaWRlLnNpemU+MCl7Y29uc3QgZT0ocy10aGlzLnNldHRpbmdzLmJvdHRvbVNsaWRlLm9mZnNldCkvdGhpcy5zZXR0aW5ncy5ib3R0b21TbGlkZS5zaXplO3Q9VSh0aGlzLnNldHRpbmdzLmJvdHRvbVNsaWRlLnRhcmdldCx0LGUpfXJldHVybiB0fXN0YXRpYyBjb21wdXRlRGltZW5zaW9uRGVuc2l0eSh0LGUscyxpPTApe3JldHVybiB0KigxLXMvMTI4K2kpK2V9fWNsYXNzIE50e2NvbnN0cnVjdG9yKHQsZSxzLGkpe3RoaXMuc2VlZD10LHRoaXMuYmlvbWVTb3VyY2U9ZSx0aGlzLnNldHRpbmdzPXMsdGhpcy5jZWxsSGVpZ2h0PXMubm9pc2UueVNpemU8PDIsdGhpcy5jZWxsV2lkdGg9cy5ub2lzZS54elNpemU8PDIsdGhpcy5jZWxsQ291bnRYWj1NYXRoLmZsb29yKDE2L3RoaXMuY2VsbFdpZHRoKSx0aGlzLmNlbGxDb3VudFk9TWF0aC5mbG9vcihzLm5vaXNlLmhlaWdodC90aGlzLmNlbGxIZWlnaHQpLHRoaXMuc2FtcGxlcj1uZXcgTXQodGhpcy5jZWxsV2lkdGgsdGhpcy5jZWxsSGVpZ2h0LHRoaXMuY2VsbENvdW50WSxlLHMubm9pc2Uscy5vY3RhdmVzLHQsaSl9ZmlsbCh0KXtjb25zdCBlPU1hdGgubWF4KHQubWluWSx0aGlzLnNldHRpbmdzLm5vaXNlLm1pblkpLHM9TWF0aC5taW4odC5tYXhZLHRoaXMuc2V0dGluZ3Mubm9pc2UubWluWSt0aGlzLnNldHRpbmdzLm5vaXNlLmhlaWdodCksaT1NYXRoLmZsb29yKGUvdGhpcy5jZWxsSGVpZ2h0KSxuPU1hdGguZmxvb3IoKHMtZSkvdGhpcy5jZWxsSGVpZ2h0KSxyPUkubWluQmxvY2tYKHQucG9zKSxvPUkubWluQmxvY2taKHQucG9zKSxhPW5ldyBGdCh0aGlzLmNlbGxDb3VudFhaLG4sdGhpcy5jZWxsQ291bnRYWix0LnBvcyxpLHRoaXMuc2FtcGxlci5maWxsTm9pc2VDb2x1bW4uYmluZCh0aGlzLnNhbXBsZXIpKSxsPUFycmF5KGEpO2wuZm9yRWFjaCgodD0+dC5pbml0aWFsaXplRm9yRmlyc3RDZWxsWCgpKSk7Zm9yKGxldCBlPTA7ZTx0aGlzLmNlbGxDb3VudFhaO2UrPTEpe2wuZm9yRWFjaCgodD0+dC5hZHZhbmNlQ2VsbFgoZSkpKTtmb3IobGV0IHM9MDtzPHRoaXMuY2VsbENvdW50WFo7cys9MSl7bGV0IGg9dC5nZXRPckNyZWF0ZVNlY3Rpb24odC5zZWN0aW9uc0NvdW50LTEpO2ZvcihsZXQgdT1uLTE7dT49MDt1LT0xKXtsLmZvckVhY2goKHQ9PnQuc2VsZWN0Q2VsbFlaKHUscykpKTtmb3IobGV0IG49dGhpcy5jZWxsSGVpZ2h0LTE7bj49MDtuLT0xKXtjb25zdCBjPShpK3UpKnRoaXMuY2VsbEhlaWdodCtuLGQ9MTUmYyxmPXQuZ2V0U2VjdGlvbkluZGV4KGMpO3QuZ2V0U2VjdGlvbkluZGV4KGgubWluQmxvY2tZKSE9PWYmJihoPXQuZ2V0T3JDcmVhdGVTZWN0aW9uKGYpKTtjb25zdCBnPW4vdGhpcy5jZWxsSGVpZ2h0O2wuZm9yRWFjaCgodD0+dC51cGRhdGVGb3JZKGcpKSk7Zm9yKGxldCB0PTA7dDx0aGlzLmNlbGxXaWR0aDt0Kz0xKXtjb25zdCBpPXIrZSp0aGlzLmNlbGxXaWR0aCt0LG49MTUmaSx1PXQvdGhpcy5jZWxsV2lkdGg7bC5mb3JFYWNoKCh0PT50LnVwZGF0ZUZvclgodSkpKTtmb3IobGV0IHQ9MDt0PHRoaXMuY2VsbFdpZHRoO3QrPTEpe2NvbnN0IGU9bytzKnRoaXMuY2VsbFdpZHRoK3Qscj0xNSZlLGw9dC90aGlzLmNlbGxXaWR0aCx1PWEuY2FsY3VsYXRlVmFsdWUobCksZj10aGlzLmJhc2VTdGF0ZShpLGMsZSx1KTtmLmVxdWFscyhCLkFJUil8fGguc2V0QmxvY2tTdGF0ZShuLGQscixmKX19fX19bC5mb3JFYWNoKCh0PT50LnN3YXBTbGljZXMoKSkpfX1iYXNlU3RhdGUodCxlLHMsaSl7cmV0dXJuKGk9KGk9TShpLzIwMCwtMSwxKSkvMi1pKmkqaS8yNCk+MD90aGlzLnNldHRpbmdzLmRlZmF1bHRCbG9jazplPHRoaXMuc2V0dGluZ3Muc2VhTGV2ZWw/dGhpcy5zZXR0aW5ncy5kZWZhdWx0Rmx1aWQ6Qi5BSVJ9fSFmdW5jdGlvbih0KXt0LmZyb21Kc29uPWZ1bmN0aW9uKHQpe3ZhciBlLHMsaSxuLHIsbyxhLGwsaCx1LGMsZDtjb25zdCBmPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJue21pblk6bnVsbCE9PShzPWsucmVhZEludChmLm1pbl95KSkmJnZvaWQgMCE9PXM/czowLGhlaWdodDpudWxsIT09KGk9ay5yZWFkSW50KGYuaGVpZ2h0KSkmJnZvaWQgMCE9PWk/aToyNTYseHpTaXplOm51bGwhPT0obj1rLnJlYWRJbnQoZi5zaXplX2hvcml6b250YWwpKSYmdm9pZCAwIT09bj9uOjEseVNpemU6bnVsbCE9PShyPWsucmVhZEludChmLnNpemVfdmVydGljYWwpKSYmdm9pZCAwIT09cj9yOjEsZGVuc2l0eUZhY3RvcjpudWxsIT09KG89ay5yZWFkTnVtYmVyKGYuZGVuc2l0eV9mYWN0b3IpKSYmdm9pZCAwIT09bz9vOjAsZGVuc2l0eU9mZnNldDpudWxsIT09KGE9ay5yZWFkTnVtYmVyKGYuZGVuc2l0eV9vZmZzZXQpKSYmdm9pZCAwIT09YT9hOjAsc2FtcGxpbmc6QnQuZnJvbUpzb24oZi5zYW1wbGluZyksdG9wU2xpZGU6RXQuZnJvbUpzb24oZi50b3Bfc2xpZGUpLGJvdHRvbVNsaWRlOkV0LmZyb21Kc29uKGYuYm90dG9tX3NsaWRlKSx1c2VTaW1wbGV4U3VyZmFjZU5vaXNlOm51bGwhPT0obD1rLnJlYWRCb29sZWFuKGYuc2ltcGxleF9zdXJmYWNlX25vaXNlKSkmJnZvaWQgMCE9PWwmJmwscmFuZG9tRGVuc2l0eU9mZnNldDpudWxsIT09KGg9ay5yZWFkQm9vbGVhbihmLnJhbmRvbV9kZW5zaXR5X29mZnNldCkpJiZ2b2lkIDAhPT1oJiZoLGlzbGFuZE5vaXNlT3ZlcnJpZGU6bnVsbCE9PSh1PWsucmVhZEJvb2xlYW4oZi5pc2xhbmRfbm9pc2Vfb3ZlcnJpZGUpKSYmdm9pZCAwIT09dSYmdSxpc0FtcGxpZmllZDpudWxsIT09KGM9ay5yZWFkQm9vbGVhbihmLmFtcGxpZmllZCkpJiZ2b2lkIDAhPT1jJiZjLHVzZUxlZ2FjeVJhbmRvbTpudWxsIT09KGQ9ay5yZWFkQm9vbGVhbihmLnVzZV9sZWdhY3lfcmFuZG9tKSkmJnZvaWQgMCE9PWQmJmR9fX0oU3R8fChTdD17fSkpLGZ1bmN0aW9uKHQpe3QuZnJvbUpzb249ZnVuY3Rpb24odCl7dmFyIGUscyxpLG4scjtjb25zdCBvPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJue3h6U2NhbGU6bnVsbCE9PShzPWsucmVhZE51bWJlcihvLnh6X3NjYWxlKSkmJnZvaWQgMCE9PXM/czoxLHlTY2FsZTpudWxsIT09KGk9ay5yZWFkTnVtYmVyKG8ueV9zY2FsZSkpJiZ2b2lkIDAhPT1pP2k6MSx4ekZhY3RvcjpudWxsIT09KG49ay5yZWFkTnVtYmVyKG8ueHpfZmFjdG9yKSkmJnZvaWQgMCE9PW4/bjo4MCx5RmFjdG9yOm51bGwhPT0ocj1rLnJlYWROdW1iZXIoby55X2ZhY3RvcikpJiZ2b2lkIDAhPT1yP3I6ODB9fX0oQnR8fChCdD17fSkpLGZ1bmN0aW9uKHQpe3QuZnJvbUpzb249ZnVuY3Rpb24odCl7dmFyIGUscyxpLG47Y29uc3Qgcj1udWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9O3JldHVybnt0YXJnZXQ6bnVsbCE9PShzPWsucmVhZE51bWJlcihyLnRhcmdldCkpJiZ2b2lkIDAhPT1zP3M6MCxzaXplOm51bGwhPT0oaT1rLnJlYWRJbnQoci5zaXplKSkmJnZvaWQgMCE9PWk/aTowLG9mZnNldDpudWxsIT09KG49ay5yZWFkSW50KHIub2Zmc2V0KSkmJnZvaWQgMCE9PW4/bjowfX19KEV0fHwoRXQ9e30pKSxmdW5jdGlvbih0KXt0LmZyb21Kc29uPWZ1bmN0aW9uKHQpe3ZhciBlLHMsaSxuLHIsbyxhLGwsaCx1O2NvbnN0IGM9bnVsbCE9PShlPWsucmVhZE9iamVjdCh0KSkmJnZvaWQgMCE9PWU/ZTp7fTtyZXR1cm57c3RydWN0dXJlczpJdC5mcm9tSnNvbihjLnN0cnVjdHVyZXMpLG5vaXNlOlN0LmZyb21Kc29uKGMubm9pc2UpLG9jdGF2ZXM6a3QuZnJvbUpzb24oYy5vY3RhdmVzKSxkZWZhdWx0QmxvY2s6Qi5mcm9tSnNvbihjLmRlZmF1bHRfYmxvY2spLGRlZmF1bHRGbHVpZDpCLmZyb21Kc29uKGMuZGVmYXVsdF9mbHVpZCksYmVkcm9ja1Jvb2ZQb3NpdGlvbjpudWxsIT09KHM9ay5yZWFkSW50KGMuYmVkcm9ja19yb29mX3Bvc2l0aW9uKSkmJnZvaWQgMCE9PXM/czowLGJlZHJvY2tGbG9vclBvc2l0aW9uOm51bGwhPT0oaT1rLnJlYWRJbnQoYy5iZWRyb2NrX2Zsb29yX3Bvc2l0aW9uKSkmJnZvaWQgMCE9PWk/aTowLHNlYUxldmVsOm51bGwhPT0obj1rLnJlYWRJbnQoYy5zZWFfbGV2ZWwpKSYmdm9pZCAwIT09bj9uOjAsZGlzYWJsZU1vYkdlbmVyYXRpb246bnVsbCE9PShyPWsucmVhZEJvb2xlYW4oYy5kaXNhYmxlX21vYl9nZW5lcmF0aW9uKSkmJnZvaWQgMCE9PXImJnIsYXF1aWZlcnNFbmFibGVkOm51bGwhPT0obz1rLnJlYWRCb29sZWFuKGMuYXF1aWZlcnNfZW5hYmxlZCkpJiZ2b2lkIDAhPT1vJiZvLG5vaXNlQ2F2ZXNFbmFibGVkOm51bGwhPT0oYT1rLnJlYWRCb29sZWFuKGMubm9pc2VfY2F2ZXNfZW5hYmxlZCkpJiZ2b2lkIDAhPT1hJiZhLGRlZXBzbGF0ZUVuYWJsZWQ6bnVsbCE9PShsPWsucmVhZEJvb2xlYW4oYy5kZWVwc2xhdGVfZW5hYmxlZCkpJiZ2b2lkIDAhPT1sJiZsLG9yZVZlaW5zRW5hYmxlZDpudWxsIT09KGg9ay5yZWFkQm9vbGVhbihjLm9yZV92ZWluc19lbmFibGVkKSkmJnZvaWQgMCE9PWgmJmgsbm9vZGxlQ2F2ZXNFbmFibGVkOm51bGwhPT0odT1rLnJlYWRCb29sZWFuKGMubm9vZGxlX2NhdmVzX2VuYWJsZWQpKSYmdm9pZCAwIT09dSYmdX19fShDdHx8KEN0PXt9KSksZnVuY3Rpb24odCl7dC5mcm9tSnNvbj1mdW5jdGlvbih0KXt2YXIgZTtjb25zdCBzPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJue3N0cm9uZ2hvbGQ6ay5jb21wb3NlKHMuc3Ryb25naG9sZCxrLnJlYWRPYmplY3QsKHQ9Pnt2YXIgZSxzLGk7cmV0dXJue2Rpc3RhbmNlOm51bGwhPT0oZT1rLnJlYWRJbnQodC5kaXN0YW5jZSkpJiZ2b2lkIDAhPT1lP2U6MCxzcHJlYWQ6bnVsbCE9PShzPWsucmVhZEludCh0LnNwcmVhZCkpJiZ2b2lkIDAhPT1zP3M6MCxjb3VudDpudWxsIT09KGk9ay5yZWFkSW50KHQuY291bnQpKSYmdm9pZCAwIT09aT9pOjB9fSkpLHN0cnVjdHVyZXM6ay5yZWFkTWFwKHMuc3RydWN0dXJlcywodD0+e3ZhciBlO3JldHVybih0PT57dmFyIGUscyxpO3JldHVybntzcGFjaW5nOm51bGwhPT0oZT1rLnJlYWRJbnQodC5zcGFjaW5nKSkmJnZvaWQgMCE9PWU/ZTowLHNlcGFyYXRpb246bnVsbCE9PShzPWsucmVhZEludCh0LnNlcGFyYXRpb24pKSYmdm9pZCAwIT09cz9zOjAsc2FsdDpudWxsIT09KGk9ay5yZWFkSW50KHQuc2FsdCkpJiZ2b2lkIDAhPT1pP2k6MH19KShudWxsIT09KGU9ay5yZWFkT2JqZWN0KHQpKSYmdm9pZCAwIT09ZT9lOnt9KX0pKX19fShJdHx8KEl0PXt9KSksZnVuY3Rpb24odCl7dC5mcm9tSnNvbj1mdW5jdGlvbih0KXt2YXIgZTtjb25zdCBzPW51bGwhPT0oZT1rLnJlYWRPYmplY3QodCkpJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJue3RlbXBlcmF0dXJlOlIuZnJvbUpzb24ocy50ZW1wZXJhdHVyZSksaHVtaWRpdHk6Ui5mcm9tSnNvbihzLmh1bWlkaXR5KSxjb250aW5lbnRhbG5lc3M6Ui5mcm9tSnNvbihzLmNvbnRpbmVudGFsbmVzcyksZXJvc2lvbjpSLmZyb21Kc29uKHMuZXJvc2lvbiksd2VpcmRuZXNzOlIuZnJvbUpzb24ocy53ZWlyZG5lc3MpLHNoaWZ0OlIuZnJvbUpzb24ocy5zaGlmdCl9fX0oa3R8fChrdD17fSkpO2V4cG9ydHtZIGFzIEJsZW5kZWROb2lzZSxudCBhcyBCbG9ja0NvbG9ycyxsdCBhcyBCbG9ja0RlZmluaXRpb24sZnQgYXMgQmxvY2tNb2RlbCxvIGFzIEJsb2NrUG9zLEIgYXMgQmxvY2tTdGF0ZSxDIGFzIENodW5rLEkgYXMgQ2h1bmtQb3MsRSBhcyBDaHVua1NlY3Rpb24seXQgYXMgQ2xpbWF0ZSxuIGFzIERpcmVjdGlvbixSdCBhcyBGaXhlZEJpb21lLFYgYXMgSW1wcm92ZWROb2lzZSxrIGFzIEpzb24sX3QgYXMgTXVsdGlOb2lzZSxoIGFzIE5idFJlYWRlcix1IGFzIE5idFdyaXRlcixOdCBhcyBOb2lzZUNodW5rR2VuZXJhdG9yLEN0IGFzIE5vaXNlR2VuZXJhdG9yU2V0dGluZ3MsRnQgYXMgTm9pc2VJbnRlcnBvbGF0b3Isa3QgYXMgTm9pc2VPY3RhdmVzLFIgYXMgTm9pc2VQYXJhbWV0ZXJzLE10IGFzIE5vaXNlU2FtcGxlcixCdCBhcyBOb2lzZVNhbXBsaW5nU2V0dGluZ3MsU3QgYXMgTm9pc2VTZXR0aW5ncyxFdCBhcyBOb2lzZVNsaWRlU2V0dGluZ3MsWCBhcyBOb3JtYWxOb2lzZSxqIGFzIFBlcmxpbk5vaXNlLEggYXMgUGVybGluU2ltcGxleE5vaXNlLFcgYXMgUmFuZG9tLHogYXMgU2ltcGxleE5vaXNlLFogYXMgU3BsaW5lLF8gYXMgU3RydWN0dXJlLHd0IGFzIFN0cnVjdHVyZVJlbmRlcmVyLEl0IGFzIFN0cnVjdHVyZVNldHRpbmdzLEF0IGFzIFRlcnJhaW5TaGFwZXIseHQgYXMgVGV4dHVyZUF0bGFzLEogYXMgV29ybGRnZW5SYW5kb20sTCBhcyBiaW5hcnlTZWFyY2gsTSBhcyBjbGFtcCxVIGFzIGNsYW1wZWRMZXJwLEEgYXMgZ2V0TGlzdFRhZyxTIGFzIGdldE9wdGlvbmFsLHkgYXMgZ2V0VGFnLE4gYXMgbGVycCxUIGFzIGxlcnAyLE8gYXMgbGVycDMsZiBhcyByZWFkLHAgYXMgcmVhZENodW5rLGQgYXMgcmVhZENvbXByZXNzZWQsZyBhcyByZWFkUmVnaW9uLGMgYXMgcmVhZFVuY29tcHJlc3NlZCxEIGFzIHNtb290aHN0ZXAsRiBhcyBzcXVhcmUsbCBhcyB0YWdOYW1lcyxhIGFzIHRhZ1R5cGVzLGIgYXMgd3JpdGUsUCBhcyB3cml0ZUNodW5rLHYgYXMgd3JpdGVDb21wcmVzc2VkLHcgYXMgd3JpdGVSZWdpb24sbSBhcyB3cml0ZVVuY29tcHJlc3NlZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwc2xhdGUuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBDb21tb24gdXRpbGl0aWVzXG4gKiBAbW9kdWxlIGdsTWF0cml4XG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBBUlJBWV9UWVBFID0gdHlwZTtcbn1cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuLyoqXG4gKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBEZWdyZWVzXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IDAsXG4gICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xufTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxuICogNHg0IE1hdHJpeDxicj5Gb3JtYXQ6IGNvbHVtbi1tYWpvciwgd2hlbiB0eXBlZCBvdXQgaXQgbG9va3MgbGlrZSByb3ctbWFqb3I8YnI+VGhlIG1hdHJpY2VzIGFyZSBiZWluZyBwb3N0IG11bHRpcGxpZWQuXG4gKiBAbW9kdWxlIG1hdDRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgIHZhciBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuICAgIHZhciBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIG91dFswXSA9IGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKTtcbiAgb3V0WzFdID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICBvdXRbMl0gPSBhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFszXSA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICBvdXRbNV0gPSBhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMik7XG4gIG91dFs2XSA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddID0gYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbOF0gPSBhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSk7XG4gIG91dFs5XSA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9IGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9IGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9IGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdOyAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcblxuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzFdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsyXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbM10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzRdO1xuICBiMSA9IGJbNV07XG4gIGIyID0gYls2XTtcbiAgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFs2XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbN10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzhdO1xuICBiMSA9IGJbOV07XG4gIGIyID0gYlsxMF07XG4gIGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzEwXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTFdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYlsxMl07XG4gIGIxID0gYlsxM107XG4gIGIyID0gYlsxNF07XG4gIGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzEzXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTRdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxNV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgb3V0WzBdID0gYVswXSAqIHg7XG4gIG91dFsxXSA9IGFbMV0gKiB4O1xuICBvdXRbMl0gPSBhWzJdICogeDtcbiAgb3V0WzNdID0gYVszXSAqIHg7XG4gIG91dFs0XSA9IGFbNF0gKiB5O1xuICBvdXRbNV0gPSBhWzVdICogeTtcbiAgb3V0WzZdID0gYVs2XSAqIHk7XG4gIG91dFs3XSA9IGFbN10gKiB5O1xuICBvdXRbOF0gPSBhWzhdICogejtcbiAgb3V0WzldID0gYVs5XSAqIHo7XG4gIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB2WzFdO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gdlsyXTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG5cbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAtcztcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLXM7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBmcm9tIGEgZHVhbCBxdWF0LlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IE1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvblxuICogQHJldHVybnMge21hdDR9IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihvdXQsIG1hdCkge1xuICBvdXRbMF0gPSBtYXRbMTJdO1xuICBvdXRbMV0gPSBtYXRbMTNdO1xuICBvdXRbMl0gPSBtYXRbMTRdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXG4gKiAgd2l0aCBhIG5vcm1hbGl6ZWQgUXVhdGVybmlvbiBwYXJhbXRlciwgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnRcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIHZhciBtMTEgPSBtYXRbMF07XG4gIHZhciBtMTIgPSBtYXRbMV07XG4gIHZhciBtMTMgPSBtYXRbMl07XG4gIHZhciBtMjEgPSBtYXRbNF07XG4gIHZhciBtMjIgPSBtYXRbNV07XG4gIHZhciBtMjMgPSBtYXRbNl07XG4gIHZhciBtMzEgPSBtYXRbOF07XG4gIHZhciBtMzIgPSBtYXRbOV07XG4gIHZhciBtMzMgPSBtYXRbMTBdO1xuICBvdXRbMF0gPSBNYXRoLmh5cG90KG0xMSwgbTEyLCBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLmh5cG90KG0yMSwgbTIyLCBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb24ob3V0LCBtYXQpIHtcbiAgdmFyIHNjYWxpbmcgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgZ2V0U2NhbGluZyhzY2FsaW5nLCBtYXQpO1xuICB2YXIgaXMxID0gMSAvIHNjYWxpbmdbMF07XG4gIHZhciBpczIgPSAxIC8gc2NhbGluZ1sxXTtcbiAgdmFyIGlzMyA9IDEgLyBzY2FsaW5nWzJdO1xuICB2YXIgc20xMSA9IG1hdFswXSAqIGlzMTtcbiAgdmFyIHNtMTIgPSBtYXRbMV0gKiBpczI7XG4gIHZhciBzbTEzID0gbWF0WzJdICogaXMzO1xuICB2YXIgc20yMSA9IG1hdFs0XSAqIGlzMTtcbiAgdmFyIHNtMjIgPSBtYXRbNV0gKiBpczI7XG4gIHZhciBzbTIzID0gbWF0WzZdICogaXMzO1xuICB2YXIgc20zMSA9IG1hdFs4XSAqIGlzMTtcbiAgdmFyIHNtMzIgPSBtYXRbOV0gKiBpczI7XG4gIHZhciBzbTMzID0gbWF0WzEwXSAqIGlzMztcbiAgdmFyIHRyYWNlID0gc20xMSArIHNtMjIgKyBzbTMzO1xuICB2YXIgUyA9IDA7XG5cbiAgaWYgKHRyYWNlID4gMCkge1xuICAgIFMgPSBNYXRoLnNxcnQodHJhY2UgKyAxLjApICogMjtcbiAgICBvdXRbM10gPSAwLjI1ICogUztcbiAgICBvdXRbMF0gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMV0gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMl0gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgfSBlbHNlIGlmIChzbTExID4gc20yMiAmJiBzbTExID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20xMSAtIHNtMjIgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgb3V0WzFdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20yMiA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMjIgLSBzbTExIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFswXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChzbTIzICsgc20zMikgLyBTO1xuICB9IGVsc2Uge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20zMyAtIHNtMTEgLSBzbTIyKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gICAgb3V0WzJdID0gMC4yNSAqIFM7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZShvdXQsIHEsIHYsIHMpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geXggLSB3ejtcbiAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gIG91dFs2XSA9IHp5ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAqIFRoZSBuZWFyL2ZhciBjbGlwIHBsYW5lcyBjb3JyZXNwb25kIHRvIGEgbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZSBaIHJhbmdlIG9mIFstMSwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdML09wZW5HTCdzIGNsaXAgdm9sdW1lLlxuICogUGFzc2luZyBudWxsL3VuZGVmaW5lZC9ubyB2YWx1ZSBmb3IgZmFyIHdpbGwgZ2VuZXJhdGUgaW5maW5pdGUgcHJvamVjdGlvbiBtYXRyaXguXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW0sIGNhbiBiZSBudWxsIG9yIEluZmluaXR5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlTk8ob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG5cbiAgaWYgKGZhciAhPSBudWxsICYmIGZhciAhPT0gSW5maW5pdHkpIHtcbiAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNF0gPSAyICogZmFyICogbmVhciAqIG5mO1xuICB9IGVsc2Uge1xuICAgIG91dFsxMF0gPSAtMTtcbiAgICBvdXRbMTRdID0gLTIgKiBuZWFyO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnBlcnNwZWN0aXZlTk99XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmVOTztcbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggc3VpdGFibGUgZm9yIFdlYkdQVSB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbMCwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdQVS9WdWxrYW4vRGlyZWN0WC9NZXRhbCdzIGNsaXAgdm9sdW1lLlxuICogUGFzc2luZyBudWxsL3VuZGVmaW5lZC9ubyB2YWx1ZSBmb3IgZmFyIHdpbGwgZ2VuZXJhdGUgaW5maW5pdGUgcHJvamVjdGlvbiBtYXRyaXguXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW0sIGNhbiBiZSBudWxsIG9yIEluZmluaXR5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlWk8ob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG5cbiAgaWYgKGZhciAhPSBudWxsICYmIGZhciAhPT0gSW5maW5pdHkpIHtcbiAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzEwXSA9IGZhciAqIG5mO1xuICAgIG91dFsxNF0gPSBmYXIgKiBuZWFyICogbmY7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzEwXSA9IC0xO1xuICAgIG91dFsxNF0gPSAtbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgdmFyIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuICBvdXRbMF0gPSB4U2NhbGU7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIG91dFs0XSA9IDAuMDtcbiAgb3V0WzVdID0geVNjYWxlO1xuICBvdXRbNl0gPSAwLjA7XG4gIG91dFs3XSA9IDAuMDtcbiAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gIG91dFs5XSA9ICh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41O1xuICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTFdID0gLTEuMDtcbiAgb3V0WzEyXSA9IDAuMDtcbiAgb3V0WzEzXSA9IDAuMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxuICogVGhlIG5lYXIvZmFyIGNsaXAgcGxhbmVzIGNvcnJlc3BvbmQgdG8gYSBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlIFogcmFuZ2Ugb2YgWy0xLCAxXSxcbiAqIHdoaWNoIG1hdGNoZXMgV2ViR0wvT3BlbkdMJ3MgY2xpcCB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvTk8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm9ydGhvTk99XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG9ydGhvID0gb3J0aG9OTztcbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBUaGUgbmVhci9mYXIgY2xpcCBwbGFuZXMgY29ycmVzcG9uZCB0byBhIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGUgWiByYW5nZSBvZiBbMCwgMV0sXG4gKiB3aGljaCBtYXRjaGVzIFdlYkdQVS9WdWxrYW4vRGlyZWN0WC9NZXRhbCdzIGNsaXAgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvcnRob1pPKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IG5lYXIgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzLlxuICogSWYgeW91IHdhbnQgYSBtYXRyaXggdGhhdCBhY3R1YWxseSBtYWtlcyBhbiBvYmplY3QgbG9vayBhdCBhbm90aGVyIG9iamVjdCwgeW91IHNob3VsZCB1c2UgdGFyZ2V0VG8gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgdmFyIGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcbiAgdmFyIHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgdmFyIGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIHZhciB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0NChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiLCBcIiArIGFbOV0gKyBcIiwgXCIgKyBhWzEwXSArIFwiLCBcIiArIGFbMTFdICsgXCIsIFwiICsgYVsxMl0gKyBcIiwgXCIgKyBhWzEzXSArIFwiLCBcIiArIGFbMTRdICsgXCIsIFwiICsgYVsxNV0gKyBcIilcIjtcbn1cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICBvdXRbOV0gPSBhWzldIC0gYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSAtIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSAtIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICBvdXRbOV0gPSBhWzldICsgYls5XSAqIHNjYWxlO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXSAqIHNjYWxlO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXSAqIHNjYWxlO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXSAqIHNjYWxlO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXSAqIHNjYWxlO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XSAqIHNjYWxlO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XSAmJiBhWzldID09PSBiWzldICYmIGFbMTBdID09PSBiWzEwXSAmJiBhWzExXSA9PT0gYlsxMV0gJiYgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYTggPSBhWzhdLFxuICAgICAgYTkgPSBhWzldLFxuICAgICAgYTEwID0gYVsxMF0sXG4gICAgICBhMTEgPSBhWzExXTtcbiAgdmFyIGExMiA9IGFbMTJdLFxuICAgICAgYTEzID0gYVsxM10sXG4gICAgICBhMTQgPSBhWzE0XSxcbiAgICAgIGExNSA9IGFbMTVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICB2YXIgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICB2YXIgYjggPSBiWzhdLFxuICAgICAgYjkgPSBiWzldLFxuICAgICAgYjEwID0gYlsxMF0sXG4gICAgICBiMTEgPSBiWzExXTtcbiAgdmFyIGIxMiA9IGJbMTJdLFxuICAgICAgYjEzID0gYlsxM10sXG4gICAgICBiMTQgPSBiWzE0XSxcbiAgICAgIGIxNSA9IGJbMTVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiYgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiYgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJiBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiYgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJiBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpO1xufVxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl07XG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgICAgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopLFxuICAgICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsIi8vcGFja2VyIHZlcnNpb25cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAgIExpdGVHcmFwaCBDTEFTUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLyoqXG4gICAgICogVGhlIEdsb2JhbCBTY29wZS4gSXQgY29udGFpbnMgYWxsIHRoZSByZWdpc3RlcmVkIG5vZGUgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBMaXRlR3JhcGhcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cblxuICAgIHZhciBMaXRlR3JhcGggPSAoZ2xvYmFsLkxpdGVHcmFwaCA9IHtcbiAgICAgICAgVkVSU0lPTjogMC40LFxuXG4gICAgICAgIENBTlZBU19HUklEX1NJWkU6IDEwLFxuXG4gICAgICAgIE5PREVfVElUTEVfSEVJR0hUOiAzMCxcbiAgICAgICAgTk9ERV9USVRMRV9URVhUX1k6IDIwLFxuICAgICAgICBOT0RFX1NMT1RfSEVJR0hUOiAyMCxcbiAgICAgICAgTk9ERV9XSURHRVRfSEVJR0hUOiAyMCxcbiAgICAgICAgTk9ERV9XSURUSDogMTQwLFxuICAgICAgICBOT0RFX01JTl9XSURUSDogNTAsXG4gICAgICAgIE5PREVfQ09MTEFQU0VEX1JBRElVUzogMTAsXG4gICAgICAgIE5PREVfQ09MTEFQU0VEX1dJRFRIOiA4MCxcbiAgICAgICAgTk9ERV9USVRMRV9DT0xPUjogXCIjOTk5XCIsXG4gICAgICAgIE5PREVfU0VMRUNURURfVElUTEVfQ09MT1I6IFwiI0ZGRlwiLFxuICAgICAgICBOT0RFX1RFWFRfU0laRTogMTQsXG4gICAgICAgIE5PREVfVEVYVF9DT0xPUjogXCIjQUFBXCIsXG4gICAgICAgIE5PREVfU1VCVEVYVF9TSVpFOiAxMixcbiAgICAgICAgTk9ERV9ERUZBVUxUX0NPTE9SOiBcIiMzMzNcIixcbiAgICAgICAgTk9ERV9ERUZBVUxUX0JHQ09MT1I6IFwiIzM1MzUzNVwiLFxuICAgICAgICBOT0RFX0RFRkFVTFRfQk9YQ09MT1I6IFwiIzY2NlwiLFxuICAgICAgICBOT0RFX0RFRkFVTFRfU0hBUEU6IFwiYm94XCIsXG4gICAgICAgIE5PREVfQk9YX09VVExJTkVfQ09MT1I6IFwiI0ZGRlwiLFxuICAgICAgICBERUZBVUxUX1NIQURPV19DT0xPUjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgICAgREVGQVVMVF9HUk9VUF9GT05UOiAyNCxcblxuICAgICAgICBXSURHRVRfQkdDT0xPUjogXCIjMjIyXCIsXG4gICAgICAgIFdJREdFVF9PVVRMSU5FX0NPTE9SOiBcIiM2NjZcIixcbiAgICAgICAgV0lER0VUX1RFWFRfQ09MT1I6IFwiI0RERFwiLFxuICAgICAgICBXSURHRVRfU0VDT05EQVJZX1RFWFRfQ09MT1I6IFwiIzk5OVwiLFxuXG4gICAgICAgIExJTktfQ09MT1I6IFwiIzlBOVwiLFxuICAgICAgICBFVkVOVF9MSU5LX0NPTE9SOiBcIiNBODZcIixcbiAgICAgICAgQ09OTkVDVElOR19MSU5LX0NPTE9SOiBcIiNBRkFcIixcblxuICAgICAgICBNQVhfTlVNQkVSX09GX05PREVTOiAxMDAwLCAvL2F2b2lkIGluZmluaXRlIGxvb3BzXG4gICAgICAgIERFRkFVTFRfUE9TSVRJT046IFsxMDAsIDEwMF0sIC8vZGVmYXVsdCBub2RlIHBvc2l0aW9uXG4gICAgICAgIFZBTElEX1NIQVBFUzogW1wiZGVmYXVsdFwiLCBcImJveFwiLCBcInJvdW5kXCIsIFwiY2FyZFwiXSwgLy8sXCJjaXJjbGVcIlxuXG4gICAgICAgIC8vc2hhcGVzIGFyZSB1c2VkIGZvciBub2RlcyBidXQgYWxzbyBmb3Igc2xvdHNcbiAgICAgICAgQk9YX1NIQVBFOiAxLFxuICAgICAgICBST1VORF9TSEFQRTogMixcbiAgICAgICAgQ0lSQ0xFX1NIQVBFOiAzLFxuICAgICAgICBDQVJEX1NIQVBFOiA0LFxuICAgICAgICBBUlJPV19TSEFQRTogNSxcblxuICAgICAgICAvL2VudW1zXG4gICAgICAgIElOUFVUOiAxLFxuICAgICAgICBPVVRQVVQ6IDIsXG5cbiAgICAgICAgRVZFTlQ6IC0xLCAvL2ZvciBvdXRwdXRzXG4gICAgICAgIEFDVElPTjogLTEsIC8vZm9yIGlucHV0c1xuXG4gICAgICAgIEFMV0FZUzogMCxcbiAgICAgICAgT05fRVZFTlQ6IDEsXG4gICAgICAgIE5FVkVSOiAyLFxuICAgICAgICBPTl9UUklHR0VSOiAzLFxuXG4gICAgICAgIFVQOiAxLFxuICAgICAgICBET1dOOiAyLFxuICAgICAgICBMRUZUOiAzLFxuICAgICAgICBSSUdIVDogNCxcbiAgICAgICAgQ0VOVEVSOiA1LFxuXG4gICAgICAgIFNUUkFJR0hUX0xJTks6IDAsXG4gICAgICAgIExJTkVBUl9MSU5LOiAxLFxuICAgICAgICBTUExJTkVfTElOSzogMixcblxuICAgICAgICBOT1JNQUxfVElUTEU6IDAsXG4gICAgICAgIE5PX1RJVExFOiAxLFxuICAgICAgICBUUkFOU1BBUkVOVF9USVRMRTogMixcbiAgICAgICAgQVVUT0hJREVfVElUTEU6IDMsXG5cbiAgICAgICAgcHJveHk6IG51bGwsIC8vdXNlZCB0byByZWRpcmVjdCBjYWxsc1xuICAgICAgICBub2RlX2ltYWdlc19wYXRoOiBcIlwiLFxuXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgY2F0Y2hfZXhjZXB0aW9uczogdHJ1ZSxcbiAgICAgICAgdGhyb3dfZXJyb3JzOiB0cnVlLFxuICAgICAgICBhbGxvd19zY3JpcHRzOiBmYWxzZSwgLy9pZiBzZXQgdG8gdHJ1ZSBzb21lIG5vZGVzIGxpa2UgRm9ybXVsYSB3b3VsZCBiZSBhbGxvd2VkIHRvIGV2YWx1YXRlIGNvZGUgdGhhdCBjb21lcyBmcm9tIHVuc2FmZSBzb3VyY2VzIChsaWtlIG5vZGUgY29uZmlndXJhdGlvbiksIHdoaWNoIGNvdWxkIGxlYWQgdG8gZXhwbG9pdHNcbiAgICAgICAgcmVnaXN0ZXJlZF9ub2RlX3R5cGVzOiB7fSwgLy9ub2RldHlwZXMgYnkgc3RyaW5nXG4gICAgICAgIG5vZGVfdHlwZXNfYnlfZmlsZV9leHRlbnNpb246IHt9LCAvL3VzZWQgZm9yIGRyb3BwaW5nIGZpbGVzIGluIHRoZSBjYW52YXNcbiAgICAgICAgTm9kZXM6IHt9LCAvL25vZGUgdHlwZXMgYnkgY2xhc3NuYW1lXG5cdFx0R2xvYmFsczoge30sIC8vdXNlZCB0byBzdG9yZSB2YXJzIGJldHdlZW4gZ3JhcGhzXG5cbiAgICAgICAgc2VhcmNoYm94X2V4dHJhczoge30sIC8vdXNlZCB0byBhZGQgZXh0cmEgZmVhdHVyZXMgdG8gdGhlIHNlYXJjaCBib3hcbiAgICAgICAgYXV0b19zb3J0X25vZGVfdHlwZXM6IGZhbHNlLCAvLyBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhdXRvbWF0aWNhbGx5IHNvcnQgbm9kZSB0eXBlcyAvIGNhdGVnb3JpZXMgaW4gdGhlIGNvbnRleHQgbWVudXNcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBub2RlIGNsYXNzIHNvIGl0IGNhbiBiZSBsaXN0ZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJOb2RlVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBuYW1lIG9mIHRoZSBub2RlIGFuZCBwYXRoXG4gICAgICAgICAqIEBwYXJhbSB7Q2xhc3N9IGJhc2VfY2xhc3MgY2xhc3MgY29udGFpbmluZyB0aGUgc3RydWN0dXJlIG9mIGEgbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgICByZWdpc3Rlck5vZGVUeXBlOiBmdW5jdGlvbih0eXBlLCBiYXNlX2NsYXNzKSB7XG4gICAgICAgICAgICBpZiAoIWJhc2VfY2xhc3MucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVnaXN0ZXIgYSBzaW1wbGUgb2JqZWN0LCBpdCBtdXN0IGJlIGEgY2xhc3Mgd2l0aCBhIHByb3RvdHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZV9jbGFzcy50eXBlID0gdHlwZTtcblxuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZSByZWdpc3RlcmVkOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgdmFyIGNsYXNzbmFtZSA9IGJhc2VfY2xhc3MubmFtZTtcblxuICAgICAgICAgICAgdmFyIHBvcyA9IHR5cGUubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgYmFzZV9jbGFzcy5jYXRlZ29yeSA9IHR5cGUuc3Vic3RyKDAsIHBvcyk7XG5cbiAgICAgICAgICAgIGlmICghYmFzZV9jbGFzcy50aXRsZSkge1xuICAgICAgICAgICAgICAgIGJhc2VfY2xhc3MudGl0bGUgPSBjbGFzc25hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2luZm8ubmFtZSA9IG5hbWUuc3Vic3RyKHBvcysxLG5hbWUubGVuZ3RoIC0gcG9zKTtcblxuICAgICAgICAgICAgLy9leHRlbmQgY2xhc3NcbiAgICAgICAgICAgIGlmIChiYXNlX2NsYXNzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vaXMgYSBjbGFzc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gTEdyYXBoTm9kZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlX2NsYXNzLnByb3RvdHlwZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZV9jbGFzcy5wcm90b3R5cGVbaV0gPSBMR3JhcGhOb2RlLnByb3RvdHlwZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1t0eXBlXTtcblx0XHRcdGlmKHByZXYpXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwicmVwbGFjaW5nIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0aWYoICFPYmplY3QuaGFzT3duUHJvcGVydHkoIGJhc2VfY2xhc3MucHJvdG90eXBlLCBcInNoYXBlXCIpIClcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGJhc2VfY2xhc3MucHJvdG90eXBlLCBcInNoYXBlXCIsIHtcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHN3aXRjaCAodikge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiZGVmYXVsdFwiOlxuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zaGFwZTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBcImJveFwiOlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NoYXBlID0gTGl0ZUdyYXBoLkJPWF9TSEFQRTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBcInJvdW5kXCI6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2hhcGUgPSBMaXRlR3JhcGguUk9VTkRfU0hBUEU7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJjaXJjbGVcIjpcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaGFwZSA9IExpdGVHcmFwaC5DSVJDTEVfU0hBUEU7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJjYXJkXCI6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2hhcGUgPSBMaXRlR3JhcGguQ0FSRF9TSEFQRTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaGFwZSA9IHY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9zaGFwZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vd2FybmluZ3Ncblx0XHRcdFx0aWYgKGJhc2VfY2xhc3MucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2UpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0XHRcIkxpdGVHcmFwaCBub2RlIGNsYXNzIFwiICtcblx0XHRcdFx0XHRcdFx0dHlwZSArXG5cdFx0XHRcdFx0XHRcdFwiIGhhcyBvblByb3BlcnR5Q2hhbmdlIG1ldGhvZCwgaXQgbXVzdCBiZSBjYWxsZWQgb25Qcm9wZXJ0eUNoYW5nZWQgd2l0aCBkIGF0IHRoZSBlbmRcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3VzZWQgdG8ga25vdyB3aGljaCBub2RlcyBjcmVhdGUgd2hlbiBkcmFnZ2luZyBmaWxlcyB0byB0aGUgY2FudmFzXG5cdFx0XHRcdGlmIChiYXNlX2NsYXNzLnN1cHBvcnRlZF9leHRlbnNpb25zKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBiYXNlX2NsYXNzLnN1cHBvcnRlZF9leHRlbnNpb25zKSB7XG5cdFx0XHRcdFx0XHR2YXIgZXh0ID0gYmFzZV9jbGFzcy5zdXBwb3J0ZWRfZXh0ZW5zaW9uc1tpXTtcblx0XHRcdFx0XHRcdGlmKGV4dCAmJiBleHQuY29uc3RydWN0b3IgPT09IFN0cmluZylcblx0XHRcdFx0XHRcdFx0dGhpcy5ub2RlX3R5cGVzX2J5X2ZpbGVfZXh0ZW5zaW9uWyBleHQudG9Mb3dlckNhc2UoKSBdID0gYmFzZV9jbGFzcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbdHlwZV0gPSBiYXNlX2NsYXNzO1xuICAgICAgICAgICAgaWYgKGJhc2VfY2xhc3MuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuTm9kZXNbY2xhc3NuYW1lXSA9IGJhc2VfY2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLm9uTm9kZVR5cGVSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgICAgTGl0ZUdyYXBoLm9uTm9kZVR5cGVSZWdpc3RlcmVkKHR5cGUsIGJhc2VfY2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgTGl0ZUdyYXBoLm9uTm9kZVR5cGVSZXBsYWNlZCkge1xuICAgICAgICAgICAgICAgIExpdGVHcmFwaC5vbk5vZGVUeXBlUmVwbGFjZWQodHlwZSwgYmFzZV9jbGFzcywgcHJldik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vd2FybmluZ3NcbiAgICAgICAgICAgIGlmIChiYXNlX2NsYXNzLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcIkxpdGVHcmFwaCBub2RlIGNsYXNzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgaGFzIG9uUHJvcGVydHlDaGFuZ2UgbWV0aG9kLCBpdCBtdXN0IGJlIGNhbGxlZCBvblByb3BlcnR5Q2hhbmdlZCB3aXRoIGQgYXQgdGhlIGVuZFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly91c2VkIHRvIGtub3cgd2hpY2ggbm9kZXMgY3JlYXRlIHdoZW4gZHJhZ2dpbmcgZmlsZXMgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgaWYgKGJhc2VfY2xhc3Muc3VwcG9ydGVkX2V4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBiYXNlX2NsYXNzLnN1cHBvcnRlZF9leHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGV4dCA9IGJhc2VfY2xhc3Muc3VwcG9ydGVkX2V4dGVuc2lvbnNbaV07XG5cdFx0XHRcdFx0aWYoZXh0ICYmIGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV90eXBlc19ieV9maWxlX2V4dGVuc2lvblsgZXh0LnRvTG93ZXJDYXNlKCkgXSA9IGJhc2VfY2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVzIGEgbm9kZSB0eXBlIGZyb20gdGhlIHN5c3RlbVxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJOb2RlVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHR5cGUgbmFtZSBvZiB0aGUgbm9kZSBvciB0aGUgbm9kZSBjb25zdHJ1Y3RvciBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIHVucmVnaXN0ZXJOb2RlVHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGJhc2VfY2xhc3MgPSB0eXBlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1t0eXBlXSA6IHR5cGU7XG5cdFx0XHRpZighYmFzZV9jbGFzcylcblx0XHRcdFx0dGhyb3coXCJub2RlIHR5cGUgbm90IGZvdW5kOiBcIiArIHR5cGUgKTtcblx0XHRcdGRlbGV0ZSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1tiYXNlX2NsYXNzLnR5cGVdO1xuXHRcdFx0aWYoYmFzZV9jbGFzcy5jb25zdHJ1Y3Rvci5uYW1lKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5Ob2Rlc1tiYXNlX2NsYXNzLmNvbnN0cnVjdG9yLm5hbWVdO1xuXHRcdH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBub2RldHlwZSBieSBwYXNzaW5nIGEgZnVuY3Rpb24sIGl0IHdyYXBzIGl0IHdpdGggYSBwcm9wZXIgY2xhc3MgYW5kIGdlbmVyYXRlcyBpbnB1dHMgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICogVXNlZnVsIHRvIHdyYXAgc2ltcGxlIG1ldGhvZHMgdGhhdCBkbyBub3QgcmVxdWlyZSBwcm9wZXJ0aWVzLCBhbmQgdGhhdCBvbmx5IHByb2Nlc3Mgc29tZSBpbnB1dCB0byBnZW5lcmF0ZSBhbiBvdXRwdXQuXG4gICAgICAgICAqIEBtZXRob2Qgd3JhcEZ1bmN0aW9uQXNOb2RlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGUgbmFtZSB3aXRoIG5hbWVzcGFjZSAocC5lLjogJ21hdGgvc3VtJylcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbV90eXBlcyBbb3B0aW9uYWxdIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHR5cGUgb2YgZXZlcnkgcGFyYW1ldGVyLCBvdGhlcndpc2UgcGFyYW1ldGVycyB3aWxsIGFjY2VwdCBhbnkgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmV0dXJuX3R5cGUgW29wdGlvbmFsXSBzdHJpbmcgd2l0aCB0aGUgcmV0dXJuIHR5cGUsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGdlbmVyaWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgW29wdGlvbmFsXSBwcm9wZXJ0aWVzIHRvIGJlIGNvbmZpZ3VyYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcEZ1bmN0aW9uQXNOb2RlOiBmdW5jdGlvbihcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgcGFyYW1fdHlwZXMsXG4gICAgICAgICAgICByZXR1cm5fdHlwZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkoZnVuYy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gTGl0ZUdyYXBoLmdldFBhcmFtZXRlck5hbWVzKGZ1bmMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvZGUgKz1cbiAgICAgICAgICAgICAgICAgICAgXCJ0aGlzLmFkZElucHV0KCdcIiArXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzW2ldICtcbiAgICAgICAgICAgICAgICAgICAgXCInLFwiICtcbiAgICAgICAgICAgICAgICAgICAgKHBhcmFtX3R5cGVzICYmIHBhcmFtX3R5cGVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiJ1wiICsgcGFyYW1fdHlwZXNbaV0gKyBcIidcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIik7XFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlICs9XG4gICAgICAgICAgICAgICAgXCJ0aGlzLmFkZE91dHB1dCgnb3V0JyxcIiArXG4gICAgICAgICAgICAgICAgKHJldHVybl90eXBlID8gXCInXCIgKyByZXR1cm5fdHlwZSArIFwiJ1wiIDogMCkgK1xuICAgICAgICAgICAgICAgIFwiKTtcXG5cIjtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29kZSArPVxuICAgICAgICAgICAgICAgICAgICBcInRoaXMucHJvcGVydGllcyA9IFwiICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcykgKyBcIjtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbGFzc29iaiA9IEZ1bmN0aW9uKGNvZGUpO1xuICAgICAgICAgICAgY2xhc3NvYmoudGl0bGUgPSBuYW1lLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgICAgICAgIGNsYXNzb2JqLmRlc2MgPSBcIkdlbmVyYXRlZCBmcm9tIFwiICsgZnVuYy5uYW1lO1xuICAgICAgICAgICAgY2xhc3NvYmoucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uIG9uRXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSB0aGlzLmdldElucHV0RGF0YShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBmdW5jLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJOb2RlVHlwZShuYW1lLCBjbGFzc29iaik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBub2RlJ3MgdHlwZXNcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyUmVnaXN0ZXJlZFR5cGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzID0ge307XG4gICAgICAgICAgICB0aGlzLm5vZGVfdHlwZXNfYnlfZmlsZV9leHRlbnNpb24gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuTm9kZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoYm94X2V4dHJhcyA9IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoaXMgbWV0aG9kIHRvIGFsbCBub2RldHlwZXMsIGV4aXN0aW5nIGFuZCB0byBiZSBjcmVhdGVkXG4gICAgICAgICAqIChZb3UgY2FuIGFkZCBpdCB0byBMR3JhcGhOb2RlLnByb3RvdHlwZSBidXQgdGhlbiBleGlzdGluZyBub2RlIHR5cGVzIHdvbnQgaGF2ZSBpdClcbiAgICAgICAgICogQG1ldGhvZCBhZGROb2RlTWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgICAgICovXG4gICAgICAgIGFkZE5vZGVNZXRob2Q6IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIExHcmFwaE5vZGUucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZVtcIl9cIiArIG5hbWVdID0gdHlwZS5wcm90b3R5cGVbbmFtZV07XG4gICAgICAgICAgICAgICAgfSAvL2tlZXAgb2xkIGluIGNhc2Ugb2YgcmVwbGFjaW5nXG4gICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBub2RlIG9mIGEgZ2l2ZW4gdHlwZSB3aXRoIGEgbmFtZS4gVGhlIG5vZGUgaXMgbm90IGF0dGFjaGVkIHRvIGFueSBncmFwaCB5ZXQuXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlTm9kZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBmdWxsIG5hbWUgb2YgdGhlIG5vZGUgY2xhc3MuIHAuZS4gXCJtYXRoL3NpblwiXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSB0byBkaXN0aW5ndWlzaCBmcm9tIG90aGVyIG5vZGVzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIHNldCBvcHRpb25zXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uKHR5cGUsIHRpdGxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYmFzZV9jbGFzcyA9IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKCFiYXNlX2NsYXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICdHcmFwaE5vZGUgdHlwZSBcIicgKyB0eXBlICsgJ1wiIG5vdCByZWdpc3RlcmVkLidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBiYXNlX2NsYXNzLnByb3RvdHlwZSB8fCBiYXNlX2NsYXNzO1xuXG4gICAgICAgICAgICB0aXRsZSA9IHRpdGxlIHx8IGJhc2VfY2xhc3MudGl0bGUgfHwgdHlwZTtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmNhdGNoX2V4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV3IGJhc2VfY2xhc3ModGl0bGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBiYXNlX2NsYXNzKHRpdGxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcblxuICAgICAgICAgICAgaWYgKCFub2RlLnRpdGxlICYmIHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS50aXRsZSA9IHRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5wcm9wZXJ0aWVzX2luZm8pIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXNfaW5mbyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5mbGFncyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLnNpemUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNpemUgPSBub2RlLmNvbXB1dGVTaXplKCk7XG5cdFx0XHRcdC8vY2FsbCBvbnJlc2l6ZT9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5wb3MpIHtcbiAgICAgICAgICAgICAgICBub2RlLnBvcyA9IExpdGVHcmFwaC5ERUZBVUxUX1BPU0lUSU9OLmNvbmNhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLm1vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLm1vZGUgPSBMaXRlR3JhcGguQUxXQVlTO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2V4dHJhIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbaV0gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSByZWdpc3RlcmVkIG5vZGUgdHlwZSB3aXRoIGEgZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAbWV0aG9kIGdldE5vZGVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGZ1bGwgbmFtZSBvZiB0aGUgbm9kZSBjbGFzcy4gcC5lLiBcIm1hdGgvc2luXCJcbiAgICAgICAgICogQHJldHVybiB7Q2xhc3N9IHRoZSBub2RlIGNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICBnZXROb2RlVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW3R5cGVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlIHR5cGVzIG1hdGNoaW5nIG9uZSBjYXRlZ29yeVxuICAgICAgICAgKiBAbWV0aG9kIGdldE5vZGVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSB3aXRoIGFsbCB0aGUgbm9kZSBjbGFzc2VzXG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldE5vZGVUeXBlc0luQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdGVnb3J5LCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5maWx0ZXIgIT0gZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLmNhdGVnb3J5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS5jYXRlZ29yeSA9PSBjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvX3NvcnRfbm9kZV90eXBlcykge1xuICAgICAgICAgICAgICAgIHIuc29ydCgoYSwgYikgPT4gYS50aXRsZS5sb2NhbGVDb21wYXJlKGIudGl0bGUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlIHR5cGUgY2F0ZWdvcmllc1xuICAgICAgICAgKiBAbWV0aG9kIGdldE5vZGVUeXBlc0NhdGVnb3JpZXNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlciBvbmx5IG5vZGVzIHdpdGggY3Rvci5maWx0ZXIgZXF1YWwgY2FuIGJlIHNob3duXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSB3aXRoIGFsbCB0aGUgbmFtZXMgb2YgdGhlIGNhdGVnb3JpZXNcbiAgICAgICAgICovXG4gICAgICAgIGdldE5vZGVUeXBlc0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCBmaWx0ZXIgKSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHsgXCJcIjogMSB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlcykge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICggdHlwZS5jYXRlZ29yeSAmJiAhdHlwZS5za2lwX2xpc3QgKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRpZih0eXBlLmZpbHRlciAhPSBmaWx0ZXIpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllc1t0eXBlLmNhdGVnb3J5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvX3NvcnRfbm9kZV90eXBlcyA/IHJlc3VsdC5zb3J0KCkgOiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9kZWJ1ZyBwdXJwb3NlczogcmVsb2FkcyBhbGwgdGhlIGpzIHNjcmlwdHMgdGhhdCBtYXRjaGVzIGEgd2lsZGNhcmRcbiAgICAgICAgcmVsb2FkTm9kZXM6IGZ1bmN0aW9uKGZvbGRlcl93aWxkY2FyZCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgLy93ZWlyZCwgdGhpcyBhcnJheSBjaGFuZ2VzIGJ5IGl0cyBvd24sIHNvIHdlIHVzZSBhIGNvcHlcbiAgICAgICAgICAgIHZhciBzY3JpcHRfZmlsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNjcmlwdF9maWxlcy5wdXNoKHRtcFtpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkb2NIZWFkT2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICAgICAgZm9sZGVyX3dpbGRjYXJkID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArIGZvbGRlcl93aWxkY2FyZDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgc2NyaXB0X2ZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IHNjcmlwdF9maWxlc1tpXS5zcmM7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhc3JjIHx8XG4gICAgICAgICAgICAgICAgICAgIHNyYy5zdWJzdHIoMCwgZm9sZGVyX3dpbGRjYXJkLmxlbmd0aCkgIT0gZm9sZGVyX3dpbGRjYXJkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVsb2FkaW5nOiBcIiArIHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWNTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZG9jSGVhZE9iai5hcHBlbmRDaGlsZChkeW5hbWljU2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jSGVhZE9iai5yZW1vdmVDaGlsZChzY3JpcHRfZmlsZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLnRocm93X2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igd2hpbGUgcmVsb2FkaW5nIFwiICsgc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZXMgcmVsb2FkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9zZXBhcmF0ZWQganVzdCB0byBpbXByb3ZlIGlmIGl0IGRvZXNuJ3Qgd29ya1xuICAgICAgICBjbG9uZU9iamVjdDogZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgdGhlIHR5cGVzIG9mIHR3byBzbG90cyBhcmUgY29tcGF0aWJsZSAodGFraW5nIGludG8gYWNjb3VudCB3aWxkY2FyZHMsIGV0YylcbiAgICAgICAgICogQG1ldGhvZCBpc1ZhbGlkQ29ubmVjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZV9hXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlX2JcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBmdW5jdGlvbih0eXBlX2EsIHR5cGVfYikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0eXBlX2EgfHwgLy9nZW5lcmljIG91dHB1dFxuICAgICAgICAgICAgICAgICF0eXBlX2IgfHwgLy9nZW5lcmljIGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZV9hID09IHR5cGVfYiB8fCAvL3NhbWUgdHlwZSAoaXMgdmFsaWQgZm9yIHRyaWdnZXJzKVxuICAgICAgICAgICAgICAgICh0eXBlX2EgPT0gTGl0ZUdyYXBoLkVWRU5UICYmIHR5cGVfYiA9PSBMaXRlR3JhcGguQUNUSU9OKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZm9yY2Ugc3RyaW5nIHR5cGUgdG8gaGFuZGxlIHRvTG93ZXJDYXNlIGNhbGwgKC0xIG51bWJlciBub3Qgb2spXG4gICAgICAgICAgICB0eXBlX2EgPSBTdHJpbmcodHlwZV9hKTtcbiAgICAgICAgICAgIHR5cGVfYiA9IFN0cmluZyh0eXBlX2IpO1xuICAgICAgICAgICAgdHlwZV9hID0gdHlwZV9hLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0eXBlX2IgPSB0eXBlX2IudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gRm9yIG5vZGVzIHN1cHBvcnRpbmcgbXVsdGlwbGUgY29ubmVjdGlvbiB0eXBlc1xuICAgICAgICAgICAgaWYgKHR5cGVfYS5pbmRleE9mKFwiLFwiKSA9PSAtMSAmJiB0eXBlX2IuaW5kZXhPZihcIixcIikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZV9hID09IHR5cGVfYjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIHBlcm11dGF0aW9ucyB0byBzZWUgaWYgb25lIGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkX3R5cGVzX2EgPSB0eXBlX2Euc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRlZF90eXBlc19iID0gdHlwZV9iLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydGVkX3R5cGVzX2EubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1cHBvcnRlZF90eXBlc19iLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRfdHlwZXNfYVtpXSA9PSBzdXBwb3J0ZWRfdHlwZXNfYltqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBzdHJpbmcgaW4gdGhlIHNlYXJjaCBib3ggc28gd2hlbiB0aGUgdXNlciB0eXBlcyBpdCBpdCB3aWxsIHJlY29tbWVuZCB0aGlzIG5vZGVcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclNlYXJjaGJveEV4dHJhXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBub2RlX3R5cGUgdGhlIG5vZGUgcmVjb21tZW5kZWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIHRleHQgdG8gc2hvdyBuZXh0IHRvIGl0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGl0IGNvdWxkIGNvbnRhaW4gaW5mbyBvZiBob3cgdGhlIG5vZGUgc2hvdWxkIGJlIGNvbmZpZ3VyZWRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyU2VhcmNoYm94RXh0cmE6IGZ1bmN0aW9uKG5vZGVfdHlwZSwgZGVzY3JpcHRpb24sIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoYm94X2V4dHJhc1tkZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlX3R5cGUsXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHBlciB0byBsb2FkIGZpbGVzIChmcm9tIHVybCB1c2luZyBmZXRjaCBvciBmcm9tIGZpbGUgdXNpbmcgRmlsZVJlYWRlcilcbiAgICAgICAgICogQG1ldGhvZCBmZXRjaEZpbGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8RmlsZXxCbG9ifSB1cmwgdGhlIHVybCBvZiB0aGUgZmlsZSAob3IgdGhlIGZpbGUgaXRzZWxmKVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBhbiBzdHJpbmcgdG8ga25vdyBob3cgdG8gZmV0Y2ggaXQ6IFwidGV4dFwiLFwiYXJyYXlidWZmZXJcIixcImpzb25cIixcImJsb2JcIlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbl9jb21wbGV0ZSBjYWxsYmFjayhkYXRhKVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbl9lcnJvciBpbiBjYXNlIG9mIGFuIGVycm9yXG4gICAgICAgICAqIEByZXR1cm4ge0ZpbGVSZWFkZXJ8UHJvbWlzZX0gcmV0dXJucyB0aGUgb2JqZWN0IHVzZWQgdG8gXG4gICAgICAgICAqL1xuXHRcdGZldGNoRmlsZTogZnVuY3Rpb24oIHVybCwgdHlwZSwgb25fY29tcGxldGUsIG9uX2Vycm9yICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0aWYoIXVybClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwidGV4dFwiO1xuXHRcdFx0aWYoIHVybC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIClcblx0XHRcdHtcblx0XHRcdFx0aWYgKHVybC5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIgJiYgTGl0ZUdyYXBoLnByb3h5KSB7XG5cdFx0XHRcdFx0dXJsID0gTGl0ZUdyYXBoLnByb3h5ICsgdXJsLnN1YnN0cih1cmwuaW5kZXhPZihcIjpcIikgKyAzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmV0Y2godXJsKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdFx0XHRcdGlmKCFyZXNwb25zZS5vaylcblx0XHRcdFx0XHRcdCB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIG5vdCBmb3VuZFwiKTsgLy9pdCB3aWxsIGJlIGNhdGNoIGJlbG93XG5cdFx0XHRcdFx0aWYodHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblx0XHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJ0ZXh0XCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblx0XHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJqc29uXCIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0XHRcdGVsc2UgaWYodHlwZSA9PSBcImJsb2JcIilcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRpZihvbl9jb21wbGV0ZSlcblx0XHRcdFx0XHRcdG9uX2NvbXBsZXRlKGRhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiZXJyb3IgZmV0Y2hpbmcgZmlsZTpcIix1cmwpO1xuXHRcdFx0XHRcdGlmKG9uX2Vycm9yKVxuXHRcdFx0XHRcdFx0b25fZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIHVybC5jb25zdHJ1Y3RvciA9PT0gRmlsZSB8fCB1cmwuY29uc3RydWN0b3IgPT09IEJsb2IpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB2ID0gZS50YXJnZXQucmVzdWx0O1xuXHRcdFx0XHRcdGlmKCB0eXBlID09IFwianNvblwiIClcblx0XHRcdFx0XHRcdHYgPSBKU09OLnBhcnNlKHYpO1xuXHRcdFx0XHRcdGlmKG9uX2NvbXBsZXRlKVxuXHRcdFx0XHRcdFx0b25fY29tcGxldGUodik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih1cmwpO1xuXHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJ0ZXh0XCIgfHwgdHlwZSA9PSBcImpzb25cIilcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQodXJsKTtcblx0XHRcdFx0ZWxzZSBpZih0eXBlID09IFwiYmxvYlwiKVxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKHVybCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG4gICAgfSk7XG5cbiAgICAvL3RpbWVyIHRoYXQgd29ya3MgZXZlcnl3aGVyZVxuICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBMaXRlR3JhcGguZ2V0VGltZSA9IHBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBEYXRlICE9IFwidW5kZWZpbmVkXCIgJiYgRGF0ZS5ub3cpIHtcbiAgICAgICAgTGl0ZUdyYXBoLmdldFRpbWUgPSBEYXRlLm5vdy5iaW5kKERhdGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBMaXRlR3JhcGguZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRbMF0gKiAwLjAwMSArIHRbMV0gKiAxZS02O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIExpdGVHcmFwaC5nZXRUaW1lID0gZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vIExHcmFwaCBDTEFTU1xuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvKipcbiAgICAgKiBMR3JhcGggaXMgdGhlIGNsYXNzIHRoYXQgY29udGFpbiBhIGZ1bGwgZ3JhcGguIFdlIGluc3RhbnRpYXRlIG9uZSBhbmQgYWRkIG5vZGVzIHRvIGl0LCBhbmQgdGhlbiB3ZSBjYW4gcnVuIHRoZSBleGVjdXRpb24gbG9vcC5cblx0ICogc3VwcG9ydGVkIGNhbGxiYWNrczpcblx0XHQrIG9uTm9kZUFkZGVkOiB3aGVuIGEgbmV3IG5vZGUgaXMgYWRkZWQgdG8gdGhlIGdyYXBoXG5cdFx0KyBvbk5vZGVSZW1vdmVkOiB3aGVuIGEgbm9kZSBpbnNpZGUgdGhpcyBncmFwaCBpcyByZW1vdmVkXG5cdFx0KyBvbk5vZGVDb25uZWN0aW9uQ2hhbmdlOiBzb21lIGNvbm5lY3Rpb24gaGFzIGNoYW5nZWQgaW4gdGhlIGdyYXBoIChjb25uZWN0ZWQgb3IgZGlzY29ubmVjdGVkKVxuICAgICAqXG4gICAgICogQGNsYXNzIExHcmFwaFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvIGRhdGEgZnJvbSBwcmV2aW91cyBzZXJpYWxpemF0aW9uIFtvcHRpb25hbF1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExHcmFwaChvKSB7XG4gICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR3JhcGggY3JlYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKG8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2xvYmFsLkxHcmFwaCA9IExpdGVHcmFwaC5MR3JhcGggPSBMR3JhcGg7XG5cbiAgICAvL2RlZmF1bHQgc3VwcG9ydGVkIHR5cGVzXG4gICAgTEdyYXBoLnN1cHBvcnRlZF90eXBlcyA9IFtcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcImJvb2xlYW5cIl07XG5cbiAgICAvL3VzZWQgdG8ga25vdyB3aGljaCB0eXBlcyBvZiBjb25uZWN0aW9ucyBzdXBwb3J0IHRoaXMgZ3JhcGggKHNvbWUgZ3JhcGhzIGRvIG5vdCBhbGxvdyBjZXJ0YWluIHR5cGVzKVxuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0U3VwcG9ydGVkVHlwZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydGVkX3R5cGVzIHx8IExHcmFwaC5zdXBwb3J0ZWRfdHlwZXM7XG4gICAgfTtcblxuICAgIExHcmFwaC5TVEFUVVNfU1RPUFBFRCA9IDE7XG4gICAgTEdyYXBoLlNUQVRVU19SVU5OSU5HID0gMjtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG5vZGVzIGZyb20gdGhpcyBncmFwaFxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gTEdyYXBoLlNUQVRVU19TVE9QUEVEO1xuXG4gICAgICAgIHRoaXMubGFzdF9ub2RlX2lkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0X2xpbmtfaWQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSAtMTsgLy91c2VkIHRvIGRldGVjdCBjaGFuZ2VzXG5cbiAgICAgICAgLy9zYWZlIGNsZWFyXG4gICAgICAgIGlmICh0aGlzLl9ub2Rlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub25SZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUub25SZW1vdmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9ub2Rlc1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9ub2Rlc19ieV9pZCA9IHt9O1xuICAgICAgICB0aGlzLl9ub2Rlc19pbl9vcmRlciA9IFtdOyAvL25vZGVzIHNvcnRlZCBpbiBleGVjdXRpb24gb3JkZXJcbiAgICAgICAgdGhpcy5fbm9kZXNfZXhlY3V0YWJsZSA9IG51bGw7IC8vbm9kZXMgdGhhdCBjb250YWluIG9uRXhlY3V0ZSBzb3J0ZWQgaW4gZXhlY3V0aW9uIG9yZGVyXG5cbiAgICAgICAgLy9vdGhlciBzY2VuZSBzdHVmZlxuICAgICAgICB0aGlzLl9ncm91cHMgPSBbXTtcblxuICAgICAgICAvL2xpbmtzXG4gICAgICAgIHRoaXMubGlua3MgPSB7fTsgLy9jb250YWluZXIgd2l0aCBhbGwgdGhlIGxpbmtzXG5cbiAgICAgICAgLy9pdGVyYXRpb25zXG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gMDtcblxuICAgICAgICAvL2N1c3RvbSBkYXRhXG4gICAgICAgIHRoaXMuY29uZmlnID0ge307XG5cdFx0dGhpcy52YXJzID0ge307XG5cdFx0dGhpcy5leHRyYSA9IHt9OyAvL3RvIHN0b3JlIGN1c3RvbSBkYXRhXG5cbiAgICAgICAgLy90aW1pbmdcbiAgICAgICAgdGhpcy5nbG9iYWx0aW1lID0gMDtcbiAgICAgICAgdGhpcy5ydW5uaW5ndGltZSA9IDA7XG4gICAgICAgIHRoaXMuZml4ZWR0aW1lID0gMDtcbiAgICAgICAgdGhpcy5maXhlZHRpbWVfbGFwc2UgPSAwLjAxO1xuICAgICAgICB0aGlzLmVsYXBzZWRfdGltZSA9IDAuMDE7XG4gICAgICAgIHRoaXMubGFzdF91cGRhdGVfdGltZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnR0aW1lID0gMDtcblxuICAgICAgICB0aGlzLmNhdGNoX2Vycm9ycyA9IHRydWU7XG5cbiAgICAgICAgLy9zdWJncmFwaF9kYXRhXG4gICAgICAgIHRoaXMuaW5wdXRzID0ge307XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IHt9O1xuXG4gICAgICAgIC8vbm90aWZ5IGNhbnZhcyB0byByZWRyYXdcbiAgICAgICAgdGhpcy5jaGFuZ2UoKTtcblxuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcImNsZWFyXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggQ2FudmFzIHRvIHRoaXMgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIGF0dGFjaENhbnZhc1xuICAgICAqIEBwYXJhbSB7R3JhcGhDYW52YXN9IGdyYXBoX2NhbnZhc1xuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hdHRhY2hDYW52YXMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xuICAgICAgICBpZiAoZ3JhcGhjYW52YXMuY29uc3RydWN0b3IgIT0gTEdyYXBoQ2FudmFzKSB7XG4gICAgICAgICAgICB0aHJvdyBcImF0dGFjaENhbnZhcyBleHBlY3RzIGEgTEdyYXBoQ2FudmFzIGluc3RhbmNlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyYXBoY2FudmFzLmdyYXBoICYmIGdyYXBoY2FudmFzLmdyYXBoICE9IHRoaXMpIHtcbiAgICAgICAgICAgIGdyYXBoY2FudmFzLmdyYXBoLmRldGFjaENhbnZhcyhncmFwaGNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaGNhbnZhcy5ncmFwaCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5wdXNoKGdyYXBoY2FudmFzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIENhbnZhcyBmcm9tIHRoaXMgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIGRldGFjaENhbnZhc1xuICAgICAqIEBwYXJhbSB7R3JhcGhDYW52YXN9IGdyYXBoX2NhbnZhc1xuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZGV0YWNoQ2FudmFzID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMuaW5kZXhPZihncmFwaGNhbnZhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBncmFwaGNhbnZhcy5ncmFwaCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5zcGxpY2UocG9zLCAxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHJ1bm5pbmcgdGhpcyBncmFwaCBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gICAgICogQG1ldGhvZCBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gZXhlY3V0aW9ucywgaWYgMCB0aGVuIGl0IHJlbmRlcnMgdG8gdGhlIG1vbml0b3IgcmVmcmVzaCByYXRlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzID0gTEdyYXBoLlNUQVRVU19SVU5OSU5HO1xuXG4gICAgICAgIGlmICh0aGlzLm9uUGxheUV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9uUGxheUV2ZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbmRFdmVudFRvQWxsTm9kZXMoXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIC8vbGF1bmNoXG4gICAgICAgIHRoaXMuc3RhcnR0aW1lID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5sYXN0X3VwZGF0ZV90aW1lID0gdGhpcy5zdGFydHRpbWU7XG4gICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMDtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly9leGVjdXRlIG9uY2UgcGVyIGZyYW1lXG4gICAgICAgIGlmICggaW50ZXJ2YWwgPT0gMCAmJiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uX2ZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmV4ZWN1dGlvbl90aW1lcl9pZCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25fZnJhbWUpO1xuXHRcdFx0XHRpZih0aGF0Lm9uQmVmb3JlU3RlcClcblx0XHRcdFx0XHR0aGF0Lm9uQmVmb3JlU3RlcCgpO1xuICAgICAgICAgICAgICAgIHRoYXQucnVuU3RlcCgxLCAhdGhhdC5jYXRjaF9lcnJvcnMpO1xuXHRcdFx0XHRpZih0aGF0Lm9uQWZ0ZXJTdGVwKVxuXHRcdFx0XHRcdHRoYXQub25BZnRlclN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uX3RpbWVyX2lkID0gLTE7XG4gICAgICAgICAgICBvbl9mcmFtZSgpO1xuICAgICAgICB9IGVsc2UgeyAvL2V4ZWN1dGUgZXZlcnkgJ2ludGVydmFsJyBtc1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25fdGltZXJfaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL2V4ZWN1dGVcblx0XHRcdFx0aWYodGhhdC5vbkJlZm9yZVN0ZXApXG5cdFx0XHRcdFx0dGhhdC5vbkJlZm9yZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICB0aGF0LnJ1blN0ZXAoMSwgIXRoYXQuY2F0Y2hfZXJyb3JzKTtcblx0XHRcdFx0aWYodGhhdC5vbkFmdGVyU3RlcClcblx0XHRcdFx0XHR0aGF0Lm9uQWZ0ZXJTdGVwKCk7XG4gICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGV4ZWN1dGlvbiBsb29wIG9mIHRoZSBncmFwaFxuICAgICAqIEBtZXRob2Qgc3RvcCBleGVjdXRpb25cbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gTEdyYXBoLlNUQVRVU19TVE9QUEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXR1cyA9IExHcmFwaC5TVEFUVVNfU1RPUFBFRDtcblxuICAgICAgICBpZiAodGhpcy5vblN0b3BFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5vblN0b3BFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uX3RpbWVyX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvbl90aW1lcl9pZCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5leGVjdXRpb25fdGltZXJfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25fdGltZXJfaWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZW5kRXZlbnRUb0FsbE5vZGVzKFwib25TdG9wXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSdW4gTiBzdGVwcyAoY3ljbGVzKSBvZiB0aGUgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIHJ1blN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIG51bWJlciBvZiBzdGVwcyB0byBydW4sIGRlZmF1bHQgaXMgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG9fbm90X2NhdGNoX2Vycm9ycyBbb3B0aW9uYWxdIGlmIHlvdSB3YW50IHRvIHRyeS9jYXRjaCBlcnJvcnMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IG1heCBudW1iZXIgb2Ygbm9kZXMgdG8gZXhlY3V0ZSAodXNlZCB0byBleGVjdXRlIGZyb20gc3RhcnQgdG8gYSBub2RlKVxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5ydW5TdGVwID0gZnVuY3Rpb24obnVtLCBkb19ub3RfY2F0Y2hfZXJyb3JzLCBsaW1pdCApIHtcbiAgICAgICAgbnVtID0gbnVtIHx8IDE7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5nbG9iYWx0aW1lID0gMC4wMDEgKiAoc3RhcnQgLSB0aGlzLnN0YXJ0dGltZSk7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fbm9kZXNfZXhlY3V0YWJsZVxuICAgICAgICAgICAgPyB0aGlzLl9ub2Rlc19leGVjdXRhYmxlXG4gICAgICAgICAgICA6IHRoaXMuX25vZGVzO1xuICAgICAgICBpZiAoIW5vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXHRcdGxpbWl0ID0gbGltaXQgfHwgbm9kZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChkb19ub3RfY2F0Y2hfZXJyb3JzKSB7XG4gICAgICAgICAgICAvL2l0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubW9kZSA9PSBMaXRlR3JhcGguQUxXQVlTICYmIG5vZGUub25FeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uRXhlY3V0ZSgpOyAvL2hhcmQgdG8gc2VuZCBlbGFwc2VkIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZml4ZWR0aW1lICs9IHRoaXMuZml4ZWR0aW1lX2xhcHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uRXhlY3V0ZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGVTdGVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vbkFmdGVyRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25BZnRlckV4ZWN1dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy9pdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5tb2RlID09IExpdGVHcmFwaC5BTFdBWVMgJiYgbm9kZS5vbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uRXhlY3V0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhlZHRpbWUgKz0gdGhpcy5maXhlZHRpbWVfbGFwc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uRXhlY3V0ZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25FeGVjdXRlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25BZnRlckV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkFmdGVyRXhlY3V0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yc19pbl9leGVjdXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzX2luX2V4ZWN1dGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC50aHJvd19lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZHVyaW5nIGV4ZWN1dGlvbjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IG5vdyAtIHN0YXJ0O1xuICAgICAgICBpZiAoZWxhcHNlZCA9PSAwKSB7XG4gICAgICAgICAgICBlbGFwc2VkID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4ZWN1dGlvbl90aW1lID0gMC4wMDEgKiBlbGFwc2VkO1xuICAgICAgICB0aGlzLmdsb2JhbHRpbWUgKz0gMC4wMDEgKiBlbGFwc2VkO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiArPSAxO1xuICAgICAgICB0aGlzLmVsYXBzZWRfdGltZSA9IChub3cgLSB0aGlzLmxhc3RfdXBkYXRlX3RpbWUpICogMC4wMDE7XG4gICAgICAgIHRoaXMubGFzdF91cGRhdGVfdGltZSA9IG5vdztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ3JhcGggZXhlY3V0aW9uIG9yZGVyIGFjY29yZGluZyB0byByZWxldmFuY2Ugb2YgdGhlIG5vZGVzIChub2RlcyB3aXRoIG9ubHkgb3V0cHV0cyBoYXZlIG1vcmUgcmVsZXZhbmNlIHRoYW5cbiAgICAgKiBub2RlcyB3aXRoIG9ubHkgaW5wdXRzLlxuICAgICAqIEBtZXRob2QgdXBkYXRlRXhlY3V0aW9uT3JkZXJcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX25vZGVzX2luX29yZGVyID0gdGhpcy5jb21wdXRlRXhlY3V0aW9uT3JkZXIoZmFsc2UpO1xuICAgICAgICB0aGlzLl9ub2Rlc19leGVjdXRhYmxlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXNfaW5fb3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlc19pbl9vcmRlcltpXS5vbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc19leGVjdXRhYmxlLnB1c2godGhpcy5fbm9kZXNfaW5fb3JkZXJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vVGhpcyBpcyBtb3JlIGludGVybmFsLCBpdCBjb21wdXRlcyB0aGUgZXhlY3V0YWJsZSBub2RlcyBpbiBvcmRlciBhbmQgcmV0dXJucyBpdFxuICAgIExHcmFwaC5wcm90b3R5cGUuY29tcHV0ZUV4ZWN1dGlvbk9yZGVyID0gZnVuY3Rpb24oXG4gICAgICAgIG9ubHlfb25FeGVjdXRlLFxuICAgICAgICBzZXRfbGV2ZWxcbiAgICApIHtcbiAgICAgICAgdmFyIEwgPSBbXTtcbiAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgdmFyIE0gPSB7fTtcbiAgICAgICAgdmFyIHZpc2l0ZWRfbGlua3MgPSB7fTsgLy90byBhdm9pZCByZXBlYXRpbmcgbGlua3NcbiAgICAgICAgdmFyIHJlbWFpbmluZ19saW5rcyA9IHt9OyAvL3RvIGFcblxuICAgICAgICAvL3NlYXJjaCBmb3IgdGhlIG5vZGVzIHdpdGhvdXQgaW5wdXRzIChzdGFydGluZyBub2RlcylcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAob25seV9vbkV4ZWN1dGUgJiYgIW5vZGUub25FeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1bbm9kZS5pZF0gPSBub2RlOyAvL2FkZCB0byBwZW5kaW5nIG5vZGVzXG5cbiAgICAgICAgICAgIHZhciBudW0gPSAwOyAvL251bSBvZiBpbnB1dCBjb25uZWN0aW9uc1xuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwyID0gbm9kZS5pbnB1dHMubGVuZ3RoOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbnB1dHNbal0gJiYgbm9kZS5pbnB1dHNbal0ubGluayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9pcyBhIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgICAgICBTLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNldF9sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9sZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvL251bSBvZiBpbnB1dCBsaW5rc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldF9sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9sZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ19saW5rc1tub2RlLmlkXSA9IG51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoUy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2dldCBhbiBzdGFydGluZyBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IFMuc2hpZnQoKTtcbiAgICAgICAgICAgIEwucHVzaChub2RlKTsgLy9hZGQgdG8gb3JkZXJlZCBsaXN0XG4gICAgICAgICAgICBkZWxldGUgTVtub2RlLmlkXTsgLy9yZW1vdmUgZnJvbSB0aGUgcGVuZGluZyBub2Rlc1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZvciBldmVyeSBvdXRwdXRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICAvL25vdCBjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5saW5rcyA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5saW5rcy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2ZvciBldmVyeSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXQubGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSBvdXRwdXQubGlua3Nbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vYWxyZWFkeSB2aXNpdGVkIGxpbmsgKGlnbm9yZSBpdClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRfbGlua3NbbGluay5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldF9ub2RlID0gdGhpcy5nZXROb2RlQnlJZChsaW5rLnRhcmdldF9pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkX2xpbmtzW2xpbmsuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0X2xldmVsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXRhcmdldF9ub2RlLl9sZXZlbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlLl9sZXZlbCA8PSBub2RlLl9sZXZlbClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZS5fbGV2ZWwgPSBub2RlLl9sZXZlbCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkX2xpbmtzW2xpbmsuaWRdID0gdHJ1ZTsgLy9tYXJrIGFzIHZpc2l0ZWRcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nX2xpbmtzW3RhcmdldF9ub2RlLmlkXSAtPSAxOyAvL3JlZHVjZSB0aGUgbnVtYmVyIG9mIGxpbmtzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nX2xpbmtzW3RhcmdldF9ub2RlLmlkXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTLnB1c2godGFyZ2V0X25vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vaWYgbm8gbW9yZSBsaW5rcywgdGhlbiBhZGQgdG8gc3RhcnRlcnMgYXJyYXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoZSByZW1haW5pbmcgb25lcyAobG9vcHMpXG4gICAgICAgIGZvciAodmFyIGkgaW4gTSkge1xuICAgICAgICAgICAgTC5wdXNoKE1baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEwubGVuZ3RoICE9IHRoaXMuX25vZGVzLmxlbmd0aCAmJiBMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNvbWV0aGluZyB3ZW50IHdyb25nLCBub2RlcyBtaXNzaW5nXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGwgPSBMLmxlbmd0aDtcblxuICAgICAgICAvL3NhdmUgb3JkZXIgbnVtYmVyIGluIHRoZSBub2RlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBMW2ldLm9yZGVyID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc29ydCBub3cgYnkgcHJpb3JpdHlcbiAgICAgICAgTCA9IEwuc29ydChmdW5jdGlvbihBLCBCKSB7XG4gICAgICAgICAgICB2YXIgQXAgPSBBLmNvbnN0cnVjdG9yLnByaW9yaXR5IHx8IEEucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgICAgIHZhciBCcCA9IEIuY29uc3RydWN0b3IucHJpb3JpdHkgfHwgQi5wcmlvcml0eSB8fCAwO1xuICAgICAgICAgICAgaWYgKEFwID09IEJwKSB7XG4gICAgICAgICAgICAgICAgLy9pZiBzYW1lIHByaW9yaXR5LCBzb3J0IGJ5IG9yZGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEEub3JkZXIgLSBCLm9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFwIC0gQnA7IC8vc29ydCBieSBwcmlvcml0eVxuICAgICAgICB9KTtcblxuICAgICAgICAvL3NhdmUgb3JkZXIgbnVtYmVyIGluIHRoZSBub2RlLCBhZ2Fpbi4uLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgTFtpXS5vcmRlciA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIG5vZGVzIHRoYXQgY291bGQgYWZmZWN0IHRoaXMgb25lIChhbmNlc3RvcnMpIGJ5IGNyYXdsaW5nIGFsbCB0aGUgaW5wdXRzIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEl0IGRvZXNuJ3QgaW5jbHVkZSB0aGUgbm9kZSBpdHNlbGZcbiAgICAgKiBAbWV0aG9kIGdldEFuY2VzdG9yc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSB3aXRoIGFsbCB0aGUgTEdyYXBoTm9kZXMgdGhhdCBhZmZlY3QgdGhpcyBub2RlLCBpbiBvcmRlciBvZiBleGVjdXRpb25cbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldEFuY2VzdG9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgcGVuZGluZyA9IFtub2RlXTtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICAgICAgICB3aGlsZSAocGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50LmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2N1cnJlbnQuaWRdICYmIGN1cnJlbnQgIT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbY3VycmVudC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gY3VycmVudC5nZXRJbnB1dE5vZGUoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ICYmIGFuY2VzdG9ycy5pbmRleE9mKGlucHV0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFuY2VzdG9ycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9ucyBldmVyeSBub2RlIGluIGEgbW9yZSByZWFkYWJsZSBtYW5uZXJcbiAgICAgKiBAbWV0aG9kIGFycmFuZ2VcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmFycmFuZ2UgPSBmdW5jdGlvbihtYXJnaW4pIHtcbiAgICAgICAgbWFyZ2luID0gbWFyZ2luIHx8IDEwMDtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmNvbXB1dGVFeGVjdXRpb25PcmRlcihmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBjb2x1bW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICB2YXIgY29sID0gbm9kZS5fbGV2ZWwgfHwgMTtcbiAgICAgICAgICAgIGlmICghY29sdW1uc1tjb2xdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uc1tjb2xdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2x1bW5zW2NvbF0ucHVzaChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gbWFyZ2luO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1heF9zaXplID0gMTAwO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXJnaW4gKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gY29sdW1uW2pdO1xuICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdID0geDtcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSA9IHk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc2l6ZVswXSA+IG1heF9zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heF9zaXplID0gbm9kZS5zaXplWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ICs9IG5vZGUuc2l6ZVsxXSArIG1hcmdpbiArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gbWF4X3NpemUgKyBtYXJnaW47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0aGUgZ3JhcGggaGFzIGJlZW4gcnVubmluZyBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAbWV0aG9kIGdldFRpbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhlIGdyYXBoIGhhcyBiZWVuIHJ1bm5pbmdcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsdGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgYWNjdW11bGF0ZWQgdXNpbmcgdGhlIGZpeGVkdGltZV9sYXBzZSB2YXIuIFRoaXMgaXMgdXNlZCBpbiBjb250ZXh0IHdoZXJlIHRoZSB0aW1lIGluY3JlbWVudHMgc2hvdWxkIGJlIGNvbnN0YW50XG4gICAgICogQG1ldGhvZCBnZXRGaXhlZFRpbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhlIGdyYXBoIGhhcyBiZWVuIHJ1bm5pbmdcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0Rml4ZWRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpeGVkdGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgaXQgdG9vayB0byBjb21wdXRlIHRoZSBsYXRlc3QgaXRlcmF0aW9uLiBUYWtlIGludG8gYWNjb3VudCB0aGF0IHRoaXMgbnVtYmVyIGNvdWxkIGJlIG5vdCBjb3JyZWN0XG4gICAgICogaWYgdGhlIG5vZGVzIGFyZSB1c2luZyBncmFwaGljYWwgYWN0aW9uc1xuICAgICAqIEBtZXRob2QgZ2V0RWxhcHNlZFRpbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayB0aGUgbGFzdCBjeWNsZVxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRFbGFwc2VkVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGFwc2VkX3RpbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGV2ZW50IHRvIGFsbCB0aGUgbm9kZXMsIHVzZWZ1bCB0byB0cmlnZ2VyIHN0dWZmXG4gICAgICogQG1ldGhvZCBzZW5kRXZlbnRUb0FsbE5vZGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50bmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGZ1bmN0aW9uIHRvIGJlIGNhbGxlZClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgcGFyYW1ldGVycyBpbiBhcnJheSBmb3JtYXRcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnNlbmRFdmVudFRvQWxsTm9kZXMgPSBmdW5jdGlvbihldmVudG5hbWUsIHBhcmFtcywgbW9kZSkge1xuICAgICAgICBtb2RlID0gbW9kZSB8fCBMaXRlR3JhcGguQUxXQVlTO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuX25vZGVzX2luX29yZGVyID8gdGhpcy5fbm9kZXNfaW5fb3JkZXIgOiB0aGlzLl9ub2RlcztcbiAgICAgICAgaWYgKCFub2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGogPCBsOyArK2opIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbal07XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmNvbnN0cnVjdG9yID09PSBMaXRlR3JhcGguU3ViZ3JhcGggJiZcbiAgICAgICAgICAgICAgICBldmVudG5hbWUgIT0gXCJvbkV4ZWN1dGVcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubW9kZSA9PSBtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2VuZEV2ZW50VG9BbGxOb2RlcyhldmVudG5hbWUsIHBhcmFtcywgbW9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5vZGVbZXZlbnRuYW1lXSB8fCBub2RlLm1vZGUgIT0gbW9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtldmVudG5hbWVdKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcyAmJiBwYXJhbXMuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgbm9kZVtldmVudG5hbWVdLmFwcGx5KG5vZGUsIHBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVbZXZlbnRuYW1lXShwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaC5wcm90b3R5cGUuc2VuZEFjdGlvblRvQ2FudmFzID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0X29mX2dyYXBoY2FudmFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhc1tpXTtcbiAgICAgICAgICAgIGlmIChjW2FjdGlvbl0pIHtcbiAgICAgICAgICAgICAgICBjW2FjdGlvbl0uYXBwbHkoYywgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IG5vZGUgaW5zdGFuY2UgdG8gdGhpcyBncmFwaFxuICAgICAqIEBtZXRob2QgYWRkXG4gICAgICogQHBhcmFtIHtMR3JhcGhOb2RlfSBub2RlIHRoZSBpbnN0YW5jZSBvZiB0aGUgbm9kZVxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihub2RlLCBza2lwX2NvbXB1dGVfb3JkZXIpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2dyb3Vwc1xuICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gTEdyYXBoR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCk7XG4gICAgICAgICAgICBub2RlLmdyYXBoID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9kZXNcbiAgICAgICAgaWYgKG5vZGUuaWQgIT0gLTEgJiYgdGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiTGl0ZUdyYXBoOiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZSB3aXRoIHRoaXMgSUQsIGNoYW5naW5nIGl0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmlkID0gKyt0aGlzLmxhc3Rfbm9kZV9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ub2Rlcy5sZW5ndGggPj0gTGl0ZUdyYXBoLk1BWF9OVU1CRVJfT0ZfTk9ERVMpIHtcbiAgICAgICAgICAgIHRocm93IFwiTGl0ZUdyYXBoOiBtYXggbnVtYmVyIG9mIG5vZGVzIGluIGEgZ3JhcGggcmVhY2hlZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9naXZlIGhpbSBhbiBpZFxuICAgICAgICBpZiAobm9kZS5pZCA9PSBudWxsIHx8IG5vZGUuaWQgPT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUuaWQgPSArK3RoaXMubGFzdF9ub2RlX2lkO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdF9ub2RlX2lkIDwgbm9kZS5pZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0X25vZGVfaWQgPSBub2RlLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5ncmFwaCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLl9ub2Rlc19ieV9pZFtub2RlLmlkXSA9IG5vZGU7XG5cbiAgICAgICAgaWYgKG5vZGUub25BZGRlZCkge1xuICAgICAgICAgICAgbm9kZS5vbkFkZGVkKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFsaWduX3RvX2dyaWQpIHtcbiAgICAgICAgICAgIG5vZGUuYWxpZ25Ub0dyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcF9jb21wdXRlX29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbk5vZGVBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vZGVBZGRlZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7IC8vdG8gY2hhaW4gYWN0aW9uc1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBncmFwaFxuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtIHtMR3JhcGhOb2RlfSBub2RlIHRoZSBpbnN0YW5jZSBvZiB0aGUgbm9kZVxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbnN0cnVjdG9yID09PSBMaXRlR3JhcGguTEdyYXBoR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2dyb3Vwcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmdyYXBoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX25vZGVzX2J5X2lkW25vZGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvL25vdCBmb3VuZFxuXG4gICAgICAgIGlmIChub2RlLmlnbm9yZV9yZW1vdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvL2Nhbm5vdCBiZSByZW1vdmVkXG5cblx0XHR0aGlzLmJlZm9yZUNoYW5nZSgpOyAvL3N1cmU/XG5cbiAgICAgICAgLy9kaXNjb25uZWN0IGlucHV0c1xuICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzbG90LmxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3RJbnB1dChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2Rpc2Nvbm5lY3Qgb3V0cHV0c1xuICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzbG90LmxpbmtzICE9IG51bGwgJiYgc2xvdC5saW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0T3V0cHV0KGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9kZS5pZCA9IC0xOyAvL3doeT9cblxuICAgICAgICAvL2NhbGxiYWNrXG4gICAgICAgIGlmIChub2RlLm9uUmVtb3ZlZCkge1xuICAgICAgICAgICAgbm9kZS5vblJlbW92ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZ3JhcGggPSBudWxsO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgLy9yZW1vdmUgZnJvbSBjYW52YXMgcmVuZGVyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0X29mX2dyYXBoY2FudmFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYW52YXMuc2VsZWN0ZWRfbm9kZXNbbm9kZS5pZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMubm9kZV9kcmFnZ2VkID09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLm5vZGVfZHJhZ2dlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW1vdmUgZnJvbSBjb250YWluZXJzXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAocG9zICE9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5zcGxpY2UocG9zLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF07XG5cbiAgICAgICAgaWYgKHRoaXMub25Ob2RlUmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vZGVSZW1vdmVkKG5vZGUpO1xuICAgICAgICB9XG5cblx0XHQvL2Nsb3NlIHBhbmVsc1xuXHRcdHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwiY2hlY2tQYW5lbHNcIik7XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcblx0XHR0aGlzLmFmdGVyQ2hhbmdlKCk7IC8vc3VyZT9cbiAgICAgICAgdGhpcy5jaGFuZ2UoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub2RlIGJ5IGl0cyBpZC5cbiAgICAgKiBAbWV0aG9kIGdldE5vZGVCeUlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc19ieV9pZFtpZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgbWF0Y2hlcyBhIGNsYXNzXG4gICAgICogQG1ldGhvZCBmaW5kTm9kZXNCeUNsYXNzXG4gICAgICogQHBhcmFtIHtDbGFzc30gY2xhc3NPYmplY3QgdGhlIGNsYXNzIGl0c2VsZiAobm90IGFuIHN0cmluZylcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlcyBvZiB0aGlzIHR5cGVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmZpbmROb2Rlc0J5Q2xhc3MgPSBmdW5jdGlvbihjbGFzc09iamVjdCwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZXNbaV0uY29uc3RydWN0b3IgPT09IGNsYXNzT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgbWF0Y2hlcyBhIHR5cGVcbiAgICAgKiBAbWV0aG9kIGZpbmROb2Rlc0J5VHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlcyBvZiB0aGlzIHR5cGVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmZpbmROb2Rlc0J5VHlwZSA9IGZ1bmN0aW9uKHR5cGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS50eXBlLnRvTG93ZXJDYXNlKCkgPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIHRoYXQgbWF0Y2hlcyBhIG5hbWUgaW4gaXRzIHRpdGxlXG4gICAgICogQG1ldGhvZCBmaW5kTm9kZUJ5VGl0bGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgbm9kZSB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSB0aGUgbm9kZSBvciBudWxsXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5maW5kTm9kZUJ5VGl0bGUgPSBmdW5jdGlvbih0aXRsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX25vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGVzW2ldLnRpdGxlID09IHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IG1hdGNoZXMgYSBuYW1lXG4gICAgICogQG1ldGhvZCBmaW5kTm9kZXNCeVRpdGxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG5vZGUgdG8gc2VhcmNoXG4gICAgICogQHJldHVybiB7QXJyYXl9IGEgbGlzdCB3aXRoIGFsbCB0aGUgbm9kZXMgd2l0aCB0aGlzIG5hbWVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmZpbmROb2Rlc0J5VGl0bGUgPSBmdW5jdGlvbih0aXRsZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZXNbaV0udGl0bGUgPT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9ub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG9wLW1vc3Qgbm9kZSBpbiB0aGlzIHBvc2l0aW9uIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIGdldE5vZGVPblBvc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGUgaW4gY2FudmFzIHNwYWNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSBpbiBjYW52YXMgc3BhY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2Rlc19saXN0IGEgbGlzdCB3aXRoIGFsbCB0aGUgbm9kZXMgdG8gc2VhcmNoIGZyb20sIGJ5IGRlZmF1bHQgaXMgYWxsIHRoZSBub2RlcyBpbiB0aGUgZ3JhcGhcbiAgICAgKiBAcmV0dXJuIHtMR3JhcGhOb2RlfSB0aGUgbm9kZSBhdCB0aGlzIHBvc2l0aW9uIG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldE5vZGVPblBvcyA9IGZ1bmN0aW9uKHgsIHksIG5vZGVzX2xpc3QsIG1hcmdpbikge1xuICAgICAgICBub2Rlc19saXN0ID0gbm9kZXNfbGlzdCB8fCB0aGlzLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGVzX2xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBuID0gbm9kZXNfbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChuLmlzUG9pbnRJbnNpZGUoeCwgeSwgbWFyZ2luKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AtbW9zdCBncm91cCBpbiB0aGF0IHBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXRHcm91cE9uUG9zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSBpbiBjYW52YXMgc3BhY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIGluIGNhbnZhcyBzcGFjZVxuICAgICAqIEByZXR1cm4ge0xHcmFwaEdyb3VwfSB0aGUgZ3JvdXAgb3IgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0R3JvdXBPblBvcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2dyb3Vwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLl9ncm91cHNbaV07XG4gICAgICAgICAgICBpZiAoZy5pc1BvaW50SW5zaWRlKHgsIHksIDIsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHRoZSBub2RlIHR5cGUgbWF0Y2hlcyB0aGUgbm9kZSB0eXBlIHJlZ2lzdGVyZWQsIHVzZWQgd2hlbiByZXBsYWNpbmcgYSBub2RldHlwZSBieSBhIG5ld2VyIHZlcnNpb24gZHVyaW5nIGV4ZWN1dGlvblxuICAgICAqIHRoaXMgcmVwbGFjZXMgdGhlIG9uZXMgdXNpbmcgdGhlIG9sZCB2ZXJzaW9uIHdpdGggdGhlIG5ldyB2ZXJzaW9uXG4gICAgICogQG1ldGhvZCBjaGVja05vZGVUeXBlc1xuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY2hlY2tOb2RlVHlwZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBjdG9yID0gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT0gY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJub2RlIGJlaW5nIHJlcGxhY2VkIGJ5IG5ld2VyIHZlcnNpb246IFwiICsgbm9kZS50eXBlKTtcbiAgICAgICAgICAgIHZhciBuZXdub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbaV0gPSBuZXdub2RlO1xuICAgICAgICAgICAgbmV3bm9kZS5jb25maWd1cmUobm9kZS5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICBuZXdub2RlLmdyYXBoID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX25vZGVzX2J5X2lkW25ld25vZGUuaWRdID0gbmV3bm9kZTtcbiAgICAgICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIG5ld25vZGUuaW5wdXRzID0gbm9kZS5pbnB1dHMuY29uY2F0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgbmV3bm9kZS5vdXRwdXRzID0gbm9kZS5vdXRwdXRzLmNvbmNhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRXhlY3V0aW9uT3JkZXIoKTtcbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKiBHTE9CQUxTICoqKioqKioqKioqKioqKioqXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICB0aGlzLl9pbnB1dF9ub2RlcyA9IHRoaXMuZmluZE5vZGVzQnlDbGFzcyhcbiAgICAgICAgICAgIExpdGVHcmFwaC5HcmFwaElucHV0LFxuICAgICAgICAgICAgdGhpcy5faW5wdXRfbm9kZXNcbiAgICAgICAgKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnB1dF9ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9pbnB1dF9ub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChub2RlLnByb3BlcnRpZXMubmFtZSAhPSBhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUub25BY3Rpb24oYWN0aW9uLCBwYXJhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIGlmICh0aGlzLm9uVHJpZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vblRyaWdnZXIoYWN0aW9uLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVsbCB0aGlzIGdyYXBoIGl0IGhhcyBhIGdsb2JhbCBncmFwaCBpbnB1dCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAbWV0aG9kIGFkZEdsb2JhbElucHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgW29wdGlvbmFsXVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuYWRkSW5wdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAvL2FscmVhZHkgZXhpc3RcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0dGhpcy5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5pbnB1dHNbbmFtZV0gPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cdFx0dGhpcy5hZnRlckNoYW5nZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0QWRkZWQobmFtZSwgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgZGF0YSB0byB0aGUgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCBzZXRHbG9iYWxJbnB1dERhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2V0SW5wdXREYXRhID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnZhbHVlID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIGdsb2JhbCBncmFwaCBpbnB1dFxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXREYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgZGF0YVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0SW5wdXREYXRhID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBuYW1lIG9mIGEgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCByZW5hbWVJbnB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdfbmFtZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUucmVuYW1lSW5wdXQgPSBmdW5jdGlvbihvbGRfbmFtZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBvbGRfbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0c1tvbGRfbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlucHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInRoZXJlIGlzIGFscmVhZHkgb25lIGlucHV0IHdpdGggdGhhdCBuYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dHNbbmFtZV0gPSB0aGlzLmlucHV0c1tvbGRfbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlucHV0c1tvbGRfbmFtZV07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbklucHV0UmVuYW1lZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0UmVuYW1lZChvbGRfbmFtZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdHlwZSBvZiBhIGdsb2JhbCBncmFwaCBpbnB1dFxuICAgICAqIEBtZXRob2QgY2hhbmdlSW5wdXRUeXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY2hhbmdlSW5wdXRUeXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlucHV0c1tuYW1lXS50eXBlICYmXG4gICAgICAgICAgICBTdHJpbmcodGhpcy5pbnB1dHNbbmFtZV0udHlwZSkudG9Mb3dlckNhc2UoKSA9PVxuICAgICAgICAgICAgICAgIFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dHNbbmFtZV0udHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgaWYgKHRoaXMub25JbnB1dFR5cGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRUeXBlQ2hhbmdlZChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCByZW1vdmVJbnB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZUlucHV0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5pbnB1dHNbbmFtZV07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbklucHV0UmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0UmVtb3ZlZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdsb2JhbCBncmFwaCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIGFkZE91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hZGRPdXRwdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm91dHB1dHNbbmFtZV0gPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dEFkZGVkKG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIGRhdGEgdG8gdGhlIGdsb2JhbCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIHNldE91dHB1dERhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbbmFtZV07XG4gICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBnbG9iYWwgZ3JhcGggb3V0cHV0XG4gICAgICogQG1ldGhvZCBnZXRPdXRwdXREYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgZGF0YVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQudmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmFtZXMgYSBnbG9iYWwgZ3JhcGggb3V0cHV0XG4gICAgICogQG1ldGhvZCByZW5hbWVPdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkX25hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3X25hbWVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbmFtZU91dHB1dCA9IGZ1bmN0aW9uKG9sZF9uYW1lLCBuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzW29sZF9uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInRoZXJlIGlzIGFscmVhZHkgb25lIG91dHB1dCB3aXRoIHRoYXQgbmFtZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0cHV0c1tuYW1lXSA9IHRoaXMub3V0cHV0c1tvbGRfbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dHNbb2xkX25hbWVdO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRSZW5hbWVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0UmVuYW1lZChvbGRfbmFtZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdHlwZSBvZiBhIGdsb2JhbCBncmFwaCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIGNoYW5nZU91dHB1dFR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5jaGFuZ2VPdXRwdXRUeXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzW25hbWVdLnR5cGUgJiZcbiAgICAgICAgICAgIFN0cmluZyh0aGlzLm91dHB1dHNbbmFtZV0udHlwZSkudG9Mb3dlckNhc2UoKSA9PVxuICAgICAgICAgICAgICAgIFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRwdXRzW25hbWVdLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG4gICAgICAgIGlmICh0aGlzLm9uT3V0cHV0VHlwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25PdXRwdXRUeXBlQ2hhbmdlZChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2xvYmFsIGdyYXBoIG91dHB1dFxuICAgICAqIEBtZXRob2QgcmVtb3ZlT3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5vdXRwdXRzW25hbWVdO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0UmVtb3ZlZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS50cmlnZ2VySW5wdXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmZpbmROb2Rlc0J5VGl0bGUobmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5vZGVzW2ldLm9uVHJpZ2dlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXRDYWxsYmFjayA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5maW5kTm9kZXNCeVRpdGxlKG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBub2Rlc1tpXS5zZXRUcmlnZ2VyKGZ1bmMpO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvL3VzZWQgZm9yIHVuZG8sIGNhbGxlZCBiZWZvcmUgYW55IGNoYW5nZSBpcyBtYWRlIHRvIHRoZSBncmFwaFxuICAgIExHcmFwaC5wcm90b3R5cGUuYmVmb3JlQ2hhbmdlID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgICBpZiAodGhpcy5vbkJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUNoYW5nZSh0aGlzLGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwib25CZWZvcmVDaGFuZ2VcIiwgdGhpcyk7XG4gICAgfTtcblxuXHQvL3VzZWQgdG8gcmVzZW5kIGFjdGlvbnMsIGNhbGxlZCBhZnRlciBhbnkgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIGdyYXBoXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hZnRlckNoYW5nZSA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMub25BZnRlckNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbkFmdGVyQ2hhbmdlKHRoaXMsaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kQWN0aW9uVG9DYW52YXMoXCJvbkFmdGVyQ2hhbmdlXCIsIHRoaXMpO1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmNvbm5lY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbihub2RlLCBsaW5rX2luZm8pIHtcbiAgICAgICAgdGhpcy51cGRhdGVFeGVjdXRpb25PcmRlcigpO1xuICAgICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uQ2hhbmdlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zZW5kQWN0aW9uVG9DYW52YXMoXCJvbkNvbm5lY3Rpb25DaGFuZ2VcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgaWYgdGhlIGdyYXBoIGlzIGluIGxpdmUgbW9kZVxuICAgICAqIEBtZXRob2QgaXNMaXZlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmlzTGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5saXN0X29mX2dyYXBoY2FudmFzW2ldO1xuICAgICAgICAgICAgaWYgKGMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHRyaWdnZXJlZCBzbG90IGFuaW1hdGlvbiBpbiBhbGwgbGlua3MgKHN0b3AgdmlzdWFsIGFuaW1hdGlvbilcbiAgICAgKiBAbWV0aG9kIGNsZWFyVHJpZ2dlcmVkU2xvdHNcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmNsZWFyVHJpZ2dlcmVkU2xvdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmxpbmtzKSB7XG4gICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5saW5rc1tpXTtcbiAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlua19pbmZvLl9sYXN0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICBsaW5rX2luZm8uX2xhc3RfdGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogQ2FsbGVkIHdoZW4gc29tZXRoaW5nIHZpc3VhbGx5IGNoYW5nZWQgKG5vdCB0aGUgZ3JhcGghKSAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR3JhcGggY2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcInNldERpcnR5XCIsIFt0cnVlLCB0cnVlXSk7XG4gICAgICAgIGlmICh0aGlzLm9uX2NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbl9jaGFuZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXREaXJ0eUNhbnZhcyA9IGZ1bmN0aW9uKGZnLCBiZykge1xuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcInNldERpcnR5XCIsIFtmZywgYmddKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBsaW5rXG4gICAgICogQG1ldGhvZCByZW1vdmVMaW5rXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmtfaWRcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihsaW5rX2lkKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGVCeUlkKGxpbmsudGFyZ2V0X2lkKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGxpbmsudGFyZ2V0X3Nsb3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vc2F2ZSBhbmQgcmVjb3ZlciBhcHAgc3RhdGUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mbyBhYm91dCB0aGlzIGdyYXBoLCBpdCBjYW4gYmUgc2VyaWFsaXplZFxuICAgICAqIEBtZXRob2Qgc2VyaWFsaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB2YWx1ZSBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2Rlc19pbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBub2Rlc19pbmZvLnB1c2godGhpcy5fbm9kZXNbaV0uc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9wYWNrIGxpbmsgaW5mbyBpbnRvIGEgbm9uLXZlcmJvc2UgZm9ybWF0XG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMubGlua3MpIHtcbiAgICAgICAgICAgIC8vbGlua3MgaXMgYW4gT0JKRUNUXG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua3NbaV07XG4gICAgICAgICAgICBpZiAoIWxpbmsuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgLy93ZWlyZCBidWcgSSBoYXZlbnQgc29sdmVkIHlldFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJ3ZWlyZCBMTGluayBidWcsIGxpbmsgaW5mbyBpcyBub3QgYSBMTGluayBidXQgYSByZWd1bGFyIG9iamVjdFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluazIgPSBuZXcgTExpbmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGxpbmspIHsgXG4gICAgICAgICAgICAgICAgICAgIGxpbmsyW2pdID0gbGlua1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW5rc1tpXSA9IGxpbmsyO1xuICAgICAgICAgICAgICAgIGxpbmsgPSBsaW5rMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlua3MucHVzaChsaW5rLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHNfaW5mbyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZ3JvdXBzX2luZm8ucHVzaCh0aGlzLl9ncm91cHNbaV0uc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBsYXN0X25vZGVfaWQ6IHRoaXMubGFzdF9ub2RlX2lkLFxuICAgICAgICAgICAgbGFzdF9saW5rX2lkOiB0aGlzLmxhc3RfbGlua19pZCxcbiAgICAgICAgICAgIG5vZGVzOiBub2Rlc19pbmZvLFxuICAgICAgICAgICAgbGlua3M6IGxpbmtzLFxuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHNfaW5mbyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG5cdFx0XHRleHRyYTogdGhpcy5leHRyYSxcbiAgICAgICAgICAgIHZlcnNpb246IExpdGVHcmFwaC5WRVJTSU9OXG4gICAgICAgIH07XG5cblx0XHRpZih0aGlzLm9uU2VyaWFsaXplKVxuXHRcdFx0dGhpcy5vblNlcmlhbGl6ZShkYXRhKTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIGEgZ3JhcGggZnJvbSBhIEpTT04gc3RyaW5nXG4gICAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIGNvbmZpZ3VyZSBhIGdyYXBoIGZyb20gYSBKU09OIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJucyBpZiB0aGVyZSB3YXMgYW55IGVycm9yIHBhcnNpbmdcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKGRhdGEsIGtlZXBfb2xkKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZWVwX29sZCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVzID0gZGF0YS5ub2RlcztcblxuICAgICAgICAvL2RlY29kZSBsaW5rcyBpbmZvICh0aGV5IGFyZSB2ZXJ5IHZlcmJvc2UpXG4gICAgICAgIGlmIChkYXRhLmxpbmtzICYmIGRhdGEubGlua3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5saW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX2RhdGEgPSBkYXRhLmxpbmtzW2ldO1xuXHRcdFx0XHRpZighbGlua19kYXRhKSAvL3dlaXJkIGJ1Z1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwic2VyaWFsaXplZCBncmFwaCBsaW5rIGRhdGEgY29udGFpbnMgZXJyb3JzLCBza2lwcGluZy5cIik7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IG5ldyBMTGluaygpO1xuICAgICAgICAgICAgICAgIGxpbmsuY29uZmlndXJlKGxpbmtfZGF0YSk7XG4gICAgICAgICAgICAgICAgbGlua3NbbGluay5pZF0gPSBsaW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5saW5rcyA9IGxpbmtzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb3B5IGFsbCBzdG9yZWQgZmllbGRzXG4gICAgICAgIGZvciAodmFyIGkgaW4gZGF0YSkge1xuXHRcdFx0aWYoaSA9PSBcIm5vZGVzXCIgfHwgaSA9PSBcImdyb3Vwc1wiICkgLy9saW5rcyBtdXN0IGJlIGFjY2VwdGVkXG5cdFx0XHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1tpXSA9IGRhdGFbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZTtcblxuICAgICAgICAvL2NyZWF0ZSBub2Rlc1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5faW5mbyA9IG5vZGVzW2ldOyAvL3N0b3JlZCBpbmZvXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShuX2luZm8udHlwZSwgbl9pbmZvLnRpdGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJOb2RlIG5vdCBmb3VuZCBvciBoYXMgZXJyb3JzOiBcIiArIG5faW5mby50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pbiBjYXNlIG9mIGVycm9yIHdlIGNyZWF0ZSBhIHJlcGxhY2VtZW50IG5vZGUgdG8gYXZvaWQgbG9zaW5nIGluZm9cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBMR3JhcGhOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGFzdF9zZXJpYWxpemF0aW9uID0gbl9pbmZvO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmhhc19lcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZS5pZCA9IG5faW5mby5pZDsgLy9pZCBpdCBvciBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBpZFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKG5vZGUsIHRydWUpOyAvL2FkZCBiZWZvcmUgY29uZmlndXJlLCBvdGhlcndpc2UgY29uZmlndXJlIGNhbm5vdCBjcmVhdGUgbGlua3NcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jb25maWd1cmUgbm9kZXMgYWZ0ZXJ3YXJkcyBzbyB0aGV5IGNhbiByZWFjaCBlYWNoIG90aGVyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBuX2luZm8gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5SWQobl9pbmZvLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbmZpZ3VyZShuX2luZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ3JvdXBzXG4gICAgICAgIHRoaXMuX2dyb3Vwcy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoZGF0YS5ncm91cHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ncm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgTGl0ZUdyYXBoLkxHcmFwaEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuY29uZmlndXJlKGRhdGEuZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyKCk7XG5cblx0XHR0aGlzLmV4dHJhID0gZGF0YS5leHRyYSB8fCB7fTtcblxuXHRcdGlmKHRoaXMub25Db25maWd1cmUpXG5cdFx0XHR0aGlzLm9uQ29uZmlndXJlKGRhdGEpO1xuXG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHRcdC8vZnJvbSBmaWxlXG5cdFx0aWYodXJsLmNvbnN0cnVjdG9yID09PSBGaWxlIHx8IHVybC5jb25zdHJ1Y3RvciA9PT0gQmxvYilcblx0XHR7XG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuXHRcdFx0XHR0aGF0LmNvbmZpZ3VyZShkYXRhKTtcblx0XHRcdFx0aWYoY2FsbGJhY2spXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZWFkZXIucmVhZEFzVGV4dCh1cmwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vaXMgYSBzdHJpbmcsIHRoZW4gYW4gVVJMXG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxLnNlbmQobnVsbCk7XG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbihvRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBncmFwaDpcIiwgcmVxLnN0YXR1cywgcmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoIHJlcS5yZXNwb25zZSApO1xuICAgICAgICAgICAgdGhhdC5jb25maWd1cmUoZGF0YSk7XG5cdFx0XHRpZihjYWxsYmFjaylcblx0XHRcdFx0Y2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGdyYXBoOlwiLCBlcnIpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLm9uTm9kZVRyYWNlID0gZnVuY3Rpb24obm9kZSwgbXNnLCBjb2xvcikge1xuICAgICAgICAvL1RPRE9cbiAgICB9O1xuXG4gICAgLy90aGlzIGlzIHRoZSBjbGFzcyBpbiBjaGFyZ2Ugb2Ygc3RvcmluZyBsaW5rIGluZm9ybWF0aW9uXG4gICAgZnVuY3Rpb24gTExpbmsoaWQsIHR5cGUsIG9yaWdpbl9pZCwgb3JpZ2luX3Nsb3QsIHRhcmdldF9pZCwgdGFyZ2V0X3Nsb3QpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm9yaWdpbl9pZCA9IG9yaWdpbl9pZDtcbiAgICAgICAgdGhpcy5vcmlnaW5fc2xvdCA9IG9yaWdpbl9zbG90O1xuICAgICAgICB0aGlzLnRhcmdldF9pZCA9IHRhcmdldF9pZDtcbiAgICAgICAgdGhpcy50YXJnZXRfc2xvdCA9IHRhcmdldF9zbG90O1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDIpOyAvL2NlbnRlclxuICAgIH1cblxuICAgIExMaW5rLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmIChvLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG9bMF07XG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9pZCA9IG9bMV07XG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9zbG90ID0gb1syXTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X2lkID0gb1szXTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3Nsb3QgPSBvWzRdO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gb1s1XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBvLmlkO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gby50eXBlO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5faWQgPSBvLm9yaWdpbl9pZDtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX3Nsb3QgPSBvLm9yaWdpbl9zbG90O1xuICAgICAgICAgICAgdGhpcy50YXJnZXRfaWQgPSBvLnRhcmdldF9pZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3Nsb3QgPSBvLnRhcmdldF9zbG90O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExMaW5rLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuaWQsXG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9pZCxcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX3Nsb3QsXG4gICAgICAgICAgICB0aGlzLnRhcmdldF9pZCxcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3Nsb3QsXG4gICAgICAgICAgICB0aGlzLnR5cGVcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLkxMaW5rID0gTExpbms7XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gICBOb2RlIENMQVNTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qXG5cdHRpdGxlOiBzdHJpbmdcblx0cG9zOiBbeCx5XVxuXHRzaXplOiBbeCx5XVxuXG5cdGlucHV0fG91dHB1dDogZXZlcnkgY29ubmVjdGlvblxuXHRcdCsgIHsgbmFtZTpzdHJpbmcsIHR5cGU6c3RyaW5nLCBwb3M6IFt4LHldPU9wdGlvbmFsLCBkaXJlY3Rpb246IFwiaW5wdXRcInxcIm91dHB1dFwiLCBsaW5rczogQXJyYXkgfSk7XG5cblx0Z2VuZXJhbCBwcm9wZXJ0aWVzOlxuXHRcdCsgY2xpcF9hcmVhOiBpZiB5b3UgcmVuZGVyIG91dHNpZGUgdGhlIG5vZGUsIGl0IHdpbGwgYmUgY2xpcHBlZFxuXHRcdCsgdW5zYWZlX2V4ZWN1dGlvbjogbm90IGFsbG93ZWQgZm9yIHNhZmUgZXhlY3V0aW9uXG5cdFx0KyBza2lwX3JlcGVhdGVkX291dHB1dHM6IHdoZW4gYWRkaW5nIG5ldyBvdXRwdXRzLCBpdCB3b250IHNob3cgaWYgdGhlcmUgaXMgb25lIGFscmVhZHkgY29ubmVjdGVkXG5cdFx0KyByZXNpemFibGU6IGlmIHNldCB0byBmYWxzZSBpdCB3b250IGJlIHJlc2l6YWJsZSB3aXRoIHRoZSBtb3VzZVxuXHRcdCsgaG9yaXpvbnRhbDogc2xvdHMgYXJlIGRpc3RyaWJ1dGVkIGhvcml6b250YWxseVxuXHRcdCsgd2lkZ2V0c19zdGFydF95OiB3aWRnZXRzIHN0YXJ0IGF0IHkgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIG9mIHRoZSBub2RlXG5cdFxuXHRmbGFncyBvYmplY3Q6XG5cdFx0KyBjb2xsYXBzZWQ6IGlmIGl0IGlzIGNvbGxhcHNlZFxuXG5cdHN1cHBvcnRlZCBjYWxsYmFja3M6XG5cdFx0KyBvbkFkZGVkOiB3aGVuIGFkZGVkIHRvIGdyYXBoICh3YXJuaW5nOiB0aGlzIGlzIGNhbGxlZCBCRUZPUkUgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB3aGVuIGxvYWRpbmcpXG5cdFx0KyBvblJlbW92ZWQ6IHdoZW4gcmVtb3ZlZCBmcm9tIGdyYXBoXG5cdFx0KyBvblN0YXJ0Olx0d2hlbiB0aGUgZ3JhcGggc3RhcnRzIHBsYXlpbmdcblx0XHQrIG9uU3RvcDpcdHdoZW4gdGhlIGdyYXBoIHN0b3BzIHBsYXlpbmdcblx0XHQrIG9uRHJhd0ZvcmVncm91bmQ6IHJlbmRlciB0aGUgaW5zaWRlIHdpZGdldHMgaW5zaWRlIHRoZSBub2RlXG5cdFx0KyBvbkRyYXdCYWNrZ3JvdW5kOiByZW5kZXIgdGhlIGJhY2tncm91bmQgYXJlYSBpbnNpZGUgdGhlIG5vZGUgKG9ubHkgaW4gZWRpdCBtb2RlKVxuXHRcdCsgb25Nb3VzZURvd25cblx0XHQrIG9uTW91c2VNb3ZlXG5cdFx0KyBvbk1vdXNlVXBcblx0XHQrIG9uTW91c2VFbnRlclxuXHRcdCsgb25Nb3VzZUxlYXZlXG5cdFx0KyBvbkV4ZWN1dGU6IGV4ZWN1dGUgdGhlIG5vZGVcblx0XHQrIG9uUHJvcGVydHlDaGFuZ2VkOiB3aGVuIGEgcHJvcGVydHkgaXMgY2hhbmdlZCBpbiB0aGUgcGFuZWwgKHJldHVybiB0cnVlIHRvIHNraXAgZGVmYXVsdCBiZWhhdmlvdXIpXG5cdFx0KyBvbkdldElucHV0czogcmV0dXJucyBhbiBhcnJheSBvZiBwb3NzaWJsZSBpbnB1dHNcblx0XHQrIG9uR2V0T3V0cHV0czogcmV0dXJucyBhbiBhcnJheSBvZiBwb3NzaWJsZSBvdXRwdXRzXG5cdFx0KyBvbkJvdW5kaW5nOiBpbiBjYXNlIHRoaXMgbm9kZSBoYXMgYSBiaWdnZXIgYm91bmRpbmcgdGhhbiB0aGUgbm9kZSBpdHNlbGYgKHRoZSBjYWxsYmFjayByZWNlaXZlcyB0aGUgYm91bmRpbmcgYXMgW3gseSx3LGhdKVxuXHRcdCsgb25EYmxDbGljazogZG91YmxlIGNsaWNrZWQgaW4gdGhlIG5vZGVcblx0XHQrIG9uSW5wdXREYmxDbGljazogaW5wdXQgc2xvdCBkb3VibGUgY2xpY2tlZCAoY2FuIGJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgYSBub2RlIGNvbm5lY3RlZClcblx0XHQrIG9uT3V0cHV0RGJsQ2xpY2s6IG91dHB1dCBzbG90IGRvdWJsZSBjbGlja2VkIChjYW4gYmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhIG5vZGUgY29ubmVjdGVkKVxuXHRcdCsgb25Db25maWd1cmU6IGNhbGxlZCBhZnRlciB0aGUgbm9kZSBoYXMgYmVlbiBjb25maWd1cmVkXG5cdFx0KyBvblNlcmlhbGl6ZTogdG8gYWRkIGV4dHJhIGluZm8gd2hlbiBzZXJpYWxpemluZyAodGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgZmlsbGVkIHdpdGggdGhlIGRhdGEpXG5cdFx0KyBvblNlbGVjdGVkXG5cdFx0KyBvbkRlc2VsZWN0ZWRcblx0XHQrIG9uRHJvcEl0ZW0gOiBET00gaXRlbSBkcm9wcGVkIG92ZXIgdGhlIG5vZGVcblx0XHQrIG9uRHJvcEZpbGUgOiBmaWxlIGRyb3BwZWQgb3ZlciB0aGUgbm9kZVxuXHRcdCsgb25Db25uZWN0SW5wdXQgOiBpZiByZXR1cm5zIGZhbHNlIHRoZSBpbmNvbWluZyBjb25uZWN0aW9uIHdpbGwgYmUgY2FuY2VsZWRcblx0XHQrIG9uQ29ubmVjdGlvbnNDaGFuZ2UgOiBhIGNvbm5lY3Rpb24gY2hhbmdlZCAobmV3IG9uZSBvciByZW1vdmVkKSAoTGl0ZUdyYXBoLklOUFVUIG9yIExpdGVHcmFwaC5PVVRQVVQsIHNsb3QsIHRydWUgaWYgY29ubmVjdGVkLCBsaW5rX2luZm8sIGlucHV0X2luZm8gKVxuXHRcdCsgb25BY3Rpb246IGFjdGlvbiBzbG90IHRyaWdnZXJlZFxuXHRcdCsgZ2V0RXh0cmFNZW51T3B0aW9uczogdG8gYWRkIG9wdGlvbiB0byBjb250ZXh0IG1lbnVcbiovXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIENsYXNzIGZvciBhbGwgdGhlIG5vZGUgdHlwZSBjbGFzc2VzXG4gICAgICogQGNsYXNzIExHcmFwaE5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgZm9yIHRoZSBub2RlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMR3JhcGhOb2RlKHRpdGxlKSB7XG4gICAgICAgIHRoaXMuX2N0b3IodGl0bGUpO1xuICAgIH1cblxuICAgIGdsb2JhbC5MR3JhcGhOb2RlID0gTGl0ZUdyYXBoLkxHcmFwaE5vZGUgPSBMR3JhcGhOb2RlO1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuX2N0b3IgPSBmdW5jdGlvbih0aXRsZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGUgfHwgXCJVbm5hbWVkXCI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFtMaXRlR3JhcGguTk9ERV9XSURUSCwgNjBdO1xuICAgICAgICB0aGlzLmdyYXBoID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDEwLCAxMCk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicG9zXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghdiB8fCB2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc1sxXSA9IHZbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pZCA9IC0xOyAvL25vdCBrbm93IHRpbGwgbm90IGFkZGVkXG4gICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG5cbiAgICAgICAgLy9pbnB1dHMgYXZhaWxhYmxlOiBhcnJheSBvZiBpbnB1dHNcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBbXTtcblxuICAgICAgICAvL2xvY2FsIGRhdGFcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307IC8vZm9yIHRoZSB2YWx1ZXNcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzX2luZm8gPSBbXTsgLy9mb3IgdGhlIGluZm9cblxuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbmZpZ3VyZSBhIG5vZGUgZnJvbSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2VyaWFsaXplZCBpbmZvXG4gICAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiBpbiBpbmZvKSB7XG4gICAgICAgICAgICBpZiAoaiA9PSBcInByb3BlcnRpZXNcIikge1xuICAgICAgICAgICAgICAgIC8vaSBkb24ndCB3YW50IHRvIGNsb25lIHByb3BlcnRpZXMsIEkgd2FudCB0byByZXVzZSB0aGUgb2xkIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gaW5mby5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1trXSA9IGluZm8ucHJvcGVydGllc1trXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25Qcm9wZXJ0eUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Qcm9wZXJ0eUNoYW5nZWQoIGssIGluZm8ucHJvcGVydGllc1trXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5mb1tqXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbmZvW2pdID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAvL29iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzW2pdICYmIHRoaXNbal0uY29uZmlndXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbal0uY29uZmlndXJlKGluZm9bal0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbal0gPSBMaXRlR3JhcGguY2xvbmVPYmplY3QoaW5mb1tqXSwgdGhpc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvL3ZhbHVlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2pdID0gaW5mb1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5mby50aXRsZSkge1xuICAgICAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuY29uc3RydWN0b3IudGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdyYXBoLmxpbmtzW2lucHV0LmxpbmtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uc0NoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5JTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgKTsgLy9saW5rX2luZm8gaGFzIGJlZW4gY3JlYXRlZCBub3csIHNvIGl0cyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQubGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0LmxpbmtzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5ncmFwaC5saW5rc1tvdXRwdXQubGlua3Nbal1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7IC8vbGlua19pbmZvIGhhcyBiZWVuIGNyZWF0ZWQgbm93LCBzbyBpdHMgdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHRpZiggdGhpcy53aWRnZXRzIClcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2lkZ2V0cy5sZW5ndGg7ICsraSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHcgPSB0aGlzLndpZGdldHNbaV07XG5cdFx0XHRcdGlmKCF3KVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRpZih3Lm9wdGlvbnMgJiYgdy5vcHRpb25zLnByb3BlcnR5ICYmIHRoaXMucHJvcGVydGllc1sgdy5vcHRpb25zLnByb3BlcnR5IF0pXG5cdFx0XHRcdFx0dy52YWx1ZSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnByb3BlcnRpZXNbIHcub3B0aW9ucy5wcm9wZXJ0eSBdICkgKTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmZvLndpZGdldHNfdmFsdWVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby53aWRnZXRzX3ZhbHVlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLndpZGdldHNbaV0pIHtcblx0XHRcdFx0XHRcdHRoaXMud2lkZ2V0c1tpXS52YWx1ZSA9IGluZm8ud2lkZ2V0c192YWx1ZXNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG4gICAgICAgIGlmICh0aGlzLm9uQ29uZmlndXJlKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ29uZmlndXJlKGluZm8pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlcmlhbGl6ZSB0aGUgY29udGVudFxuICAgICAqIEBtZXRob2Qgc2VyaWFsaXplXG4gICAgICovXG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jcmVhdGUgc2VyaWFsaXphdGlvbiBvYmplY3RcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHBvczogdGhpcy5wb3MsXG4gICAgICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgICAgICBmbGFnczogTGl0ZUdyYXBoLmNsb25lT2JqZWN0KHRoaXMuZmxhZ3MpLFxuXHRcdFx0b3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGVcbiAgICAgICAgfTtcblxuICAgICAgICAvL3NwZWNpYWwgY2FzZSBmb3Igd2hlbiB0aGVyZSB3ZXJlIGVycm9yc1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gTEdyYXBoTm9kZSAmJiB0aGlzLmxhc3Rfc2VyaWFsaXphdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdF9zZXJpYWxpemF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBvLmlucHV0cyA9IHRoaXMuaW5wdXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgLy9jbGVhciBvdXRwdXRzIGxhc3QgZGF0YSAoYmVjYXVzZSBkYXRhIGluIGNvbm5lY3Rpb25zIGlzIG5ldmVyIHNlcmlhbGl6ZWQgYnV0IHN0b3JlZCBpbnNpZGUgdGhlIG91dHB1dHMgaW5mbylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3V0cHV0c1tpXS5fZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG8ub3V0cHV0cyA9IHRoaXMub3V0cHV0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRpdGxlICYmIHRoaXMudGl0bGUgIT0gdGhpcy5jb25zdHJ1Y3Rvci50aXRsZSkge1xuICAgICAgICAgICAgby50aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBvLnByb3BlcnRpZXMgPSBMaXRlR3JhcGguY2xvbmVPYmplY3QodGhpcy5wcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLndpZGdldHMgJiYgdGhpcy5zZXJpYWxpemVfd2lkZ2V0cykge1xuICAgICAgICAgICAgby53aWRnZXRzX3ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndpZGdldHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aWYodGhpcy53aWRnZXRzW2ldKVxuXHQgICAgICAgICAgICAgICAgby53aWRnZXRzX3ZhbHVlc1tpXSA9IHRoaXMud2lkZ2V0c1tpXS52YWx1ZTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdG8ud2lkZ2V0c192YWx1ZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvLnR5cGUpIHtcbiAgICAgICAgICAgIG8udHlwZSA9IHRoaXMuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICBvLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iZ2NvbG9yKSB7XG4gICAgICAgICAgICBvLmJnY29sb3IgPSB0aGlzLmJnY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm94Y29sb3IpIHtcbiAgICAgICAgICAgIG8uYm94Y29sb3IgPSB0aGlzLmJveGNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoYXBlKSB7XG4gICAgICAgICAgICBvLnNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uU2VyaWFsaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vblNlcmlhbGl6ZShvKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJub2RlIG9uU2VyaWFsaXplIHNob3VsZG50IHJldHVybiBhbnl0aGluZywgZGF0YSBzaG91bGQgYmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcGFzcyBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIC8qIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIG5vZGUgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKHRoaXMudHlwZSk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlIGNsb25lIGl0IGJlY2F1c2Ugc2VyaWFsaXplIHJldHVybnMgc2hhcmVkIGNvbnRhaW5lcnNcbiAgICAgICAgdmFyIGRhdGEgPSBMaXRlR3JhcGguY2xvbmVPYmplY3QodGhpcy5zZXJpYWxpemUoKSk7XG5cbiAgICAgICAgLy9yZW1vdmUgbGlua3NcbiAgICAgICAgaWYgKGRhdGEuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5pbnB1dHNbaV0ubGluayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLm91dHB1dHNbaV0ubGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vdXRwdXRzW2ldLmxpbmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGRhdGFbXCJpZFwiXTtcbiAgICAgICAgLy9yZW1vdmUgbGlua3NcbiAgICAgICAgbm9kZS5jb25maWd1cmUoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlcmlhbGl6ZSBhbmQgc3RyaW5naWZ5XG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqL1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc2VyaWFsaXplKCkpO1xuICAgIH07XG4gICAgLy9MR3JhcGhOb2RlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGluZm8pIHt9IC8vdGhpcyBjYW5ub3QgYmUgZG9uZSBmcm9tIHdpdGhpbiwgbXVzdCBiZSBkb25lIGluIExpdGVHcmFwaFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBzdHJpbmdcbiAgICAgKiBAbWV0aG9kIGdldFRpdGxlXG4gICAgICovXG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnRpdGxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAgICogQG1ldGhvZCBzZXRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG5cdFx0aWYoIHZhbHVlID09PSB0aGlzLnByb3BlcnRpZXNbbmFtZV0gKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBwcmV2X3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMub25Qcm9wZXJ0eUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmKCB0aGlzLm9uUHJvcGVydHlDaGFuZ2VkKG5hbWUsIHZhbHVlLCBwcmV2X3ZhbHVlKSA9PT0gZmFsc2UgKSAvL2Fib3J0IGNoYW5nZVxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBwcmV2X3ZhbHVlO1xuICAgICAgICB9XG5cdFx0aWYodGhpcy53aWRnZXRzKSAvL3dpZGdldHMgY291bGQgYmUgbGlua2VkIHRvIHByb3BlcnRpZXNcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLndpZGdldHMubGVuZ3RoOyArK2kpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB3ID0gdGhpcy53aWRnZXRzW2ldO1xuXHRcdFx0XHRpZighdylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0aWYody5vcHRpb25zLnByb3BlcnR5ID09IG5hbWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR3LnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cbiAgICB9O1xuXG4gICAgLy8gRXhlY3V0aW9uICoqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBvdXRwdXQgZGF0YVxuICAgICAqIEBtZXRob2Qgc2V0T3V0cHV0RGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKHNsb3QsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcyBtYXliZSBzbG93IGFuZCBhIG5pY2hlIGNhc2VcbiAgICAgICAgLy9pZihzbG90ICYmIHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZylcbiAgICAgICAgLy9cdHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KHNsb3QpO1xuXG4gICAgICAgIGlmIChzbG90ID09IC0xIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dF9pbmZvID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dF9pbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3N0b3JlIGRhdGEgaW4gdGhlIG91dHB1dCBpdHNlbGYgaW4gY2FzZSB3ZSB3YW50IHRvIGRlYnVnXG4gICAgICAgIG91dHB1dF9pbmZvLl9kYXRhID0gZGF0YTtcblxuICAgICAgICAvL2lmIHRoZXJlIGFyZSBjb25uZWN0aW9ucywgcGFzcyB0aGUgZGF0YSB0byB0aGUgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tzbG90XS5saW5rcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMub3V0cHV0c1tzbG90XS5saW5rc1tpXTtcblx0XHRcdFx0dmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuXHRcdFx0XHRpZihsaW5rKVxuXHRcdFx0XHRcdGxpbmsuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgb3V0cHV0IGRhdGEgdHlwZSwgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gYmUgYWJsZSB0byBvdmVyd3JpdGUgdGhlIGRhdGEgdHlwZVxuICAgICAqIEBtZXRob2Qgc2V0T3V0cHV0RGF0YVR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhdHlwZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnNldE91dHB1dERhdGFUeXBlID0gZnVuY3Rpb24oc2xvdCwgdHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90ID09IC0xIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRfaW5mbyA9IHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgaWYgKCFvdXRwdXRfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vc3RvcmUgZGF0YSBpbiB0aGUgb3V0cHV0IGl0c2VsZiBpbiBjYXNlIHdlIHdhbnQgdG8gZGVidWdcbiAgICAgICAgb3V0cHV0X2luZm8udHlwZSA9IHR5cGU7XG5cbiAgICAgICAgLy9pZiB0aGVyZSBhcmUgY29ubmVjdGlvbnMsIHBhc3MgdGhlIGRhdGEgdG8gdGhlIGNvbm5lY3Rpb25zXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzW3Nsb3RdLmxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3NbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGlucHV0IGRhdGEgKGRhdGEgdHJhdmVsaW5nIHRocm91Z2ggdGhlIGNvbm5lY3Rpb24pIGZyb20gb25lIHNsb3RcbiAgICAgKiBAbWV0aG9kIGdldElucHV0RGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZV91cGRhdGUgaWYgc2V0IHRvIHRydWUgaXQgd2lsbCBmb3JjZSB0aGUgY29ubmVjdGVkIG5vZGUgb2YgdGhpcyBzbG90IHRvIG91dHB1dCBkYXRhIGludG8gdGhpcyBsaW5rXG4gICAgICogQHJldHVybiB7Kn0gZGF0YSBvciBpZiBpdCBpcyBub3QgY29ubmVjdGVkIHJldHVybnMgdW5kZWZpbmVkXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXREYXRhID0gZnVuY3Rpb24oc2xvdCwgZm9yY2VfdXBkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvL3VuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLmlucHV0cy5sZW5ndGggfHwgdGhpcy5pbnB1dHNbc2xvdF0ubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMuaW5wdXRzW3Nsb3RdLmxpbms7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAvL2J1Zzogd2VpcmQgY2FzZSBidXQgaXQgaGFwcGVucyBzb21ldGltZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3JjZV91cGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NwZWNpYWwgY2FzZTogdXNlZCB0byBleHRyYWN0IGRhdGEgZnJvbSB0aGUgaW5jb21pbmcgY29ubmVjdGlvbiBiZWZvcmUgdGhlIGdyYXBoIGhhcyBiZWVuIGV4ZWN1dGVkXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rLm9yaWdpbl9pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnVwZGF0ZU91dHB1dERhdGEpIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlT3V0cHV0RGF0YShsaW5rLm9yaWdpbl9zbG90KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgbm9kZS5vbkV4ZWN1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rLmRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgZGF0YSB0eXBlIChpbiBjYXNlIHRoaXMgc3VwcG9ydHMgbXVsdGlwbGUgaW5wdXQgdHlwZXMpXG4gICAgICogQG1ldGhvZCBnZXRJbnB1dERhdGFUeXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGF0eXBlIGluIHN0cmluZyBmb3JtYXRcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dERhdGFUeXBlID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvL3VuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLmlucHV0cy5sZW5ndGggfHwgdGhpcy5pbnB1dHNbc2xvdF0ubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMuaW5wdXRzW3Nsb3RdLmxpbms7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAvL2J1Zzogd2VpcmQgY2FzZSBidXQgaXQgaGFwcGVucyBzb21ldGltZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rLm9yaWdpbl9pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsudHlwZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0X2luZm8gPSBub2RlLm91dHB1dHNbbGluay5vcmlnaW5fc2xvdF07XG4gICAgICAgIGlmIChvdXRwdXRfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dF9pbmZvLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgZGF0YSBmcm9tIG9uZSBzbG90IHVzaW5nIGl0cyBuYW1lIGluc3RlYWQgb2Ygc2xvdCBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGdldElucHV0RGF0YUJ5TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzbG90X25hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlX3VwZGF0ZSBpZiBzZXQgdG8gdHJ1ZSBpdCB3aWxsIGZvcmNlIHRoZSBjb25uZWN0ZWQgbm9kZSBvZiB0aGlzIHNsb3QgdG8gb3V0cHV0IGRhdGEgaW50byB0aGlzIGxpbmtcbiAgICAgKiBAcmV0dXJuIHsqfSBkYXRhIG9yIGlmIGl0IGlzIG5vdCBjb25uZWN0ZWQgcmV0dXJucyBudWxsXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXREYXRhQnlOYW1lID0gZnVuY3Rpb24oXG4gICAgICAgIHNsb3RfbmFtZSxcbiAgICAgICAgZm9yY2VfdXBkYXRlXG4gICAgKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KHNsb3RfbmFtZSk7XG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnB1dERhdGEoc2xvdCwgZm9yY2VfdXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBpbiBvbmUgaW5wdXQgc2xvdFxuICAgICAqIEBtZXRob2QgaXNJbnB1dENvbm5lY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5pc0lucHV0Q29ubmVjdGVkID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsb3QgPCB0aGlzLmlucHV0cy5sZW5ndGggJiYgdGhpcy5pbnB1dHNbc2xvdF0ubGluayAhPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0ZWxscyB5b3UgaW5mbyBhYm91dCBhbiBpbnB1dCBjb25uZWN0aW9uICh3aGljaCBub2RlLCB0eXBlLCBldGMpXG4gICAgICogQG1ldGhvZCBnZXRJbnB1dEluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IG9yIG51bGwgeyBsaW5rOiBpZCwgbmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcgb3IgMCB9XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXRJbmZvID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdCA8IHRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzW3Nsb3RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaW5rIGluZm8gaW4gdGhlIGNvbm5lY3Rpb24gb2YgYW4gaW5wdXQgc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXRMaW5rXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtMTGlua30gb2JqZWN0IG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dExpbmsgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90IDwgdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2xvdF9pbmZvID0gdGhpcy5pbnB1dHNbc2xvdF07XG5cdFx0XHRyZXR1cm4gdGhpcy5ncmFwaC5saW5rc1sgc2xvdF9pbmZvLmxpbmsgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgbm9kZSBjb25uZWN0ZWQgaW4gdGhlIGlucHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGdldElucHV0Tm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7TEdyYXBoTm9kZX0gbm9kZSBvciBudWxsXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXROb2RlID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIWlucHV0IHx8IGlucHV0LmxpbmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2lucHV0LmxpbmtdO1xuICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLm9yaWdpbl9pZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGlucHV0IHdpdGggdGhpcyBuYW1lLCBvdGhlcndpc2UgY2hlY2tzIGlmIHRoZXJlIGlzIGEgcHJvcGVydHkgd2l0aCB0aGF0IG5hbWVcbiAgICAgKiBAbWV0aG9kIGdldElucHV0T3JQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dE9yUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcyA/IHRoaXMucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZm8gPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IGlucHV0X2luZm8ubmFtZSAmJiBpbnB1dF9pbmZvLmxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tpbnB1dF9pbmZvLmxpbmtdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRlbGxzIHlvdSB0aGUgbGFzdCBvdXRwdXQgZGF0YSB0aGF0IHdlbnQgaW4gdGhhdCBzbG90XG4gICAgICogQG1ldGhvZCBnZXRPdXRwdXREYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICBvYmplY3Qgb3IgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldE91dHB1dERhdGEgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICByZXR1cm4gaW5mby5fZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGluZm8gYWJvdXQgYW4gb3V0cHV0IGNvbm5lY3Rpb24gKHdoaWNoIG5vZGUsIHR5cGUsIGV0YylcbiAgICAgKiBAbWV0aG9kIGdldE91dHB1dEluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gIG9iamVjdCBvciBudWxsIHsgbmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGxpbmtzOiBbIGlkcyBvZiBsaW5rcyBpbiBudW1iZXIgXSB9XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0SW5mbyA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90IDwgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBpbiBvbmUgb3V0cHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGlzT3V0cHV0Q29ubmVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmlzT3V0cHV0Q29ubmVjdGVkID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzbG90IDwgdGhpcy5vdXRwdXRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzW3Nsb3RdLmxpbmtzICYmXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MubGVuZ3RoXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRlbGxzIHlvdSBpZiB0aGVyZSBpcyBhbnkgY29ubmVjdGlvbiBpbiB0aGUgb3V0cHV0IHNsb3RzXG4gICAgICogQG1ldGhvZCBpc0FueU91dHB1dENvbm5lY3RlZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuaXNBbnlPdXRwdXRDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tpXS5saW5rcyAmJiB0aGlzLm91dHB1dHNbaV0ubGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZXMgYWxsIHRoZSBub2RlcyBjb25uZWN0ZWQgdG8gdGhpcyBvdXRwdXQgc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0T3V0cHV0Tm9kZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldE91dHB1dE5vZGVzID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cyB8fCB0aGlzLm91dHB1dHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dC5saW5rcyB8fCBvdXRwdXQubGlua3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5rX2lkID0gb3V0cHV0LmxpbmtzW2ldO1xuICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmsudGFyZ2V0X2lkKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHRhcmdldF9ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFuIGV2ZW50IGluIHRoaXMgbm9kZSwgdGhpcyB3aWxsIHRyaWdnZXIgYW55IG91dHB1dCB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZSAoIFwib25fcGxheVwiLCAuLi4gKSBpZiBhY3Rpb24gaXMgZXF1aXZhbGVudCB0byBmYWxzZSB0aGVuIHRoZSBldmVudCBpcyBzZW5kIHRvIGFsbFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cyB8fCAhdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpXG4gICAgICAgICAgICB0aGlzLmdyYXBoLl9sYXN0X3RyaWdnZXJfdGltZSA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICBpZiAoICFvdXRwdXQgfHwgb3V0cHV0LnR5cGUgIT09IExpdGVHcmFwaC5FVkVOVCB8fCAoYWN0aW9uICYmIG91dHB1dC5uYW1lICE9IGFjdGlvbikgKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdChpLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYW4gc2xvdCBldmVudCBpbiB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIHRyaWdnZXJTbG90XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNsb3QgdGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgc2xvdFxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGlua19pZCBbb3B0aW9uYWxdIGluIGNhc2UgeW91IHdhbnQgdG8gdHJpZ2dlciBhbmQgc3BlY2lmaWMgb3V0cHV0IGxpbmsgaW4gYSBzbG90XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUudHJpZ2dlclNsb3QgPSBmdW5jdGlvbihzbG90LCBwYXJhbSwgbGlua19pZCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rcyA9IG91dHB1dC5saW5rcztcbiAgICAgICAgaWYgKCFsaW5rcyB8fCAhbGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5fbGFzdF90cmlnZ2VyX3RpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9mb3IgZXZlcnkgbGluayBhdHRhY2hlZCBoZXJlXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGlua3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGxpbmtzW2tdO1xuICAgICAgICAgICAgaWYgKGxpbmtfaWQgIT0gbnVsbCAmJiBsaW5rX2lkICE9IGlkKSB7XG4gICAgICAgICAgICAgICAgLy90byBza2lwIGxpbmtzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rc1trXV07XG4gICAgICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xuICAgICAgICAgICAgICAgIC8vbm90IGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua19pbmZvLl9sYXN0X3RpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby50YXJnZXRfaWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9ub2RlIG5vdCBmb3VuZD9cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy91c2VkIHRvIG1hcmsgZXZlbnRzIGluIGdyYXBoXG4gICAgICAgICAgICB2YXIgdGFyZ2V0X2Nvbm5lY3Rpb24gPSBub2RlLmlucHV0c1tsaW5rX2luZm8udGFyZ2V0X3Nsb3RdO1xuXG5cdFx0XHRpZiAobm9kZS5tb2RlID09PSBMaXRlR3JhcGguT05fVFJJR0dFUilcblx0XHRcdHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vbkV4ZWN1dGUocGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG5vZGUub25BY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uQWN0aW9uKHRhcmdldF9jb25uZWN0aW9uLm5hbWUsIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHRyaWdnZXIgc2xvdCBhbmltYXRpb25cbiAgICAgKiBAbWV0aG9kIGNsZWFyVHJpZ2dlcmVkU2xvdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzbG90IHRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IHNsb3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGlua19pZCBbb3B0aW9uYWxdIGluIGNhc2UgeW91IHdhbnQgdG8gdHJpZ2dlciBhbmQgc3BlY2lmaWMgb3V0cHV0IGxpbmsgaW4gYSBzbG90XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuY2xlYXJUcmlnZ2VyZWRTbG90ID0gZnVuY3Rpb24oc2xvdCwgbGlua19pZCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rcyA9IG91dHB1dC5saW5rcztcbiAgICAgICAgaWYgKCFsaW5rcyB8fCAhbGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZvciBldmVyeSBsaW5rIGF0dGFjaGVkIGhlcmVcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5rcy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgdmFyIGlkID0gbGlua3Nba107XG4gICAgICAgICAgICBpZiAobGlua19pZCAhPSBudWxsICYmIGxpbmtfaWQgIT0gaWQpIHtcbiAgICAgICAgICAgICAgICAvL3RvIHNraXAgbGlua3NcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtzW2tdXTtcbiAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgLy9ub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rX2luZm8uX2xhc3RfdGltZSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBub2RlIHNpemUgYW5kIHRyaWdnZXJzIGNhbGxiYWNrXG4gICAgICogQG1ldGhvZCBzZXRTaXplXG4gICAgICogQHBhcmFtIHt2ZWMyfSBzaXplXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpXG5cdHtcblx0XHR0aGlzLnNpemUgPSBzaXplO1xuXHRcdGlmKHRoaXMub25SZXNpemUpXG5cdFx0XHR0aGlzLm9uUmVzaXplKHRoaXMuc2l6ZSk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBwcm9wZXJ0eSB0byB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRfdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIG91dHB1dCB0eXBlIChcInZlYzNcIixcIm51bWJlclwiLC4uLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFfaW5mbyB0aGlzIGNhbiBiZSB1c2VkIHRvIGhhdmUgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIHRoZSBwcm9wZXJ0eSAobGlrZSB2YWx1ZXMsIGV0YylcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uKFxuICAgICAgICBuYW1lLFxuICAgICAgICBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBleHRyYV9pbmZvXG4gICAgKSB7XG4gICAgICAgIHZhciBvID0geyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlLCBkZWZhdWx0X3ZhbHVlOiBkZWZhdWx0X3ZhbHVlIH07XG4gICAgICAgIGlmIChleHRyYV9pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgICAgICBvW2ldID0gZXh0cmFfaW5mb1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllc19pbmZvKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNfaW5mbyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcGVydGllc19pbmZvLnB1c2gobyk7XG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgLy9jb25uZWN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IG91dHB1dCBzbG90IHRvIHVzZSBpbiB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZE91dHB1dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgc3RyaW5nIGRlZmluaW5nIHRoZSBvdXRwdXQgdHlwZSAoXCJ2ZWMzXCIsXCJudW1iZXJcIiwuLi4pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhX2luZm8gdGhpcyBjYW4gYmUgdXNlZCB0byBoYXZlIHNwZWNpYWwgcHJvcGVydGllcyBvZiBhbiBvdXRwdXQgKGxhYmVsLCBzcGVjaWFsIGNvbG9yLCBwb3NpdGlvbiwgZXRjKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZE91dHB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGV4dHJhX2luZm8pIHtcbiAgICAgICAgdmFyIG8gPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIGxpbmtzOiBudWxsIH07XG4gICAgICAgIGlmIChleHRyYV9pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgICAgICBvW2ldID0gZXh0cmFfaW5mb1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dHMucHVzaChvKTtcbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dEFkZGVkKG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2l6ZSggdGhpcy5jb21wdXRlU2l6ZSgpICk7XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgb3V0cHV0IHNsb3QgdG8gdXNlIGluIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgYWRkT3V0cHV0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHRyaXBsZXRzIGxpa2UgW1tuYW1lLHR5cGUsZXh0cmFfaW5mb10sWy4uLl1dXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkT3V0cHV0cyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gYXJyYXlbaV07XG4gICAgICAgICAgICB2YXIgbyA9IHsgbmFtZTogaW5mb1swXSwgdHlwZTogaW5mb1sxXSwgbGluazogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKGFycmF5WzJdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBpbmZvWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9bal0gPSBpbmZvWzJdW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKG8pO1xuICAgICAgICAgICAgaWYgKHRoaXMub25PdXRwdXRBZGRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25PdXRwdXRBZGRlZChvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U2l6ZSggdGhpcy5jb21wdXRlU2l6ZSgpICk7XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhbiBleGlzdGluZyBvdXRwdXQgc2xvdFxuICAgICAqIEBtZXRob2QgcmVtb3ZlT3V0cHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5yZW1vdmVPdXRwdXQgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdE91dHB1dChzbG90KTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnNwbGljZShzbG90LCAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNsb3Q7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRwdXRzW2ldIHx8ICF0aGlzLm91dHB1dHNbaV0ubGlua3MpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5rcyA9IHRoaXMub3V0cHV0c1tpXS5saW5rcztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbbGlua3Nbal1dO1xuICAgICAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluay5vcmlnaW5fc2xvdCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0UmVtb3ZlZChzbG90KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgaW5wdXQgc2xvdCB0byB1c2UgaW4gdGhpcyBub2RlXG4gICAgICogQG1ldGhvZCBhZGRJbnB1dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgc3RyaW5nIGRlZmluaW5nIHRoZSBpbnB1dCB0eXBlIChcInZlYzNcIixcIm51bWJlclwiLC4uLiksIGl0IGl0cyBhIGdlbmVyaWMgb25lIHVzZSAwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhX2luZm8gdGhpcyBjYW4gYmUgdXNlZCB0byBoYXZlIHNwZWNpYWwgcHJvcGVydGllcyBvZiBhbiBpbnB1dCAobGFiZWwsIGNvbG9yLCBwb3NpdGlvbiwgZXRjKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZElucHV0ID0gZnVuY3Rpb24obmFtZSwgdHlwZSwgZXh0cmFfaW5mbykge1xuICAgICAgICB0eXBlID0gdHlwZSB8fCAwO1xuICAgICAgICB2YXIgbyA9IHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgbGluazogbnVsbCB9O1xuICAgICAgICBpZiAoZXh0cmFfaW5mbykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYV9pbmZvKSB7XG4gICAgICAgICAgICAgICAgb1tpXSA9IGV4dHJhX2luZm9baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dHMucHVzaChvKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcblxuICAgICAgICBpZiAodGhpcy5vbklucHV0QWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dEFkZGVkKG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBzZXZlcmFsIG5ldyBpbnB1dCBzbG90cyBpbiB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZElucHV0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHRyaXBsZXRzIGxpa2UgW1tuYW1lLHR5cGUsZXh0cmFfaW5mb10sWy4uLl1dXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkSW5wdXRzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHZhciBvID0geyBuYW1lOiBpbmZvWzBdLCB0eXBlOiBpbmZvWzFdLCBsaW5rOiBudWxsIH07XG4gICAgICAgICAgICBpZiAoYXJyYXlbMl0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGluZm9bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgb1tqXSA9IGluZm9bMl1bal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2gobyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vbklucHV0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5wdXRBZGRlZChvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U2l6ZSggdGhpcy5jb21wdXRlU2l6ZSgpICk7XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhbiBleGlzdGluZyBpbnB1dCBzbG90XG4gICAgICogQG1ldGhvZCByZW1vdmVJbnB1dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUucmVtb3ZlSW5wdXQgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdElucHV0KHNsb3QpO1xuICAgICAgICB2YXIgc2xvdF9pbmZvID0gdGhpcy5pbnB1dHMuc3BsaWNlKHNsb3QsIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gc2xvdDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbdGhpcy5pbnB1dHNbaV0ubGlua107XG4gICAgICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmsudGFyZ2V0X3Nsb3QgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICBpZiAodGhpcy5vbklucHV0UmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0UmVtb3ZlZChzbG90LCBzbG90X2luZm9bMF0gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYW4gc3BlY2lhbCBjb25uZWN0aW9uIHRvIHRoaXMgbm9kZSAodXNlZCBmb3Igc3BlY2lhbCBraW5kcyBvZiBncmFwaHMpXG4gICAgICogQG1ldGhvZCBhZGRDb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIGlucHV0IHR5cGUgKFwidmVjM1wiLFwibnVtYmVyXCIsLi4uKVxuICAgICAqIEBwYXJhbSB7W3gseV19IHBvcyBwb3NpdGlvbiBvZiB0aGUgY29ubmVjdGlvbiBpbnNpZGUgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIGlmIGlzIGlucHV0IG9yIG91dHB1dFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZENvbm5lY3Rpb24gPSBmdW5jdGlvbihuYW1lLCB0eXBlLCBwb3MsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgIGxpbmtzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaChvKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGVzIHRoZSBtaW5pbXVtIHNpemUgb2YgYSBub2RlIGFjY29yZGluZyB0byBpdHMgaW5wdXRzIGFuZCBvdXRwdXQgc2xvdHNcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVTaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbkhlaWdodFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHRvdGFsIHNpemVcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zaXplLmNvbmNhdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvd3MgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID8gdGhpcy5pbnB1dHMubGVuZ3RoIDogMSxcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cyA/IHRoaXMub3V0cHV0cy5sZW5ndGggOiAxXG4gICAgICAgICk7XG4gICAgICAgIHZhciBzaXplID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKTtcbiAgICAgICAgcm93cyA9IE1hdGgubWF4KHJvd3MsIDEpO1xuICAgICAgICB2YXIgZm9udF9zaXplID0gTGl0ZUdyYXBoLk5PREVfVEVYVF9TSVpFOyAvL2FsdGhvdWdoIGl0IHNob3VsZCBiZSBncmFwaGNhbnZhcy5pbm5lcl90ZXh0X2ZvbnQgc2l6ZVxuXG4gICAgICAgIHZhciBmb250X3NpemUgPSBmb250X3NpemU7XG4gICAgICAgIHZhciB0aXRsZV93aWR0aCA9IGNvbXB1dGVfdGV4dF9zaXplKHRoaXMudGl0bGUpO1xuICAgICAgICB2YXIgaW5wdXRfd2lkdGggPSAwO1xuICAgICAgICB2YXIgb3V0cHV0X3dpZHRoID0gMDtcblxuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBpbnB1dC5sYWJlbCB8fCBpbnB1dC5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRfd2lkdGggPSBjb21wdXRlX3RleHRfc2l6ZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRfd2lkdGggPCB0ZXh0X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X3dpZHRoID0gdGV4dF93aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gb3V0cHV0LmxhYmVsIHx8IG91dHB1dC5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRfd2lkdGggPSBjb21wdXRlX3RleHRfc2l6ZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0X3dpZHRoIDwgdGV4dF93aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfd2lkdGggPSB0ZXh0X3dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNpemVbMF0gPSBNYXRoLm1heChpbnB1dF93aWR0aCArIG91dHB1dF93aWR0aCArIDEwLCB0aXRsZV93aWR0aCk7XG4gICAgICAgIHNpemVbMF0gPSBNYXRoLm1heChzaXplWzBdLCBMaXRlR3JhcGguTk9ERV9XSURUSCk7XG4gICAgICAgIGlmICh0aGlzLndpZGdldHMgJiYgdGhpcy53aWRnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2l6ZVswXSA9IE1hdGgubWF4KHNpemVbMF0sIExpdGVHcmFwaC5OT0RFX1dJRFRIICogMS41KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemVbMV0gPSAodGhpcy5jb25zdHJ1Y3Rvci5zbG90X3N0YXJ0X3kgfHwgMCkgKyByb3dzICogTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQ7XG5cbiAgICAgICAgdmFyIHdpZGdldHNfaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0cyAmJiB0aGlzLndpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMud2lkZ2V0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53aWRnZXRzW2ldLmNvbXB1dGVTaXplKVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzX2hlaWdodCArPSB0aGlzLndpZGdldHNbaV0uY29tcHV0ZVNpemUoc2l6ZVswXSlbMV0gKyA0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0c19oZWlnaHQgKz0gTGl0ZUdyYXBoLk5PREVfV0lER0VUX0hFSUdIVCArIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aWRnZXRzX2hlaWdodCArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIGhlaWdodCB1c2luZyB3aWRnZXRzIGhlaWdodFxuICAgICAgICBpZiggdGhpcy53aWRnZXRzX3VwIClcbiAgICAgICAgICAgIHNpemVbMV0gPSBNYXRoLm1heCggc2l6ZVsxXSwgd2lkZ2V0c19oZWlnaHQgKTtcbiAgICAgICAgZWxzZSBpZiggdGhpcy53aWRnZXRzX3N0YXJ0X3kgIT0gbnVsbCApXG4gICAgICAgICAgICBzaXplWzFdID0gTWF0aC5tYXgoIHNpemVbMV0sIHdpZGdldHNfaGVpZ2h0ICsgdGhpcy53aWRnZXRzX3N0YXJ0X3kgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2l6ZVsxXSArPSB3aWRnZXRzX2hlaWdodDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlX3RleHRfc2l6ZSh0ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb250X3NpemUgKiB0ZXh0Lmxlbmd0aCAqIDAuNjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IubWluX2hlaWdodCAmJlxuICAgICAgICAgICAgc2l6ZVsxXSA8IHRoaXMuY29uc3RydWN0b3IubWluX2hlaWdodFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHNpemVbMV0gPSB0aGlzLmNvbnN0cnVjdG9yLm1pbl9oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzaXplWzFdICs9IDY7IC8vbWFyZ2luXG5cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYWxsIHRoZSBpbmZvIGF2YWlsYWJsZSBhYm91dCBhIHByb3BlcnR5IG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0UHJvcGVydHlJbmZvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgb2JqZWN0IHdpdGggYWxsIHRoZSBhdmFpbGFibGUgaW5mb1xuICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJbmZvID0gZnVuY3Rpb24oIHByb3BlcnR5IClcblx0e1xuICAgICAgICB2YXIgaW5mbyA9IG51bGw7XG5cblx0XHQvL3RoZXJlIGFyZSBzZXZlcmFsIHdheXMgdG8gZGVmaW5lIGluZm8gYWJvdXQgYSBwcm9wZXJ0eVxuXHRcdC8vbGVnYWN5IG1vZGVcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzX2luZm8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzX2luZm8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzX2luZm9baV0ubmFtZSA9PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvID0gdGhpcy5wcm9wZXJ0aWVzX2luZm9baV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXHRcdC8vbGl0ZXNjZW5lIG1vZGUgdXNpbmcgdGhlIGNvbnN0cnVjdG9yXG5cdFx0aWYodGhpcy5jb25zdHJ1Y3RvcltcIkBcIiArIHByb3BlcnR5XSlcblx0XHRcdGluZm8gPSB0aGlzLmNvbnN0cnVjdG9yW1wiQFwiICsgcHJvcGVydHldO1xuXG5cdFx0aWYodGhpcy5jb25zdHJ1Y3Rvci53aWRnZXRzX2luZm8gJiYgdGhpcy5jb25zdHJ1Y3Rvci53aWRnZXRzX2luZm9bcHJvcGVydHldKVxuXHRcdFx0aW5mbyA9IHRoaXMuY29uc3RydWN0b3Iud2lkZ2V0c19pbmZvW3Byb3BlcnR5XTtcblxuXHRcdC8vbGl0ZXNjZW5lIG1vZGUgdXNpbmcgdGhlIGNvbnN0cnVjdG9yXG5cdFx0aWYgKCFpbmZvICYmIHRoaXMub25HZXRQcm9wZXJ0eUluZm8pIHtcbiAgICAgICAgICAgIGluZm8gPSB0aGlzLm9uR2V0UHJvcGVydHlJbmZvKHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgIGluZm8gPSB7fTtcblx0XHRpZighaW5mby50eXBlKVxuXHRcdFx0aW5mby50eXBlID0gdHlwZW9mIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eV07XG5cdFx0aWYoaW5mby53aWRnZXQgPT0gXCJjb21ib1wiKVxuXHRcdFx0aW5mby50eXBlID0gXCJlbnVtXCI7XG5cblx0XHRyZXR1cm4gaW5mbztcblx0fVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIHdpZGdldCBpbnNpZGUgdGhlIG5vZGUsIGl0IHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wIG9mIHRoZSBub2RlLCB5b3UgY2FuIGNvbnRyb2wgbG90cyBvZiBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFdpZGdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB3aWRnZXQgdHlwZSAoY291bGQgYmUgXCJudW1iZXJcIixcInN0cmluZ1wiLFwiY29tYm9cIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSB0ZXh0IHRvIHNob3cgb24gdGhlIHdpZGdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gaXQgY2hhbmdlcyAob3B0aW9uYWxseSwgaXQgY2FuIGJlIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBtb2RpZnkpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNwZWNpYWwgcHJvcGVydGllcyBvZiB0aGlzIHdpZGdldCBcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjcmVhdGVkIHdpZGdldCBvYmplY3RcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiggdHlwZSwgbmFtZSwgdmFsdWUsIGNhbGxiYWNrLCBvcHRpb25zIClcblx0e1xuICAgICAgICBpZiAoIXRoaXMud2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIH1cblxuXHRcdGlmKCFvcHRpb25zICYmIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdFx0e1xuXHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSAvL29wdGlvbnMgY2FuIGJlIHRoZSBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRvcHRpb25zID0geyBwcm9wZXJ0eTogb3B0aW9ucyB9O1xuXG5cdFx0aWYoY2FsbGJhY2sgJiYgY2FsbGJhY2suY29uc3RydWN0b3IgPT09IFN0cmluZykgLy9jYWxsYmFjayBjYW4gYmUgdGhlIHByb3BlcnR5IG5hbWVcblx0XHR7XG5cdFx0XHRpZighb3B0aW9ucylcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0b3B0aW9ucy5wcm9wZXJ0eSA9IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbilcblx0XHR7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJhZGRXaWRnZXQ6IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHR9XG5cbiAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3Lm9wdGlvbnMueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3LnkgPSB3Lm9wdGlvbnMueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgIXcub3B0aW9ucy5jYWxsYmFjayAmJiAhdy5vcHRpb25zLnByb3BlcnR5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJMaXRlR3JhcGggYWRkV2lkZ2V0KC4uLikgd2l0aG91dCBhIGNhbGxiYWNrIG9yIHByb3BlcnR5IGFzc2lnbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09IFwiY29tYm9cIiAmJiAhdy5vcHRpb25zLnZhbHVlcykge1xuICAgICAgICAgICAgdGhyb3cgXCJMaXRlR3JhcGggYWRkV2lkZ2V0KCdjb21ibycsLi4uKSByZXF1aXJlcyB0byBwYXNzIHZhbHVlcyBpbiBvcHRpb25zOiB7IHZhbHVlczpbJ3JlZCcsJ2JsdWUnXSB9XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2godyk7XG5cdFx0dGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZEN1c3RvbVdpZGdldCA9IGZ1bmN0aW9uKGN1c3RvbV93aWRnZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpZGdldHMpIHtcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKGN1c3RvbV93aWRnZXQpO1xuICAgICAgICByZXR1cm4gY3VzdG9tX3dpZGdldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgYm91bmRpbmcgb2YgdGhlIG9iamVjdCwgdXNlZCBmb3IgcmVuZGVyaW5nIHB1cnBvc2VzXG4gICAgICogYm91bmRpbmcgaXM6IFt0b3BsZWZ0X2Nvcm5lcngsIHRvcGxlZnRfY29ybmVyeSwgd2lkdGgsIGhlaWdodF1cbiAgICAgKiBAbWV0aG9kIGdldEJvdW5kaW5nXG4gICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5WzRdfSB0aGUgdG90YWwgc2l6ZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSAtIDQ7XG4gICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICBvdXRbMl0gPSB0aGlzLnNpemVbMF0gKyA0O1xuICAgICAgICBvdXRbM10gPSB0aGlzLmZsYWdzLmNvbGxhcHNlZCA/IExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCA6IHRoaXMuc2l6ZVsxXSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcblxuICAgICAgICBpZiAodGhpcy5vbkJvdW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9uQm91bmRpbmcob3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhlIHNoYXBlIG9mIGEgbm9kZVxuICAgICAqIEBtZXRob2QgaXNQb2ludEluc2lkZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmlzUG9pbnRJbnNpZGUgPSBmdW5jdGlvbih4LCB5LCBtYXJnaW4sIHNraXBfdGl0bGUpIHtcbiAgICAgICAgbWFyZ2luID0gbWFyZ2luIHx8IDA7XG5cbiAgICAgICAgdmFyIG1hcmdpbl90b3AgPSB0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGguaXNMaXZlKCkgPyAwIDogTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICBpZiAoc2tpcF90aXRsZSkge1xuICAgICAgICAgICAgbWFyZ2luX3RvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiYgdGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIC8vaWYgKCBkaXN0YW5jZShbeCx5XSwgW3RoaXMucG9zWzBdICsgdGhpcy5zaXplWzBdKjAuNSwgdGhpcy5wb3NbMV0gKyB0aGlzLnNpemVbMV0qMC41XSkgPCBMaXRlR3JhcGguTk9ERV9DT0xMQVBTRURfUkFESVVTKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc1swXSAtIG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgLSBtYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9jb2xsYXBzZWRfd2lkdGggfHwgTGl0ZUdyYXBoLk5PREVfQ09MTEFQU0VEX1dJRFRIKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAyICogbWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAyICogbWFyZ2luXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLnBvc1swXSAtIDQgLSBtYXJnaW4gPCB4ICYmXG4gICAgICAgICAgICB0aGlzLnBvc1swXSArIHRoaXMuc2l6ZVswXSArIDQgKyBtYXJnaW4gPiB4ICYmXG4gICAgICAgICAgICB0aGlzLnBvc1sxXSAtIG1hcmdpbl90b3AgLSBtYXJnaW4gPCB5ICYmXG4gICAgICAgICAgICB0aGlzLnBvc1sxXSArIHRoaXMuc2l6ZVsxXSArIG1hcmdpbiA+IHlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiBhIHBvaW50IGlzIGluc2lkZSBhIG5vZGUgc2xvdCwgYW5kIHJldHVybnMgaW5mbyBhYm91dCB3aGljaCBzbG90XG4gICAgICogQG1ldGhvZCBnZXRTbG90SW5Qb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGlmIGZvdW5kIHRoZSBvYmplY3QgY29udGFpbnMgeyBpbnB1dHxvdXRwdXQ6IHNsb3Qgb2JqZWN0LCBzbG90OiBudW1iZXIsIGxpbmtfcG9zOiBbeCx5XSB9XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0U2xvdEluUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIC8vc2VhcmNoIGZvciBpbnB1dHNcbiAgICAgICAgdmFyIGxpbmtfcG9zID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ubmVjdGlvblBvcyh0cnVlLCBpLCBsaW5rX3Bvcyk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzFdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbnB1dDogaW5wdXQsIHNsb3Q6IGksIGxpbmtfcG9zOiBsaW5rX3BvcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb25uZWN0aW9uUG9zKGZhbHNlLCBpLCBsaW5rX3Bvcyk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzFdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBvdXRwdXQ6IG91dHB1dCwgc2xvdDogaSwgbGlua19wb3M6IGxpbmtfcG9zIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGlucHV0IHNsb3Qgd2l0aCBhIGdpdmVuIG5hbWUgKHVzZWQgZm9yIGR5bmFtaWMgc2xvdHMpLCAtMSBpZiBub3QgZm91bmRcbiAgICAgKiBAbWV0aG9kIGZpbmRJbnB1dFNsb3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc2xvdFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHNsb3QgKC0xIGlmIG5vdCBmb3VuZClcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5maW5kSW5wdXRTbG90ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09IHRoaXMuaW5wdXRzW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIG91dHB1dCBzbG90IHdpdGggYSBnaXZlbiBuYW1lICh1c2VkIGZvciBkeW5hbWljIHNsb3RzKSwgLTEgaWYgbm90IGZvdW5kXG4gICAgICogQG1ldGhvZCBmaW5kT3V0cHV0U2xvdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBzbG90XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgc2xvdCAoLTEgaWYgbm90IGZvdW5kKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmZpbmRPdXRwdXRTbG90ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gdGhpcy5vdXRwdXRzW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgdGhpcyBub2RlIG91dHB1dCB0byB0aGUgaW5wdXQgb2YgYW5vdGhlciBub2RlXG4gICAgICogQG1ldGhvZCBjb25uZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcGFyYW0ge0xHcmFwaE5vZGV9IG5vZGUgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSB0YXJnZXRfc2xvdCB0aGUgaW5wdXQgc2xvdCBvZiB0aGUgdGFyZ2V0IG5vZGUgKGNvdWxkIGJlIHRoZSBudW1iZXIgb2YgdGhlIHNsb3Qgb3IgdGhlIHN0cmluZyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBzbG90LCBvciAtMSB0byBjb25uZWN0IGEgdHJpZ2dlcilcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBsaW5rX2luZm8gaXMgY3JlYXRlZCwgb3RoZXJ3aXNlIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oc2xvdCwgdGFyZ2V0X25vZGUsIHRhcmdldF9zbG90KSB7XG4gICAgICAgIHRhcmdldF9zbG90ID0gdGFyZ2V0X3Nsb3QgfHwgMDtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vY291bGQgYmUgY29ubmVjdGVkIGJlZm9yZSBhZGRpbmcgaXQgdG8gYSBncmFwaFxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJDb25uZWN0OiBFcnJvciwgbm9kZSBkb2Vzbid0IGJlbG9uZyB0byBhbnkgZ3JhcGguIE5vZGVzIG11c3QgYmUgYWRkZWQgZmlyc3QgdG8gYSBncmFwaCBiZWZvcmUgY29ubmVjdGluZyB0aGVtLlwiXG4gICAgICAgICAgICApOyAvL2R1ZSB0byBsaW5rIGlkcyBiZWluZyBhc3NvY2lhdGVkIHdpdGggZ3JhcGhzXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2VlayBmb3IgdGhlIG91dHB1dCBzbG90XG4gICAgICAgIGlmIChzbG90LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgIHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KHNsb3QpO1xuICAgICAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIG5vIHNsb3Qgb2YgbmFtZSBcIiArIHNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vdXRwdXRzIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIHNsb3QgbnVtYmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldF9ub2RlICYmIHRhcmdldF9ub2RlLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIHRhcmdldF9ub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZCh0YXJnZXRfbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXRfbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJ0YXJnZXQgbm9kZSBpcyBudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2F2b2lkIGxvb3BiYWNrXG4gICAgICAgIGlmICh0YXJnZXRfbm9kZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8veW91IGNhbiBzcGVjaWZ5IHRoZSBzbG90IGJ5IG5hbWVcbiAgICAgICAgaWYgKHRhcmdldF9zbG90LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgIHRhcmdldF9zbG90ID0gdGFyZ2V0X25vZGUuZmluZElucHV0U2xvdCh0YXJnZXRfc2xvdCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0X3Nsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb25uZWN0OiBFcnJvciwgbm8gc2xvdCBvZiBuYW1lIFwiICsgdGFyZ2V0X3Nsb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0X3Nsb3QgPT09IExpdGVHcmFwaC5FVkVOVCkge1xuICAgICAgICAgICAgLy9zZWFyY2ggZm9yIGZpcnN0IHNsb3Qgd2l0aCBldmVudD9cbiAgICAgICAgICAgIC8qXG5cdFx0Ly9jcmVhdGUgaW5wdXQgZm9yIHRyaWdnZXJcblx0XHR2YXIgaW5wdXQgPSB0YXJnZXRfbm9kZS5hZGRJbnB1dChcIm9uVHJpZ2dlclwiLCBMaXRlR3JhcGguRVZFTlQgKTtcblx0XHR0YXJnZXRfc2xvdCA9IHRhcmdldF9ub2RlLmlucHV0cy5sZW5ndGggLSAxOyAvL2xhc3Qgb25lIGlzIHRoZSBvbmUgY3JlYXRlZFxuXHRcdHRhcmdldF9ub2RlLm1vZGUgPSBMaXRlR3JhcGguT05fVFJJR0dFUjtcblx0XHQqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAhdGFyZ2V0X25vZGUuaW5wdXRzIHx8XG4gICAgICAgICAgICB0YXJnZXRfc2xvdCA+PSB0YXJnZXRfbm9kZS5pbnB1dHMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIHNsb3QgbnVtYmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vaWYgdGhlcmUgaXMgc29tZXRoaW5nIGFscmVhZHkgcGx1Z2dlZCB0aGVyZSwgZGlzY29ubmVjdFxuICAgICAgICBpZiAodGFyZ2V0X25vZGUuaW5wdXRzW3RhcmdldF9zbG90XS5saW5rICE9IG51bGwpIHtcblx0XHRcdHRoaXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICB0YXJnZXRfbm9kZS5kaXNjb25uZWN0SW5wdXQodGFyZ2V0X3Nsb3QpO1xuXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL3doeSBoZXJlPz9cbiAgICAgICAgLy90aGlzLnNldERpcnR5Q2FudmFzKGZhbHNlLHRydWUpO1xuICAgICAgICAvL3RoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSggdGhpcyApO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbc2xvdF07XG5cbiAgICAgICAgLy9hbGxvd3Mgbm9kZXMgdG8gYmxvY2sgY29ubmVjdGlvblxuICAgICAgICBpZiAodGFyZ2V0X25vZGUub25Db25uZWN0SW5wdXQpIHtcbiAgICAgICAgICAgIGlmICggdGFyZ2V0X25vZGUub25Db25uZWN0SW5wdXQodGFyZ2V0X3Nsb3QsIG91dHB1dC50eXBlLCBvdXRwdXQsIHRoaXMsIHNsb3QpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnB1dCA9IHRhcmdldF9ub2RlLmlucHV0c1t0YXJnZXRfc2xvdF07XG4gICAgICAgIHZhciBsaW5rX2luZm8gPSBudWxsO1xuXG5cdFx0Ly90aGlzIHNsb3RzIGNhbm5vdCBiZSBjb25uZWN0ZWQgKGRpZmZlcmVudCB0eXBlcylcbiAgICAgICAgaWYgKCFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24ob3V0cHV0LnR5cGUsIGlucHV0LnR5cGUpKVxuXHRcdHtcblx0ICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKGZhbHNlLCB0cnVlKTtcblx0XHRcdGlmKGNoYW5nZWQpXG5cdFx0ICAgICAgICB0aGlzLmdyYXBoLmNvbm5lY3Rpb25DaGFuZ2UodGhpcywgbGlua19pbmZvKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmKCFjaGFuZ2VkKVxuXHRcdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcblxuXHRcdC8vY3JlYXRlIGxpbmsgY2xhc3Ncblx0XHRsaW5rX2luZm8gPSBuZXcgTExpbmsoXG5cdFx0XHQrK3RoaXMuZ3JhcGgubGFzdF9saW5rX2lkLFxuXHRcdFx0aW5wdXQudHlwZSxcblx0XHRcdHRoaXMuaWQsXG5cdFx0XHRzbG90LFxuXHRcdFx0dGFyZ2V0X25vZGUuaWQsXG5cdFx0XHR0YXJnZXRfc2xvdFxuXHRcdCk7XG5cblx0XHQvL2FkZCB0byBncmFwaCBsaW5rcyBsaXN0XG5cdFx0dGhpcy5ncmFwaC5saW5rc1tsaW5rX2luZm8uaWRdID0gbGlua19pbmZvO1xuXG5cdFx0Ly9jb25uZWN0IGluIG91dHB1dFxuXHRcdGlmIChvdXRwdXQubGlua3MgPT0gbnVsbCkge1xuXHRcdFx0b3V0cHV0LmxpbmtzID0gW107XG5cdFx0fVxuXHRcdG91dHB1dC5saW5rcy5wdXNoKGxpbmtfaW5mby5pZCk7XG5cdFx0Ly9jb25uZWN0IGluIGlucHV0XG5cdFx0dGFyZ2V0X25vZGUuaW5wdXRzW3RhcmdldF9zbG90XS5saW5rID0gbGlua19pbmZvLmlkO1xuXHRcdGlmICh0aGlzLmdyYXBoKSB7XG5cdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UpIHtcblx0XHRcdHRoaXMub25Db25uZWN0aW9uc0NoYW5nZShcblx0XHRcdFx0TGl0ZUdyYXBoLk9VVFBVVCxcblx0XHRcdFx0c2xvdCxcblx0XHRcdFx0dHJ1ZSxcblx0XHRcdFx0bGlua19pbmZvLFxuXHRcdFx0XHRvdXRwdXRcblx0XHRcdCk7XG5cdFx0fSAvL2xpbmtfaW5mbyBoYXMgYmVlbiBjcmVhdGVkIG5vdywgc28gaXRzIHVwZGF0ZWRcblx0XHRpZiAodGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZSkge1xuXHRcdFx0dGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZShcblx0XHRcdFx0TGl0ZUdyYXBoLklOUFVULFxuXHRcdFx0XHR0YXJnZXRfc2xvdCxcblx0XHRcdFx0dHJ1ZSxcblx0XHRcdFx0bGlua19pbmZvLFxuXHRcdFx0XHRpbnB1dFxuXHRcdFx0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZ3JhcGggJiYgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKSB7XG5cdFx0XHR0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG5cdFx0XHRcdExpdGVHcmFwaC5JTlBVVCxcblx0XHRcdFx0dGFyZ2V0X25vZGUsXG5cdFx0XHRcdHRhcmdldF9zbG90LFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRzbG90XG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuXHRcdFx0XHRMaXRlR3JhcGguT1VUUFVULFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRzbG90LFxuXHRcdFx0XHR0YXJnZXRfbm9kZSxcblx0XHRcdFx0dGFyZ2V0X3Nsb3Rcblx0XHRcdCk7XG5cdFx0fVxuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXMoZmFsc2UsIHRydWUpO1xuXHRcdHRoaXMuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcblx0XHR0aGlzLmdyYXBoLmNvbm5lY3Rpb25DaGFuZ2UodGhpcywgbGlua19pbmZvKTtcblxuICAgICAgICByZXR1cm4gbGlua19pbmZvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0IG9uZSBvdXRwdXQgdG8gYW4gc3BlY2lmaWMgbm9kZVxuICAgICAqIEBtZXRob2QgZGlzY29ubmVjdE91dHB1dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyX29yX3N0cmluZ30gc2xvdCAoY291bGQgYmUgdGhlIG51bWJlciBvZiB0aGUgc2xvdCBvciB0aGUgc3RyaW5nIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNsb3QpXG4gICAgICogQHBhcmFtIHtMR3JhcGhOb2RlfSB0YXJnZXRfbm9kZSB0aGUgdGFyZ2V0IG5vZGUgdG8gd2hpY2ggdGhpcyBzbG90IGlzIGNvbm5lY3RlZCBbT3B0aW9uYWwsIGlmIG5vdCB0YXJnZXRfbm9kZSBpcyBzcGVjaWZpZWQgYWxsIG5vZGVzIHdpbGwgYmUgZGlzY29ubmVjdGVkXVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGl0IHdhcyBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdE91dHB1dCA9IGZ1bmN0aW9uKHNsb3QsIHRhcmdldF9ub2RlKSB7XG4gICAgICAgIGlmIChzbG90LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgIHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KHNsb3QpO1xuICAgICAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIG5vIHNsb3Qgb2YgbmFtZSBcIiArIHNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3V0cHV0cyB8fCBzbG90ID49IHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3Q6IEVycm9yLCBzbG90IG51bWJlciBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL2dldCBvdXRwdXQgc2xvdFxuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dCB8fCAhb3V0cHV0LmxpbmtzIHx8IG91dHB1dC5saW5rcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9vbmUgb2YgdGhlIG91dHB1dCBsaW5rcyBpbiB0aGlzIHNsb3RcbiAgICAgICAgaWYgKHRhcmdldF9ub2RlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZCh0YXJnZXRfbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhcmdldF9ub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUYXJnZXQgTm9kZSBub3QgZm91bmRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvdXRwdXQubGlua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSBvdXRwdXQubGlua3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG5cbiAgICAgICAgICAgICAgICAvL2lzIHRoZSBsaW5rIHdlIGFyZSBzZWFyY2hpbmcgZm9yLi4uXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtfaW5mby50YXJnZXRfaWQgPT0gdGFyZ2V0X25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmtzLnNwbGljZShpLCAxKTsgLy9yZW1vdmUgaGVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0YXJnZXRfbm9kZS5pbnB1dHNbbGlua19pbmZvLnRhcmdldF9zbG90XTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubGluayA9IG51bGw7IC8vcmVtb3ZlIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdOyAvL3JlbW92ZSB0aGUgbGluayBmcm9tIHRoZSBsaW5rcyBwb29sXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldF9ub2RlLm9uQ29ubmVjdGlvbnNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlLm9uQ29ubmVjdGlvbnNDaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLklOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby50YXJnZXRfc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy9saW5rX2luZm8gaGFzbid0IGJlZW4gbW9kaWZpZWQgc28gaXRzIG9rXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uc0NoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvL2FsbCB0aGUgbGlua3MgaW4gdGhpcyBvdXRwdXQgc2xvdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3V0cHV0LmxpbmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX2lkID0gb3V0cHV0LmxpbmtzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYnVnOiBpdCBoYXBwZW5zIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby50YXJnZXRfaWQpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0YXJnZXRfbm9kZS5pbnB1dHNbbGlua19pbmZvLnRhcmdldF9zbG90XTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQubGluayA9IG51bGw7IC8vcmVtb3ZlIG90aGVyIHNpZGUgbGlua1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSAvL2xpbmtfaW5mbyBoYXNuJ3QgYmVlbiBtb2RpZmllZCBzbyBpdHMgb2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGggJiYgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLklOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby50YXJnZXRfc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTsgLy9yZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgbGlua3MgcG9vbFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk9VVFBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk9VVFBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5JTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LmxpbmtzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXMoZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLmdyYXBoLmNvbm5lY3Rpb25DaGFuZ2UodGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0IG9uZSBpbnB1dFxuICAgICAqIEBtZXRob2QgZGlzY29ubmVjdElucHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiBpdCB3YXMgZGlzY29ubmVjdGVkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3RJbnB1dCA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgLy9zZWVrIGZvciB0aGUgb3V0cHV0IHNsb3RcbiAgICAgICAgaWYgKHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChzbG90KTtcbiAgICAgICAgICAgIGlmIChzbG90ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3Q6IEVycm9yLCBubyBzbG90IG9mIG5hbWUgXCIgKyBzbG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlucHV0cyB8fCBzbG90ID49IHRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIHNsb3QgbnVtYmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMuaW5wdXRzW3Nsb3RdLmxpbms7XG5cdFx0aWYobGlua19pZCAhPSBudWxsKVxuXHRcdHtcblx0XHRcdHRoaXMuaW5wdXRzW3Nsb3RdLmxpbmsgPSBudWxsO1xuXG5cdFx0XHQvL3JlbW92ZSBvdGhlciBzaWRlXG5cdFx0XHR2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcblx0XHRcdGlmIChsaW5rX2luZm8pIHtcblx0XHRcdFx0dmFyIHRhcmdldF9ub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rX2luZm8ub3JpZ2luX2lkKTtcblx0XHRcdFx0aWYgKCF0YXJnZXRfbm9kZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvdXRwdXQgPSB0YXJnZXRfbm9kZS5vdXRwdXRzW2xpbmtfaW5mby5vcmlnaW5fc2xvdF07XG5cdFx0XHRcdGlmICghb3V0cHV0IHx8ICFvdXRwdXQubGlua3MgfHwgb3V0cHV0LmxpbmtzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9zZWFyY2ggaW4gdGhlIGlucHV0cyBsaXN0IGZvciB0aGlzIGxpbmtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvdXRwdXQubGlua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKG91dHB1dC5saW5rc1tpXSA9PSBsaW5rX2lkKSB7XG5cdFx0XHRcdFx0XHRvdXRwdXQubGlua3Muc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07IC8vcmVtb3ZlIGZyb20gdGhlIHBvb2xcblx0XHRcdFx0aWYgKHRoaXMuZ3JhcGgpIHtcblx0XHRcdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuXHRcdFx0XHRcdHRoaXMub25Db25uZWN0aW9uc0NoYW5nZShcblx0XHRcdFx0XHRcdExpdGVHcmFwaC5JTlBVVCxcblx0XHRcdFx0XHRcdHNsb3QsXG5cdFx0XHRcdFx0XHRmYWxzZSxcblx0XHRcdFx0XHRcdGxpbmtfaW5mbyxcblx0XHRcdFx0XHRcdGlucHV0XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZSkge1xuXHRcdFx0XHRcdHRhcmdldF9ub2RlLm9uQ29ubmVjdGlvbnNDaGFuZ2UoXG5cdFx0XHRcdFx0XHRMaXRlR3JhcGguT1VUUFVULFxuXHRcdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRcdGZhbHNlLFxuXHRcdFx0XHRcdFx0bGlua19pbmZvLFxuXHRcdFx0XHRcdFx0b3V0cHV0XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcblx0XHRcdFx0XHR0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG5cdFx0XHRcdFx0XHRMaXRlR3JhcGguT1VUUFVULFxuXHRcdFx0XHRcdFx0dGFyZ2V0X25vZGUsXG5cdFx0XHRcdFx0XHRpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoTGl0ZUdyYXBoLklOUFVULCB0aGlzLCBzbG90KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gLy9saW5rICE9IG51bGxcblxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKGZhbHNlLCB0cnVlKTtcblx0XHRpZih0aGlzLmdyYXBoKVxuXHQgICAgICAgIHRoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGNlbnRlciBvZiBhIGNvbm5lY3Rpb24gcG9pbnQgaW4gY2FudmFzIGNvb3Jkc1xuICAgICAqIEBtZXRob2QgZ2V0Q29ubmVjdGlvblBvc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfaW5wdXQgdHJ1ZSBpZiBpZiBhIGlucHV0IHNsb3QsIGZhbHNlIGlmIGl0IGlzIGFuIG91dHB1dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyX29yX3N0cmluZ30gc2xvdCAoY291bGQgYmUgdGhlIG51bWJlciBvZiB0aGUgc2xvdCBvciB0aGUgc3RyaW5nIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNsb3QpXG4gICAgICogQHBhcmFtIHt2ZWMyfSBvdXQgW29wdGlvbmFsXSBhIHBsYWNlIHRvIHN0b3JlIHRoZSBvdXRwdXQsIHRvIGZyZWUgZ2FyYmFnZVxuICAgICAqIEByZXR1cm4ge1t4LHldfSB0aGUgcG9zaXRpb25cbiAgICAgKiovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvblBvcyA9IGZ1bmN0aW9uKFxuICAgICAgICBpc19pbnB1dCxcbiAgICAgICAgc2xvdF9udW1iZXIsXG4gICAgICAgIG91dFxuICAgICkge1xuICAgICAgICBvdXQgPSBvdXQgfHwgbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgdmFyIG51bV9zbG90cyA9IDA7XG4gICAgICAgIGlmIChpc19pbnB1dCAmJiB0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgbnVtX3Nsb3RzID0gdGhpcy5pbnB1dHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNfaW5wdXQgJiYgdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBudW1fc2xvdHMgPSB0aGlzLm91dHB1dHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICogMC41O1xuXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLl9jb2xsYXBzZWRfd2lkdGggfHwgTGl0ZUdyYXBoLk5PREVfQ09MTEFQU0VEX1dJRFRIO1xuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IHRoaXMucG9zWzBdICsgdyAqIDAuNTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF0gKyB3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlaXJkIGZlYXR1cmUgdGhhdCBuZXZlciBnb3QgZmluaXNoZWRcbiAgICAgICAgaWYgKGlzX2lucHV0ICYmIHNsb3RfbnVtYmVyID09IC0xKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAqIDAuNTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogMC41O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaGFyZC1jb2RlZCBwb3NcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNfaW5wdXQgJiZcbiAgICAgICAgICAgIG51bV9zbG90cyA+IHNsb3RfbnVtYmVyICYmXG4gICAgICAgICAgICB0aGlzLmlucHV0c1tzbG90X251bWJlcl0ucG9zXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF0gKyB0aGlzLmlucHV0c1tzbG90X251bWJlcl0ucG9zWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gKyB0aGlzLmlucHV0c1tzbG90X251bWJlcl0ucG9zWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICFpc19pbnB1dCAmJlxuICAgICAgICAgICAgbnVtX3Nsb3RzID4gc2xvdF9udW1iZXIgJiZcbiAgICAgICAgICAgIHRoaXMub3V0cHV0c1tzbG90X251bWJlcl0ucG9zXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF0gKyB0aGlzLm91dHB1dHNbc2xvdF9udW1iZXJdLnBvc1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdICsgdGhpcy5vdXRwdXRzW3Nsb3RfbnVtYmVyXS5wb3NbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ob3Jpem9udGFsIGRpc3RyaWJ1dGVkIHNsb3RzXG4gICAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIG91dFswXSA9XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NbMF0gKyAoc2xvdF9udW1iZXIgKyAwLjUpICogKHRoaXMuc2l6ZVswXSAvIG51bV9zbG90cyk7XG4gICAgICAgICAgICBpZiAoaXNfaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gKyB0aGlzLnNpemVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9kZWZhdWx0IHZlcnRpY2FsIHNsb3RzXG4gICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF0gKyBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHRoaXMuc2l6ZVswXSArIDEgLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb3V0WzFdID1cbiAgICAgICAgICAgIHRoaXMucG9zWzFdICtcbiAgICAgICAgICAgIChzbG90X251bWJlciArIDAuNykgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCArXG4gICAgICAgICAgICAodGhpcy5jb25zdHJ1Y3Rvci5zbG90X3N0YXJ0X3kgfHwgMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIC8qIEZvcmNlIGFsaWduIHRvIGdyaWQgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hbGlnblRvR3JpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBvc1swXSA9XG4gICAgICAgICAgICBMaXRlR3JhcGguQ0FOVkFTX0dSSURfU0laRSAqXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMucG9zWzBdIC8gTGl0ZUdyYXBoLkNBTlZBU19HUklEX1NJWkUpO1xuICAgICAgICB0aGlzLnBvc1sxXSA9XG4gICAgICAgICAgICBMaXRlR3JhcGguQ0FOVkFTX0dSSURfU0laRSAqXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMucG9zWzFdIC8gTGl0ZUdyYXBoLkNBTlZBU19HUklEX1NJWkUpO1xuICAgIH07XG5cbiAgICAvKiBDb25zb2xlIG91dHB1dCAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25zb2xlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNvbGUgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uc29sZS5wdXNoKG1zZyk7XG4gICAgICAgIGlmICh0aGlzLmNvbnNvbGUubGVuZ3RoID4gTEdyYXBoTm9kZS5NQVhfQ09OU09MRSkge1xuICAgICAgICAgICAgdGhpcy5jb25zb2xlLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuXHRcdGlmKHRoaXMuZ3JhcGgub25Ob2RlVHJhY2UpXG5cdCAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVUcmFjZSh0aGlzLCBtc2cpO1xuICAgIH07XG5cbiAgICAvKiBGb3JjZXMgdG8gcmVkcmF3IG9yIHRoZSBtYWluIGNhbnZhcyAoTEdyYXBoTm9kZSkgb3IgdGhlIGJnIGNhbnZhcyAobGlua3MpICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0RGlydHlDYW52YXMgPSBmdW5jdGlvbihcbiAgICAgICAgZGlydHlfZm9yZWdyb3VuZCxcbiAgICAgICAgZGlydHlfYmFja2dyb3VuZFxuICAgICkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoLnNlbmRBY3Rpb25Ub0NhbnZhcyhcInNldERpcnR5XCIsIFtcbiAgICAgICAgICAgIGRpcnR5X2ZvcmVncm91bmQsXG4gICAgICAgICAgICBkaXJ0eV9iYWNrZ3JvdW5kXG4gICAgICAgIF0pO1xuICAgIH07XG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuc3JjID0gTGl0ZUdyYXBoLm5vZGVfaW1hZ2VzX3BhdGggKyB1cmw7XG4gICAgICAgIGltZy5yZWFkeSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB0aGF0LnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH07XG5cbiAgICAvL3NhZmUgTEdyYXBoTm9kZSBhY3Rpb24gZXhlY3V0aW9uIChub3Qgc3VyZSBpZiBzYWZlKVxuICAgIC8qXG5MR3JhcGhOb2RlLnByb3RvdHlwZS5leGVjdXRlQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKVxue1xuXHRpZihhY3Rpb24gPT0gXCJcIikgcmV0dXJuIGZhbHNlO1xuXG5cdGlmKCBhY3Rpb24uaW5kZXhPZihcIjtcIikgIT0gLTEgfHwgYWN0aW9uLmluZGV4T2YoXCJ9XCIpICE9IC0xKVxuXHR7XG5cdFx0dGhpcy50cmFjZShcIkVycm9yOiBBY3Rpb24gY29udGFpbnMgdW5zYWZlIGNoYXJhY3RlcnNcIik7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIHRva2VucyA9IGFjdGlvbi5zcGxpdChcIihcIik7XG5cdHZhciBmdW5jX25hbWUgPSB0b2tlbnNbMF07XG5cdGlmKCB0eXBlb2YodGhpc1tmdW5jX25hbWVdKSAhPSBcImZ1bmN0aW9uXCIpXG5cdHtcblx0XHR0aGlzLnRyYWNlKFwiRXJyb3I6IEFjdGlvbiBub3QgZm91bmQgb24gbm9kZTogXCIgKyBmdW5jX25hbWUpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjb2RlID0gYWN0aW9uO1xuXG5cdHRyeVxuXHR7XG5cdFx0dmFyIF9mb28gPSBldmFsO1xuXHRcdGV2YWwgPSBudWxsO1xuXHRcdChuZXcgRnVuY3Rpb24oXCJ3aXRoKHRoaXMpIHsgXCIgKyBjb2RlICsgXCJ9XCIpKS5jYWxsKHRoaXMpO1xuXHRcdGV2YWwgPSBfZm9vO1xuXHR9XG5cdGNhdGNoIChlcnIpXG5cdHtcblx0XHR0aGlzLnRyYWNlKFwiRXJyb3IgZXhlY3V0aW5nIGFjdGlvbiB7XCIgKyBhY3Rpb24gKyBcIn0gOlwiICsgZXJyKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cbiovXG5cbiAgICAvKiBBbGxvd3MgdG8gZ2V0IG9uTW91c2VNb3ZlIGFuZCBvbk1vdXNlVXAgZXZlbnRzIGV2ZW4gaWYgdGhlIG1vdXNlIGlzIG91dCBvZiBmb2N1cyAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNhcHR1cmVJbnB1dCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoIHx8ICF0aGlzLmdyYXBoLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5ncmFwaC5saXN0X29mX2dyYXBoY2FudmFzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBsaXN0W2ldO1xuICAgICAgICAgICAgLy9yZWxlYXNpbmcgc29tZWJvZHkgZWxzZXMgY2FwdHVyZT8hXG4gICAgICAgICAgICBpZiAoIXYgJiYgYy5ub2RlX2NhcHR1cmluZ19pbnB1dCAhPSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY2hhbmdlXG4gICAgICAgICAgICBjLm5vZGVfY2FwdHVyaW5nX2lucHV0ID0gdiA/IHRoaXMgOiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIHRoZSBub2RlIHRvIG1ha2UgaXQgc21hbGxlciBvbiB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBjb2xsYXBzZVxuICAgICAqKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuY29sbGFwc2FibGUgPT09IGZhbHNlICYmICFmb3JjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBub2RlIHRvIGRvIG5vdCBtb3ZlIG9yIHJlYWxpZ24gb24gWlxuICAgICAqIEBtZXRob2QgcGluXG4gICAgICoqL1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUucGluID0gZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MucGlubmVkID0gIXRoaXMuZmxhZ3MucGlubmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5waW5uZWQgPSB2O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmxvY2FsVG9TY3JlZW4gPSBmdW5jdGlvbih4LCB5LCBncmFwaGNhbnZhcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHggKyB0aGlzLnBvc1swXSkgKiBncmFwaGNhbnZhcy5zY2FsZSArIGdyYXBoY2FudmFzLm9mZnNldFswXSxcbiAgICAgICAgICAgICh5ICsgdGhpcy5wb3NbMV0pICogZ3JhcGhjYW52YXMuc2NhbGUgKyBncmFwaGNhbnZhcy5vZmZzZXRbMV1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTEdyYXBoR3JvdXAodGl0bGUpIHtcbiAgICAgICAgdGhpcy5fY3Rvcih0aXRsZSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsLkxHcmFwaEdyb3VwID0gTGl0ZUdyYXBoLkxHcmFwaEdyb3VwID0gTEdyYXBoR3JvdXA7XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUuX2N0b3IgPSBmdW5jdGlvbih0aXRsZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGUgfHwgXCJHcm91cFwiO1xuICAgICAgICB0aGlzLmZvbnRfc2l6ZSA9IDI0O1xuICAgICAgICB0aGlzLmNvbG9yID0gTEdyYXBoQ2FudmFzLm5vZGVfY29sb3JzLnBhbGVfYmx1ZVxuICAgICAgICAgICAgPyBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMucGFsZV9ibHVlLmdyb3VwY29sb3JcbiAgICAgICAgICAgIDogXCIjQUFBXCI7XG4gICAgICAgIHRoaXMuX2JvdW5kaW5nID0gbmV3IEZsb2F0MzJBcnJheShbMTAsIDEwLCAxNDAsIDgwXSk7XG4gICAgICAgIHRoaXMuX3BvcyA9IHRoaXMuX2JvdW5kaW5nLnN1YmFycmF5KDAsIDIpO1xuICAgICAgICB0aGlzLl9zaXplID0gdGhpcy5fYm91bmRpbmcuc3ViYXJyYXkoMiwgNCk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgICAgIHRoaXMuZ3JhcGggPSBudWxsO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYgfHwgdi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zWzBdID0gdlswXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NbMV0gPSB2WzFdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2IHx8IHYubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NpemVbMF0gPSBNYXRoLm1heCgxNDAsIHZbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpemVbMV0gPSBNYXRoLm1heCg4MCwgdlsxXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24obykge1xuICAgICAgICB0aGlzLnRpdGxlID0gby50aXRsZTtcbiAgICAgICAgdGhpcy5fYm91bmRpbmcuc2V0KG8uYm91bmRpbmcpO1xuICAgICAgICB0aGlzLmNvbG9yID0gby5jb2xvcjtcbiAgICAgICAgdGhpcy5mb250ID0gby5mb250O1xuICAgIH07XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5fYm91bmRpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgICAgICAgIGJvdW5kaW5nOiBbXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChiWzBdKSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGJbMV0pLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoYlsyXSksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChiWzNdKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgZm9udDogdGhpcy5mb250XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGVsdGF4LCBkZWx0YXksIGlnbm9yZV9ub2Rlcykge1xuICAgICAgICB0aGlzLl9wb3NbMF0gKz0gZGVsdGF4O1xuICAgICAgICB0aGlzLl9wb3NbMV0gKz0gZGVsdGF5O1xuICAgICAgICBpZiAoaWdub3JlX25vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgICAgICAgIG5vZGUucG9zWzBdICs9IGRlbHRheDtcbiAgICAgICAgICAgIG5vZGUucG9zWzFdICs9IGRlbHRheTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUucmVjb21wdXRlSW5zaWRlTm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ncmFwaC5fbm9kZXM7XG4gICAgICAgIHZhciBub2RlX2JvdW5kaW5nID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgbm9kZS5nZXRCb3VuZGluZyhub2RlX2JvdW5kaW5nKTtcbiAgICAgICAgICAgIGlmICghb3ZlcmxhcEJvdW5kaW5nKHRoaXMuX2JvdW5kaW5nLCBub2RlX2JvdW5kaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvL291dCBvZiB0aGUgdmlzaWJsZSBhcmVhXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5pc1BvaW50SW5zaWRlID0gTEdyYXBoTm9kZS5wcm90b3R5cGUuaXNQb2ludEluc2lkZTtcbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUuc2V0RGlydHlDYW52YXMgPSBMR3JhcGhOb2RlLnByb3RvdHlwZS5zZXREaXJ0eUNhbnZhcztcblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy9TY2FsZSBhbmQgT2Zmc2V0XG4gICAgZnVuY3Rpb24gRHJhZ0FuZFNjYWxlKGVsZW1lbnQsIHNraXBfZXZlbnRzKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xuICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5tYXhfc2NhbGUgPSAxMDtcbiAgICAgICAgdGhpcy5taW5fc2NhbGUgPSAwLjE7XG4gICAgICAgIHRoaXMub25yZWRyYXcgPSBudWxsO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2UgPSBbMCwgMF07XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJsZV9hcmVhID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGlmICghc2tpcF9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBMaXRlR3JhcGguRHJhZ0FuZFNjYWxlID0gRHJhZ0FuZFNjYWxlO1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLmxhc3RfbW91c2UgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXG4gICAgICAgIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayA9IHRoaXMub25Nb3VzZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2spO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrKTtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcIm1vdXNld2hlZWxcIixcbiAgICAgICAgICAgIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjaywgZmFsc2UpO1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmNvbXB1dGVWaXNpYmxlQXJlYSA9IGZ1bmN0aW9uKCB2aWV3cG9ydCApIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzBdID0gdGhpcy52aXNpYmxlX2FyZWFbMV0gPSB0aGlzLnZpc2libGVfYXJlYVsyXSA9IHRoaXMudmlzaWJsZV9hcmVhWzNdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmVsZW1lbnQud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB2YXIgc3RhcnR4ID0gLXRoaXMub2Zmc2V0WzBdO1xuICAgICAgICB2YXIgc3RhcnR5ID0gLXRoaXMub2Zmc2V0WzFdO1xuXHRcdGlmKCB2aWV3cG9ydCApXG5cdFx0e1xuXHRcdFx0c3RhcnR4ICs9IHZpZXdwb3J0WzBdIC8gdGhpcy5zY2FsZTtcblx0XHRcdHN0YXJ0eSArPSB2aWV3cG9ydFsxXSAvIHRoaXMuc2NhbGU7XG5cdFx0XHR3aWR0aCA9IHZpZXdwb3J0WzJdO1xuXHRcdFx0aGVpZ2h0ID0gdmlld3BvcnRbM107XG5cdFx0fVxuICAgICAgICB2YXIgZW5keCA9IHN0YXJ0eCArIHdpZHRoIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGVuZHkgPSBzdGFydHkgKyBoZWlnaHQgLyB0aGlzLnNjYWxlO1xuICAgICAgICB0aGlzLnZpc2libGVfYXJlYVswXSA9IHN0YXJ0eDtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMV0gPSBzdGFydHk7XG4gICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzJdID0gZW5keCAtIHN0YXJ0eDtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbM10gPSBlbmR5IC0gc3RhcnR5O1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIHZhciB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIGUuY2FudmFzeCA9IHg7XG4gICAgICAgIGUuY2FudmFzeSA9IHk7XG4gICAgICAgIGUuZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nO1xuXG5cdFx0dmFyIGlzX2luc2lkZSA9ICF0aGlzLnZpZXdwb3J0IHx8ICggdGhpcy52aWV3cG9ydCAmJiB4ID49IHRoaXMudmlld3BvcnRbMF0gJiYgeCA8ICh0aGlzLnZpZXdwb3J0WzBdICsgdGhpcy52aWV3cG9ydFsyXSkgJiYgeSA+PSB0aGlzLnZpZXdwb3J0WzFdICYmIHkgPCAodGhpcy52aWV3cG9ydFsxXSArIHRoaXMudmlld3BvcnRbM10pICk7XG5cbiAgICAgICAgdmFyIGlnbm9yZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vbm1vdXNlKSB7XG4gICAgICAgICAgICBpZ25vcmUgPSB0aGlzLm9ubW91c2UoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09IFwibW91c2Vkb3duXCIgJiYgaXNfaW5zaWRlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZW1vdmVcIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrICk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoIFwibW91c2V1cFwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2sgKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gXCJtb3VzZW1vdmVcIikge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0geCAtIHRoaXMubGFzdF9tb3VzZVswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0geSAtIHRoaXMubGFzdF9tb3VzZVsxXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlRHJhZyhkZWx0YXgsIGRlbHRheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBcIm1vdXNldXBcIikge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayApO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIGlzX2luc2lkZSAmJlxuICAgICAgICAgICAgKGUudHlwZSA9PSBcIm1vdXNld2hlZWxcIiB8fFxuICAgICAgICAgICAgZS50eXBlID09IFwid2hlZWxcIiB8fFxuICAgICAgICAgICAgZS50eXBlID09IFwiRE9NTW91c2VTY3JvbGxcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBlLmV2ZW50VHlwZSA9IFwibW91c2V3aGVlbFwiO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PSBcIndoZWVsXCIpIHtcbiAgICAgICAgICAgICAgICBlLndoZWVsID0gLWUuZGVsdGFZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLndoZWVsID1cbiAgICAgICAgICAgICAgICAgICAgZS53aGVlbERlbHRhWSAhPSBudWxsID8gZS53aGVlbERlbHRhWSA6IGUuZGV0YWlsICogLTYwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Zyb20gc3RhY2sgb3ZlcmZsb3dcbiAgICAgICAgICAgIGUuZGVsdGEgPSBlLndoZWVsRGVsdGFcbiAgICAgICAgICAgICAgICA/IGUud2hlZWxEZWx0YSAvIDQwXG4gICAgICAgICAgICAgICAgOiBlLmRlbHRhWVxuICAgICAgICAgICAgICAgID8gLWUuZGVsdGFZIC8gM1xuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGVsdGFTY2FsZSgxLjAgKyBlLmRlbHRhICogMC4wNSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RfbW91c2VbMF0gPSB4O1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VbMV0gPSB5O1xuXG5cdFx0aWYoaXNfaW5zaWRlKVxuXHRcdHtcblx0ICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0ICAgIHJldHVybiBmYWxzZTtcblx0XHR9XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUudG9DYW52YXNDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLCB0aGlzLnNjYWxlKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLm9mZnNldFswXSwgdGhpcy5vZmZzZXRbMV0pO1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmNvbnZlcnRPZmZzZXRUb0NhbnZhcyA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAvL3JldHVybiBbcG9zWzBdIC8gdGhpcy5zY2FsZSAtIHRoaXMub2Zmc2V0WzBdLCBwb3NbMV0gLyB0aGlzLnNjYWxlIC0gdGhpcy5vZmZzZXRbMV1dO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHBvc1swXSArIHRoaXMub2Zmc2V0WzBdKSAqIHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAocG9zWzFdICsgdGhpcy5vZmZzZXRbMV0pICogdGhpcy5zY2FsZVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmNvbnZlcnRDYW52YXNUb09mZnNldCA9IGZ1bmN0aW9uKHBvcywgb3V0KSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBbMCwgMF07XG4gICAgICAgIG91dFswXSA9IHBvc1swXSAvIHRoaXMuc2NhbGUgLSB0aGlzLm9mZnNldFswXTtcbiAgICAgICAgb3V0WzFdID0gcG9zWzFdIC8gdGhpcy5zY2FsZSAtIHRoaXMub2Zmc2V0WzFdO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLm1vdXNlRHJhZyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5vZmZzZXRbMF0gKz0geCAvIHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMub2Zmc2V0WzFdICs9IHkgLyB0aGlzLnNjYWxlO1xuXG4gICAgICAgIGlmICh0aGlzLm9ucmVkcmF3KSB7XG4gICAgICAgICAgICB0aGlzLm9ucmVkcmF3KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuY2hhbmdlU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSwgem9vbWluZ19jZW50ZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5taW5fc2NhbGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5taW5fc2NhbGU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiB0aGlzLm1heF9zY2FsZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1heF9zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PSB0aGlzLnNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgem9vbWluZ19jZW50ZXIgPSB6b29taW5nX2NlbnRlciB8fCBbXG4gICAgICAgICAgICByZWN0LndpZHRoICogMC41LFxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgKiAwLjVcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY29udmVydENhbnZhc1RvT2Zmc2V0KHpvb21pbmdfY2VudGVyKTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHZhbHVlO1xuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zY2FsZSAtIDEpIDwgMC4wMSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2NlbnRlciA9IHRoaXMuY29udmVydENhbnZhc1RvT2Zmc2V0KHpvb21pbmdfY2VudGVyKTtcbiAgICAgICAgdmFyIGRlbHRhX29mZnNldCA9IFtcbiAgICAgICAgICAgIG5ld19jZW50ZXJbMF0gLSBjZW50ZXJbMF0sXG4gICAgICAgICAgICBuZXdfY2VudGVyWzFdIC0gY2VudGVyWzFdXG4gICAgICAgIF07XG5cbiAgICAgICAgdGhpcy5vZmZzZXRbMF0gKz0gZGVsdGFfb2Zmc2V0WzBdO1xuICAgICAgICB0aGlzLm9mZnNldFsxXSArPSBkZWx0YV9vZmZzZXRbMV07XG5cbiAgICAgICAgaWYgKHRoaXMub25yZWRyYXcpIHtcbiAgICAgICAgICAgIHRoaXMub25yZWRyYXcodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS5jaGFuZ2VEZWx0YVNjYWxlID0gZnVuY3Rpb24odmFsdWUsIHpvb21pbmdfY2VudGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU2NhbGUodGhpcy5zY2FsZSAqIHZhbHVlLCB6b29taW5nX2NlbnRlcik7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgICAgIHRoaXMub2Zmc2V0WzBdID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXRbMV0gPSAwO1xuICAgIH07XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vIExHcmFwaENhbnZhczogTEdyYXBoIHJlbmRlcmVyIENMQVNTXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3MgaXMgaW4gY2hhcmdlIG9mIHJlbmRlcmluZyBvbmUgZ3JhcGggaW5zaWRlIGEgY2FudmFzLiBBbmQgcHJvdmlkZXMgYWxsIHRoZSBpbnRlcmFjdGlvbiByZXF1aXJlZC5cbiAgICAgKiBWYWxpZCBjYWxsYmFja3MgYXJlOiBvbk5vZGVTZWxlY3RlZCwgb25Ob2RlRGVzZWxlY3RlZCwgb25TaG93Tm9kZVBhbmVsLCBvbk5vZGVEYmxDbGlja2VkXG4gICAgICpcbiAgICAgKiBAY2xhc3MgTEdyYXBoQ2FudmFzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzfSBjYW52YXMgdGhlIGNhbnZhcyB3aGVyZSB5b3Ugd2FudCB0byByZW5kZXIgKGl0IGFjY2VwdHMgYSBzZWxlY3RvciBpbiBzdHJpbmcgZm9ybWF0IG9yIHRoZSBjYW52YXMgZWxlbWVudCBpdHNlbGYpXG4gICAgICogQHBhcmFtIHtMR3JhcGh9IGdyYXBoIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBbb3B0aW9uYWxdIHsgc2tpcF9yZW5kZXJpbmcsIGF1dG9yZXNpemUsIHZpZXdwb3J0IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMR3JhcGhDYW52YXMoY2FudmFzLCBncmFwaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvL2lmKGdyYXBoID09PSB1bmRlZmluZWQpXG4gICAgICAgIC8vXHR0aHJvdyAoXCJObyBncmFwaCBhc3NpZ25lZFwiKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kX2ltYWdlID0gTEdyYXBoQ2FudmFzLkRFRkFVTFRfQkFDS0dST1VORF9JTUFHRTtcblxuICAgICAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRzID0gbmV3IERyYWdBbmRTY2FsZSgpO1xuICAgICAgICB0aGlzLnpvb21fbW9kaWZ5X2FscGhhID0gdHJ1ZTsgLy9vdGhlcndpc2UgaXQgZ2VuZXJhdGVzIHVnbHkgcGF0dGVybnMgd2hlbiBzY2FsaW5nIGRvd24gdG9vIG11Y2hcblxuICAgICAgICB0aGlzLnRpdGxlX3RleHRfZm9udCA9IFwiXCIgKyBMaXRlR3JhcGguTk9ERV9URVhUX1NJWkUgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIHRoaXMuaW5uZXJfdGV4dF9mb250ID1cbiAgICAgICAgICAgIFwibm9ybWFsIFwiICsgTGl0ZUdyYXBoLk5PREVfU1VCVEVYVF9TSVpFICsgXCJweCBBcmlhbFwiO1xuICAgICAgICB0aGlzLm5vZGVfdGl0bGVfY29sb3IgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9DT0xPUjtcbiAgICAgICAgdGhpcy5kZWZhdWx0X2xpbmtfY29sb3IgPSBMaXRlR3JhcGguTElOS19DT0xPUjtcbiAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3IgPSB7XG4gICAgICAgICAgICBpbnB1dF9vZmY6IFwiIzc3OFwiLFxuICAgICAgICAgICAgaW5wdXRfb246IFwiIzdGN1wiLFxuICAgICAgICAgICAgb3V0cHV0X29mZjogXCIjNzc4XCIsXG4gICAgICAgICAgICBvdXRwdXRfb246IFwiIzdGN1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5oaWdocXVhbGl0eV9yZW5kZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnVzZV9ncmFkaWVudHMgPSBmYWxzZTsgLy9zZXQgdG8gdHJ1ZSB0byByZW5kZXIgdGl0bGViYXIgd2l0aCBncmFkaWVudHNcbiAgICAgICAgdGhpcy5lZGl0b3JfYWxwaGEgPSAxOyAvL3VzZWQgZm9yIHRyYW5zaXRpb25cbiAgICAgICAgdGhpcy5wYXVzZV9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbGVhcl9iYWNrZ3JvdW5kID0gdHJ1ZTtcblxuXHRcdHRoaXMucmVhZF9vbmx5ID0gZmFsc2U7IC8vaWYgc2V0IHRvIHRydWUgdXNlcnMgY2Fubm90IG1vZGlmeSB0aGUgZ3JhcGhcbiAgICAgICAgdGhpcy5yZW5kZXJfb25seV9zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGl2ZV9tb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvd19pbmZvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbGxvd19kcmFnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbGxvd19kcmFnbm9kZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmFsbG93X2ludGVyYWN0aW9uID0gdHJ1ZTsgLy9hbGxvdyB0byBjb250cm9sIHdpZGdldHMsIGJ1dHRvbnMsIGNvbGxhcHNlLCBldGNcbiAgICAgICAgdGhpcy5hbGxvd19zZWFyY2hib3ggPSB0cnVlO1xuICAgICAgICB0aGlzLmFsbG93X3JlY29ubmVjdF9saW5rcyA9IGZhbHNlOyAvL2FsbG93cyB0byBjaGFuZ2UgYSBjb25uZWN0aW9uIHdpdGggaGF2aW5nIHRvIHJlZG8gaXQgYWdhaW5cblx0XHR0aGlzLmFsaWduX3RvX2dyaWQgPSBmYWxzZTsgLy9zbmFwIHRvIGdyaWRcblxuICAgICAgICB0aGlzLmRyYWdfbW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsOyAvL2FsbG93cyB0byBmaWx0ZXIgdG8gb25seSBhY2NlcHQgc29tZSB0eXBlIG9mIG5vZGVzIGluIGEgZ3JhcGhcblxuXHRcdHRoaXMuc2V0X2NhbnZhc19kaXJ0eV9vbl9tb3VzZV9ldmVudCA9IHRydWU7IC8vZm9yY2VzIHRvIHJlZHJhdyB0aGUgY2FudmFzIGlmIHRoZSBtb3VzZSBkb2VzIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWx3YXlzX3JlbmRlcl9iYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyX3NoYWRvd3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcl9jYW52YXNfYm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfY29ubmVjdGlvbnNfc2hhZG93cyA9IGZhbHNlOyAvL3RvbyBtdWNoIGNwdVxuICAgICAgICB0aGlzLnJlbmRlcl9jb25uZWN0aW9uc19ib3JkZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcl9jdXJ2ZWRfY29ubmVjdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfY29ubmVjdGlvbl9hcnJvd3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfY29sbGFwc2VkX3Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfZXhlY3V0aW9uX29yZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyX3RpdGxlX2NvbG9yZWQgPSB0cnVlO1xuXHRcdHRoaXMucmVuZGVyX2xpbmtfdG9vbHRpcCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5saW5rc19yZW5kZXJfbW9kZSA9IExpdGVHcmFwaC5TUExJTkVfTElOSztcblxuICAgICAgICB0aGlzLm1vdXNlID0gWzAsIDBdOyAvL21vdXNlIGluIGNhbnZhcyBjb29yZGluYXRlcywgd2hlcmUgMCwwIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGJsdWUgcmVjdGFuZ2xlXG4gICAgICAgIHRoaXMuZ3JhcGhfbW91c2UgPSBbMCwgMF07IC8vbW91c2UgaW4gZ3JhcGggY29vcmRpbmF0ZXMsIHdoZXJlIDAsMCBpcyB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBibHVlIHJlY3RhbmdsZVxuXHRcdHRoaXMuY2FudmFzX21vdXNlID0gdGhpcy5ncmFwaF9tb3VzZTsgLy9MRUdBQ1k6IFJFTU9WRSBUSElTLCBVU0UgR1JBUEhfTU9VU0UgSU5TVEVBRFxuXG4gICAgICAgIC8vdG8gcGVyc29uYWxpemUgdGhlIHNlYXJjaCBib3hcbiAgICAgICAgdGhpcy5vblNlYXJjaEJveCA9IG51bGw7XG4gICAgICAgIHRoaXMub25TZWFyY2hCb3hTZWxlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgIC8vY2FsbGJhY2tzXG4gICAgICAgIHRoaXMub25Nb3VzZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25EcmF3QmFja2dyb3VuZCA9IG51bGw7IC8vdG8gcmVuZGVyIGJhY2tncm91bmQgb2JqZWN0cyAoYmVoaW5kIG5vZGVzIGFuZCBjb25uZWN0aW9ucykgaW4gdGhlIGNhbnZhcyBhZmZlY3RlZCBieSB0cmFuc2Zvcm1cbiAgICAgICAgdGhpcy5vbkRyYXdGb3JlZ3JvdW5kID0gbnVsbDsgLy90byByZW5kZXIgZm9yZWdyb3VuZCBvYmplY3RzIChhYm92ZSBub2RlcyBhbmQgY29ubmVjdGlvbnMpIGluIHRoZSBjYW52YXMgYWZmZWN0ZWQgYnkgdHJhbnNmb3JtXG4gICAgICAgIHRoaXMub25EcmF3T3ZlcmxheSA9IG51bGw7IC8vdG8gcmVuZGVyIGZvcmVncm91bmQgb2JqZWN0cyBub3QgYWZmZWN0ZWQgYnkgdHJhbnNmb3JtIChmb3IgR1VJcylcblx0XHR0aGlzLm9uRHJhd0xpbmtUb29sdGlwID0gbnVsbDsgLy9jYWxsZWQgd2hlbiByZW5kZXJpbmcgYSB0b29sdGlwXG5cdFx0dGhpcy5vbk5vZGVNb3ZlZCA9IG51bGw7IC8vY2FsbGVkIGFmdGVyIG1vdmluZyBhIG5vZGVcblx0XHR0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gbnVsbDsgLy9jYWxsZWQgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzXG5cdFx0dGhpcy5vbkNvbm5lY3RpbmdDaGFuZ2UgPSBudWxsOyAvL2NhbGxlZCBiZWZvcmUgYW55IGxpbmsgY2hhbmdlc1xuXHRcdHRoaXMub25CZWZvcmVDaGFuZ2UgPSBudWxsOyAvL2NhbGxlZCBiZWZvcmUgbW9kaWZ5aW5nIHRoZSBncmFwaFxuXHRcdHRoaXMub25BZnRlckNoYW5nZSA9IG51bGw7IC8vY2FsbGVkIGFmdGVyIG1vZGlmeWluZyB0aGUgZ3JhcGhcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoID0gMztcbiAgICAgICAgdGhpcy5yb3VuZF9yYWRpdXMgPSA4O1xuXG4gICAgICAgIHRoaXMuY3VycmVudF9ub2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlX3dpZGdldCA9IG51bGw7IC8vdXNlZCBmb3Igd2lkZ2V0c1xuXHRcdHRoaXMub3Zlcl9saW5rX2NlbnRlciA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9wb3NpdGlvbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWEgPSB0aGlzLmRzLnZpc2libGVfYXJlYTtcbiAgICAgICAgdGhpcy52aXNpYmxlX2xpbmtzID0gW107XG5cblx0XHR0aGlzLnZpZXdwb3J0ID0gb3B0aW9ucy52aWV3cG9ydCB8fCBudWxsOyAvL3RvIGNvbnN0cmFpbnQgcmVuZGVyIGFyZWEgdG8gYSBwb3J0aW9uIG9mIHRoZSBjYW52YXNcblxuICAgICAgICAvL2xpbmsgY2FudmFzIGFuZCBncmFwaFxuICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIGdyYXBoLmF0dGFjaENhbnZhcyh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q2FudmFzKGNhbnZhcyxvcHRpb25zLnNraXBfZXZlbnRzKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5za2lwX3JlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdXRvcmVzaXplID0gb3B0aW9ucy5hdXRvcmVzaXplO1xuICAgIH1cblxuICAgIGdsb2JhbC5MR3JhcGhDYW52YXMgPSBMaXRlR3JhcGguTEdyYXBoQ2FudmFzID0gTEdyYXBoQ2FudmFzO1xuXG5cdExHcmFwaENhbnZhcy5ERUZBVUxUX0JBQ0tHUk9VTkRfSU1BR0UgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBR1FBQUFCa0NBSUFBQUQvZ0FJREFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUJKUkVGVWVOcnMxckVLd2pBVWhsRVRVa2ozdlA5cmRtcjFZc2FtbWsydzV3ZHh1TGdjTUh5cHRmYXd1Wlg0cEpTV1pUbmZudS9sbkllL2pOTnhISEdObi8vSE5iYnYrNGRyNlYrMTF1RjUyN2FyVTcrdTYzcWZhL2JubWg4c1dMQmd3WUpscVJmOE1FcHRYUEJYSlhhMzdCU2wzaXhZc0dEQk1saXdGTHlDVi9EZUxJTUZDeFlzV0xCTXdTdDRCZS9OZ2dYTFlNR0NCVXZCSzNpTnJ1QzlXYkJnd1lKbHNHQXBlQVd2NEwxWkJnc1dMRml3WUptQ1YvQUszcHNGQzViQmdnVUxsb0pYOEJwZHdYdXpZTUdDQmN0Z3dWTHdDbDdCZTdNTUZpeFlzR0RCc3U4RkgxRmFTbUV4VmZBeEJhL2d2Vm13WU1HQ1piQmcvVzR2QVFZQTV0UkY5UVlsdi9RQUFBQUFTVVZPUks1Q1lJST1cIjtcblxuICAgIExHcmFwaENhbnZhcy5saW5rX3R5cGVfY29sb3JzID0ge1xuICAgICAgICBcIi0xXCI6IExpdGVHcmFwaC5FVkVOVF9MSU5LX0NPTE9SLFxuICAgICAgICBudW1iZXI6IFwiI0FBQVwiLFxuICAgICAgICBub2RlOiBcIiNEQ0FcIlxuICAgIH07XG4gICAgTEdyYXBoQ2FudmFzLmdyYWRpZW50cyA9IHt9OyAvL2NhY2hlIG9mIGdyYWRpZW50c1xuXG4gICAgLyoqXG4gICAgICogY2xlYXJzIGFsbCB0aGUgZGF0YSBpbnNpZGVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RfZHJhd190aW1lID0gMDtcbiAgICAgICAgdGhpcy5yZW5kZXJfdGltZSA9IDA7XG4gICAgICAgIHRoaXMuZnBzID0gMDtcblxuICAgICAgICAvL3RoaXMuc2NhbGUgPSAxO1xuICAgICAgICAvL3RoaXMub2Zmc2V0ID0gWzAsMF07XG5cbiAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlX25vZGVzID0gW107XG4gICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlX292ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzID0ge307XG5cblx0XHR0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlydHlfYXJlYSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5ub2RlX2luX3BhbmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlX3dpZGdldCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5sYXN0X21vdXNlID0gWzAsIDBdO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VjbGljayA9IDA7XG4gICAgICAgIHRoaXMudmlzaWJsZV9hcmVhLnNldChbMCwgMCwgMCwgMF0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9uQ2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMub25DbGVhcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFzc2lnbnMgYSBncmFwaCwgeW91IGNhbiByZWFzc2lnbiBncmFwaHMgdG8gdGhlIHNhbWUgY2FudmFzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldEdyYXBoXG4gICAgICogQHBhcmFtIHtMR3JhcGh9IGdyYXBoXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXRHcmFwaCA9IGZ1bmN0aW9uKGdyYXBoLCBza2lwX2NsZWFyKSB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoID09IGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNraXBfY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ3JhcGggJiYgdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5kZXRhY2hDYW52YXModGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaC5hdHRhY2hDYW52YXModGhpcyk7XG5cblx0XHQvL3JlbW92ZSB0aGUgZ3JhcGggc3RhY2sgaW4gY2FzZSBhIHN1YmdyYXBoIHdhcyBvcGVuXG5cdFx0aWYgKHRoaXMuX2dyYXBoX3N0YWNrKVxuXHRcdFx0dGhpcy5fZ3JhcGhfc3RhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHRvcCBsZXZlbCBncmFwaCAoaW4gY2FzZSB0aGVyZSBhcmUgc3ViZ3JhcGhzIG9wZW4gb24gdGhlIGNhbnZhcylcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0VG9wR3JhcGhcbiAgICAgKiBAcmV0dXJuIHtMR3JhcGh9IGdyYXBoXG4gICAgICovXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuZ2V0VG9wR3JhcGggPSBmdW5jdGlvbigpXG5cdHtcblx0XHRpZih0aGlzLl9ncmFwaF9zdGFjay5sZW5ndGgpXG5cdFx0XHRyZXR1cm4gdGhpcy5fZ3JhcGhfc3RhY2tbMF07XG5cdFx0cmV0dXJuIHRoaXMuZ3JhcGg7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIG9wZW5zIGEgZ3JhcGggY29udGFpbmVkIGluc2lkZSBhIG5vZGUgaW4gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb3BlblN1YmdyYXBoXG4gICAgICogQHBhcmFtIHtMR3JhcGh9IGdyYXBoXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5vcGVuU3ViZ3JhcGggPSBmdW5jdGlvbihncmFwaCkge1xuICAgICAgICBpZiAoIWdyYXBoKSB7XG4gICAgICAgICAgICB0aHJvdyBcImdyYXBoIGNhbm5vdCBiZSBudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmFwaCA9PSBncmFwaCkge1xuICAgICAgICAgICAgdGhyb3cgXCJncmFwaCBjYW5ub3QgYmUgdGhlIHNhbWVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ncmFwaF9zdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoX3N0YWNrID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ncmFwaF9zdGFjay5wdXNoKHRoaXMuZ3JhcGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JhcGguYXR0YWNoQ2FudmFzKHRoaXMpO1xuXHRcdHRoaXMuY2hlY2tQYW5lbHMoKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2xvc2VzIGEgc3ViZ3JhcGggY29udGFpbmVkIGluc2lkZSBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2xvc2VTdWJncmFwaFxuICAgICAqIEBwYXJhbSB7TEdyYXBofSBhc3NpZ25zIGEgZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNsb3NlU3ViZ3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ncmFwaF9zdGFjayB8fCB0aGlzLl9ncmFwaF9zdGFjay5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJncmFwaF9ub2RlID0gdGhpcy5ncmFwaC5fc3ViZ3JhcGhfbm9kZTtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5fZ3JhcGhfc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZF9saW5rcyA9IHt9O1xuICAgICAgICBncmFwaC5hdHRhY2hDYW52YXModGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzdWJncmFwaF9ub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlck9uTm9kZShzdWJncmFwaF9ub2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoW3N1YmdyYXBoX25vZGVdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB2aXN1YWx5IGFjdGl2ZSBncmFwaCAoaW4gY2FzZSB0aGVyZSBhcmUgbW9yZSBpbiB0aGUgc3RhY2spXG4gICAgICogQG1ldGhvZCBnZXRDdXJyZW50R3JhcGhcbiAgICAgKiBAcmV0dXJuIHtMR3JhcGh9IHRoZSBhY3RpdmUgZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldEN1cnJlbnRHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXNzaWducyBhIGNhbnZhc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRDYW52YXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gYXNzaWducyBhIGNhbnZhcyAoYWxzbyBhY2NlcHRzIHRoZSBJRCBvZiB0aGUgZWxlbWVudCAobm90IGEgc2VsZWN0b3IpXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXRDYW52YXMgPSBmdW5jdGlvbihjYW52YXMsIHNraXBfZXZlbnRzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgY3JlYXRpbmcgTGl0ZUdyYXBoIGNhbnZhczogQ2FudmFzIG5vdCBmb3VuZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW52YXMgPT09IHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbnZhcyAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgLy9tYXliZSBkZXRhY2ggZXZlbnRzIGZyb20gb2xkX2NhbnZhc1xuICAgICAgICAgICAgaWYgKCFza2lwX2V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5kcy5lbGVtZW50ID0gY2FudmFzO1xuXG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuY2FudmFzLnRhYmluZGV4ID0gXCIxMDAwXCI7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgKz0gXCIgbGdyYXBoY2FudmFzXCI7XG4gICAgICAgIGNhbnZhcy5kYXRhID0gdGhpcztcbiAgICAgICAgY2FudmFzLnRhYmluZGV4ID0gXCIxXCI7IC8vdG8gYWxsb3cga2V5IGV2ZW50c1xuXG4gICAgICAgIC8vYmcgY2FudmFzOiB1c2VkIGZvciBub24gY2hhbmdpbmcgc3R1ZmZcbiAgICAgICAgdGhpcy5iZ2NhbnZhcyA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5iZ2NhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5iZ2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICB0aGlzLmJnY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmJnY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW52YXMuZ2V0Q29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLmxvY2FsTmFtZSAhPSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFbGVtZW50IHN1cHBsaWVkIGZvciBMR3JhcGhDYW52YXMgbXVzdCBiZSBhIDxjYW52YXM+IGVsZW1lbnQsIHlvdSBwYXNzZWQgYSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5sb2NhbE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgQ2FudmFzXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3R4ID0gKHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSk7XG4gICAgICAgIGlmIChjdHggPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFjYW52YXMud2ViZ2xfZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIGNhbnZhcyBzZWVtcyB0byBiZSBXZWJHTCwgZW5hYmxpbmcgV2ViR0wgcmVuZGVyZXJcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVdlYkdMKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lucHV0OiAgKG1vdmUgYW5kIHVwIGNvdWxkIGJlIHVuYmluZGVkKVxuICAgICAgICB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2V1cF9jYWxsYmFjayA9IHRoaXMucHJvY2Vzc01vdXNlVXAuYmluZCh0aGlzKTtcblxuICAgICAgICBpZiAoIXNraXBfZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL3VzZWQgaW4gc29tZSBldmVudHMgdG8gY2FwdHVyZSB0aGVtXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5fZG9Ob3RoaW5nID0gZnVuY3Rpb24gZG9Ob3RoaW5nKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLl9kb1JldHVyblRydWUgPSBmdW5jdGlvbiBkb05vdGhpbmcoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBiaW5kcyBtb3VzZSwga2V5Ym9hcmQsIHRvdWNoIGFuZCBkcmFnIGV2ZW50cyB0byB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBiaW5kRXZlbnRzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRzX2JpbmRlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTEdyYXBoQ2FudmFzOiBldmVudHMgYWxyZWFkeSBiaW5kZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSB0aGlzLmdldENhbnZhc1dpbmRvdygpO1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSByZWZfd2luZG93LmRvY3VtZW50OyAvL2hhY2sgdXNlZCB3aGVuIG1vdmluZyBjYW52YXMgYmV0d2VlbiB3aW5kb3dzXG5cbiAgICAgICAgdGhpcy5fbW91c2Vkb3duX2NhbGxiYWNrID0gdGhpcy5wcm9jZXNzTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNld2hlZWxfY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NNb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3RvdWNoX2NhbGxiYWNrID0gdGhpcy50b3VjaEhhbmRsZXIuYmluZCh0aGlzKTtcblxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2ssIHRydWUpOyAvL2Rvd24gZG8gbm90IG5lZWQgdG8gc3RvcmUgdGhlIGJpbmRlZFxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2spO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5fZG9Ob3RoaW5nKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsX2NhbGxiYWNrLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvL3RvdWNoIGV2ZW50c1xuICAgICAgICAvL2lmKCAndG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IClcbiAgICAgICAge1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLl90b3VjaF9jYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0tleWJvYXJkICoqKioqKioqKioqKioqKioqKlxuICAgICAgICB0aGlzLl9rZXlfY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NLZXkuYmluZCh0aGlzKTtcblxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5X2NhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2tleV9jYWxsYmFjaywgdHJ1ZSk7IC8vaW4gZG9jdW1lbnQsIG90aGVyd2lzZSBpdCBkb2Vzbid0IGZpcmUga2V5dXBcblxuICAgICAgICAvL0Ryb3BwaW5nIFN0dWZmIG92ZXIgbm9kZXMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIHRoaXMuX29uZHJvcF9jYWxsYmFjayA9IHRoaXMucHJvY2Vzc0Ryb3AuYmluZCh0aGlzKTtcblxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuX2RvTm90aGluZywgZmFsc2UpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgdGhpcy5fZG9Ob3RoaW5nLCBmYWxzZSk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLl9vbmRyb3BfY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgdGhpcy5fZG9SZXR1cm5UcnVlLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzX2JpbmRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHVuYmluZHMgbW91c2UgZXZlbnRzIGZyb20gdGhlIGNhbnZhc1xuICAgICAqIEBtZXRob2QgdW5iaW5kRXZlbnRzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzX2JpbmRlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTEdyYXBoQ2FudmFzOiBubyBldmVudHMgYmluZGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSB0aGlzLmdldENhbnZhc1dpbmRvdygpO1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSByZWZfd2luZG93LmRvY3VtZW50O1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fbW91c2Vkb3duX2NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwibW91c2V3aGVlbFwiLFxuICAgICAgICAgICAgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFja1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJET01Nb3VzZVNjcm9sbFwiLFxuICAgICAgICAgICAgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFja1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlfY2FsbGJhY2spO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fa2V5X2NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHRoaXMuX2RvTm90aGluZyk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuX29uZHJvcF9jYWxsYmFjayk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgdGhpcy5fZG9SZXR1cm5UcnVlKTtcblxuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaF9jYWxsYmFjayApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrICk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaF9jYWxsYmFjayApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2sgKTtcblxuICAgICAgICB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3VzZXdoZWVsX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2V5X2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25kcm9wX2NhbGxiYWNrID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9ldmVudHNfYmluZGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5nZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHZhciBxdWVzdGlvbiA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgaWYgKHF1ZXN0aW9uICE9IC0xKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc3Vic3RyKDAsIHF1ZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnQgPSB1cmwubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICBpZiAocG9pbnQgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyKHBvaW50ICsgMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBhbGxvd3MgdG8gcmVuZGVyIHRoZSBjYW52YXMgdXNpbmcgV2ViR0wgaW5zdGVhZCBvZiBDYW52YXMyRFxuICAgICAqIHRoaXMgaXMgdXNlZnVsIGlmIHlvdSBwbGFudCB0byByZW5kZXIgM0Qgb2JqZWN0cyBpbnNpZGUgeW91ciBub2RlcywgaXQgdXNlcyBsaXRlZ2wuanMgZm9yIHdlYmdsIGFuZCBjYW52YXMyRHRvV2ViR0wgdG8gZW11bGF0ZSB0aGUgQ2FudmFzMkQgY2FsbHMgaW4gd2ViR0xcbiAgICAgKiBAbWV0aG9kIGVuYWJsZVdlYkdMXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZW5hYmxlV2ViR0wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBHTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImxpdGVnbC5qcyBtdXN0IGJlIGluY2x1ZGVkIHRvIHVzZSBhIFdlYkdMIGNhbnZhc1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlV2ViR0xDYW52YXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJ3ZWJnbENhbnZhcy5qcyBtdXN0IGJlIGluY2x1ZGVkIHRvIHVzZSB0aGlzIGZlYXR1cmVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLmN0eCA9IGVuYWJsZVdlYkdMQ2FudmFzKHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5jdHgud2ViZ2wgPSB0cnVlO1xuICAgICAgICB0aGlzLmJnY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHRoaXMuYmdjdHggPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLmNhbnZhcy53ZWJnbF9lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvKlxuXHRHTC5jcmVhdGUoeyBjYW52YXM6IHRoaXMuYmdjYW52YXMgfSk7XG5cdHRoaXMuYmdjdHggPSBlbmFibGVXZWJHTENhbnZhcyggdGhpcy5iZ2NhbnZhcyApO1xuXHR3aW5kb3cuZ2wgPSB0aGlzLmdsO1xuXHQqL1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtYXJrcyBhcyBkaXJ0eSB0aGUgY2FudmFzLCB0aGlzIHdheSBpdCB3aWxsIGJlIHJlbmRlcmVkIGFnYWluXG4gICAgICpcbiAgICAgKiBAY2xhc3MgTEdyYXBoQ2FudmFzXG4gICAgICogQG1ldGhvZCBzZXREaXJ0eVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gZmdjYW52YXMgaWYgdGhlIGZvcmVncm91bmQgY2FudmFzIGlzIGRpcnR5ICh0aGUgb25lIGNvbnRhaW5pbmcgdGhlIG5vZGVzKVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gYmdjYW52YXMgaWYgdGhlIGJhY2tncm91bmQgY2FudmFzIGlzIGRpcnR5ICh0aGUgb25lIGNvbnRhaW5pbmcgdGhlIHdpcmVzKVxuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbihmZ2NhbnZhcywgYmdjYW52YXMpIHtcbiAgICAgICAgaWYgKGZnY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJnY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGF0dGFjaCB0aGUgY2FudmFzIGluIGEgcG9wdXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0Q2FudmFzV2luZG93XG4gICAgICogQHJldHVybiB7d2luZG93fSByZXR1cm5zIHRoZSB3aW5kb3cgd2hlcmUgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCAodGhlIERPTSByb290IG5vZGUpXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5nZXRDYW52YXNXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gdGhpcy5jYW52YXMub3duZXJEb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzdGFydHMgcmVuZGVyaW5nIHRoZSBjb250ZW50IG9mIHRoZSBjYW52YXMgd2hlbiBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3RhcnRSZW5kZXJpbmdcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnN0YXJ0UmVuZGVyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX3JlbmRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vYWxyZWFkeSByZW5kZXJpbmdcblxuICAgICAgICB0aGlzLmlzX3JlbmRlcmluZyA9IHRydWU7XG4gICAgICAgIHJlbmRlckZyYW1lLmNhbGwodGhpcyk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyRnJhbWUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGF1c2VfcmVuZGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSB0aGlzLmdldENhbnZhc1dpbmRvdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfcmVuZGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGcmFtZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzdG9wcyByZW5kZXJpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGNhbnZhcyAodG8gc2F2ZSByZXNvdXJjZXMpXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHN0b3BSZW5kZXJpbmdcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnN0b3BSZW5kZXJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pc19yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgLypcblx0aWYodGhpcy5yZW5kZXJpbmdfdGltZXJfaWQpXG5cdHtcblx0XHRjbGVhckludGVydmFsKHRoaXMucmVuZGVyaW5nX3RpbWVyX2lkKTtcblx0XHR0aGlzLnJlbmRlcmluZ190aW1lcl9pZCA9IG51bGw7XG5cdH1cblx0Ki9cbiAgICB9O1xuXG4gICAgLyogTGl0ZUdyYXBoQ2FudmFzIGlucHV0ICovXG5cblx0Ly91c2VkIHRvIGJsb2NrIGZ1dHVyZSBtb3VzZSBldmVudHMgKGJlY2F1c2Ugb2YgaW0gZ3VpKVxuXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLmJsb2NrQ2xpY2sgPSBmdW5jdGlvbigpXG5cdHtcblx0XHR0aGlzLmJsb2NrX2NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLmxhc3RfbW91c2VjbGljayA9IDA7XG5cdH1cblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc01vdXNlRG93biA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdGlmKCB0aGlzLnNldF9jYW52YXNfZGlydHlfb25fbW91c2VfZXZlbnQgKVxuXHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFxuXHRcdGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGp1c3RNb3VzZUV2ZW50KGUpO1xuXG4gICAgICAgIHZhciByZWZfd2luZG93ID0gdGhpcy5nZXRDYW52YXNXaW5kb3coKTtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gcmVmX3dpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR2YXIgeCA9IGUubG9jYWxYO1xuXHRcdHZhciB5ID0gZS5sb2NhbFk7XG5cdFx0Ly9jb25zb2xlLmxvZyh5LHRoaXMudmlld3BvcnQpO1xuXG5cdFx0dGhpcy5kcy52aWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG5cdFx0dmFyIGlzX2luc2lkZSA9ICF0aGlzLnZpZXdwb3J0IHx8ICggdGhpcy52aWV3cG9ydCAmJiB4ID49IHRoaXMudmlld3BvcnRbMF0gJiYgeCA8ICh0aGlzLnZpZXdwb3J0WzBdICsgdGhpcy52aWV3cG9ydFsyXSkgJiYgeSA+PSB0aGlzLnZpZXdwb3J0WzFdICYmIHkgPCAodGhpcy52aWV3cG9ydFsxXSArIHRoaXMudmlld3BvcnRbM10pICk7XG5cbiAgICAgICAgLy9tb3ZlIG1vdXNlIG1vdmUgZXZlbnQgdG8gdGhlIHdpbmRvdyBpbiBjYXNlIGl0IGRyYWdzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuXHRcdGlmKCF0aGlzLm9wdGlvbnMuc2tpcF9ldmVudHMpXG5cdFx0e1xuXHRcdFx0dGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2spO1xuXHRcdFx0cmVmX3dpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2ssIHRydWUgKTsgLy9jYXRjaCBmb3IgdGhlIGVudGlyZSB3aW5kb3dcblx0XHRcdHJlZl93aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJtb3VzZXVwXCIsIHRoaXMuX21vdXNldXBfY2FsbGJhY2ssIHRydWUgKTtcblx0XHR9XG5cblx0XHRpZighaXNfaW5zaWRlKVxuXHRcdFx0cmV0dXJuO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlT25Qb3MoIGUuY2FudmFzWCwgZS5jYW52YXNZLCB0aGlzLnZpc2libGVfbm9kZXMsIDUgKTtcbiAgICAgICAgdmFyIHNraXBfZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNraXBfYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB2YXIgaXNfZG91YmxlX2NsaWNrID0gbm93IC0gdGhpcy5sYXN0X21vdXNlY2xpY2sgPCAzMDA7XG5cdFx0dGhpcy5tb3VzZVswXSA9IGUubG9jYWxYO1xuXHRcdHRoaXMubW91c2VbMV0gPSBlLmxvY2FsWTtcbiAgICAgICAgdGhpcy5ncmFwaF9tb3VzZVswXSA9IGUuY2FudmFzWDtcbiAgICAgICAgdGhpcy5ncmFwaF9tb3VzZVsxXSA9IGUuY2FudmFzWTtcblx0XHR0aGlzLmxhc3RfY2xpY2tfcG9zaXRpb24gPSBbdGhpcy5tb3VzZVswXSx0aGlzLm1vdXNlWzFdXTtcblxuICAgICAgICB0aGlzLmNhbnZhcy5mb2N1cygpO1xuXG4gICAgICAgIExpdGVHcmFwaC5jbG9zZUFsbENvbnRleHRNZW51cyhyZWZfd2luZG93KTtcblxuICAgICAgICBpZiAodGhpcy5vbk1vdXNlKVxuXHRcdHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uTW91c2UoZSkgPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXHRcdC8vbGVmdCBidXR0b24gbW91c2VcbiAgICAgICAgaWYgKGUud2hpY2ggPT0gMSlcblx0XHR7XG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5KVxuXHRcdFx0e1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVswXSA9IGUuY2FudmFzWDtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXSA9IGUuY2FudmFzWTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsyXSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbM10gPSAxO1xuICAgICAgICAgICAgICAgIHNraXBfYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNsaWNraW5nX2NhbnZhc19iZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvL3doZW4gY2xpY2tlZCBvbiB0b3Agb2YgYSBub2RlXG4gICAgICAgICAgICAvL2FuZCBpdCBpcyBub3QgaW50ZXJhY3RpdmVcbiAgICAgICAgICAgIGlmIChub2RlICYmIHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gJiYgIXNraXBfYWN0aW9uICYmICF0aGlzLnJlYWRfb25seSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saXZlX21vZGUgJiYgIW5vZGUuZmxhZ3MucGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnJpbmdUb0Zyb250KG5vZGUpO1xuICAgICAgICAgICAgICAgIH0gLy9pZiBpdCB3YXNuJ3Qgc2VsZWN0ZWQ/XG5cbiAgICAgICAgICAgICAgICAvL25vdCBkcmFnZ2luZyBtb3VzZSB0byBjb25uZWN0IHR3byBzbG90c1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuY29ubmVjdGluZ19ub2RlICYmICFub2RlLmZsYWdzLmNvbGxhcHNlZCAmJiAhdGhpcy5saXZlX21vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vU2VhcmNoIGZvciBjb3JuZXIgZm9yIHJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhc2tpcF9hY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVzaXphYmxlICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1swXSArIG5vZGUuc2l6ZVswXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gKyBub2RlLnNpemVbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuXHRcdFx0XHRcdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcdFx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXppbmdfbm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcInNlLXJlc2l6ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWFyY2ggZm9yIG91dHB1dHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBub2RlLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19wb3MgPSBub2RlLmdldENvbm5lY3Rpb25Qb3MoZmFsc2UsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzBdIC0gMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKCBmYWxzZSwgaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QgPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdE91dHB1dChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2RvdWJsZV9jbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uT3V0cHV0RGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbk91dHB1dERibENsaWNrKGksIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25PdXRwdXRDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uT3V0cHV0Q2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWFyY2ggZm9yIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbm9kZS5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzBdIC0gMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19kb3VibGVfY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbklucHV0RGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbklucHV0RGJsQ2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbklucHV0Q2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbklucHV0Q2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGluayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5saW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTsgLy9iZWZvcmUgZGlzY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbG93X3JlY29ubmVjdF9saW5rcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnNoaWZ0S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlID0gdGhpcy5ncmFwaC5fbm9kZXNfYnlfaWRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8ub3JpZ2luX2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby5vcmlnaW5fc2xvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dCA9IHRoaXMuY29ubmVjdGluZ19ub2RlLm91dHB1dHNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zID0gdGhpcy5jb25uZWN0aW5nX25vZGUuZ2V0Q29ubmVjdGlvblBvcyggZmFsc2UsIHRoaXMuY29ubmVjdGluZ19zbG90ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IC8vbm90IHJlc2l6aW5nXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pdCB3YXNuJ3QgY2xpY2tlZCBvbiB0aGUgbGlua3MgYm94ZXNcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBfYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja19kcmFnX25vZGUgPSBmYWxzZTtcblx0XHRcdFx0XHR2YXIgcG9zID0gW2UuY2FudmFzWCAtIG5vZGUucG9zWzBdLCBlLmNhbnZhc1kgLSBub2RlLnBvc1sxXV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy93aWRnZXRzXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLnByb2Nlc3NOb2RlV2lkZ2V0cyggbm9kZSwgdGhpcy5ncmFwaF9tb3VzZSwgZSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja19kcmFnX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX3dpZGdldCA9IFtub2RlLCB3aWRnZXRdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9kb3VibGUgY2xpY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2RvdWJsZV9jbGljayAmJiB0aGlzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RvdWJsZSBjbGljayBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbkRibENsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbkRibENsaWNrKCBlLCBwb3MsIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc05vZGVEYmxDbGlja2VkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfZHJhZ19ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgZG8gbm90IGNhcHR1cmUgbW91c2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlLm9uTW91c2VEb3duICYmIG5vZGUub25Nb3VzZURvd24oIGUsIHBvcywgdGhpcyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfZHJhZ19ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vb3BlbiBzdWJncmFwaCBidXR0b25cblx0XHRcdFx0XHRcdGlmKG5vZGUuc3ViZ3JhcGggJiYgIW5vZGUuc2tpcF9zdWJncmFwaF9idXR0b24pXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmICggIW5vZGUuZmxhZ3MuY29sbGFwc2VkICYmIHBvc1swXSA+IG5vZGUuc2l6ZVswXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAmJiBwb3NbMV0gPCAwICkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhhdC5vcGVuU3ViZ3JhcGgobm9kZS5zdWJncmFwaCk7XG5cdFx0XHRcdFx0XHRcdFx0fSwgMTApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmxpdmVfbW9kZSkge1xuXHRcdFx0XHRcdFx0XHRjbGlja2luZ19jYW52YXNfYmcgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja19kcmFnX25vZGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibG9ja19kcmFnX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93X2RyYWdub2Rlcykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZF9ub2Rlc1tub2RlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc05vZGVTZWxlY3RlZChub2RlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vY2xpY2tlZCBvdXRzaWRlIG9mIG5vZGVzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL3NlYXJjaCBmb3IgbGluayBjb25uZWN0b3Jcblx0XHRcdFx0aWYoIXRoaXMucmVhZF9vbmx5KSBcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlzaWJsZV9saW5rcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0dmFyIGxpbmsgPSB0aGlzLnZpc2libGVfbGlua3NbaV07XG5cdFx0XHRcdFx0XHR2YXIgY2VudGVyID0gbGluay5fcG9zO1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHQhY2VudGVyIHx8XG5cdFx0XHRcdFx0XHRcdGUuY2FudmFzWCA8IGNlbnRlclswXSAtIDQgfHxcblx0XHRcdFx0XHRcdFx0ZS5jYW52YXNYID4gY2VudGVyWzBdICsgNCB8fFxuXHRcdFx0XHRcdFx0XHRlLmNhbnZhc1kgPCBjZW50ZXJbMV0gLSA0IHx8XG5cdFx0XHRcdFx0XHRcdGUuY2FudmFzWSA+IGNlbnRlclsxXSArIDRcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vbGluayBjbGlja2VkXG5cdFx0XHRcdFx0XHR0aGlzLnNob3dMaW5rTWVudShsaW5rLCBlKTtcblx0XHRcdFx0XHRcdHRoaXMub3Zlcl9saW5rX2NlbnRlciA9IG51bGw7IC8vY2xlYXIgdG9vbHRpcFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cCA9IHRoaXMuZ3JhcGguZ2V0R3JvdXBPblBvcyggZS5jYW52YXNYLCBlLmNhbnZhc1kgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwX3Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfZ3JvdXAgJiYgIXRoaXMucmVhZF9vbmx5ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKCBbZS5jYW52YXNYLCBlLmNhbnZhc1ldLCBbIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzBdICsgdGhpcy5zZWxlY3RlZF9ncm91cC5zaXplWzBdLCB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1sxXSArIHRoaXMuc2VsZWN0ZWRfZ3JvdXAuc2l6ZVsxXSBdICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ICogdGhpcy5kcy5zY2FsZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwX3Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucmVjb21wdXRlSW5zaWRlTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc19kb3VibGVfY2xpY2sgJiYgIXRoaXMucmVhZF9vbmx5ICYmIHRoaXMuYWxsb3dfc2VhcmNoYm94KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1NlYXJjaEJveChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlja2luZ19jYW52YXNfYmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNraXBfYWN0aW9uICYmIGNsaWNraW5nX2NhbnZhc19iZyAmJiB0aGlzLmFsbG93X2RyYWdjYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAyKSB7XG4gICAgICAgICAgICAvL21pZGRsZSBidXR0b25cbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDMpIHtcbiAgICAgICAgICAgIC8vcmlnaHQgYnV0dG9uXG5cdFx0XHRpZighdGhpcy5yZWFkX29ubHkpXG5cdCAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbnRleHRNZW51KG5vZGUsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPXG4gICAgICAgIC8vaWYodGhpcy5ub2RlX3NlbGVjdGVkICE9IHByZXZfc2VsZWN0ZWQpXG4gICAgICAgIC8vXHR0aGlzLm9uTm9kZVNlbGVjdGlvbkNoYW5nZSh0aGlzLm5vZGVfc2VsZWN0ZWQpO1xuXG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVswXSA9IGUubG9jYWxYO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VbMV0gPSBlLmxvY2FsWTtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlY2xpY2sgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VfZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8qXG5cdGlmKCAodGhpcy5kaXJ0eV9jYW52YXMgfHwgdGhpcy5kaXJ0eV9iZ2NhbnZhcykgJiYgdGhpcy5yZW5kZXJpbmdfdGltZXJfaWQgPT0gbnVsbClcblx0XHR0aGlzLmRyYXcoKTtcblx0Ki9cblxuICAgICAgICB0aGlzLmdyYXBoLmNoYW5nZSgpO1xuXG4gICAgICAgIC8vdGhpcyBpcyB0byBlbnN1cmUgdG8gZGVmb2N1cyhibHVyKSBpZiBhIHRleHQgaW5wdXQgZWxlbWVudCBpcyBvbiBmb2N1c1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhcmVmX3dpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8XG4gICAgICAgICAgICAocmVmX3dpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT1cbiAgICAgICAgICAgICAgICBcImlucHV0XCIgJiZcbiAgICAgICAgICAgICAgICByZWZfd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPVxuICAgICAgICAgICAgICAgICAgICBcInRleHRhcmVhXCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgbW91c2UgbW92ZSBldmVudCBoYXMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICogQG1ldGhvZCBwcm9jZXNzTW91c2VNb3ZlXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc01vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b3Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuXG5cdFx0aWYoIHRoaXMuc2V0X2NhbnZhc19kaXJ0eV9vbl9tb3VzZV9ldmVudCApXG5cdFx0XHR0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRqdXN0TW91c2VFdmVudChlKTtcbiAgICAgICAgdmFyIG1vdXNlID0gW2UubG9jYWxYLCBlLmxvY2FsWV07XG5cdFx0dGhpcy5tb3VzZVswXSA9IG1vdXNlWzBdO1xuXHRcdHRoaXMubW91c2VbMV0gPSBtb3VzZVsxXTtcbiAgICAgICAgdmFyIGRlbHRhID0gW1xuICAgICAgICAgICAgbW91c2VbMF0gLSB0aGlzLmxhc3RfbW91c2VbMF0sXG4gICAgICAgICAgICBtb3VzZVsxXSAtIHRoaXMubGFzdF9tb3VzZVsxXVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2UgPSBtb3VzZTtcbiAgICAgICAgdGhpcy5ncmFwaF9tb3VzZVswXSA9IGUuY2FudmFzWDtcbiAgICAgICAgdGhpcy5ncmFwaF9tb3VzZVsxXSA9IGUuY2FudmFzWTtcblxuXHRcdGlmKHRoaXMuYmxvY2tfY2xpY2spXG5cdFx0e1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuICAgICAgICBlLmRyYWdnaW5nID0gdGhpcy5sYXN0X21vdXNlX2RyYWdnaW5nO1xuXG4gICAgICAgIGlmICh0aGlzLm5vZGVfd2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NOb2RlV2lkZ2V0cyhcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0WzBdLFxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhfbW91c2UsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0WzFdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlKVxuXHRcdHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzJdID0gZS5jYW52YXNYIC0gdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMF07XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVszXSA9IGUuY2FudmFzWSAtIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICB9IFxuXHRcdGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRfZ3JvdXAgJiYgIXRoaXMucmVhZF9vbmx5KVxuXHRcdHtcbiAgICAgICAgICAgIC8vbW92aW5nL3Jlc2l6aW5nIGEgZ3JvdXBcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX2dyb3VwX3Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5zaXplID0gW1xuICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ggLSB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZIC0gdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMV1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0gZGVsdGFbMF0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXkgPSBkZWx0YVsxXSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5tb3ZlKGRlbHRheCwgZGVsdGF5LCBlLmN0cmxLZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX2dyb3VwLl9ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZHJhZ2dpbmdfY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRzLm9mZnNldFswXSArPSBkZWx0YVswXSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRzLm9mZnNldFsxXSArPSBkZWx0YVsxXSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFsbG93X2ludGVyYWN0aW9uICYmICF0aGlzLnJlYWRfb25seSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2dldCBub2RlIG92ZXJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlT25Qb3MoZS5jYW52YXNYLGUuY2FudmFzWSx0aGlzLnZpc2libGVfbm9kZXMpO1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBtb3VzZW92ZXIgZmxhZ1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmdyYXBoLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaC5fbm9kZXNbaV0ubW91c2VPdmVyICYmIG5vZGUgIT0gdGhpcy5ncmFwaC5fbm9kZXNbaV0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbW91c2UgbGVhdmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXNbaV0ubW91c2VPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVfb3ZlciAmJiB0aGlzLm5vZGVfb3Zlci5vbk1vdXNlTGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9vdmVyLm9uTW91c2VMZWF2ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfb3ZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbW91c2Ugb3ZlciBhIG5vZGVcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG5cblx0XHRcdFx0aWYobm9kZS5yZWRyYXdfb25fbW91c2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCI7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLm1vdXNlT3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAvL21vdXNlIGVudGVyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW91c2VPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX292ZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaW4gY2FzZSB0aGUgbm9kZSB3YW50cyB0byBkbyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9uTW91c2VNb3ZlKCBlLCBbZS5jYW52YXNYIC0gbm9kZS5wb3NbMF0sIGUuY2FudmFzWSAtIG5vZGUucG9zWzFdXSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaWYgZHJhZ2dpbmcgYSBsaW5rXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLl9oaWdobGlnaHRfaW5wdXQgfHwgWzAsIDBdOyAvL3RvIHN0b3JlIHRoZSBvdXRwdXQgb2YgaXNPdmVyTm9kZUlucHV0XG5cbiAgICAgICAgICAgICAgICAgICAgLy9vbiB0b3Agb2YgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPdmVyTm9kZUJveChub2RlLCBlLmNhbnZhc1gsIGUuY2FudmFzWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbW91c2Ugb24gdG9wIG9mIHRoZSBjb3JuZXIgYm94LCBkb24ndCBrbm93IHdoYXQgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgSSBoYXZlIGEgc2xvdCBiZWxvdyBkZSBtb3VzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmlzT3Zlck5vZGVJbnB1dCggbm9kZSwgZS5jYW52YXNYLCBlLmNhbnZhc1ksIHBvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QgIT0gLTEgJiYgbm9kZS5pbnB1dHNbc2xvdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdF90eXBlID0gbm9kZS5pbnB1dHNbc2xvdF0udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIExpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbiggdGhpcy5jb25uZWN0aW5nX291dHB1dC50eXBlLCBzbG90X3R5cGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0X2lucHV0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXRfc2xvdCA9IG5vZGUuaW5wdXRzW3Nsb3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0X2lucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXRfc2xvdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1NlYXJjaCBmb3IgY29ybmVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gKyBub2RlLnNpemVbMF0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdICsgbm9kZS5zaXplWzFdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcInNlLXJlc2l6ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gXCJjcm9zc2hhaXJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vbm90IG92ZXIgYSBub2RlXG5cbiAgICAgICAgICAgICAgICAvL3NlYXJjaCBmb3IgbGluayBjb25uZWN0b3Jcblx0XHRcdFx0dmFyIG92ZXJfbGluayA9IG51bGw7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aXNpYmxlX2xpbmtzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0dmFyIGxpbmsgPSB0aGlzLnZpc2libGVfbGlua3NbaV07XG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IGxpbmsuX3Bvcztcblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHQhY2VudGVyIHx8XG5cdFx0XHRcdFx0XHRlLmNhbnZhc1ggPCBjZW50ZXJbMF0gLSA0IHx8XG5cdFx0XHRcdFx0XHRlLmNhbnZhc1ggPiBjZW50ZXJbMF0gKyA0IHx8XG5cdFx0XHRcdFx0XHRlLmNhbnZhc1kgPCBjZW50ZXJbMV0gLSA0IHx8XG5cdFx0XHRcdFx0XHRlLmNhbnZhc1kgPiBjZW50ZXJbMV0gKyA0XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b3Zlcl9saW5rID0gbGluaztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiggb3Zlcl9saW5rICE9IHRoaXMub3Zlcl9saW5rX2NlbnRlciApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLm92ZXJfbGlua19jZW50ZXIgPSBvdmVyX2xpbms7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5jYW52YXMpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy9lbmRcblxuXHRcdFx0Ly9zZW5kIGV2ZW50IHRvIG5vZGUgaWYgY2FwdHVyaW5nIGlucHV0ICh1c2VkIHdpdGggd2lkZ2V0cyB0aGF0IGFsbG93IGRyYWcgb3V0c2lkZSBvZiB0aGUgYXJlYSBvZiB0aGUgbm9kZSlcbiAgICAgICAgICAgIGlmICggdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dCAmJiB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0ICE9IG5vZGUgJiYgdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5vbk1vdXNlTW92ZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0Lm9uTW91c2VNb3ZlKGUsW2UuY2FudmFzWCAtIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQucG9zWzBdLGUuY2FudmFzWSAtIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQucG9zWzFdXSwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8vbm9kZSBiZWluZyBkcmFnZ2VkXG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlX2RyYWdnZWQgJiYgIXRoaXMubGl2ZV9tb2RlKSB7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJkcmFnZ2luIVwiLHRoaXMuc2VsZWN0ZWRfbm9kZXMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIG4ucG9zWzBdICs9IGRlbHRhWzBdIC8gdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgbi5wb3NbMV0gKz0gZGVsdGFbMV0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucmVzaXppbmdfbm9kZSAmJiAhdGhpcy5saXZlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgbW91c2UgdG8gbm9kZSBzcGFjZVxuXHRcdFx0XHR2YXIgZGVzaXJlZF9zaXplID0gWyBlLmNhbnZhc1ggLSB0aGlzLnJlc2l6aW5nX25vZGUucG9zWzBdLCBlLmNhbnZhc1kgLSB0aGlzLnJlc2l6aW5nX25vZGUucG9zWzFdIF07XG5cdFx0XHRcdHZhciBtaW5fc2l6ZSA9IHRoaXMucmVzaXppbmdfbm9kZS5jb21wdXRlU2l6ZSgpO1xuXHRcdFx0XHRkZXNpcmVkX3NpemVbMF0gPSBNYXRoLm1heCggbWluX3NpemVbMF0sIGRlc2lyZWRfc2l6ZVswXSApO1xuXHRcdFx0XHRkZXNpcmVkX3NpemVbMV0gPSBNYXRoLm1heCggbWluX3NpemVbMV0sIGRlc2lyZWRfc2l6ZVsxXSApO1xuXHRcdFx0XHR0aGlzLnJlc2l6aW5nX25vZGUuc2V0U2l6ZSggZGVzaXJlZF9zaXplICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcInNlLXJlc2l6ZVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIG1vdXNlIHVwIGV2ZW50IGhhcyB0byBiZSBwcm9jZXNzZWRcbiAgICAgKiBAbWV0aG9kIHByb2Nlc3NNb3VzZVVwXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc01vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG5cblx0XHRpZiggdGhpcy5zZXRfY2FudmFzX2RpcnR5X29uX21vdXNlX2V2ZW50IClcblx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXMgPSB0aGlzO1xuXG4gICAgICAgIC8vcmVzdG9yZSB0aGUgbW91c2Vtb3ZlIGV2ZW50IGJhY2sgdG8gdGhlIGNhbnZhc1xuXHRcdGlmKCF0aGlzLm9wdGlvbnMuc2tpcF9ldmVudHMpXG5cdFx0e1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayx0cnVlKTtcblx0XHRcdHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2ssdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9tb3VzZXVwX2NhbGxiYWNrLCB0cnVlKTtcblx0XHR9XG5cbiAgICAgICAgdGhpcy5hZGp1c3RNb3VzZUV2ZW50KGUpO1xuICAgICAgICB2YXIgbm93ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgZS5jbGlja190aW1lID0gbm93IC0gdGhpcy5sYXN0X21vdXNlY2xpY2s7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMubGFzdF9jbGlja19wb3NpdGlvbiA9IG51bGw7XG5cblx0XHRpZih0aGlzLmJsb2NrX2NsaWNrKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUubG9nKFwiZm9vXCIpO1xuXHRcdFx0dGhpcy5ibG9ja19jbGljayA9IGZhbHNlOyAvL3VzZWQgdG8gYXZvaWQgc2VuZGluZyB0d2ljZSBhIGNsaWNrIGluIGEgaW1tZWRpYXRlIGJ1dHRvblxuXHRcdH1cblxuICAgICAgICBpZiAoZS53aGljaCA9PSAxKSB7XG5cblx0XHRcdGlmKCB0aGlzLm5vZGVfd2lkZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5wcm9jZXNzTm9kZVdpZGdldHMoIHRoaXMubm9kZV93aWRnZXRbMF0sIHRoaXMuZ3JhcGhfbW91c2UsIGUgKTtcblx0XHRcdH1cblxuICAgICAgICAgICAgLy9sZWZ0IGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5ub2RlX3dpZGdldCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX2dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZ4ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMF0gLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZnkgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1sxXSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAubW92ZShkaWZmeCwgZGlmZnksIGUuY3RybEtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMF0gPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1swXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMV0gPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1sxXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfZ3JvdXAuX25vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cF9yZXNpemluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVfYm91bmRpbmcgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0QWxsTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGJvdW5kaW5nIGFuZCBmbGlwIGlmIGxlZnQgdG8gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBNYXRoLmFicyh0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gTWF0aC5hYnModGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbM10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnR4ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzJdIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMF0gLSB3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVszXSA8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdIC0gaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdID0gc3RhcnR4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXSA9IHN0YXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMl0gPSB3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVszXSA9IGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy90ZXN0IGFnYWluc3QgYWxsIG5vZGVzIChub3QgdmlzaWJsZSBiZWNhdXNlIHRoZSByZWN0YW5nbGUgbWF5YmUgc3RhcnQgb3V0c2lkZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9fc2VsZWN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmdldEJvdW5kaW5nKG5vZGVfYm91bmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFvdmVybGFwQm91bmRpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlX2JvdW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vb3V0IG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvX3NlbGVjdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b19zZWxlY3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGVzKHRvX3NlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbm5lY3Rpbmdfbm9kZSkge1xuICAgICAgICAgICAgICAgIC8vZHJhZ2dpbmcgYSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyhcbiAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9ub2Rlc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvL25vZGUgYmVsb3cgbW91c2VcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzT3Zlck5vZGVCb3gobm9kZSwgZS5jYW52YXNYLCBlLmNhbnZhc1kpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUuY29ubmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5FVkVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2xvdCBiZWxvdyBtb3VzZT8gY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmlzT3Zlck5vZGVJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1lcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlLmNvbm5lY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3Qgb24gdG9wIG9mIGFuIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5nZXRJbnB1dEluZm8oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hdXRvIGNvbm5lY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQudHlwZSA9PSBMaXRlR3JhcGguRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUuY29ubmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5FVkVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpbnB1dC5saW5rICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgJiYgdGhpcy5jb25uZWN0aW5nX291dHB1dC50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUuY29ubmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QgPSAtMTtcbiAgICAgICAgICAgIH0gLy9ub3QgZHJhZ2dpbmcgY29ubmVjdGlvblxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKHRoaXMucmVzaXppbmdfbm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemluZ19ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ub2RlX2RyYWdnZWQpIHtcbiAgICAgICAgICAgICAgICAvL25vZGUgYmVpbmcgZHJhZ2dlZD9cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZV9kcmFnZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBlLmNsaWNrX3RpbWUgPCAzMDAgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoIGUuY2FudmFzWCwgZS5jYW52YXNZLCBub2RlLnBvc1swXSwgbm9kZS5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCwgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMF0gPSBNYXRoLnJvdW5kKHRoaXMubm9kZV9kcmFnZ2VkLnBvc1swXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQucG9zWzFdID0gTWF0aC5yb3VuZCh0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMV0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoLmNvbmZpZy5hbGlnbl90b19ncmlkIHx8IHRoaXMuYWxpZ25fdG9fZ3JpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQuYWxpZ25Ub0dyaWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdGlmKCB0aGlzLm9uTm9kZU1vdmVkIClcblx0XHRcdFx0XHR0aGlzLm9uTm9kZU1vdmVkKCB0aGlzLm5vZGVfZHJhZ2dlZCApO1xuXHRcdFx0XHR0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKHRoaXMubm9kZV9kcmFnZ2VkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZCA9IG51bGw7XG4gICAgICAgICAgICB9IC8vbm8gbm9kZSBiZWluZyBkcmFnZ2VkXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2dldCBub2RlIG92ZXJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZU9uUG9zKFxuICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX25vZGVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9kZSAmJiBlLmNsaWNrX3RpbWUgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlX292ZXIgJiYgdGhpcy5ub2RlX292ZXIub25Nb3VzZVVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9vdmVyLm9uTW91c2VVcCggZSwgWyBlLmNhbnZhc1ggLSB0aGlzLm5vZGVfb3Zlci5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMubm9kZV9vdmVyLnBvc1sxXSBdLCB0aGlzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0Lm9uTW91c2VVcFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0Lm9uTW91c2VVcChlLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ggLSB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0LnBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSAtIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQucG9zWzFdXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDIpIHtcbiAgICAgICAgICAgIC8vbWlkZGxlIGJ1dHRvblxuICAgICAgICAgICAgLy90cmFjZShcIm1pZGRsZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAzKSB7XG4gICAgICAgICAgICAvL3JpZ2h0IGJ1dHRvblxuICAgICAgICAgICAgLy90cmFjZShcInJpZ2h0XCIpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19jYW52YXMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG5cdGlmKCh0aGlzLmRpcnR5X2NhbnZhcyB8fCB0aGlzLmRpcnR5X2JnY2FudmFzKSAmJiB0aGlzLnJlbmRlcmluZ190aW1lcl9pZCA9PSBudWxsKVxuXHRcdHRoaXMuZHJhdygpO1xuXHQqL1xuXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgbW91c2Ugd2hlZWwgZXZlbnQgaGFzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAqIEBtZXRob2QgcHJvY2Vzc01vdXNlV2hlZWxcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VXaGVlbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoIHx8ICF0aGlzLmFsbG93X2RyYWdjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IGUud2hlZWxEZWx0YVkgIT0gbnVsbCA/IGUud2hlZWxEZWx0YVkgOiBlLmRldGFpbCAqIC02MDtcblxuICAgICAgICB0aGlzLmFkanVzdE1vdXNlRXZlbnQoZSk7XG5cblx0XHR2YXIgeCA9IGUubG9jYWxYO1xuXHRcdHZhciB5ID0gZS5sb2NhbFk7XG5cdFx0dmFyIGlzX2luc2lkZSA9ICF0aGlzLnZpZXdwb3J0IHx8ICggdGhpcy52aWV3cG9ydCAmJiB4ID49IHRoaXMudmlld3BvcnRbMF0gJiYgeCA8ICh0aGlzLnZpZXdwb3J0WzBdICsgdGhpcy52aWV3cG9ydFsyXSkgJiYgeSA+PSB0aGlzLnZpZXdwb3J0WzFdICYmIHkgPCAodGhpcy52aWV3cG9ydFsxXSArIHRoaXMudmlld3BvcnRbM10pICk7XG5cdFx0aWYoIWlzX2luc2lkZSlcblx0XHRcdHJldHVybjtcblxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRzLnNjYWxlO1xuXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIHNjYWxlICo9IDEuMTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHNjYWxlICo9IDEgLyAxLjE7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuc2V0Wm9vbSggc2NhbGUsIFsgZS5sb2NhbFgsIGUubG9jYWxZIF0gKTtcbiAgICAgICAgdGhpcy5kcy5jaGFuZ2VTY2FsZShzY2FsZSwgW2UubG9jYWxYLCBlLmxvY2FsWV0pO1xuXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHByZXZlbnQgZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgYSBwb3NpdGlvbiAoaW4gZ3JhcGggc3BhY2UpIGlzIG9uIHRvcCBvZiBhIG5vZGUgbGl0dGxlIGNvcm5lciBib3hcbiAgICAgKiBAbWV0aG9kIGlzT3Zlck5vZGVCb3hcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5pc092ZXJOb2RlQm94ID0gZnVuY3Rpb24obm9kZSwgY2FudmFzeCwgY2FudmFzeSkge1xuICAgICAgICB2YXIgdGl0bGVfaGVpZ2h0ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICBjYW52YXN4LFxuICAgICAgICAgICAgICAgIGNhbnZhc3ksXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gKyAyLFxuICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdICsgMiAtIHRpdGxlX2hlaWdodCxcbiAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQgLSA0LFxuICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAtIDRcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdHJ1ZSBpZiBhIHBvc2l0aW9uIChpbiBncmFwaCBzcGFjZSkgaXMgb24gdG9wIG9mIGEgbm9kZSBpbnB1dCBzbG90XG4gICAgICogQG1ldGhvZCBpc092ZXJOb2RlSW5wdXRcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5pc092ZXJOb2RlSW5wdXQgPSBmdW5jdGlvbihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgY2FudmFzeCxcbiAgICAgICAgY2FudmFzeSxcbiAgICAgICAgc2xvdF9wb3NcbiAgICApIHtcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuaW5wdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX3BvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyh0cnVlLCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNfaW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBpc19pbnNpZGUgPSBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMjBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc19pbnNpZGUgPSBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzFdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzX2luc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdF9wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RfcG9zWzBdID0gbGlua19wb3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90X3Bvc1sxXSA9IGxpbmtfcG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHByb2Nlc3MgYSBrZXkgZXZlbnRcbiAgICAgKiBAbWV0aG9kIHByb2Nlc3NLZXlcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzS2V5ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9ja19kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIC8vY29uc29sZS5sb2coZSk7IC8vZGVidWdcblxuICAgICAgICBpZiAoZS50YXJnZXQubG9jYWxOYW1lID09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImtleWRvd25cIikge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAzMikge1xuICAgICAgICAgICAgICAgIC8vZXNjXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJsb2NrX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NlbGVjdCBhbGwgQ29udHJvbCBBXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDY1ICYmIGUuY3RybEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoKTtcbiAgICAgICAgICAgICAgICBibG9ja19kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PSBcIktleUNcIiAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvL2NvcHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlUb0NsaXBib2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja19kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT0gXCJLZXlWXCIgJiYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy9wYXN0ZVxuICAgICAgICAgICAgICAgIHRoaXMucGFzdGVGcm9tQ2xpcGJvYXJkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGVsZXRlIG9yIGJhY2tzcGFjZVxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSA0NiB8fCBlLmtleUNvZGUgPT0gOCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQubG9jYWxOYW1lICE9IFwiaW5wdXRcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJ0ZXh0YXJlYVwiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlU2VsZWN0ZWROb2RlcygpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja19kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY29sbGFwc2VcbiAgICAgICAgICAgIC8vLi4uXG5cbiAgICAgICAgICAgIC8vVE9ET1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV0ub25LZXlEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX25vZGVzW2ldLm9uS2V5RG93bihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gXCJrZXl1cFwiKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19jYW52YXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV0ub25LZXlVcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2Rlc1tpXS5vbktleVVwKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaC5jaGFuZ2UoKTtcblxuICAgICAgICBpZiAoYmxvY2tfZGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNvcHlUb0NsaXBib2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xpcGJvYXJkX2luZm8gPSB7XG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBsaW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHNlbGVjdGVkX25vZGVzX2FycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGVkX25vZGVzW2ldO1xuICAgICAgICAgICAgbm9kZS5fcmVsYXRpdmVfaWQgPSBpbmRleDtcbiAgICAgICAgICAgIHNlbGVjdGVkX25vZGVzX2FycmF5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZF9ub2Rlc19hcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3RlZF9ub2Rlc19hcnJheVtpXTtcblx0XHRcdHZhciBjbG9uZWQgPSBub2RlLmNsb25lKCk7XG5cdFx0XHRpZighY2xvbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJub2RlIHR5cGUgbm90IGZvdW5kOiBcIiArIG5vZGUudHlwZSApO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cbiAgICAgICAgICAgIGNsaXBib2FyZF9pbmZvLm5vZGVzLnB1c2goY2xvbmVkLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlucHV0cyAmJiBub2RlLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0IHx8IGlucHV0LmxpbmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbaW5wdXQubGlua107XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLm9yaWdpbl9pZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldF9ub2RlIHx8ICF0aGlzLnNlbGVjdGVkX25vZGVzW3RhcmdldF9ub2RlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbXByb3ZlIHRoaXMgYnkgYWxsb3dpbmcgY29ubmVjdGlvbnMgdG8gbm9uLXNlbGVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfSAvL25vdCBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmRfaW5mby5saW5rcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9ub2RlLl9yZWxhdGl2ZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby5vcmlnaW5fc2xvdCwgLy9qLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fcmVsYXRpdmVfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgXCJsaXRlZ3JhcGhlZGl0b3JfY2xpcGJvYXJkXCIsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShjbGlwYm9hcmRfaW5mbylcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wYXN0ZUZyb21DbGlwYm9hcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImxpdGVncmFwaGVkaXRvcl9jbGlwYm9hcmRcIik7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuXG4gICAgICAgIC8vY3JlYXRlIG5vZGVzXG4gICAgICAgIHZhciBjbGlwYm9hcmRfaW5mbyA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBib2FyZF9pbmZvLm5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZV9kYXRhID0gY2xpcGJvYXJkX2luZm8ubm9kZXNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKG5vZGVfZGF0YS50eXBlKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jb25maWd1cmUobm9kZV9kYXRhKTtcbiAgICAgICAgICAgICAgICBub2RlLnBvc1swXSArPSA1O1xuICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdICs9IDU7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3JlYXRlIGxpbmtzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcGJvYXJkX2luZm8ubGlua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSBjbGlwYm9hcmRfaW5mby5saW5rc1tpXTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5fbm9kZSA9IG5vZGVzW2xpbmtfaW5mb1swXV07XG4gICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSBub2Rlc1tsaW5rX2luZm9bMl1dO1xuXHRcdFx0aWYoIG9yaWdpbl9ub2RlICYmIHRhcmdldF9ub2RlIClcblx0ICAgICAgICAgICAgb3JpZ2luX25vZGUuY29ubmVjdChsaW5rX2luZm9bMV0sIHRhcmdldF9ub2RlLCBsaW5rX2luZm9bM10pO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJXYXJuaW5nLCBub2RlcyBtaXNzaW5nIG9uIHBhc3RpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdE5vZGVzKG5vZGVzKTtcblxuXHRcdHRoaXMuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcHJvY2VzcyBhIGl0ZW0gZHJvcCBldmVudCBvbiB0b3AgdGhlIGNhbnZhc1xuICAgICAqIEBtZXRob2QgcHJvY2Vzc0Ryb3BcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzRHJvcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmFkanVzdE1vdXNlRXZlbnQoZSk7XG5cdFx0dmFyIHggPSBlLmxvY2FsWDtcblx0XHR2YXIgeSA9IGUubG9jYWxZO1xuXHRcdHZhciBpc19pbnNpZGUgPSAhdGhpcy52aWV3cG9ydCB8fCAoIHRoaXMudmlld3BvcnQgJiYgeCA+PSB0aGlzLnZpZXdwb3J0WzBdICYmIHggPCAodGhpcy52aWV3cG9ydFswXSArIHRoaXMudmlld3BvcnRbMl0pICYmIHkgPj0gdGhpcy52aWV3cG9ydFsxXSAmJiB5IDwgKHRoaXMudmlld3BvcnRbMV0gKyB0aGlzLnZpZXdwb3J0WzNdKSApO1xuXHRcdGlmKCFpc19pbnNpZGUpXG5cdFx0XHRyZXR1cm47XG5cbiAgICAgICAgdmFyIHBvcyA9IFtlLmNhbnZhc1gsIGUuY2FudmFzWV07XG5cblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGggPyB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyhwb3NbMF0sIHBvc1sxXSkgOiBudWxsO1xuXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Ecm9wSXRlbSkge1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLm9uRHJvcEl0ZW0oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0Ryb3BJdGVtKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUub25Ecm9wRmlsZSB8fCBub2RlLm9uRHJvcERhdGEpIHtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gTEdyYXBoQ2FudmFzLmdldEZpbGVFeHRlbnNpb24oZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25Ecm9wRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcHJlcGFyZSByZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uRHJvcERhdGEoZGF0YSwgZmlsZW5hbWUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmlsZS50eXBlLnNwbGl0KFwiL1wiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwidGV4dFwiIHx8IHR5cGUgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiaW1hZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vbkRyb3BJdGVtKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5vbkRyb3BJdGVtKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25Ecm9wSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Ecm9wSXRlbShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vY2FsbGVkIGlmIHRoZSBncmFwaCBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGRyb3AgaXRlbSBiZWhhdmlvdXJcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNoZWNrRHJvcEl0ZW0gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF07XG4gICAgICAgICAgICB2YXIgZXh0ID0gTEdyYXBoQ2FudmFzLmdldEZpbGVFeHRlbnNpb24oZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5vZGV0eXBlID0gTGl0ZUdyYXBoLm5vZGVfdHlwZXNfYnlfZmlsZV9leHRlbnNpb25bZXh0XTtcbiAgICAgICAgICAgIGlmIChub2RldHlwZSkge1xuXHRcdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUobm9kZXR5cGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBbZS5jYW52YXNYLCBlLmNhbnZhc1ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vbkRyb3BGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc05vZGVEYmxDbGlja2VkID0gZnVuY3Rpb24obikge1xuICAgICAgICBpZiAodGhpcy5vblNob3dOb2RlUGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMub25TaG93Tm9kZVBhbmVsKG4pO1xuICAgICAgICB9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuc2hvd1Nob3dOb2RlUGFuZWwobik7XG5cdFx0fVxuXG4gICAgICAgIGlmICh0aGlzLm9uTm9kZURibENsaWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob2RlRGJsQ2xpY2tlZChuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc05vZGVTZWxlY3RlZCA9IGZ1bmN0aW9uKG5vZGUsIGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlKG5vZGUsIGUgJiYgZS5zaGlmdEtleSk7XG4gICAgICAgIGlmICh0aGlzLm9uTm9kZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9kZVNlbGVjdGVkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlbGVjdHMgYSBnaXZlbiBub2RlIChvciBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbilcbiAgICAgKiBAbWV0aG9kIHNlbGVjdE5vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZWxlY3ROb2RlID0gZnVuY3Rpb24oXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGFkZF90b19jdXJyZW50X3NlbGVjdGlvblxuICAgICkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0QWxsTm9kZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoW25vZGVdLCBhZGRfdG9fY3VycmVudF9zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlbGVjdHMgc2V2ZXJhbCBub2RlcyAob3IgYWRkcyB0aGVtIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbilcbiAgICAgKiBAbWV0aG9kIHNlbGVjdE5vZGVzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2VsZWN0Tm9kZXMgPSBmdW5jdGlvbiggbm9kZXMsIGFkZF90b19jdXJyZW50X3NlbGVjdGlvbiApXG5cdHtcbiAgICAgICAgaWYgKCFhZGRfdG9fY3VycmVudF9zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGxOb2RlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMgPSBub2RlcyB8fCB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbm9kZS5pc19zZWxlY3RlZCAmJiBub2RlLm9uU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNfc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2Rlc1tub2RlLmlkXSA9IG5vZGU7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZF9saW5rc1tub2RlLmlucHV0c1tqXS5saW5rXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBub2RlLm91dHB1dHNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0LmxpbmtzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZF9saW5rc1tvdXQubGlua3Nba11dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cdFx0aWYoXHR0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlIClcblx0XHRcdHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoIHRoaXMuc2VsZWN0ZWRfbm9kZXMgKTtcblxuICAgICAgICB0aGlzLnNldERpcnR5KHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqIEBtZXRob2QgZGVzZWxlY3ROb2RlXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZGVzZWxlY3ROb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuaXNfc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5vbkRlc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG5vZGUub25EZXNlbGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pc19zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLm9uTm9kZURlc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob2RlRGVzZWxlY3RlZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVtb3ZlIGhpZ2hsaWdodGVkXG4gICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW25vZGUuaW5wdXRzW2ldLmxpbmtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IG5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3V0LmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0LmxpbmtzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5oaWdobGlnaHRlZF9saW5rc1tvdXQubGlua3Nbal1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZXMgYWxsIG5vZGVzIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQG1ldGhvZCBkZXNlbGVjdEFsbE5vZGVzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZGVzZWxlY3RBbGxOb2RlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNfc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm9uRGVzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25EZXNlbGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmlzX3NlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5vbk5vZGVEZXNlbGVjdGVkKSB7XG5cdFx0XHRcdHRoaXMub25Ob2RlRGVzZWxlY3RlZChub2RlKTtcblx0XHRcdH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkX25vZGVzID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudF9ub2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZF9saW5rcyA9IHt9O1xuXHRcdGlmKFx0dGhpcy5vblNlbGVjdGlvbkNoYW5nZSApXG5cdFx0XHR0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCB0aGlzLnNlbGVjdGVkX25vZGVzICk7XG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRlbGV0ZXMgYWxsIG5vZGVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmcm9tIHRoZSBncmFwaFxuICAgICAqIEBtZXRob2QgZGVsZXRlU2VsZWN0ZWROb2Rlc1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV07XG5cblx0XHRcdGlmKG5vZGUuYmxvY2tfZGVsZXRlKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly9hdXRvY29ubmVjdCB3aGVuIHBvc3NpYmxlICh2ZXJ5IGJhc2ljLCBvbmx5IHRha2VzIGludG8gYWNjb3VudCBmaXJzdCBpbnB1dC1vdXRwdXQpXG5cdFx0XHRpZihub2RlLmlucHV0cyAmJiBub2RlLmlucHV0cy5sZW5ndGggJiYgbm9kZS5vdXRwdXRzICYmIG5vZGUub3V0cHV0cy5sZW5ndGggJiYgTGl0ZUdyYXBoLmlzVmFsaWRDb25uZWN0aW9uKCBub2RlLmlucHV0c1swXS50eXBlLCBub2RlLm91dHB1dHNbMF0udHlwZSApICYmIG5vZGUuaW5wdXRzWzBdLmxpbmsgJiYgbm9kZS5vdXRwdXRzWzBdLmxpbmtzICYmIG5vZGUub3V0cHV0c1swXS5saW5rcy5sZW5ndGggKSBcblx0XHRcdHtcblx0XHRcdFx0dmFyIGlucHV0X2xpbmsgPSBub2RlLmdyYXBoLmxpbmtzWyBub2RlLmlucHV0c1swXS5saW5rIF07XG5cdFx0XHRcdHZhciBvdXRwdXRfbGluayA9IG5vZGUuZ3JhcGgubGlua3NbIG5vZGUub3V0cHV0c1swXS5saW5rc1swXSBdO1xuXHRcdFx0XHR2YXIgaW5wdXRfbm9kZSA9IG5vZGUuZ2V0SW5wdXROb2RlKDApO1xuXHRcdFx0XHR2YXIgb3V0cHV0X25vZGUgPSBub2RlLmdldE91dHB1dE5vZGVzKDApWzBdO1xuXHRcdFx0XHRpZihpbnB1dF9ub2RlICYmIG91dHB1dF9ub2RlKVxuXHRcdFx0XHRcdGlucHV0X25vZGUuY29ubmVjdCggaW5wdXRfbGluay5vcmlnaW5fc2xvdCwgb3V0cHV0X25vZGUsIG91dHB1dF9saW5rLnRhcmdldF9zbG90ICk7XG5cdFx0XHR9XG4gICAgICAgICAgICB0aGlzLmdyYXBoLnJlbW92ZShub2RlKTtcblx0XHRcdGlmICh0aGlzLm9uTm9kZURlc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5vbk5vZGVEZXNlbGVjdGVkKG5vZGUpO1xuXHRcdFx0fVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50X25vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzID0ge307XG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSk7XG5cdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjZW50ZXJzIHRoZSBjYW1lcmEgb24gYSBnaXZlbiBub2RlXG4gICAgICogQG1ldGhvZCBjZW50ZXJPbk5vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jZW50ZXJPbk5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMuZHMub2Zmc2V0WzBdID1cbiAgICAgICAgICAgIC1ub2RlLnBvc1swXSAtXG4gICAgICAgICAgICBub2RlLnNpemVbMF0gKiAwLjUgK1xuICAgICAgICAgICAgKHRoaXMuY2FudmFzLndpZHRoICogMC41KSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgIHRoaXMuZHMub2Zmc2V0WzFdID1cbiAgICAgICAgICAgIC1ub2RlLnBvc1sxXSAtXG4gICAgICAgICAgICBub2RlLnNpemVbMV0gKiAwLjUgK1xuICAgICAgICAgICAgKHRoaXMuY2FudmFzLmhlaWdodCAqIDAuNSkgLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGRzIHNvbWUgdXNlZnVsIHByb3BlcnRpZXMgdG8gYSBtb3VzZSBldmVudCwgbGlrZSB0aGUgcG9zaXRpb24gaW4gZ3JhcGggY29vcmRpbmF0ZXNcbiAgICAgKiBAbWV0aG9kIGFkanVzdE1vdXNlRXZlbnRcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5hZGp1c3RNb3VzZUV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBlLmxvY2FsWCA9IGUuY2xpZW50WCAtIGIubGVmdDtcbiAgICAgICAgICAgIGUubG9jYWxZID0gZS5jbGllbnRZIC0gYi50b3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLmxvY2FsWCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIGUubG9jYWxZID0gZS5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5kZWx0YVggPSBlLmxvY2FsWCAtIHRoaXMubGFzdF9tb3VzZV9wb3NpdGlvblswXTtcbiAgICAgICAgZS5kZWx0YVkgPSBlLmxvY2FsWSAtIHRoaXMubGFzdF9tb3VzZV9wb3NpdGlvblsxXTtcblxuICAgICAgICB0aGlzLmxhc3RfbW91c2VfcG9zaXRpb25bMF0gPSBlLmxvY2FsWDtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlX3Bvc2l0aW9uWzFdID0gZS5sb2NhbFk7XG5cbiAgICAgICAgZS5jYW52YXNYID0gZS5sb2NhbFggLyB0aGlzLmRzLnNjYWxlIC0gdGhpcy5kcy5vZmZzZXRbMF07XG4gICAgICAgIGUuY2FudmFzWSA9IGUubG9jYWxZIC8gdGhpcy5kcy5zY2FsZSAtIHRoaXMuZHMub2Zmc2V0WzFdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBncmFwaCAoZGVmYXVsdCBpcyAxKSwgeW91IGNhbiBwYXNzIGFsc28gYSBwbGFjZSB1c2VkIHRvIHBpdm90IHRoZSB6b29tXG4gICAgICogQG1ldGhvZCBzZXRab29tXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKHZhbHVlLCB6b29taW5nX2NlbnRlcikge1xuICAgICAgICB0aGlzLmRzLmNoYW5nZVNjYWxlKHZhbHVlLCB6b29taW5nX2NlbnRlcik7XG4gICAgICAgIC8qXG5cdGlmKCF6b29taW5nX2NlbnRlciAmJiB0aGlzLmNhbnZhcylcblx0XHR6b29taW5nX2NlbnRlciA9IFt0aGlzLmNhbnZhcy53aWR0aCAqIDAuNSx0aGlzLmNhbnZhcy5oZWlnaHQgKiAwLjVdO1xuXG5cdHZhciBjZW50ZXIgPSB0aGlzLmNvbnZlcnRPZmZzZXRUb0NhbnZhcyggem9vbWluZ19jZW50ZXIgKTtcblxuXHR0aGlzLmRzLnNjYWxlID0gdmFsdWU7XG5cblx0aWYodGhpcy5zY2FsZSA+IHRoaXMubWF4X3pvb20pXG5cdFx0dGhpcy5zY2FsZSA9IHRoaXMubWF4X3pvb207XG5cdGVsc2UgaWYodGhpcy5zY2FsZSA8IHRoaXMubWluX3pvb20pXG5cdFx0dGhpcy5zY2FsZSA9IHRoaXMubWluX3pvb207XG5cblx0dmFyIG5ld19jZW50ZXIgPSB0aGlzLmNvbnZlcnRPZmZzZXRUb0NhbnZhcyggem9vbWluZ19jZW50ZXIgKTtcblx0dmFyIGRlbHRhX29mZnNldCA9IFtuZXdfY2VudGVyWzBdIC0gY2VudGVyWzBdLCBuZXdfY2VudGVyWzFdIC0gY2VudGVyWzFdXTtcblxuXHR0aGlzLm9mZnNldFswXSArPSBkZWx0YV9vZmZzZXRbMF07XG5cdHRoaXMub2Zmc2V0WzFdICs9IGRlbHRhX29mZnNldFsxXTtcblx0Ki9cblxuICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIGNvb3JkaW5hdGUgZnJvbSBncmFwaCBjb29yZGluYXRlcyB0byBjYW52YXMyRCBjb29yZGluYXRlc1xuICAgICAqIEBtZXRob2QgY29udmVydE9mZnNldFRvQ2FudmFzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29udmVydE9mZnNldFRvQ2FudmFzID0gZnVuY3Rpb24ocG9zLCBvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHMuY29udmVydE9mZnNldFRvQ2FudmFzKHBvcywgb3V0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgYSBjb29yZGluYXRlIGZyb20gQ2FudmFzMkQgY29vcmRpbmF0ZXMgdG8gZ3JhcGggc3BhY2VcbiAgICAgKiBAbWV0aG9kIGNvbnZlcnRDYW52YXNUb09mZnNldFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNvbnZlcnRDYW52YXNUb09mZnNldCA9IGZ1bmN0aW9uKHBvcywgb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRzLmNvbnZlcnRDYW52YXNUb09mZnNldChwb3MsIG91dCk7XG4gICAgfTtcblxuICAgIC8vY29udmVydHMgZXZlbnQgY29vcmRpbmF0ZXMgZnJvbSBjYW52YXMyRCB0byBncmFwaCBjb29yZGluYXRlc1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29udmVydEV2ZW50VG9DYW52YXNPZmZzZXQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRDYW52YXNUb09mZnNldChbXG4gICAgICAgICAgICBlLmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICBlLmNsaWVudFkgLSByZWN0LnRvcFxuICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYnJpbmdzIGEgbm9kZSB0byBmcm9udCAoYWJvdmUgYWxsIG90aGVyIG5vZGVzKVxuICAgICAqIEBtZXRob2QgYnJpbmdUb0Zyb250XG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuYnJpbmdUb0Zyb250ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ3JhcGguX25vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGlmIChpID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyYXBoLl9ub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGguX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlbmRzIGEgbm9kZSB0byB0aGUgYmFjayAoYmVsb3cgYWxsIG90aGVyIG5vZGVzKVxuICAgICAqIEBtZXRob2Qgc2VuZFRvQmFja1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNlbmRUb0JhY2sgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5ncmFwaC5fbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGguX25vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXMudW5zaGlmdChub2RlKTtcbiAgICB9O1xuXG4gICAgLyogSW50ZXJhY3Rpb24gKi9cblxuICAgIC8qIExHcmFwaENhbnZhcyByZW5kZXIgKi9cbiAgICB2YXIgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3Mgd2hpY2ggbm9kZXMgYXJlIHZpc2libGUgKGluc2lkZSB0aGUgY2FtZXJhIGFyZWEpXG4gICAgICogQG1ldGhvZCBjb21wdXRlVmlzaWJsZU5vZGVzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29tcHV0ZVZpc2libGVOb2RlcyA9IGZ1bmN0aW9uKG5vZGVzLCBvdXQpIHtcbiAgICAgICAgdmFyIHZpc2libGVfbm9kZXMgPSBvdXQgfHwgW107XG4gICAgICAgIHZpc2libGVfbm9kZXMubGVuZ3RoID0gMDtcbiAgICAgICAgbm9kZXMgPSBub2RlcyB8fCB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgICAgIC8vc2tpcCByZW5kZXJpbmcgbm9kZXMgaW4gbGl2ZSBtb2RlXG4gICAgICAgICAgICBpZiAodGhpcy5saXZlX21vZGUgJiYgIW4ub25EcmF3QmFja2dyb3VuZCAmJiAhbi5vbkRyYXdGb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3ZlcmxhcEJvdW5kaW5nKHRoaXMudmlzaWJsZV9hcmVhLCBuLmdldEJvdW5kaW5nKHRlbXApKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvL291dCBvZiB0aGUgdmlzaWJsZSBhcmVhXG5cbiAgICAgICAgICAgIHZpc2libGVfbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZV9ub2RlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVuZGVycyB0aGUgd2hvbGUgY2FudmFzIGNvbnRlbnQsIGJ5IHJlbmRlcmluZyBpbiB0d28gc2VwYXJhdGVkIGNhbnZhcywgb25lIGNvbnRhaW5pbmcgdGhlIGJhY2tncm91bmQgZ3JpZCBhbmQgdGhlIGNvbm5lY3Rpb25zLCBhbmQgb25lIGNvbnRhaW5pbmcgdGhlIG5vZGVzKVxuICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihmb3JjZV9jYW52YXMsIGZvcmNlX2JnY2FudmFzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXMgfHwgdGhpcy5jYW52YXMud2lkdGggPT0gMCB8fCB0aGlzLmNhbnZhcy5oZWlnaHQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9mcHMgY291bnRpbmdcbiAgICAgICAgdmFyIG5vdyA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMucmVuZGVyX3RpbWUgPSAobm93IC0gdGhpcy5sYXN0X2RyYXdfdGltZSkgKiAwLjAwMTtcbiAgICAgICAgdGhpcy5sYXN0X2RyYXdfdGltZSA9IG5vdztcblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5kcy5jb21wdXRlVmlzaWJsZUFyZWEodGhpcy52aWV3cG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzIHx8XG4gICAgICAgICAgICBmb3JjZV9iZ2NhbnZhcyB8fFxuICAgICAgICAgICAgdGhpcy5hbHdheXNfcmVuZGVyX2JhY2tncm91bmQgfHxcbiAgICAgICAgICAgICh0aGlzLmdyYXBoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5fbGFzdF90cmlnZ2VyX3RpbWUgJiZcbiAgICAgICAgICAgICAgICBub3cgLSB0aGlzLmdyYXBoLl9sYXN0X3RyaWdnZXJfdGltZSA8IDEwMDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja0NhbnZhcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGlydHlfY2FudmFzIHx8IGZvcmNlX2NhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5kcmF3RnJvbnRDYW52YXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnBzID0gdGhpcy5yZW5kZXJfdGltZSA/IDEuMCAvIHRoaXMucmVuZGVyX3RpbWUgOiAwO1xuICAgICAgICB0aGlzLmZyYW1lICs9IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSBmcm9udCBjYW52YXMgKHRoZSBvbmUgY29udGFpbmluZyBhbGwgdGhlIG5vZGVzKVxuICAgICAqIEBtZXRob2QgZHJhd0Zyb250Q2FudmFzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0Zyb250Q2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLmN0eCkge1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmJnY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICAvL21heWJlIGlzIHVzaW5nIHdlYmdsLi4uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIGlmICggY3R4LnN0YXJ0MkQgJiYgIXRoaXMudmlld3BvcnQgKSB7XG4gICAgICAgICAgICBjdHguc3RhcnQyRCgpO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NsaXAgZGlydHkgYXJlYSBpZiB0aGVyZSBpcyBvbmUsIG90aGVyd2lzZSB3b3JrIGluIGZ1bGwgY2FudmFzXG5cdFx0dmFyIGFyZWEgPSB0aGlzLnZpZXdwb3J0IHx8IHRoaXMuZGlydHlfYXJlYTtcbiAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdCggYXJlYVswXSxhcmVhWzFdLGFyZWFbMl0sYXJlYVszXSApO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2xlYXJcbiAgICAgICAgLy9jYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNsZWFyX2JhY2tncm91bmQpIHtcblx0XHRcdGlmKGFyZWEpXG5cdCAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoIGFyZWFbMF0sYXJlYVsxXSxhcmVhWzJdLGFyZWFbM10gKTtcblx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9kcmF3IGJnIGNhbnZhc1xuICAgICAgICBpZiAodGhpcy5iZ2NhbnZhcyA9PSB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja0NhbnZhcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSggdGhpcy5iZ2NhbnZhcywgMCwgMCApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXJpbmdcbiAgICAgICAgaWYgKHRoaXMub25SZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMub25SZW5kZXIoY2FudmFzLCBjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbmZvIHdpZGdldFxuICAgICAgICBpZiAodGhpcy5zaG93X2luZm8pIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVySW5mbyhjdHgsIGFyZWEgPyBhcmVhWzBdIDogMCwgYXJlYSA/IGFyZWFbMV0gOiAwICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgLy9hcHBseSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLmRzLnRvQ2FudmFzQ29udGV4dChjdHgpO1xuXG4gICAgICAgICAgICAvL2RyYXcgbm9kZXNcbiAgICAgICAgICAgIHZhciBkcmF3bl9ub2RlcyA9IDA7XG4gICAgICAgICAgICB2YXIgdmlzaWJsZV9ub2RlcyA9IHRoaXMuY29tcHV0ZVZpc2libGVOb2RlcyhcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9ub2Rlc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXNpYmxlX25vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB2aXNpYmxlX25vZGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy90cmFuc2Zvcm0gY29vcmRzIHN5c3RlbVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShub2RlLnBvc1swXSwgbm9kZS5wb3NbMV0pO1xuXG4gICAgICAgICAgICAgICAgLy9EcmF3XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Tm9kZShub2RlLCBjdHgpO1xuICAgICAgICAgICAgICAgIGRyYXduX25vZGVzICs9IDE7XG5cbiAgICAgICAgICAgICAgICAvL1Jlc3RvcmVcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL29uIHRvcCAoZGVidWcpXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJfZXhlY3V0aW9uX29yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3RXhlY3V0aW9uT3JkZXIoY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jb25uZWN0aW9ucyBvbnRvcD9cbiAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoLmNvbmZpZy5saW5rc19vbnRvcCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saXZlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29ubmVjdGlvbnMoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY3VycmVudCBjb25uZWN0aW9uICh0aGUgb25lIGJlaW5nIGRyYWdnZWQgYnkgdGhlIG1vdXNlKVxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZ19wb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX2NvbG9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5jb25uZWN0aW5nX291dHB1dC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkVWRU5UOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19jb2xvciA9IExpdGVHcmFwaC5FVkVOVF9MSU5LX0NPTE9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2NvbG9yID0gTGl0ZUdyYXBoLkNPTk5FQ1RJTkdfTElOS19DT0xPUjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3RoZSBjb25uZWN0aW9uIGJlaW5nIGRyYWdnZWQgYnkgdGhlIG1vdXNlXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5rKFxuICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3MsXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmdyYXBoX21vdXNlWzBdLCB0aGlzLmdyYXBoX21vdXNlWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtfY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQuZGlyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jb25uZWN0aW5nX25vZGUuaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTGl0ZUdyYXBoLkRPV05cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IExpdGVHcmFwaC5SSUdIVCksXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5DRU5URVJcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dC50eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkJPWF9TSEFQRVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3NbMF0gLSA2ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Bvc1sxXSAtIDUgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0LnNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmNvbm5lY3RpbmdfcG9zWzBdICsgOCwgdGhpcy5jb25uZWN0aW5nX3Bvc1sxXSArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5jb25uZWN0aW5nX3Bvc1swXSAtIDQsIHRoaXMuY29ubmVjdGluZ19wb3NbMV0gKyA2ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmNvbm5lY3RpbmdfcG9zWzBdIC0gNCwgdGhpcy5jb25uZWN0aW5nX3Bvc1sxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRfaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLl9oaWdobGlnaHRfaW5wdXRfc2xvdC5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5faGlnaGxpZ2h0X2lucHV0WzBdICsgOCwgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5faGlnaGxpZ2h0X2lucHV0WzBdIC0gNCwgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdICsgNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuX2hpZ2hsaWdodF9pbnB1dFswXSAtIDQsIHRoaXMuX2hpZ2hsaWdodF9pbnB1dFsxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly90aGUgc2VsZWN0aW9uIHJlY3RhbmdsZVxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjRkZGXCI7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMl0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzNdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly9vbiB0b3Agb2YgbGluayBjZW50ZXJcblx0XHRcdGlmKHRoaXMub3Zlcl9saW5rX2NlbnRlciAmJiB0aGlzLnJlbmRlcl9saW5rX3Rvb2x0aXApXG5cdFx0XHRcdHRoaXMuZHJhd0xpbmtUb29sdGlwKCBjdHgsIHRoaXMub3Zlcl9saW5rX2NlbnRlciApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpZih0aGlzLm9uRHJhd0xpbmtUb29sdGlwKSAvL3RvIHJlbW92ZVxuXHRcdFx0XHRcdHRoaXMub25EcmF3TGlua1Rvb2x0aXAoY3R4LG51bGwpO1xuXG5cdFx0XHQvL2N1c3RvbSBpbmZvXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRyYXdGb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRyYXdGb3JlZ3JvdW5kKGN0eCwgdGhpcy52aXNpYmxlX3JlY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cblx0XHQvL2RyYXdzIHBhbmVsIGluIHRoZSBjb3JuZXIgXG5cdFx0aWYgKHRoaXMuX2dyYXBoX3N0YWNrICYmIHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5kcmF3U3ViZ3JhcGhQYW5lbCggY3R4ICk7XG5cdFx0fVxuXG5cbiAgICAgICAgaWYgKHRoaXMub25EcmF3T3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYXdPdmVybGF5KGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdHguZmluaXNoMkQpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGZ1bmN0aW9uIEkgdXNlIGluIHdlYmdsIHJlbmRlcmVyXG4gICAgICAgICAgICBjdHguZmluaXNoMkQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyB0aGUgcGFuZWwgaW4gdGhlIGNvcm5lciB0aGF0IHNob3dzIHN1YmdyYXBoIHByb3BlcnRpZXNcbiAgICAgKiBAbWV0aG9kIGRyYXdTdWJncmFwaFBhbmVsXG4gICAgICoqL1xuXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdTdWJncmFwaFBhbmVsID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHN1YmdyYXBoID0gdGhpcy5ncmFwaDtcblx0XHR2YXIgc3Vibm9kZSA9IHN1YmdyYXBoLl9zdWJncmFwaF9ub2RlO1xuXHRcdGlmKCFzdWJub2RlKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUud2FybihcInN1YmdyYXBoIHdpdGhvdXQgc3Vibm9kZVwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbnVtID0gc3Vibm9kZS5pbnB1dHMgPyBzdWJub2RlLmlucHV0cy5sZW5ndGggOiAwO1xuXHRcdHZhciB3ID0gMzAwO1xuXHRcdHZhciBoID0gTWF0aC5mbG9vcihMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDEuNik7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gXCIjMTExXCI7XG5cdFx0Y3R4Lmdsb2JhbEFscGhhID0gMC44O1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucm91bmRSZWN0KDEwLDEwLHcsIChudW0gKyAxKSAqIGggKyA1MCw4ICk7XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzg4OFwiO1xuXHRcdGN0eC5mb250ID0gXCIxNHB4IEFyaWFsXCI7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdGN0eC5maWxsVGV4dCggXCJHcmFwaCBJbnB1dHNcIiwgMjAsIDM0ICk7XG5cdFx0dmFyIHBvcyA9IHRoaXMubW91c2U7XG5cblx0XHRpZiggdGhpcy5kcmF3QnV0dG9uKCB3IC0gMjAsIDIwLDIwLDIwLCBcIlhcIiwgXCIjMTUxNTE1XCIgKSApXG5cdFx0e1xuXHRcdFx0dGhpcy5jbG9zZVN1YmdyYXBoKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHkgPSA1MDtcblx0XHRjdHguZm9udCA9IFwiMjBweCBBcmlhbFwiO1xuXHRcdGlmKHN1Ym5vZGUuaW5wdXRzKVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdWJub2RlLmlucHV0cy5sZW5ndGg7ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgaW5wdXQgPSBzdWJub2RlLmlucHV0c1tpXTtcblx0XHRcdGlmKGlucHV0Lm5vdF9zdWJncmFwaF9pbnB1dClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vaW5wdXQgYnV0dG9uIGNsaWNrZWRcblx0XHRcdGlmKCB0aGlzLmRyYXdCdXR0b24oIDIwLHkrMix3IC0gMjAsIGggLSAyICkgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdHlwZSA9IHN1Ym5vZGUuY29uc3RydWN0b3IuaW5wdXRfbm9kZV90eXBlIHx8IFwiZ3JhcGgvaW5wdXRcIjtcblx0XHRcdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcblx0XHRcdFx0dmFyIG5ld25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZSggdHlwZSApO1xuXHRcdFx0XHRpZihuZXdub2RlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3ViZ3JhcGguYWRkKCBuZXdub2RlICk7XG5cdFx0XHRcdFx0dGhpcy5ibG9ja19jbGljayA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMubGFzdF9jbGlja19wb3NpdGlvbiA9IG51bGw7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3ROb2RlcyhbbmV3bm9kZV0pO1xuXHRcdFx0XHRcdHRoaXMubm9kZV9kcmFnZ2VkID0gbmV3bm9kZTtcblx0XHRcdFx0XHR0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuXHRcdFx0XHRcdG5ld25vZGUuc2V0UHJvcGVydHkoXCJuYW1lXCIsaW5wdXQubmFtZSk7XG5cdFx0XHRcdFx0bmV3bm9kZS5zZXRQcm9wZXJ0eShcInR5cGVcIixpbnB1dC50eXBlKTtcblx0XHRcdFx0XHR0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMF0gPSB0aGlzLmdyYXBoX21vdXNlWzBdIC0gNTtcblx0XHRcdFx0XHR0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMV0gPSB0aGlzLmdyYXBoX21vdXNlWzFdIC0gNTtcblx0XHRcdFx0XHR0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJncmFwaCBpbnB1dCBub2RlIG5vdCBmb3VuZDpcIix0eXBlKTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzlDOVwiO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LmFyYyh3IC0gMTYseSArIGggKiAwLjUsNSwwLDIqTWF0aC5QSSk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG5cdFx0XHRjdHguZmlsbFRleHQoIGlucHV0Lm5hbWUsIDUwLCB5ICsgaCowLjc1ICk7XG5cdFx0XHR2YXIgdHcgPSBjdHgubWVhc3VyZVRleHQoIGlucHV0Lm5hbWUgKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBcIiM3NzdcIjtcblx0XHRcdGN0eC5maWxsVGV4dCggaW5wdXQudHlwZSwgNTAgKyB0dy53aWR0aCArIDEwLCB5ICsgaCowLjc1ICk7XG5cblx0XHRcdHkgKz0gaDtcblx0XHR9XG5cblx0XHQvL2FkZCArIGJ1dHRvblxuXHRcdGlmKCB0aGlzLmRyYXdCdXR0b24oIDIwLHkrMix3IC0gMjAsIGggLSAyLCBcIitcIiwgXCIjMTUxNTE1XCIsIFwiIzIyMlwiICkgKVxuXHRcdHtcblx0XHRcdHRoaXMuc2hvd1N1YmdyYXBoUHJvcGVydGllc0RpYWxvZyggc3Vibm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdC8vRHJhd3MgYSBidXR0b24gaW50byB0aGUgY2FudmFzIG92ZXJsYXkgYW5kIGNvbXB1dGVzIGlmIGl0IHdhcyBjbGlja2VkIHVzaW5nIHRoZSBpbW1lZGlhdGUgZ3VpIHBhcmFkaWdtXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0J1dHRvbiA9IGZ1bmN0aW9uKCB4LHksdyxoLCB0ZXh0LCBiZ2NvbG9yLCBob3ZlcmNvbG9yLCB0ZXh0Y29sb3IgKVxuXHR7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY3R4O1xuXHRcdGJnY29sb3IgPSBiZ2NvbG9yIHx8IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQ09MT1I7XG5cdFx0aG92ZXJjb2xvciA9IGhvdmVyY29sb3IgfHwgXCIjNTU1XCI7XG5cdFx0dGV4dGNvbG9yID0gdGV4dGNvbG9yIHx8IExpdGVHcmFwaC5OT0RFX1RFWFRfQ09MT1I7XG5cblx0XHR2YXIgcG9zID0gdGhpcy5tb3VzZTtcblx0XHR2YXIgaG92ZXIgPSBMaXRlR3JhcGguaXNJbnNpZGVSZWN0YW5nbGUoIHBvc1swXSwgcG9zWzFdLCB4LHksdyxoICk7XG5cdFx0cG9zID0gdGhpcy5sYXN0X2NsaWNrX3Bvc2l0aW9uO1xuXHRcdHZhciBjbGlja2VkID0gcG9zICYmIExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSBob3ZlciA/IGhvdmVyY29sb3IgOiBiZ2NvbG9yO1xuXHRcdGlmKGNsaWNrZWQpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yb3VuZFJlY3QoeCx5LHcsaCw0ICk7XG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmKHRleHQgIT0gbnVsbClcblx0XHR7XG5cdFx0XHRpZih0ZXh0LmNvbnN0cnVjdG9yID09IFN0cmluZylcblx0XHRcdHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRjb2xvcjtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdGN0eC5mb250ID0gKChoICogMC42NSl8MCkgKyBcInB4IEFyaWFsXCI7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCggdGV4dCwgeCArIHcgKiAwLjUseSArIGggKiAwLjc1ICk7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgd2FzX2NsaWNrZWQgPSBjbGlja2VkICYmICF0aGlzLmJsb2NrX2NsaWNrO1xuXHRcdGlmKGNsaWNrZWQpXG5cdFx0XHR0aGlzLmJsb2NrQ2xpY2soKTtcblx0XHRyZXR1cm4gd2FzX2NsaWNrZWQ7XG5cdH1cblxuXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLmlzQXJlYUNsaWNrZWQgPSBmdW5jdGlvbiggeCx5LHcsaCwgaG9sZF9jbGljayApXG5cdHtcblx0XHR2YXIgcG9zID0gdGhpcy5tb3VzZTtcblx0XHR2YXIgaG92ZXIgPSBMaXRlR3JhcGguaXNJbnNpZGVSZWN0YW5nbGUoIHBvc1swXSwgcG9zWzFdLCB4LHksdyxoICk7XG5cdFx0cG9zID0gdGhpcy5sYXN0X2NsaWNrX3Bvc2l0aW9uO1xuXHRcdHZhciBjbGlja2VkID0gcG9zICYmIExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblx0XHR2YXIgd2FzX2NsaWNrZWQgPSBjbGlja2VkICYmICF0aGlzLmJsb2NrX2NsaWNrO1xuXHRcdGlmKGNsaWNrZWQgJiYgaG9sZF9jbGljaylcblx0XHRcdHRoaXMuYmxvY2tDbGljaygpO1xuXHRcdHJldHVybiB3YXNfY2xpY2tlZDtcblx0fVxuXG4gICAgLyoqXG4gICAgICogZHJhd3Mgc29tZSB1c2VmdWwgc3RhdHMgaW4gdGhlIGNvcm5lciBvZiB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCByZW5kZXJJbmZvXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucmVuZGVySW5mbyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSkge1xuICAgICAgICB4ID0geCB8fCAxMDtcbiAgICAgICAgeSA9IHkgfHwgdGhpcy5jYW52YXMuaGVpZ2h0IC0gODA7XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgICAgICBjdHguZm9udCA9IFwiMTBweCBBcmlhbFwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjODg4XCI7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCBcIlQ6IFwiICsgdGhpcy5ncmFwaC5nbG9iYWx0aW1lLnRvRml4ZWQoMikgKyBcInNcIiwgNSwgMTMgKiAxICk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXCJJOiBcIiArIHRoaXMuZ3JhcGguaXRlcmF0aW9uLCA1LCAxMyAqIDIgKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIk46IFwiICsgdGhpcy5ncmFwaC5fbm9kZXMubGVuZ3RoICsgXCIgW1wiICsgdGhpcy52aXNpYmxlX25vZGVzLmxlbmd0aCArIFwiXVwiLCA1LCAxMyAqIDMgKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIlY6IFwiICsgdGhpcy5ncmFwaC5fdmVyc2lvbiwgNSwgMTMgKiA0KTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIkZQUzpcIiArIHRoaXMuZnBzLnRvRml4ZWQoMiksIDUsIDEzICogNSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXCJObyBncmFwaCBzZWxlY3RlZFwiLCA1LCAxMyAqIDEpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSBiYWNrIGNhbnZhcyAodGhlIG9uZSBjb250YWluaW5nIHRoZSBiYWNrZ3JvdW5kIGFuZCB0aGUgY29ubmVjdGlvbnMpXG4gICAgICogQG1ldGhvZCBkcmF3QmFja0NhbnZhc1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdCYWNrQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmJnY2FudmFzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYW52YXMud2lkdGggIT0gdGhpcy5jYW52YXMud2lkdGggfHxcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgIT0gdGhpcy5jYW52YXMuaGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmJnY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmJnY3R4ID0gdGhpcy5iZ2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuYmdjdHg7XG4gICAgICAgIGlmIChjdHguc3RhcnQpIHtcbiAgICAgICAgICAgIGN0eC5zdGFydCgpO1xuICAgICAgICB9XG5cblx0XHR2YXIgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0IHx8IFswLDAsY3R4LmNhbnZhcy53aWR0aCxjdHguY2FudmFzLmhlaWdodF07XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICBpZiAodGhpcy5jbGVhcl9iYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KCB2aWV3cG9ydFswXSwgdmlld3BvcnRbMV0sIHZpZXdwb3J0WzJdLCB2aWV3cG9ydFszXSApO1xuICAgICAgICB9XG5cblx0XHQvL3Nob3cgc3ViZ3JhcGggc3RhY2sgaGVhZGVyXG4gICAgICAgIGlmICh0aGlzLl9ncmFwaF9zdGFjayAmJiB0aGlzLl9ncmFwaF9zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50X2dyYXBoID0gdGhpcy5fZ3JhcGhfc3RhY2tbdGhpcy5fZ3JhcGhfc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgc3ViZ3JhcGhfbm9kZSA9IHRoaXMuZ3JhcGguX3N1YmdyYXBoX25vZGU7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdWJncmFwaF9ub2RlLmJnY29sb3I7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTA7XG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCgxLCAxLCBjYW52YXMud2lkdGggLSAyLCBjYW52YXMuaGVpZ2h0IC0gMik7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gXCI0MHB4IEFyaWFsXCI7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdWJncmFwaF9ub2RlLmJnY29sb3IgfHwgXCIjQUFBXCI7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLl9ncmFwaF9zdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRpdGxlICs9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoX3N0YWNrW2ldLl9zdWJncmFwaF9ub2RlLmdldFRpdGxlKCkgKyBcIiA+PiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICB0aXRsZSArIHN1YmdyYXBoX25vZGUuZ2V0VGl0bGUoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggKiAwLjUsXG4gICAgICAgICAgICAgICAgNDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnX2FscmVhZHlfcGFpbnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vblJlbmRlckJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGJnX2FscmVhZHlfcGFpbnRlZCA9IHRoaXMub25SZW5kZXJCYWNrZ3JvdW5kKGNhbnZhcywgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVzZXQgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgICBpZiAoICF0aGlzLnZpZXdwb3J0IClcblx0XHR7XG5cdCAgICAgICAgY3R4LnJlc3RvcmUoKTtcblx0XHQgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHR9XG4gICAgICAgIHRoaXMudmlzaWJsZV9saW5rcy5sZW5ndGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICAvL2FwcGx5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHMudG9DYW52YXNDb250ZXh0KGN0eCk7XG5cbiAgICAgICAgICAgIC8vcmVuZGVyIEJHXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kX2ltYWdlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5kcy5zY2FsZSA+IDAuNSAmJlxuICAgICAgICAgICAgICAgICFiZ19hbHJlYWR5X3BhaW50ZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnpvb21fbW9kaWZ5X2FscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMS4wIC0gMC41IC8gdGhpcy5kcy5zY2FsZSkgKiB0aGlzLmVkaXRvcl9hbHBoYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmVkaXRvcl9hbHBoYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYmdfaW1nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JnX2ltZy5uYW1lICE9IHRoaXMuYmFja2dyb3VuZF9pbWFnZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZ19pbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdfaW1nLm5hbWUgPSB0aGlzLmJhY2tncm91bmRfaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JnX2ltZy5zcmMgPSB0aGlzLmJhY2tncm91bmRfaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdfaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kcmF3KHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGF0dGVybiA9PSBudWxsICYmIHRoaXMuX2JnX2ltZy53aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuX2JnX2ltZywgXCJyZXBlYXRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm5faW1nID0gdGhpcy5fYmdfaW1nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fcGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfYXJlYVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzNdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZ3JvdXBzXG4gICAgICAgICAgICBpZiAodGhpcy5ncmFwaC5fZ3JvdXBzLmxlbmd0aCAmJiAhdGhpcy5saXZlX21vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdHcm91cHMoY2FudmFzLCBjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRyYXdCYWNrZ3JvdW5kKGN0eCwgdGhpcy52aXNpYmxlX2FyZWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub25CYWNrZ3JvdW5kUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgLy9MRUdBQ1lcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIldBUk5JTkchIG9uQmFja2dyb3VuZFJlbmRlciBkZXByZWNhdGVkLCBub3cgaXMgbmFtZWQgb25EcmF3QmFja2dyb3VuZCBcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkJhY2tncm91bmRSZW5kZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0RFQlVHOiBzaG93IGNsaXBwaW5nIGFyZWFcbiAgICAgICAgICAgIC8vY3R4LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgICAgICAvL2N0eC5maWxsUmVjdCggdGhpcy52aXNpYmxlX2FyZWFbMF0gKyAxMCwgdGhpcy52aXNpYmxlX2FyZWFbMV0gKyAxMCwgdGhpcy52aXNpYmxlX2FyZWFbMl0gLSAyMCwgdGhpcy52aXNpYmxlX2FyZWFbM10gLSAyMCk7XG5cbiAgICAgICAgICAgIC8vYmdcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9jYW52YXNfYm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjMjM1XCI7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25zX3NoYWRvd3MpIHtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcIiMwMDBcIjtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gNjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZHJhdyBjb25uZWN0aW9uc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Nvbm5lY3Rpb25zKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuXG4gICAgICAgICAgICAvL3Jlc3RvcmUgc3RhdGVcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3R4LmZpbmlzaCkge1xuICAgICAgICAgICAgY3R4LmZpbmlzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7IC8vdG8gZm9yY2UgdG8gcmVwYWludCB0aGUgZnJvbnQgY2FudmFzIHdpdGggdGhlIGJnY2FudmFzXG4gICAgfTtcblxuICAgIHZhciB0ZW1wX3ZlYzIgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIGdpdmVuIG5vZGUgaW5zaWRlIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIGRyYXdOb2RlXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd05vZGUgPSBmdW5jdGlvbihub2RlLCBjdHgpIHtcbiAgICAgICAgdmFyIGdsb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50X25vZGUgPSBub2RlO1xuXG4gICAgICAgIHZhciBjb2xvciA9IG5vZGUuY29sb3IgfHwgbm9kZS5jb25zdHJ1Y3Rvci5jb2xvciB8fCBMaXRlR3JhcGguTk9ERV9ERUZBVUxUX0NPTE9SO1xuICAgICAgICB2YXIgYmdjb2xvciA9IG5vZGUuYmdjb2xvciB8fCBub2RlLmNvbnN0cnVjdG9yLmJnY29sb3IgfHwgTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9CR0NPTE9SO1xuXG4gICAgICAgIC8vc2hhZG93IGFuZCBnbG93XG4gICAgICAgIGlmIChub2RlLm1vdXNlT3Zlcikge1xuICAgICAgICAgICAgZ2xvdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG93X3F1YWxpdHkgPSB0aGlzLmRzLnNjYWxlIDwgMC42OyAvL3pvb21lZCBvdXRcblxuICAgICAgICAvL29ubHkgcmVuZGVyIGlmIGl0IGZvcmNlcyBpdCB0byBkbyBpdFxuICAgICAgICBpZiAodGhpcy5saXZlX21vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub25EcmF3Rm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9uRHJhd0ZvcmVncm91bmQoY3R4LCB0aGlzLCB0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvcl9hbHBoYSA9IHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBlZGl0b3JfYWxwaGE7XG5cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX3NoYWRvd3MgJiYgIWxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBMaXRlR3JhcGguREVGQVVMVF9TSEFET1dfQ09MT1I7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDIgKiB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAyICogdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMyAqIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2N1c3RvbSBkcmF3IGNvbGxhcHNlZCBtZXRob2QgKGRyYXcgYWZ0ZXIgc2hhZG93cyBiZWNhdXNlIHRoZXkgYXJlIGFmZmVjdGVkKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub2RlLmZsYWdzLmNvbGxhcHNlZCAmJlxuICAgICAgICAgICAgbm9kZS5vbkRyYXdDb2xsYXBzZWQgJiZcbiAgICAgICAgICAgIG5vZGUub25EcmF3Q29sbGFwc2VkKGN0eCwgdGhpcykgPT0gdHJ1ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2xpcCBpZiByZXF1aXJlZCAobWFzaylcbiAgICAgICAgdmFyIHNoYXBlID0gbm9kZS5fc2hhcGUgfHwgTGl0ZUdyYXBoLkJPWF9TSEFQRTtcbiAgICAgICAgdmFyIHNpemUgPSB0ZW1wX3ZlYzI7XG4gICAgICAgIHRlbXBfdmVjMi5zZXQobm9kZS5zaXplKTtcbiAgICAgICAgdmFyIGhvcml6b250YWwgPSBub2RlLmhvcml6b250YWw7IC8vIHx8IG5vZGUuZmxhZ3MuaG9yaXpvbnRhbDtcblxuICAgICAgICBpZiAobm9kZS5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5pbm5lcl90ZXh0X2ZvbnQ7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBub2RlLmdldFRpdGxlID8gbm9kZS5nZXRUaXRsZSgpIDogbm9kZS50aXRsZTtcbiAgICAgICAgICAgIGlmICh0aXRsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fY29sbGFwc2VkX3dpZHRoID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2l6ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1lYXN1cmVUZXh0KHRpdGxlKS53aWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKiAyXG4gICAgICAgICAgICAgICAgKTsgLy9MaXRlR3JhcGguTk9ERV9DT0xMQVBTRURfV0lEVEg7XG4gICAgICAgICAgICAgICAgc2l6ZVswXSA9IG5vZGUuX2NvbGxhcHNlZF93aWR0aDtcbiAgICAgICAgICAgICAgICBzaXplWzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmNsaXBfYXJlYSkge1xuICAgICAgICAgICAgLy9TdGFydCBjbGlwcGluZ1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoMCwgMCwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSkge1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoMCwgMCwgc2l6ZVswXSwgc2l6ZVsxXSwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQ0lSQ0xFX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVsxXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyBzaGFwZVxuICAgICAgICBpZiAobm9kZS5oYXNfZXJyb3JzKSB7XG4gICAgICAgICAgICBiZ2NvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdOb2RlU2hhcGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgYmdjb2xvcixcbiAgICAgICAgICAgIG5vZGUuaXNfc2VsZWN0ZWQsXG4gICAgICAgICAgICBub2RlLm1vdXNlT3ZlclxuICAgICAgICApO1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cbiAgICAgICAgLy9kcmF3IGZvcmVncm91bmRcbiAgICAgICAgaWYgKG5vZGUub25EcmF3Rm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgbm9kZS5vbkRyYXdGb3JlZ3JvdW5kKGN0eCwgdGhpcywgdGhpcy5jYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25uZWN0aW9uIHNsb3RzXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBob3Jpem9udGFsID8gXCJjZW50ZXJcIiA6IFwibGVmdFwiO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuaW5uZXJfdGV4dF9mb250O1xuXG4gICAgICAgIHZhciByZW5kZXJfdGV4dCA9ICFsb3dfcXVhbGl0eTtcblxuICAgICAgICB2YXIgb3V0X3Nsb3QgPSB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0O1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgICAgICB2YXIgbWF4X3kgPSAwO1xuICAgICAgICB2YXIgc2xvdF9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDIpOyAvL3RvIHJldXNlXG5cbiAgICAgICAgLy9yZW5kZXIgaW5wdXRzIGFuZCBvdXRwdXRzXG4gICAgICAgIGlmICghbm9kZS5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIC8vaW5wdXQgY29ubmVjdGlvbiBzbG90c1xuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUuaW5wdXRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGVkaXRvcl9hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2Ugb3BhY2l0eSBvZiBpbmNvbXBhdGlibGUgc2xvdHMgd2hlbiBkcmFnZ2luZyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmNvbm5lY3Rpbmdfbm9kZSAmJiAhTGl0ZUdyYXBoLmlzVmFsaWRDb25uZWN0aW9uKCBzbG90LnR5cGUgLCBvdXRfc2xvdC50eXBlKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNCAqIGVkaXRvcl9hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5saW5rICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNsb3QuY29sb3Jfb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9jb25uZWN0aW9uX2NvbG9yLmlucHV0X29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzbG90LmNvbG9yX29mZiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3IuaW5wdXRfb2ZmO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBub2RlLmdldENvbm5lY3Rpb25Qb3ModHJ1ZSwgaSwgc2xvdF9wb3MpO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLT0gbm9kZS5wb3NbMF07XG4gICAgICAgICAgICAgICAgICAgIHBvc1sxXSAtPSBub2RlLnBvc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heF95IDwgcG9zWzFdICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF95ID0gcG9zWzFdICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC50eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5CT1hfU0hBUEVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLSA1ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLSA4ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC0gNiArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC0gNSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbG90LnNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zWzBdICsgOCwgcG9zWzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zWzBdIC0gNCwgcG9zWzFdICsgNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSAtIDQsIHBvc1sxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYobG93X3F1YWxpdHkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSAtIDQsIHBvc1sxXSAtIDQsIDgsIDggKTsgLy9mYXN0ZXJcblx0XHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9yZW5kZXIgbmFtZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyX3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc2xvdC5sYWJlbCAhPSBudWxsID8gc2xvdC5sYWJlbCA6IHNsb3QubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IExpdGVHcmFwaC5OT0RFX1RFWFRfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwgfHwgc2xvdC5kaXIgPT0gTGl0ZUdyYXBoLlVQKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NbMF0sIHBvc1sxXSAtIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcG9zWzBdICsgMTAsIHBvc1sxXSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9vdXRwdXQgY29ubmVjdGlvbiBzbG90c1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC40ICogZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gaG9yaXpvbnRhbCA/IFwiY2VudGVyXCIgOiBcInJpZ2h0XCI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLm91dHB1dHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyhmYWxzZSwgaSwgc2xvdF9wb3MpO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLT0gbm9kZS5wb3NbMF07XG4gICAgICAgICAgICAgICAgICAgIHBvc1sxXSAtPSBub2RlLnBvc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heF95IDwgcG9zWzFdICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF95ID0gcG9zWzFdICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QubGlua3MgJiYgc2xvdC5saW5rcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNsb3QuY29sb3Jfb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9jb25uZWN0aW9uX2NvbG9yLm91dHB1dF9vblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2xvdC5jb2xvcl9vZmYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9jb25uZWN0aW9uX2NvbG9yLm91dHB1dF9vZmY7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jdHgucmVjdCggbm9kZS5zaXplWzBdIC0gMTQsaSoxNCwxMCwxMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC50eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5CT1hfU0hBUEVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLSA1ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLSA4ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC0gNiArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC0gNSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbG90LnNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zWzBdICsgOCwgcG9zWzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zWzBdIC0gNCwgcG9zWzFdICsgNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSAtIDQsIHBvc1sxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYobG93X3F1YWxpdHkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSAtIDQsIHBvc1sxXSAtIDQsIDgsIDggKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy90cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYoc2xvdC5ub2RlX2lkICE9IG51bGwgJiYgc2xvdC5zbG90ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAvL1x0Y3R4LmZpbGxTdHlsZSA9IFwiI0Y4NVwiO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYoc2xvdC5saW5rcyAhPSBudWxsICYmIHNsb3QubGlua3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGlmKCFsb3dfcXVhbGl0eSlcblx0ICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9yZW5kZXIgb3V0cHV0IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlcl90ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHNsb3QubGFiZWwgIT0gbnVsbCA/IHNsb3QubGFiZWwgOiBzbG90Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBMaXRlR3JhcGguTk9ERV9URVhUX0NPTE9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsIHx8IHNsb3QuZGlyID09IExpdGVHcmFwaC5ET1dOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NbMF0sIHBvc1sxXSAtIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NbMF0gLSAxMCwgcG9zWzFdICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgICAgICBpZiAobm9kZS53aWRnZXRzKSB7XG5cdFx0XHRcdHZhciB3aWRnZXRzX3kgPSBtYXhfeTtcbiAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCB8fCBub2RlLndpZGdldHNfdXApIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0c195ID0gMjtcbiAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdGlmKCBub2RlLndpZGdldHNfc3RhcnRfeSAhPSBudWxsIClcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0c195ID0gbm9kZS53aWRnZXRzX3N0YXJ0X3k7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Tm9kZVdpZGdldHMoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNfeSxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0ICYmIHRoaXMubm9kZV93aWRnZXRbMF0gPT0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm5vZGVfd2lkZ2V0WzFdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyX2NvbGxhcHNlZF9zbG90cykge1xuICAgICAgICAgICAgLy9pZiBjb2xsYXBzZWRcbiAgICAgICAgICAgIHZhciBpbnB1dF9zbG90ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfc2xvdCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vZ2V0IGZpcnN0IGNvbm5lY3RlZCBzbG90IHRvIHJlbmRlclxuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5saW5rID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X3Nsb3QgPSBzbG90O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xvdC5saW5rcyB8fCAhc2xvdC5saW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF9zbG90ID0gc2xvdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnB1dF9zbG90KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogLTAuNTsgLy9jZW50ZXJcbiAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbm9kZS5fY29sbGFwc2VkX3dpZHRoICogMC41O1xuICAgICAgICAgICAgICAgICAgICB5ID0gLUxpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzY4NlwiO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNsb3QudHlwZSA9PT0gTGl0ZUdyYXBoLkVWRU5UIHx8XG4gICAgICAgICAgICAgICAgICAgIHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5CT1hfU0hBUEVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeCAtIDcgKyAwLjUsIHkgLSA0LCAxNCwgOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbG90LnNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgOCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIC00LCB5IC0gNCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIC00LCB5ICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIDQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG91dHB1dF9zbG90KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBub2RlLl9jb2xsYXBzZWRfd2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKiAtMC41OyAvL2NlbnRlclxuICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBub2RlLl9jb2xsYXBzZWRfd2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNjg2XCI7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNsb3QudHlwZSA9PT0gTGl0ZUdyYXBoLkVWRU5UIHx8XG4gICAgICAgICAgICAgICAgICAgIHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5CT1hfU0hBUEVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeCAtIDcgKyAwLjUsIHkgLSA0LCAxNCwgOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbG90LnNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgNiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIDYsIHkgLSA0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gNiwgeSArIDQpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgLy9jdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5jbGlwX2FyZWEpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgfTtcblxuXHQvL3VzZWQgYnkgdGhpcy5vdmVyX2xpbmtfY2VudGVyXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0xpbmtUb29sdGlwID0gZnVuY3Rpb24oIGN0eCwgbGluayApXG5cdHtcblx0XHR2YXIgcG9zID0gbGluay5fcG9zO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMoIHBvc1swXSwgcG9zWzFdLCAzLCAwLCBNYXRoLlBJICogMiApO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZihsaW5rLmRhdGEgPT0gbnVsbClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmKHRoaXMub25EcmF3TGlua1Rvb2x0aXApXG5cdFx0XHRpZiggdGhpcy5vbkRyYXdMaW5rVG9vbHRpcChjdHgsbGluayx0aGlzKSA9PSB0cnVlIClcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIGRhdGEgPSBsaW5rLmRhdGE7XG5cdFx0dmFyIHRleHQgPSBudWxsO1xuXG5cdFx0aWYoIGRhdGEuY29uc3RydWN0b3IgPT09IE51bWJlciApXG5cdFx0XHR0ZXh0ID0gZGF0YS50b0ZpeGVkKDIpO1xuXHRcdGVsc2UgaWYoIGRhdGEuY29uc3RydWN0b3IgPT09IFN0cmluZyApXG5cdFx0XHR0ZXh0ID0gXCJcXFwiXCIgKyBkYXRhICsgXCJcXFwiXCI7XG5cdFx0ZWxzZSBpZiggZGF0YS5jb25zdHJ1Y3RvciA9PT0gQm9vbGVhbiApXG5cdFx0XHR0ZXh0ID0gU3RyaW5nKGRhdGEpO1xuXHRcdGVsc2UgaWYgKGRhdGEudG9Ub29sVGlwKVxuXHRcdFx0dGV4dCA9IGRhdGEudG9Ub29sVGlwKCk7XG5cdFx0ZWxzZVxuXHRcdFx0dGV4dCA9IFwiW1wiICsgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lICsgXCJdXCI7XG5cblx0XHRpZih0ZXh0ID09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGV4dCA9IHRleHQuc3Vic3RyKDAsMzApOyAvL2F2b2lkIHdlaXJkXG5cblx0XHRjdHguZm9udCA9IFwiMTRweCBDb3VyaWVyIE5ld1wiO1xuXHRcdHZhciBpbmZvID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuXHRcdHZhciB3ID0gaW5mby53aWR0aCArIDIwO1xuXHRcdHZhciBoID0gMjQ7XG5cdFx0Y3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xuXHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gMjtcblx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IDI7XG5cdFx0Y3R4LnNoYWRvd0JsdXIgPSAzO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiM0NTRcIjtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJvdW5kUmVjdCggcG9zWzBdIC0gdyowLjUsIHBvc1sxXSAtIDE1IC0gaCwgdywgaCwzLCAzKTtcblx0XHRjdHgubW92ZVRvKCBwb3NbMF0gLSAxMCwgcG9zWzFdIC0gMTUgKTtcblx0XHRjdHgubGluZVRvKCBwb3NbMF0gKyAxMCwgcG9zWzFdIC0gMTUgKTtcblx0XHRjdHgubGluZVRvKCBwb3NbMF0sIHBvc1sxXSAtIDUgKTtcblx0XHRjdHguZmlsbCgpO1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiI0NFQ1wiO1xuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NbMF0sIHBvc1sxXSAtIDE1IC0gaCAqIDAuMyk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSBzaGFwZSBvZiB0aGUgZ2l2ZW4gbm9kZSBpbiB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBkcmF3Tm9kZVNoYXBlXG4gICAgICoqL1xuICAgIHZhciB0bXBfYXJlYSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdOb2RlU2hhcGUgPSBmdW5jdGlvbihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgY3R4LFxuICAgICAgICBzaXplLFxuICAgICAgICBmZ2NvbG9yLFxuICAgICAgICBiZ2NvbG9yLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgbW91c2Vfb3ZlclxuICAgICkge1xuICAgICAgICAvL2JnIHJlY3RcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmdjb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnY29sb3I7XG5cbiAgICAgICAgdmFyIHRpdGxlX2hlaWdodCA9IExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgdmFyIGxvd19xdWFsaXR5ID0gdGhpcy5kcy5zY2FsZSA8IDAuNTtcblxuICAgICAgICAvL3JlbmRlciBub2RlIGFyZWEgZGVwZW5kaW5nIG9uIHNoYXBlXG4gICAgICAgIHZhciBzaGFwZSA9XG4gICAgICAgICAgICBub2RlLl9zaGFwZSB8fCBub2RlLmNvbnN0cnVjdG9yLnNoYXBlIHx8IExpdGVHcmFwaC5ST1VORF9TSEFQRTtcblxuICAgICAgICB2YXIgdGl0bGVfbW9kZSA9IG5vZGUuY29uc3RydWN0b3IudGl0bGVfbW9kZTtcblxuICAgICAgICB2YXIgcmVuZGVyX3RpdGxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRpdGxlX21vZGUgPT0gTGl0ZUdyYXBoLlRSQU5TUEFSRU5UX1RJVExFKSB7XG4gICAgICAgICAgICByZW5kZXJfdGl0bGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aXRsZV9tb2RlID09IExpdGVHcmFwaC5BVVRPSElERV9USVRMRSAmJiBtb3VzZV9vdmVyKSB7XG4gICAgICAgICAgICByZW5kZXJfdGl0bGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZWEgPSB0bXBfYXJlYTtcbiAgICAgICAgYXJlYVswXSA9IDA7IC8veFxuICAgICAgICBhcmVhWzFdID0gcmVuZGVyX3RpdGxlID8gLXRpdGxlX2hlaWdodCA6IDA7IC8veVxuICAgICAgICBhcmVhWzJdID0gc2l6ZVswXSArIDE7IC8vd1xuICAgICAgICBhcmVhWzNdID0gcmVuZGVyX3RpdGxlID8gc2l6ZVsxXSArIHRpdGxlX2hlaWdodCA6IHNpemVbMV07IC8vaFxuXG4gICAgICAgIHZhciBvbGRfYWxwaGEgPSBjdHguZ2xvYmFsQWxwaGE7XG5cbiAgICAgICAgLy9mdWxsIG5vZGUgc2hhcGVcbiAgICAgICAgLy9pZihub2RlLmZsYWdzLmNvbGxhcHNlZClcbiAgICAgICAge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHNoYXBlID09IExpdGVHcmFwaC5CT1hfU0hBUEUgfHwgbG93X3F1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoYXJlYVswXSwgYXJlYVsxXSwgYXJlYVsyXSwgYXJlYVszXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSB8fFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5DQVJEX1NIQVBFXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgICAgICAgICBhcmVhWzBdLFxuICAgICAgICAgICAgICAgICAgICBhcmVhWzFdLFxuICAgICAgICAgICAgICAgICAgICBhcmVhWzJdLFxuICAgICAgICAgICAgICAgICAgICBhcmVhWzNdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdW5kX3JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUgPT0gTGl0ZUdyYXBoLkNBUkRfU0hBUEUgPyAwIDogdGhpcy5yb3VuZF9yYWRpdXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQ0lSQ0xFX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVsxXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuXHRcdFx0Ly9zZXBhcmF0b3Jcblx0XHRcdGlmKCFub2RlLmZsYWdzLmNvbGxhcHNlZClcblx0XHRcdHtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLDAuMilcIjtcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIC0xLCBhcmVhWzJdLCAyKTtcblx0XHRcdH1cbiAgICAgICAgfVxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cbiAgICAgICAgaWYgKG5vZGUub25EcmF3QmFja2dyb3VuZCkge1xuICAgICAgICAgICAgbm9kZS5vbkRyYXdCYWNrZ3JvdW5kKGN0eCwgdGhpcywgdGhpcy5jYW52YXMsIHRoaXMuZ3JhcGhfbW91c2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGl0bGUgYmcgKHJlbWVtYmVyLCBpdCBpcyByZW5kZXJlZCBBQk9WRSB0aGUgbm9kZSlcbiAgICAgICAgaWYgKHJlbmRlcl90aXRsZSB8fCB0aXRsZV9tb2RlID09IExpdGVHcmFwaC5UUkFOU1BBUkVOVF9USVRMRSkge1xuICAgICAgICAgICAgLy90aXRsZSBiYXJcbiAgICAgICAgICAgIGlmIChub2RlLm9uRHJhd1RpdGxlQmFyKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkRyYXdUaXRsZUJhciggY3R4LCB0aXRsZV9oZWlnaHQsIHNpemUsIHRoaXMuZHMuc2NhbGUsIGZnY29sb3IgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgdGl0bGVfbW9kZSAhPSBMaXRlR3JhcGguVFJBTlNQQVJFTlRfVElUTEUgJiZcbiAgICAgICAgICAgICAgICAobm9kZS5jb25zdHJ1Y3Rvci50aXRsZV9jb2xvciB8fCB0aGlzLnJlbmRlcl90aXRsZV9jb2xvcmVkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlX2NvbG9yID0gbm9kZS5jb25zdHJ1Y3Rvci50aXRsZV9jb2xvciB8fCBmZ2NvbG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IExpdGVHcmFwaC5ERUZBVUxUX1NIQURPV19DT0xPUjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyogZ3JhZGllbnQgdGVzdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZV9ncmFkaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyYWQgPSBMR3JhcGhDYW52YXMuZ3JhZGllbnRzW3RpdGxlX2NvbG9yXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkID0gTEdyYXBoQ2FudmFzLmdyYWRpZW50c1sgdGl0bGVfY29sb3IgXSA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCA0MDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoMCwgdGl0bGVfY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoMSwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZV9jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2N0eC5nbG9iYWxBbHBoYSA9IDAuNSAqIG9sZF9hbHBoYTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlID09IExpdGVHcmFwaC5CT1hfU0hBUEUgfHwgbG93X3F1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoMCwgLXRpdGxlX2hlaWdodCwgc2l6ZVswXSArIDEsIHRpdGxlX2hlaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSB8fCBzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRSApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAtdGl0bGVfaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdW5kX3JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZmxhZ3MuY29sbGFwc2VkID8gdGhpcy5yb3VuZF9yYWRpdXMgOiAwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3RpdGxlIGJveFxuICAgICAgICAgICAgdmFyIGJveF9zaXplID0gMTA7XG4gICAgICAgICAgICBpZiAobm9kZS5vbkRyYXdUaXRsZUJveCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25EcmF3VGl0bGVCb3goY3R4LCB0aXRsZV9oZWlnaHQsIHNpemUsIHRoaXMuZHMuc2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguUk9VTkRfU0hBUEUgfHxcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguQ0lSQ0xFX1NIQVBFIHx8XG4gICAgICAgICAgICAgICAgc2hhcGUgPT0gTGl0ZUdyYXBoLkNBUkRfU0hBUEVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChsb3dfcXVhbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQgKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQgKiAtMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94X3NpemUgKiAwLjUgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5vZGUuYm94Y29sb3IgfHwgTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9CT1hDT0xPUjtcblx0XHRcdFx0aWYobG93X3F1YWxpdHkpXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KCB0aXRsZV9oZWlnaHQgKiAwLjUgLSBib3hfc2l6ZSAqMC41LCB0aXRsZV9oZWlnaHQgKiAtMC41IC0gYm94X3NpemUgKjAuNSwgYm94X3NpemUgLCBib3hfc2l6ZSAgKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5hcmMoXG5cdFx0XHRcdFx0XHR0aXRsZV9oZWlnaHQgKiAwLjUsXG5cdFx0XHRcdFx0XHR0aXRsZV9oZWlnaHQgKiAtMC41LFxuXHRcdFx0XHRcdFx0Ym94X3NpemUgKiAwLjUsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqIDJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aXRsZV9oZWlnaHQgLSBib3hfc2l6ZSkgKiAwLjUgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRpdGxlX2hlaWdodCArIGJveF9zaXplKSAqIC0wLjUgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94X3NpemUgKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94X3NpemUgKyAyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBub2RlLmJveGNvbG9yIHx8IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQk9YQ09MT1I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAodGl0bGVfaGVpZ2h0IC0gYm94X3NpemUpICogMC41LFxuICAgICAgICAgICAgICAgICAgICAodGl0bGVfaGVpZ2h0ICsgYm94X3NpemUpICogLTAuNSxcbiAgICAgICAgICAgICAgICAgICAgYm94X3NpemUsXG4gICAgICAgICAgICAgICAgICAgIGJveF9zaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9sZF9hbHBoYTtcblxuICAgICAgICAgICAgLy90aXRsZSB0ZXh0XG4gICAgICAgICAgICBpZiAobm9kZS5vbkRyYXdUaXRsZVRleHQpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRHJhd1RpdGxlVGV4dChcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGl0bGVfdGV4dF9mb250LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLnRpdGxlX3RleHRfZm9udDtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBTdHJpbmcobm9kZS5nZXRUaXRsZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gTGl0ZUdyYXBoLk5PREVfU0VMRUNURURfVElUTEVfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnN0cnVjdG9yLnRpdGxlX3RleHRfY29sb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfdGl0bGVfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVhc3VyZSA9IGN0eC5tZWFzdXJlVGV4dCh0aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUuc3Vic3RyKDAsMjApLCAvL2F2b2lkIHVybHMgdG9vIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsLy8gKyBtZWFzdXJlLndpZHRoICogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX1RFWFRfWSAtIHRpdGxlX2hlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfVEVYVF9ZIC0gdGl0bGVfaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cdFx0XHQvL3N1YmdyYXBoIGJveFxuXHRcdFx0aWYgKCFub2RlLmZsYWdzLmNvbGxhcHNlZCAmJiBub2RlLnN1YmdyYXBoICYmICFub2RlLnNraXBfc3ViZ3JhcGhfYnV0dG9uKSB7XG5cdFx0XHRcdHZhciB3ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuXHRcdFx0XHR2YXIgeCA9IG5vZGUuc2l6ZVswXSAtIHc7XG5cdFx0XHRcdHZhciBvdmVyID0gTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKCB0aGlzLmdyYXBoX21vdXNlWzBdIC0gbm9kZS5wb3NbMF0sIHRoaXMuZ3JhcGhfbW91c2VbMV0gLSBub2RlLnBvc1sxXSwgeCsyLCAtdysyLCB3LTQsIHctNCApO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiIzg4OFwiIDogXCIjNTU1XCI7XG5cdFx0XHRcdGlmKCBzaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFIHx8IGxvd19xdWFsaXR5KVxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdCh4KzIsIC13KzIsIHctNCwgdy00KTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5yb3VuZFJlY3QoeCsyLCAtdysyLCB3LTQsIHctNCw0KTtcblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBcIiMzMzNcIjtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHggKyB3ICogMC4yLCAtdyAqIDAuNik7XG5cdFx0XHRcdGN0eC5saW5lVG8oeCArIHcgKiAwLjgsIC13ICogMC42KTtcblx0XHRcdFx0Y3R4LmxpbmVUbyh4ICsgdyAqIDAuNSwgLXcgKiAwLjMpO1xuXHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2N1c3RvbSB0aXRsZSByZW5kZXJcbiAgICAgICAgICAgIGlmIChub2RlLm9uRHJhd1RpdGxlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkRyYXdUaXRsZShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXIgc2VsZWN0aW9uIG1hcmtlclxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm9uQm91bmRpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uQm91bmRpbmcoYXJlYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aXRsZV9tb2RlID09IExpdGVHcmFwaC5UUkFOU1BBUkVOVF9USVRMRSkge1xuICAgICAgICAgICAgICAgIGFyZWFbMV0gLT0gdGl0bGVfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGFyZWFbM10gKz0gdGl0bGVfaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjg7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSkge1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAtNiArIGFyZWFbMF0sXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgMTIgKyBhcmVhWzJdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbM11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguUk9VTkRfU0hBUEUgfHxcbiAgICAgICAgICAgICAgICAoc2hhcGUgPT0gTGl0ZUdyYXBoLkNBUkRfU0hBUEUgJiYgbm9kZS5mbGFncy5jb2xsYXBzZWQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgICAgICAgICAtNiArIGFyZWFbMF0sXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgMTIgKyBhcmVhWzJdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbM10sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm91bmRfcmFkaXVzICogMlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09IExpdGVHcmFwaC5DQVJEX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChcbiAgICAgICAgICAgICAgICAgICAgLTYgKyBhcmVhWzBdLFxuICAgICAgICAgICAgICAgICAgICAtNiArIGFyZWFbMV0sXG4gICAgICAgICAgICAgICAgICAgIDEyICsgYXJlYVsyXSxcbiAgICAgICAgICAgICAgICAgICAgMTIgKyBhcmVhWzNdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdW5kX3JhZGl1cyAqIDIsXG4gICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQ0lSQ0xFX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVsxXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSArIDYsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IExpdGVHcmFwaC5OT0RFX0JPWF9PVVRMSU5FX0NPTE9SO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmdjb2xvcjtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1hcmdpbl9hcmVhID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB2YXIgbGlua19ib3VuZGluZyA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgdmFyIHRlbXBBID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICB2YXIgdGVtcEIgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgZXZlcnkgY29ubmVjdGlvbiB2aXNpYmxlIGluIHRoZSBjYW52YXNcbiAgICAgKiBPUFRJTUlaRSBUSElTOiBwcmUtY2F0Y2ggY29ubmVjdGlvbnMgcG9zaXRpb24gaW5zdGVhZCBvZiByZWNvbXB1dGluZyB0aGVtIGV2ZXJ5IHRpbWVcbiAgICAgKiBAbWV0aG9kIGRyYXdDb25uZWN0aW9uc1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdDb25uZWN0aW9ucyA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICB2YXIgbm93ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIHZpc2libGVfYXJlYSA9IHRoaXMudmlzaWJsZV9hcmVhO1xuICAgICAgICBtYXJnaW5fYXJlYVswXSA9IHZpc2libGVfYXJlYVswXSAtIDIwO1xuICAgICAgICBtYXJnaW5fYXJlYVsxXSA9IHZpc2libGVfYXJlYVsxXSAtIDIwO1xuICAgICAgICBtYXJnaW5fYXJlYVsyXSA9IHZpc2libGVfYXJlYVsyXSArIDQwO1xuICAgICAgICBtYXJnaW5fYXJlYVszXSA9IHZpc2libGVfYXJlYVszXSArIDQwO1xuXG4gICAgICAgIC8vZHJhdyBjb25uZWN0aW9uc1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5jb25uZWN0aW9uc193aWR0aDtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI0FBQVwiO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmVkaXRvcl9hbHBoYTtcbiAgICAgICAgLy9mb3IgZXZlcnkgbm9kZVxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgbiA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IG4gPCBsOyArK24pIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbl07XG4gICAgICAgICAgICAvL2ZvciBldmVyeSBpbnB1dCAod2UgcmVuZGVyIGp1c3QgaW5wdXRzIGJlY2F1c2UgaXQgaXMgZWFzaWVyIGFzIGV2ZXJ5IHNsb3QgY2FuIG9ubHkgaGF2ZSBvbmUgaW5wdXQpXG4gICAgICAgICAgICBpZiAoIW5vZGUuaW5wdXRzIHx8ICFub2RlLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQgfHwgaW5wdXQubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IGlucHV0Lmxpbms7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2ZpbmQgbGluayBpbmZvXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmsub3JpZ2luX2lkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRfbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfbm9kZV9zbG90ID0gbGluay5vcmlnaW5fc2xvdDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfbm9kZV9zbG90cG9zID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRfbm9kZV9zbG90ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGVfc2xvdHBvcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGUucG9zWzBdICsgMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9ub2RlLnBvc1sxXSArIDEwXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zID0gc3RhcnRfbm9kZS5nZXRDb25uZWN0aW9uUG9zKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9ub2RlX3Nsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW5kX25vZGVfc2xvdHBvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyh0cnVlLCBpLCB0ZW1wQik7XG5cbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgbGluayBib3VuZGluZ1xuICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMF0gPSBzdGFydF9ub2RlX3Nsb3Rwb3NbMF07XG4gICAgICAgICAgICAgICAgbGlua19ib3VuZGluZ1sxXSA9IHN0YXJ0X25vZGVfc2xvdHBvc1sxXTtcbiAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzJdID0gZW5kX25vZGVfc2xvdHBvc1swXSAtIHN0YXJ0X25vZGVfc2xvdHBvc1swXTtcbiAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzNdID0gZW5kX25vZGVfc2xvdHBvc1sxXSAtIHN0YXJ0X25vZGVfc2xvdHBvc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAobGlua19ib3VuZGluZ1syXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua19ib3VuZGluZ1swXSArPSBsaW5rX2JvdW5kaW5nWzJdO1xuICAgICAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzJdID0gTWF0aC5hYnMobGlua19ib3VuZGluZ1syXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5rX2JvdW5kaW5nWzNdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzFdICs9IGxpbmtfYm91bmRpbmdbM107XG4gICAgICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbM10gPSBNYXRoLmFicyhsaW5rX2JvdW5kaW5nWzNdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3NraXAgbGlua3Mgb3V0c2lkZSBvZiB0aGUgdmlzaWJsZSBhcmVhIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXBCb3VuZGluZyhsaW5rX2JvdW5kaW5nLCBtYXJnaW5fYXJlYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X3Nsb3QgPSBzdGFydF9ub2RlLm91dHB1dHNbc3RhcnRfbm9kZV9zbG90XTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kX3Nsb3QgPSBub2RlLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0X3Nsb3QgfHwgIWVuZF9zbG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfZGlyID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfc2xvdC5kaXIgfHxcbiAgICAgICAgICAgICAgICAgICAgKHN0YXJ0X25vZGUuaG9yaXpvbnRhbCA/IExpdGVHcmFwaC5ET1dOIDogTGl0ZUdyYXBoLlJJR0hUKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kX2RpciA9XG4gICAgICAgICAgICAgICAgICAgIGVuZF9zbG90LmRpciB8fFxuICAgICAgICAgICAgICAgICAgICAobm9kZS5ob3Jpem9udGFsID8gTGl0ZUdyYXBoLlVQIDogTGl0ZUdyYXBoLkxFRlQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5rKFxuICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGVfc2xvdHBvcyxcbiAgICAgICAgICAgICAgICAgICAgZW5kX25vZGVfc2xvdHBvcyxcbiAgICAgICAgICAgICAgICAgICAgbGluayxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvL2V2ZW50IHRyaWdnZXJlZCByZW5kZXJlZCBvbiB0b3BcbiAgICAgICAgICAgICAgICBpZiAobGluayAmJiBsaW5rLl9sYXN0X3RpbWUgJiYgbm93IC0gbGluay5fbGFzdF90aW1lIDwgMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDIuMCAtIChub3cgLSBsaW5rLl9sYXN0X3RpbWUpICogMC4wMDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBjdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRtcCAqIGY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGVfc2xvdHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9ub2RlX3Nsb3Rwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9kaXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgYSBsaW5rIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqIEBtZXRob2QgcmVuZGVyTGlua1xuICAgICAqIEBwYXJhbSB7dmVjMn0gYSBzdGFydCBwb3NcbiAgICAgKiBAcGFyYW0ge3ZlYzJ9IGIgZW5kIHBvc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5rIHRoZSBsaW5rIG9iamVjdCB3aXRoIGFsbCB0aGUgbGluayBpbmZvXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwX2JvcmRlciBpZ25vcmUgdGhlIHNoYWRvdyBvZiB0aGUgbGlua1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxvdyBzaG93IGZsb3cgYW5pbWF0aW9uIChmb3IgZXZlbnRzKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciB0aGUgY29sb3IgZm9yIHRoZSBsaW5rXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2RpciB0aGUgZGlyZWN0aW9uIGVudW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kX2RpciB0aGUgZGlyZWN0aW9uIGVudW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtX3N1YmxpbmVzIG51bWJlciBvZiBzdWJsaW5lcyAodXNlZnVsIHRvIHJlcHJlc2VudCB2ZWMzIG9yIHJnYilcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5yZW5kZXJMaW5rID0gZnVuY3Rpb24oXG4gICAgICAgIGN0eCxcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgbGluayxcbiAgICAgICAgc2tpcF9ib3JkZXIsXG4gICAgICAgIGZsb3csXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdGFydF9kaXIsXG4gICAgICAgIGVuZF9kaXIsXG4gICAgICAgIG51bV9zdWJsaW5lc1xuICAgICkge1xuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlX2xpbmtzLnB1c2gobGluayk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2Nob29zZSBjb2xvclxuICAgICAgICBpZiAoIWNvbG9yICYmIGxpbmspIHtcbiAgICAgICAgICAgIGNvbG9yID0gbGluay5jb2xvciB8fCBMR3JhcGhDYW52YXMubGlua190eXBlX2NvbG9yc1tsaW5rLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy5kZWZhdWx0X2xpbmtfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmsgIT0gbnVsbCAmJiB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW2xpbmsuaWRdKSB7XG4gICAgICAgICAgICBjb2xvciA9IFwiI0ZGRlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRfZGlyID0gc3RhcnRfZGlyIHx8IExpdGVHcmFwaC5SSUdIVDtcbiAgICAgICAgZW5kX2RpciA9IGVuZF9kaXIgfHwgTGl0ZUdyYXBoLkxFRlQ7XG5cbiAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShhLCBiKTtcblxuICAgICAgICBpZiAodGhpcy5yZW5kZXJfY29ubmVjdGlvbnNfYm9yZGVyICYmIHRoaXMuZHMuc2NhbGUgPiAwLjYpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoICsgNDtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgIG51bV9zdWJsaW5lcyA9IG51bV9zdWJsaW5lcyB8fCAxO1xuICAgICAgICBpZiAobnVtX3N1YmxpbmVzID4gMSkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYmVnaW4gbGluZSBzaGFwZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX3N1YmxpbmVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXR5ID0gKGkgLSAobnVtX3N1YmxpbmVzIC0gMSkgKiAwLjUpICogNTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGlua3NfcmVuZGVyX21vZGUgPT0gTGl0ZUdyYXBoLlNQTElORV9MSU5LKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhhWzBdLCBhWzFdICsgb2Zmc2V0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X29mZnNldF94ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfb2Zmc2V0X3kgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfb2Zmc2V0X3ggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfb2Zmc2V0X3kgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRfZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkxFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRfeCA9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF94ID0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRfeSA9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3kgPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVuZF9kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeCA9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeCA9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF95ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0X3kgPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgYVswXSArIHN0YXJ0X29mZnNldF94LFxuICAgICAgICAgICAgICAgICAgICBhWzFdICsgc3RhcnRfb2Zmc2V0X3kgKyBvZmZzZXR5LFxuICAgICAgICAgICAgICAgICAgICBiWzBdICsgZW5kX29mZnNldF94LFxuICAgICAgICAgICAgICAgICAgICBiWzFdICsgZW5kX29mZnNldF95ICsgb2Zmc2V0eSxcbiAgICAgICAgICAgICAgICAgICAgYlswXSxcbiAgICAgICAgICAgICAgICAgICAgYlsxXSArIG9mZnNldHlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxpbmtzX3JlbmRlcl9tb2RlID09IExpdGVHcmFwaC5MSU5FQVJfTElOSykge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYVswXSwgYVsxXSArIG9mZnNldHkpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF9vZmZzZXRfeCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X29mZnNldF95ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kX29mZnNldF94ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kX29mZnNldF95ID0gMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXJ0X2Rpcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3ggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF94ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF95ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF95ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVuZF9kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0X3kgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsID0gMTU7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICAgICAgYVswXSArIHN0YXJ0X29mZnNldF94ICogbCxcbiAgICAgICAgICAgICAgICAgICAgYVsxXSArIHN0YXJ0X29mZnNldF95ICogbCArIG9mZnNldHlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgICAgICAgIGJbMF0gKyBlbmRfb2Zmc2V0X3ggKiBsLFxuICAgICAgICAgICAgICAgICAgICBiWzFdICsgZW5kX29mZnNldF95ICogbCArIG9mZnNldHlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYlswXSwgYlsxXSArIG9mZnNldHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxpbmtzX3JlbmRlcl9tb2RlID09IExpdGVHcmFwaC5TVFJBSUdIVF9MSU5LKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfeCA9IGFbMF07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X3kgPSBhWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfeCA9IGJbMF07XG4gICAgICAgICAgICAgICAgdmFyIGVuZF95ID0gYlsxXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRfZGlyID09IExpdGVHcmFwaC5SSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydF94ICs9IDEwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X3kgKz0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmRfZGlyID09IExpdGVHcmFwaC5MRUZUKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZF94IC09IDEwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZF95IC09IDEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHN0YXJ0X3gsIHN0YXJ0X3kpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oKHN0YXJ0X3ggKyBlbmRfeCkgKiAwLjUsIHN0YXJ0X3kpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oKHN0YXJ0X3ggKyBlbmRfeCkgKiAwLjUsIGVuZF95KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGVuZF94LCBlbmRfeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiWzBdLCBiWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvL3Vua25vd25cbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVuZGVyaW5nIHRoZSBvdXRsaW5lIG9mIHRoZSBjb25uZWN0aW9uIGNhbiBiZSBhIGxpdHRsZSBiaXQgc2xvd1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnJlbmRlcl9jb25uZWN0aW9uc19ib3JkZXIgJiZcbiAgICAgICAgICAgIHRoaXMuZHMuc2NhbGUgPiAwLjYgJiZcbiAgICAgICAgICAgICFza2lwX2JvcmRlclxuICAgICAgICApIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgwLDAsMCwwLjUpXCI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5jb25uZWN0aW9uc193aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIC8vZW5kIGxpbmUgc2hhcGVcblxuICAgICAgICB2YXIgcG9zID0gdGhpcy5jb21wdXRlQ29ubmVjdGlvblBvaW50KGEsIGIsIDAuNSwgc3RhcnRfZGlyLCBlbmRfZGlyKTtcbiAgICAgICAgaWYgKGxpbmsgJiYgbGluay5fcG9zKSB7XG4gICAgICAgICAgICBsaW5rLl9wb3NbMF0gPSBwb3NbMF07XG4gICAgICAgICAgICBsaW5rLl9wb3NbMV0gPSBwb3NbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlciBhcnJvdyBpbiB0aGUgbWlkZGxlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZHMuc2NhbGUgPj0gMC42ICYmXG4gICAgICAgICAgICB0aGlzLmhpZ2hxdWFsaXR5X3JlbmRlciAmJlxuICAgICAgICAgICAgZW5kX2RpciAhPSBMaXRlR3JhcGguQ0VOVEVSXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy9yZW5kZXIgYXJyb3dcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9jb25uZWN0aW9uX2Fycm93cykge1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0d28gcG9pbnRzIGluIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHBvc0EgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgICAgIDAuMjUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0IgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgICAgIDAuMjYsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0MgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgICAgIDAuNzUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0QgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgICAgIDAuNzYsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgdGhlIGFuZ2xlIGJldHdlZW4gdGhlbSBzbyB0aGUgYXJyb3cgcG9pbnRzIGluIHRoZSByaWdodCBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgYW5nbGVBID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGVCID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJfY3VydmVkX2Nvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlQSA9IC1NYXRoLmF0YW4yKHBvc0JbMF0gLSBwb3NBWzBdLCBwb3NCWzFdIC0gcG9zQVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlQiA9IC1NYXRoLmF0YW4yKHBvc0RbMF0gLSBwb3NDWzBdLCBwb3NEWzFdIC0gcG9zQ1sxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVCID0gYW5nbGVBID0gYlsxXSA+IGFbMV0gPyAwIDogTWF0aC5QSTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3JlbmRlciBhcnJvd1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb3NBWzBdLCBwb3NBWzFdKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oLTUsIC0zKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKDAsICs3KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKCs1LCAtMyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb3NDWzBdLCBwb3NDWzFdKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlQik7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oLTUsIC0zKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKDAsICs3KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKCs1LCAtMyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2NpcmNsZVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVuZGVyIGZsb3dpbmcgcG9pbnRzXG4gICAgICAgIGlmIChmbG93KSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gKExpdGVHcmFwaC5nZXRUaW1lKCkgKiAwLjAwMSArIGkgKiAwLjIpICUgMTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5jb21wdXRlQ29ubmVjdGlvblBvaW50KFxuICAgICAgICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICAgICAgICBiLFxuICAgICAgICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICAgICAgICBzdGFydF9kaXIsXG4gICAgICAgICAgICAgICAgICAgIGVuZF9kaXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHBvc1swXSwgcG9zWzFdLCA1LCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL3JldHVybnMgdGhlIGxpbmsgY2VudGVyIHBvaW50IGJhc2VkIG9uIGN1cnZhdHVyZVxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludCA9IGZ1bmN0aW9uKFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICB0LFxuICAgICAgICBzdGFydF9kaXIsXG4gICAgICAgIGVuZF9kaXJcbiAgICApIHtcbiAgICAgICAgc3RhcnRfZGlyID0gc3RhcnRfZGlyIHx8IExpdGVHcmFwaC5SSUdIVDtcbiAgICAgICAgZW5kX2RpciA9IGVuZF9kaXIgfHwgTGl0ZUdyYXBoLkxFRlQ7XG5cbiAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShhLCBiKTtcbiAgICAgICAgdmFyIHAwID0gYTtcbiAgICAgICAgdmFyIHAxID0gW2FbMF0sIGFbMV1dO1xuICAgICAgICB2YXIgcDIgPSBbYlswXSwgYlsxXV07XG4gICAgICAgIHZhciBwMyA9IGI7XG5cbiAgICAgICAgc3dpdGNoIChzdGFydF9kaXIpIHtcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkxFRlQ6XG4gICAgICAgICAgICAgICAgcDFbMF0gKz0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguUklHSFQ6XG4gICAgICAgICAgICAgICAgcDFbMF0gKz0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5VUDpcbiAgICAgICAgICAgICAgICBwMVsxXSArPSBkaXN0ICogLTAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5ET1dOOlxuICAgICAgICAgICAgICAgIHAxWzFdICs9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZW5kX2Rpcikge1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICBwMlswXSArPSBkaXN0ICogLTAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5SSUdIVDpcbiAgICAgICAgICAgICAgICBwMlswXSArPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgIHAyWzFdICs9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgcDJbMV0gKz0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYzEgPSAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgICAgIHZhciBjMiA9IDMgKiAoKDEgLSB0KSAqICgxIC0gdCkpICogdDtcbiAgICAgICAgdmFyIGMzID0gMyAqICgxIC0gdCkgKiAodCAqIHQpO1xuICAgICAgICB2YXIgYzQgPSB0ICogdCAqIHQ7XG5cbiAgICAgICAgdmFyIHggPSBjMSAqIHAwWzBdICsgYzIgKiBwMVswXSArIGMzICogcDJbMF0gKyBjNCAqIHAzWzBdO1xuICAgICAgICB2YXIgeSA9IGMxICogcDBbMV0gKyBjMiAqIHAxWzFdICsgYzMgKiBwMlsxXSArIGM0ICogcDNbMV07XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0V4ZWN1dGlvbk9yZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4yNTtcblxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjc1O1xuXG4gICAgICAgIHZhciB2aXNpYmxlX25vZGVzID0gdGhpcy52aXNpYmxlX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2libGVfbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdmlzaWJsZV9ub2Rlc1tpXTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsXG4gICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hULFxuICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChub2RlLm9yZGVyID09IDApIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41LFxuICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjRkZGXCI7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgbm9kZS5vcmRlcixcbiAgICAgICAgICAgICAgICBub2RlLnBvc1swXSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAqIC0wLjUsXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gLSA2XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSB3aWRnZXRzIHN0b3JlZCBpbnNpZGUgYSBub2RlXG4gICAgICogQG1ldGhvZCBkcmF3Tm9kZVdpZGdldHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3Tm9kZVdpZGdldHMgPSBmdW5jdGlvbihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcG9zWSxcbiAgICAgICAgY3R4LFxuICAgICAgICBhY3RpdmVfd2lkZ2V0XG4gICAgKSB7XG4gICAgICAgIGlmICghbm9kZS53aWRnZXRzIHx8ICFub2RlLndpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSBub2RlLnNpemVbMF07XG4gICAgICAgIHZhciB3aWRnZXRzID0gbm9kZS53aWRnZXRzO1xuICAgICAgICBwb3NZICs9IDI7XG4gICAgICAgIHZhciBIID0gTGl0ZUdyYXBoLk5PREVfV0lER0VUX0hFSUdIVDtcbiAgICAgICAgdmFyIHNob3dfdGV4dCA9IHRoaXMuZHMuc2NhbGUgPiAwLjU7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICB2YXIgb3V0bGluZV9jb2xvciA9IExpdGVHcmFwaC5XSURHRVRfT1VUTElORV9DT0xPUjtcbiAgICAgICAgdmFyIGJhY2tncm91bmRfY29sb3IgPSBMaXRlR3JhcGguV0lER0VUX0JHQ09MT1I7XG4gICAgICAgIHZhciB0ZXh0X2NvbG9yID0gTGl0ZUdyYXBoLldJREdFVF9URVhUX0NPTE9SO1xuXHRcdHZhciBzZWNvbmRhcnlfdGV4dF9jb2xvciA9IExpdGVHcmFwaC5XSURHRVRfU0VDT05EQVJZX1RFWFRfQ09MT1I7XG4gICAgICAgIHZhciBtYXJnaW4gPSAxNTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZGdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB3ID0gd2lkZ2V0c1tpXTtcbiAgICAgICAgICAgIHZhciB5ID0gcG9zWTtcbiAgICAgICAgICAgIGlmICh3LnkpIHtcbiAgICAgICAgICAgICAgICB5ID0gdy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdy5sYXN0X3kgPSB5O1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3V0bGluZV9jb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMyMjJcIjtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdC8vY3R4LmxpbmVXaWR0aCA9IDI7XG5cdFx0XHRpZih3LmRpc2FibGVkKVxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgKj0gMC41O1xuXHRcdFx0dmFyIHdpZGdldF93aWR0aCA9IHcud2lkdGggfHwgd2lkdGg7XG5cbiAgICAgICAgICAgIHN3aXRjaCAody50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAody5jbGlja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3LmNsaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QobWFyZ2luLCB5LCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIKTtcblx0XHRcdFx0XHRpZihzaG93X3RleHQgJiYgIXcuZGlzYWJsZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoIG1hcmdpbiwgeSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHcubmFtZSwgd2lkZ2V0X3dpZHRoICogMC41LCB5ICsgSCAqIDAuNyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvZ2dsZVwiOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG91dGxpbmVfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kX2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgsIEggKiAwLjUpO1xuXHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEggKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblx0XHRcdFx0XHRpZihzaG93X3RleHQgJiYgIXcuZGlzYWJsZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdy52YWx1ZSA/IFwiIzg5QVwiIDogXCIjMzMzXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyggd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgeSArIEggKiAwLjUsIEggKiAwLjM2LCAwLCBNYXRoLlBJICogMiApO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2Vjb25kYXJ5X3RleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAody5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQody5uYW1lLCBtYXJnaW4gKiAyLCB5ICsgSCAqIDAuNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdy52YWx1ZSA/IHRleHRfY29sb3IgOiBzZWNvbmRhcnlfdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHcub3B0aW9ucy5vbiB8fCBcInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHcub3B0aW9ucy5vZmYgfHwgXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldF93aWR0aCAtIDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBIICogMC43XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzbGlkZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB3Lm9wdGlvbnMubWF4IC0gdy5vcHRpb25zLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG52YWx1ZSA9ICh3LnZhbHVlIC0gdy5vcHRpb25zLm1pbikgLyByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGFjdGl2ZV93aWRnZXQgPT0gdyA/IFwiIzg5QVwiIDogXCIjNjc4XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChtYXJnaW4sIHksIG52YWx1ZSAqICh3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyKSwgSCk7XG5cdFx0XHRcdFx0aWYoc2hvd190ZXh0ICYmICF3LmRpc2FibGVkKVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KG1hcmdpbiwgeSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3Lm1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlcl9udmFsdWUgPSAody5tYXJrZXIgLSB3Lm9wdGlvbnMubWluKSAvIHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FBOVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KCBtYXJnaW4gKyBtYXJrZXJfbnZhbHVlICogKHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIpLCB5LCAyLCBIICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dfdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3Lm5hbWUgKyBcIiAgXCIgKyBOdW1iZXIody52YWx1ZSkudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRfd2lkdGggKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIEggKiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21ib1wiOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG91dGxpbmVfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kX2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0aWYoc2hvd190ZXh0KVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QobWFyZ2luLCBwb3NZLCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBILCBIICogMC41KTtcblx0XHRcdFx0XHRlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QobWFyZ2luLCBwb3NZLCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIICk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpIHtcblx0XHRcdFx0XHRcdGlmKCF3LmRpc2FibGVkKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRfY29sb3I7XG5cdFx0XHRcdFx0XHRpZighdy5kaXNhYmxlZClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRjdHgubW92ZVRvKG1hcmdpbiArIDE2LCBwb3NZICsgNSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8obWFyZ2luICsgNiwgcG9zWSArIEggKiAwLjUpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKG1hcmdpbiArIDE2LCBwb3NZICsgSCAtIDUpO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8od2lkZ2V0X3dpZHRoIC0gbWFyZ2luIC0gMTYsIHBvc1kgKyA1KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh3aWRnZXRfd2lkdGggLSBtYXJnaW4gLSA2LCBwb3NZICsgSCAqIDAuNSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8od2lkZ2V0X3dpZHRoIC0gbWFyZ2luIC0gMTYsIHBvc1kgKyBIIC0gNSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0XHR9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2Vjb25kYXJ5X3RleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQody5uYW1lLCBtYXJnaW4gKiAyICsgNSwgeSArIEggKiAwLjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcudHlwZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIody52YWx1ZSkudG9GaXhlZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcub3B0aW9ucy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdy5vcHRpb25zLnByZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyIC0gMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBIICogMC43XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2ID0gdy52YWx1ZTtcblx0XHRcdFx0XHRcdFx0aWYoIHcub3B0aW9ucy52YWx1ZXMgKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHcub3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24gKVxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzID0gdmFsdWVzKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFsdWVzICYmIHZhbHVlcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG5cdFx0XHRcdFx0XHRcdFx0XHR2ID0gdmFsdWVzWyB3LnZhbHVlIF07XG5cdFx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIgLSAyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIEggKiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG91dGxpbmVfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kX2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChtYXJnaW4sIHBvc1ksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgsIEggKiAwLjUpO1xuXHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCggbWFyZ2luLCBwb3NZLCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIICk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KSB7XG5cdFx0XHRcdFx0XHRpZighdy5kaXNhYmxlZClcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuICAgIFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0Y3R4LnJlY3QobWFyZ2luLCBwb3NZLCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIKTtcblx0XHRcdFx0XHRcdGN0eC5jbGlwKCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvL2N0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWNvbmRhcnlfdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3Lm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh3Lm5hbWUsIG1hcmdpbiAqIDIsIHkgKyBIICogMC43KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChTdHJpbmcody52YWx1ZSkuc3Vic3RyKDAsMzApLCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCB5ICsgSCAqIDAuNyk7IC8vMzAgY2hhcnMgbWF4XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh3LmRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcuZHJhdyhjdHgsIG5vZGUsIHdpZGdldF93aWR0aCwgeSwgSCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NZICs9ICh3LmNvbXB1dGVTaXplID8gdy5jb21wdXRlU2l6ZSh3aWRnZXRfd2lkdGgpWzFdIDogSCkgKyA0O1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG5cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcHJvY2VzcyBhbiBldmVudCBvbiB3aWRnZXRzXG4gICAgICogQG1ldGhvZCBwcm9jZXNzTm9kZVdpZGdldHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTm9kZVdpZGdldHMgPSBmdW5jdGlvbihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcG9zLFxuICAgICAgICBldmVudCxcbiAgICAgICAgYWN0aXZlX3dpZGdldFxuICAgICkge1xuICAgICAgICBpZiAoIW5vZGUud2lkZ2V0cyB8fCAhbm9kZS53aWRnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHBvc1swXSAtIG5vZGUucG9zWzBdO1xuICAgICAgICB2YXIgeSA9IHBvc1sxXSAtIG5vZGUucG9zWzFdO1xuICAgICAgICB2YXIgd2lkdGggPSBub2RlLnNpemVbMF07XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSB0aGlzLmdldENhbnZhc1dpbmRvdygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS53aWRnZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdyA9IG5vZGUud2lkZ2V0c1tpXTtcblx0XHRcdGlmKCF3IHx8IHcuZGlzYWJsZWQpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIHdpZGdldF9oZWlnaHQgPSB3LmNvbXB1dGVTaXplID8gdy5jb21wdXRlU2l6ZSh3aWR0aClbMV0gOiBMaXRlR3JhcGguTk9ERV9XSURHRVRfSEVJR0hUO1xuXHRcdFx0dmFyIHdpZGdldF93aWR0aCA9IHcud2lkdGggfHwgd2lkdGg7XG5cdFx0XHQvL291dHNpZGVcblx0XHRcdGlmICggdyAhPSBhY3RpdmVfd2lkZ2V0ICYmIFxuXHRcdFx0XHQoeCA8IDYgfHwgeCA+IHdpZGdldF93aWR0aCAtIDEyIHx8IHkgPCB3Lmxhc3RfeSB8fCB5ID4gdy5sYXN0X3kgKyB3aWRnZXRfaGVpZ2h0IHx8IHcubGFzdF95ID09PSB1bmRlZmluZWQpICkgXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgb2xkX3ZhbHVlID0gdy52YWx1ZTtcblxuICAgICAgICAgICAgLy9pZiAoIHcgPT0gYWN0aXZlX3dpZGdldCB8fCAoeCA+IDYgJiYgeCA8IHdpZGdldF93aWR0aCAtIDEyICYmIHkgPiB3Lmxhc3RfeSAmJiB5IDwgdy5sYXN0X3kgKyB3aWRnZXRfaGVpZ2h0KSApIHtcblx0XHRcdC8vaW5zaWRlIHdpZGdldFxuXHRcdFx0c3dpdGNoICh3LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcImJ1dHRvblwiOlxuXHRcdFx0XHRcdGlmIChldmVudC50eXBlID09PSBcIm1vdXNlZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAody5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcuY2FsbGJhY2sodywgdGhhdCwgbm9kZSwgcG9zLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdy5jbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwic2xpZGVyXCI6XG5cdFx0XHRcdFx0dmFyIHJhbmdlID0gdy5vcHRpb25zLm1heCAtIHcub3B0aW9ucy5taW47XG5cdFx0XHRcdFx0dmFyIG52YWx1ZSA9IE1hdGguY2xhbXAoKHggLSAxNSkgLyAod2lkZ2V0X3dpZHRoIC0gMzApLCAwLCAxKTtcblx0XHRcdFx0XHR3LnZhbHVlID0gdy5vcHRpb25zLm1pbiArICh3Lm9wdGlvbnMubWF4IC0gdy5vcHRpb25zLm1pbikgKiBudmFsdWU7XG5cdFx0XHRcdFx0aWYgKHcuY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlubmVyX3ZhbHVlX2NoYW5nZSh3LCB3LnZhbHVlKTtcblx0XHRcdFx0XHRcdH0sIDIwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibnVtYmVyXCI6XG5cdFx0XHRcdGNhc2UgXCJjb21ib1wiOlxuXHRcdFx0XHRcdHZhciBvbGRfdmFsdWUgPSB3LnZhbHVlO1xuXHRcdFx0XHRcdGlmIChldmVudC50eXBlID09IFwibW91c2Vtb3ZlXCIgJiYgdy50eXBlID09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdHcudmFsdWUgKz0gZXZlbnQuZGVsdGFYICogMC4xICogKHcub3B0aW9ucy5zdGVwIHx8IDEpO1xuXHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWluICE9IG51bGwgJiYgdy52YWx1ZSA8IHcub3B0aW9ucy5taW4gKSB7XG5cdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWluO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWF4ICE9IG51bGwgJiYgdy52YWx1ZSA+IHcub3B0aW9ucy5tYXggKSB7XG5cdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWF4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdy5vcHRpb25zLnZhbHVlcztcblx0XHRcdFx0XHRcdGlmICh2YWx1ZXMgJiYgdmFsdWVzLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMgPSB3Lm9wdGlvbnMudmFsdWVzKHcsIG5vZGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlc19saXN0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYoIHcudHlwZSAhPSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZXNfbGlzdCA9IHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyB2YWx1ZXMgOiBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVsdGEgPSB4IDwgNDAgPyAtMSA6IHggPiB3aWRnZXRfd2lkdGggLSA0MCA/IDEgOiAwO1xuXHRcdFx0XHRcdFx0aWYgKHcudHlwZSA9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHRcdHcudmFsdWUgKz0gZGVsdGEgKiAwLjEgKiAody5vcHRpb25zLnN0ZXAgfHwgMSk7XG5cdFx0XHRcdFx0XHRcdGlmICggdy5vcHRpb25zLm1pbiAhPSBudWxsICYmIHcudmFsdWUgPCB3Lm9wdGlvbnMubWluICkge1xuXHRcdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWluO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggdy5vcHRpb25zLm1heCAhPSBudWxsICYmIHcudmFsdWUgPiB3Lm9wdGlvbnMubWF4ICkge1xuXHRcdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWF4O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGRlbHRhKSB7IC8vY2xpY2tlZCBpbiBhcnJvdywgdXNlZCBmb3IgY29tYm9zIFxuXHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdFx0XHRcdFx0dGhpcy5sYXN0X21vdXNlY2xpY2sgPSAwOyAvL2F2b2lkcyBkb2JsIGNsaWNrIGV2ZW50XG5cdFx0XHRcdFx0XHRcdGlmKHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gdmFsdWVzX2xpc3QuaW5kZXhPZiggU3RyaW5nKCB3LnZhbHVlICkgKSArIGRlbHRhO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSB2YWx1ZXNfbGlzdC5pbmRleE9mKCB3LnZhbHVlICkgKyBkZWx0YTtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID49IHZhbHVlc19saXN0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gdmFsdWVzX2xpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoaW5kZXggPCAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKCB2YWx1ZXMuY29uc3RydWN0b3IgPT09IEFycmF5IClcblx0XHRcdFx0XHRcdFx0XHR3LnZhbHVlID0gdmFsdWVzW2luZGV4XTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdHcudmFsdWUgPSBpbmRleDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vY29tYm8gY2xpY2tlZCBcblx0XHRcdFx0XHRcdFx0dmFyIHRleHRfdmFsdWVzID0gdmFsdWVzICE9IHZhbHVlc19saXN0ID8gT2JqZWN0LnZhbHVlcyh2YWx1ZXMpIDogdmFsdWVzO1xuXHRcdFx0XHRcdFx0XHR2YXIgbWVudSA9IG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUodGV4dF92YWx1ZXMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNjYWxlOiBNYXRoLm1heCgxLCB0aGlzLmRzLnNjYWxlKSxcblx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50OiBldmVudCxcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZTogXCJkYXJrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjazogaW5uZXJfY2xpY2tlZC5iaW5kKHcpXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRyZWZfd2luZG93KTtcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBvcHRpb24sIGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFsdWVzICE9IHZhbHVlc19saXN0KVxuXHRcdFx0XHRcdFx0XHRcdFx0diA9IHRleHRfdmFsdWVzLmluZGV4T2Yodik7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHY7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJfdmFsdWVfY2hhbmdlKHRoaXMsIHYpO1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IC8vZW5kIG1vdXNlZG93blxuXHRcdFx0XHRcdGVsc2UgaWYoZXZlbnQudHlwZSA9PSBcIm1vdXNldXBcIiAmJiB3LnR5cGUgPT0gXCJudW1iZXJcIilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgZGVsdGEgPSB4IDwgNDAgPyAtMSA6IHggPiB3aWRnZXRfd2lkdGggLSA0MCA/IDEgOiAwO1xuXHRcdFx0XHRcdFx0aWYgKGV2ZW50LmNsaWNrX3RpbWUgPCAyMDAgJiYgZGVsdGEgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnByb21wdChcIlZhbHVlXCIsdy52YWx1ZSxmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gTnVtYmVyKHYpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5uZXJfdmFsdWVfY2hhbmdlKHRoaXMsIHRoaXMudmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdH0uYmluZCh3KSxcblx0XHRcdFx0XHRcdFx0XHRldmVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIG9sZF92YWx1ZSAhPSB3LnZhbHVlIClcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoXG5cdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVyX3ZhbHVlX2NoYW5nZSh0aGlzLCB0aGlzLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fS5iaW5kKHcpLFxuXHRcdFx0XHRcdFx0XHQyMFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJ0b2dnbGVcIjpcblx0XHRcdFx0XHRpZiAoZXZlbnQudHlwZSA9PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHRcdFx0XHR3LnZhbHVlID0gIXcudmFsdWU7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpbm5lcl92YWx1ZV9jaGFuZ2Uodywgdy52YWx1ZSk7XG5cdFx0XHRcdFx0XHR9LCAyMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRcdGNhc2UgXCJ0ZXh0XCI6XG5cdFx0XHRcdFx0aWYgKGV2ZW50LnR5cGUgPT0gXCJtb3VzZWRvd25cIikge1xuXHRcdFx0XHRcdFx0dGhpcy5wcm9tcHQoXCJWYWx1ZVwiLHcudmFsdWUsZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2O1xuXHRcdFx0XHRcdFx0XHRcdGlubmVyX3ZhbHVlX2NoYW5nZSh0aGlzLCB2KTtcblx0XHRcdFx0XHRcdFx0fS5iaW5kKHcpLFxuXHRcdFx0XHRcdFx0XHRldmVudCx3Lm9wdGlvbnMgPyB3Lm9wdGlvbnMubXVsdGlsaW5lIDogZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKHcubW91c2UpIHtcblx0XHRcdFx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdy5tb3VzZShldmVudCwgW3gsIHldLCBub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IC8vZW5kIHN3aXRjaFxuXG5cdFx0XHQvL3ZhbHVlIGNoYW5nZWRcblx0XHRcdGlmKCBvbGRfdmFsdWUgIT0gdy52YWx1ZSApXG5cdFx0XHR7XG5cdFx0XHRcdGlmKG5vZGUub25XaWRnZXRDaGFuZ2VkKVxuXHRcdFx0XHRcdG5vZGUub25XaWRnZXRDaGFuZ2VkKCB3Lm5hbWUsdy52YWx1ZSxvbGRfdmFsdWUsdyApO1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JhcGguX3ZlcnNpb24rKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHc7XG4gICAgICAgIH0vL2VuZCBmb3JcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl92YWx1ZV9jaGFuZ2Uod2lkZ2V0LCB2YWx1ZSkge1xuICAgICAgICAgICAgd2lkZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIHdpZGdldC5vcHRpb25zICYmIHdpZGdldC5vcHRpb25zLnByb3BlcnR5ICYmIG5vZGUucHJvcGVydGllc1t3aWRnZXQub3B0aW9ucy5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldFByb3BlcnR5KCB3aWRnZXQub3B0aW9ucy5wcm9wZXJ0eSwgdmFsdWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWRnZXQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB3aWRnZXQuY2FsbGJhY2sod2lkZ2V0LnZhbHVlLCB0aGF0LCBub2RlLCBwb3MsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBldmVyeSBncm91cCBhcmVhIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICogQG1ldGhvZCBkcmF3R3JvdXBzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0dyb3VwcyA9IGZ1bmN0aW9uKGNhbnZhcywgY3R4KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JhcGguX2dyb3VwcztcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjUgKiB0aGlzLmVkaXRvcl9hbHBoYTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXBCb3VuZGluZyh0aGlzLnZpc2libGVfYXJlYSwgZ3JvdXAuX2JvdW5kaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvL291dCBvZiB0aGUgdmlzaWJsZSBhcmVhXG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncm91cC5jb2xvciB8fCBcIiMzMzVcIjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdyb3VwLmNvbG9yIHx8IFwiIzMzNVwiO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGdyb3VwLl9wb3M7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGdyb3VwLl9zaXplO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4yNSAqIHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdICsgMC41LCBwb3NbMV0gKyAwLjUsIHNpemVbMF0sIHNpemVbMV0pO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHBvc1swXSArIHNpemVbMF0sIHBvc1sxXSArIHNpemVbMV0pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb3NbMF0gKyBzaXplWzBdIC0gMTAsIHBvc1sxXSArIHNpemVbMV0pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb3NbMF0gKyBzaXplWzBdLCBwb3NbMV0gKyBzaXplWzFdIC0gMTApO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgdmFyIGZvbnRfc2l6ZSA9XG4gICAgICAgICAgICAgICAgZ3JvdXAuZm9udF9zaXplIHx8IExpdGVHcmFwaC5ERUZBVUxUX0dST1VQX0ZPTlRfU0laRTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udF9zaXplICsgXCJweCBBcmlhbFwiO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGdyb3VwLnRpdGxlLCBwb3NbMF0gKyA0LCBwb3NbMV0gKyBmb250X3NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5hZGp1c3ROb2Rlc1NpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ncmFwaC5fbm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5vZGVzW2ldLnNpemUgPSBub2Rlc1tpXS5jb21wdXRlU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlc2l6ZXMgdGhlIGNhbnZhcyB0byBhIGdpdmVuIHNpemUsIGlmIG5vIHNpemUgaXMgcGFzc2VkLCB0aGVuIGl0IHRyaWVzIHRvIGZpbGwgdGhlIHBhcmVudE5vZGVcbiAgICAgKiBAbWV0aG9kIHJlc2l6ZVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5jYW52YXMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy53aWR0aCA9PSB3aWR0aCAmJiB0aGlzLmNhbnZhcy5oZWlnaHQgPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuYmdjYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgdGhpcy5iZ2NhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHN3aXRjaGVzIHRvIGxpdmUgbW9kZSAobm9kZSBzaGFwZXMgYXJlIG5vdCByZW5kZXJlZCwgb25seSB0aGUgY29udGVudClcbiAgICAgKiB0aGlzIGZlYXR1cmUgd2FzIGRlc2lnbmVkIHdoZW4gZ3JhcGhzIHdoZXJlIG1lYW50IHRvIGNyZWF0ZSB1c2VyIGludGVyZmFjZXNcbiAgICAgKiBAbWV0aG9kIHN3aXRjaExpdmVNb2RlXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc3dpdGNoTGl2ZU1vZGUgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saXZlX21vZGUgPSAhdGhpcy5saXZlX21vZGU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5saXZlX21vZGUgPyAxLjEgOiAwLjk7XG4gICAgICAgIGlmICh0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgdGhpcy5saXZlX21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yX2FscGhhID0gMC4xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yX2FscGhhICo9IGRlbHRhO1xuICAgICAgICAgICAgc2VsZi5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDEgJiYgc2VsZi5lZGl0b3JfYWxwaGEgPCAwLjAxKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGl2ZV9tb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAxICYmIHNlbGYuZWRpdG9yX2FscGhhID4gMC45OSkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodCk7XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3JfYWxwaGEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5vbk5vZGVTZWxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybjsgLy9kaXNhYmxlZFxuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vYWxlcnQoXCJmb29cIik7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgICAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICB0eXBlID0gXCJcIjtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwibW91c2Vkb3duXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwibW91c2Vtb3ZlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidG91Y2hlbmRcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJtb3VzZXVwXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaW5pdE1vdXNlRXZlbnQodHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlLCB2aWV3LCBjbGlja0NvdW50LFxuICAgICAgICAvLyAgICAgICAgICAgc2NyZWVuWCwgc2NyZWVuWSwgY2xpZW50WCwgY2xpZW50WSwgY3RybEtleSxcbiAgICAgICAgLy8gICAgICAgICAgIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksIGJ1dHRvbiwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICB2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGZpcnN0LnNjcmVlblgsXG4gICAgICAgICAgICBmaXJzdC5zY3JlZW5ZLFxuICAgICAgICAgICAgZmlyc3QuY2xpZW50WCxcbiAgICAgICAgICAgIGZpcnN0LmNsaWVudFksXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIDAgLypsZWZ0Ki8sXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICAgIGZpcnN0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgLyogQ09OVEVYVCBNRU5VICoqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uR3JvdXBBZGQgPSBmdW5jdGlvbihpbmZvLCBlbnRyeSwgbW91c2VfZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcblxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgTGl0ZUdyYXBoLkxHcmFwaEdyb3VwKCk7XG4gICAgICAgIGdyb3VwLnBvcyA9IGNhbnZhcy5jb252ZXJ0RXZlbnRUb0NhbnZhc09mZnNldChtb3VzZV9ldmVudCk7XG4gICAgICAgIGNhbnZhcy5ncmFwaC5hZGQoZ3JvdXApO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51QWRkID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMsIGUsIHByZXZfbWVudSwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuICAgICAgICB2YXIgZ3JhcGggPSBjYW52YXMuZ3JhcGg7XG4gICAgICAgIGlmICghZ3JhcGgpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb25NZW51QWRkZWQoYmFzZV9jYXRlZ29yeSAscHJldl9tZW51KXtcbiAgICBcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzICA9IExpdGVHcmFwaC5nZXROb2RlVHlwZXNDYXRlZ29yaWVzKGNhbnZhcy5maWx0ZXIgfHwgZ3JhcGguZmlsdGVyKS5maWx0ZXIoZnVuY3Rpb24oY2F0ZWdvcnkpe3JldHVybiBjYXRlZ29yeS5zdGFydHNXaXRoKGJhc2VfY2F0ZWdvcnkpfSk7XG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIFxuICAgICAgICAgICAgY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24oY2F0ZWdvcnkpe1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICghY2F0ZWdvcnkpIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VfY2F0ZWdvcnlfcmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBiYXNlX2NhdGVnb3J5ICsgJyknKTtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlfbmFtZSA9IGNhdGVnb3J5LnJlcGxhY2UoYmFzZV9jYXRlZ29yeV9yZWdleCxcIlwiKS5zcGxpdCgnLycpWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeV9wYXRoID0gYmFzZV9jYXRlZ29yeSAgPT09ICcnID8gY2F0ZWdvcnlfbmFtZSArICcvJyA6IGJhc2VfY2F0ZWdvcnkgKyBjYXRlZ29yeV9uYW1lICsgJy8nO1xuICAgIFxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY2F0ZWdvcnlfbmFtZTtcbiAgICAgICAgICAgICAgICBpZihuYW1lLmluZGV4T2YoXCI6OlwiKSAhPSAtMSkgLy9pbiBjYXNlIGl0IGhhcyBhIG5hbWVzcGFjZSBsaWtlIFwic2hhZGVyOjptYXRoL3JhbmRcIiBpdCBoaWRlcyB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KFwiOjpcIilbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbihlbnRyeSl7cmV0dXJuIGVudHJ5LnZhbHVlID09PSBjYXRlZ29yeV9wYXRofSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyB2YWx1ZTogY2F0ZWdvcnlfcGF0aCwgY29udGVudDogbmFtZSwgaGFzX3N1Ym1lbnU6IHRydWUsIGNhbGxiYWNrIDogZnVuY3Rpb24odmFsdWUsIGV2ZW50LCBtb3VzZUV2ZW50LCBjb250ZXh0TWVudSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lcl9vbk1lbnVBZGRlZCh2YWx1ZS52YWx1ZSwgY29udGV4dE1lbnUpXG4gICAgICAgICAgICAgICAgICAgIH19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIHZhciBub2RlcyA9IExpdGVHcmFwaC5nZXROb2RlVHlwZXNJbkNhdGVnb3J5KGJhc2VfY2F0ZWdvcnkuc2xpY2UoMCwgLTEpLCBjYW52YXMuZmlsdGVyIHx8IGdyYXBoLmZpbHRlciApO1xuICAgICAgICAgICAgbm9kZXMubWFwKGZ1bmN0aW9uKG5vZGUpe1xuICAgIFxuICAgICAgICAgICAgICAgIGlmIChub2RlLnNraXBfbGlzdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHsgdmFsdWU6IG5vZGUudHlwZSwgY29udGVudDogbm9kZS50aXRsZSwgaGFzX3N1Ym1lbnU6IGZhbHNlICwgY2FsbGJhY2sgOiBmdW5jdGlvbih2YWx1ZSwgZXZlbnQsIG1vdXNlRXZlbnQsIGNvbnRleHRNZW51KXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RfZXZlbnQgPSBjb250ZXh0TWVudS5nZXRGaXJzdEV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBjYW52YXMuY29udmVydEV2ZW50VG9DYW52YXNPZmZzZXQoZmlyc3RfZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KCBlbnRyaWVzLCB7IGV2ZW50OiBlLCBwYXJlbnRNZW51OiBwcmV2X21lbnUgfSwgcmVmX3dpbmRvdyApO1xuICAgIFxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlubmVyX29uTWVudUFkZGVkKCcnLHByZXZfbWVudSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudUNvbGxhcHNlQWxsID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlRWRpdCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxJbnB1dHMgPSBmdW5jdGlvbihcbiAgICAgICAgdixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZSxcbiAgICAgICAgcHJldl9tZW51LFxuICAgICAgICBub2RlXG4gICAgKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25hbF9pbnB1dHM7XG4gICAgICAgIGlmIChub2RlLm9uR2V0SW5wdXRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbm9kZS5vbkdldElucHV0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZW50cnlbMF07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzJdICYmIGVudHJ5WzJdLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZW50cnlbMl0ubGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0geyBjb250ZW50OiBsYWJlbCwgdmFsdWU6IGVudHJ5IH07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzFdID09IExpdGVHcmFwaC5BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jbGFzc05hbWUgPSBcImV2ZW50XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uTWVudU5vZGVJbnB1dHMpIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSB0aGlzLm9uTWVudU5vZGVJbnB1dHMoZW50cmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIm5vIGlucHV0IGVudHJpZXNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVudSA9IG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUoXG4gICAgICAgICAgICBlbnRyaWVzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgICAgIHBhcmVudE1lbnU6IHByZXZfbWVudSxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmX3dpbmRvd1xuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodiwgZSwgcHJldikge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHYuY2FsbGJhY2suY2FsbCh0aGF0LCBub2RlLCB2LCBlLCBwcmV2KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYudmFsdWUpIHtcblx0XHRcdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZElucHV0KHYudmFsdWVbMF0sIHYudmFsdWVbMV0sIHYudmFsdWVbMl0pO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnNob3dNZW51Tm9kZU9wdGlvbmFsT3V0cHV0cyA9IGZ1bmN0aW9uKFxuICAgICAgICB2LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBlLFxuICAgICAgICBwcmV2X21lbnUsXG4gICAgICAgIG5vZGVcbiAgICApIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBjYW52YXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBub2RlLm9wdGlvbmFsX291dHB1dHM7XG4gICAgICAgIGlmIChub2RlLm9uR2V0T3V0cHV0cykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG5vZGUub25HZXRPdXRwdXRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAvL3NlcGFyYXRvcj9cbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5mbGFncy5za2lwX3JlcGVhdGVkX291dHB1dHMgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5maW5kT3V0cHV0U2xvdChlbnRyeVswXSkgIT0gLTFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSAvL3NraXAgdGhlIG9uZXMgYWxyZWFkeSBvblxuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGVudHJ5WzBdO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeVsyXSAmJiBlbnRyeVsyXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGVudHJ5WzJdLmxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHsgY29udGVudDogbGFiZWwsIHZhbHVlOiBlbnRyeSB9O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeVsxXSA9PSBMaXRlR3JhcGguRVZFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jbGFzc05hbWUgPSBcImV2ZW50XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uTWVudU5vZGVPdXRwdXRzKSB7XG4gICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5vbk1lbnVOb2RlT3V0cHV0cyhlbnRyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZfd2luZG93XG4gICAgICAgICk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBlLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdi5jYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsIHYsIGUsIHByZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHYudmFsdWVbMV07XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vc3VibWVudSB3aHk/XG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGNvbnRlbnQ6IGksIHZhbHVlOiB2YWx1ZVtpXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShlbnRyaWVzLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZE91dHB1dCh2LnZhbHVlWzBdLCB2LnZhbHVlWzFdLCB2LnZhbHVlWzJdKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuXHRcdFx0XHRub2RlLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vblNob3dNZW51Tm9kZVByb3BlcnRpZXMgPSBmdW5jdGlvbihcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGUsXG4gICAgICAgIHByZXZfbWVudSxcbiAgICAgICAgbm9kZVxuICAgICkge1xuICAgICAgICBpZiAoIW5vZGUgfHwgIW5vZGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuXG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnByb3BlcnRpZXNbaV0gIT09IHVuZGVmaW5lZCA/IG5vZGUucHJvcGVydGllc1tpXSA6IFwiIFwiO1xuXHRcdFx0aWYoIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiIClcblx0XHRcdFx0dmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHR2YXIgaW5mbyA9IG5vZGUuZ2V0UHJvcGVydHlJbmZvKGkpO1xuXHRcdFx0aWYoaW5mby50eXBlID09IFwiZW51bVwiIHx8IGluZm8udHlwZSA9PSBcImNvbWJvXCIpXG5cdFx0XHRcdHZhbHVlID0gTEdyYXBoQ2FudmFzLmdldFByb3BlcnR5UHJpbnRhYmxlVmFsdWUoIHZhbHVlLCBpbmZvLnZhbHVlcyApO1xuXG4gICAgICAgICAgICAvL3ZhbHVlIGNvdWxkIGNvbnRhaW4gaW52YWxpZCBodG1sIGNoYXJhY3RlcnMsIGNsZWFuIHRoYXRcbiAgICAgICAgICAgIHZhbHVlID0gTEdyYXBoQ2FudmFzLmRlY29kZUhUTUwodmFsdWUpO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OlxuICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdwcm9wZXJ0eV9uYW1lJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIChpbmZvLmxhYmVsID8gaW5mby5sYWJlbCA6IGkpICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdwcm9wZXJ0eV92YWx1ZSc+XCIgK1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVudSA9IG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUoXG4gICAgICAgICAgICBlbnRyaWVzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgICAgIHBhcmVudE1lbnU6IHByZXZfbWVudSxcbiAgICAgICAgICAgICAgICBhbGxvd19odG1sOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZfd2luZG93XG4gICAgICAgICk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBvcHRpb25zLCBlLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjYW52YXMuc2hvd0VkaXRQcm9wZXJ0eVZhbHVlKG5vZGUsIHYudmFsdWUsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogW3JlY3QubGVmdCwgcmVjdC50b3BdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLmRlY29kZUhUTUwgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlLmlubmVyVGV4dCA9IHN0cjtcbiAgICAgICAgcmV0dXJuIGUuaW5uZXJIVE1MO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25SZXNpemVOb2RlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zaXplID0gbm9kZS5jb21wdXRlU2l6ZSgpO1xuICAgICAgICBpZiAobm9kZS5vblJlc2l6ZSlcbiAgICAgICAgICAgIG5vZGUub25SZXNpemUobm9kZS5zaXplKTtcbiAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zaG93TGlua01lbnUgPSBmdW5jdGlvbihsaW5rLCBlKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0XHRjb25zb2xlLmxvZyhsaW5rKTtcblx0XHR2YXIgb3B0aW9ucyA9IFtcIkFkZCBOb2RlXCIsbnVsbCxcIkRlbGV0ZVwiXTtcbiAgICAgICAgdmFyIG1lbnUgPSBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGV2ZW50OiBlLFxuXHRcdFx0dGl0bGU6IGxpbmsuZGF0YSAhPSBudWxsID8gbGluay5kYXRhLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LG9wdGlvbnMsZSkge1xuICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFkZCBOb2RlXCI6XG5cdFx0XHRcdFx0TEdyYXBoQ2FudmFzLm9uTWVudUFkZChudWxsLCBudWxsLCBlLCBtZW51LCBmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwibm9kZSBhdXRvY29ubmVjdFwiKTtcblx0XHRcdFx0XHRcdHZhciBub2RlX2xlZnQgPSB0aGF0LmdyYXBoLmdldE5vZGVCeUlkKCBsaW5rLm9yaWdpbl9pZCApO1xuXHRcdFx0XHRcdFx0dmFyIG5vZGVfcmlnaHQgPSB0aGF0LmdyYXBoLmdldE5vZGVCeUlkKCBsaW5rLnRhcmdldF9pZCApO1xuXHRcdFx0XHRcdFx0aWYoIW5vZGUuaW5wdXRzIHx8ICFub2RlLmlucHV0cy5sZW5ndGggfHwgIW5vZGUub3V0cHV0cyB8fCAhbm9kZS5vdXRwdXRzLmxlbmd0aClcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0aWYoIG5vZGVfbGVmdC5vdXRwdXRzWyBsaW5rLm9yaWdpbl9zbG90IF0udHlwZSA9PSBub2RlLmlucHV0c1swXS50eXBlICYmIG5vZGUub3V0cHV0c1swXS50eXBlID09IG5vZGVfcmlnaHQuaW5wdXRzWzBdLnR5cGUgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRub2RlX2xlZnQuY29ubmVjdCggbGluay5vcmlnaW5fc2xvdCwgbm9kZSwgMCApO1xuXHRcdFx0XHRcdFx0XHRub2RlLmNvbm5lY3QoIDAsIG5vZGVfcmlnaHQsIGxpbmsudGFyZ2V0X3Nsb3QgKTtcblx0XHRcdFx0XHRcdFx0bm9kZS5wb3NbMF0gLT0gbm9kZS5zaXplWzBdICogMC41O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJEZWxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ncmFwaC5yZW1vdmVMaW5rKGxpbmsuaWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25TaG93UHJvcGVydHlFZGl0b3IgPSBmdW5jdGlvbihpdGVtLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIHZhciBpbnB1dF9odG1sID0gXCJcIjtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gaXRlbS5wcm9wZXJ0eSB8fCBcInRpdGxlXCI7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGVbcHJvcGVydHldO1xuXG4gICAgICAgIHZhciBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaWFsb2cuY2xhc3NOYW1lID0gXCJncmFwaGRpYWxvZ1wiO1xuICAgICAgICBkaWFsb2cuaW5uZXJIVE1MID0gXCI8c3BhbiBjbGFzcz0nbmFtZSc+PC9zcGFuPjxpbnB1dCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcgY2xhc3M9J3ZhbHVlJy8+PGJ1dHRvbj5PSzwvYnV0dG9uPlwiO1xuXHRcdC8vZGlhbG9nLmlubmVySFRNTCA9IFwiPHNwYW4gY2xhc3M9J25hbWUnPjwvc3Bhbj48dGV4dGFyZWEgYXV0b2ZvY3VzIGNsYXNzPSd2YWx1ZSc+PC90ZXh0YXJlYT48YnV0dG9uPk9LPC9idXR0b24+XCI7XG4gICAgICAgIHZhciB0aXRsZSA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIik7XG4gICAgICAgIHRpdGxlLmlubmVyVGV4dCA9IHByb3BlcnR5O1xuICAgICAgICB2YXIgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcIi52YWx1ZVwiKTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgIT0gMTMgJiYgZS50YXJnZXQubG9jYWxOYW1lICE9IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlubmVyKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgY2FudmFzID0gZ3JhcGhjYW52YXMuY2FudmFzO1xuXG4gICAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb2Zmc2V0eCA9IC0yMDtcbiAgICAgICAgdmFyIG9mZnNldHkgPSAtMjA7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICBvZmZzZXR4IC09IHJlY3QubGVmdDtcbiAgICAgICAgICAgIG9mZnNldHkgLT0gcmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gZXZlbnQuY2xpZW50WCArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gZXZlbnQuY2xpZW50WSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGNhbnZhcy53aWR0aCAqIDAuNSArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gY2FudmFzLmhlaWdodCAqIDAuNSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnV0dG9uID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIik7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW5uZXIpO1xuICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgICAgICAgICAgc2V0VmFsdWUoaW5wdXQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT0gXCJOdW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09IFwiQm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoZGlhbG9nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaWFsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb21wdCA9IGZ1bmN0aW9uKHRpdGxlLCB2YWx1ZSwgY2FsbGJhY2ssIGV2ZW50LCBtdWx0aWxpbmUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgaW5wdXRfaHRtbCA9IFwiXCI7XG4gICAgICAgIHRpdGxlID0gdGl0bGUgfHwgXCJcIjtcblxuICAgICAgICB2YXIgbW9kaWZpZWQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGlhbG9nLmNsYXNzTmFtZSA9IFwiZ3JhcGhkaWFsb2cgcm91bmRlZFwiO1xuXHRcdGlmKG11bHRpbGluZSlcblx0ICAgICAgICBkaWFsb2cuaW5uZXJIVE1MID0gXCI8c3BhbiBjbGFzcz0nbmFtZSc+PC9zcGFuPiA8dGV4dGFyZWEgYXV0b2ZvY3VzIGNsYXNzPSd2YWx1ZSc+PC90ZXh0YXJlYT48YnV0dG9uIGNsYXNzPSdyb3VuZGVkJz5PSzwvYnV0dG9uPlwiO1xuXHRcdGVsc2Vcblx0ICAgICAgICBkaWFsb2cuaW5uZXJIVE1MID0gXCI8c3BhbiBjbGFzcz0nbmFtZSc+PC9zcGFuPiA8aW5wdXQgYXV0b2ZvY3VzIHR5cGU9J3RleHQnIGNsYXNzPSd2YWx1ZScvPjxidXR0b24gY2xhc3M9J3JvdW5kZWQnPk9LPC9idXR0b24+XCI7XG4gICAgICAgIGRpYWxvZy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5wcm9tcHRfYm94ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChkaWFsb2cucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuZHMuc2NhbGUgPiAxKSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZShcIiArIHRoaXMuZHMuc2NhbGUgKyBcIilcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIW1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGF0LnByb21wdF9ib3gpIHtcbiAgICAgICAgICAgIHRoYXQucHJvbXB0X2JveC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQucHJvbXB0X2JveCA9IGRpYWxvZztcblxuICAgICAgICB2YXIgZmlyc3QgPSBudWxsO1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIG5hbWVfZWxlbWVudCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIik7XG4gICAgICAgIG5hbWVfZWxlbWVudC5pbm5lclRleHQgPSB0aXRsZTtcbiAgICAgICAgdmFyIHZhbHVlX2VsZW1lbnQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcIi52YWx1ZVwiKTtcbiAgICAgICAgdmFsdWVfZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IHZhbHVlX2VsZW1lbnQ7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgICAgICAgICAgICAvL0VTQ1xuICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQubG9jYWxOYW1lICE9IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBidXR0b24gPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0LnNldERpcnR5KHRydWUpO1xuICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgY2FudmFzID0gZ3JhcGhjYW52YXMuY2FudmFzO1xuXG4gICAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb2Zmc2V0eCA9IC0yMDtcbiAgICAgICAgdmFyIG9mZnNldHkgPSAtMjA7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICBvZmZzZXR4IC09IHJlY3QubGVmdDtcbiAgICAgICAgICAgIG9mZnNldHkgLT0gcmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gZXZlbnQuY2xpZW50WCArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gZXZlbnQuY2xpZW50WSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGNhbnZhcy53aWR0aCAqIDAuNSArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gY2FudmFzLmhlaWdodCAqIDAuNSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkaWFsb2cpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSwgMTApO1xuXG4gICAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5zZWFyY2hfbGltaXQgPSAtMTtcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNob3dTZWFyY2hCb3ggPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBpbnB1dF9odG1sID0gXCJcIjtcbiAgICAgICAgdmFyIGdyYXBoY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBncmFwaGNhbnZhcy5jYW52YXM7XG4gICAgICAgIHZhciByb290X2RvY3VtZW50ID0gY2FudmFzLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgdmFyIGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcImxpdGVncmFwaCBsaXRlc2VhcmNoYm94IGdyYXBoZGlhbG9nIHJvdW5kZWRcIjtcbiAgICAgICAgZGlhbG9nLmlubmVySFRNTCA9XG4gICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSduYW1lJz5TZWFyY2g8L3NwYW4+IDxpbnB1dCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcgY2xhc3M9J3ZhbHVlIHJvdW5kZWQnLz48ZGl2IGNsYXNzPSdoZWxwZXInPjwvZGl2PlwiO1xuICAgICAgICBkaWFsb2cuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuc2VhcmNoX2JveCA9IG51bGw7XG4gICAgICAgICAgICByb290X2RvY3VtZW50LmJvZHkuZm9jdXMoKTtcblx0XHRcdHJvb3RfZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiXCI7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDIwKTsgLy9pbXBvcnRhbnQsIGlmIGNhbnZhcyBsb3NlcyBmb2N1cyBrZXlzIHdvbnQgYmUgY2FwdHVyZWRcbiAgICAgICAgICAgIGlmIChkaWFsb2cucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRpbWVvdXRfY2xvc2UgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmRzLnNjYWxlID4gMSkge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyB0aGlzLmRzLnNjYWxlICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICBkaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRfY2xvc2UpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dF9jbG9zZSk7XG4gICAgICAgICAgICAgICAgdGltZW91dF9jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvL2RpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgdGltZW91dF9jbG9zZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhhdC5zZWFyY2hfYm94KSB7XG4gICAgICAgICAgICB0aGF0LnNlYXJjaF9ib3guY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LnNlYXJjaF9ib3ggPSBkaWFsb2c7XG5cbiAgICAgICAgdmFyIGhlbHBlciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLmhlbHBlclwiKTtcblxuICAgICAgICB2YXIgZmlyc3QgPSBudWxsO1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAzOCkge1xuICAgICAgICAgICAgICAgICAgICAvL1VQXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNlbGVjdGlvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ET1dOXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAvL0VTQ1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdChzZWxlY3RlZC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QoZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZWZyZXNoSGVscGVyLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXHRcdGlmKCByb290X2RvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IClcblx0ICAgICAgICByb290X2RvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHQgICAgcm9vdF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cdFx0XHRyb290X2RvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdH1cblxuICAgICAgICAvL2NvbXB1dGUgYmVzdCBwb3NpdGlvblxuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB2YXIgbGVmdCA9ICggZXZlbnQgPyBldmVudC5jbGllbnRYIDogKHJlY3QubGVmdCArIHJlY3Qud2lkdGggKiAwLjUpICkgLSA4MDtcbiAgICAgICAgdmFyIHRvcCA9ICggZXZlbnQgPyBldmVudC5jbGllbnRZIDogKHJlY3QudG9wICsgcmVjdC5oZWlnaHQgKiAwLjUpICkgLSAyMDtcbiAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuXG5cdFx0Ly9UbyBhdm9pZCBvdXQgb2Ygc2NyZWVuIHByb2JsZW1zXG5cdFx0aWYoZXZlbnQubGF5ZXJZID4gKHJlY3QuaGVpZ2h0IC0gMjAwKSkgXG4gICAgICAgICAgICBoZWxwZXIuc3R5bGUubWF4SGVpZ2h0ID0gKHJlY3QuaGVpZ2h0IC0gZXZlbnQubGF5ZXJZIC0gMjApICsgXCJweFwiO1xuXG5cdFx0LypcbiAgICAgICAgdmFyIG9mZnNldHggPSAtMjA7XG4gICAgICAgIHZhciBvZmZzZXR5ID0gLTIwO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgb2Zmc2V0eCAtPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBvZmZzZXR5IC09IHJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGV2ZW50LmNsaWVudFggKyBvZmZzZXR4ICsgXCJweFwiO1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IGV2ZW50LmNsaWVudFkgKyBvZmZzZXR5ICsgXCJweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBjYW52YXMud2lkdGggKiAwLjUgKyBvZmZzZXR4ICsgXCJweFwiO1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IGNhbnZhcy5oZWlnaHQgKiAwLjUgKyBvZmZzZXR5ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cdFx0Ki9cblxuICAgICAgICBpbnB1dC5mb2N1cygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdChuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9uU2VhcmNoQm94U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQub25TZWFyY2hCb3hTZWxlY3Rpb24obmFtZSwgZXZlbnQsIGdyYXBoY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmEgPSBMaXRlR3JhcGguc2VhcmNoYm94X2V4dHJhc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBleHRyYS50eXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cblx0XHRcdFx0XHRncmFwaGNhbnZhcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucG9zID0gZ3JhcGhjYW52YXMuY29udmVydEV2ZW50VG9DYW52YXNPZmZzZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEgJiYgZXh0cmEuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmRhdGEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZXh0cmEuZGF0YS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkUHJvcGVydHkoIGksIGV4dHJhLmRhdGEucHJvcGVydGllc1tpXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5kYXRhLmlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5wdXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYS5kYXRhLmlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZE91dHB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmRhdGEuaW5wdXRzW2ldWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZGF0YS5pbnB1dHNbaV1bMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGF0YS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vdXRwdXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYS5kYXRhLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRPdXRwdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5kYXRhLm91dHB1dHNbaV1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5kYXRhLm91dHB1dHNbaV1bMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGF0YS50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGl0bGUgPSBleHRyYS5kYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmRhdGEuanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29uZmlndXJlKGV4dHJhLmRhdGEuanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0XHRcdFx0XHRcdGdyYXBoY2FudmFzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlU2VsZWN0aW9uKGZvcndhcmQpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgID8gaGVscGVyLmNoaWxkTm9kZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgOiBoZWxwZXIuY2hpbGROb2Rlc1toZWxwZXIuY2hpbGROb2Rlcy5sZW5ndGhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RlZC5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdGVkLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWQuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgc2VsZWN0ZWQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcImVuZFwiLCBiZWhhdmlvcjogXCJzbW9vdGhcIn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaEhlbHBlcigpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHN0ciA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgaGVscGVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoYXQub25TZWFyY2hCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoYXQub25TZWFyY2hCb3goaGVscGVyLCBzdHIsIGdyYXBoY2FudmFzKTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlc3VsdChsaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgZmlsdGVyID0gZ3JhcGhjYW52YXMuZmlsdGVyIHx8IGdyYXBoY2FudmFzLmdyYXBoLmZpbHRlcjtcblxuICAgICAgICAgICAgICAgIC8vZXh0cmFzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBMaXRlR3JhcGguc2VhcmNoYm94X2V4dHJhcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmEgPSBMaXRlR3JhcGguc2VhcmNoYm94X2V4dHJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmRlc2MudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XHRcdHZhciBjdG9yID0gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1sgZXh0cmEudHlwZSBdO1xuXHRcdFx0XHRcdGlmKCBjdG9yICYmIGN0b3IuZmlsdGVyICE9IGZpbHRlciApXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVzdWx0KCBleHRyYS5kZXNjLCBcInNlYXJjaGJveF9leHRyYVwiICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCAhPT0gLTEgJiYgYysrID4gTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdHZhciBmaWx0ZXJlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHsgLy9maWx0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIExpdGVHcmFwaC5yZWdpc3RlcmVkX25vZGVfdHlwZXMgKTsgLy90eXBlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBrZXlzLmZpbHRlciggaW5uZXJfdGVzdF9maWx0ZXIgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlcykge1xuXHRcdFx0XHRcdFx0aWYoIGlubmVyX3Rlc3RfZmlsdGVyKGkpIClcblx0XHRcdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0YWRkUmVzdWx0KGZpbHRlcmVkW2ldKTtcblx0XHRcdFx0XHRpZiAoIExHcmFwaENhbnZhcy5zZWFyY2hfbGltaXQgIT09IC0xICYmIGMrKyA+IExHcmFwaENhbnZhcy5zZWFyY2hfbGltaXQgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBpbm5lcl90ZXN0X2ZpbHRlciggdHlwZSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IExpdGVHcmFwaC5yZWdpc3RlcmVkX25vZGVfdHlwZXNbIHR5cGUgXTtcblx0XHRcdFx0XHRpZihmaWx0ZXIgJiYgY3Rvci5maWx0ZXIgIT0gZmlsdGVyIClcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSAhPT0gLTE7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkUmVzdWx0KHR5cGUsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBoZWxwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVscC5pbm5lclRleHQgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGhlbHAuZGF0YXNldFtcInR5cGVcIl0gPSBlc2NhcGUodHlwZSk7XG4gICAgICAgICAgICAgICAgaGVscC5jbGFzc05hbWUgPSBcImxpdGVncmFwaCBsaXRlLXNlYXJjaC1pdGVtXCI7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwLmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVscC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodW5lc2NhcGUodGhpcy5kYXRhc2V0W1widHlwZVwiXSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhlbHBlci5hcHBlbmRDaGlsZChoZWxwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd0VkaXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oIG5vZGUsIHByb3BlcnR5LCBvcHRpb25zICkge1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbmZvID0gbm9kZS5nZXRQcm9wZXJ0eUluZm8ocHJvcGVydHkpO1xuXHRcdHZhciB0eXBlID0gaW5mby50eXBlO1xuXG4gICAgICAgIHZhciBpbnB1dF9odG1sID0gXCJcIjtcblxuICAgICAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiIHx8IHR5cGUgPT0gXCJudW1iZXJcIiB8fCB0eXBlID09IFwiYXJyYXlcIiB8fCB0eXBlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlucHV0X2h0bWwgPSBcIjxpbnB1dCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcgY2xhc3M9J3ZhbHVlJy8+XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoICh0eXBlID09IFwiZW51bVwiIHx8IHR5cGUgPT0gXCJjb21ib1wiKSAmJiBpbmZvLnZhbHVlcykge1xuICAgICAgICAgICAgaW5wdXRfaHRtbCA9IFwiPHNlbGVjdCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcgY2xhc3M9J3ZhbHVlJz5cIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gaW5mby52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGk7XG5cdFx0XHRcdGlmKCBpbmZvLnZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKVxuXHRcdFx0XHRcdHYgPSBpbmZvLnZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgIGlucHV0X2h0bWwgKz1cbiAgICAgICAgICAgICAgICAgICAgXCI8b3B0aW9uIHZhbHVlPSdcIiArXG4gICAgICAgICAgICAgICAgICAgIHYgK1xuICAgICAgICAgICAgICAgICAgICBcIicgXCIgK1xuICAgICAgICAgICAgICAgICAgICAodiA9PSBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldID8gXCJzZWxlY3RlZFwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIj5cIiArXG4gICAgICAgICAgICAgICAgICAgIGluZm8udmFsdWVzW2ldICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L29wdGlvbj5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0X2h0bWwgKz0gXCI8L3NlbGVjdD5cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBpbnB1dF9odG1sID1cbiAgICAgICAgICAgICAgICBcIjxpbnB1dCBhdXRvZm9jdXMgdHlwZT0nY2hlY2tib3gnIGNsYXNzPSd2YWx1ZScgXCIgK1xuICAgICAgICAgICAgICAgIChub2RlLnByb3BlcnRpZXNbcHJvcGVydHldID8gXCJjaGVja2VkXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAgXCIvPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuY3JlYXRlRGlhbG9nKFxuICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nbmFtZSc+XCIgK1xuICAgICAgICAgICAgICAgIChpbmZvLmxhYmVsID8gaW5mby5sYWJlbCA6IHByb3BlcnR5KSArXG4gICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIgK1xuICAgICAgICAgICAgICAgIGlucHV0X2h0bWwgK1xuICAgICAgICAgICAgICAgIFwiPGJ1dHRvbj5PSzwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICgodHlwZSA9PSBcImVudW1cIiB8fCB0eXBlID09IFwiY29tYm9cIikgJiYgaW5mby52YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwic2VsZWN0XCIpO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vdmFyIGluZGV4ID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgLy9zZXRWYWx1ZSggZS5vcHRpb25zW2Uuc2VsZWN0ZWRJbmRleF0udmFsdWUgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIik7XG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSghIWlucHV0LmNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cdFx0XHRcdHZhciB2ID0gbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkID8gbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA6IFwiXCI7XG5cdFx0XHRcdGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSAhPSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlubmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidXR0b24gPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpbm5lcik7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXIoKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShpbnB1dC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuXG5cdFx0XHRpZihpbmZvICYmIGluZm8udmFsdWVzICYmIGluZm8udmFsdWVzLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgaW5mby52YWx1ZXNbdmFsdWVdICE9IHVuZGVmaW5lZCApXG5cdFx0XHRcdHZhbHVlID0gaW5mby52YWx1ZXNbdmFsdWVdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09IFwiYXJyYXlcIiB8fCB0eXBlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG5vZGUuZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICBub2RlLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vblByb3BlcnR5Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25Qcm9wZXJ0eUNoYW5nZWQocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblx0XHRcdGlmKG9wdGlvbnMub25jbG9zZSlcblx0XHRcdFx0b3B0aW9ucy5vbmNsb3NlKCk7XG4gICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuXHRcdHJldHVybiBkaWFsb2c7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY3JlYXRlRGlhbG9nID0gZnVuY3Rpb24oaHRtbCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGlhbG9nLmNsYXNzTmFtZSA9IFwiZ3JhcGhkaWFsb2dcIjtcbiAgICAgICAgZGlhbG9nLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldHggPSAtMjA7XG4gICAgICAgIHZhciBvZmZzZXR5ID0gLTIwO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgb2Zmc2V0eCAtPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBvZmZzZXR5IC09IHJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIG9mZnNldHggKz0gb3B0aW9ucy5wb3NpdGlvblswXTtcbiAgICAgICAgICAgIG9mZnNldHkgKz0gb3B0aW9ucy5wb3NpdGlvblsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmV2ZW50KSB7XG4gICAgICAgICAgICBvZmZzZXR4ICs9IG9wdGlvbnMuZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIG9mZnNldHkgKz0gb3B0aW9ucy5ldmVudC5jbGllbnRZO1xuICAgICAgICB9IC8vY2VudGVyZWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXR4ICs9IHRoaXMuY2FudmFzLndpZHRoICogMC41O1xuICAgICAgICAgICAgb2Zmc2V0eSArPSB0aGlzLmNhbnZhcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSBvZmZzZXR5ICsgXCJweFwiO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcblxuICAgICAgICBkaWFsb2cuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICB9O1xuXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuY3JlYXRlUGFuZWwgPSBmdW5jdGlvbih0aXRsZSwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHJlZl93aW5kb3cgPSBvcHRpb25zLndpbmRvdyB8fCB3aW5kb3c7XG5cdFx0dmFyIHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdHJvb3QuY2xhc3NOYW1lID0gXCJsaXRlZ3JhcGggZGlhbG9nXCI7XG5cdFx0cm9vdC5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2RpYWxvZy1oZWFkZXInPjxzcGFuIGNsYXNzPSdkaWFsb2ctdGl0bGUnPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPSdkaWFsb2ctY29udGVudCc+PC9kaXY+PGRpdiBjbGFzcz0nZGlhbG9nLWZvb3Rlcic+PC9kaXY+XCI7XG5cdFx0cm9vdC5oZWFkZXIgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLWhlYWRlclwiKTtcblxuXHRcdGlmKG9wdGlvbnMud2lkdGgpXG5cdFx0XHRyb290LnN0eWxlLndpZHRoID0gb3B0aW9ucy53aWR0aCArIChvcHRpb25zLndpZHRoLmNvbnN0cnVjdG9yID09PSBOdW1iZXIgPyBcInB4XCIgOiBcIlwiKTtcblx0XHRpZihvcHRpb25zLmhlaWdodClcblx0XHRcdHJvb3Quc3R5bGUuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKyAob3B0aW9ucy5oZWlnaHQuY29uc3RydWN0b3IgPT09IE51bWJlciA/IFwicHhcIiA6IFwiXCIpO1xuXHRcdGlmKG9wdGlvbnMuY2xvc2FibGUpXG5cdFx0e1xuXHRcdFx0dmFyIGNsb3NlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cdFx0XHRjbG9zZS5pbm5lckhUTUwgPSBcIiYjMTAwMDU7XCI7XG5cdFx0XHRjbG9zZS5jbGFzc0xpc3QuYWRkKFwiY2xvc2VcIik7XG5cdFx0XHRjbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpe1xuXHRcdFx0XHRyb290LmNsb3NlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHJvb3QuaGVhZGVyLmFwcGVuZENoaWxkKGNsb3NlKTtcblx0XHR9XG5cdFx0cm9vdC50aXRsZV9lbGVtZW50ID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiLmRpYWxvZy10aXRsZVwiKTtcblx0XHRyb290LnRpdGxlX2VsZW1lbnQuaW5uZXJUZXh0ID0gdGl0bGU7XG5cdFx0cm9vdC5jb250ZW50ID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiLmRpYWxvZy1jb250ZW50XCIpO1xuXHRcdHJvb3QuZm9vdGVyID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiLmRpYWxvZy1mb290ZXJcIik7XG5cblx0XHRyb290LmNsb3NlID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmKHRoaXMucGFyZW50Tm9kZSlcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHJvb3QuY2xlYXIgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5jb250ZW50LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0fVxuXG5cdFx0cm9vdC5hZGRIVE1MID0gZnVuY3Rpb24oY29kZSwgY2xhc3NuYW1lLCBvbl9mb290ZXIpXG5cdFx0e1xuXHRcdFx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0aWYoY2xhc3NuYW1lKVxuXHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGNsYXNzbmFtZTtcblx0XHRcdGVsZW0uaW5uZXJIVE1MID0gY29kZTtcblx0XHRcdGlmKG9uX2Zvb3Rlcilcblx0XHRcdFx0cm9vdC5mb290ZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJvb3QuY29udGVudC5hcHBlbmRDaGlsZChlbGVtKTtcblx0XHRcdHJldHVybiBlbGVtO1xuXHRcdH1cblxuXHRcdHJvb3QuYWRkQnV0dG9uID0gZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zIClcblx0XHR7XG5cdFx0XHR2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG5cdFx0XHRlbGVtLmlubmVyVGV4dCA9IG5hbWU7XG5cdFx0XHRlbGVtLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0ZWxlbS5jbGFzc0xpc3QuYWRkKFwiYnRuXCIpO1xuXHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixjYWxsYmFjayk7XG5cdFx0XHRyb290LmZvb3Rlci5hcHBlbmRDaGlsZChlbGVtKTtcblx0XHRcdHJldHVybiBlbGVtO1xuXHRcdH1cblxuXHRcdHJvb3QuYWRkU2VwYXJhdG9yID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdGVsZW0uY2xhc3NOYW1lID0gXCJzZXBhcmF0b3JcIjtcblx0XHRcdHJvb3QuY29udGVudC5hcHBlbmRDaGlsZChlbGVtKTtcblx0XHR9XG5cblx0XHRyb290LmFkZFdpZGdldCA9IGZ1bmN0aW9uKCB0eXBlLCBuYW1lLCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2sgKVxuXHRcdHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0dmFyIHN0cl92YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cdFx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYodHlwZSA9PSBcIm51bWJlclwiKVxuXHRcdFx0XHRzdHJfdmFsdWUgPSB2YWx1ZS50b0ZpeGVkKDMpO1xuXG5cdFx0XHR2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRlbGVtLmNsYXNzTmFtZSA9IFwicHJvcGVydHlcIjtcblx0XHRcdGVsZW0uaW5uZXJIVE1MID0gXCI8c3BhbiBjbGFzcz0ncHJvcGVydHlfbmFtZSc+PC9zcGFuPjxzcGFuIGNsYXNzPSdwcm9wZXJ0eV92YWx1ZSc+PC9zcGFuPlwiO1xuXHRcdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiLnByb3BlcnR5X25hbWVcIikuaW5uZXJUZXh0ID0gb3B0aW9ucy5sYWJlbCB8fCBuYW1lO1xuXHRcdFx0dmFyIHZhbHVlX2VsZW1lbnQgPSBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIucHJvcGVydHlfdmFsdWVcIik7XG5cdFx0XHR2YWx1ZV9lbGVtZW50LmlubmVyVGV4dCA9IHN0cl92YWx1ZTtcblx0XHRcdGVsZW0uZGF0YXNldFtcInByb3BlcnR5XCJdID0gbmFtZTtcblx0XHRcdGVsZW0uZGF0YXNldFtcInR5cGVcIl0gPSBvcHRpb25zLnR5cGUgfHwgdHlwZTtcblx0XHRcdGVsZW0ub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRlbGVtLnZhbHVlID0gdmFsdWU7XG5cblx0XHRcdC8vaWYoIHR5cGUgPT0gXCJjb2RlXCIgKVxuXHRcdFx0Ly9cdGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7IGlubmVyX3Nob3dDb2RlUGFkKCBub2RlLCB0aGlzLmRhdGFzZXRbXCJwcm9wZXJ0eVwiXSApOyB9KTtcblx0XHRcdGlmICh0eXBlID09IFwiYm9vbGVhblwiKVxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoXCJib29sZWFuXCIpO1xuXHRcdFx0XHRpZih2YWx1ZSlcblx0XHRcdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoXCJib29sLW9uXCIpO1xuXHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpeyBcblx0XHRcdFx0XHQvL3ZhciB2ID0gbm9kZS5wcm9wZXJ0aWVzW3RoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdXTsgXG5cdFx0XHRcdFx0Ly9ub2RlLnNldFByb3BlcnR5KHRoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdLCF2KTsgdGhpcy5pbm5lclRleHQgPSB2ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7IFxuXHRcdFx0XHRcdHZhciBwcm9wbmFtZSA9IHRoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdO1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSAhdGhpcy52YWx1ZTtcblx0XHRcdFx0XHR0aGlzLmNsYXNzTGlzdC50b2dnbGUoXCJib29sLW9uXCIpO1xuXHRcdFx0XHRcdHRoaXMucXVlcnlTZWxlY3RvcihcIi5wcm9wZXJ0eV92YWx1ZVwiKS5pbm5lclRleHQgPSB0aGlzLnZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG5cdFx0XHRcdFx0aW5uZXJDaGFuZ2UocHJvcG5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm51bWJlclwiKVxuXHRcdFx0e1xuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LnNldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiLHRydWUpO1xuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpeyBcblx0XHRcdFx0XHRpZihlLmNvZGUgPT0gXCJFbnRlclwiKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHZhbHVlX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24oKXsgXG5cdFx0XHRcdFx0dmFyIHYgPSB0aGlzLmlubmVyVGV4dDtcblx0XHRcdFx0XHR2YXIgcHJvcG5hbWUgPSB0aGlzLnBhcmVudE5vZGUuZGF0YXNldFtcInByb3BlcnR5XCJdO1xuXHRcdFx0XHRcdHZhciBwcm9wdHlwZSA9IHRoaXMucGFyZW50Tm9kZS5kYXRhc2V0W1widHlwZVwiXTtcblx0XHRcdFx0XHRpZiggcHJvcHR5cGUgPT0gXCJudW1iZXJcIilcblx0XHRcdFx0XHRcdHYgPSBOdW1iZXIodik7XG5cdFx0XHRcdFx0aW5uZXJDaGFuZ2UocHJvcG5hbWUsIHYpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGUgPT0gXCJlbnVtXCIgfHwgdHlwZSA9PSBcImNvbWJvXCIpIHtcblx0XHRcdFx0dmFyIHN0cl92YWx1ZSA9IExHcmFwaENhbnZhcy5nZXRQcm9wZXJ0eVByaW50YWJsZVZhbHVlKCB2YWx1ZSwgb3B0aW9ucy52YWx1ZXMgKTtcblx0XHRcdFx0dmFsdWVfZWxlbWVudC5pbm5lclRleHQgPSBzdHJfdmFsdWU7XG5cblx0XHRcdFx0dmFsdWVfZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpeyBcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gb3B0aW9ucy52YWx1ZXMgfHwgW107XG5cdFx0XHRcdFx0dmFyIHByb3BuYW1lID0gdGhpcy5wYXJlbnROb2RlLmRhdGFzZXRbXCJwcm9wZXJ0eVwiXTtcblx0XHRcdFx0XHR2YXIgZWxlbV90aGF0ID0gdGhpcztcblx0XHRcdFx0XHR2YXIgbWVudSA9IG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUodmFsdWVzLHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU6IFwiZGFya1wiLFxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjazogaW5uZXJfY2xpY2tlZFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHJlZl93aW5kb3cpO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodiwgb3B0aW9uLCBldmVudCkge1xuXHRcdFx0XHRcdFx0Ly9ub2RlLnNldFByb3BlcnR5KHByb3BuYW1lLHYpOyBcblx0XHRcdFx0XHRcdC8vZ3JhcGhjYW52YXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGVsZW1fdGhhdC5pbm5lclRleHQgPSB2O1xuXHRcdFx0XHRcdFx0aW5uZXJDaGFuZ2UocHJvcG5hbWUsdik7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0cm9vdC5jb250ZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuXG5cdFx0XHRmdW5jdGlvbiBpbm5lckNoYW5nZShuYW1lLCB2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJjaGFuZ2VcIixuYW1lLHZhbHVlKTtcblx0XHRcdFx0Ly90aGF0LmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cdFx0XHRcdGlmKG9wdGlvbnMuY2FsbGJhY2spXG5cdFx0XHRcdFx0b3B0aW9ucy5jYWxsYmFjayhuYW1lLHZhbHVlKTtcblx0XHRcdFx0aWYoY2FsbGJhY2spXG5cdFx0XHRcdFx0Y2FsbGJhY2sobmFtZSx2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiByb290O1xuXHR9O1xuXG5cdExHcmFwaENhbnZhcy5nZXRQcm9wZXJ0eVByaW50YWJsZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHZhbHVlcylcblx0e1xuXHRcdGlmKCF2YWx1ZXMpXG5cdFx0XHRyZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuXHRcdGlmKHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XHRcdFx0XG5cdFx0fVxuXG5cdFx0aWYodmFsdWVzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdFx0e1xuXHRcdFx0dmFyIGRlc2NfdmFsdWUgPSBcIlwiO1xuXHRcdFx0Zm9yKHZhciBrIGluIHZhbHVlcylcblx0XHRcdHtcblx0XHRcdFx0aWYodmFsdWVzW2tdICE9IHZhbHVlKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRkZXNjX3ZhbHVlID0gaztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHZhbHVlKSArIFwiIChcIitkZXNjX3ZhbHVlK1wiKVwiO1xuXHRcdH1cblx0fVxuXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd1Nob3dOb2RlUGFuZWwgPSBmdW5jdGlvbiggbm9kZSApXG5cdHtcblx0XHR3aW5kb3cuU0VMRUNURURfTk9ERSA9IG5vZGU7XG5cdFx0dmFyIHBhbmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNub2RlLXBhbmVsXCIpO1xuXHRcdGlmKHBhbmVsKVxuXHRcdFx0cGFuZWwuY2xvc2UoKTtcblx0XHR2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cdFx0cGFuZWwgPSB0aGlzLmNyZWF0ZVBhbmVsKG5vZGUudGl0bGUgfHwgXCJcIix7Y2xvc2FibGU6IHRydWUsIHdpbmRvdzogcmVmX3dpbmRvdyB9KTtcblx0XHRwYW5lbC5pZCA9IFwibm9kZS1wYW5lbFwiO1xuXHRcdHBhbmVsLm5vZGUgPSBub2RlO1xuXHRcdHBhbmVsLmNsYXNzTGlzdC5hZGQoXCJzZXR0aW5nc1wiKTtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGdyYXBoY2FudmFzID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGlubmVyX3JlZnJlc2goKVxuXHRcdHtcblx0XHRcdHBhbmVsLmNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIjsgLy9jbGVhclxuXHRcdFx0cGFuZWwuYWRkSFRNTChcIjxzcGFuIGNsYXNzPSdub2RlX3R5cGUnPlwiK25vZGUudHlwZStcIjwvc3Bhbj48c3BhbiBjbGFzcz0nbm9kZV9kZXNjJz5cIisobm9kZS5jb25zdHJ1Y3Rvci5kZXNjIHx8IFwiXCIpK1wiPC9zcGFuPjxzcGFuIGNsYXNzPSdzZXBhcmF0b3InPjwvc3Bhbj5cIik7XG5cblx0XHRcdHBhbmVsLmFkZEhUTUwoXCI8aDM+UHJvcGVydGllczwvaDM+XCIpO1xuXG5cdFx0XHRmb3IodmFyIGkgaW4gbm9kZS5wcm9wZXJ0aWVzKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlLnByb3BlcnRpZXNbaV07XG5cdFx0XHRcdHZhciBpbmZvID0gbm9kZS5nZXRQcm9wZXJ0eUluZm8oaSk7XG5cdFx0XHRcdHZhciB0eXBlID0gaW5mby50eXBlIHx8IFwic3RyaW5nXCI7XG5cblx0XHRcdFx0Ly9pbiBjYXNlIHRoZSB1c2VyIHdhbnRzIGNvbnRyb2wgb3ZlciB0aGUgc2lkZSBwYW5lbCB3aWRnZXRcblx0XHRcdFx0aWYoIG5vZGUub25BZGRQcm9wZXJ0eVRvUGFuZWwgJiYgbm9kZS5vbkFkZFByb3BlcnR5VG9QYW5lbChpLHBhbmVsKSApXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0cGFuZWwuYWRkV2lkZ2V0KCBpbmZvLndpZGdldCB8fCBpbmZvLnR5cGUsIGksIHZhbHVlLCBpbmZvLCBmdW5jdGlvbihuYW1lLHZhbHVlKXtcblx0XHRcdFx0XHRncmFwaGNhbnZhcy5ncmFwaC5iZWZvcmVDaGFuZ2Uobm9kZSk7XG5cdFx0XHRcdFx0bm9kZS5zZXRQcm9wZXJ0eShuYW1lLHZhbHVlKTtcblx0XHRcdFx0XHRncmFwaGNhbnZhcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuXHRcdFx0XHRcdGdyYXBoY2FudmFzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwYW5lbC5hZGRTZXBhcmF0b3IoKTtcblxuXHRcdFx0aWYobm9kZS5vblNob3dDdXN0b21QYW5lbEluZm8pXG5cdFx0XHRcdG5vZGUub25TaG93Q3VzdG9tUGFuZWxJbmZvKHBhbmVsKTtcblxuXHRcdFx0Lypcblx0XHRcdHBhbmVsLmFkZEhUTUwoXCI8aDM+Q29ubmVjdGlvbnM8L2gzPlwiKTtcblx0XHRcdHZhciBjb25uZWN0aW9uX2NvbnRhaW5lcnMgPSBwYW5lbC5hZGRIVE1MKFwiPGRpdiBjbGFzcz0naW5wdXRzIGNvbm5lY3Rpb25zX3NpZGUnPjwvZGl2PjxkaXYgY2xhc3M9J291dHB1dHMgY29ubmVjdGlvbnNfc2lkZSc+PC9kaXY+XCIsXCJjb25uZWN0aW9uc1wiKTtcblx0XHRcdHZhciBpbnB1dHMgPSBjb25uZWN0aW9uX2NvbnRhaW5lcnMucXVlcnlTZWxlY3RvcihcIi5pbnB1dHNcIik7XG5cdFx0XHR2YXIgb3V0cHV0cyA9IGNvbm5lY3Rpb25fY29udGFpbmVycy5xdWVyeVNlbGVjdG9yKFwiLm91dHB1dHNcIik7XG5cdFx0XHQqL1xuXG5cdFx0XHRwYW5lbC5hZGRCdXR0b24oXCJEZWxldGVcIixmdW5jdGlvbigpe1xuXHRcdFx0XHRpZihub2RlLmJsb2NrX2RlbGV0ZSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdG5vZGUuZ3JhcGgucmVtb3ZlKG5vZGUpO1xuXHRcdFx0XHRwYW5lbC5jbG9zZSgpO1xuXHRcdFx0fSkuY2xhc3NMaXN0LmFkZChcImRlbGV0ZVwiKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbm5lcl9zaG93Q29kZVBhZCggbm9kZSwgcHJvcG5hbWUgKVxuXHRcdHtcblx0XHRcdHBhbmVsLnN0eWxlLnRvcCA9IFwiY2FsYyggNTAlIC0gMjUwcHgpXCI7XG5cdFx0XHRwYW5lbC5zdHlsZS5sZWZ0ID0gXCJjYWxjKCA1MCUgLSA0MDBweClcIjtcblx0XHRcdHBhbmVsLnN0eWxlLndpZHRoID0gXCI4MDBweFwiO1xuXHRcdFx0cGFuZWwuc3R5bGUuaGVpZ2h0ID0gXCI1MDBweFwiO1xuXG5cdFx0XHRpZih3aW5kb3cuQ29kZUZsYXNrKSAvL2Rpc2FibGVkIGZvciBub3dcblx0XHRcdHtcblx0XHRcdFx0cGFuZWwuY29udGVudC5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2NvZGUnPjwvZGl2PlwiO1xuXHRcdFx0XHR2YXIgZmxhc2sgPSBuZXcgQ29kZUZsYXNrKCBcImRpdi5jb2RlXCIsIHsgbGFuZ3VhZ2U6ICdqcycgfSk7XG5cdFx0XHRcdGZsYXNrLnVwZGF0ZUNvZGUobm9kZS5wcm9wZXJ0aWVzW3Byb3BuYW1lXSk7XG5cdFx0XHRcdGZsYXNrLm9uVXBkYXRlKCBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdFx0bm9kZS5zZXRQcm9wZXJ0eShwcm9wbmFtZSwgY29kZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRwYW5lbC5jb250ZW50LmlubmVySFRNTCA9IFwiPHRleHRhcmVhIGNsYXNzPSdjb2RlJz48L3RleHRhcmVhPlwiO1xuXHRcdFx0XHR2YXIgdGV4dGFyZWEgPSBwYW5lbC5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKTtcblx0XHRcdFx0dGV4dGFyZWEudmFsdWUgPSBub2RlLnByb3BlcnRpZXNbcHJvcG5hbWVdO1xuXHRcdFx0XHR0ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKGUpO1xuXHRcdFx0XHRcdGlmKGUuY29kZSA9PSBcIkVudGVyXCIgJiYgZS5jdHJsS2V5IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkFzc2lnbmVkXCIpO1xuXHRcdFx0XHRcdFx0bm9kZS5zZXRQcm9wZXJ0eShwcm9wbmFtZSwgdGV4dGFyZWEudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFwiY2FsYygxMDAlIC0gNDBweClcIjtcblx0XHRcdH1cblx0XHRcdHZhciBhc3NpZ24gPSB0aGF0LmNyZWF0ZUJ1dHRvbiggXCJBc3NpZ25cIiwgbnVsbCwgZnVuY3Rpb24oKXtcblx0XHRcdFx0bm9kZS5zZXRQcm9wZXJ0eShwcm9wbmFtZSwgdGV4dGFyZWEudmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0XHRwYW5lbC5jb250ZW50LmFwcGVuZENoaWxkKGFzc2lnbik7XG5cdFx0XHR2YXIgYnV0dG9uID0gdGhhdC5jcmVhdGVCdXR0b24oIFwiQ2xvc2VcIiwgbnVsbCwgZnVuY3Rpb24oKXtcblx0XHRcdFx0cGFuZWwuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcblx0XHRcdFx0aW5uZXJfcmVmcmVzaCgpO1xuXHRcdFx0fSk7XG5cdFx0XHRidXR0b24uc3R5bGUuZmxvYXQgPSBcInJpZ2h0XCI7XG5cdFx0XHRwYW5lbC5jb250ZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdFx0fVxuXG5cdFx0aW5uZXJfcmVmcmVzaCgpO1xuXG5cdFx0dGhpcy5jYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCggcGFuZWwgKTtcblx0fVxuXHRcblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nID0gZnVuY3Rpb24obm9kZSlcblx0e1xuXHRcdGNvbnNvbGUubG9nKFwic2hvd2luZyBzdWJncmFwaCBwcm9wZXJ0aWVzIGRpYWxvZ1wiKTtcblxuXHRcdHZhciBvbGRfcGFuZWwgPSB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXCIuc3ViZ3JhcGhfZGlhbG9nXCIpO1xuXHRcdGlmKG9sZF9wYW5lbClcblx0XHRcdG9sZF9wYW5lbC5jbG9zZSgpO1xuXG5cdFx0dmFyIHBhbmVsID0gdGhpcy5jcmVhdGVQYW5lbChcIlN1YmdyYXBoIElucHV0c1wiLHtjbG9zYWJsZTp0cnVlLCB3aWR0aDogNTAwfSk7XG5cdFx0cGFuZWwubm9kZSA9IG5vZGU7XG5cdFx0cGFuZWwuY2xhc3NMaXN0LmFkZChcInN1YmdyYXBoX2RpYWxvZ1wiKTtcblxuXHRcdGZ1bmN0aW9uIGlubmVyX3JlZnJlc2goKVxuXHRcdHtcblx0XHRcdHBhbmVsLmNsZWFyKCk7XG5cblx0XHRcdC8vc2hvdyBjdXJyZW50c1xuXHRcdFx0aWYobm9kZS5pbnB1dHMpXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2ldO1xuXHRcdFx0XHRcdGlmKGlucHV0Lm5vdF9zdWJncmFwaF9pbnB1dClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdHZhciBodG1sID0gXCI8YnV0dG9uPiYjMTAwMDU7PC9idXR0b24+IDxzcGFuIGNsYXNzPSdidWxsZXRfaWNvbic+PC9zcGFuPjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+PHNwYW4gY2xhc3M9J3R5cGUnPjwvc3Bhbj5cIjtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IHBhbmVsLmFkZEhUTUwoaHRtbCxcInN1YmdyYXBoX3Byb3BlcnR5XCIpO1xuXHRcdFx0XHRcdGVsZW0uZGF0YXNldFtcIm5hbWVcIl0gPSBpbnB1dC5uYW1lO1xuXHRcdFx0XHRcdGVsZW0uZGF0YXNldFtcInNsb3RcIl0gPSBpO1xuXHRcdFx0XHRcdGVsZW0ucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpLmlubmVyVGV4dCA9IGlucHV0Lm5hbWU7XG5cdFx0XHRcdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiLnR5cGVcIikuaW5uZXJUZXh0ID0gaW5wdXQudHlwZTtcblx0XHRcdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHRub2RlLnJlbW92ZUlucHV0KCBOdW1iZXIoIHRoaXMucGFyZW50Tm9kZS5kYXRhc2V0W1wic2xvdFwiXSApICk7XG5cdFx0XHRcdFx0XHRpbm5lcl9yZWZyZXNoKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2FkZCBleHRyYVxuXHRcdHZhciBodG1sID0gXCIgKyA8c3BhbiBjbGFzcz0nbGFiZWwnPk5hbWU8L3NwYW4+PGlucHV0IGNsYXNzPSduYW1lJy8+PHNwYW4gY2xhc3M9J2xhYmVsJz5UeXBlPC9zcGFuPjxpbnB1dCBjbGFzcz0ndHlwZSc+PC9pbnB1dD48YnV0dG9uPis8L2J1dHRvbj5cIjtcblx0XHR2YXIgZWxlbSA9IHBhbmVsLmFkZEhUTUwoaHRtbCxcInN1YmdyYXBoX3Byb3BlcnR5IGV4dHJhXCIsIHRydWUpO1xuXHRcdGVsZW0ucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXMucGFyZW50Tm9kZTtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIikudmFsdWU7XG5cdFx0XHR2YXIgdHlwZSA9IGVsZW0ucXVlcnlTZWxlY3RvcihcIi50eXBlXCIpLnZhbHVlO1xuXHRcdFx0aWYoIW5hbWUgfHwgbm9kZS5maW5kSW5wdXRTbG90KG5hbWUpICE9IC0xKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRub2RlLmFkZElucHV0KG5hbWUsdHlwZSk7XG5cdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKS52YWx1ZSA9IFwiXCI7XG5cdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIudHlwZVwiKS52YWx1ZSA9IFwiXCI7XG5cdFx0XHRpbm5lcl9yZWZyZXNoKCk7XG5cdFx0fSk7XG5cblx0XHRpbm5lcl9yZWZyZXNoKCk7XG5cdCAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHBhbmVsKTtcblx0XHRyZXR1cm4gcGFuZWw7XG5cdH1cblxuXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLmNoZWNrUGFuZWxzID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0aWYoIXRoaXMuY2FudmFzKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBwYW5lbHMgPSB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGl0ZWdyYXBoLmRpYWxvZ1wiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcGFuZWxzLmxlbmd0aDsgKytpKVxuXHRcdHtcblx0XHRcdHZhciBwYW5lbCA9IHBhbmVsc1tpXTtcblx0XHRcdGlmKCAhcGFuZWwubm9kZSApXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0aWYoICFwYW5lbC5ub2RlLmdyYXBoIHx8IHBhbmVsLmdyYXBoICE9IHRoaXMuZ3JhcGggKVxuXHRcdFx0XHRwYW5lbC5jbG9zZSgpO1xuXHRcdH1cblx0fVxuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVDb2xsYXBzZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG5cdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2Uobm9kZSk7XG4gICAgICAgIG5vZGUuY29sbGFwc2UoKTtcblx0XHRub2RlLmdyYXBoLmFmdGVyQ2hhbmdlKG5vZGUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZVBpbiA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIG5vZGUucGluKCk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlTW9kZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUoXG4gICAgICAgICAgICBbXCJBbHdheXNcIiwgXCJPbiBFdmVudFwiLCBcIk9uIFRyaWdnZXJcIiwgXCJOZXZlclwiXSxcbiAgICAgICAgICAgIHsgZXZlbnQ6IGUsIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLCBwYXJlbnRNZW51OiBtZW51LCBub2RlOiBub2RlIH1cbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJPbiBFdmVudFwiOlxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGUgPSBMaXRlR3JhcGguT05fRVZFTlQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJPbiBUcmlnZ2VyXCI6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW9kZSA9IExpdGVHcmFwaC5PTl9UUklHR0VSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTmV2ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlID0gTGl0ZUdyYXBoLk5FVkVSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQWx3YXlzXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlID0gTGl0ZUdyYXBoLkFMV0FZUztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sb3JzID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIm5vIG5vZGUgZm9yIGNvbG9yXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgY29udGVudDpcbiAgICAgICAgICAgICAgICBcIjxzcGFuIHN0eWxlPSdkaXNwbGF5OiBibG9jazsgcGFkZGluZy1sZWZ0OiA0cHg7Jz5ObyBjb2xvcjwvc3Bhbj5cIlxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIExHcmFwaENhbnZhcy5ub2RlX2NvbG9ycykge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gTEdyYXBoQ2FudmFzLm5vZGVfY29sb3JzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6XG4gICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gc3R5bGU9J2Rpc3BsYXk6IGJsb2NrOyBjb2xvcjogIzk5OTsgcGFkZGluZy1sZWZ0OiA0cHg7IGJvcmRlci1sZWZ0OiA4cHggc29saWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBjb2xvci5jb2xvciArXG4gICAgICAgICAgICAgICAgICAgIFwiOyBiYWNrZ3JvdW5kLWNvbG9yOlwiICtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IuYmdjb2xvciArXG4gICAgICAgICAgICAgICAgICAgIFwiJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KHZhbHVlcywge1xuICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgIHBhcmVudE1lbnU6IG1lbnUsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodikge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSB2LnZhbHVlID8gTEdyYXBoQ2FudmFzLm5vZGVfY29sb3JzW3YudmFsdWVdIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnN0cnVjdG9yID09PSBMaXRlR3JhcGguTEdyYXBoR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xvciA9IGNvbG9yLmdyb3VwY29sb3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xvciA9IGNvbG9yLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmJnY29sb3IgPSBjb2xvci5iZ2NvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuY29sb3I7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuYmdjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlU2hhcGVzID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIm5vIG5vZGUgcGFzc2VkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KExpdGVHcmFwaC5WQUxJRF9TSEFQRVMsIHtcbiAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsXG4gICAgICAgICAgICBwYXJlbnRNZW51OiBtZW51LFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblx0XHRcdG5vZGUuZ3JhcGguYmVmb3JlQ2hhbmdlKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5zaGFwZSA9IHY7XG5cdFx0XHRub2RlLmdyYXBoLmFmdGVyQ2hhbmdlKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVSZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZSwgbWVudSwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IFwibm8gbm9kZSBwYXNzZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnJlbW92YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0dmFyIGdyYXBoID0gbm9kZS5ncmFwaDtcblx0XHRncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlKG5vZGUpO1xuXHRcdGdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlVG9TdWJncmFwaCA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG5cdFx0dmFyIGdyYXBoID0gbm9kZS5ncmFwaDtcblx0XHR2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcblx0XHRpZighZ3JhcGhjYW52YXMpIC8vPz9cblx0XHRcdHJldHVybjtcblxuXHRcdHZhciBub2Rlc19saXN0ID0gT2JqZWN0LnZhbHVlcyggZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMgfHwge30gKTtcblx0XHRpZiggIW5vZGVzX2xpc3QubGVuZ3RoIClcblx0XHRcdG5vZGVzX2xpc3QgPSBbIG5vZGUgXTtcblxuXHRcdHZhciBzdWJncmFwaF9ub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJncmFwaC9zdWJncmFwaFwiKTtcblx0XHRzdWJncmFwaF9ub2RlLnBvcyA9IG5vZGUucG9zLmNvbmNhdCgpO1xuXHRcdGdyYXBoLmFkZChzdWJncmFwaF9ub2RlKTtcblxuXHRcdHN1YmdyYXBoX25vZGUuYnVpbGRGcm9tTm9kZXMoIG5vZGVzX2xpc3QgKTtcblxuXHRcdGdyYXBoY2FudmFzLmRlc2VsZWN0QWxsTm9kZXMoKTtcbiAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVDbG9uZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNsb25hYmxlID09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld25vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgIGlmICghbmV3bm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld25vZGUucG9zID0gW25vZGUucG9zWzBdICsgNSwgbm9kZS5wb3NbMV0gKyA1XTtcblxuXHRcdG5vZGUuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgIG5vZGUuZ3JhcGguYWRkKG5ld25vZGUpO1xuXHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcblxuICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMgPSB7XG4gICAgICAgIHJlZDogeyBjb2xvcjogXCIjMzIyXCIsIGJnY29sb3I6IFwiIzUzM1wiLCBncm91cGNvbG9yOiBcIiNBODhcIiB9LFxuICAgICAgICBicm93bjogeyBjb2xvcjogXCIjMzMyOTIyXCIsIGJnY29sb3I6IFwiIzU5MzkzMFwiLCBncm91cGNvbG9yOiBcIiNiMDY2MzRcIiB9LFxuICAgICAgICBncmVlbjogeyBjb2xvcjogXCIjMjMyXCIsIGJnY29sb3I6IFwiIzM1M1wiLCBncm91cGNvbG9yOiBcIiM4QThcIiB9LFxuICAgICAgICBibHVlOiB7IGNvbG9yOiBcIiMyMjNcIiwgYmdjb2xvcjogXCIjMzM1XCIsIGdyb3VwY29sb3I6IFwiIzg4QVwiIH0sXG4gICAgICAgIHBhbGVfYmx1ZToge1xuICAgICAgICAgICAgY29sb3I6IFwiIzJhMzYzYlwiLFxuICAgICAgICAgICAgYmdjb2xvcjogXCIjM2Y1MTU5XCIsXG4gICAgICAgICAgICBncm91cGNvbG9yOiBcIiMzZjc4OWVcIlxuICAgICAgICB9LFxuICAgICAgICBjeWFuOiB7IGNvbG9yOiBcIiMyMzNcIiwgYmdjb2xvcjogXCIjMzU1XCIsIGdyb3VwY29sb3I6IFwiIzhBQVwiIH0sXG4gICAgICAgIHB1cnBsZTogeyBjb2xvcjogXCIjMzIzXCIsIGJnY29sb3I6IFwiIzUzNVwiLCBncm91cGNvbG9yOiBcIiNhMTMwOWJcIiB9LFxuICAgICAgICB5ZWxsb3c6IHsgY29sb3I6IFwiIzQzMlwiLCBiZ2NvbG9yOiBcIiM2NTNcIiwgZ3JvdXBjb2xvcjogXCIjYjU4YjJhXCIgfSxcbiAgICAgICAgYmxhY2s6IHsgY29sb3I6IFwiIzIyMlwiLCBiZ2NvbG9yOiBcIiMwMDBcIiwgZ3JvdXBjb2xvcjogXCIjNDQ0XCIgfVxuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldENhbnZhc01lbnVPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZ2V0TWVudU9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLmdldE1lbnVPcHRpb25zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJBZGQgTm9kZVwiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVBZGRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgY29udGVudDogXCJBZGQgR3JvdXBcIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbkdyb3VwQWRkIH1cbiAgICAgICAgICAgICAgICAvL3tjb250ZW50OlwiQ29sbGFwc2UgQWxsXCIsIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Q29sbGFwc2VBbGwgfVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2dyYXBoX3N0YWNrICYmIHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIkNsb3NlIHN1YmdyYXBoXCIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmNsb3NlU3ViZ3JhcGguYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0RXh0cmFNZW51T3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYU1lbnVPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KGV4dHJhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICAvL2NhbGxlZCBieSBwcm9jZXNzQ29udGV4dE1lbnUgdG8gZXh0cmFjdCB0aGUgbWVudSBsaXN0XG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5nZXROb2RlTWVudU9wdGlvbnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gbnVsbDtcblxuICAgICAgICBpZiAobm9kZS5nZXRNZW51T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG5vZGUuZ2V0TWVudU9wdGlvbnModGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJJbnB1dHNcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLnNob3dNZW51Tm9kZU9wdGlvbmFsSW5wdXRzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiT3V0cHV0c1wiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxPdXRwdXRzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uU2hvd01lbnVOb2RlUHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vblNob3dQcm9wZXJ0eUVkaXRvclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIk1vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Tm9kZU1vZGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJSZXNpemVcIiwgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5yZXNpemFibGUpIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBMR3JhcGhDYW52YXMub25SZXNpemVOb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ29sbGFwc2VcIixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sbGFwc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgY29udGVudDogXCJQaW5cIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUGluIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIkNvbG9yc1wiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sb3JzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiU2hhcGVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVTaGFwZXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vbkdldElucHV0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IG5vZGUub25HZXRJbnB1dHMoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMgJiYgaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLm9uR2V0T3V0cHV0cykge1xuICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBub2RlLm9uR2V0T3V0cHV0cygpO1xuICAgICAgICAgICAgaWYgKG91dHB1dHMgJiYgb3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWzFdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5nZXRFeHRyYU1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmEgPSBub2RlLmdldEV4dHJhTWVudU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBleHRyYS5jb25jYXQob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5jbG9uYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogXCJDbG9uZVwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Tm9kZUNsb25lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cdFx0aWYoMCkgLy9UT0RPXG5cdFx0b3B0aW9ucy5wdXNoKHtcblx0XHRcdGNvbnRlbnQ6IFwiVG8gU3ViZ3JhcGhcIixcblx0XHRcdGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Tm9kZVRvU3ViZ3JhcGhcblx0XHR9KTtcblxuXHRcdG9wdGlvbnMucHVzaChudWxsLCB7XG5cdFx0XHRjb250ZW50OiBcIlJlbW92ZVwiLFxuXHRcdFx0ZGlzYWJsZWQ6ICEobm9kZS5yZW1vdmFibGUgIT09IGZhbHNlICYmICFub2RlLmJsb2NrX2RlbGV0ZSApLFxuXHRcdFx0Y2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUmVtb3ZlXG5cdFx0fSk7XG5cbiAgICAgICAgaWYgKG5vZGUuZ3JhcGggJiYgbm9kZS5ncmFwaC5vbkdldE5vZGVNZW51T3B0aW9ucykge1xuICAgICAgICAgICAgbm9kZS5ncmFwaC5vbkdldE5vZGVNZW51T3B0aW9ucyhvcHRpb25zLCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldEdyb3VwTWVudU9wdGlvbnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBvID0gW1xuICAgICAgICAgICAgeyBjb250ZW50OiBcIlRpdGxlXCIsIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25TaG93UHJvcGVydHlFZGl0b3IgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIkNvbG9yXCIsXG4gICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sb3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiRm9udCBzaXplXCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiZm9udF9zaXplXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJOdW1iZXJcIixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uU2hvd1Byb3BlcnR5RWRpdG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHsgY29udGVudDogXCJSZW1vdmVcIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUmVtb3ZlIH1cbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzQ29udGV4dE1lbnUgPSBmdW5jdGlvbihub2RlLCBldmVudCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBjYW52YXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgdmFyIG1lbnVfaW5mbyA9IG51bGw7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX29wdGlvbl9jbGlja2VkLFxuICAgICAgICAgICAgZXh0cmE6IG5vZGVcbiAgICAgICAgfTtcblxuXHRcdGlmKG5vZGUpXG5cdFx0XHRvcHRpb25zLnRpdGxlID0gbm9kZS50eXBlO1xuXG4gICAgICAgIC8vY2hlY2sgaWYgbW91c2UgaXMgaW4gaW5wdXRcbiAgICAgICAgdmFyIHNsb3QgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgc2xvdCA9IG5vZGUuZ2V0U2xvdEluUG9zaXRpb24oZXZlbnQuY2FudmFzWCwgZXZlbnQuY2FudmFzWSk7XG4gICAgICAgICAgICBMR3JhcGhDYW52YXMuYWN0aXZlX25vZGUgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vb24gc2xvdFxuICAgICAgICAgICAgbWVudV9pbmZvID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5nZXRTbG90TWVudU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBtZW51X2luZm8gPSBub2RlLmdldFNsb3RNZW51T3B0aW9ucyhzbG90KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzbG90ICYmXG4gICAgICAgICAgICAgICAgICAgIHNsb3Qub3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHNsb3Qub3V0cHV0LmxpbmtzICYmXG4gICAgICAgICAgICAgICAgICAgIHNsb3Qub3V0cHV0LmxpbmtzLmxlbmd0aFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBtZW51X2luZm8ucHVzaCh7IGNvbnRlbnQ6IFwiRGlzY29ubmVjdCBMaW5rc1wiLCBzbG90OiBzbG90IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX3Nsb3QgPSBzbG90LmlucHV0IHx8IHNsb3Qub3V0cHV0O1xuICAgICAgICAgICAgICAgIG1lbnVfaW5mby5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBfc2xvdC5sb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJDYW5ub3QgcmVtb3ZlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBjb250ZW50OiBcIlJlbW92ZSBTbG90XCIsIHNsb3Q6IHNsb3QgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWVudV9pbmZvLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIF9zbG90Lm5hbWVMb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJDYW5ub3QgcmVuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBjb250ZW50OiBcIlJlbmFtZSBTbG90XCIsIHNsb3Q6IHNsb3QgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnRpdGxlID1cbiAgICAgICAgICAgICAgICAoc2xvdC5pbnB1dCA/IHNsb3QuaW5wdXQudHlwZSA6IHNsb3Qub3V0cHV0LnR5cGUpIHx8IFwiKlwiO1xuICAgICAgICAgICAgaWYgKHNsb3QuaW5wdXQgJiYgc2xvdC5pbnB1dC50eXBlID09IExpdGVHcmFwaC5BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRpdGxlID0gXCJBY3Rpb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzbG90Lm91dHB1dCAmJiBzbG90Lm91dHB1dC50eXBlID09IExpdGVHcmFwaC5FVkVOVCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBcIkV2ZW50XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vb24gbm9kZVxuICAgICAgICAgICAgICAgIG1lbnVfaW5mbyA9IHRoaXMuZ2V0Tm9kZU1lbnVPcHRpb25zKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZW51X2luZm8gPSB0aGlzLmdldENhbnZhc01lbnVPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncmFwaC5nZXRHcm91cE9uUG9zKFxuICAgICAgICAgICAgICAgICAgICBldmVudC5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5jYW52YXNZXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9vbiBncm91cFxuICAgICAgICAgICAgICAgICAgICBtZW51X2luZm8ucHVzaChudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIkVkaXQgR3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VibWVudToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkdyb3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuZ2V0R3JvdXBNZW51T3B0aW9ucyhncm91cClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9zaG93IG1lbnVcbiAgICAgICAgaWYgKCFtZW51X2luZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShtZW51X2luZm8sIG9wdGlvbnMsIHJlZl93aW5kb3cpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX29wdGlvbl9jbGlja2VkKHYsIG9wdGlvbnMsIGUpIHtcbiAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYuY29udGVudCA9PSBcIlJlbW92ZSBTbG90XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHYuc2xvdDtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUlucHV0KGluZm8uc2xvdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmZvLm91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZU91dHB1dChpbmZvLnNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYuY29udGVudCA9PSBcIkRpc2Nvbm5lY3QgTGlua3NcIikge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdi5zbG90O1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLm91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3RPdXRwdXQoaW5mby5zbG90KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZm8uaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0SW5wdXQoaW5mby5zbG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2LmNvbnRlbnQgPT0gXCJSZW5hbWUgU2xvdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB2LnNsb3Q7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3RfaW5mbyA9IGluZm8uaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLmdldElucHV0SW5mbyhpbmZvLnNsb3QpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZS5nZXRPdXRwdXRJbmZvKGluZm8uc2xvdCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoYXQuY3JlYXRlRGlhbG9nKFxuICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSduYW1lJz5OYW1lPC9zcGFuPjxpbnB1dCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcvPjxidXR0b24+T0s8L2J1dHRvbj5cIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgJiYgc2xvdF9pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gc2xvdF9pbmZvLmxhYmVsIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90X2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdF9pbmZvLmxhYmVsID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0RGlydHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYodi5jYWxsYmFjaylcbiAgICAgICAgICAgIC8vXHRyZXR1cm4gdi5jYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsIG9wdGlvbnMsIGUsIG1lbnUsIHRoYXQsIGV2ZW50ICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9BUEkgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vbGlrZSByZWN0IGJ1dCByb3VuZGVkIGNvcm5lcnNcbiAgICBpZiAodHlwZW9mKHdpbmRvdykgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICYmICF3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QpIHtcbiAgICAgICAgd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUucm91bmRSZWN0ID0gZnVuY3Rpb24oXG5cdFx0eCxcblx0XHR5LFxuXHRcdHcsXG5cdFx0aCxcblx0XHRyYWRpdXMsXG5cdFx0cmFkaXVzX2xvd1xuXHQpIHtcblx0XHR2YXIgdG9wX2xlZnRfcmFkaXVzID0gMDtcblx0XHR2YXIgdG9wX3JpZ2h0X3JhZGl1cyA9IDA7XG5cdFx0dmFyIGJvdHRvbV9sZWZ0X3JhZGl1cyA9IDA7XG5cdFx0dmFyIGJvdHRvbV9yaWdodF9yYWRpdXMgPSAwO1xuXG5cdFx0aWYgKCByYWRpdXMgPT09IDAgKVxuXHRcdHtcblx0XHRcdHRoaXMucmVjdCh4LHksdyxoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihyYWRpdXNfbG93ID09PSB1bmRlZmluZWQpXG5cdFx0XHRyYWRpdXNfbG93ID0gcmFkaXVzO1xuXG5cdFx0Ly9tYWtlIGl0IGNvbXBhdGlibGUgd2l0aCBvZmZpY2lhbCBvbmVcblx0XHRpZihyYWRpdXMgIT0gbnVsbCAmJiByYWRpdXMuY29uc3RydWN0b3IgPT09IEFycmF5KVxuXHRcdHtcblx0XHRcdGlmKHJhZGl1cy5sZW5ndGggPT0gMSlcblx0XHRcdFx0dG9wX2xlZnRfcmFkaXVzID0gdG9wX3JpZ2h0X3JhZGl1cyA9IGJvdHRvbV9sZWZ0X3JhZGl1cyA9IGJvdHRvbV9yaWdodF9yYWRpdXMgPSByYWRpdXNbMF07XG5cdFx0XHRlbHNlIGlmKHJhZGl1cy5sZW5ndGggPT0gMilcblx0XHRcdHtcblx0XHRcdFx0dG9wX2xlZnRfcmFkaXVzID0gYm90dG9tX3JpZ2h0X3JhZGl1cyA9IHJhZGl1c1swXTtcblx0XHRcdFx0dG9wX3JpZ2h0X3JhZGl1cyA9IGJvdHRvbV9sZWZ0X3JhZGl1cyA9IHJhZGl1c1sxXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYocmFkaXVzLmxlbmd0aCA9PSA0KVxuXHRcdFx0e1xuXHRcdFx0XHR0b3BfbGVmdF9yYWRpdXMgPSByYWRpdXNbMF07XG5cdFx0XHRcdHRvcF9yaWdodF9yYWRpdXMgPSByYWRpdXNbMV07XG5cdFx0XHRcdGJvdHRvbV9sZWZ0X3JhZGl1cyA9IHJhZGl1c1syXTtcblx0XHRcdFx0Ym90dG9tX3JpZ2h0X3JhZGl1cyA9IHJhZGl1c1szXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlbHNlIC8vb2xkIHVzaW5nIG51bWJlcnNcblx0XHR7XG5cdFx0XHR0b3BfbGVmdF9yYWRpdXMgPSByYWRpdXMgfHwgMDtcblx0XHRcdHRvcF9yaWdodF9yYWRpdXMgPSByYWRpdXMgfHwgMDtcblx0XHRcdGJvdHRvbV9sZWZ0X3JhZGl1cyA9IHJhZGl1c19sb3cgfHwgMDtcblx0XHRcdGJvdHRvbV9yaWdodF9yYWRpdXMgPSByYWRpdXNfbG93IHx8IDA7XG5cdFx0fVxuXG5cdFx0Ly90b3AgcmlnaHRcblx0XHR0aGlzLm1vdmVUbyh4ICsgdG9wX2xlZnRfcmFkaXVzLCB5KTtcblx0XHR0aGlzLmxpbmVUbyh4ICsgdyAtIHRvcF9yaWdodF9yYWRpdXMsIHkpO1xuXHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyh4ICsgdywgeSwgeCArIHcsIHkgKyB0b3BfcmlnaHRfcmFkaXVzKTtcblxuXHRcdC8vYm90dG9tIHJpZ2h0XG5cdFx0dGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gYm90dG9tX3JpZ2h0X3JhZGl1cyk7XG5cdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0eCArIHcsXG5cdFx0XHR5ICsgaCxcblx0XHRcdHggKyB3IC0gYm90dG9tX3JpZ2h0X3JhZGl1cyxcblx0XHRcdHkgKyBoXG5cdFx0KTtcblxuXHRcdC8vYm90dG9tIGxlZnRcblx0XHR0aGlzLmxpbmVUbyh4ICsgYm90dG9tX3JpZ2h0X3JhZGl1cywgeSArIGgpO1xuXHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaCwgeCwgeSArIGggLSBib3R0b21fbGVmdF9yYWRpdXMpO1xuXG5cdFx0Ly90b3AgbGVmdFxuXHRcdHRoaXMubGluZVRvKHgsIHkgKyBib3R0b21fbGVmdF9yYWRpdXMpO1xuXHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wX2xlZnRfcmFkaXVzLCB5KTtcblx0fTtcblx0fS8vaWZcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVPYmplY3RzKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBMaXRlR3JhcGguY29tcGFyZU9iamVjdHMgPSBjb21wYXJlT2JqZWN0cztcblxuICAgIGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgIChiWzBdIC0gYVswXSkgKiAoYlswXSAtIGFbMF0pICsgKGJbMV0gLSBhWzFdKSAqIChiWzFdIC0gYVsxXSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBjb2xvclRvU3RyaW5nKGMpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwicmdiYShcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMF0gKiAyNTUpLnRvRml4ZWQoKSArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMV0gKiAyNTUpLnRvRml4ZWQoKSArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMl0gKiAyNTUpLnRvRml4ZWQoKSArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICAoYy5sZW5ndGggPT0gNCA/IGNbM10udG9GaXhlZCgyKSA6IFwiMS4wXCIpICtcbiAgICAgICAgICAgIFwiKVwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIExpdGVHcmFwaC5jb2xvclRvU3RyaW5nID0gY29sb3JUb1N0cmluZztcblxuICAgIGZ1bmN0aW9uIGlzSW5zaWRlUmVjdGFuZ2xlKHgsIHksIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAobGVmdCA8IHggJiYgbGVmdCArIHdpZHRoID4geCAmJiB0b3AgPCB5ICYmIHRvcCArIGhlaWdodCA+IHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlID0gaXNJbnNpZGVSZWN0YW5nbGU7XG5cbiAgICAvL1ttaW54LG1pbnksbWF4eCxtYXh5XVxuICAgIGZ1bmN0aW9uIGdyb3dCb3VuZGluZyhib3VuZGluZywgeCwgeSkge1xuICAgICAgICBpZiAoeCA8IGJvdW5kaW5nWzBdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1swXSA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA+IGJvdW5kaW5nWzJdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1syXSA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA8IGJvdW5kaW5nWzFdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1sxXSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA+IGJvdW5kaW5nWzNdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1szXSA9IHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTGl0ZUdyYXBoLmdyb3dCb3VuZGluZyA9IGdyb3dCb3VuZGluZztcblxuICAgIC8vcG9pbnQgaW5zaWRlIGJvdW5kaW5nIGJveFxuICAgIGZ1bmN0aW9uIGlzSW5zaWRlQm91bmRpbmcocCwgYmIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcFswXSA8IGJiWzBdWzBdIHx8XG4gICAgICAgICAgICBwWzFdIDwgYmJbMF1bMV0gfHxcbiAgICAgICAgICAgIHBbMF0gPiBiYlsxXVswXSB8fFxuICAgICAgICAgICAgcFsxXSA+IGJiWzFdWzFdXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBMaXRlR3JhcGguaXNJbnNpZGVCb3VuZGluZyA9IGlzSW5zaWRlQm91bmRpbmc7XG5cbiAgICAvL2JvdW5kaW5nIG92ZXJsYXAsIGZvcm1hdDogWyBzdGFydHgsIHN0YXJ0eSwgd2lkdGgsIGhlaWdodCBdXG4gICAgZnVuY3Rpb24gb3ZlcmxhcEJvdW5kaW5nKGEsIGIpIHtcbiAgICAgICAgdmFyIEFfZW5kX3ggPSBhWzBdICsgYVsyXTtcbiAgICAgICAgdmFyIEFfZW5kX3kgPSBhWzFdICsgYVszXTtcbiAgICAgICAgdmFyIEJfZW5kX3ggPSBiWzBdICsgYlsyXTtcbiAgICAgICAgdmFyIEJfZW5kX3kgPSBiWzFdICsgYlszXTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBhWzBdID4gQl9lbmRfeCB8fFxuICAgICAgICAgICAgYVsxXSA+IEJfZW5kX3kgfHxcbiAgICAgICAgICAgIEFfZW5kX3ggPCBiWzBdIHx8XG4gICAgICAgICAgICBBX2VuZF95IDwgYlsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLm92ZXJsYXBCb3VuZGluZyA9IG92ZXJsYXBCb3VuZGluZztcblxuICAgIC8vQ29udmVydCBhIGhleCB2YWx1ZSB0byBpdHMgZGVjaW1hbCB2YWx1ZSAtIHRoZSBpbnB1dHRlZCBoZXggbXVzdCBiZSBpbiB0aGVcbiAgICAvL1x0Zm9ybWF0IG9mIGEgaGV4IHRyaXBsZXQgLSB0aGUga2luZCB3ZSB1c2UgZm9yIEhUTUwgY29sb3Vycy4gVGhlIGZ1bmN0aW9uXG4gICAgLy9cdHdpbGwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhyZWUgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIGhleDJudW0oaGV4KSB7XG4gICAgICAgIGlmIChoZXguY2hhckF0KDApID09IFwiI1wiKSB7XG4gICAgICAgICAgICBoZXggPSBoZXguc2xpY2UoMSk7XG4gICAgICAgIH0gLy9SZW1vdmUgdGhlICcjJyBjaGFyIC0gaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICBoZXggPSBoZXgudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIGhleF9hbHBoYWJldHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5KDMpO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIHZhciBpbnQxLCBpbnQyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkgKz0gMikge1xuICAgICAgICAgICAgaW50MSA9IGhleF9hbHBoYWJldHMuaW5kZXhPZihoZXguY2hhckF0KGkpKTtcbiAgICAgICAgICAgIGludDIgPSBoZXhfYWxwaGFiZXRzLmluZGV4T2YoaGV4LmNoYXJBdChpICsgMSkpO1xuICAgICAgICAgICAgdmFsdWVba10gPSBpbnQxICogMTYgKyBpbnQyO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBMaXRlR3JhcGguaGV4Mm51bSA9IGhleDJudW07XG5cbiAgICAvL0dpdmUgYSBhcnJheSB3aXRoIHRocmVlIHZhbHVlcyBhcyB0aGUgYXJndW1lbnQgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVyblxuICAgIC8vXHR0aGUgY29ycmVzcG9uZGluZyBoZXggdHJpcGxldC5cbiAgICBmdW5jdGlvbiBudW0yaGV4KHRyaXBsZXQpIHtcbiAgICAgICAgdmFyIGhleF9hbHBoYWJldHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgdmFyIGhleCA9IFwiI1wiO1xuICAgICAgICB2YXIgaW50MSwgaW50MjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGludDEgPSB0cmlwbGV0W2ldIC8gMTY7XG4gICAgICAgICAgICBpbnQyID0gdHJpcGxldFtpXSAlIDE2O1xuXG4gICAgICAgICAgICBoZXggKz0gaGV4X2FscGhhYmV0cy5jaGFyQXQoaW50MSkgKyBoZXhfYWxwaGFiZXRzLmNoYXJBdChpbnQyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH1cblxuICAgIExpdGVHcmFwaC5udW0yaGV4ID0gbnVtMmhleDtcblxuICAgIC8qIExpdGVHcmFwaCBHVUkgZWxlbWVudHMgdXNlZCBmb3IgY2FudmFzIGVkaXRpbmcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIENvbnRleHRNZW51IGZyb20gTGl0ZUdVSVxuICAgICAqXG4gICAgICogQGNsYXNzIENvbnRleHRNZW51XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIChhbGxvd3Mgb2JqZWN0IHsgdGl0bGU6IFwiTmljZSB0ZXh0XCIsIGNhbGxiYWNrOiBmdW5jdGlvbiAuLi4gfSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBbb3B0aW9uYWxdIFNvbWUgb3B0aW9uczpcXFxuICAgICAqIC0gdGl0bGU6IHRpdGxlIHRvIHNob3cgb24gdG9wIG9mIHRoZSBtZW51XG4gICAgICogLSBjYWxsYmFjazogZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIG9wdGlvbiBpcyBjbGlja2VkLCBpdCByZWNlaXZlcyB0aGUgaXRlbSBpbmZvcm1hdGlvblxuICAgICAqIC0gaWdub3JlX2l0ZW1fY2FsbGJhY2tzOiBpZ25vcmVzIHRoZSBjYWxsYmFjayBpbnNpZGUgdGhlIGl0ZW0sIGl0IGp1c3QgY2FsbHMgdGhlIG9wdGlvbnMuY2FsbGJhY2tcbiAgICAgKiAtIGV2ZW50OiB5b3UgY2FuIHBhc3MgYSBNb3VzZUV2ZW50LCB0aGlzIHdheSB0aGUgQ29udGV4dE1lbnUgYXBwZWFycyBpbiB0aGF0IHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGV4dE1lbnUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy90byBsaW5rIGEgbWVudSB3aXRoIGl0cyBwYXJlbnRcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50TWVudSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50TWVudS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwicGFyZW50TWVudSBtdXN0IGJlIG9mIGNsYXNzIENvbnRleHRNZW51LCBpZ25vcmluZyBpdFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudE1lbnUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1lbnUgPSBvcHRpb25zLnBhcmVudE1lbnU7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWVudS5jdXJyZW50X3N1Ym1lbnUgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHR2YXIgZXZlbnRDbGFzcyA9IG51bGw7XG5cdFx0aWYob3B0aW9ucy5ldmVudCkgLy91c2Ugc3RyaW5ncyBiZWNhdXNlIGNvbXBhcmluZyBjbGFzc2VzIGJldHdlZW4gd2luZG93cyBkb2VzbnQgd29ya1xuXHRcdFx0ZXZlbnRDbGFzcyA9IG9wdGlvbnMuZXZlbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKCBldmVudENsYXNzICE9PSBcIk1vdXNlRXZlbnRcIiAmJlxuICAgICAgICAgICAgZXZlbnRDbGFzcyAhPT0gXCJDdXN0b21FdmVudFwiICYmXG5cdFx0XHRldmVudENsYXNzICE9PSBcIlBvaW50ZXJFdmVudFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkV2ZW50IHBhc3NlZCB0byBDb250ZXh0TWVudSBpcyBub3Qgb2YgdHlwZSBNb3VzZUV2ZW50IG9yIEN1c3RvbUV2ZW50LiBJZ25vcmluZyBpdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZXZlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByb290LmNsYXNzTmFtZSA9IFwibGl0ZWdyYXBoIGxpdGVjb250ZXh0bWVudSBsaXRlbWVudWJhci1wYW5lbFwiO1xuICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJvb3QuY2xhc3NOYW1lICs9IFwiIFwiICsgb3B0aW9ucy5jbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5zdHlsZS5taW5XaWR0aCA9IDEwMDtcbiAgICAgICAgcm9vdC5zdHlsZS5taW5IZWlnaHQgPSAxMDA7XG4gICAgICAgIHJvb3Quc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcm9vdC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgIH0sIDEwMCk7IC8vZGVsYXkgc28gdGhlIG1vdXNlIHVwIGV2ZW50IGlzIG5vdCBjYXVnaHQgYnkgdGhpcyBlbGVtZW50XG5cbiAgICAgICAgLy90aGlzIHByZXZlbnRzIHRoZSBkZWZhdWx0IGNvbnRleHQgYnJvd3NlciBtZW51IHRvIG9wZW4gaW4gY2FzZSB0aGlzIG1lbnUgd2FzIGNyZWF0ZWQgd2hlbiBwcmVzc2luZyByaWdodCBidXR0b25cbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJtb3VzZXVwXCIsXG4gICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJjb250ZXh0bWVudVwiLFxuICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcmlnaHQgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBvbl9tb3VzZV93aGVlbChlKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQocm9vdC5zdHlsZS50b3ApO1xuICAgICAgICAgICAgcm9vdC5zdHlsZS50b3AgPVxuICAgICAgICAgICAgICAgIChwb3MgKyBlLmRlbHRhWSAqIG9wdGlvbnMuc2Nyb2xsX3NwZWVkKS50b0ZpeGVkKCkgKyBcInB4XCI7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5zY3JvbGxfc3BlZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Nyb2xsX3NwZWVkID0gMC4xO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgb25fbW91c2Vfd2hlZWwsIHRydWUpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIG9uX21vdXNlX3doZWVsLCB0cnVlKTtcblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJsaXRlbWVudS10aXRsZVwiO1xuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZW50cmllc1xuICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHZhbHVlcy5jb25zdHJ1Y3RvciA9PSBBcnJheSA/IHZhbHVlc1tpXSA6IGk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmIG5hbWUuY29uc3RydWN0b3IgIT09IFN0cmluZykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmNvbnRlbnQgPT09IHVuZGVmaW5lZCA/IFN0cmluZyhuYW1lKSA6IG5hbWUuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBudW0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2xvc2Ugb24gbGVhdmVcbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5sb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QuY2xvc2luZ190aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyb290LmNsb3NpbmdfdGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdC5jbG9zaW5nX3RpbWVyID0gc2V0VGltZW91dCh0aGF0LmNsb3NlLmJpbmQodGhhdCwgZSksIDUwMCk7XG4gICAgICAgICAgICAvL3RoYXQuY2xvc2UoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHJvb3QuY2xvc2luZ190aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyb290LmNsb3NpbmdfdGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvL2luc2VydCBiZWZvcmUgY2hlY2tpbmcgcG9zaXRpb25cbiAgICAgICAgdmFyIHJvb3RfZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnQpIHtcbiAgICAgICAgICAgIHJvb3RfZG9jdW1lbnQgPSBvcHRpb25zLmV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb290X2RvY3VtZW50KSB7XG4gICAgICAgICAgICByb290X2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cblxuXHRcdGlmKCByb290X2RvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IClcblx0ICAgICAgICByb290X2RvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKHJvb3QpO1xuXHRcdGVsc2Vcblx0XHQgICAgcm9vdF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJvb3QpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBiZXN0IHBvc2l0aW9uXG4gICAgICAgIHZhciBsZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgICAgIHZhciB0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudCkge1xuICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMuZXZlbnQuY2xpZW50WCAtIDEwO1xuICAgICAgICAgICAgdG9wID0gb3B0aW9ucy5ldmVudC5jbGllbnRZIC0gMTA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgICAgICAgICAgIHRvcCAtPSAyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50TWVudSkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gb3B0aW9ucy5wYXJlbnRNZW51LnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBib2R5X3JlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHJvb3RfcmVjdCA9IHJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRpZihib2R5X3JlY3QuaGVpZ2h0ID09IDApXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJkb2N1bWVudC5ib2R5IGhlaWdodCBpcyAwLiBUaGF0IGlzIGRhbmdlcm91cywgc2V0IGh0bWwsYm9keSB7IGhlaWdodDogMTAwJTsgfVwiKTtcblxuICAgICAgICAgICAgaWYgKGJvZHlfcmVjdC53aWR0aCAmJiBsZWZ0ID4gYm9keV9yZWN0LndpZHRoIC0gcm9vdF9yZWN0LndpZHRoIC0gMTApIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYm9keV9yZWN0LndpZHRoIC0gcm9vdF9yZWN0LndpZHRoIC0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9keV9yZWN0LmhlaWdodCAmJiB0b3AgPiBib2R5X3JlY3QuaGVpZ2h0IC0gcm9vdF9yZWN0LmhlaWdodCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gYm9keV9yZWN0LmhlaWdodCAtIHJvb3RfcmVjdC5oZWlnaHQgLSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3Quc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgIHJvb3Quc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNjYWxlKSB7XG4gICAgICAgICAgICByb290LnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyBvcHRpb25zLnNjYWxlICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwibGl0ZW1lbnUtZW50cnkgc3VibWVudVwiO1xuXG4gICAgICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VwYXJhdG9yXCIpO1xuICAgICAgICAgICAgLy9lbGVtZW50LmlubmVySFRNTCA9IFwiPGhyLz5cIlxuICAgICAgICAgICAgLy9jb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdmFsdWUgJiYgdmFsdWUudGl0bGUgPyB2YWx1ZS50aXRsZSA6IG5hbWU7XG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3VibWVudSB8fCB2YWx1ZS5oYXNfc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoYXNfc3VibWVudVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhc2V0W1widmFsdWVcIl0gPSBuYW1lO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub25jbGlja19jYWxsYmFjayA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRhdGFzZXRbXCJ2YWx1ZVwiXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyB2YWx1ZS5jbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGlubmVyX29uY2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9vcGVuKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGlubmVyX292ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb3ZlcihlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuaGFzX3N1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIGl0IGlzIGEgc3VibWVudSwgYXV0b29wZW4gbGlrZSB0aGUgaXRlbSB3YXMgY2xpY2tlZFxuICAgICAgICAgICAgaW5uZXJfb25jbGljay5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9tZW51IG9wdGlvbiBjbGlja2VkXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX29uY2xpY2soZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjbG9zZV9wYXJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhhdC5jdXJyZW50X3N1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmN1cnJlbnRfc3VibWVudS5jbG9zZShlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9nbG9iYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBvcHRpb25zLmNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm5vZGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zcGVjaWFsIGNhc2VzXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICAgICFvcHRpb25zLmlnbm9yZV9pdGVtX2NhbGxiYWNrcyAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5kaXNhYmxlZCAhPT0gdHJ1ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvL2l0ZW0gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB2YWx1ZS5jYWxsYmFjay5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5leHRyYVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAociA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VfcGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnN1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5zdWJtZW51Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ29udGV4dE1lbnUgc3VibWVudSBuZWVkcyBvcHRpb25zXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Ym1lbnUgPSBuZXcgdGhhdC5jb25zdHJ1Y3Rvcih2YWx1ZS5zdWJtZW51Lm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB2YWx1ZS5zdWJtZW51LmNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZW51OiB0aGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlX2l0ZW1fY2FsbGJhY2tzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1Ym1lbnUuaWdub3JlX2l0ZW1fY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHZhbHVlLnN1Ym1lbnUudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogdmFsdWUuc3VibWVudS5leHRyYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9vcGVuOiBvcHRpb25zLmF1dG9vcGVuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZV9wYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbG9zZV9wYXJlbnQgJiYgIXRoYXQubG9jaykge1xuICAgICAgICAgICAgICAgIHRoYXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihlLCBpZ25vcmVfcGFyZW50X21lbnUpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudE1lbnUgJiYgIWlnbm9yZV9wYXJlbnRfbWVudSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50TWVudS5jdXJyZW50X3N1Ym1lbnUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWVudS5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBlICYmXG4gICAgICAgICAgICAgICAgIUNvbnRleHRNZW51LmlzQ3Vyc29yT3ZlckVsZW1lbnQoZSwgdGhpcy5wYXJlbnRNZW51LnJvb3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBDb250ZXh0TWVudS50cmlnZ2VyKHRoaXMucGFyZW50TWVudS5yb290LCBcIm1vdXNlbGVhdmVcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudF9zdWJtZW51KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfc3VibWVudS5jbG9zZShlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJvb3QuY2xvc2luZ190aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucm9vdC5jbG9zaW5nX3RpbWVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL3RoaXMgY29kZSBpcyB1c2VkIHRvIHRyaWdnZXIgZXZlbnRzIGVhc2lseSAodXNlZCBpbiB0aGUgY29udGV4dCBtZW51IG1vdXNlbGVhdmVcbiAgICBDb250ZXh0TWVudS50cmlnZ2VyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnRfbmFtZSwgcGFyYW1zLCBvcmlnaW4pIHtcbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnRfbmFtZSwgdHJ1ZSwgdHJ1ZSwgcGFyYW1zKTsgLy9jYW5CdWJibGUsIGNhbmNlbGFibGUsIGRldGFpbFxuICAgICAgICBldnQuc3JjRWxlbWVudCA9IG9yaWdpbjtcbiAgICAgICAgaWYgKGVsZW1lbnQuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5fX2V2ZW50cykge1xuICAgICAgICAgICAgZWxlbWVudC5fX2V2ZW50cy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbHNlIG5vdGhpbmcgc2VlbXMgYmluZGVkIGhlcmUgc28gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH07XG5cbiAgICAvL3JldHVybnMgdGhlIHRvcCBtb3N0IG1lbnVcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuZ2V0VG9wTWVudSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudE1lbnUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucGFyZW50TWVudS5nZXRUb3BNZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5nZXRGaXJzdEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50TWVudSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJlbnRNZW51LmdldEZpcnN0RXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmV2ZW50O1xuICAgIH07XG5cbiAgICBDb250ZXh0TWVudS5pc0N1cnNvck92ZXJFbGVtZW50ID0gZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBldmVudC5jbGllbnRYO1xuICAgICAgICB2YXIgdG9wID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0b3AgPiByZWN0LnRvcCAmJlxuICAgICAgICAgICAgdG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAmJlxuICAgICAgICAgICAgbGVmdCA+IHJlY3QubGVmdCAmJlxuICAgICAgICAgICAgbGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5Db250ZXh0TWVudSA9IENvbnRleHRNZW51O1xuXG4gICAgTGl0ZUdyYXBoLmNsb3NlQWxsQ29udGV4dE1lbnVzID0gZnVuY3Rpb24ocmVmX3dpbmRvdykge1xuICAgICAgICByZWZfd2luZG93ID0gcmVmX3dpbmRvdyB8fCB3aW5kb3c7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gcmVmX3dpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmxpdGVjb250ZXh0bWVudVwiKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0W2ldLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFtpXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGguZXh0ZW5kQ2xhc3MgPSBmdW5jdGlvbih0YXJnZXQsIG9yaWdpbikge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9yaWdpbikge1xuICAgICAgICAgICAgLy9jb3B5IGNsYXNzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtpXSA9IG9yaWdpbltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmlnaW4ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAvL2NvcHkgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb3JpZ2luLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vb25seSBlbnVtZXJhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW4ucHJvdG90eXBlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYXZvaWQgb3ZlcndyaXRpbmcgZXhpc3Rpbmcgb25lc1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvcHkgZ2V0dGVyc1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGVbaV0gPSBvcmlnaW4ucHJvdG90eXBlW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vYW5kIHNldHRlcnNcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4ucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oaSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8vdXNlZCBieSBzb21lIHdpZGdldHMgdG8gcmVuZGVyIGEgY3VydmUgZWRpdG9yXG5cdGZ1bmN0aW9uIEN1cnZlRWRpdG9yKCBwb2ludHMgKVxuXHR7XG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IC0xO1xuXHRcdHRoaXMubmVhcmVzdCA9IC0xO1xuXHRcdHRoaXMuc2l6ZSA9IG51bGw7IC8vc3RvcmVzIGxhc3Qgc2l6ZSB1c2VkXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5tYXJnaW4gPSA1O1xuXHR9XG5cblx0Q3VydmVFZGl0b3Iuc2FtcGxlQ3VydmUgPSBmdW5jdGlvbihmLHBvaW50cylcblx0e1xuXHRcdGlmKCFwb2ludHMpXG5cdFx0XHRyZXR1cm47XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHR2YXIgcG4gPSBwb2ludHNbaSsxXTtcblx0XHRcdGlmKHBuWzBdIDwgZilcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgciA9IChwblswXSAtIHBbMF0pO1xuXHRcdFx0aWYoIE1hdGguYWJzKHIpIDwgMC4wMDAwMSApXG5cdFx0XHRcdHJldHVybiBwWzFdO1xuXHRcdFx0dmFyIGxvY2FsX2YgPSAoZiAtIHBbMF0pIC8gcjtcblx0XHRcdHJldHVybiBwWzFdICogKDEuMCAtIGxvY2FsX2YpICsgcG5bMV0gKiBsb2NhbF9mO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdEN1cnZlRWRpdG9yLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oIGN0eCwgc2l6ZSwgZ3JhcGhjYW52YXMsIGJhY2tncm91bmRfY29sb3IsIGxpbmVfY29sb3IsIGluYWN0aXZlIClcblx0e1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRpZighcG9pbnRzKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cdFx0dmFyIHcgPSBzaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXHRcdHZhciBoID0gc2l6ZVsxXSAtIHRoaXMubWFyZ2luICogMjtcblxuXHRcdGxpbmVfY29sb3IgPSBsaW5lX2NvbG9yIHx8IFwiIzY2NlwiO1xuXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHgudHJhbnNsYXRlKHRoaXMubWFyZ2luLHRoaXMubWFyZ2luKTtcblxuXHRcdGlmKGJhY2tncm91bmRfY29sb3IpXG5cdFx0e1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzExMVwiO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsMCx3LGgpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzIyMlwiO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHcqMC41LDAsMSxoKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IFwiIzMzM1wiO1xuXHRcdFx0Y3R4LnN0cm9rZVJlY3QoMCwwLHcsaCk7XG5cdFx0fVxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVfY29sb3I7XG5cdFx0aWYoaW5hY3RpdmUpXG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSAwLjU7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHRjdHgubGluZVRvKCBwWzBdICogdywgKDEuMCAtIHBbMV0pICogaCApO1xuXHRcdH1cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRpZighaW5hY3RpdmUpXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0ZWQgPT0gaSA/IFwiI0ZGRlwiIDogKHRoaXMubmVhcmVzdCA9PSBpID8gXCIjREREXCIgOiBcIiNBQUFcIik7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyggcFswXSAqIHcsICgxLjAgLSBwWzFdKSAqIGgsIDIsIDAsIE1hdGguUEkgKiAyICk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxuXG5cdC8vbG9jYWxwb3MgaXMgbW91c2UgaW4gY3VydmUgZWRpdG9yIHNwYWNlXG5cdEN1cnZlRWRpdG9yLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKCBsb2NhbHBvcywgZ3JhcGhjYW52YXMgKVxuXHR7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGlmKCFwb2ludHMpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYoIGxvY2FscG9zWzFdIDwgMCApXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvL3RoaXMuY2FwdHVyZUlucHV0KHRydWUpO1xuXHRcdHZhciB3ID0gdGhpcy5zaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXHRcdHZhciBoID0gdGhpcy5zaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXHRcdHZhciB4ID0gbG9jYWxwb3NbMF0gLSB0aGlzLm1hcmdpbjtcblx0XHR2YXIgeSA9IGxvY2FscG9zWzFdIC0gdGhpcy5tYXJnaW47XG5cdFx0dmFyIHBvcyA9IFt4LHldO1xuXHRcdHZhciBtYXhfZGlzdCA9IDMwIC8gZ3JhcGhjYW52YXMuZHMuc2NhbGU7XG5cdFx0Ly9zZWFyY2ggY2xvc2VyIG9uZVxuXHRcdHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmdldENsb3NlclBvaW50KHBvcywgbWF4X2Rpc3QpO1xuXHRcdC8vY3JlYXRlIG9uZVxuXHRcdGlmKHRoaXMuc2VsZWN0ZWQgPT0gLTEpXG5cdFx0e1xuXHRcdFx0dmFyIHBvaW50ID0gW3ggLyB3LCAxIC0geSAvIGhdO1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcblx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBwb2ludHMuaW5kZXhPZihwb2ludCk7XG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYodGhpcy5zZWxlY3RlZCAhPSAtMSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oIGxvY2FscG9zLCBncmFwaGNhbnZhcyApXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcyA9IHRoaXMuc2VsZWN0ZWQ7XG5cdFx0aWYocyA8IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHggPSAobG9jYWxwb3NbMF0gLSB0aGlzLm1hcmdpbikgLyAodGhpcy5zaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyICk7XG5cdFx0dmFyIHkgPSAobG9jYWxwb3NbMV0gLSB0aGlzLm1hcmdpbikgLyAodGhpcy5zaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyICk7XG5cdFx0dmFyIGN1cnZlcG9zID0gWyhsb2NhbHBvc1swXSAtIHRoaXMubWFyZ2luKSwobG9jYWxwb3NbMV0gLSB0aGlzLm1hcmdpbildO1xuXHRcdHZhciBtYXhfZGlzdCA9IDMwIC8gZ3JhcGhjYW52YXMuZHMuc2NhbGU7XG5cdFx0dGhpcy5fbmVhcmVzdCA9IHRoaXMuZ2V0Q2xvc2VyUG9pbnQoY3VydmVwb3MsIG1heF9kaXN0KTtcblx0XHR2YXIgcG9pbnQgPSBwb2ludHNbc107XG5cdFx0aWYocG9pbnQpXG5cdFx0e1xuXHRcdFx0dmFyIGlzX2VkZ2VfcG9pbnQgPSBzID09IDAgfHwgcyA9PSBwb2ludHMubGVuZ3RoIC0gMTtcblx0XHRcdGlmKCAhaXNfZWRnZV9wb2ludCAmJiAobG9jYWxwb3NbMF0gPCAtMTAgfHwgbG9jYWxwb3NbMF0gPiB0aGlzLnNpemVbMF0gKyAxMCB8fCBsb2NhbHBvc1sxXSA8IC0xMCB8fCBsb2NhbHBvc1sxXSA+IHRoaXMuc2l6ZVsxXSArIDEwKSApXG5cdFx0XHR7XG5cdFx0XHRcdHBvaW50cy5zcGxpY2UocywxKTtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IC0xO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiggIWlzX2VkZ2VfcG9pbnQgKSAvL25vdCBlZGdlc1xuXHRcdFx0XHRwb2ludFswXSA9IE1hdGguY2xhbXAoeCwwLDEpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwb2ludFswXSA9IHMgPT0gMCA/IDAgOiAxO1xuXHRcdFx0cG9pbnRbMV0gPSAxLjAgLSBNYXRoLmNsYW1wKHksMCwxKTtcblx0XHRcdHBvaW50cy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG5cdFx0XHR0aGlzLnNlbGVjdGVkID0gcG9pbnRzLmluZGV4T2YocG9pbnQpO1xuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKCBsb2NhbHBvcywgZ3JhcGhjYW52YXMgKVxuXHR7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IC0xO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdEN1cnZlRWRpdG9yLnByb3RvdHlwZS5nZXRDbG9zZXJQb2ludCA9IGZ1bmN0aW9uKHBvcywgbWF4X2Rpc3QpXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybiAtMTtcblx0XHRtYXhfZGlzdCA9IG1heF9kaXN0IHx8IDMwO1xuXHRcdHZhciB3ID0gKHRoaXMuc2l6ZVswXSAtIHRoaXMubWFyZ2luICogMik7XG5cdFx0dmFyIGggPSAodGhpcy5zaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyKTtcblx0XHR2YXIgbnVtID0gcG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgcDIgPSBbMCwwXTtcblx0XHR2YXIgbWluX2Rpc3QgPSAxMDAwMDAwO1xuXHRcdHZhciBjbG9zZXN0ID0gLTE7XG5cdFx0dmFyIGxhc3RfdmFsaWQgPSAtMTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHRwMlswXSA9IHBbMF0gKiB3O1xuXHRcdFx0cDJbMV0gPSAoMS4wIC0gcFsxXSkgKiBoO1xuXHRcdFx0aWYocDJbMF0gPCBwb3NbMF0pXG5cdFx0XHRcdGxhc3RfdmFsaWQgPSBpO1xuXHRcdFx0dmFyIGRpc3QgPSB2ZWMyLmRpc3RhbmNlKHBvcyxwMik7XG5cdFx0XHRpZihkaXN0ID4gbWluX2Rpc3QgfHwgZGlzdCA+IG1heF9kaXN0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNsb3Nlc3QgPSBpO1xuXHRcdFx0bWluX2Rpc3QgPSBkaXN0O1xuXHRcdH1cblx0XHRyZXR1cm4gY2xvc2VzdDtcblx0fVxuXG5cdExpdGVHcmFwaC5DdXJ2ZUVkaXRvciA9IEN1cnZlRWRpdG9yO1xuXG4gICAgLy91c2VkIHRvIGNyZWF0ZSBub2RlcyBmcm9tIHdyYXBwaW5nIGZ1bmN0aW9uc1xuICAgIExpdGVHcmFwaC5nZXRQYXJhbWV0ZXJOYW1lcyA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jICsgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bL11bL10uKiQvZ20sIFwiXCIpIC8vIHN0cmlwIHNpbmdsZS1saW5lIGNvbW1lbnRzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCBcIlwiKSAvLyBzdHJpcCB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1svXVsqXVteLypdKlsqXVsvXS9nLCBcIlwiKSAvLyBzdHJpcCBtdWx0aS1saW5lIGNvbW1lbnRzICAvKiovXG4gICAgICAgICAgICAuc3BsaXQoXCIpe1wiLCAxKVswXVxuICAgICAgICAgICAgLnJlcGxhY2UoL15bXihdKlsoXS8sIFwiXCIpIC8vIGV4dHJhY3QgdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC5yZXBsYWNlKC89W14sXSsvZywgXCJcIikgLy8gc3RyaXAgYW55IEVTNiBkZWZhdWx0c1xuICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTsgLy8gc3BsaXQgJiBmaWx0ZXIgW1wiXCJdXG4gICAgfTtcblxuICAgIE1hdGguY2xhbXAgPSBmdW5jdGlvbih2LCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID4gdiA/IGEgOiBiIDwgdiA/IGIgOiB2O1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiICYmICF3aW5kb3dbXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl0pIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgfTtcbiAgICB9XG59KSh0aGlzKTtcblxuaWYgKHR5cGVvZiBleHBvcnRzICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBleHBvcnRzLkxpdGVHcmFwaCA9IHRoaXMuTGl0ZUdyYXBoO1xufVxuXG4vL2Jhc2ljIG5vZGVzXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XG5cbiAgICAvL0NvbnN0YW50XG4gICAgZnVuY3Rpb24gVGltZSgpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJpbiBtc1wiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJpbiBzZWNcIiwgXCJudW1iZXJcIik7XG4gICAgfVxuXG4gICAgVGltZS50aXRsZSA9IFwiVGltZVwiO1xuICAgIFRpbWUuZGVzYyA9IFwiVGltZVwiO1xuXG4gICAgVGltZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmdyYXBoLmdsb2JhbHRpbWUgKiAxMDAwKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuZ3JhcGguZ2xvYmFsdGltZSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvdGltZVwiLCBUaW1lKTtcblxuICAgIC8vU3ViZ3JhcGg6IGEgbm9kZSB0aGF0IGNvbnRhaW5zIGEgZ3JhcGhcbiAgICBmdW5jdGlvbiBTdWJncmFwaCgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCA4MF07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgZW5hYmxlZDogdHJ1ZSB9O1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vY3JlYXRlIGlubmVyIGdyYXBoXG4gICAgICAgIHRoaXMuc3ViZ3JhcGggPSBuZXcgTGl0ZUdyYXBoLkxHcmFwaCgpO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLl9zdWJncmFwaF9ub2RlID0gdGhpcztcbiAgICAgICAgdGhpcy5zdWJncmFwaC5faXNfc3ViZ3JhcGggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25UcmlnZ2VyID0gdGhpcy5vblN1YmdyYXBoVHJpZ2dlci5iaW5kKHRoaXMpO1xuXG5cdFx0Ly9ub2RlcyBpbnB1dCBub2RlIGFkZGVkIGluc2lkZVxuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uSW5wdXRBZGRlZCA9IHRoaXMub25TdWJncmFwaE5ld0lucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25JbnB1dFJlbmFtZWQgPSB0aGlzLm9uU3ViZ3JhcGhSZW5hbWVkSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbklucHV0VHlwZUNoYW5nZWQgPSB0aGlzLm9uU3ViZ3JhcGhUeXBlQ2hhbmdlSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbklucHV0UmVtb3ZlZCA9IHRoaXMub25TdWJncmFwaFJlbW92ZWRJbnB1dC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25PdXRwdXRBZGRlZCA9IHRoaXMub25TdWJncmFwaE5ld091dHB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uT3V0cHV0UmVuYW1lZCA9IHRoaXMub25TdWJncmFwaFJlbmFtZWRPdXRwdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbk91dHB1dFR5cGVDaGFuZ2VkID0gdGhpcy5vblN1YmdyYXBoVHlwZUNoYW5nZU91dHB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uT3V0cHV0UmVtb3ZlZCA9IHRoaXMub25TdWJncmFwaFJlbW92ZWRPdXRwdXQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBTdWJncmFwaC50aXRsZSA9IFwiU3ViZ3JhcGhcIjtcbiAgICBTdWJncmFwaC5kZXNjID0gXCJHcmFwaCBpbnNpZGUgYSBub2RlXCI7XG4gICAgU3ViZ3JhcGgudGl0bGVfY29sb3IgPSBcIiMzMzRcIjtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1tcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdXTtcbiAgICB9O1xuXG5cdC8qXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uRHJhd1RpdGxlID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzU1NVwiO1xuICAgICAgICB2YXIgdyA9IExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgdmFyIHggPSB0aGlzLnNpemVbMF0gLSB3O1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgLXcsIHcsIHcpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMzMzXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgdyAqIDAuMiwgLXcgKiAwLjYpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3ICogMC44LCAtdyAqIDAuNik7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcgKiAwLjUsIC13ICogMC4zKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9O1xuXHQqL1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uRGJsQ2xpY2sgPSBmdW5jdGlvbihlLCBwb3MsIGdyYXBoY2FudmFzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdyYXBoY2FudmFzLm9wZW5TdWJncmFwaCh0aGF0LnN1YmdyYXBoKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH07XG5cblx0LypcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBwb3MsIGdyYXBoY2FudmFzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLmZsYWdzLmNvbGxhcHNlZCAmJlxuICAgICAgICAgICAgcG9zWzBdID4gdGhpcy5zaXplWzBdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICYmXG4gICAgICAgICAgICBwb3NbMV0gPCAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5vcGVuU3ViZ3JhcGgodGhhdC5zdWJncmFwaCk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXHQqL1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uQWN0aW9uKGFjdGlvbiwgcGFyYW0pO1xuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZW5hYmxlZFwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2VuZCBpbnB1dHMgdG8gc3ViZ3JhcGggZ2xvYmFsIGlucHV0c1xuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldElucHV0RGF0YShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmdyYXBoLnNldElucHV0RGF0YShpbnB1dC5uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2V4ZWN1dGVcbiAgICAgICAgdGhpcy5zdWJncmFwaC5ydW5TdGVwKCk7XG5cbiAgICAgICAgLy9zZW5kIHN1YmdyYXBoIGdsb2JhbCBvdXRwdXRzIHRvIG91dHB1dHNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3ViZ3JhcGguZ2V0T3V0cHV0RGF0YShvdXRwdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUuc2VuZEV2ZW50VG9BbGxOb2RlcyA9IGZ1bmN0aW9uKGV2ZW50bmFtZSwgcGFyYW0sIG1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zdWJncmFwaC5zZW5kRXZlbnRUb0FsbE5vZGVzKGV2ZW50bmFtZSwgcGFyYW0sIG1vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXHRTdWJncmFwaC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCwgZ3JhcGhjYW52YXMsIGNhbnZhcywgcG9zKVxuXHR7XG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgeSA9IHRoaXMuc2l6ZVsxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDAuNTtcblxuXHRcdC8vYnV0dG9uXG5cdFx0dmFyIG92ZXIgPSBMaXRlR3JhcGguaXNJbnNpZGVSZWN0YW5nbGUocG9zWzBdLHBvc1sxXSx0aGlzLnBvc1swXSx0aGlzLnBvc1sxXSArIHksdGhpcy5zaXplWzBdLExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IG92ZXIgPyBcIiM1NTVcIiA6IFwiIzIyMlwiO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRpZiAodGhpcy5fc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSlcblx0XHRcdGN0eC5yZWN0KDAsIHksIHRoaXMuc2l6ZVswXSsxLCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpO1xuXHRcdGVsc2Vcblx0XHRcdGN0eC5yb3VuZFJlY3QoIDAsIHksIHRoaXMuc2l6ZVswXSsxLCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsIDAsIDgpO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHQvL2J1dHRvblxuXHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdGN0eC5mb250ID0gXCIyNHB4IEFyaWFsXCI7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IG92ZXIgPyBcIiNERERcIiA6IFwiIzk5OVwiO1xuXHRcdGN0eC5maWxsVGV4dCggXCIrXCIsIHRoaXMuc2l6ZVswXSAqIDAuNSwgeSArIDI0ICk7XG5cdH1cblxuXHRTdWJncmFwaC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBsb2NhbHBvcywgZ3JhcGhjYW52YXMpXG5cdHtcblx0XHR2YXIgeSA9IHRoaXMuc2l6ZVsxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDAuNTtcblx0XHRpZihsb2NhbHBvc1sxXSA+IHkpXG5cdFx0e1xuXHRcdFx0Z3JhcGhjYW52YXMuc2hvd1N1YmdyYXBoUHJvcGVydGllc0RpYWxvZyh0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRTdWJncmFwaC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbigpXG5cdHtcblx0XHR2YXIgbnVtX2lucHV0cyA9IHRoaXMuaW5wdXRzID8gdGhpcy5pbnB1dHMubGVuZ3RoIDogMDtcblx0XHR2YXIgbnVtX291dHB1dHMgPSB0aGlzLm91dHB1dHMgPyB0aGlzLm91dHB1dHMubGVuZ3RoIDogMDtcblx0XHRyZXR1cm4gWyAyMDAsIE1hdGgubWF4KG51bV9pbnB1dHMsbnVtX291dHB1dHMpICogTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgXTtcblx0fVxuXG4gICAgLy8qKioqIElOUFVUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoVHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50LCBwYXJhbSkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3QoZXZlbnQpO1xuICAgICAgICBpZiAoc2xvdCAhPSAtMSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdChzbG90KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaE5ld0lucHV0ID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChuYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vYWRkIGlucHV0IHRvIHRoZSBub2RlXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoUmVuYW1lZElucHV0ID0gZnVuY3Rpb24ob2xkbmFtZSwgbmFtZSkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChvbGRuYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKHNsb3QpO1xuICAgICAgICBpbmZvLm5hbWUgPSBuYW1lO1xuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFR5cGVDaGFuZ2VJbnB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRJbnB1dFNsb3QobmFtZSk7XG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLmdldElucHV0SW5mbyhzbG90KTtcbiAgICAgICAgaW5mby50eXBlID0gdHlwZTtcbiAgICB9O1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhSZW1vdmVkSW5wdXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlSW5wdXQoc2xvdCk7XG4gICAgfTtcblxuICAgIC8vKioqKiBPVVRQVVRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhOZXdPdXRwdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kT3V0cHV0U2xvdChuYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoUmVuYW1lZE91dHB1dCA9IGZ1bmN0aW9uKG9sZG5hbWUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KG9sZG5hbWUpO1xuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5nZXRPdXRwdXRJbmZvKHNsb3QpO1xuICAgICAgICBpbmZvLm5hbWUgPSBuYW1lO1xuICAgIH07XG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFR5cGVDaGFuZ2VPdXRwdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kT3V0cHV0U2xvdChuYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0T3V0cHV0SW5mbyhzbG90KTtcbiAgICAgICAgaW5mby50eXBlID0gdHlwZTtcbiAgICB9O1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhSZW1vdmVkT3V0cHV0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChuYW1lKTtcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZU91dHB1dChzbG90KTtcbiAgICB9O1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBTdWJncmFwaC5wcm90b3R5cGUuZ2V0RXh0cmFNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKGdyYXBoY2FudmFzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIk9wZW5cIixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLm9wZW5TdWJncmFwaCh0aGF0LnN1YmdyYXBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgc2l6ZVsxXSArPSAyMDtcbiAgICB9O1xuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IExpdGVHcmFwaC5MR3JhcGhOb2RlLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICAgICAgZGF0YS5zdWJncmFwaCA9IHRoaXMuc3ViZ3JhcGguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgLy9ubyBuZWVkIHRvIGRlZmluZSBub2RlLmNvbmZpZ3VyZSwgdGhlIGRlZmF1bHQgbWV0aG9kIGRldGVjdHMgbm9kZS5zdWJncmFwaCBhbmQgcGFzc2VzIHRoZSBvYmplY3QgdG8gbm9kZS5zdWJncmFwaC5jb25maWd1cmUoKVxuXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUodGhpcy50eXBlKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICBkZWxldGUgZGF0YVtcImlkXCJdO1xuICAgICAgICBkZWxldGUgZGF0YVtcImlucHV0c1wiXTtcbiAgICAgICAgZGVsZXRlIGRhdGFbXCJvdXRwdXRzXCJdO1xuICAgICAgICBub2RlLmNvbmZpZ3VyZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuXHRTdWJncmFwaC5wcm90b3R5cGUuYnVpbGRGcm9tTm9kZXMgPSBmdW5jdGlvbihub2Rlcylcblx0e1xuXHRcdC8vY2xlYXIgYWxsP1xuXHRcdC8vVE9ET1xuXG5cdFx0Ly9ub2RlcyB0aGF0IGNvbm5lY3QgZGF0YSBiZXR3ZWVuIHBhcmVudCBncmFwaCBhbmQgc3ViZ3JhcGhcblx0XHR2YXIgc3ViZ3JhcGhfaW5wdXRzID0gW107XG5cdFx0dmFyIHN1YmdyYXBoX291dHB1dHMgPSBbXTtcblxuXHRcdC8vbWFyayBpbm5lciBub2Rlc1xuXHRcdHZhciBpZHMgPSB7fTtcblx0XHR2YXIgbWluX3ggPSAwO1xuXHRcdHZhciBtYXhfeCA9IDA7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKVxuXHRcdHtcblx0XHRcdHZhciBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZHNbIG5vZGUuaWQgXSA9IG5vZGU7XG5cdFx0XHRtaW5feCA9IE1hdGgubWluKCBub2RlLnBvc1swXSwgbWluX3ggKTtcblx0XHRcdG1heF94ID0gTWF0aC5tYXgoIG5vZGUucG9zWzBdLCBtaW5feCApO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgbGFzdF9pbnB1dF95ID0gMDtcblx0XHR2YXIgbGFzdF9vdXRwdXRfeSA9IDA7XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdC8vY2hlY2sgaW5wdXRzXG5cdFx0XHRpZiggbm9kZS5pbnB1dHMgKVxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyArK2opXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tqXTtcblx0XHRcdFx0XHRpZiggIWlucHV0IHx8ICFpbnB1dC5saW5rIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdHZhciBsaW5rID0gbm9kZS5ncmFwaC5saW5rc1sgaW5wdXQubGluayBdO1xuXHRcdFx0XHRcdGlmKCFsaW5rKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYoIGlkc1sgbGluay5vcmlnaW5faWQgXSApXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHQvL3RoaXMuYWRkSW5wdXQoaW5wdXQubmFtZSxsaW5rLnR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuc3ViZ3JhcGguYWRkSW5wdXQoaW5wdXQubmFtZSxsaW5rLnR5cGUpO1xuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0dmFyIGlucHV0X25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcImdyYXBoL2lucHV0XCIpO1xuXHRcdFx0XHRcdHRoaXMuc3ViZ3JhcGguYWRkKCBpbnB1dF9ub2RlICk7XG5cdFx0XHRcdFx0aW5wdXRfbm9kZS5wb3MgPSBbbWluX3ggLSAyMDAsIGxhc3RfaW5wdXRfeSBdO1xuXHRcdFx0XHRcdGxhc3RfaW5wdXRfeSArPSAxMDA7XG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0fVxuXG5cdFx0XHQvL2NoZWNrIG91dHB1dHNcblx0XHRcdGlmKCBub2RlLm91dHB1dHMgKVxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgKytqKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIG91dHB1dCA9IG5vZGUub3V0cHV0c1tqXTtcblx0XHRcdFx0XHRpZiggIW91dHB1dCB8fCAhb3V0cHV0LmxpbmtzIHx8ICFvdXRwdXQubGlua3MubGVuZ3RoIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdHZhciBpc19leHRlcm5hbCA9IGZhbHNlO1xuXHRcdFx0XHRcdGZvcih2YXIgayA9IDA7IGsgPCBvdXRwdXQubGlua3MubGVuZ3RoOyArK2spXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGxpbmsgPSBub2RlLmdyYXBoLmxpbmtzWyBvdXRwdXQubGlua3Nba10gXTtcblx0XHRcdFx0XHRcdGlmKCFsaW5rKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGlmKCBpZHNbIGxpbmsudGFyZ2V0X2lkIF0gKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGlzX2V4dGVybmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighaXNfZXh0ZXJuYWwpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHQvL3RoaXMuYWRkT3V0cHV0KG91dHB1dC5uYW1lLG91dHB1dC50eXBlKTtcblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdHZhciBvdXRwdXRfbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwiZ3JhcGgvb3V0cHV0XCIpO1xuXHRcdFx0XHRcdHRoaXMuc3ViZ3JhcGguYWRkKCBvdXRwdXRfbm9kZSApO1xuXHRcdFx0XHRcdG91dHB1dF9ub2RlLnBvcyA9IFttYXhfeCArIDUwLCBsYXN0X291dHB1dF95IF07XG5cdFx0XHRcdFx0bGFzdF9vdXRwdXRfeSArPSAxMDA7XG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vZGV0ZWN0IGlucHV0cyBhbmQgb3V0cHV0c1xuXHRcdFx0Ly9zcGxpdCBldmVyeSBjb25uZWN0aW9uIGluIHR3byBkYXRhX2Nvbm5lY3Rpb24gbm9kZXNcblx0XHRcdC8va2VlcCB0cmFjayBvZiBpbnRlcm5hbCBjb25uZWN0aW9uc1xuXHRcdFx0Ly9jb25uZWN0IGV4dGVybmFsIGNvbm5lY3Rpb25zXG5cblx0XHQvL2Nsb25lIG5vZGVzIGluc2lkZSBzdWJncmFwaCBhbmQgdHJ5IHRvIHJlY29ubmVjdCB0aGVtXG5cblx0XHQvL2Nvbm5lY3QgZWRnZSBzdWJncmFwaCBub2RlcyB0byBleHRhcm5hbCBjb25uZWN0aW9ucyBub2Rlc1xuXHR9XG5cbiAgICBMaXRlR3JhcGguU3ViZ3JhcGggPSBTdWJncmFwaDtcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoL3N1YmdyYXBoXCIsIFN1YmdyYXBoKTtcblxuICAgIC8vSW5wdXQgZm9yIGEgc3ViZ3JhcGhcbiAgICBmdW5jdGlvbiBHcmFwaElucHV0KCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIm51bWJlclwiKTtcblxuICAgICAgICB0aGlzLm5hbWVfaW5fZ3JhcGggPSBcIlwiO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRuYW1lOiBcIlwiLFxuXHRcdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcdHZhbHVlOiAwXG5cdFx0fTsgXG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubmFtZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcbiAgICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgICAgXCJOYW1lXCIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGF0LnNldFByb3BlcnR5KFwibmFtZVwiLHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnR5cGVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXG4gICAgICAgICAgICBcInRleHRcIixcbiAgICAgICAgICAgIFwiVHlwZVwiLFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnR5cGUsXG4gICAgICAgICAgICBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoYXQuc2V0UHJvcGVydHkoXCJ0eXBlXCIsdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy52YWx1ZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcbiAgICAgICAgICAgIFwibnVtYmVyXCIsXG4gICAgICAgICAgICBcIlZhbHVlXCIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUsXG4gICAgICAgICAgICBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zZXRQcm9wZXJ0eShcInZhbHVlXCIsdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE4MCwgOTBdO1xuICAgIH1cblxuICAgIEdyYXBoSW5wdXQudGl0bGUgPSBcIklucHV0XCI7XG4gICAgR3JhcGhJbnB1dC5kZXNjID0gXCJJbnB1dCBvZiB0aGUgZ3JhcGhcIjtcblxuXHRHcmFwaElucHV0LnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHRoaXMudXBkYXRlVHlwZSgpO1xuXHR9XG5cblx0Ly9lbnN1cmVzIHRoZSB0eXBlIGluIHRoZSBub2RlIG91dHB1dCBhbmQgdGhlIHR5cGUgaW4gdGhlIGFzc29jaWF0ZWQgZ3JhcGggaW5wdXQgYXJlIHRoZSBzYW1lXG5cdEdyYXBoSW5wdXQucHJvdG90eXBlLnVwZGF0ZVR5cGUgPSBmdW5jdGlvbigpXG5cdHtcblx0XHR2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xuXHRcdHRoaXMudHlwZV93aWRnZXQudmFsdWUgPSB0eXBlO1xuXG5cdFx0Ly91cGRhdGUgb3V0cHV0XG5cdFx0aWYodGhpcy5vdXRwdXRzWzBdLnR5cGUgIT0gdHlwZSlcblx0XHR7XG5cdCAgICAgICAgaWYgKCFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24odGhpcy5vdXRwdXRzWzBdLnR5cGUsdHlwZSkpXG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdE91dHB1dCgwKTtcblx0XHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gdHlwZTtcblx0XHR9XG5cblx0XHQvL3VwZGF0ZSB3aWRnZXRcblx0XHRpZih0eXBlID09IFwibnVtYmVyXCIpXG5cdFx0e1xuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC52YWx1ZSA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZSA9PSBcImJvb2xlYW5cIilcblx0XHR7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC50eXBlID0gXCJ0b2dnbGVcIjtcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlID09IFwic3RyaW5nXCIpXG5cdFx0e1xuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudHlwZSA9IFwidGV4dFwiO1xuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudmFsdWUgPSBcIlwiO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudHlwZSA9IG51bGw7XG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC52YWx1ZSA9IG51bGw7XG5cdFx0fVxuXHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlO1xuXG5cdFx0Ly91cGRhdGUgZ3JhcGhcblx0XHRpZiAodGhpcy5ncmFwaCAmJiB0aGlzLm5hbWVfaW5fZ3JhcGgpIHtcblx0XHRcdHRoaXMuZ3JhcGguY2hhbmdlSW5wdXRUeXBlKHRoaXMubmFtZV9pbl9ncmFwaCwgdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly90aGlzIGlzIGV4ZWN1dGVkIEFGVEVSIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZFxuXHRHcmFwaElucHV0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdilcblx0e1xuXHRcdGlmKCBuYW1lID09IFwibmFtZVwiIClcblx0XHR7XG5cdFx0XHRpZiAodiA9PSBcIlwiIHx8IHYgPT0gdGhpcy5uYW1lX2luX2dyYXBoIHx8IHYgPT0gXCJlbmFibGVkXCIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5ncmFwaClcblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMubmFtZV9pbl9ncmFwaCkge1xuXHRcdFx0XHRcdC8vYWxyZWFkeSBhZGRlZFxuXHRcdFx0XHRcdHRoaXMuZ3JhcGgucmVuYW1lSW5wdXQoIHRoaXMubmFtZV9pbl9ncmFwaCwgdiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGguYWRkSW5wdXQoIHYsIHRoaXMucHJvcGVydGllcy50eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy93aGF0IGlmIG5vdD8hXG5cdFx0XHR0aGlzLm5hbWVfd2lkZ2V0LnZhbHVlID0gdjtcblx0XHRcdHRoaXMubmFtZV9pbl9ncmFwaCA9IHY7XG5cdFx0fVxuXHRcdGVsc2UgaWYoIG5hbWUgPT0gXCJ0eXBlXCIgKVxuXHRcdHtcblx0XHRcdHRoaXMudXBkYXRlVHlwZSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmKCBuYW1lID09IFwidmFsdWVcIiApXG5cdFx0e1xuXHRcdH1cblx0fVxuXG4gICAgR3JhcGhJbnB1dC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcblxuICAgIEdyYXBoSW5wdXQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTbG90KDAsIHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHcmFwaElucHV0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BlcnRpZXMubmFtZTtcbiAgICAgICAgLy9yZWFkIGZyb20gZ2xvYmFsIGlucHV0XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmFwaC5pbnB1dHNbbmFtZV07XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEudmFsdWUgIT09IHVuZGVmaW5lZCA/IGRhdGEudmFsdWUgOiB0aGlzLnByb3BlcnRpZXMudmFsdWUgKTtcbiAgICB9O1xuXG4gICAgR3JhcGhJbnB1dC5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVfaW5fZ3JhcGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgucmVtb3ZlSW5wdXQodGhpcy5uYW1lX2luX2dyYXBoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGguR3JhcGhJbnB1dCA9IEdyYXBoSW5wdXQ7XG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaC9pbnB1dFwiLCBHcmFwaElucHV0KTtcblxuICAgIC8vT3V0cHV0IGZvciBhIHN1YmdyYXBoXG4gICAgZnVuY3Rpb24gR3JhcGhPdXRwdXQoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgXCJcIik7XG5cbiAgICAgICAgdGhpcy5uYW1lX2luX2dyYXBoID0gXCJcIjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm9wZXJ0aWVzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5uYW1lX2luX2dyYXBoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICh2ID09IFwiXCIgfHwgdiA9PSB0aGF0Lm5hbWVfaW5fZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5uYW1lX2luX2dyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdyYXBoLnJlbmFtZU91dHB1dCh0aGF0Lm5hbWVfaW5fZ3JhcGgsIHYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ3JhcGguYWRkT3V0cHV0KHYsIHRoYXQucHJvcGVydGllcy50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhhdC5uYW1lX3dpZGdldC52YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgdGhhdC5uYW1lX2luX2dyYXBoID0gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIFwidHlwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmlucHV0c1swXS50eXBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICh2ID09IFwiYWN0aW9uXCIgfHwgdiA9PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IExpdGVHcmFwaC5BQ1RJT047XG4gICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24odGhhdC5pbnB1dHNbMF0udHlwZSx2KSlcblx0XHRcdFx0XHR0aGF0LmRpc2Nvbm5lY3RJbnB1dCgwKTtcbiAgICAgICAgICAgICAgICB0aGF0LmlucHV0c1swXS50eXBlID0gdjtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5uYW1lX2luX2dyYXBoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdyYXBoLmNoYW5nZU91dHB1dFR5cGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm5hbWVfaW5fZ3JhcGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmlucHV0c1swXS50eXBlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoYXQudHlwZV93aWRnZXQudmFsdWUgPSB2IHx8IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm5hbWVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJOYW1lXCIsdGhpcy5wcm9wZXJ0aWVzLm5hbWUsXCJuYW1lXCIpO1xuICAgICAgICB0aGlzLnR5cGVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJUeXBlXCIsdGhpcy5wcm9wZXJ0aWVzLnR5cGUsXCJ0eXBlXCIpO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTgwLCA2MF07XG4gICAgfVxuXG4gICAgR3JhcGhPdXRwdXQudGl0bGUgPSBcIk91dHB1dFwiO1xuICAgIEdyYXBoT3V0cHV0LmRlc2MgPSBcIk91dHB1dCBvZiB0aGUgZ3JhcGhcIjtcblxuICAgIEdyYXBoT3V0cHV0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdGhpcy5ncmFwaC5zZXRPdXRwdXREYXRhKHRoaXMucHJvcGVydGllcy5uYW1lLCB0aGlzLl92YWx1ZSk7XG4gICAgfTtcblxuICAgIEdyYXBoT3V0cHV0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy50eXBlID09IExpdGVHcmFwaC5BQ1RJT04pIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgudHJpZ2dlcih0aGlzLnByb3BlcnRpZXMubmFtZSwgcGFyYW0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoT3V0cHV0LnByb3RvdHlwZS5vblJlbW92ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZV9pbl9ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVPdXRwdXQodGhpcy5uYW1lX2luX2dyYXBoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHcmFwaE91dHB1dC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5HcmFwaE91dHB1dCA9IEdyYXBoT3V0cHV0O1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGgvb3V0cHV0XCIsIEdyYXBoT3V0cHV0KTtcblxuICAgIC8vQ29uc3RhbnRcbiAgICBmdW5jdGlvbiBDb25zdGFudE51bWJlcigpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIDEuMCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInZhbHVlXCIsMSxcInZhbHVlXCIpO1xuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTgwLCAzMF07XG4gICAgfVxuXG4gICAgQ29uc3RhbnROdW1iZXIudGl0bGUgPSBcIkNvbnN0IE51bWJlclwiO1xuICAgIENvbnN0YW50TnVtYmVyLmRlc2MgPSBcIkNvbnN0YW50IG51bWJlclwiO1xuXG4gICAgQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcGFyc2VGbG9hdCh0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXSkpO1xuICAgIH07XG5cbiAgICBDb25zdGFudE51bWJlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG5cblx0Q29uc3RhbnROdW1iZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odilcblx0e1xuXHRcdHRoaXMuc2V0UHJvcGVydHkoXCJ2YWx1ZVwiLHYpO1xuXHR9XG5cbiAgICBDb25zdGFudE51bWJlci5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAvL3Nob3cgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgdGhpcy5vdXRwdXRzWzBdLmxhYmVsID0gdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0udG9GaXhlZCgzKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9jb25zdFwiLCBDb25zdGFudE51bWJlcik7XG5cbiAgICBmdW5jdGlvbiBDb25zdGFudEJvb2xlYW4oKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIHRydWUpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidG9nZ2xlXCIsXCJ2YWx1ZVwiLHRydWUsXCJ2YWx1ZVwiKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE0MCwgMzBdO1xuICAgIH1cblxuICAgIENvbnN0YW50Qm9vbGVhbi50aXRsZSA9IFwiQ29uc3QgQm9vbGVhblwiO1xuICAgIENvbnN0YW50Qm9vbGVhbi5kZXNjID0gXCJDb25zdGFudCBib29sZWFuXCI7XG4gICAgQ29uc3RhbnRCb29sZWFuLnByb3RvdHlwZS5nZXRUaXRsZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5nZXRUaXRsZTtcblxuICAgIENvbnN0YW50Qm9vbGVhbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXSk7XG4gICAgfTtcblxuXHRDb25zdGFudEJvb2xlYW4ucHJvdG90eXBlLnNldFZhbHVlID0gQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLnNldFZhbHVlO1xuXG5cdENvbnN0YW50Qm9vbGVhbi5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcInRvZ2dsZVwiLCBMaXRlR3JhcGguQUNUSU9OXV07XG5cdH07XG5cblx0Q29uc3RhbnRCb29sZWFuLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbilcblx0e1xuXHRcdHRoaXMuc2V0VmFsdWUoICF0aGlzLnByb3BlcnRpZXMudmFsdWUgKTtcblx0fVxuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9ib29sZWFuXCIsIENvbnN0YW50Qm9vbGVhbik7XG5cbiAgICBmdW5jdGlvbiBDb25zdGFudFN0cmluZygpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcInZhbHVlXCIsXCJcIixcInZhbHVlXCIpOyAgLy9saW5rIHRvIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxODAsIDMwXTtcbiAgICB9XG5cbiAgICBDb25zdGFudFN0cmluZy50aXRsZSA9IFwiQ29uc3QgU3RyaW5nXCI7XG4gICAgQ29uc3RhbnRTdHJpbmcuZGVzYyA9IFwiQ29uc3RhbnQgc3RyaW5nXCI7XG5cbiAgICBDb25zdGFudFN0cmluZy5wcm90b3R5cGUuZ2V0VGl0bGUgPSBDb25zdGFudE51bWJlci5wcm90b3R5cGUuZ2V0VGl0bGU7XG5cbiAgICBDb25zdGFudFN0cmluZy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXSk7XG4gICAgfTtcblxuXHRDb25zdGFudFN0cmluZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWU7XG5cblx0Q29uc3RhbnRTdHJpbmcucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKVxuXHRcdHtcblx0XHRcdHRoYXQuc2V0UHJvcGVydHkoXCJ2YWx1ZVwiLGUudGFyZ2V0LnJlc3VsdCk7XG5cdFx0fVxuXHRcdHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuXHR9XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3N0cmluZ1wiLCBDb25zdGFudFN0cmluZyk7XG5cbiAgICBmdW5jdGlvbiBDb25zdGFudE9iamVjdCgpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvYmpcIiwgXCJvYmplY3RcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxMjAsIDMwXTtcblx0XHR0aGlzLl9vYmplY3QgPSB7fTtcbiAgICB9XG5cbiAgICBDb25zdGFudE9iamVjdC50aXRsZSA9IFwiQ29uc3QgT2JqZWN0XCI7XG4gICAgQ29uc3RhbnRPYmplY3QuZGVzYyA9IFwiQ29uc3RhbnQgT2JqZWN0XCI7XG5cbiAgICBDb25zdGFudE9iamVjdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9vYmplY3QpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJiYXNpYy9vYmplY3RcIiwgQ29uc3RhbnRPYmplY3QgKTtcblxuICAgIGZ1bmN0aW9uIENvbnN0YW50RmlsZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInVybFwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ1cmxcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ0eXBlXCIsIFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcInVybFwiLFwiXCIsXCJ1cmxcIik7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIENvbnN0YW50RmlsZS50aXRsZSA9IFwiQ29uc3QgRmlsZVwiO1xuICAgIENvbnN0YW50RmlsZS5kZXNjID0gXCJGZXRjaGVzIGEgZmlsZSBmcm9tIGFuIHVybFwiO1xuICAgIENvbnN0YW50RmlsZVtcIkB0eXBlXCJdID0geyB0eXBlOiBcImVudW1cIiwgdmFsdWVzOiBbXCJ0ZXh0XCIsXCJhcnJheWJ1ZmZlclwiLFwiYmxvYlwiLFwianNvblwiXSB9O1xuXG4gICAgQ29uc3RhbnRGaWxlLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwidXJsXCIpXG5cdFx0e1xuXHRcdFx0aWYoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT0gXCJcIilcblx0XHRcdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZmV0Y2hGaWxlKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuICAgIENvbnN0YW50RmlsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApIHx8IHRoaXMucHJvcGVydGllcy51cmw7XG5cdFx0aWYodXJsICYmICh1cmwgIT0gdGhpcy5fdXJsIHx8IHRoaXMuX3R5cGUgIT0gdGhpcy5wcm9wZXJ0aWVzLnR5cGUpKVxuXHRcdFx0dGhpcy5mZXRjaEZpbGUodXJsKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2RhdGEgKTtcbiAgICB9O1xuXG5cdENvbnN0YW50RmlsZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWU7XG5cbiAgICBDb25zdGFudEZpbGUucHJvdG90eXBlLmZldGNoRmlsZSA9IGZ1bmN0aW9uKHVybCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRpZighdXJsIHx8IHVybC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKVxuXHRcdHtcblx0XHRcdHRoYXQuX2RhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IG51bGw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xuXHRcdHRoaXMuX3R5cGUgPSB0aGlzLnByb3BlcnRpZXMudHlwZTtcbiAgICAgICAgaWYgKHVybC5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIgJiYgTGl0ZUdyYXBoLnByb3h5KSB7XG4gICAgICAgICAgICB1cmwgPSBMaXRlR3JhcGgucHJveHkgKyB1cmwuc3Vic3RyKHVybC5pbmRleE9mKFwiOlwiKSArIDMpO1xuICAgICAgICB9XG5cdFx0ZmV0Y2godXJsKVxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0XHRpZighcmVzcG9uc2Uub2spXG5cdFx0XHRcdCB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIG5vdCBmb3VuZFwiKTtcblxuXHRcdFx0aWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJhcnJheWJ1ZmZlclwiKVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblx0XHRcdGVsc2UgaWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJ0ZXh0XCIpXG5cdFx0XHRcdHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cdFx0XHRlbHNlIGlmKHRoYXQucHJvcGVydGllcy50eXBlID09IFwianNvblwiKVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0ZWxzZSBpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcImJsb2JcIilcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcblx0XHR9KVxuXHRcdC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHRoYXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0FFQVwiO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHR0aGF0Ll9kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcInJlZFwiO1xuXHRcdFx0Y29uc29sZS5lcnJvcihcImVycm9yIGZldGNoaW5nIGZpbGU6XCIsdXJsKTtcblx0XHR9KTtcbiAgICB9O1xuXG5cdENvbnN0YW50RmlsZS5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGZpbGUpXG5cdHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dGhpcy5fdXJsID0gZmlsZS5uYW1lO1xuXHRcdHRoaXMuX3R5cGUgPSB0aGlzLnByb3BlcnRpZXMudHlwZTtcblx0XHR0aGlzLnByb3BlcnRpZXMudXJsID0gZmlsZS5uYW1lO1xuXHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKVxuXHRcdHtcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiNBRUFcIjtcblx0XHRcdHZhciB2ID0gZS50YXJnZXQucmVzdWx0O1xuXHRcdFx0aWYoIHRoYXQucHJvcGVydGllcy50eXBlID09IFwianNvblwiIClcblx0XHRcdFx0diA9IEpTT04ucGFyc2Uodik7XG5cdFx0XHR0aGF0Ll9kYXRhID0gdjtcblx0XHR9XG5cdFx0aWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJhcnJheWJ1ZmZlclwiKVxuXHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuXHRcdGVsc2UgaWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJqc29uXCIpXG5cdFx0XHRyZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcblx0XHRlbHNlIGlmKHRoYXQucHJvcGVydGllcy50eXBlID09IFwiYmxvYlwiKVxuXHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoZmlsZSk7XG5cdH1cblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvZmlsZVwiLCBDb25zdGFudEZpbGUpO1xuXG5cdC8vdG8gc3RvcmUganNvbiBvYmplY3RzXG4gICAgZnVuY3Rpb24gQ29uc3RhbnREYXRhKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwianNvblwiLFwiXCIsXCJ2YWx1ZVwiKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE0MCwgMzBdO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgQ29uc3RhbnREYXRhLnRpdGxlID0gXCJDb25zdCBEYXRhXCI7XG4gICAgQ29uc3RhbnREYXRhLmRlc2MgPSBcIkNvbnN0YW50IERhdGFcIjtcblxuICAgIENvbnN0YW50RGF0YS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndpZGdldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBRUFcIjtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdGFudERhdGEucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmFsdWUpO1xuICAgIH07XG5cblx0Q29uc3RhbnREYXRhLnByb3RvdHlwZS5zZXRWYWx1ZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5zZXRWYWx1ZTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvZGF0YVwiLCBDb25zdGFudERhdGEpO1xuXG5cdC8vdG8gc3RvcmUganNvbiBvYmplY3RzXG4gICAgZnVuY3Rpb24gQ29uc3RhbnRBcnJheSgpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJhcnJheVwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJsZW5ndGhcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCBcIltdXCIpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwiYXJyYXlcIix0aGlzLnByb3BlcnRpZXMudmFsdWUsXCJ2YWx1ZVwiKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE0MCwgNTBdO1xuICAgIH1cblxuICAgIENvbnN0YW50QXJyYXkudGl0bGUgPSBcIkNvbnN0IEFycmF5XCI7XG4gICAgQ29uc3RhbnRBcnJheS5kZXNjID0gXCJDb25zdGFudCBBcnJheVwiO1xuXG4gICAgQ29uc3RhbnRBcnJheS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndpZGdldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuXHRcdFx0aWYodmFsdWVbMF0gIT0gXCJbXCIpXG5cdCAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gSlNPTi5wYXJzZShcIltcIiArIHZhbHVlICsgXCJdXCIpO1xuXHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FFQVwiO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnN0YW50QXJyYXkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmKHYgJiYgdi5sZW5ndGgpIC8vY2xvbmVcblx0XHR7XG5cdFx0XHRpZighdGhpcy5fdmFsdWUpXG5cdFx0XHRcdHRoaXMuX3ZhbHVlID0gbmV3IEFycmF5KCk7XG5cdFx0XHR0aGlzLl92YWx1ZS5sZW5ndGggPSB2Lmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgKytpKVxuXHRcdFx0XHR0aGlzLl92YWx1ZVtpXSA9IHZbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92YWx1ZSApO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLl92YWx1ZSA/ICggdGhpcy5fdmFsdWUubGVuZ3RoIHx8IDApIDogMCApO1xuICAgIH07XG5cblx0Q29uc3RhbnRBcnJheS5wcm90b3R5cGUuc2V0VmFsdWUgPSBDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWU7XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2FycmF5XCIsIENvbnN0YW50QXJyYXkpO1xuXG5cdGZ1bmN0aW9uIFNldEFycmF5KClcblx0e1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiYXJyXCIsIFwiYXJyYXlcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2YWx1ZVwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJhcnJcIiwgXCJhcnJheVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGluZGV4OiAwIH07XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcImlcIix0aGlzLnByb3BlcnRpZXMuaW5kZXgsXCJpbmRleFwiKTtcblx0fVxuXG4gICAgU2V0QXJyYXkudGl0bGUgPSBcIlNldCBBcnJheVwiO1xuICAgIFNldEFycmF5LmRlc2MgPSBcIlNldHMgaW5kZXggb2YgYXJyYXlcIjtcblxuICAgIFNldEFycmF5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmKCFhcnIpXG5cdFx0XHRyZXR1cm47XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYodiA9PT0gdW5kZWZpbmVkIClcblx0XHRcdHJldHVybjtcblx0XHRpZih0aGlzLnByb3BlcnRpZXMuaW5kZXgpXG5cdFx0XHRhcnJbIE1hdGguZmxvb3IodGhpcy5wcm9wZXJ0aWVzLmluZGV4KSBdID0gdjtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxhcnIpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3NldF9hcnJheVwiLCBTZXRBcnJheSApO1xuXG4gICAgZnVuY3Rpb24gQXJyYXlFbGVtZW50KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiYXJyYXlcIiwgXCJhcnJheSx0YWJsZSxzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbmRleFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIlwiKTtcblx0XHR0aGlzLmFkZFByb3BlcnR5KFwiaW5kZXhcIiwwKTtcbiAgICB9XG5cbiAgICBBcnJheUVsZW1lbnQudGl0bGUgPSBcIkFycmF5W2ldXCI7XG4gICAgQXJyYXlFbGVtZW50LmRlc2MgPSBcIlJldHVybnMgYW4gZWxlbWVudCBmcm9tIGFuIGFycmF5XCI7XG5cbiAgICBBcnJheUVsZW1lbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYoaW5kZXggPT0gbnVsbClcblx0XHRcdGluZGV4ID0gdGhpcy5wcm9wZXJ0aWVzLmluZGV4O1xuXHRcdGlmKGFycmF5ID09IG51bGwgfHwgaW5kZXggPT0gbnVsbCApXG5cdFx0XHRyZXR1cm47XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBhcnJheVtNYXRoLmZsb29yKE51bWJlcihpbmRleCkpXSApO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2FycmF5W11cIiwgQXJyYXlFbGVtZW50KTtcblxuICAgIGZ1bmN0aW9uIFRhYmxlRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInRhYmxlXCIsIFwidGFibGVcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJyb3dcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb2xcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmFsdWVcIiwgXCJcIik7XG5cdFx0dGhpcy5hZGRQcm9wZXJ0eShcInJvd1wiLDApO1xuXHRcdHRoaXMuYWRkUHJvcGVydHkoXCJjb2x1bW5cIiwwKTtcbiAgICB9XG5cbiAgICBUYWJsZUVsZW1lbnQudGl0bGUgPSBcIlRhYmxlW3Jvd11bY29sXVwiO1xuICAgIFRhYmxlRWxlbWVudC5kZXNjID0gXCJSZXR1cm5zIGFuIGVsZW1lbnQgZnJvbSBhIHRhYmxlXCI7XG5cbiAgICBUYWJsZUVsZW1lbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0aWYocm93ID09IG51bGwpXG5cdFx0XHRyb3cgPSB0aGlzLnByb3BlcnRpZXMucm93O1xuXHRcdGlmKGNvbCA9PSBudWxsKVxuXHRcdFx0Y29sID0gdGhpcy5wcm9wZXJ0aWVzLmNvbHVtbjtcblx0XHRpZih0YWJsZSA9PSBudWxsIHx8IHJvdyA9PSBudWxsIHx8IGNvbCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciByb3cgPSB0YWJsZVtNYXRoLmZsb29yKE51bWJlcihyb3cpKV07XG5cdFx0aWYocm93KVxuXHQgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByb3dbTWF0aC5mbG9vcihOdW1iZXIoY29sKSldICk7XG5cdFx0ZWxzZVxuXHQgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBudWxsICk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvdGFibGVbXVtdXCIsIFRhYmxlRWxlbWVudCk7XG5cbiAgICBmdW5jdGlvbiBPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm9ialwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcInByb3AuXCIsXCJcIix0aGlzLnNldFZhbHVlLmJpbmQodGhpcykgKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE0MCwgMzBdO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgT2JqZWN0UHJvcGVydHkudGl0bGUgPSBcIk9iamVjdCBwcm9wZXJ0eVwiO1xuICAgIE9iamVjdFByb3BlcnR5LmRlc2MgPSBcIk91dHB1dHMgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdFwiO1xuXG4gICAgT2JqZWN0UHJvcGVydHkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPSB2O1xuICAgICAgICB0aGlzLndpZGdldC52YWx1ZSA9IHY7XG4gICAgfTtcblxuICAgIE9iamVjdFByb3BlcnR5LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcImluLlwiICsgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG5cbiAgICBPYmplY3RQcm9wZXJ0eS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndpZGdldC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICBPYmplY3RQcm9wZXJ0eS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhW3RoaXMucHJvcGVydGllcy52YWx1ZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvb2JqZWN0X3Byb3BlcnR5XCIsIE9iamVjdFByb3BlcnR5KTtcblxuICAgIGZ1bmN0aW9uIE9iamVjdEtleXMoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvYmpcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwia2V5c1wiLCBcImFycmF5XCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCAzMF07XG4gICAgfVxuXG4gICAgT2JqZWN0S2V5cy50aXRsZSA9IFwiT2JqZWN0IGtleXNcIjtcbiAgICBPYmplY3RLZXlzLmRlc2MgPSBcIk91dHB1dHMgYW4gYXJyYXkgd2l0aCB0aGUga2V5cyBvZiBhbiBvYmplY3RcIjtcblxuICAgIE9iamVjdEtleXMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgT2JqZWN0LmtleXMoZGF0YSkgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL29iamVjdF9rZXlzXCIsIE9iamVjdEtleXMpO1xuXG5cblx0ZnVuY3Rpb24gU2V0T2JqZWN0KClcblx0e1xuICAgICAgICB0aGlzLmFkZElucHV0KFwib2JqXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidmFsdWVcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib2JqXCIsIFwiXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgcHJvcGVydHk6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5uYW1lX3dpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwicHJvcC5cIix0aGlzLnByb3BlcnRpZXMucHJvcGVydHksXCJwcm9wZXJ0eVwiKTtcblx0fVxuXG4gICAgU2V0T2JqZWN0LnRpdGxlID0gXCJTZXQgT2JqZWN0XCI7XG4gICAgU2V0T2JqZWN0LmRlc2MgPSBcIkFkZHMgcHJvcGVydGllc3J0eSB0byBvYmplY3RcIjtcblxuICAgIFNldE9iamVjdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZighb2JqKVxuXHRcdFx0cmV0dXJuO1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGlmKHYgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLnByb3BlcnR5KVxuXHRcdFx0b2JqWyB0aGlzLnByb3BlcnRpZXMucHJvcGVydHkgXSA9IHY7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsb2JqKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9zZXRfb2JqZWN0XCIsIFNldE9iamVjdCApO1xuXG5cbiAgICBmdW5jdGlvbiBNZXJnZU9iamVjdHMoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJcIik7XG5cdFx0dGhpcy5fcmVzdWx0ID0ge307XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsXCJjbGVhclwiLFwiXCIsZnVuY3Rpb24oKXtcblx0XHRcdHRoYXQuX3Jlc3VsdCA9IHt9O1xuXHRcdH0pO1xuXHRcdHRoaXMuc2l6ZSA9IHRoaXMuY29tcHV0ZVNpemUoKTtcbiAgICB9XG5cbiAgICBNZXJnZU9iamVjdHMudGl0bGUgPSBcIk1lcmdlIE9iamVjdHNcIjtcbiAgICBNZXJnZU9iamVjdHMuZGVzYyA9IFwiQ3JlYXRlcyBhbiBvYmplY3QgY29weWluZyBwcm9wZXJ0aWVzIGZyb20gb3RoZXJzXCI7XG5cbiAgICBNZXJnZU9iamVjdHMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdHZhciBDID0gdGhpcy5fcmVzdWx0O1xuXHRcdGlmKEEpXG5cdFx0XHRmb3IodmFyIGkgaW4gQSlcblx0XHRcdFx0Q1tpXSA9IEFbaV07XG5cdFx0aWYoQilcblx0XHRcdGZvcih2YXIgaSBpbiBCKVxuXHRcdFx0XHRDW2ldID0gQltpXTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxDKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9tZXJnZV9vYmplY3RzXCIsIE1lcmdlT2JqZWN0cyApO1xuXG4gICAgLy9TdG9yZSBhcyB2YXJpYWJsZVxuICAgIGZ1bmN0aW9uIFZhcmlhYmxlKCkge1xuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHZhcm5hbWU6IFwibXluYW1lXCIsIGNvbnRhaW5lcjogVmFyaWFibGUuTElURUdSQVBIIH07XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIFZhcmlhYmxlLnRpdGxlID0gXCJWYXJpYWJsZVwiO1xuICAgIFZhcmlhYmxlLmRlc2MgPSBcInN0b3JlL3JlYWQgdmFyaWFibGUgdmFsdWVcIjtcblxuXHRWYXJpYWJsZS5MSVRFR1JBUEggPSAwOyAvL2JldHdlZW4gYWxsIGdyYXBoc1xuXHRWYXJpYWJsZS5HUkFQSCA9IDE7XHQvL29ubHkgaW5zaWRlIHRoaXMgZ3JhcGhcblx0VmFyaWFibGUuR0xPQkFMU0NPUEUgPSAyO1x0Ly9hdHRhY2hlZCB0byBXaW5kb3dcblxuICAgIFZhcmlhYmxlW1wiQGNvbnRhaW5lclwiXSA9IHsgdHlwZTogXCJlbnVtXCIsIHZhbHVlczoge1wibGl0ZWdyYXBoXCI6VmFyaWFibGUuTElURUdSQVBILCBcImdyYXBoXCI6VmFyaWFibGUuR1JBUEgsXCJnbG9iYWxcIjogVmFyaWFibGUuR0xPQkFMU0NPUEV9IH07XG5cbiAgICBWYXJpYWJsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG5cblx0XHRpZih0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMCkpXG5cdFx0e1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdFx0Y29udGFpbmVyWyB0aGlzLnByb3BlcnRpZXMudmFybmFtZSBdID0gdGhpcy52YWx1ZTtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBjb250YWluZXJbIHRoaXMucHJvcGVydGllcy52YXJuYW1lIF0gKTtcbiAgICB9O1xuXG5cdFZhcmlhYmxlLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbigpXG5cdHtcblx0XHRzd2l0Y2godGhpcy5wcm9wZXJ0aWVzLmNvbnRhaW5lcilcblx0XHR7XG5cdFx0XHRjYXNlIFZhcmlhYmxlLkdSQVBIOlxuXHRcdFx0XHRpZih0aGlzLmdyYXBoKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdyYXBoLnZhcnM7XG5cdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFZhcmlhYmxlLkdMT0JBTFNDT1BFOlxuXHRcdFx0XHRyZXR1cm4gZ2xvYmFsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVmFyaWFibGUuTElURUdSQVBIOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIExpdGVHcmFwaC5HbG9iYWxzO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuICAgIFZhcmlhYmxlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnZhcm5hbWU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvdmFyaWFibGVcIiwgVmFyaWFibGUpO1xuXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgaWYodiAmJiB2Lmxlbmd0aCAhPSBudWxsKVxuXHRcdFx0cmV0dXJuIE51bWJlcih2Lmxlbmd0aCk7XG5cdFx0cmV0dXJuIDA7XG4gICAgfVxuXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcbiAgICAgICAgXCJiYXNpYy9sZW5ndGhcIixcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBbXCJcIl0sXG4gICAgICAgIFwibnVtYmVyXCJcbiAgICApO1xuXG5cdGZ1bmN0aW9uIERvd25sb2FkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkYXRhXCIsIDAgKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImRvd25sb2FkXCIsIExpdGVHcmFwaC5BQ1RJT04gKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGZpbGVuYW1lOiBcImRhdGEuanNvblwiIH07XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLFwiRG93bmxvYWRcIixcIlwiLCBmdW5jdGlvbih2KXtcblx0XHRcdGlmKCF0aGF0LnZhbHVlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGF0LmRvd25sb2FkQXNGaWxlKCk7XG5cdFx0fSk7XG4gICAgfVxuXG4gICAgRG93bmxvYWREYXRhLnRpdGxlID0gXCJEb3dubG9hZFwiO1xuICAgIERvd25sb2FkRGF0YS5kZXNjID0gXCJEb3dubG9hZCBzb21lIGRhdGFcIjtcblxuXHREb3dubG9hZERhdGEucHJvdG90eXBlLmRvd25sb2FkQXNGaWxlID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0aWYodGhpcy52YWx1ZSA9PSBudWxsKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHN0ciA9IG51bGw7XG5cdFx0aWYodGhpcy52YWx1ZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKVxuXHRcdFx0c3RyID0gdGhpcy52YWx1ZTtcblx0XHRlbHNlXG5cdFx0XHRzdHIgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKTtcblxuXHRcdHZhciBmaWxlID0gbmV3IEJsb2IoW3N0cl0pO1xuXHRcdHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBmaWxlICk7XG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgdGhpcy5wcm9wZXJ0aWVzLmZpbGVuYW1lICk7XG5cdFx0ZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0ZWxlbWVudC5jbGljaygpO1xuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgVVJMLnJldm9rZU9iamVjdFVSTCggdXJsICk7IH0sIDEwMDAqNjAgKTsgLy93YWl0IG9uZSBtaW51dGUgdG8gcmV2b2tlIHVybFxuXHR9XG5cbiAgICBEb3dubG9hZERhdGEucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpeyB0aGF0LmRvd25sb2FkQXNGaWxlKCk7IH0sIDEwMCk7IC8vZGVmZXJyZWQgdG8gYXZvaWQgYmxvY2tpbmcgdGhlIHJlbmRlcmVyIHdpdGggdGhlIHBvcHVwXG5cdH1cblxuICAgIERvd25sb2FkRGF0YS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0c1swXSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIERvd25sb2FkRGF0YS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2Rvd25sb2FkXCIsIERvd25sb2FkRGF0YSk7XG5cblxuXG4gICAgLy9XYXRjaCBhIHZhbHVlIGluIHRoZSBlZGl0b3JcbiAgICBmdW5jdGlvbiBXYXRjaCgpIHtcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2YWx1ZVwiLCAwLCB7IGxhYmVsOiBcIlwiIH0pO1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICB9XG5cbiAgICBXYXRjaC50aXRsZSA9IFwiV2F0Y2hcIjtcbiAgICBXYXRjaC5kZXNjID0gXCJTaG93IHZhbHVlIG9mIGlucHV0XCI7XG5cbiAgICBXYXRjaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0c1swXSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdhdGNoLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0c1swXS5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9O1xuXG4gICAgV2F0Y2gudG9TdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChvLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvLnRvRml4ZWQoMyk7XG4gICAgICAgIH0gZWxzZSBpZiAoby5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIltcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBXYXRjaC50b1N0cmluZyhvW2ldKSArIChpICsgMSAhPSBvLmxlbmd0aCA/IFwiLFwiIDogXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgKz0gXCJdXCI7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhvKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXYXRjaC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAvL3Nob3cgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgdGhpcy5pbnB1dHNbMF0ubGFiZWwgPSBXYXRjaC50b1N0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy93YXRjaFwiLCBXYXRjaCk7XG5cbiAgICAvL2luIGNhc2Ugb25lIHR5cGUgZG9lc250IG1hdGNoIG90aGVyIHR5cGUgYnV0IHlvdSB3YW50IHRvIGNvbm5lY3QgdGhlbSBhbnl3YXlcbiAgICBmdW5jdGlvbiBDYXN0KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgMCk7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIDApO1xuICAgICAgICB0aGlzLnNpemUgPSBbNDAsIDMwXTtcbiAgICB9XG5cbiAgICBDYXN0LnRpdGxlID0gXCJDYXN0XCI7XG4gICAgQ2FzdC5kZXNjID0gXCJBbGxvd3MgdG8gY29ubmVjdCBkaWZmZXJlbnQgdHlwZXNcIjtcblxuICAgIENhc3QucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5nZXRJbnB1dERhdGEoMCkpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2Nhc3RcIiwgQ2FzdCk7XG5cbiAgICAvL1Nob3cgdmFsdWUgaW5zaWRlIHRoZSBkZWJ1ZyBjb25zb2xlXG4gICAgZnVuY3Rpb24gQ29uc29sZSgpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gTGl0ZUdyYXBoLk9OX0VWRU5UO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1zZ1wiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImxvZ1wiLCBMaXRlR3JhcGguRVZFTlQpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwibXNnXCIsIDApO1xuICAgIH1cblxuICAgIENvbnNvbGUudGl0bGUgPSBcIkNvbnNvbGVcIjtcbiAgICBDb25zb2xlLmRlc2MgPSBcIlNob3cgdmFsdWUgaW5zaWRlIHRoZSBjb25zb2xlXCI7XG5cbiAgICBDb25zb2xlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwYXJhbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwid2FyblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4ocGFyYW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocGFyYW0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnNvbGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIGlmIChtc2cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tc2cgPSBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9O1xuXG4gICAgQ29uc29sZS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtcImxvZ1wiLCBMaXRlR3JhcGguQUNUSU9OXSxcbiAgICAgICAgICAgIFtcIndhcm5cIiwgTGl0ZUdyYXBoLkFDVElPTl0sXG4gICAgICAgICAgICBbXCJlcnJvclwiLCBMaXRlR3JhcGguQUNUSU9OXVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2NvbnNvbGVcIiwgQ29uc29sZSk7XG5cbiAgICAvL1Nob3cgdmFsdWUgaW5zaWRlIHRoZSBkZWJ1ZyBjb25zb2xlXG4gICAgZnVuY3Rpb24gQWxlcnQoKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IExpdGVHcmFwaC5PTl9FVkVOVDtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1zZ1wiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsIFwiVGV4dFwiLCBcIlwiLCBcIm1zZ1wiKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gWzIwMCwgMzBdO1xuICAgIH1cblxuICAgIEFsZXJ0LnRpdGxlID0gXCJBbGVydFwiO1xuICAgIEFsZXJ0LmRlc2MgPSBcIlNob3cgYW4gYWxlcnQgd2luZG93XCI7XG4gICAgQWxlcnQuY29sb3IgPSBcIiM1MTBcIjtcblxuICAgIEFsZXJ0LnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdGhpcy53aWRnZXQudmFsdWUgPSBvLnByb3BlcnRpZXMubXNnO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIHZhciBtc2cgPSB0aGlzLnByb3BlcnRpZXMubXNnO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYWxlcnQobXNnKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2FsZXJ0XCIsIEFsZXJ0KTtcblxuICAgIC8vRXhlY2l0ZXMgc2ltcGxlIGNvZGVcbiAgICBmdW5jdGlvbiBOb2RlU2NyaXB0KCkge1xuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm9uRXhlY3V0ZVwiLCBcInJldHVybiBBO1wiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlwiKTtcblxuICAgICAgICB0aGlzLl9mdW5jID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgfVxuXG4gICAgTm9kZVNjcmlwdC5wcm90b3R5cGUub25Db25maWd1cmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmIChvLnByb3BlcnRpZXMub25FeGVjdXRlICYmIExpdGVHcmFwaC5hbGxvd19zY3JpcHRzKVxuICAgICAgICAgICAgdGhpcy5jb21waWxlQ29kZShvLnByb3BlcnRpZXMub25FeGVjdXRlKTtcblx0XHRlbHNlXG5cdFx0XHRjb25zb2xlLndhcm4oXCJTY3JpcHQgbm90IGNvbXBpbGVkLCBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cyBpcyBmYWxzZVwiKTtcbiAgICB9O1xuXG4gICAgTm9kZVNjcmlwdC50aXRsZSA9IFwiU2NyaXB0XCI7XG4gICAgTm9kZVNjcmlwdC5kZXNjID0gXCJleGVjdXRlcyBhIGNvZGUgKG1heCAxMDAgY2hhcmFjdGVycylcIjtcblxuICAgIE5vZGVTY3JpcHQud2lkZ2V0c19pbmZvID0ge1xuICAgICAgICBvbkV4ZWN1dGU6IHsgdHlwZTogXCJjb2RlXCIgfVxuICAgIH07XG5cbiAgICBOb2RlU2NyaXB0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwib25FeGVjdXRlXCIgJiYgTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMpXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVDb2RlKHZhbHVlKTtcblx0XHRlbHNlXG5cdFx0XHRjb25zb2xlLndhcm4oXCJTY3JpcHQgbm90IGNvbXBpbGVkLCBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cyBpcyBmYWxzZVwiKTtcbiAgICB9O1xuXG4gICAgTm9kZVNjcmlwdC5wcm90b3R5cGUuY29tcGlsZUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgIHRoaXMuX2Z1bmMgPSBudWxsO1xuICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAyNTYpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNjcmlwdCB0b28gbG9uZywgbWF4IDI1NiBjaGFyc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2RlX2xvdyA9IGNvZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBmb3JiaWRkZW5fd29yZHMgPSBbXG4gICAgICAgICAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICBcImJvZHlcIixcbiAgICAgICAgICAgICAgICBcImRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJldmFsXCIsXG4gICAgICAgICAgICAgICAgXCJub2Rlc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICAgICBdOyAvL2JhZCBzZWN1cml0eSBzb2x1dGlvblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JiaWRkZW5fd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZV9sb3cuaW5kZXhPZihmb3JiaWRkZW5fd29yZHNbaV0pICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQgc2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdW5jID0gbmV3IEZ1bmN0aW9uKFwiQVwiLCBcIkJcIiwgXCJDXCIsIFwiREFUQVwiLCBcIm5vZGVcIiwgY29kZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBzY3JpcHRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE5vZGVTY3JpcHQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Z1bmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgICAgIHZhciBDID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fZnVuYyhBLCBCLCBDLCB0aGlzLmRhdGEsIHRoaXMpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gc2NyaXB0XCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE5vZGVTY3JpcHQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1tcIkNcIiwgXCJcIl1dO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3NjcmlwdFwiLCBOb2RlU2NyaXB0KTtcbn0pKHRoaXMpO1xuXG4vL2V2ZW50IHJlbGF0ZWQgbm9kZXNcclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxyXG4gICAgZnVuY3Rpb24gTG9nRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImV2ZW50XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgfVxyXG5cclxuICAgIExvZ0V2ZW50LnRpdGxlID0gXCJMb2cgRXZlbnRcIjtcclxuICAgIExvZ0V2ZW50LmRlc2MgPSBcIkxvZyBldmVudCBpbiBjb25zb2xlXCI7XHJcblxyXG4gICAgTG9nRXZlbnQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGFjdGlvbiwgcGFyYW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9sb2dcIiwgTG9nRXZlbnQpO1xyXG5cclxuICAgIC8vY29udmVydCB0byBFdmVudCBpZiB0aGUgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgZnVuY3Rpb24gVHJpZ2dlckV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpZlwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImNoYW5nZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZmFsc2VcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgb25seV9vbl9jaGFuZ2U6IHRydWUgfTtcclxuXHRcdHRoaXMucHJldiA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgVHJpZ2dlckV2ZW50LnRpdGxlID0gXCJUcmlnZ2VyRXZlbnRcIjtcclxuICAgIFRyaWdnZXJFdmVudC5kZXNjID0gXCJUcmlnZ2VycyBldmVudCBpZiBpbnB1dCBldmFsdWF0ZXMgdG8gdHJ1ZVwiO1xyXG5cclxuICAgIFRyaWdnZXJFdmVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG5cdFx0dmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHZhciBjaGFuZ2VkID0gKHYgIT0gdGhpcy5wcmV2KTtcclxuXHRcdGlmKHRoaXMucHJldiA9PT0gMClcclxuXHRcdFx0Y2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0dmFyIG11c3RfcmVzZW5kID0gKGNoYW5nZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLm9ubHlfb25fY2hhbmdlKSB8fCAoIWNoYW5nZWQgJiYgIXRoaXMucHJvcGVydGllcy5vbmx5X29uX2NoYW5nZSk7XHJcblx0XHRpZih2ICYmIG11c3RfcmVzZW5kIClcclxuXHQgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMCwgcGFyYW0pO1xyXG5cdFx0aWYoIXYgJiYgbXVzdF9yZXNlbmQpXHJcblx0ICAgICAgICB0aGlzLnRyaWdnZXJTbG90KDIsIHBhcmFtKTtcclxuXHRcdGlmKGNoYW5nZWQpXHJcblx0ICAgICAgICB0aGlzLnRyaWdnZXJTbG90KDEsIHBhcmFtKTtcclxuXHRcdHRoaXMucHJldiA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL3RyaWdnZXJcIiwgVHJpZ2dlckV2ZW50KTtcclxuXHJcbiAgICAvL1NlcXVlbmNlciBmb3IgZXZlbnRzXHJcbiAgICBmdW5jdGlvbiBTZXF1ZW5jZXIoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzEyMCwgMzBdO1xyXG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7IGhvcml6b250YWw6IHRydWUsIHJlbmRlcl9ib3g6IGZhbHNlIH07XHJcbiAgICB9XHJcblxyXG4gICAgU2VxdWVuY2VyLnRpdGxlID0gXCJTZXF1ZW5jZXJcIjtcclxuICAgIFNlcXVlbmNlci5kZXNjID0gXCJUcmlnZ2VyIGV2ZW50cyB3aGVuIGFuIGV2ZW50IGFycml2ZXNcIjtcclxuXHJcbiAgICBTZXF1ZW5jZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIFNlcXVlbmNlci5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdChpLCBwYXJhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL3NlcXVlbmNlclwiLCBTZXF1ZW5jZXIpO1xyXG5cclxuICAgIC8vRmlsdGVyIGV2ZW50c1xyXG4gICAgZnVuY3Rpb24gRmlsdGVyRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImV2ZW50XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGVxdWFsX3RvOiBcIlwiLFxyXG4gICAgICAgICAgICBoYXNfcHJvcGVydHk6IFwiXCIsXHJcbiAgICAgICAgICAgIHByb3BlcnR5X2VxdWFsX3RvOiBcIlwiXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBGaWx0ZXJFdmVudC50aXRsZSA9IFwiRmlsdGVyIEV2ZW50XCI7XHJcbiAgICBGaWx0ZXJFdmVudC5kZXNjID0gXCJCbG9ja3MgZXZlbnRzIHRoYXQgZG8gbm90IG1hdGNoIHRoZSBmaWx0ZXJcIjtcclxuXHJcbiAgICBGaWx0ZXJFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5lcXVhbF90byAmJiB0aGlzLnByb3BlcnRpZXMuZXF1YWxfdG8gIT0gcGFyYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNfcHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBwYXJhbVt0aGlzLnByb3BlcnRpZXMuaGFzX3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucHJvcGVydHlfZXF1YWxfdG8gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wcm9wZXJ0eV9lcXVhbF90byAhPSBwcm9wXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXJTbG90KDAsIHBhcmFtKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvZmlsdGVyXCIsIEZpbHRlckV2ZW50KTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gRXZlbnRCcmFuY2goKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb25kXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZhbHNlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzEyMCwgNjBdO1xyXG5cdFx0dGhpcy5fdmFsdWUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBFdmVudEJyYW5jaC50aXRsZSA9IFwiQnJhbmNoXCI7XHJcbiAgICBFdmVudEJyYW5jaC5kZXNjID0gXCJJZiBjb25kaXRpb24gaXMgdHJ1ZSwgb3V0cHV0cyB0cmlnZ2VycyB0cnVlLCBvdGhlcndpc2UgZmFsc2VcIjtcclxuXHJcbiAgICBFdmVudEJyYW5jaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdH1cclxuXHJcbiAgICBFdmVudEJyYW5jaC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcblx0XHR0aGlzLnRyaWdnZXJTbG90KHRoaXMuX3ZhbHVlID8gMCA6IDEpO1xyXG5cdH1cclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9icmFuY2hcIiwgRXZlbnRCcmFuY2gpO1xyXG5cclxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcclxuICAgIGZ1bmN0aW9uIEV2ZW50Q291bnRlcigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5jXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkZWNcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInJlc2V0XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiY2hhbmdlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJudW1cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5udW0gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIEV2ZW50Q291bnRlci50aXRsZSA9IFwiQ291bnRlclwiO1xyXG4gICAgRXZlbnRDb3VudGVyLmRlc2MgPSBcIkNvdW50cyBldmVudHNcIjtcclxuXHJcbiAgICBFdmVudENvdW50ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5udW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlbnRDb3VudGVyLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMubnVtO1xyXG4gICAgICAgIGlmIChhY3Rpb24gPT0gXCJpbmNcIikge1xyXG4gICAgICAgICAgICB0aGlzLm51bSArPSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwiZGVjXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5udW0gLT0gMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PSBcInJlc2V0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5udW0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5udW0gIT0gdikge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwgdGhpcy5udW0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRXZlbnRDb3VudGVyLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FBQVwiO1xyXG4gICAgICAgIGN0eC5mb250ID0gXCIyMHB4IEFyaWFsXCI7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMubnVtLCB0aGlzLnNpemVbMF0gKiAwLjUsIHRoaXMuc2l6ZVsxXSAqIDAuNSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZW50Q291bnRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMubnVtKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvY291bnRlclwiLCBFdmVudENvdW50ZXIpO1xyXG5cclxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcclxuICAgIGZ1bmN0aW9uIERlbGF5RXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInRpbWVfaW5fbXNcIiwgMTAwMCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImV2ZW50XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib25fdGltZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG5cclxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgRGVsYXlFdmVudC50aXRsZSA9IFwiRGVsYXlcIjtcclxuICAgIERlbGF5RXZlbnQuZGVzYyA9IFwiRGVsYXlzIG9uZSBldmVudFwiO1xyXG5cclxuICAgIERlbGF5RXZlbnQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5wcm9wZXJ0aWVzLnRpbWVfaW5fbXM7XHJcbiAgICAgICAgaWYgKHRpbWUgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobnVsbCwgcGFyYW0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaChbdGltZSwgcGFyYW1dKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIERlbGF5RXZlbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkdCA9IHRoaXMuZ3JhcGguZWxhcHNlZF90aW1lICogMTAwMDsgLy9pbiBtc1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy50aW1lX2luX21zID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuX3BlbmRpbmdbaV07XHJcbiAgICAgICAgICAgIGFjdGlvblswXSAtPSBkdDtcclxuICAgICAgICAgICAgaWYgKGFjdGlvblswXSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3JlbW92ZVxyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgLS1pO1xyXG5cclxuICAgICAgICAgICAgLy90cmlnZ2VyXHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihudWxsLCBhY3Rpb25bMV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRGVsYXlFdmVudC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImV2ZW50XCIsIExpdGVHcmFwaC5BQ1RJT05dLCBbXCJ0aW1lX2luX21zXCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvZGVsYXlcIiwgRGVsYXlFdmVudCk7XHJcblxyXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxyXG4gICAgZnVuY3Rpb24gVGltZXJFdmVudCgpIHtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiaW50ZXJ2YWxcIiwgMTAwMCk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImV2ZW50XCIsIFwidGlja1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9uX3RpY2tcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdF9pbnRlcnZhbCA9IDEwMDA7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBUaW1lckV2ZW50LnRpdGxlID0gXCJUaW1lclwiO1xyXG4gICAgVGltZXJFdmVudC5kZXNjID0gXCJTZW5kcyBhbiBldmVudCBldmVyeSBOIG1pbGxpc2Vjb25kc1wiO1xyXG5cclxuICAgIFRpbWVyRXZlbnQucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIlRpbWVyOiBcIiArIHRoaXMubGFzdF9pbnRlcnZhbC50b1N0cmluZygpICsgXCJtc1wiO1xyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50Lm9uX2NvbG9yID0gXCIjQUFBXCI7XHJcbiAgICBUaW1lckV2ZW50Lm9mZl9jb2xvciA9IFwiIzIyMlwiO1xyXG5cclxuICAgIFRpbWVyRXZlbnQucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gdGhpcy50cmlnZ2VyZWRcclxuICAgICAgICAgICAgPyBUaW1lckV2ZW50Lm9uX2NvbG9yXHJcbiAgICAgICAgICAgIDogVGltZXJFdmVudC5vZmZfY29sb3I7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGR0ID0gdGhpcy5ncmFwaC5lbGFwc2VkX3RpbWUgKiAxMDAwOyAvL2luIG1zXHJcblxyXG4gICAgICAgIHZhciB0cmlnZ2VyID0gdGhpcy50aW1lID09IDA7XHJcblxyXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcclxuICAgICAgICB0aGlzLmxhc3RfaW50ZXJ2YWwgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgMSxcclxuICAgICAgICAgICAgdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJpbnRlcnZhbFwiKSB8IDBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0cmlnZ2VyICYmXHJcbiAgICAgICAgICAgICh0aGlzLnRpbWUgPCB0aGlzLmxhc3RfaW50ZXJ2YWwgfHwgaXNOYU4odGhpcy5sYXN0X2ludGVydmFsKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzLmxlbmd0aCA+IDEgJiYgdGhpcy5pbnB1dHNbMV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMudGltZSAlIHRoaXMubGFzdF9pbnRlcnZhbDtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl90aWNrXCIsIHRoaXMucHJvcGVydGllcy5ldmVudCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzLmxlbmd0aCA+IDEgJiYgdGhpcy5pbnB1dHNbMV0pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImludGVydmFsXCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJ0aWNrXCIsIFwiYm9vbGVhblwiXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL3RpbWVyXCIsIFRpbWVyRXZlbnQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIERhdGFTdG9yZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZGF0YVwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiYXNzaWduXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZGF0YVwiLCBcIlwiKTtcclxuXHRcdHRoaXMuX2xhc3RfdmFsdWUgPSBudWxsO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBkYXRhOiBudWxsLCBzZXJpYWxpemU6IHRydWUgfTtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsXCJzdG9yZVwiLFwiXCIsZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhhdC5wcm9wZXJ0aWVzLmRhdGEgPSB0aGF0Ll9sYXN0X3ZhbHVlO1xyXG5cdFx0fSk7XHJcbiAgICB9XHJcblxyXG4gICAgRGF0YVN0b3JlLnRpdGxlID0gXCJEYXRhIFN0b3JlXCI7XHJcbiAgICBEYXRhU3RvcmUuZGVzYyA9IFwiU3RvcmVzIGRhdGEgYW5kIG9ubHkgY2hhbmdlcyB3aGVuIGV2ZW50IGlzIHJlY2VpdmVkXCI7XHJcblxyXG5cdERhdGFTdG9yZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHRoaXMuX2xhc3RfdmFsdWUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMuZGF0YSApO1xyXG5cdH1cclxuXHJcbiAgICBEYXRhU3RvcmUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzLmRhdGEgPSB0aGlzLl9sYXN0X3ZhbHVlO1xyXG4gICAgfTtcclxuXHJcblx0RGF0YVN0b3JlLnByb3RvdHlwZS5vblNlcmlhbGl6ZSA9IGZ1bmN0aW9uKG8pXHJcblx0e1xyXG5cdFx0aWYoby5kYXRhID09IG51bGwpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5zZXJpYWxpemUgPT0gZmFsc2UgfHwgKG8uZGF0YS5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nICYmIG8uZGF0YS5jb25zdHJ1Y3RvciAhPT0gTnVtYmVyICYmIG8uZGF0YS5jb25zdHJ1Y3RvciAhPT0gQm9vbGVhbiAmJiBvLmRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5ICYmIG8uZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICkpXHJcblx0XHRcdG8uZGF0YSA9IG51bGw7XHJcblx0fVxyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvZGF0YV9zdG9yZVwiLCBEYXRhU3RvcmUpO1xyXG59KSh0aGlzKTtcclxuXG4vL3dpZGdldHNcbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcblxuICAgIC8qIEJ1dHRvbiAqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0QnV0dG9uKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ0ZXh0XCIsIFwiY2xpY2sgbWVcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJmb250X3NpemVcIiwgMzApO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWVzc2FnZVwiLCBcIlwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzE2NCwgODRdO1xuICAgICAgICB0aGlzLmNsaWNrZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBXaWRnZXRCdXR0b24udGl0bGUgPSBcIkJ1dHRvblwiO1xuICAgIFdpZGdldEJ1dHRvbi5kZXNjID0gXCJUcmlnZ2VycyBhbiBldmVudFwiO1xuXG4gICAgV2lkZ2V0QnV0dG9uLmZvbnQgPSBcIkFyaWFsXCI7XG4gICAgV2lkZ2V0QnV0dG9uLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJnaW4gPSAxMDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbWFyZ2luICsgMSxcbiAgICAgICAgICAgIG1hcmdpbiArIDEsXG4gICAgICAgICAgICB0aGlzLnNpemVbMF0gLSBtYXJnaW4gKiAyLFxuICAgICAgICAgICAgdGhpcy5zaXplWzFdIC0gbWFyZ2luICogMlxuICAgICAgICApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFGXCI7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIG1hcmdpbiAtIDEsXG4gICAgICAgICAgICBtYXJnaW4gLSAxLFxuICAgICAgICAgICAgdGhpcy5zaXplWzBdIC0gbWFyZ2luICogMixcbiAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAtIG1hcmdpbiAqIDJcbiAgICAgICAgKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY2xpY2tlZFxuICAgICAgICAgICAgPyBcIndoaXRlXCJcbiAgICAgICAgICAgIDogdGhpcy5tb3VzZU92ZXJcbiAgICAgICAgICAgID8gXCIjNjY4XCJcbiAgICAgICAgICAgIDogXCIjMzM0XCI7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAtIG1hcmdpbiAqIDIsXG4gICAgICAgICAgICB0aGlzLnNpemVbMV0gLSBtYXJnaW4gKiAyXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy50ZXh0IHx8IHRoaXMucHJvcGVydGllcy50ZXh0ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZm9udF9zaXplID0gdGhpcy5wcm9wZXJ0aWVzLmZvbnRfc2l6ZSB8fCAzMDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY2xpY2tlZCA/IFwiYmxhY2tcIiA6IFwid2hpdGVcIjtcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udF9zaXplICsgXCJweCBcIiArIFdpZGdldEJ1dHRvbi5mb250O1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy50ZXh0LFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVbMV0gKiAwLjUgKyBmb250X3NpemUgKiAwLjNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2lkZ2V0QnV0dG9uLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGxvY2FsX3Bvcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsb2NhbF9wb3NbMF0gPiAxICYmXG4gICAgICAgICAgICBsb2NhbF9wb3NbMV0gPiAxICYmXG4gICAgICAgICAgICBsb2NhbF9wb3NbMF0gPCB0aGlzLnNpemVbMF0gLSAyICYmXG4gICAgICAgICAgICBsb2NhbF9wb3NbMV0gPCB0aGlzLnNpemVbMV0gLSAyXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMCwgdGhpcy5wcm9wZXJ0aWVzLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2lkZ2V0QnV0dG9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuY2xpY2tlZCk7XG4gICAgfTtcblxuICAgIFdpZGdldEJ1dHRvbi5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmNsaWNrZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvYnV0dG9uXCIsIFdpZGdldEJ1dHRvbik7XG5cbiAgICBmdW5jdGlvbiBXaWRnZXRUb2dnbGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiZVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2XCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJlXCIsIExpdGVHcmFwaC5FVkVOVCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgZm9udDogXCJcIiwgdmFsdWU6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNjAsIDQ0XTtcbiAgICB9XG5cbiAgICBXaWRnZXRUb2dnbGUudGl0bGUgPSBcIlRvZ2dsZVwiO1xuICAgIFdpZGdldFRvZ2dsZS5kZXNjID0gXCJUb2dnbGVzIGJldHdlZW4gdHJ1ZSBvciBmYWxzZVwiO1xuXG4gICAgV2lkZ2V0VG9nZ2xlLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemVbMV0gKiAwLjU7XG4gICAgICAgIHZhciBtYXJnaW4gPSAwLjI1O1xuICAgICAgICB2YXIgaCA9IHRoaXMuc2l6ZVsxXSAqIDAuODtcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLnByb3BlcnRpZXMuZm9udCB8fCAoc2l6ZSAqIDAuOCkudG9GaXhlZCgwKSArIFwicHggQXJpYWxcIjtcbiAgICAgICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGhpcy50aXRsZSkud2lkdGg7XG4gICAgICAgIHZhciB4ID0gKHRoaXMuc2l6ZVswXSAtICh3ICsgc2l6ZSkpICogMC41O1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHgsIGggLSBzaXplLCBzaXplLCBzaXplKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID8gXCIjQUVGXCIgOiBcIiMwMDBcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgeCArIHNpemUgKiBtYXJnaW4sXG4gICAgICAgICAgICBoIC0gc2l6ZSArIHNpemUgKiBtYXJnaW4sXG4gICAgICAgICAgICBzaXplICogKDEgLSBtYXJnaW4gKiAyKSxcbiAgICAgICAgICAgIHNpemUgKiAoMSAtIG1hcmdpbiAqIDIpXG4gICAgICAgICk7XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRpdGxlLCBzaXplICogMS4yICsgeCwgaCAqIDAuODUpO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgfTtcblxuICAgIFdpZGdldFRvZ2dsZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gIXRoaXMucHJvcGVydGllcy52YWx1ZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZVwiLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBXaWRnZXRUb2dnbGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBXaWRnZXRUb2dnbGUucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgbG9jYWxfcG9zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsX3Bvc1swXSA+IDEgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1sxXSA+IDEgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1swXSA8IHRoaXMuc2l6ZVswXSAtIDIgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1sxXSA8IHRoaXMuc2l6ZVsxXSAtIDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPSAhdGhpcy5wcm9wZXJ0aWVzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZVwiLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvdG9nZ2xlXCIsIFdpZGdldFRvZ2dsZSk7XG5cbiAgICAvKiBOdW1iZXIgKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIFdpZGdldE51bWJlcigpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgNjBdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IG1pbjogLTEwMDAsIG1heDogMTAwMCwgdmFsdWU6IDEsIHN0ZXA6IDEgfTtcbiAgICAgICAgdGhpcy5vbGRfeSA9IC0xO1xuICAgICAgICB0aGlzLl9yZW1haW5kZXIgPSAwO1xuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSAwO1xuICAgICAgICB0aGlzLm1vdXNlX2NhcHR1cmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgV2lkZ2V0TnVtYmVyLnRpdGxlID0gXCJOdW1iZXJcIjtcbiAgICBXaWRnZXROdW1iZXIuZGVzYyA9IFwiV2lkZ2V0IHRvIHNlbGVjdCBudW1iZXIgdmFsdWVcIjtcblxuICAgIFdpZGdldE51bWJlci5waXhlbHNfdGhyZXNob2xkID0gMTA7XG4gICAgV2lkZ2V0TnVtYmVyLm1hcmtlcnNfY29sb3IgPSBcIiM2NjZcIjtcblxuICAgIFdpZGdldE51bWJlci5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuc2l6ZVswXSAqIDAuNTtcbiAgICAgICAgdmFyIGggPSB0aGlzLnNpemVbMV07XG4gICAgICAgIGlmIChoID4gMzApIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBXaWRnZXROdW1iZXIubWFya2Vyc19jb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgaCAqIDAuMSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBoICogMC4xLCBoICogMC4yKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGggKiAtMC4xLCBoICogMC4yKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIGggKiAwLjkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaCAqIDAuMSwgaCAqIDAuOCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBoICogLTAuMSwgaCAqIDAuOCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSAoaCAqIDAuNykudG9GaXhlZCgxKSArIFwicHggQXJpYWxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gKGggKiAwLjgpLnRvRml4ZWQoMSkgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LmZvbnQgPSAoaCAqIDAuNykudG9GaXhlZCgxKSArIFwicHggQXJpYWxcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0VFRVwiO1xuICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUudG9GaXhlZCh0aGlzLl9wcmVjaXNpb24pLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIGggKiAwLjc1XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFdpZGdldE51bWJlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBXaWRnZXROdW1iZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHQgPSAodGhpcy5wcm9wZXJ0aWVzLnN0ZXAgKyBcIlwiKS5zcGxpdChcIi5cIik7XG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHQubGVuZ3RoID4gMSA/IHRbMV0ubGVuZ3RoIDogMDtcbiAgICB9O1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIHBvcykge1xuICAgICAgICBpZiAocG9zWzFdIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbGRfeSA9IGUuY2FudmFzWTtcbiAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG4gICAgICAgIHRoaXMubW91c2VfY2FwdHVyZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBXaWRnZXROdW1iZXIucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMubW91c2VfY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IHRoaXMub2xkX3kgLSBlLmNhbnZhc1k7XG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBkZWx0YSAqPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5KSB7XG4gICAgICAgICAgICBkZWx0YSAqPSAwLjE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbGRfeSA9IGUuY2FudmFzWTtcblxuICAgICAgICB2YXIgc3RlcHMgPSB0aGlzLl9yZW1haW5kZXIgKyBkZWx0YSAvIFdpZGdldE51bWJlci5waXhlbHNfdGhyZXNob2xkO1xuICAgICAgICB0aGlzLl9yZW1haW5kZXIgPSBzdGVwcyAlIDE7XG4gICAgICAgIHN0ZXBzID0gc3RlcHMgfCAwO1xuXG4gICAgICAgIHZhciB2ID0gTWF0aC5jbGFtcChcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSArIHN0ZXBzICogdGhpcy5wcm9wZXJ0aWVzLnN0ZXAsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluLFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1heFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPSB2O1xuICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldE51bWJlci5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24oZSwgcG9zKSB7XG4gICAgICAgIGlmIChlLmNsaWNrX3RpbWUgPCAyMDApIHtcbiAgICAgICAgICAgIHZhciBzdGVwcyA9IHBvc1sxXSA+IHRoaXMuc2l6ZVsxXSAqIDAuNSA/IC0xIDogMTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IE1hdGguY2xhbXAoXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICsgc3RlcHMgKiB0aGlzLnByb3BlcnRpZXMuc3RlcCxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW91c2VfY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VfY2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9udW1iZXJcIiwgV2lkZ2V0TnVtYmVyKTtcblxuXG4gICAgLyogQ29tYm8gKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIFdpZGdldENvbWJvKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJjaGFuZ2VcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCA2MF07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgdmFsdWU6IFwiQVwiLCB2YWx1ZXM6XCJBO0I7Q1wiIH07XG4gICAgICAgIHRoaXMub2xkX3kgPSAtMTtcbiAgICAgICAgdGhpcy5tb3VzZV9jYXB0dXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3ZhbHVlcyA9IHRoaXMucHJvcGVydGllcy52YWx1ZXMuc3BsaXQoXCI7XCIpO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcblx0XHR0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcIlwiLCB0aGlzLnByb3BlcnRpZXMudmFsdWUsIGZ1bmN0aW9uKHYpe1xuXHRcdFx0dGhhdC5wcm9wZXJ0aWVzLnZhbHVlID0gdjtcbiAgICAgICAgICAgIHRoYXQudHJpZ2dlclNsb3QoMSwgdik7XG5cdFx0fSwgeyBwcm9wZXJ0eTogXCJ2YWx1ZVwiLCB2YWx1ZXM6IHRoaXMuX3ZhbHVlcyB9ICk7XG4gICAgfVxuXG4gICAgV2lkZ2V0Q29tYm8udGl0bGUgPSBcIkNvbWJvXCI7XG4gICAgV2lkZ2V0Q29tYm8uZGVzYyA9IFwiV2lkZ2V0IHRvIHNlbGVjdCBmcm9tIGEgbGlzdFwiO1xuXG4gICAgV2lkZ2V0Q29tYm8ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSApO1xuICAgIH07XG5cbiAgICBXaWRnZXRDb21iby5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdGlmKG5hbWUgPT0gXCJ2YWx1ZXNcIilcblx0XHR7XG5cdFx0XHR0aGlzLl92YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIjtcIik7XG5cdFx0XHR0aGlzLndpZGdldC5vcHRpb25zLnZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcblx0XHR9XG5cdFx0ZWxzZSBpZihuYW1lID09IFwidmFsdWVcIilcblx0XHR7XG5cdFx0XHR0aGlzLndpZGdldC52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L2NvbWJvXCIsIFdpZGdldENvbWJvKTtcblxuXG4gICAgLyogS25vYiAqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0S25vYigpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2NCwgODRdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgICB2YWx1ZTogMC41LFxuICAgICAgICAgICAgY29sb3I6IFwiIzdBRlwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiAyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICB9XG5cbiAgICBXaWRnZXRLbm9iLnRpdGxlID0gXCJLbm9iXCI7XG4gICAgV2lkZ2V0S25vYi5kZXNjID0gXCJDaXJjdWxhciBjb250cm9sbGVyXCI7XG4gICAgV2lkZ2V0S25vYi5zaXplID0gWzgwLCAxMDBdO1xuXG4gICAgV2lkZ2V0S25vYi5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID1cbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnZhbHVlIC0gdGhpcy5wcm9wZXJ0aWVzLm1pbikgL1xuICAgICAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMubWF4IC0gdGhpcy5wcm9wZXJ0aWVzLm1pbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VudGVyX3ggPSB0aGlzLnNpemVbMF0gKiAwLjU7XG4gICAgICAgIHZhciBjZW50ZXJfeSA9IHRoaXMuc2l6ZVsxXSAqIDAuNTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKSAqIDAuNSAtIDU7XG4gICAgICAgIHZhciB3ID0gTWF0aC5mbG9vcihyYWRpdXMgKiAwLjA1KTtcblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRlcl94LCBjZW50ZXJfeSk7XG4gICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAqIDAuNzUpO1xuXG4gICAgICAgIC8vYmdcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCwwLjUpXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAxLjUpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIC8vdmFsdWVcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICByYWRpdXMgLSA0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIE1hdGguUEkgKiAxLjUgKiBNYXRoLm1heCgwLjAxLCB0aGlzLnZhbHVlKVxuICAgICAgICApO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvL2lubmVyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjZW50ZXJfeCwgY2VudGVyX3ksIHJhZGl1cyAqIDAuNzUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvL21pbmliYWxsXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm1vdXNlT3ZlciA/IFwid2hpdGVcIiA6IHRoaXMucHJvcGVydGllcy5jb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLnZhbHVlICogTWF0aC5QSSAqIDEuNSArIE1hdGguUEkgKiAwLjc1O1xuICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgY2VudGVyX3ggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKiAwLjY1LFxuICAgICAgICAgICAgY2VudGVyX3kgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKiAwLjY1LFxuICAgICAgICAgICAgcmFkaXVzICogMC4wNSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvL3RleHRcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubW91c2VPdmVyID8gXCJ3aGl0ZVwiIDogXCIjQUFBXCI7XG4gICAgICAgIGN0eC5mb250ID0gTWF0aC5mbG9vcihyYWRpdXMgKiAwLjUpICsgXCJweCBBcmlhbFwiO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlLnRvRml4ZWQodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiksXG4gICAgICAgICAgICBjZW50ZXJfeCxcbiAgICAgICAgICAgIGNlbnRlcl95ICsgcmFkaXVzICogMC4xNVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBMaXRlR3JhcGguY29sb3JUb1N0cmluZyhbXG4gICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFdpZGdldEtub2IucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmNlbnRlciA9IFt0aGlzLnNpemVbMF0gKiAwLjUsIHRoaXMuc2l6ZVsxXSAqIDAuNSArIDIwXTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLnNpemVbMF0gKiAwLjU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdIDwgMjAgfHxcbiAgICAgICAgICAgIExpdGVHcmFwaC5kaXN0YW5jZShcbiAgICAgICAgICAgICAgICBbZS5jYW52YXNYLCBlLmNhbnZhc1ldLFxuICAgICAgICAgICAgICAgIFt0aGlzLnBvc1swXSArIHRoaXMuY2VudGVyWzBdLCB0aGlzLnBvc1sxXSArIHRoaXMuY2VudGVyWzFdXVxuICAgICAgICAgICAgKSA+IHRoaXMucmFkaXVzXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2xkbW91c2UgPSBbZS5jYW52YXNYIC0gdGhpcy5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdXTtcbiAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9sZG1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IFtlLmNhbnZhc1ggLSB0aGlzLnBvc1swXSwgZS5jYW52YXNZIC0gdGhpcy5wb3NbMV1dO1xuXG4gICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdiAtPSAobVsxXSAtIHRoaXMub2xkbW91c2VbMV0pICogMC4wMTtcbiAgICAgICAgaWYgKHYgPiAxLjApIHtcbiAgICAgICAgICAgIHYgPSAxLjA7XG4gICAgICAgIH0gZWxzZSBpZiAodiA8IDAuMCkge1xuICAgICAgICAgICAgdiA9IDAuMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID1cbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW4gK1xuICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5tYXggLSB0aGlzLnByb3BlcnRpZXMubWluKSAqIHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMub2xkbW91c2UgPSBtO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLm9sZG1vdXNlKSB7XG4gICAgICAgICAgICB0aGlzLm9sZG1vdXNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwibWluXCIgfHwgbmFtZSA9PSBcIm1heFwiIHx8IG5hbWUgPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvL2Jsb2NrXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQva25vYlwiLCBXaWRnZXRLbm9iKTtcblxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcbiAgICBmdW5jdGlvbiBXaWRnZXRTbGlkZXJHVUkoKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICB2YWx1ZTogMC41LFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgdGV4dDogXCJWXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCA0MF07XG4gICAgICAgIHRoaXMuc2xpZGVyID0gdGhpcy5hZGRXaWRnZXQoXG4gICAgICAgICAgICBcInNsaWRlclwiLFxuICAgICAgICAgICAgXCJWXCIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUsXG4gICAgICAgICAgICBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlID0gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBXaWRnZXRTbGlkZXJHVUkudGl0bGUgPSBcIklubmVyIFNsaWRlclwiO1xuXG4gICAgV2lkZ2V0U2xpZGVyR1VJLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRTbGlkZXJHVUkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvaW50ZXJuYWxfc2xpZGVyXCIsIFdpZGdldFNsaWRlckdVSSk7XG5cbiAgICAvL1dpZGdldCBIIFNMSURFUlxuICAgIGZ1bmN0aW9uIFdpZGdldEhTbGlkZXIoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNjAsIDI2XTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgY29sb3I6IFwiIzdBRlwiLCBtaW46IDAsIG1heDogMSwgdmFsdWU6IDAuNSB9O1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgfVxuXG4gICAgV2lkZ2V0SFNsaWRlci50aXRsZSA9IFwiSC5TbGlkZXJcIjtcbiAgICBXaWRnZXRIU2xpZGVyLmRlc2MgPSBcIkxpbmVhciBzbGlkZXIgY29udHJvbGxlclwiO1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9XG4gICAgICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy52YWx1ZSAtIHRoaXMucHJvcGVydGllcy5taW4pIC9cbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ib3JkZXJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDIsIDIsIHRoaXMuc2l6ZVswXSAtIDQsIHRoaXMuc2l6ZVsxXSAtIDQpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoNCwgNCwgKHRoaXMuc2l6ZVswXSAtIDgpICogdGhpcy52YWx1ZSwgdGhpcy5zaXplWzFdIC0gOCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfTtcblxuICAgIFdpZGdldEhTbGlkZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPVxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbiArXG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW4pICogdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBMaXRlR3JhcGguY29sb3JUb1N0cmluZyhbXG4gICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFdpZGdldEhTbGlkZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jYW52YXNZIC0gdGhpcy5wb3NbMV0gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9sZG1vdXNlID0gW2UuY2FudmFzWCAtIHRoaXMucG9zWzBdLCBlLmNhbnZhc1kgLSB0aGlzLnBvc1sxXV07XG4gICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5vbGRtb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSBbZS5jYW52YXNYIC0gdGhpcy5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdXTtcblxuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBkZWx0YSA9IG1bMF0gLSB0aGlzLm9sZG1vdXNlWzBdO1xuICAgICAgICB2ICs9IGRlbHRhIC8gdGhpcy5zaXplWzBdO1xuICAgICAgICBpZiAodiA+IDEuMCkge1xuICAgICAgICAgICAgdiA9IDEuMDtcbiAgICAgICAgfSBlbHNlIGlmICh2IDwgMC4wKSB7XG4gICAgICAgICAgICB2ID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IHY7XG5cbiAgICAgICAgdGhpcy5vbGRtb3VzZSA9IG07XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldEhTbGlkZXIucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5vbGRtb3VzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMub2xkbW91c2UgPSBudWxsO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9oc2xpZGVyXCIsIFdpZGdldEhTbGlkZXIpO1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNjAsIDI2XTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBtaW46IDAsIG1heDogMSwgdmFsdWU6IDAsIGNvbG9yOiBcIiNBQUZcIiB9O1xuICAgIH1cblxuICAgIFdpZGdldFByb2dyZXNzLnRpdGxlID0gXCJQcm9ncmVzc1wiO1xuICAgIFdpZGdldFByb2dyZXNzLmRlc2MgPSBcIlNob3dzIGRhdGEgaW4gbGluZWFyIHByb2dyZXNzXCI7XG5cbiAgICBXaWRnZXRQcm9ncmVzcy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0gPSB2O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdpZGdldFByb2dyZXNzLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vYm9yZGVyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuICAgICAgICB2YXIgdiA9XG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnZhbHVlIC0gdGhpcy5wcm9wZXJ0aWVzLm1pbikgL1xuICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5tYXggLSB0aGlzLnByb3BlcnRpZXMubWluKTtcbiAgICAgICAgdiA9IE1hdGgubWluKDEsIHYpO1xuICAgICAgICB2ID0gTWF0aC5tYXgoMCwgdik7XG4gICAgICAgIGN0eC5maWxsUmVjdCgyLCAyLCAodGhpcy5zaXplWzBdIC0gNCkgKiB2LCB0aGlzLnNpemVbMV0gLSA0KTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvcHJvZ3Jlc3NcIiwgV2lkZ2V0UHJvZ3Jlc3MpO1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0VGV4dCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dHMoXCJcIiwgMCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBcIi4uLlwiLFxuICAgICAgICAgICAgZm9udDogXCJBcmlhbFwiLFxuICAgICAgICAgICAgZm9udHNpemU6IDE4LFxuICAgICAgICAgICAgY29sb3I6IFwiI0FBQVwiLFxuICAgICAgICAgICAgYWxpZ246IFwibGVmdFwiLFxuICAgICAgICAgICAgZ2xvd1NpemU6IDAsXG4gICAgICAgICAgICBkZWNpbWFsczogMVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIFdpZGdldFRleHQudGl0bGUgPSBcIlRleHRcIjtcbiAgICBXaWRnZXRUZXh0LmRlc2MgPSBcIlNob3dzIHRoZSBpbnB1dCB2YWx1ZVwiO1xuICAgIFdpZGdldFRleHQud2lkZ2V0cyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInJlc2l6ZVwiLCB0ZXh0OiBcIlJlc2l6ZSBib3hcIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwibGVkX3RleHRcIiwgdGV4dDogXCJMRURcIiwgdHlwZTogXCJtaW5pYnV0dG9uXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcIm5vcm1hbF90ZXh0XCIsIHRleHQ6IFwiTm9ybWFsXCIsIHR5cGU6IFwibWluaWJ1dHRvblwiIH1cbiAgICBdO1xuXG4gICAgV2lkZ2V0VGV4dC5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAvL2N0eC5maWxsU3R5bGU9XCIjMDAwXCI7XG4gICAgICAgIC8vY3R4LmZpbGxSZWN0KDAsMCwxMDAsNjApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzW1wiY29sb3JcIl07XG4gICAgICAgIHZhciB2ID0gdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tcImdsb3dTaXplXCJdKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMucHJvcGVydGllc1tcImdsb3dTaXplXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvbnRzaXplID0gdGhpcy5wcm9wZXJ0aWVzW1wiZm9udHNpemVcIl07XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMucHJvcGVydGllc1tcImFsaWduXCJdO1xuICAgICAgICBjdHguZm9udCA9IGZvbnRzaXplLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgdGhpcy5wcm9wZXJ0aWVzW1wiZm9udFwiXTtcbiAgICAgICAgdGhpcy5zdHIgPVxuICAgICAgICAgICAgdHlwZW9mIHYgPT0gXCJudW1iZXJcIiA/IHYudG9GaXhlZCh0aGlzLnByb3BlcnRpZXNbXCJkZWNpbWFsc1wiXSkgOiB2O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zdHIuc3BsaXQoXCJcXFxcblwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiYWxpZ25cIl0gPT0gXCJsZWZ0XCIgPyAxNSA6IHRoaXMuc2l6ZVswXSAtIDE1LFxuICAgICAgICAgICAgICAgICAgICBmb250c2l6ZSAqIC0wLjE1ICsgZm9udHNpemUgKiAocGFyc2VJbnQoaSkgKyAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIHRoaXMubGFzdF9jdHggPSBjdHg7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9O1xuXG4gICAgV2lkZ2V0VGV4dC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdID0gdjtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldFRleHQucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdF9jdHgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lcyA9IHRoaXMuc3RyLnNwbGl0KFwiXFxcXG5cIik7XG4gICAgICAgIHRoaXMubGFzdF9jdHguZm9udCA9XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJmb250c2l6ZVwiXSArIFwicHggXCIgKyB0aGlzLnByb3BlcnRpZXNbXCJmb250XCJdO1xuICAgICAgICB2YXIgbWF4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gdGhpcy5sYXN0X2N0eC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGg7XG4gICAgICAgICAgICBpZiAobWF4IDwgdykge1xuICAgICAgICAgICAgICAgIG1heCA9IHc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplWzBdID0gbWF4ICsgMjA7XG4gICAgICAgIHRoaXMuc2l6ZVsxXSA9IDQgKyBsaW5lcy5sZW5ndGggKiB0aGlzLnByb3BlcnRpZXNbXCJmb250c2l6ZVwiXTtcblxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBXaWRnZXRUZXh0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0ciA9IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUudG9GaXhlZCgzKSA6IHZhbHVlO1xuICAgICAgICAvL3RoaXMucmVzaXplKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC90ZXh0XCIsIFdpZGdldFRleHQpO1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0UGFuZWwoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsyMDAsIDEwMF07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgICAgIGJnY29sb3JUb3A6IFwiI2YwZjBmMFwiLFxuICAgICAgICAgICAgYmdjb2xvckJvdHRvbTogXCIjZTBlMGUwXCIsXG4gICAgICAgICAgICBzaGFkb3dTaXplOiAyLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgV2lkZ2V0UGFuZWwudGl0bGUgPSBcIlBhbmVsXCI7XG4gICAgV2lkZ2V0UGFuZWwuZGVzYyA9IFwiTm9uIGludGVyYWN0aXZlIHBhbmVsXCI7XG4gICAgV2lkZ2V0UGFuZWwud2lkZ2V0cyA9IFt7IG5hbWU6IFwidXBkYXRlXCIsIHRleHQ6IFwiVXBkYXRlXCIsIHR5cGU6IFwiYnV0dG9uXCIgfV07XG5cbiAgICBXaWRnZXRQYW5lbC5wcm90b3R5cGUuY3JlYXRlR3JhZGllbnQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiYmdjb2xvclRvcFwiXSA9PSBcIlwiIHx8XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJiZ2NvbG9yQm90dG9tXCJdID09IFwiXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVhcmdyYWRpZW50ID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGluZWFyZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgdGhpcy5zaXplWzFdKTtcbiAgICAgICAgdGhpcy5saW5lYXJncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgdGhpcy5wcm9wZXJ0aWVzW1wiYmdjb2xvclRvcFwiXSk7XG4gICAgICAgIHRoaXMubGluZWFyZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIHRoaXMucHJvcGVydGllc1tcImJnY29sb3JCb3R0b21cIl0pO1xuICAgIH07XG5cbiAgICBXaWRnZXRQYW5lbC5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxpbmVhcmdyYWRpZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR3JhZGllbnQoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5saW5lYXJncmFkaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMucHJvcGVydGllc1tcImJvcmRlckNvbG9yXCJdO1xuICAgICAgICAvL2N0eC5maWxsU3R5bGUgPSBcIiNlYmViZWJcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGluZWFyZ3JhZGllbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tcInNoYWRvd1NpemVcIl0pIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiIzAwMFwiO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnByb3BlcnRpZXNbXCJzaGFkb3dTaXplXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJvdW5kUmVjdChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5zaXplWzBdIC0gMSxcbiAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAtIDEsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJzaGFkb3dTaXplXCJdXG4gICAgICAgICk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9wYW5lbFwiLCBXaWRnZXRQYW5lbCk7XG59KSh0aGlzKTtcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZXBhZElucHV0KCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwibGVmdF94X2F4aXNcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJsZWZ0X3lfYXhpc1wiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImJ1dHRvbl9wcmVzc2VkXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBnYW1lcGFkX2luZGV4OiAwLCB0aHJlc2hvbGQ6IDAuMSB9O1xyXG5cclxuICAgICAgICB0aGlzLl9sZWZ0X2F4aXMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIHRoaXMuX3JpZ2h0X2F4aXMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJzID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgICAgICB0aGlzLl9wcmV2aW91c19idXR0b25zID0gbmV3IFVpbnQ4QXJyYXkoMTcpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRfYnV0dG9ucyA9IG5ldyBVaW50OEFycmF5KDE3KTtcclxuICAgIH1cclxuXHJcbiAgICBHYW1lcGFkSW5wdXQudGl0bGUgPSBcIkdhbWVwYWRcIjtcclxuICAgIEdhbWVwYWRJbnB1dC5kZXNjID0gXCJnZXRzIHRoZSBpbnB1dCBvZiB0aGUgZ2FtZXBhZFwiO1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5DRU5URVIgPSAwO1xyXG4gICAgR2FtZXBhZElucHV0LkxFRlQgPSAxO1xyXG4gICAgR2FtZXBhZElucHV0LlJJR0hUID0gMjtcclxuICAgIEdhbWVwYWRJbnB1dC5VUCA9IDQ7XHJcbiAgICBHYW1lcGFkSW5wdXQuRE9XTiA9IDg7XHJcblxyXG4gICAgR2FtZXBhZElucHV0Lnplcm8gPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgR2FtZXBhZElucHV0LmJ1dHRvbnMgPSBbXHJcbiAgICAgICAgXCJhXCIsXHJcbiAgICAgICAgXCJiXCIsXHJcbiAgICAgICAgXCJ4XCIsXHJcbiAgICAgICAgXCJ5XCIsXHJcbiAgICAgICAgXCJsYlwiLFxyXG4gICAgICAgIFwicmJcIixcclxuICAgICAgICBcImx0XCIsXHJcbiAgICAgICAgXCJydFwiLFxyXG4gICAgICAgIFwiYmFja1wiLFxyXG4gICAgICAgIFwic3RhcnRcIixcclxuICAgICAgICBcImxzXCIsXHJcbiAgICAgICAgXCJyc1wiLFxyXG4gICAgICAgIFwiaG9tZVwiXHJcbiAgICBdO1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9nZXQgZ2FtZXBhZFxyXG4gICAgICAgIHZhciBnYW1lcGFkID0gdGhpcy5nZXRHYW1lcGFkKCk7XHJcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IHRoaXMucHJvcGVydGllcy50aHJlc2hvbGQgfHwgMC4wO1xyXG5cclxuICAgICAgICBpZiAoZ2FtZXBhZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWZ0X2F4aXNbMF0gPVxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FtZXBhZC54Ym94LmF4ZXNbXCJseFwiXSkgPiB0aHJlc2hvbGRcclxuICAgICAgICAgICAgICAgICAgICA/IGdhbWVwYWQueGJveC5heGVzW1wibHhcIl1cclxuICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZnRfYXhpc1sxXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcImx5XCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJseVwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fcmlnaHRfYXhpc1swXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcInJ4XCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJyeFwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fcmlnaHRfYXhpc1sxXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcInJ5XCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJyeVwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcnNbMF0gPVxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FtZXBhZC54Ym94LmF4ZXNbXCJsdHJpZ2dlclwiXSkgPiB0aHJlc2hvbGRcclxuICAgICAgICAgICAgICAgICAgICA/IGdhbWVwYWQueGJveC5heGVzW1wibHRyaWdnZXJcIl1cclxuICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJzWzFdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wicnRyaWdnZXJcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcInJ0cmlnZ2VyXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0LmxpbmtzIHx8ICFvdXRwdXQubGlua3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGdhbWVwYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG91dHB1dC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0X2F4aXNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLl9sZWZ0X2F4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0X2F4aXNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLl9yaWdodF9heGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0X3hfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX2xlZnRfYXhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGVmdF95X2F4aXNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLl9sZWZ0X2F4aXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0X3hfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX3JpZ2h0X2F4aXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0X3lfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX3JpZ2h0X2F4aXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRyaWdnZXJfbGVmdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX3RyaWdnZXJzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmlnZ2VyX3JpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fdHJpZ2dlcnNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJhXCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJiXCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJ4XCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInlfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJ5XCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxiX2J1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5idXR0b25zW1wibGJcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmJfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJyYlwiXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsc19idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImxzXCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJzX2J1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5idXR0b25zW1wicnNcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X2xlZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guaGF0bWFwICYgR2FtZXBhZElucHV0LkxFRlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhhdF9yaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5oYXRtYXAgJiBHYW1lcGFkSW5wdXQuUklHSFQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhhdF91cFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5oYXRtYXAgJiBHYW1lcGFkSW5wdXQuVVA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhhdF9kb3duXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmhhdG1hcCAmIEdhbWVwYWRJbnB1dC5ET1dOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoYXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guaGF0bWFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydF9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInN0YXJ0XCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJhY2tfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJiYWNrXCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJ1dHRvbl9wcmVzc2VkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgdGhpcy5fY3VycmVudF9idXR0b25zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2pcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudF9idXR0b25zW2pdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9wcmV2aW91c19idXR0b25zW2pdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR2FtZXBhZElucHV0LmJ1dHRvbnNbal1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBubyBnYW1lcGFkIGlzIGNvbm5lY3RlZCwgb3V0cHV0IDBcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG91dHB1dC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJidXR0b25fcHJlc3NlZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0X2F4aXNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0X2F4aXNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBHYW1lcGFkSW5wdXQuemVybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblx0R2FtZXBhZElucHV0Lm1hcHBpbmcgPSB7YTowLGI6MSx4OjIseTozLGxiOjQscmI6NSxsdDo2LHJ0OjcsYmFjazo4LHN0YXJ0OjksbHM6MTAscnM6MTEgfTtcclxuXHRHYW1lcGFkSW5wdXQubWFwcGluZ19hcnJheSA9IFtcImFcIixcImJcIixcInhcIixcInlcIixcImxiXCIsXCJyYlwiLFwibHRcIixcInJ0XCIsXCJiYWNrXCIsXCJzdGFydFwiLFwibHNcIixcInJzXCJdO1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5wcm90b3R5cGUuZ2V0R2FtZXBhZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBnZXRHYW1lcGFkcyA9XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci5nZXRHYW1lcGFkcyB8fFxyXG4gICAgICAgICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHMgfHxcclxuICAgICAgICAgICAgbmF2aWdhdG9yLm1vekdldEdhbWVwYWRzO1xyXG4gICAgICAgIGlmICghZ2V0R2FtZXBhZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBnYW1lcGFkcyA9IGdldEdhbWVwYWRzLmNhbGwobmF2aWdhdG9yKTtcclxuICAgICAgICB2YXIgZ2FtZXBhZCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzX2J1dHRvbnMuc2V0KHRoaXMuX2N1cnJlbnRfYnV0dG9ucyk7XHJcblxyXG4gICAgICAgIC8vcGljayB0aGUgZmlyc3QgY29ubmVjdGVkXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucHJvcGVydGllcy5nYW1lcGFkX2luZGV4OyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghZ2FtZXBhZHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdhbWVwYWQgPSBnYW1lcGFkc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8veGJveCBjb250cm9sbGVyIG1hcHBpbmdcclxuICAgICAgICAgICAgdmFyIHhib3ggPSB0aGlzLnhib3hfbWFwcGluZztcclxuICAgICAgICAgICAgaWYgKCF4Ym94KSB7XHJcbiAgICAgICAgICAgICAgICB4Ym94ID0gdGhpcy54Ym94X21hcHBpbmcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgaGF0OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhdG1hcDogR2FtZXBhZElucHV0LkNFTlRFUlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeGJveC5heGVzW1wibHhcIl0gPSBnYW1lcGFkLmF4ZXNbMF07XHJcbiAgICAgICAgICAgIHhib3guYXhlc1tcImx5XCJdID0gZ2FtZXBhZC5heGVzWzFdO1xyXG4gICAgICAgICAgICB4Ym94LmF4ZXNbXCJyeFwiXSA9IGdhbWVwYWQuYXhlc1syXTtcclxuICAgICAgICAgICAgeGJveC5heGVzW1wicnlcIl0gPSBnYW1lcGFkLmF4ZXNbM107XHJcbiAgICAgICAgICAgIHhib3guYXhlc1tcImx0cmlnZ2VyXCJdID0gZ2FtZXBhZC5idXR0b25zWzZdLnZhbHVlO1xyXG4gICAgICAgICAgICB4Ym94LmF4ZXNbXCJydHJpZ2dlclwiXSA9IGdhbWVwYWQuYnV0dG9uc1s3XS52YWx1ZTtcclxuICAgICAgICAgICAgeGJveC5oYXQgPSBcIlwiO1xyXG4gICAgICAgICAgICB4Ym94LmhhdG1hcCA9IEdhbWVwYWRJbnB1dC5DRU5URVI7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdhbWVwYWQuYnV0dG9ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudF9idXR0b25zW2pdID0gZ2FtZXBhZC5idXR0b25zW2pdLnByZXNzZWQ7XHJcblxyXG5cdFx0XHRcdGlmKGogPCAxMilcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR4Ym94LmJ1dHRvbnNbIEdhbWVwYWRJbnB1dC5tYXBwaW5nX2FycmF5W2pdIF0gPSBnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZDtcclxuXHRcdFx0XHRcdGlmKGdhbWVwYWQuYnV0dG9uc1tqXS53YXNfcHJlc3NlZClcclxuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCBHYW1lcGFkSW5wdXQubWFwcGluZ19hcnJheVtqXSArIFwiX2J1dHRvbl9ldmVudFwiICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgLy9tYXBwaW5nIG9mIFhCT1hcclxuXHRcdFx0XHRcdHN3aXRjaCAoIGogKSAvL0kgdXNlIGEgc3dpdGNoIHRvIGVuc3VyZSB0aGF0IGEgcGxheWVyIHdpdGggYW5vdGhlciBnYW1lcGFkIGNvdWxkIHBsYXlcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAxMjpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZ2FtZXBhZC5idXR0b25zW2pdLnByZXNzZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHhib3guaGF0ICs9IFwidXBcIjtcclxuXHRcdFx0XHRcdFx0XHRcdHhib3guaGF0bWFwIHw9IEdhbWVwYWRJbnB1dC5VUDtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgMTM6XHJcblx0XHRcdFx0XHRcdFx0aWYgKGdhbWVwYWQuYnV0dG9uc1tqXS5wcmVzc2VkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdCArPSBcImRvd25cIjtcclxuXHRcdFx0XHRcdFx0XHRcdHhib3guaGF0bWFwIHw9IEdhbWVwYWRJbnB1dC5ET1dOO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAxNDpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZ2FtZXBhZC5idXR0b25zW2pdLnByZXNzZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHhib3guaGF0ICs9IFwibGVmdFwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXRtYXAgfD0gR2FtZXBhZElucHV0LkxFRlQ7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE1OlxyXG5cdFx0XHRcdFx0XHRcdGlmIChnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXQgKz0gXCJyaWdodFwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXRtYXAgfD0gR2FtZXBhZElucHV0LlJJR0hUO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAxNjpcclxuXHRcdFx0XHRcdFx0XHR4Ym94LmJ1dHRvbnNbXCJob21lXCJdID0gZ2FtZXBhZC5idXR0b25zW2pdLnByZXNzZWQ7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHR9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2FtZXBhZC54Ym94ID0geGJveDtcclxuICAgICAgICAgICAgcmV0dXJuIGdhbWVwYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBHYW1lcGFkSW5wdXQucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9yZW5kZXIgZ2FtZXBhZCBzdGF0ZT9cclxuICAgICAgICB2YXIgbGEgPSB0aGlzLl9sZWZ0X2F4aXM7XHJcbiAgICAgICAgdmFyIHJhID0gdGhpcy5fcmlnaHRfYXhpcztcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiM4OEFcIjtcclxuICAgICAgICBjdHguc3Ryb2tlUmVjdChcclxuICAgICAgICAgICAgKGxhWzBdICsgMSkgKiAwLjUgKiB0aGlzLnNpemVbMF0gLSA0LFxyXG4gICAgICAgICAgICAobGFbMV0gKyAxKSAqIDAuNSAqIHRoaXMuc2l6ZVsxXSAtIDQsXHJcbiAgICAgICAgICAgIDgsXHJcbiAgICAgICAgICAgIDhcclxuICAgICAgICApO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzhBOFwiO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KFxyXG4gICAgICAgICAgICAocmFbMF0gKyAxKSAqIDAuNSAqIHRoaXMuc2l6ZVswXSAtIDQsXHJcbiAgICAgICAgICAgIChyYVsxXSArIDEpICogMC41ICogdGhpcy5zaXplWzFdIC0gNCxcclxuICAgICAgICAgICAgOCxcclxuICAgICAgICAgICAgOFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIGggPSB0aGlzLnNpemVbMV0gLyB0aGlzLl9jdXJyZW50X2J1dHRvbnMubGVuZ3RoO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBRUJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2N1cnJlbnRfYnV0dG9ucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudF9idXR0b25zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgaCAqIGksIDYsIGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBHYW1lcGFkSW5wdXQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcImxlZnRfYXhpc1wiLCBcInZlYzJcIl0sXHJcbiAgICAgICAgICAgIFtcInJpZ2h0X2F4aXNcIiwgXCJ2ZWMyXCJdLFxyXG4gICAgICAgICAgICBbXCJsZWZ0X3hfYXhpc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wibGVmdF95X2F4aXNcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJpZ2h0X3hfYXhpc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmlnaHRfeV9heGlzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ0cmlnZ2VyX2xlZnRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInRyaWdnZXJfcmlnaHRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImFfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJiX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wieF9idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInlfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJsYl9idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJiX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wibHNfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJyc19idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInN0YXJ0X2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYmFja19idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImFfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJiX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wieF9idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcInlfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJsYl9idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcInJiX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wibHNfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJyc19idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcInN0YXJ0X2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wiYmFja19idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcImhhdF9sZWZ0XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJoYXRfcmlnaHRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImhhdF91cFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiaGF0X2Rvd25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImhhdFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYnV0dG9uX3ByZXNzZWRcIiwgTGl0ZUdyYXBoLkVWRU5UXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiaW5wdXQvZ2FtZXBhZFwiLCBHYW1lcGFkSW5wdXQpO1xyXG59KSh0aGlzKTtcclxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICAvL0NvbnZlcnRlclxyXG4gICAgZnVuY3Rpb24gQ29udmVydGVyKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlwiKTtcclxuXHR0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBDb252ZXJ0ZXIudGl0bGUgPSBcIkNvbnZlcnRlclwiO1xyXG4gICAgQ29udmVydGVyLmRlc2MgPSBcInR5cGUgQSB0byB0eXBlIEJcIjtcclxuXHJcbiAgICBDb252ZXJ0ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQubGlua3MgfHwgIW91dHB1dC5saW5rcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHYubGVuZ3RoID8gdlswXSA6IHBhcnNlRmxvYXQodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWMyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZlYzNcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVjNFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZlYzJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVjM1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWM0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA8IHYubGVuZ3RoICYmIGogPCByZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdID0gdltqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IHBhcnNlRmxvYXQodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgQ29udmVydGVyLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJudW1iZXJcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInZlYzJcIiwgXCJ2ZWMyXCJdLFxyXG4gICAgICAgICAgICBbXCJ2ZWMzXCIsIFwidmVjM1wiXSxcclxuICAgICAgICAgICAgW1widmVjNFwiLCBcInZlYzRcIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvY29udmVydGVyXCIsIENvbnZlcnRlcik7XHJcblxyXG4gICAgLy9CeXBhc3NcclxuICAgIGZ1bmN0aW9uIEJ5cGFzcygpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XHJcbiAgICB9XHJcblxyXG4gICAgQnlwYXNzLnRpdGxlID0gXCJCeXBhc3NcIjtcclxuICAgIEJ5cGFzcy5kZXNjID0gXCJyZW1vdmVzIHRoZSB0eXBlXCI7XHJcblxyXG4gICAgQnlwYXNzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2J5cGFzc1wiLCBCeXBhc3MpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFRvTnVtYmVyKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBUb051bWJlci50aXRsZSA9IFwidG8gTnVtYmVyXCI7XHJcbiAgICBUb051bWJlci5kZXNjID0gXCJDYXN0IHRvIG51bWJlclwiO1xyXG5cclxuICAgIFRvTnVtYmVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBOdW1iZXIodikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvdG9fbnVtYmVyXCIsIFRvTnVtYmVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoUmFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIsIHsgbG9ja2VkOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIsIHsgbG9ja2VkOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiY2xhbXBlZFwiLCBcIm51bWJlclwiLCB7IGxvY2tlZDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJpbl9taW5cIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImluX21heFwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib3V0X21pblwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib3V0X21heFwiLCAxKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaXplID0gWzEyMCwgNTBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhSYW5nZS50aXRsZSA9IFwiUmFuZ2VcIjtcclxuICAgIE1hdGhSYW5nZS5kZXNjID0gXCJDb252ZXJ0IGEgbnVtYmVyIGZyb20gb25lIHJhbmdlIHRvIGFub3RoZXJcIjtcclxuXHJcbiAgICBNYXRoUmFuZ2UucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbGFzdF92IHx8IDApLnRvRml4ZWQoMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoUmFuZ2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbaW5wdXQubmFtZV0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdiA9IHRoaXMucHJvcGVydGllc1tcImluXCJdO1xyXG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCB8fCB2LmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpIHtcclxuICAgICAgICAgICAgdiA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5fbWluID0gdGhpcy5wcm9wZXJ0aWVzLmluX21pbjtcclxuICAgICAgICB2YXIgaW5fbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLmluX21heDtcclxuICAgICAgICB2YXIgb3V0X21pbiA9IHRoaXMucHJvcGVydGllcy5vdXRfbWluO1xyXG4gICAgICAgIHZhciBvdXRfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLm91dF9tYXg7XHJcblx0XHQvKlxyXG5cdFx0aWYoIGluX21pbiA+IGluX21heCApXHJcblx0XHR7XHJcblx0XHRcdGluX21pbiA9IGluX21heDtcclxuXHRcdFx0aW5fbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLmluX21pbjtcclxuXHRcdH1cclxuXHRcdGlmKCBvdXRfbWluID4gb3V0X21heCApXHJcblx0XHR7XHJcblx0XHRcdG91dF9taW4gPSBvdXRfbWF4O1xyXG5cdFx0XHRvdXRfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLm91dF9taW47XHJcblx0XHR9XHJcblx0XHQqL1xyXG5cclxuICAgICAgICB0aGlzLl9sYXN0X3YgPSAoKHYgLSBpbl9taW4pIC8gKGluX21heCAtIGluX21pbikpICogKG91dF9tYXggLSBvdXRfbWluKSArIG91dF9taW47XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2xhc3Rfdik7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIE1hdGguY2xhbXAoIHRoaXMuX2xhc3Rfdiwgb3V0X21pbiwgb3V0X21heCApKTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aFJhbmdlLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgLy9zaG93IHRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgICAgaWYgKHRoaXMuX2xhc3Rfdikge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbMF0ubGFiZWwgPSB0aGlzLl9sYXN0X3YudG9GaXhlZCgzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbMF0ubGFiZWwgPSBcIj9cIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhSYW5nZS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJpbl9taW5cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImluX21heFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wib3V0X21pblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wib3V0X21heFwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9yYW5nZVwiLCBNYXRoUmFuZ2UpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGhSYW5kKCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmFsdWVcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1pblwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWF4XCIsIDEpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhSYW5kLnRpdGxlID0gXCJSYW5kXCI7XHJcbiAgICBNYXRoUmFuZC5kZXNjID0gXCJSYW5kb20gbnVtYmVyXCI7XHJcblxyXG4gICAgTWF0aFJhbmQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbaW5wdXQubmFtZV0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWluID0gdGhpcy5wcm9wZXJ0aWVzLm1pbjtcclxuICAgICAgICB2YXIgbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLm1heDtcclxuICAgICAgICB0aGlzLl9sYXN0X3YgPSBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2xhc3Rfdik7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhSYW5kLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgLy9zaG93IHRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgICAgdGhpcy5vdXRwdXRzWzBdLmxhYmVsID0gKHRoaXMuX2xhc3RfdiB8fCAwKS50b0ZpeGVkKDMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoUmFuZC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcIm1pblwiLCBcIm51bWJlclwiXSwgW1wibWF4XCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3JhbmRcIiwgTWF0aFJhbmQpO1xyXG5cclxuICAgIC8vYmFzaWMgY29udGludW91cyBub2lzZVxyXG4gICAgZnVuY3Rpb24gTWF0aE5vaXNlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtYXhcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInNtb290aFwiLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwic2VlZFwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib2N0YXZlc1wiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwicGVyc2lzdGVuY2VcIiwgMC44KTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwic3BlZWRcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzkwLCAzMF07XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aE5vaXNlLnRpdGxlID0gXCJOb2lzZVwiO1xyXG4gICAgTWF0aE5vaXNlLmRlc2MgPSBcIlJhbmRvbSBudW1iZXIgd2l0aCB0ZW1wb3JhbCBjb250aW51aXR5XCI7XHJcbiAgICBNYXRoTm9pc2UuZGF0YSA9IG51bGw7XHJcblxyXG4gICAgTWF0aE5vaXNlLmdldFZhbHVlID0gZnVuY3Rpb24oZiwgc21vb3RoKSB7XHJcbiAgICAgICAgaWYgKCFNYXRoTm9pc2UuZGF0YSkge1xyXG4gICAgICAgICAgICBNYXRoTm9pc2UuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAyNCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aE5vaXNlLmRhdGEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIE1hdGhOb2lzZS5kYXRhW2ldID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmID0gZiAlIDEwMjQ7XHJcbiAgICAgICAgaWYgKGYgPCAwKSB7XHJcbiAgICAgICAgICAgIGYgKz0gMTAyNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZfbWluID0gTWF0aC5mbG9vcihmKTtcclxuICAgICAgICB2YXIgZiA9IGYgLSBmX21pbjtcclxuICAgICAgICB2YXIgcjEgPSBNYXRoTm9pc2UuZGF0YVtmX21pbl07XHJcbiAgICAgICAgdmFyIHIyID0gTWF0aE5vaXNlLmRhdGFbZl9taW4gPT0gMTAyMyA/IDAgOiBmX21pbiArIDFdO1xyXG4gICAgICAgIGlmIChzbW9vdGgpIHtcclxuICAgICAgICAgICAgZiA9IGYgKiBmICogZiAqIChmICogKGYgKiA2LjAgLSAxNS4wKSArIDEwLjApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjEgKiAoMSAtIGYpICsgcjIgKiBmO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoTm9pc2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBmID0gdGhpcy5nZXRJbnB1dERhdGEoMCkgfHwgMDtcclxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5wcm9wZXJ0aWVzLm9jdGF2ZXMgfHwgMTtcclxuXHRcdHZhciByID0gMDtcclxuXHRcdHZhciBhbXAgPSAxO1xyXG5cdFx0dmFyIHNlZWQgPSB0aGlzLnByb3BlcnRpZXMuc2VlZCB8fCAwO1xyXG5cdFx0ZiArPSBzZWVkO1xyXG5cdFx0dmFyIHNwZWVkID0gdGhpcy5wcm9wZXJ0aWVzLnNwZWVkIHx8IDE7XHJcblx0XHR2YXIgdG90YWxfYW1wID0gMDtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHIgKz0gTWF0aE5vaXNlLmdldFZhbHVlKGYgKiAoMStpKSAqIHNwZWVkLCB0aGlzLnByb3BlcnRpZXMuc21vb3RoKSAqIGFtcDtcclxuXHRcdFx0dG90YWxfYW1wICs9IGFtcDtcclxuXHRcdFx0YW1wICo9IHRoaXMucHJvcGVydGllcy5wZXJzaXN0ZW5jZTtcclxuXHRcdFx0aWYoYW1wIDwgMC4wMDEpXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHRyIC89IHRvdGFsX2FtcDtcclxuICAgICAgICB2YXIgbWluID0gdGhpcy5wcm9wZXJ0aWVzLm1pbjtcclxuICAgICAgICB2YXIgbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLm1heDtcclxuICAgICAgICB0aGlzLl9sYXN0X3YgPSByICogKG1heCAtIG1pbikgKyBtaW47XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2xhc3Rfdik7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhOb2lzZS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIC8vc2hvdyB0aGUgY3VycmVudCB2YWx1ZVxyXG4gICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9ICh0aGlzLl9sYXN0X3YgfHwgMCkudG9GaXhlZCgzKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL25vaXNlXCIsIE1hdGhOb2lzZSk7XHJcblxyXG4gICAgLy9nZW5lcmF0ZXMgc3Bpa2VzIGV2ZXJ5IHJhbmRvbSB0aW1lXHJcbiAgICBmdW5jdGlvbiBNYXRoU3Bpa2VzKCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtaW5fdGltZVwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWF4X3RpbWVcIiwgMik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImR1cmF0aW9uXCIsIDAuMik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzkwLCAzMF07XHJcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nX3RpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2JsaW5rX3RpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhTcGlrZXMudGl0bGUgPSBcIlNwaWtlc1wiO1xyXG4gICAgTWF0aFNwaWtlcy5kZXNjID0gXCJzcGlrZSBldmVyeSByYW5kb20gdGltZVwiO1xyXG5cclxuICAgIE1hdGhTcGlrZXMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkdCA9IHRoaXMuZ3JhcGguZWxhcHNlZF90aW1lOyAvL2luIHNlY3NcclxuXHJcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nX3RpbWUgLT0gZHQ7XHJcbiAgICAgICAgdGhpcy5fYmxpbmtfdGltZSAtPSBkdDtcclxuXHJcbiAgICAgICAgdmFyIHYgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLl9ibGlua190aW1lID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuX2JsaW5rX3RpbWUgLyB0aGlzLnByb3BlcnRpZXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHYgPSAxIC8gKE1hdGgucG93KGYgKiA4IC0gNCwgNCkgKyAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmdfdGltZSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtYWluaW5nX3RpbWUgPVxyXG4gICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5tYXhfdGltZSAtIHRoaXMucHJvcGVydGllcy5taW5fdGltZSkgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbl90aW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9ibGlua190aW1lID0gdGhpcy5wcm9wZXJ0aWVzLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjRkZGXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiIzAwMFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdik7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9zcGlrZXNcIiwgTWF0aFNwaWtlcyk7XHJcblxyXG4gICAgLy9NYXRoIGNsYW1wXHJcbiAgICBmdW5jdGlvbiBNYXRoQ2xhbXAoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtaW5cIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1heFwiLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoQ2xhbXAudGl0bGUgPSBcIkNsYW1wXCI7XHJcbiAgICBNYXRoQ2xhbXAuZGVzYyA9IFwiQ2xhbXAgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcIjtcclxuICAgIC8vTWF0aENsYW1wLmZpbHRlciA9IFwic2hhZGVyXCI7XHJcblxyXG4gICAgTWF0aENsYW1wLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ID0gTWF0aC5tYXgodGhpcy5wcm9wZXJ0aWVzLm1pbiwgdik7XHJcbiAgICAgICAgdiA9IE1hdGgubWluKHRoaXMucHJvcGVydGllcy5tYXgsIHYpO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aENsYW1wLnByb3RvdHlwZS5nZXRDb2RlID0gZnVuY3Rpb24obGFuZykge1xyXG4gICAgICAgIHZhciBjb2RlID0gXCJcIjtcclxuICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDApKSB7XHJcbiAgICAgICAgICAgIGNvZGUgKz1cclxuICAgICAgICAgICAgICAgIFwiY2xhbXAoe3swfX0sXCIgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbiArXHJcbiAgICAgICAgICAgICAgICBcIixcIiArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4ICtcclxuICAgICAgICAgICAgICAgIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2NsYW1wXCIsIE1hdGhDbGFtcCk7XHJcblxyXG4gICAgLy9NYXRoIEFCU1xyXG4gICAgZnVuY3Rpb24gTWF0aExlcnAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBmOiAwLjUgfTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aExlcnAudGl0bGUgPSBcIkxlcnBcIjtcclxuICAgIE1hdGhMZXJwLmRlc2MgPSBcIkxpbmVhciBJbnRlcnBvbGF0aW9uXCI7XHJcblxyXG4gICAgTWF0aExlcnAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2MSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2MSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHYxID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHYyID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHYyID09IG51bGwpIHtcclxuICAgICAgICAgICAgdjIgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLnByb3BlcnRpZXMuZjtcclxuXHJcbiAgICAgICAgdmFyIF9mID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgaWYgKF9mICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZiA9IF9mO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYxICogKDEgLSBmKSArIHYyICogZik7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhMZXJwLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiZlwiLCBcIm51bWJlclwiXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9sZXJwXCIsIE1hdGhMZXJwKTtcclxuXHJcbiAgICAvL01hdGggQUJTXHJcbiAgICBmdW5jdGlvbiBNYXRoQWJzKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoQWJzLnRpdGxlID0gXCJBYnNcIjtcclxuICAgIE1hdGhBYnMuZGVzYyA9IFwiQWJzb2x1dGVcIjtcclxuXHJcbiAgICBNYXRoQWJzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgTWF0aC5hYnModikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvYWJzXCIsIE1hdGhBYnMpO1xyXG5cclxuICAgIC8vTWF0aCBGbG9vclxyXG4gICAgZnVuY3Rpb24gTWF0aEZsb29yKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoRmxvb3IudGl0bGUgPSBcIkZsb29yXCI7XHJcbiAgICBNYXRoRmxvb3IuZGVzYyA9IFwiRmxvb3IgbnVtYmVyIHRvIHJlbW92ZSBmcmFjdGlvbmFsIHBhcnRcIjtcclxuXHJcbiAgICBNYXRoRmxvb3IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBNYXRoLmZsb29yKHYpKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2Zsb29yXCIsIE1hdGhGbG9vcik7XHJcblxyXG4gICAgLy9NYXRoIGZyYWNcclxuICAgIGZ1bmN0aW9uIE1hdGhGcmFjKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoRnJhYy50aXRsZSA9IFwiRnJhY1wiO1xyXG4gICAgTWF0aEZyYWMuZGVzYyA9IFwiUmV0dXJucyBmcmFjdGlvbmFsIHBhcnRcIjtcclxuXHJcbiAgICBNYXRoRnJhYy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYgJSAxKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2ZyYWNcIiwgTWF0aEZyYWMpO1xyXG5cclxuICAgIC8vTWF0aCBGbG9vclxyXG4gICAgZnVuY3Rpb24gTWF0aFNtb290aFN0ZXAoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgQTogMCwgQjogMSB9O1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhTbW9vdGhTdGVwLnRpdGxlID0gXCJTbW9vdGhzdGVwXCI7XHJcbiAgICBNYXRoU21vb3RoU3RlcC5kZXNjID0gXCJTbW9vdGhzdGVwXCI7XHJcblxyXG4gICAgTWF0aFNtb290aFN0ZXAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZWRnZTAgPSB0aGlzLnByb3BlcnRpZXMuQTtcclxuICAgICAgICB2YXIgZWRnZTEgPSB0aGlzLnByb3BlcnRpZXMuQjtcclxuXHJcbiAgICAgICAgLy8gU2NhbGUsIGJpYXMgYW5kIHNhdHVyYXRlIHggdG8gMC4uMSByYW5nZVxyXG4gICAgICAgIHYgPSBNYXRoLmNsYW1wKCh2IC0gZWRnZTApIC8gKGVkZ2UxIC0gZWRnZTApLCAwLjAsIDEuMCk7XHJcbiAgICAgICAgLy8gRXZhbHVhdGUgcG9seW5vbWlhbFxyXG4gICAgICAgIHYgPSB2ICogdiAqICgzIC0gMiAqIHYpO1xyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdik7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9zbW9vdGhzdGVwXCIsIE1hdGhTbW9vdGhTdGVwKTtcclxuXHJcbiAgICAvL01hdGggc2NhbGVcclxuICAgIGZ1bmN0aW9uIE1hdGhTY2FsZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIiwgeyBsYWJlbDogXCJcIiB9KTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiLCB7IGxhYmVsOiBcIlwiIH0pO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJmYWN0b3JcIiwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFNjYWxlLnRpdGxlID0gXCJTY2FsZVwiO1xyXG4gICAgTWF0aFNjYWxlLmRlc2MgPSBcInYgKiBmYWN0b3JcIjtcclxuXHJcbiAgICBNYXRoU2NhbGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2YWx1ZSAqIHRoaXMucHJvcGVydGllcy5mYWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3NjYWxlXCIsIE1hdGhTY2FsZSk7XHJcblxyXG5cdC8vR2F0ZVxyXG5cdGZ1bmN0aW9uIEdhdGUoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidlwiLFwiYm9vbGVhblwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcclxuXHR9XHJcblxyXG5cdEdhdGUudGl0bGUgPSBcIkdhdGVcIjtcclxuXHRHYXRlLmRlc2MgPSBcImlmIHYgaXMgdHJ1ZSwgdGhlbiBvdXRwdXRzIEEsIG90aGVyd2lzZSBCXCI7XHJcblxyXG5cdEdhdGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmdldElucHV0RGF0YSggdiA/IDEgOiAyICkpO1xyXG5cdH07XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9nYXRlXCIsIEdhdGUpO1xyXG5cclxuXHJcbiAgICAvL01hdGggQXZlcmFnZVxyXG4gICAgZnVuY3Rpb24gTWF0aEF2ZXJhZ2VGaWx0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzYW1wbGVzXCIsIDEwKTtcclxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDEwKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoQXZlcmFnZUZpbHRlci50aXRsZSA9IFwiQXZlcmFnZVwiO1xyXG4gICAgTWF0aEF2ZXJhZ2VGaWx0ZXIuZGVzYyA9IFwiQXZlcmFnZSBGaWx0ZXJcIjtcclxuXHJcbiAgICBNYXRoQXZlcmFnZUZpbHRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHYgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG51bV9zYW1wbGVzID0gdGhpcy5fdmFsdWVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdGhpcy5fdmFsdWVzW3RoaXMuX2N1cnJlbnQgJSBudW1fc2FtcGxlc10gPSB2O1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudCA+IG51bV9zYW1wbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF2ciA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fc2FtcGxlczsgKytpKSB7XHJcbiAgICAgICAgICAgIGF2ciArPSB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgYXZyIC8gbnVtX3NhbXBsZXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoQXZlcmFnZUZpbHRlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDEpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMuc2FtcGxlcyA9IE1hdGgucm91bmQodmFsdWUpO1xyXG4gICAgICAgIHZhciBvbGQgPSB0aGlzLl92YWx1ZXM7XHJcblxyXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5wcm9wZXJ0aWVzLnNhbXBsZXMpO1xyXG4gICAgICAgIGlmIChvbGQubGVuZ3RoIDw9IHRoaXMuX3ZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnNldChvbGQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5zZXQob2xkLnN1YmFycmF5KDAsIHRoaXMuX3ZhbHVlcy5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9hdmVyYWdlXCIsIE1hdGhBdmVyYWdlRmlsdGVyKTtcclxuXHJcbiAgICAvL01hdGhcclxuICAgIGZ1bmN0aW9uIE1hdGhUZW5kVG8oKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJmYWN0b3JcIiwgMC4xKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFRlbmRUby50aXRsZSA9IFwiVGVuZFRvXCI7XHJcbiAgICBNYXRoVGVuZFRvLmRlc2MgPSBcIm1vdmVzIHRoZSBvdXRwdXQgdmFsdWUgYWx3YXlzIGNsb3NlciB0byB0aGUgaW5wdXRcIjtcclxuXHJcbiAgICBNYXRoVGVuZFRvLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmID0gdGhpcy5wcm9wZXJ0aWVzLmZhY3RvcjtcclxuICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl92YWx1ZSAqICgxIC0gZikgKyB2ICogZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3RlbmRUb1wiLCBNYXRoVGVuZFRvKTtcclxuXHJcbiAgICAvL01hdGggb3BlcmF0aW9uXHJcbiAgICBmdW5jdGlvbiBNYXRoT3BlcmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwibnVtYmVyLGFycmF5LG9iamVjdFwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIj1cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIkFcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIkJcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIk9QXCIsIFwiK1wiLCBcImVudW1cIiwgeyB2YWx1ZXM6IE1hdGhPcGVyYXRpb24udmFsdWVzIH0pO1xyXG5cdFx0dGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSArIEI7IH07XHJcblx0XHR0aGlzLl9yZXN1bHQgPSBbXTsgLy9vbmx5IHVzZWQgZm9yIGFycmF5c1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhPcGVyYXRpb24udmFsdWVzID0gW1wiK1wiLCBcIi1cIiwgXCIqXCIsIFwiL1wiLCBcIiVcIiwgXCJeXCIsIFwibWF4XCIsIFwibWluXCJdO1xyXG5cclxuXHRNYXRoT3BlcmF0aW9uLnRpdGxlID0gXCJPcGVyYXRpb25cIjtcclxuICAgIE1hdGhPcGVyYXRpb24uZGVzYyA9IFwiRWFzeSBtYXRoIG9wZXJhdG9yc1wiO1xyXG4gICAgTWF0aE9wZXJhdGlvbltcIkBPUFwiXSA9IHtcclxuICAgICAgICB0eXBlOiBcImVudW1cIixcclxuICAgICAgICB0aXRsZTogXCJvcGVyYXRpb25cIixcclxuICAgICAgICB2YWx1ZXM6IE1hdGhPcGVyYXRpb24udmFsdWVzXHJcbiAgICB9O1xyXG4gICAgTWF0aE9wZXJhdGlvbi5zaXplID0gWzEwMCwgNjBdO1xyXG5cclxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCJtYXhcIiB8fCB0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCJtaW5cIilcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJvcGVydGllcy5PUCArIFwiKEEsQilcIjtcclxuICAgICAgICByZXR1cm4gXCJBIFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QICsgXCIgQlwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoT3BlcmF0aW9uLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0gPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoT3BlcmF0aW9uLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKVxyXG5cdHtcclxuXHRcdGlmIChuYW1lICE9IFwiT1BcIilcclxuXHRcdFx0cmV0dXJuO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wZXJ0aWVzLk9QKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6IHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIEEgKyBCOyB9OyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIi1cIjogdGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSAtIEI7IH07IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwieFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiWFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiKlwiOiB0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBICogQjsgfTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6IHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIEEgLyBCOyB9OyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIiVcIjogdGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSAlIEI7IH07IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiXlwiOiB0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSxCKSB7IHJldHVybiBNYXRoLnBvdyhBLCBCKTsgfTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjogdGhpcy5fZnVuYyA9IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gTWF0aC5tYXgoQSwgQik7IH07IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWluXCI6IHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIE1hdGgubWluKEEsIEIpOyB9OyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiVW5rbm93biBvcGVyYXRpb246IFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QKTtcclxuXHRcdFx0XHR0aGlzLl9mdW5jID0gZnVuY3Rpb24oQSkgeyByZXR1cm4gQTsgfTtcclxuXHRcdFx0XHRicmVhaztcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoIEEgIT0gbnVsbCApIHtcclxuXHRcdFx0aWYoIEEuY29uc3RydWN0b3IgPT09IE51bWJlciApXHJcblx0ICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiQVwiXSA9IEE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQSA9IHRoaXMucHJvcGVydGllc1tcIkFcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcIkJcIl0gPSBCO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIEIgPSB0aGlzLnByb3BlcnRpZXNbXCJCXCJdO1xyXG4gICAgICAgIH1cclxuXHJcblx0XHR2YXIgcmVzdWx0O1xyXG5cdFx0aWYoQS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKVxyXG5cdFx0e1xyXG5cdCAgICAgICAgcmVzdWx0ID0gMDtcclxuXHRcdFx0cmVzdWx0ID0gdGhpcy5fZnVuYyhBLEIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihBLmNvbnN0cnVjdG9yID09PSBBcnJheSlcclxuXHRcdHtcclxuXHRcdFx0cmVzdWx0ID0gdGhpcy5fcmVzdWx0O1xyXG5cdFx0XHRyZXN1bHQubGVuZ3RoID0gQS5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBBLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2Z1bmMoQVtpXSxCKTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0cmVzdWx0ID0ge307XHJcblx0XHRcdGZvcih2YXIgaSBpbiBBKVxyXG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2Z1bmMoQVtpXSxCKTtcclxuXHRcdH1cclxuXHQgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjQwcHggQXJpYWxcIjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNjY2XCI7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuT1AsXHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAqIDAuNSxcclxuICAgICAgICAgICAgKHRoaXMuc2l6ZVsxXSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCkgKiAwLjVcclxuICAgICAgICApO1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL29wZXJhdGlvblwiLCBNYXRoT3BlcmF0aW9uKTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvb3BlcmF0aW9uXCIsIFwiTUFYXCIsIHtcclxuICAgICAgICBwcm9wZXJ0aWVzOiB7T1A6XCJtYXhcIn0sXHJcbiAgICAgICAgdGl0bGU6IFwiTUFYKClcIlxyXG4gICAgfSk7XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL29wZXJhdGlvblwiLCBcIk1JTlwiLCB7XHJcbiAgICAgICAgcHJvcGVydGllczoge09QOlwibWluXCJ9LFxyXG4gICAgICAgIHRpdGxlOiBcIk1JTigpXCJcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvL01hdGggY29tcGFyZVxyXG4gICAgZnVuY3Rpb24gTWF0aENvbXBhcmUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJBPT1CXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIkEhPUJcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJBXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJCXCIsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhDb21wYXJlLnRpdGxlID0gXCJDb21wYXJlXCI7XHJcbiAgICBNYXRoQ29tcGFyZS5kZXNjID0gXCJjb21wYXJlcyBiZXR3ZWVuIHR3byB2YWx1ZXNcIjtcclxuXHJcbiAgICBNYXRoQ29tcGFyZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChBICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiQVwiXSA9IEE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQSA9IHRoaXMucHJvcGVydGllc1tcIkFcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcIkJcIl0gPSBCO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIEIgPSB0aGlzLnByb3BlcnRpZXNbXCJCXCJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgIGlmICghb3V0cHV0LmxpbmtzIHx8ICFvdXRwdXQubGlua3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBPT1CXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBID09IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQSE9QlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQSAhPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkE+QlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQSA+IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQTxCXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBIDwgQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBPD1CXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBIDw9IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQT49QlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQSA+PSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoQ29tcGFyZS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wiQT09QlwiLCBcImJvb2xlYW5cIl0sXHJcbiAgICAgICAgICAgIFtcIkEhPUJcIiwgXCJib29sZWFuXCJdLFxyXG4gICAgICAgICAgICBbXCJBPkJcIiwgXCJib29sZWFuXCJdLFxyXG4gICAgICAgICAgICBbXCJBPEJcIiwgXCJib29sZWFuXCJdLFxyXG4gICAgICAgICAgICBbXCJBPj1CXCIsIFwiYm9vbGVhblwiXSxcclxuICAgICAgICAgICAgW1wiQTw9QlwiLCBcImJvb2xlYW5cIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvY29tcGFyZVwiLCBNYXRoQ29tcGFyZSk7XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI9PVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogW1tcIkE9PUJcIiwgXCJib29sZWFuXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJBPT1CXCJcclxuICAgIH0pO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCIhPVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogW1tcIkEhPUJcIiwgXCJib29sZWFuXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJBIT1CXCJcclxuICAgIH0pO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI+XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiQT5CXCIsIFwiYm9vbGVhblwiXV0sXHJcbiAgICAgICAgdGl0bGU6IFwiQT5CXCJcclxuICAgIH0pO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI8XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wiQTxCXCIsIFwiYm9vbGVhblwiXV0sXHJcbiAgICAgICAgdGl0bGU6IFwiQTxCXCJcclxuICAgIH0pO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI+PVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogW1tcIkE+PUJcIiwgXCJib29sZWFuXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJBPj1CXCJcclxuICAgIH0pO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI8PVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogW1tcIkE8PUJcIiwgXCJib29sZWFuXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJBPD1CXCJcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGhDb25kaXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ0cnVlXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZhbHNlXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQVwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQlwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiT1BcIiwgXCI+XCIsIFwiZW51bVwiLCB7IHZhbHVlczogTWF0aENvbmRpdGlvbi52YWx1ZXMgfSk7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJDb25kLlwiLHRoaXMucHJvcGVydGllcy5PUCx7IHByb3BlcnR5OiBcIk9QXCIsIHZhbHVlczogTWF0aENvbmRpdGlvbi52YWx1ZXMgfSApO1xyXG5cclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDYwXTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoQ29uZGl0aW9uLnZhbHVlcyA9IFtcIj5cIiwgXCI8XCIsIFwiPT1cIiwgXCIhPVwiLCBcIjw9XCIsIFwiPj1cIiwgXCJ8fFwiLCBcIiYmXCIgXTtcclxuICAgIE1hdGhDb25kaXRpb25bXCJAT1BcIl0gPSB7XHJcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXHJcbiAgICAgICAgdGl0bGU6IFwib3BlcmF0aW9uXCIsXHJcbiAgICAgICAgdmFsdWVzOiBNYXRoQ29uZGl0aW9uLnZhbHVlc1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoQ29uZGl0aW9uLnRpdGxlID0gXCJDb25kaXRpb25cIjtcclxuICAgIE1hdGhDb25kaXRpb24uZGVzYyA9IFwiZXZhbHVhdGVzIGNvbmRpdGlvbiBiZXR3ZWVuIEEgYW5kIEJcIjtcclxuXHJcbiAgICBNYXRoQ29uZGl0aW9uLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIkEgXCIgKyB0aGlzLnByb3BlcnRpZXMuT1AgKyBcIiBCXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhDb25kaXRpb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKEEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBBID0gdGhpcy5wcm9wZXJ0aWVzLkE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLkEgPSBBO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoQiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIEIgPSB0aGlzLnByb3BlcnRpZXMuQjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuQiA9IEI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMucHJvcGVydGllcy5PUCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSA+IEI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIjxcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPCBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCI9PVwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSA9PSBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSAhPSBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSA8PSBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSA+PSBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ8fFwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSB8fCBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCImJlwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQSAmJiBCO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmVzdWx0KTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgIXJlc3VsdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9jb25kaXRpb25cIiwgTWF0aENvbmRpdGlvbik7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGhCcmFuY2goKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb25kXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgXCJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmYWxzZVwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDYwXTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoQnJhbmNoLnRpdGxlID0gXCJCcmFuY2hcIjtcclxuICAgIE1hdGhCcmFuY2guZGVzYyA9IFwiSWYgY29uZGl0aW9uIGlzIHRydWUsIG91dHB1dHMgSU4gaW4gdHJ1ZSwgb3RoZXJ3aXNlIGluIGZhbHNlXCI7XHJcblxyXG4gICAgTWF0aEJyYW5jaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIFYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICB2YXIgY29uZCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cclxuXHRcdGlmKGNvbmQpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBWKTtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIG51bGwpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgbnVsbCk7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCBWKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2JyYW5jaFwiLCBNYXRoQnJhbmNoKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aEFjY3VtdWxhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluY1wiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRvdGFsXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJpbmNyZW1lbnRcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhBY2N1bXVsYXRlLnRpdGxlID0gXCJBY2N1bXVsYXRlXCI7XHJcbiAgICBNYXRoQWNjdW11bGF0ZS5kZXNjID0gXCJJbmNyZW1lbnRzIGEgdmFsdWUgZXZlcnkgdGltZVwiO1xyXG5cclxuICAgIE1hdGhBY2N1bXVsYXRlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5jID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKGluYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgKz0gaW5jO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSArPSB0aGlzLnByb3BlcnRpZXMuaW5jcmVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2FjY3VtdWxhdGVcIiwgTWF0aEFjY3VtdWxhdGUpO1xyXG5cclxuICAgIC8vTWF0aCBUcmlnb25vbWV0cnlcclxuICAgIGZ1bmN0aW9uIE1hdGhUcmlnb25vbWV0cnkoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJzaW5cIiwgXCJudW1iZXJcIik7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJhbXBsaXR1ZGVcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm9mZnNldFwiLCAwKTtcclxuICAgICAgICB0aGlzLmJnSW1hZ2VVcmwgPSBcIm5vZGVzL2ltZ3MvaWNvbi1zaW4ucG5nXCI7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aFRyaWdvbm9tZXRyeS50aXRsZSA9IFwiVHJpZ29ub21ldHJ5XCI7XHJcbiAgICBNYXRoVHJpZ29ub21ldHJ5LmRlc2MgPSBcIlNpbiBDb3MgVGFuXCI7XHJcbiAgICAvL01hdGhUcmlnb25vbWV0cnkuZmlsdGVyID0gXCJzaGFkZXJcIjtcclxuXHJcbiAgICBNYXRoVHJpZ29ub21ldHJ5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbXBsaXR1ZGUgPSB0aGlzLnByb3BlcnRpZXNbXCJhbXBsaXR1ZGVcIl07XHJcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRJbnB1dFNsb3QoXCJhbXBsaXR1ZGVcIik7XHJcbiAgICAgICAgaWYgKHNsb3QgIT0gLTEpIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gdGhpcy5nZXRJbnB1dERhdGEoc2xvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnByb3BlcnRpZXNbXCJvZmZzZXRcIl07XHJcbiAgICAgICAgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChcIm9mZnNldFwiKTtcclxuICAgICAgICBpZiAoc2xvdCAhPSAtMSkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldElucHV0RGF0YShzbG90KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzaW5cIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguc2luKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImNvc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5jb3Modik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidGFuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnRhbih2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhc2luXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmFzaW4odik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWNvc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5hY29zKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImF0YW5cIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYXRhbih2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgYW1wbGl0dWRlICogdmFsdWUgKyBvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTWF0aFRyaWdvbm9tZXRyeS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcInZcIiwgXCJudW1iZXJcIl0sIFtcImFtcGxpdHVkZVwiLCBcIm51bWJlclwiXSwgW1wib2Zmc2V0XCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aFRyaWdvbm9tZXRyeS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wic2luXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJjb3NcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInRhblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYXNpblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYWNvc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYXRhblwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC90cmlnb25vbWV0cnlcIiwgTWF0aFRyaWdvbm9tZXRyeSk7XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL3RyaWdvbm9tZXRyeVwiLCBcIlNJTigpXCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbW1wic2luXCIsIFwibnVtYmVyXCJdXSxcclxuICAgICAgICB0aXRsZTogXCJTSU4oKVwiXHJcbiAgICB9KTtcclxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC90cmlnb25vbWV0cnlcIiwgXCJDT1MoKVwiLCB7XHJcbiAgICAgICAgb3V0cHV0czogW1tcImNvc1wiLCBcIm51bWJlclwiXV0sXHJcbiAgICAgICAgdGl0bGU6IFwiQ09TKClcIlxyXG4gICAgfSk7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvdHJpZ29ub21ldHJ5XCIsIFwiVEFOKClcIiwge1xyXG4gICAgICAgIG91dHB1dHM6IFtbXCJ0YW5cIiwgXCJudW1iZXJcIl1dLFxyXG4gICAgICAgIHRpdGxlOiBcIlRBTigpXCJcclxuICAgIH0pO1xyXG5cclxuICAgIC8vbWF0aCBsaWJyYXJ5IGZvciBzYWZlIG1hdGggb3BlcmF0aW9ucyB3aXRob3V0IGV2YWxcclxuICAgIGZ1bmN0aW9uIE1hdGhGb3JtdWxhKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ5XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgeDogMS4wLCB5OiAxLjAsIGZvcm11bGE6IFwieCt5XCIgfTtcclxuICAgICAgICB0aGlzLmNvZGVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXHJcbiAgICAgICAgICAgIFwidGV4dFwiLFxyXG4gICAgICAgICAgICBcIkYoeCx5KVwiLFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZm9ybXVsYSxcclxuICAgICAgICAgICAgZnVuY3Rpb24odiwgY2FudmFzLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuZm9ybXVsYSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KFwidG9nZ2xlXCIsIFwiYWxsb3dcIiwgTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMsIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMgPSB2O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2Z1bmMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGhGb3JtdWxhLnRpdGxlID0gXCJGb3JtdWxhXCI7XHJcbiAgICBNYXRoRm9ybXVsYS5kZXNjID0gXCJDb21wdXRlIGZvcm11bGFcIjtcclxuICAgIE1hdGhGb3JtdWxhLnNpemUgPSBbMTYwLCAxMDBdO1xyXG5cclxuICAgIE1hdGhBdmVyYWdlRmlsdGVyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJmb3JtdWxhXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2RlX3dpZGdldC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTWF0aEZvcm11bGEucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmICh4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wieFwiXSA9IHg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IHRoaXMucHJvcGVydGllc1tcInhcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoeSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcInlcIl0gPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXNbXCJ5XCJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLnByb3BlcnRpZXNbXCJmb3JtdWxhXCJdO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mdW5jIHx8IHRoaXMuX2Z1bmNfY29kZSAhPSB0aGlzLnByb3BlcnRpZXMuZm9ybXVsYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnVuYyA9IG5ldyBGdW5jdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcInhcIixcclxuICAgICAgICAgICAgICAgICAgICBcInlcIixcclxuICAgICAgICAgICAgICAgICAgICBcIlRJTUVcIixcclxuICAgICAgICAgICAgICAgICAgICBcInJldHVybiBcIiArIHRoaXMucHJvcGVydGllcy5mb3JtdWxhXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnVuY19jb2RlID0gdGhpcy5wcm9wZXJ0aWVzLmZvcm11bGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9mdW5jKHgsIHksIHRoaXMuZ3JhcGguZ2xvYmFsdGltZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBudWxsO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aEZvcm11bGEucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bmNfY29kZSB8fCBcIkZvcm11bGFcIjtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aEZvcm11bGEucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZiA9IHRoaXMucHJvcGVydGllc1tcImZvcm11bGFcIl07XHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvZm9ybXVsYVwiLCBNYXRoRm9ybXVsYSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEVmVjMlRvWFkoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZlYzJcIiwgXCJ2ZWMyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInlcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjMlRvWFkudGl0bGUgPSBcIlZlYzItPlhZXCI7XHJcbiAgICBNYXRoM0RWZWMyVG9YWS5kZXNjID0gXCJ2ZWN0b3IgMiB0byBjb21wb25lbnRzXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjMlRvWFkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdlswXSk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHZbMV0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMyLXRvLXh5XCIsIE1hdGgzRFZlYzJUb1hZKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RYWVRvVmVjMigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0cyhbW1wieFwiLCBcIm51bWJlclwiXSwgW1wieVwiLCBcIm51bWJlclwiXV0pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmVjMlwiLCBcInZlYzJcIik7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEWFlUb1ZlYzIudGl0bGUgPSBcIlhZLT5WZWMyXCI7XHJcbiAgICBNYXRoM0RYWVRvVmVjMi5kZXNjID0gXCJjb21wb25lbnRzIHRvIHZlY3RvcjJcIjtcclxuXHJcbiAgICBNYXRoM0RYWVRvVmVjMi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHggPSB0aGlzLnByb3BlcnRpZXMueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXMueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBkYXRhWzBdID0geDtcclxuICAgICAgICBkYXRhWzFdID0geTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC94eS10by12ZWMyXCIsIE1hdGgzRFhZVG9WZWMyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzVG9YWVooKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZlYzNcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInlcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ6XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFZlYzNUb1hZWi50aXRsZSA9IFwiVmVjMy0+WFlaXCI7XHJcbiAgICBNYXRoM0RWZWMzVG9YWVouZGVzYyA9IFwidmVjdG9yIDMgdG8gY29tcG9uZW50c1wiO1xyXG5cclxuICAgIE1hdGgzRFZlYzNUb1hZWi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2WzBdKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdlsxXSk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDIsIHZbMl0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLXRvLXh5elwiLCBNYXRoM0RWZWMzVG9YWVopO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFhZWlRvVmVjMygpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0cyhbW1wieFwiLCBcIm51bWJlclwiXSwgW1wieVwiLCBcIm51bWJlclwiXSwgW1wielwiLCBcIm51bWJlclwiXV0pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmVjM1wiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB4OiAwLCB5OiAwLCB6OiAwIH07XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEWFlaVG9WZWMzLnRpdGxlID0gXCJYWVotPlZlYzNcIjtcclxuICAgIE1hdGgzRFhZWlRvVmVjMy5kZXNjID0gXCJjb21wb25lbnRzIHRvIHZlY3RvcjNcIjtcclxuXHJcbiAgICBNYXRoM0RYWVpUb1ZlYzMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB4ID0gdGhpcy5wcm9wZXJ0aWVzLng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB5ID0gdGhpcy5wcm9wZXJ0aWVzLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB6ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgaWYgKHogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB6ID0gdGhpcy5wcm9wZXJ0aWVzLno7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgZGF0YVswXSA9IHg7XHJcbiAgICAgICAgZGF0YVsxXSA9IHk7XHJcbiAgICAgICAgZGF0YVsyXSA9IHo7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QveHl6LXRvLXZlYzNcIiwgTWF0aDNEWFlaVG9WZWMzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWM0VG9YWVpXKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2ZWM0XCIsIFwidmVjNFwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInhcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ5XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwielwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIndcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjNFRvWFlaVy50aXRsZSA9IFwiVmVjNC0+WFlaV1wiO1xyXG4gICAgTWF0aDNEVmVjNFRvWFlaVy5kZXNjID0gXCJ2ZWN0b3IgNCB0byBjb21wb25lbnRzXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjNFRvWFlaVy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2WzBdKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdlsxXSk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDIsIHZbMl0pO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgzLCB2WzNdKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvdmVjNC10by14eXp3XCIsIE1hdGgzRFZlYzRUb1hZWlcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFhZWldUb1ZlYzQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1xyXG4gICAgICAgICAgICBbXCJ4XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ5XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ6XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ3XCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2ZWM0XCIsIFwidmVjNFwiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDAgfTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RYWVpXVG9WZWM0LnRpdGxlID0gXCJYWVpXLT5WZWM0XCI7XHJcbiAgICBNYXRoM0RYWVpXVG9WZWM0LmRlc2MgPSBcImNvbXBvbmVudHMgdG8gdmVjdG9yNFwiO1xyXG5cclxuICAgIE1hdGgzRFhZWldUb1ZlYzQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB4ID0gdGhpcy5wcm9wZXJ0aWVzLng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB5ID0gdGhpcy5wcm9wZXJ0aWVzLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB6ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgaWYgKHogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB6ID0gdGhpcy5wcm9wZXJ0aWVzLno7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3ID0gdGhpcy5nZXRJbnB1dERhdGEoMyk7XHJcbiAgICAgICAgaWYgKHcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3ID0gdGhpcy5wcm9wZXJ0aWVzLnc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgZGF0YVswXSA9IHg7XHJcbiAgICAgICAgZGF0YVsxXSA9IHk7XHJcbiAgICAgICAgZGF0YVsyXSA9IHo7XHJcbiAgICAgICAgZGF0YVszXSA9IHc7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QveHl6dy10by12ZWM0XCIsIE1hdGgzRFhZWldUb1ZlYzQpO1xyXG5cclxufSkodGhpcyk7XHJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBNYXRoM0RNYXQ0KClcclxuXHR7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlRcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJSXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiU1wiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJtYXQ0XCIsIFwibWF0NFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0XCJUXCI6WzAsMCwwXSxcclxuXHRcdFx0XCJSXCI6WzAsMCwwXSxcclxuXHRcdFx0XCJTXCI6WzEsMSwxXSxcclxuXHRcdFx0Ul9pbl9kZWdyZWVzOiB0cnVlXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5fcmVzdWx0ID0gbWF0NC5jcmVhdGUoKTtcclxuXHRcdHRoaXMuX211c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdE1hdGgzRE1hdDQudGl0bGUgPSBcIm1hdDRcIjtcclxuXHRNYXRoM0RNYXQ0LnRlbXBfcXVhdCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwwLDFdKTtcclxuXHRNYXRoM0RNYXQ0LnRlbXBfbWF0NCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cdE1hdGgzRE1hdDQudGVtcF92ZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuXHJcblx0TWF0aDNETWF0NC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSlcclxuXHR7XHJcblx0XHR0aGlzLl9tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRNYXRoM0RNYXQ0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIE0gPSB0aGlzLl9yZXN1bHQ7XHJcblx0XHR2YXIgUSA9IE1hdGgzRE1hdDQudGVtcF9xdWF0O1xyXG5cdFx0dmFyIHRlbXBfbWF0NCA9IE1hdGgzRE1hdDQudGVtcF9tYXQ0O1xyXG5cdFx0dmFyIHRlbXBfdmVjMyA9IE1hdGgzRE1hdDQudGVtcF92ZWMzO1xyXG5cclxuXHRcdHZhciBUID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHR2YXIgUiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0dmFyIFMgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuXHJcblx0XHRpZiggdGhpcy5fbXVzdF91cGRhdGUgfHwgVCB8fCBSIHx8IFMgKVxyXG5cdFx0e1xyXG5cdFx0XHRUID0gVCB8fCB0aGlzLnByb3BlcnRpZXMuVDtcclxuXHRcdFx0UiA9IFIgfHwgdGhpcy5wcm9wZXJ0aWVzLlI7XHJcblx0XHRcdFMgPSBTIHx8IHRoaXMucHJvcGVydGllcy5TO1xyXG5cdFx0XHRtYXQ0LmlkZW50aXR5KCBNICk7XHJcblx0XHRcdG1hdDQudHJhbnNsYXRlKCBNLCBNLCBUICk7XHJcblx0XHRcdGlmKHRoaXMucHJvcGVydGllcy5SX2luX2RlZ3JlZXMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0ZW1wX3ZlYzMuc2V0KCBSICk7XHJcblx0XHRcdFx0dmVjMy5zY2FsZSh0ZW1wX3ZlYzMsdGVtcF92ZWMzLERFRzJSQUQpO1xyXG5cdFx0XHRcdHF1YXQuZnJvbUV1bGVyKCBRLCB0ZW1wX3ZlYzMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cXVhdC5mcm9tRXVsZXIoIFEsIFIgKTtcclxuXHRcdFx0bWF0NC5mcm9tUXVhdCggdGVtcF9tYXQ0LCBRICk7XHJcblx0XHRcdG1hdDQubXVsdGlwbHkoIE0sIE0sIHRlbXBfbWF0NCApO1xyXG5cdFx0XHRtYXQ0LnNjYWxlKCBNLCBNLCBTICk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIE0pO1x0XHRcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvbWF0NFwiLCBNYXRoM0RNYXQ0KTtcclxuXHJcbiAgICAvL01hdGggM0Qgb3BlcmF0aW9uXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RPcGVyYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJudW1iZXIsdmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIm51bWJlcix2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiPVwiLCBcIm51bWJlcix2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJPUFwiLCBcIitcIiwgXCJlbnVtXCIsIHsgdmFsdWVzOiBNYXRoM0RPcGVyYXRpb24udmFsdWVzIH0pO1xyXG5cdFx0dGhpcy5fcmVzdWx0ID0gdmVjMy5jcmVhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RPcGVyYXRpb24udmFsdWVzID0gW1wiK1wiLCBcIi1cIiwgXCIqXCIsIFwiL1wiLCBcIiVcIiwgXCJeXCIsIFwibWF4XCIsIFwibWluXCIsXCJkb3RcIixcImNyb3NzXCJdO1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aDNkL29wZXJhdGlvblwiLCBcIkNST1NTKClcIiwge1xyXG4gICAgICAgIHByb3BlcnRpZXM6IHtcIk9QXCI6XCJjcm9zc1wifSxcclxuICAgICAgICB0aXRsZTogXCJDUk9TUygpXCJcclxuICAgIH0pO1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aDNkL29wZXJhdGlvblwiLCBcIkRPVCgpXCIsIHtcclxuICAgICAgICBwcm9wZXJ0aWVzOiB7XCJPUFwiOlwiZG90XCJ9LFxyXG4gICAgICAgIHRpdGxlOiBcIkRPVCgpXCJcclxuICAgIH0pO1xyXG5cclxuXHRNYXRoM0RPcGVyYXRpb24udGl0bGUgPSBcIk9wZXJhdGlvblwiO1xyXG4gICAgTWF0aDNET3BlcmF0aW9uLmRlc2MgPSBcIkVhc3kgbWF0aCAzRCBvcGVyYXRvcnNcIjtcclxuICAgIE1hdGgzRE9wZXJhdGlvbltcIkBPUFwiXSA9IHtcclxuICAgICAgICB0eXBlOiBcImVudW1cIixcclxuICAgICAgICB0aXRsZTogXCJvcGVyYXRpb25cIixcclxuICAgICAgICB2YWx1ZXM6IE1hdGgzRE9wZXJhdGlvbi52YWx1ZXNcclxuICAgIH07XHJcbiAgICBNYXRoM0RPcGVyYXRpb24uc2l6ZSA9IFsxMDAsIDYwXTtcclxuXHJcbiAgICBNYXRoM0RPcGVyYXRpb24ucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCJtYXhcIiB8fCB0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCJtaW5cIiApXHJcblx0XHRcdHJldHVybiB0aGlzLnByb3BlcnRpZXMuT1AgKyBcIihBLEIpXCI7XHJcbiAgICAgICAgcmV0dXJuIFwiQSBcIiArIHRoaXMucHJvcGVydGllcy5PUCArIFwiIEJcIjtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aDNET3BlcmF0aW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHRpZihBID09IG51bGwgfHwgQiA9PSBudWxsKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRpZihBLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpXHJcblx0XHRcdEEgPSBbQSxBLEFdO1xyXG5cdFx0aWYoQi5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKVxyXG5cdFx0XHRCID0gW0IsQixCXTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMucHJvcGVydGllcy5PUCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmVjMy5hZGQocmVzdWx0LEEsQik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZlYzMuc3ViKHJlc3VsdCxBLEIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJYXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2ZWMzLm11bChyZXN1bHQsQSxCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmVjMy5kaXYocmVzdWx0LEEsQik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIiVcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IEFbMF0lQlswXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IEFbMV0lQlsxXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsyXSA9IEFbMl0lQlsyXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gTWF0aC5wb3coQVswXSxCWzBdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IE1hdGgucG93KEFbMV0sQlsxXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMl0gPSBNYXRoLnBvdyhBWzJdLEJbMl0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IE1hdGgubWF4KEFbMF0sQlswXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBNYXRoLm1heChBWzFdLEJbMV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzJdID0gTWF0aC5tYXgoQVsyXSxCWzJdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWluXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSBNYXRoLm1pbihBWzBdLEJbMF0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5taW4oQVsxXSxCWzFdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsyXSA9IE1hdGgubWluKEFbMl0sQlsyXSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkb3RcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZlYzMuZG90KEEsQik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNyb3NzXCI6XHJcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHJlc3VsdCxBLEIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIG9wZXJhdGlvbjogXCIgKyB0aGlzLnByb3BlcnRpZXMuT1ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aDNET3BlcmF0aW9uLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN0eC5mb250ID0gXCI0MHB4IEFyaWFsXCI7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzY2NlwiO1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLk9QLFxyXG4gICAgICAgICAgICB0aGlzLnNpemVbMF0gKiAwLjUsXHJcbiAgICAgICAgICAgICh0aGlzLnNpemVbMV0gKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpICogMC41XHJcbiAgICAgICAgKTtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL29wZXJhdGlvblwiLCBNYXRoM0RPcGVyYXRpb24pO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzNTY2FsZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJmXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGY6IDEgfTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWMzU2NhbGUudGl0bGUgPSBcInZlYzNfc2NhbGVcIjtcclxuICAgIE1hdGgzRFZlYzNTY2FsZS5kZXNjID0gXCJzY2FsZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjM1NjYWxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChmID09IG51bGwpIHtcclxuICAgICAgICAgICAgZiA9IHRoaXMucHJvcGVydGllcy5mO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgIGRhdGFbMF0gPSB2WzBdICogZjtcclxuICAgICAgICBkYXRhWzFdID0gdlsxXSAqIGY7XHJcbiAgICAgICAgZGF0YVsyXSA9IHZbMl0gKiBmO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvdmVjMy1zY2FsZVwiLCBNYXRoM0RWZWMzU2NhbGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzNMZW5ndGgoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWMzTGVuZ3RoLnRpdGxlID0gXCJ2ZWMzX2xlbmd0aFwiO1xyXG4gICAgTWF0aDNEVmVjM0xlbmd0aC5kZXNjID0gXCJyZXR1cm5zIHRoZSBtb2R1bGUgb2YgYSB2ZWN0b3JcIjtcclxuXHJcbiAgICBNYXRoM0RWZWMzTGVuZ3RoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkaXN0KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvdmVjMy1sZW5ndGhcIiwgTWF0aDNEVmVjM0xlbmd0aCk7XHJcblxyXG4gICAgZnVuY3Rpb24gTWF0aDNEVmVjM05vcm1hbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWMzTm9ybWFsaXplLnRpdGxlID0gXCJ2ZWMzX25vcm1hbGl6ZVwiO1xyXG4gICAgTWF0aDNEVmVjM05vcm1hbGl6ZS5kZXNjID0gXCJyZXR1cm5zIHRoZSB2ZWN0b3Igbm9ybWFsaXplZFwiO1xyXG5cclxuICAgIE1hdGgzRFZlYzNOb3JtYWxpemUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXSk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgIGRhdGFbMF0gPSB2WzBdIC8gZGlzdDtcclxuICAgICAgICBkYXRhWzFdID0gdlsxXSAvIGRpc3Q7XHJcbiAgICAgICAgZGF0YVsyXSA9IHZbMl0gLyBkaXN0O1xyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzMtbm9ybWFsaXplXCIsIE1hdGgzRFZlYzNOb3JtYWxpemUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzNMZXJwKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImZcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGY6IDAuNSB9O1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGgzRFZlYzNMZXJwLnRpdGxlID0gXCJ2ZWMzX2xlcnBcIjtcclxuICAgIE1hdGgzRFZlYzNMZXJwLmRlc2MgPSBcInJldHVybnMgdGhlIGludGVycG9sYXRlZCB2ZWN0b3JcIjtcclxuXHJcbiAgICBNYXRoM0RWZWMzTGVycC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoQSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoQiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImZcIik7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBkYXRhWzBdID0gQVswXSAqICgxIC0gZikgKyBCWzBdICogZjtcclxuICAgICAgICBkYXRhWzFdID0gQVsxXSAqICgxIC0gZikgKyBCWzFdICogZjtcclxuICAgICAgICBkYXRhWzJdID0gQVsyXSAqICgxIC0gZikgKyBCWzJdICogZjtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLWxlcnBcIiwgTWF0aDNEVmVjM0xlcnApO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzNEb3QoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWMzRG90LnRpdGxlID0gXCJ2ZWMzX2RvdFwiO1xyXG4gICAgTWF0aDNEVmVjM0RvdC5kZXNjID0gXCJyZXR1cm5zIHRoZSBkb3QgcHJvZHVjdFwiO1xyXG5cclxuICAgIE1hdGgzRFZlYzNEb3QucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKEEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKEIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZG90ID0gQVswXSAqIEJbMF0gKyBBWzFdICogQlsxXSArIEFbMl0gKiBCWzJdO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkb3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLWRvdFwiLCBNYXRoM0RWZWMzRG90KTtcclxuXHJcbiAgICAvL2lmIGdsTWF0cml4IGlzIGluc3RhbGxlZC4uLlxyXG4gICAgaWYgKGdsb2JhbC5nbE1hdHJpeCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGgzRFF1YXRlcm5pb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicXVhdFwiLCBcInF1YXRcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgeDogMCwgeTogMCwgejogMCwgdzogMSwgbm9ybWFsaXplOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHF1YXQuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoM0RRdWF0ZXJuaW9uLnRpdGxlID0gXCJRdWF0ZXJuaW9uXCI7XHJcbiAgICAgICAgTWF0aDNEUXVhdGVybmlvbi5kZXNjID0gXCJxdWF0ZXJuaW9uXCI7XHJcblxyXG4gICAgICAgIE1hdGgzRFF1YXRlcm5pb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVswXSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwieFwiKTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVbMV0gPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInlcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlWzJdID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ6XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVszXSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwid1wiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5ub3JtYWxpemUpIHtcclxuICAgICAgICAgICAgICAgIHF1YXQubm9ybWFsaXplKHRoaXMuX3ZhbHVlLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBNYXRoM0RRdWF0ZXJuaW9uLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgW1wieFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgICAgIFtcInlcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgICAgICBbXCJ6XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICAgICAgW1wid1wiLCBcIm51bWJlclwiXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3F1YXRlcm5pb25cIiwgTWF0aDNEUXVhdGVybmlvbik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGgzRFJvdGF0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0cyhbW1wiZGVncmVlc1wiLCBcIm51bWJlclwiXSwgW1wiYXhpc1wiLCBcInZlYzNcIl1dKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJxdWF0XCIsIFwicXVhdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBhbmdsZTogOTAuMCwgYXhpczogdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHF1YXQuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoM0RSb3RhdGlvbi50aXRsZSA9IFwiUm90YXRpb25cIjtcclxuICAgICAgICBNYXRoM0RSb3RhdGlvbi5kZXNjID0gXCJxdWF0ZXJuaW9uIHJvdGF0aW9uXCI7XHJcblxyXG4gICAgICAgIE1hdGgzRFJvdGF0aW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmIChhbmdsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhbmdsZSA9IHRoaXMucHJvcGVydGllcy5hbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICBpZiAoYXhpcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBheGlzID0gdGhpcy5wcm9wZXJ0aWVzLmF4aXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBSID0gcXVhdC5zZXRBeGlzQW5nbGUodGhpcy5fdmFsdWUsIGF4aXMsIGFuZ2xlICogMC4wMTc0NTMyOTI1KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIFIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3JvdGF0aW9uXCIsIE1hdGgzRFJvdGF0aW9uKTtcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGhFdWxlclRvUXVhdCgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcImV1bGVyXCIsIFwidmVjM1wiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJxdWF0XCIsIFwicXVhdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBldWxlcjpbMCwwLDBdLCB1c2VfeWF3X3BpdGNoX3JvbGw6IGZhbHNlIH07XHJcblx0XHRcdHRoaXMuX2RlZ3MgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHF1YXQuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoRXVsZXJUb1F1YXQudGl0bGUgPSBcIkV1bGVyLT5RdWF0XCI7XHJcbiAgICAgICAgTWF0aEV1bGVyVG9RdWF0LmRlc2MgPSBcIkNvbnZlcnRzIGV1bGVyIGFuZ2xlcyAoaW4gZGVncmVlcykgdG8gcXVhdGVybmlvblwiO1xyXG5cclxuICAgICAgICBNYXRoRXVsZXJUb1F1YXQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZXVsZXIgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKGV1bGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGV1bGVyID0gdGhpcy5wcm9wZXJ0aWVzLmV1bGVyO1xyXG4gICAgICAgICAgICB9XHJcblx0XHRcdHZlYzMuc2NhbGUoIHRoaXMuX2RlZ3MsIGV1bGVyLCBERUcyUkFEICk7XHJcblx0XHRcdGlmKHRoaXMucHJvcGVydGllcy51c2VfeWF3X3BpdGNoX3JvbGwpXHJcblx0XHRcdFx0dGhpcy5fZGVncyA9IFt0aGlzLl9kZWdzWzJdLHRoaXMuX2RlZ3NbMF0sdGhpcy5fZGVnc1sxXV07XHJcbiAgICAgICAgICAgIHZhciBSID0gcXVhdC5mcm9tRXVsZXIodGhpcy5fdmFsdWUsIHRoaXMuX2RlZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgUik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvZXVsZXJfdG9fcXVhdFwiLCBNYXRoRXVsZXJUb1F1YXQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBNYXRoUXVhdFRvRXVsZXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoW1wicXVhdFwiLCBcInF1YXRcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcImV1bGVyXCIsIFwidmVjM1wiKTtcclxuXHRcdFx0dGhpcy5fdmFsdWUgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aFF1YXRUb0V1bGVyLnRpdGxlID0gXCJFdWxlci0+UXVhdFwiO1xyXG4gICAgICAgIE1hdGhRdWF0VG9FdWxlci5kZXNjID0gXCJDb252ZXJ0cyByb3RYLHJvdFkscm90WiBpbiBkZWdyZWVzIHRvIHF1YXRcIjtcclxuXHJcbiAgICAgICAgTWF0aFF1YXRUb0V1bGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdFx0aWYoIXEpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgUiA9IHF1YXQudG9FdWxlcih0aGlzLl92YWx1ZSwgcSk7XHJcblx0XHRcdHZlYzMuc2NhbGUoIHRoaXMuX3ZhbHVlLCB0aGlzLl92YWx1ZSwgREVHMlJBRCApO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3F1YXRfdG9fZXVsZXJcIiwgTWF0aFF1YXRUb0V1bGVyKTtcclxuXHJcblxyXG4gICAgICAgIC8vTWF0aDNEIHJvdGF0ZSB2ZWMzXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aDNEUm90YXRlVmVjMygpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1tcInZlYzNcIiwgXCJ2ZWMzXCJdLCBbXCJxdWF0XCIsIFwicXVhdFwiXV0pO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcInJlc3VsdFwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgdmVjOiBbMCwgMCwgMV0gfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGgzRFJvdGF0ZVZlYzMudGl0bGUgPSBcIlJvdC4gVmVjM1wiO1xyXG4gICAgICAgIE1hdGgzRFJvdGF0ZVZlYzMuZGVzYyA9IFwicm90YXRlIGEgcG9pbnRcIjtcclxuXHJcbiAgICAgICAgTWF0aDNEUm90YXRlVmVjMy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZWMgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKHZlYyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2ZWMgPSB0aGlzLnByb3BlcnRpZXMudmVjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBxdWF0ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgIGlmIChxdWF0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSh2ZWMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1RdWF0KHZlYzMuY3JlYXRlKCksIHZlYywgcXVhdClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9yb3RhdGVfdmVjM1wiLCBNYXRoM0RSb3RhdGVWZWMzKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aDNETXVsdFF1YXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXRzKFtbXCJBXCIsIFwicXVhdFwiXSwgW1wiQlwiLCBcInF1YXRcIl1dKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJBKkJcIiwgXCJxdWF0XCIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBxdWF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aDNETXVsdFF1YXQudGl0bGUgPSBcIk11bHQuIFF1YXRcIjtcclxuICAgICAgICBNYXRoM0RNdWx0UXVhdC5kZXNjID0gXCJyb3RhdGUgcXVhdGVybmlvblwiO1xyXG5cclxuICAgICAgICBNYXRoM0RNdWx0UXVhdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmIChBID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICBpZiAoQiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBSID0gcXVhdC5tdWx0aXBseSh0aGlzLl92YWx1ZSwgQSwgQik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBSKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9tdWx0LXF1YXRcIiwgTWF0aDNETXVsdFF1YXQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBNYXRoM0RRdWF0U2xlcnAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXRzKFtcclxuICAgICAgICAgICAgICAgIFtcIkFcIiwgXCJxdWF0XCJdLFxyXG4gICAgICAgICAgICAgICAgW1wiQlwiLCBcInF1YXRcIl0sXHJcbiAgICAgICAgICAgICAgICBbXCJmYWN0b3JcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwic2xlcnBcIiwgXCJxdWF0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiZmFjdG9yXCIsIDAuNSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHF1YXQuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoM0RRdWF0U2xlcnAudGl0bGUgPSBcIlF1YXQgU2xlcnBcIjtcclxuICAgICAgICBNYXRoM0RRdWF0U2xlcnAuZGVzYyA9IFwicXVhdGVybmlvbiBzcGhlcmljYWwgaW50ZXJwb2xhdGlvblwiO1xyXG5cclxuICAgICAgICBNYXRoM0RRdWF0U2xlcnAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAoQSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgaWYgKEIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSB0aGlzLnByb3BlcnRpZXMuZmFjdG9yO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbnB1dERhdGEoMikgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBSID0gcXVhdC5zbGVycCh0aGlzLl92YWx1ZSwgQSwgQiwgZmFjdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIFIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3F1YXQtc2xlcnBcIiwgTWF0aDNEUXVhdFNsZXJwKTtcclxuXHJcblxyXG4gICAgICAgIC8vTWF0aDNEIHJvdGF0ZSB2ZWMzXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aDNEUmVtYXBSYW5nZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcInZlYzNcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcInJlbWFwXCIsIFwidmVjM1wiKTtcclxuXHRcdFx0dGhpcy5hZGRPdXRwdXQoXCJjbGFtcGVkXCIsIFwidmVjM1wiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBjbGFtcDogdHJ1ZSwgcmFuZ2VfbWluOiBbLTEsIC0xLCAwXSwgcmFuZ2VfbWF4OiBbMSwgMSwgMF0sIHRhcmdldF9taW46IFstMSwtMSwwXSwgdGFyZ2V0X21heDpbMSwxLDBdIH07XHJcblx0XHRcdHRoaXMuX3ZhbHVlID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdFx0dGhpcy5fY2xhbXBlZCA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoM0RSZW1hcFJhbmdlLnRpdGxlID0gXCJSZW1hcCBSYW5nZVwiO1xyXG4gICAgICAgIE1hdGgzRFJlbWFwUmFuZ2UuZGVzYyA9IFwicmVtYXAgYSAzRCByYW5nZVwiO1xyXG5cclxuICAgICAgICBNYXRoM0RSZW1hcFJhbmdlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHZlYyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0XHRpZih2ZWMpXHJcblx0XHRcdFx0dGhpcy5fdmFsdWUuc2V0KHZlYyk7XHJcblx0XHRcdHZhciByYW5nZV9taW4gPSB0aGlzLnByb3BlcnRpZXMucmFuZ2VfbWluO1xyXG5cdFx0XHR2YXIgcmFuZ2VfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhbmdlX21heDtcclxuXHRcdFx0dmFyIHRhcmdldF9taW4gPSB0aGlzLnByb3BlcnRpZXMudGFyZ2V0X21pbjtcclxuXHRcdFx0dmFyIHRhcmdldF9tYXggPSB0aGlzLnByb3BlcnRpZXMudGFyZ2V0X21heDtcclxuXHJcblx0XHRcdC8vc3dhcCB0byBhdm9pZCBlcnJvcnNcclxuXHRcdFx0LypcclxuXHRcdFx0aWYocmFuZ2VfbWluID4gcmFuZ2VfbWF4KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cmFuZ2VfbWluID0gcmFuZ2VfbWF4O1xyXG5cdFx0XHRcdHJhbmdlX21heCA9IHRoaXMucHJvcGVydGllcy5yYW5nZV9taW47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHRhcmdldF9taW4gPiB0YXJnZXRfbWF4KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGFyZ2V0X21pbiA9IHRhcmdldF9tYXg7XHJcblx0XHRcdFx0dGFyZ2V0X21heCA9IHRoaXMucHJvcGVydGllcy50YXJnZXRfbWluO1xyXG5cdFx0XHR9XHJcblx0XHRcdCovXHJcblxyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHIgPSByYW5nZV9tYXhbaV0gLSByYW5nZV9taW5baV07XHJcblx0XHRcdFx0dGhpcy5fY2xhbXBlZFtpXSA9IE1hdGguY2xhbXAoIHRoaXMuX3ZhbHVlW2ldLCByYW5nZV9taW5baV0sIHJhbmdlX21heFtpXSApO1xyXG5cdFx0XHRcdGlmKHIgPT0gMClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR0aGlzLl92YWx1ZVtpXSA9ICh0YXJnZXRfbWluW2ldICsgdGFyZ2V0X21heFtpXSkgKiAwLjU7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBuID0gKHRoaXMuX3ZhbHVlW2ldIC0gcmFuZ2VfbWluW2ldKSAvIHI7XHJcblx0XHRcdFx0aWYodGhpcy5wcm9wZXJ0aWVzLmNsYW1wKVxyXG5cdFx0XHRcdFx0biA9IE1hdGguY2xhbXAobiwwLDEpO1xyXG5cdFx0XHRcdHZhciB0ID0gdGFyZ2V0X21heFtpXSAtIHRhcmdldF9taW5baV07XHJcblx0XHRcdFx0dGhpcy5fdmFsdWVbaV0gPSB0YXJnZXRfbWluW2ldICsgbiAqIHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuX3ZhbHVlKTtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsdGhpcy5fY2xhbXBlZCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvcmVtYXBfcmFuZ2VcIiwgTWF0aDNEUmVtYXBSYW5nZSk7XHJcblxyXG5cclxuXHJcbiAgICB9IC8vZ2xNYXRyaXhcclxuXHRlbHNlXHJcblx0XHRjb25zb2xlLndhcm4oXCJObyBnbG1hdHJpeCBmb3VuZCwgc29tZSBNYXRoM0Qgbm9kZXMgbWF5IG5vdCB3b3JrXCIpO1xyXG5cclxufSkodGhpcyk7XHJcblxuLy9iYXNpYyBub2Rlc1xyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZyhhKSB7XHJcblx0XHRpZihhICYmIGEuY29uc3RydWN0b3IgPT09IE9iamVjdClcclxuXHRcdHtcclxuXHRcdFx0dHJ5XHJcblx0XHRcdHtcclxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2F0Y2ggKGVycilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiBTdHJpbmcoYSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXCJzdHJpbmcvdG9TdHJpbmdcIiwgdG9TdHJpbmcsIFtcIlwiXSwgXCJTdHJpbmdcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPT0gYjtcclxuICAgIH1cclxuXHJcbiAgICBMaXRlR3JhcGgud3JhcEZ1bmN0aW9uQXNOb2RlKFxyXG4gICAgICAgIFwic3RyaW5nL2NvbXBhcmVcIixcclxuICAgICAgICBjb21wYXJlLFxyXG4gICAgICAgIFtcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICBcImJvb2xlYW5cIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb25jYXRlbmF0ZShhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvY29uY2F0ZW5hdGVcIixcclxuICAgICAgICBjb25jYXRlbmF0ZSxcclxuICAgICAgICBbXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgXCJzdHJpbmdcIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS5pbmRleE9mKGIpICE9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvY29udGFpbnNcIixcclxuICAgICAgICBjb250YWlucyxcclxuICAgICAgICBbXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgXCJib29sZWFuXCJcclxuICAgICk7XHJcblxyXG4gICAgZnVuY3Rpb24gdG9VcHBlckNhc2UoYSkge1xyXG4gICAgICAgIGlmIChhICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvdG9VcHBlckNhc2VcIixcclxuICAgICAgICB0b1VwcGVyQ2FzZSxcclxuICAgICAgICBbXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgXCJzdHJpbmdcIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzcGxpdChzdHIsIHNlcGFyYXRvcikge1xyXG5cdFx0aWYoc2VwYXJhdG9yID09IG51bGwpXHJcblx0XHRcdHNlcGFyYXRvciA9IHRoaXMucHJvcGVydGllcy5zZXBhcmF0b3I7XHJcbiAgICAgICAgaWYgKHN0ciA9PSBudWxsIClcclxuXHQgICAgICAgIHJldHVybiBbXTtcclxuXHRcdGlmKCBzdHIuY29uc3RydWN0b3IgPT09IFN0cmluZyApXHJcblx0XHRcdHJldHVybiBzdHIuc3BsaXQoc2VwYXJhdG9yIHx8IFwiIFwiKTtcclxuXHRcdGVsc2UgaWYoIHN0ci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgciA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdHJbaV0gPSBzdHJbaV0uc3BsaXQoc2VwYXJhdG9yIHx8IFwiIFwiKTtcclxuXHRcdFx0cmV0dXJuIHI7XHJcblx0XHR9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcclxuICAgICAgICBcInN0cmluZy9zcGxpdFwiLFxyXG4gICAgICAgIHNwbGl0LFxyXG4gICAgICAgIFtcInN0cmluZyxhcnJheVwiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICBcImFycmF5XCIsXHJcblx0XHR7IHNlcGFyYXRvcjogXCIsXCIgfVxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiB0b0ZpeGVkKGEpIHtcclxuICAgICAgICBpZiAoYSAhPSBudWxsICYmIGEuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS50b0ZpeGVkKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICBMaXRlR3JhcGgud3JhcEZ1bmN0aW9uQXNOb2RlKFxyXG4gICAgICAgIFwic3RyaW5nL3RvRml4ZWRcIixcclxuICAgICAgICB0b0ZpeGVkLFxyXG4gICAgICAgIFtcIm51bWJlclwiXSxcclxuICAgICAgICBcInN0cmluZ1wiLFxyXG4gICAgICAgIHsgcHJlY2lzaW9uOiAwIH1cclxuICAgICk7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIFN0cmluZ1RvVGFibGUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcInN0cmluZ1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRhYmxlXCIsIFwidGFibGVcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJyb3dzXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwic2VwYXJhdG9yXCIsIFwiLFwiKTtcclxuXHRcdHRoaXMuX3RhYmxlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBTdHJpbmdUb1RhYmxlLnRpdGxlID0gXCJ0b1RhYmxlXCI7XHJcbiAgICBTdHJpbmdUb1RhYmxlLmRlc2MgPSBcIlNwbGl0cyBhIHN0cmluZyB0byB0YWJsZVwiO1xyXG5cclxuICAgIFN0cmluZ1RvVGFibGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWlucHV0KVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR2YXIgc2VwYXJhdG9yID0gdGhpcy5wcm9wZXJ0aWVzLnNlcGFyYXRvciB8fCBcIixcIjtcclxuXHRcdGlmKGlucHV0ICE9IHRoaXMuX3N0ciB8fCBzZXBhcmF0b3IgIT0gdGhpcy5fbGFzdF9zZXBhcmF0b3IgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLl9sYXN0X3NlcGFyYXRvciA9IHNlcGFyYXRvcjtcclxuXHRcdFx0dGhpcy5fc3RyID0gaW5wdXQ7XHJcblx0XHRcdHRoaXMuX3RhYmxlID0gaW5wdXQuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uKGEpeyByZXR1cm4gYS50cmltKCkuc3BsaXQoc2VwYXJhdG9yKX0pO1xyXG5cdFx0fVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90YWJsZSApO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLl90YWJsZSA/IHRoaXMuX3RhYmxlLmxlbmd0aCA6IDAgKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJzdHJpbmcvdG9UYWJsZVwiLCBTdHJpbmdUb1RhYmxlKTtcclxuXHJcbn0pKHRoaXMpO1xyXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcblxuICAgIGZ1bmN0aW9uIFNlbGVjdG9yKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VsXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJDXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiRFwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIik7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IDA7XG4gICAgfVxuXG4gICAgU2VsZWN0b3IudGl0bGUgPSBcIlNlbGVjdG9yXCI7XG4gICAgU2VsZWN0b3IuZGVzYyA9IFwic2VsZWN0cyBhbiBvdXRwdXRcIjtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBRkJcIjtcbiAgICAgICAgdmFyIHkgPSAodGhpcy5zZWxlY3RlZCArIDEpICogTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKyA2O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oNTAsIHkpO1xuICAgICAgICBjdHgubGluZVRvKDUwLCB5ICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQpO1xuICAgICAgICBjdHgubGluZVRvKDM0LCB5ICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjUpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH07XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWwgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHNlbCA9PSBudWxsIHx8IHNlbC5jb25zdHJ1Y3RvciAhPT0gTnVtYmVyKVxuICAgICAgICAgICAgc2VsID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbCA9IE1hdGgucm91bmQoc2VsKSAlICh0aGlzLmlucHV0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShzZWwgKyAxKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1tcIkVcIiwgMF0sIFtcIkZcIiwgMF0sIFtcIkdcIiwgMF0sIFtcIkhcIiwgMF1dO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImxvZ2ljL3NlbGVjdG9yXCIsIFNlbGVjdG9yKTtcblxuICAgIGZ1bmN0aW9uIFNlcXVlbmNlKCkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBzZXF1ZW5jZTogXCJBLEIsQ1wiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbmRleFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNlcVwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIik7XG5cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdGhpcy5wcm9wZXJ0aWVzLnNlcXVlbmNlLnNwbGl0KFwiLFwiKTtcbiAgICB9XG5cbiAgICBTZXF1ZW5jZS50aXRsZSA9IFwiU2VxdWVuY2VcIjtcbiAgICBTZXF1ZW5jZS5kZXNjID0gXCJzZWxlY3Qgb25lIGVsZW1lbnQgZnJvbSBhIHNlcXVlbmNlIGZyb20gYSBzdHJpbmdcIjtcblxuICAgIFNlcXVlbmNlLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwic2VxdWVuY2VcIikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VxdWVuY2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VxID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIGlmIChzZXEgJiYgc2VxICE9IHRoaXMuY3VycmVudF9zZXF1ZW5jZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBzZXEuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X3NlcXVlbmNlID0gc2VxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleCA9IE1hdGgucm91bmQoaW5kZXgpICUgdGhpcy52YWx1ZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnZhbHVlc1tpbmRleF0pO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImxvZ2ljL3NlcXVlbmNlXCIsIFNlcXVlbmNlKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XG5cbiAgICBmdW5jdGlvbiBHcmFwaGljc1Bsb3QoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwiTnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcIk51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkNcIiwgXCJOdW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJEXCIsIFwiTnVtYmVyXCIpO1xuXG4gICAgICAgIHRoaXMudmFsdWVzID0gW1tdLCBbXSwgW10sIFtdXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBzY2FsZTogMiB9O1xuICAgIH1cblxuICAgIEdyYXBoaWNzUGxvdC50aXRsZSA9IFwiUGxvdFwiO1xuICAgIEdyYXBoaWNzUGxvdC5kZXNjID0gXCJQbG90cyBkYXRhIG92ZXIgdGltZVwiO1xuICAgIEdyYXBoaWNzUGxvdC5jb2xvcnMgPSBbXCIjRkZGXCIsIFwiI0Y5OVwiLCBcIiM5RjlcIiwgXCIjOTlGXCJdO1xuXG4gICAgR3JhcGhpY3NQbG90LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc1tpXTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHYpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiBzaXplWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NQbG90LnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gKDAuNSAqIHNpemVbMV0pIC8gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlO1xuICAgICAgICB2YXIgY29sb3JzID0gR3JhcGhpY3NQbG90LmNvbG9ycztcbiAgICAgICAgdmFyIG9mZnNldCA9IHNpemVbMV0gKiAwLjU7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzU1NVwiO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhzaXplWzBdLCBvZmZzZXQpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW2ldIHx8ICF0aGlzLmlucHV0c1tpXS5saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzWzBdICogc2NhbGUgKiAtMSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIE1hdGguY2xhbXAodiwgMCwgc2l6ZVsxXSkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdmFsdWVzLmxlbmd0aCAmJiBqIDwgc2l6ZVswXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2pdICogc2NhbGUgKiAtMSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhqLCBNYXRoLmNsYW1wKHYsIDAsIHNpemVbMV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvcGxvdFwiLCBHcmFwaGljc1Bsb3QpO1xuXG4gICAgZnVuY3Rpb24gR3JhcGhpY3NJbWFnZSgpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmcmFtZVwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHVybDogXCJcIiB9O1xuICAgIH1cblxuICAgIEdyYXBoaWNzSW1hZ2UudGl0bGUgPSBcIkltYWdlXCI7XG4gICAgR3JhcGhpY3NJbWFnZS5kZXNjID0gXCJJbWFnZSBsb2FkZXJcIjtcbiAgICBHcmFwaGljc0ltYWdlLndpZGdldHMgPSBbeyBuYW1lOiBcImxvYWRcIiwgdGV4dDogXCJMb2FkXCIsIHR5cGU6IFwiYnV0dG9uXCIgfV07XG5cbiAgICBHcmFwaGljc0ltYWdlLnN1cHBvcnRlZF9leHRlbnNpb25zID0gW1wianBnXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcImdpZlwiXTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tcInVybFwiXSAhPSBcIlwiICYmIHRoaXMuaW1nID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEltYWdlKHRoaXMucHJvcGVydGllc1tcInVybFwiXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbWcgJiYgdGhpcy5zaXplWzBdID4gNSAmJiB0aGlzLnNpemVbMV0gPiA1ICYmIHRoaXMuaW1nLndpZHRoKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5pbWcpIHtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiMwMDBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbWcgJiYgdGhpcy5pbWcud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmltZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW1nICYmIHRoaXMuaW1nLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmltZy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmIChuYW1lID09IFwidXJsXCIgJiYgdmFsdWUgIT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2UodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHVybCA9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmltZyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cbiAgICAgICAgaWYgKHVybC5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIgJiYgTGl0ZUdyYXBoLnByb3h5KSB7XG4gICAgICAgICAgICB1cmwgPSBMaXRlR3JhcGgucHJveHkgKyB1cmwuc3Vic3RyKHVybC5pbmRleE9mKFwiOlwiKSArIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWcuc3JjID0gdXJsO1xuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjRjk1XCI7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkltYWdlIGxvYWRlZCwgc2l6ZTogXCIgKyB0aGF0LmltZy53aWR0aCArIFwieFwiICsgdGhhdC5pbWcuaGVpZ2h0ICk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiM5RjlcIjtcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiZXJyb3IgbG9hZGluZyB0aGUgaW1hZ2U6XCIgKyB1cmwpO1xuXHRcdH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25XaWRnZXQgPSBmdW5jdGlvbihlLCB3aWRnZXQpIHtcbiAgICAgICAgaWYgKHdpZGdldC5uYW1lID09IFwibG9hZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZSh0aGlzLnByb3BlcnRpZXNbXCJ1cmxcIl0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3VybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl91cmwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy51cmwgPSB0aGlzLl91cmw7XG4gICAgICAgIHRoaXMubG9hZEltYWdlKHRoaXMuX3VybCwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICB0aGF0LnNpemVbMV0gPSAoaW1nLmhlaWdodCAvIGltZy53aWR0aCkgKiB0aGF0LnNpemVbMF07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2ltYWdlXCIsIEdyYXBoaWNzSW1hZ2UpO1xuXG4gICAgZnVuY3Rpb24gQ29sb3JQYWxldHRlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiZlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJDb2xvclwiLCBcImNvbG9yXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBjb2xvckE6IFwiIzQ0NDQ0NFwiLFxuICAgICAgICAgICAgY29sb3JCOiBcIiM0NEFBRkZcIixcbiAgICAgICAgICAgIGNvbG9yQzogXCIjNDRGRkFBXCIsXG4gICAgICAgICAgICBjb2xvckQ6IFwiI0ZGRkZGRlwiXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQ29sb3JQYWxldHRlLnRpdGxlID0gXCJQYWxldHRlXCI7XG4gICAgQ29sb3JQYWxldHRlLmRlc2MgPSBcIkdlbmVyYXRlcyBhIGNvbG9yXCI7XG5cbiAgICBDb2xvclBhbGV0dGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY29sb3JBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGMucHVzaChoZXgybnVtKHRoaXMucHJvcGVydGllcy5jb2xvckEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmNvbG9yQiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjLnB1c2goaGV4Mm51bSh0aGlzLnByb3BlcnRpZXMuY29sb3JCKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jb2xvckMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYy5wdXNoKGhleDJudW0odGhpcy5wcm9wZXJ0aWVzLmNvbG9yQykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY29sb3JEICE9IG51bGwpIHtcbiAgICAgICAgICAgIGMucHVzaChoZXgybnVtKHRoaXMucHJvcGVydGllcy5jb2xvckQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgICAgICAgIGYgPSAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPiAxLjApIHtcbiAgICAgICAgICAgIGYgPSAxLjA7XG4gICAgICAgIH0gZWxzZSBpZiAoZiA8IDAuMCkge1xuICAgICAgICAgICAgZiA9IDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gWzAsIDAsIDBdO1xuICAgICAgICBpZiAoZiA9PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGYgPT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY1tjLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvcyA9IChjLmxlbmd0aCAtIDEpICogZjtcbiAgICAgICAgICAgIHZhciBjMSA9IGNbTWF0aC5mbG9vcihwb3MpXTtcbiAgICAgICAgICAgIHZhciBjMiA9IGNbTWF0aC5mbG9vcihwb3MpICsgMV07XG4gICAgICAgICAgICB2YXIgdCA9IHBvcyAtIE1hdGguZmxvb3IocG9zKTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IGMxWzBdICogKDEgLSB0KSArIGMyWzBdICogdDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IGMxWzFdICogKDEgLSB0KSArIGMyWzFdICogdDtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IGMxWzJdICogKDEgLSB0KSArIGMyWzJdICogdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG5cdGNbMF0gPSAxLjAgLSBNYXRoLmFicyggTWF0aC5zaW4oIDAuMSAqIHJlTW9kdWxhci5nZXRUaW1lKCkgKiBNYXRoLlBJKSApO1xuXHRjWzFdID0gTWF0aC5hYnMoIE1hdGguc2luKCAwLjA3ICogcmVNb2R1bGFyLmdldFRpbWUoKSAqIE1hdGguUEkpICk7XG5cdGNbMl0gPSBNYXRoLmFicyggTWF0aC5zaW4oIDAuMDEgKiByZU1vZHVsYXIuZ2V0VGltZSgpICogTWF0aC5QSSkgKTtcblx0Ki9cblxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSAvPSAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJveGNvbG9yID0gY29sb3JUb1N0cmluZyhyZXN1bHQpO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmVzdWx0KTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJjb2xvci9wYWxldHRlXCIsIENvbG9yUGFsZXR0ZSk7XG5cbiAgICBmdW5jdGlvbiBJbWFnZUZyYW1lKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwiaW1hZ2UsY2FudmFzXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbMjAwLCAyMDBdO1xuICAgIH1cblxuICAgIEltYWdlRnJhbWUudGl0bGUgPSBcIkZyYW1lXCI7XG4gICAgSW1hZ2VGcmFtZS5kZXNjID0gXCJGcmFtZSB2aWV3ZXJld1wiO1xuICAgIEltYWdlRnJhbWUud2lkZ2V0cyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInJlc2l6ZVwiLCB0ZXh0OiBcIlJlc2l6ZSBib3hcIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwidmlld1wiLCB0ZXh0OiBcIlZpZXcgSW1hZ2VcIiwgdHlwZTogXCJidXR0b25cIiB9XG4gICAgXTtcblxuICAgIEltYWdlRnJhbWUucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWUgJiYgIXRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuZnJhbWUsIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZUZyYW1lLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBJbWFnZUZyYW1lLnByb3RvdHlwZS5vbldpZGdldCA9IGZ1bmN0aW9uKGUsIHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0Lm5hbWUgPT0gXCJyZXNpemVcIiAmJiB0aGlzLmZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZnJhbWUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXdpZHRoICYmIHRoaXMuZnJhbWUudmlkZW9XaWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmZyYW1lLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5mcmFtZS52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkZ2V0Lm5hbWUgPT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlRnJhbWUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy92YXIgc3RyID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICBpZiAoc2hvd0VsZW1lbnQgJiYgdGhpcy5mcmFtZSkge1xuICAgICAgICAgICAgc2hvd0VsZW1lbnQodGhpcy5mcmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9mcmFtZVwiLCBJbWFnZUZyYW1lKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlRmFkZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1xuICAgICAgICAgICAgW1wiaW1nMVwiLCBcImltYWdlXCJdLFxuICAgICAgICAgICAgW1wiaW1nMlwiLCBcImltYWdlXCJdLFxuICAgICAgICAgICAgW1wiZmFkZVwiLCBcIm51bWJlclwiXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJpbWFnZVwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBmYWRlOiAwLjUsIHdpZHRoOiA1MTIsIGhlaWdodDogNTEyIH07XG4gICAgfVxuXG4gICAgSW1hZ2VGYWRlLnRpdGxlID0gXCJJbWFnZSBmYWRlXCI7XG4gICAgSW1hZ2VGYWRlLmRlc2MgPSBcIkZhZGVzIGJldHdlZW4gaW1hZ2VzXCI7XG4gICAgSW1hZ2VGYWRlLndpZGdldHMgPSBbXG4gICAgICAgIHsgbmFtZTogXCJyZXNpemVBXCIsIHRleHQ6IFwiUmVzaXplIHRvIEFcIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwicmVzaXplQlwiLCB0ZXh0OiBcIlJlc2l6ZSB0byBCXCIsIHR5cGU6IFwiYnV0dG9uXCIgfVxuICAgIF07XG5cbiAgICBJbWFnZUZhZGUucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5wcm9wZXJ0aWVzW1wid2lkdGhcIl0sIHRoaXMucHJvcGVydGllc1tcImhlaWdodFwiXSk7XG4gICAgfTtcblxuICAgIEltYWdlRmFkZS5wcm90b3R5cGUuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLnByb3BlcnRpZXNbXCJ3aWR0aFwiXTtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzW1wiaGVpZ2h0XCJdO1xuICAgIH07XG5cbiAgICBJbWFnZUZhZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoQSwgMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFkZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuICAgICAgICBpZiAoZmFkZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmYWRlID0gdGhpcy5wcm9wZXJ0aWVzW1wiZmFkZVwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcImZhZGVcIl0gPSBmYWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZmFkZTtcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKEIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShCLCAwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9pbWFnZWZhZGVcIiwgSW1hZ2VGYWRlKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlQ3JvcCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjU2LCB4OiAwLCB5OiAwLCBzY2FsZTogMS4wIH07XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs1MCwgMjBdO1xuICAgIH1cblxuICAgIEltYWdlQ3JvcC50aXRsZSA9IFwiQ3JvcFwiO1xuICAgIEltYWdlQ3JvcC5kZXNjID0gXCJDcm9wIEltYWdlXCI7XG5cbiAgICBJbWFnZUNyb3AucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VDcm9wLnByb3RvdHlwZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMucHJvcGVydGllc1tcIndpZHRoXCJdO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLnByb3BlcnRpZXNbXCJoZWlnaHRcIl07XG4gICAgfTtcblxuICAgIEltYWdlQ3JvcC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQud2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgLXRoaXMucHJvcGVydGllc1tcInhcIl0sXG4gICAgICAgICAgICAgICAgLXRoaXMucHJvcGVydGllc1tcInlcIl0sXG4gICAgICAgICAgICAgICAgaW5wdXQud2lkdGggKiB0aGlzLnByb3BlcnRpZXNbXCJzY2FsZVwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dC5oZWlnaHQgKiB0aGlzLnByb3BlcnRpZXNbXCJzY2FsZVwiXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmNhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VDcm9wLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVbMF0sXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlQ3JvcC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAobmFtZSA9PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tuYW1lXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNjYWxlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvY3JvcEltYWdlXCIsIEltYWdlQ3JvcCk7XG5cbiAgICAvL0NBTlZBUyBzdHVmZlxuXG4gICAgZnVuY3Rpb24gQ2FudmFzTm9kZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNsZWFyXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB3aWR0aDogNTEyLCBoZWlnaHQ6IDUxMiwgYXV0b2NsZWFyOiB0cnVlIH07XG5cbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB9XG5cbiAgICBDYW52YXNOb2RlLnRpdGxlID0gXCJDYW52YXNcIjtcbiAgICBDYW52YXNOb2RlLmRlc2MgPSBcIkNhbnZhcyB0byByZW5kZXIgc3R1ZmZcIjtcblxuICAgIENhbnZhc05vZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHwgMDtcbiAgICAgICAgdmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0IHwgMDtcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPSB3KSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9IGgpIHtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5hdXRvY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBjYW52YXMpO1xuICAgIH07XG5cbiAgICBDYW52YXNOb2RlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSBcImNsZWFyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2NhbnZhc1wiLCBDYW52YXNOb2RlKTtcblxuICAgIGZ1bmN0aW9uIERyYXdJbWFnZU5vZGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjYW52YXNcIiwgXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbWdcIiwgXCJpbWFnZSxjYW52YXNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwieVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB4OiAwLCB5OiAwLCBvcGFjaXR5OiAxIH07XG4gICAgfVxuXG4gICAgRHJhd0ltYWdlTm9kZS50aXRsZSA9IFwiRHJhd0ltYWdlXCI7XG4gICAgRHJhd0ltYWdlTm9kZS5kZXNjID0gXCJEcmF3cyBpbWFnZSBpbnRvIGEgY2FudmFzXCI7XG5cbiAgICBEcmF3SW1hZ2VOb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltZyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiaW1nXCIpO1xuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInhcIik7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ5XCIpO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIHgsIHkpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2RyYXdJbWFnZVwiLCBEcmF3SW1hZ2VOb2RlKTtcblxuICAgIGZ1bmN0aW9uIERyYXdSZWN0YW5nbGVOb2RlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiY2FudmFzXCIsIFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwieFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInlcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ3XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3OiAxMCxcbiAgICAgICAgICAgIGg6IDEwLFxuICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBEcmF3UmVjdGFuZ2xlTm9kZS50aXRsZSA9IFwiRHJhd1JlY3RhbmdsZVwiO1xuICAgIERyYXdSZWN0YW5nbGVOb2RlLmRlc2MgPSBcIkRyYXdzIHJlY3RhbmdsZSBpbiBjYW52YXNcIjtcblxuICAgIERyYXdSZWN0YW5nbGVOb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInhcIik7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ5XCIpO1xuICAgICAgICB2YXIgdyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwid1wiKTtcbiAgICAgICAgdmFyIGggPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImhcIik7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvZHJhd1JlY3RhbmdsZVwiLCBEcmF3UmVjdGFuZ2xlTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBJbWFnZVZpZGVvKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXRzKFtbXCJmcmFtZVwiLCBcImltYWdlXCJdLCBbXCJ0XCIsIFwibnVtYmVyXCJdLCBbXCJkXCIsIFwibnVtYmVyXCJdXSk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgdXJsOiBcIlwiLCB1c2VfcHJveHk6IHRydWUgfTtcbiAgICB9XG5cbiAgICBJbWFnZVZpZGVvLnRpdGxlID0gXCJWaWRlb1wiO1xuICAgIEltYWdlVmlkZW8uZGVzYyA9IFwiVmlkZW8gcGxheWJhY2tcIjtcbiAgICBJbWFnZVZpZGVvLndpZGdldHMgPSBbXG4gICAgICAgIHsgbmFtZTogXCJwbGF5XCIsIHRleHQ6IFwiUExBWVwiLCB0eXBlOiBcIm1pbmlidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwic3RvcFwiLCB0ZXh0OiBcIlNUT1BcIiwgdHlwZTogXCJtaW5pYnV0dG9uXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcImRlbW9cIiwgdGV4dDogXCJEZW1vIHZpZGVvXCIsIHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcIm11dGVcIiwgdGV4dDogXCJNdXRlIHZpZGVvXCIsIHR5cGU6IFwiYnV0dG9uXCIgfVxuICAgIF07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnVybCAhPSB0aGlzLl92aWRlb191cmwpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZFZpZGVvKHRoaXMucHJvcGVydGllcy51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbyB8fCB0aGlzLl92aWRlby53aWR0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodCAmJiB0ID49IDAgJiYgdCA8PSAxLjApIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvLmN1cnJlbnRUaW1lID0gdCAqIHRoaXMuX3ZpZGVvLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZGVvLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZpZGVvKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3ZpZGVvLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDIsIHRoaXMuX3ZpZGVvLmR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5sb2FkVmlkZW8gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdGhpcy5fdmlkZW9fdXJsID0gdXJsO1xuXG5cdFx0dmFyIHBvcyA9IHVybC5zdWJzdHIoMCwxMCkuaW5kZXhPZihcIjpcIik7XG5cdFx0dmFyIHByb3RvY29sID0gXCJcIjtcblx0XHRpZihwb3MgIT0gLTEpXG5cdFx0XHRwcm90b2NvbCA9IHVybC5zdWJzdHIoMCxwb3MpO1xuXG5cdFx0dmFyIGhvc3QgPSBcIlwiO1xuXHRcdGlmKHByb3RvY29sKVxuXHRcdHtcblx0XHRcdGhvc3QgPSB1cmwuc3Vic3RyKDAsdXJsLmluZGV4T2YoXCIvXCIscHJvdG9jb2wubGVuZ3RoICsgMykpO1xuXHRcdFx0aG9zdCA9IGhvc3Quc3Vic3RyKHByb3RvY29sLmxlbmd0aCszKTtcblx0XHR9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnVzZV9wcm94eSAmJlxuICAgICAgICAgICAgcHJvdG9jb2wgJiZcbiAgICAgICAgICAgIExpdGVHcmFwaC5wcm94eSAmJlxuXHRcdFx0aG9zdCAhPSBsb2NhdGlvbi5ob3N0XG4gICAgICAgICkge1xuICAgICAgICAgICAgdXJsID0gTGl0ZUdyYXBoLnByb3h5ICsgdXJsLnN1YnN0cih1cmwuaW5kZXhPZihcIjpcIikgKyAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgICB0aGlzLl92aWRlby5zcmMgPSB1cmw7XG4gICAgICAgIHRoaXMuX3ZpZGVvLnR5cGUgPSBcInR5cGU9dmlkZW8vbXA0XCI7XG5cbiAgICAgICAgdGhpcy5fdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl92aWRlby5hdXRvcGxheSA9IHRydWU7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy9vbmxvYWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHVyYXRpb246IFwiICsgdGhpcy5kdXJhdGlvbiArIFwiIHNlY29uZHNcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNpemU6IFwiICsgdGhpcy52aWRlb1dpZHRoICsgXCIsXCIgKyB0aGlzLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy52aWRlb1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnZpZGVvSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vb25sb2FkXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInZpZGVvIGxvYWRpbmcuLi5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgdmlkZW86IFwiICsgdGhpcy5zcmMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuZXJyb3IuTUVESUFfRVJSX0FCT1JURUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IHN0b3BwZWQgdGhlIHZpZGVvLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuZXJyb3IuTUVESUFfRVJSX05FVFdPUks6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTmV0d29yayBlcnJvciAtIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5lcnJvci5NRURJQV9FUlJfREVDT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlZpZGVvIGlzIGJyb2tlbi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5lcnJvci5NRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU29ycnksIHlvdXIgYnJvd3NlciBjYW4ndCBwbGF5IHRoaXMgdmlkZW8uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyBFbmRlZC5cIik7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTsgLy9sb29wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnZpZGVvKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ1cmxcIiAmJiB2YWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRWaWRlbyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlkZW8gJiYgdGhpcy5fdmlkZW8udmlkZW9XaWR0aCApIHsgLy9pcyBsb2FkZWRcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5wbGF5UGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl92aWRlby5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlVmlkZW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHRoaXMuX3ZpZGVvLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmlkZW8gcGF1c2VkXCIpO1xuICAgICAgICB0aGlzLl92aWRlby5wYXVzZSgpO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vbldpZGdldCA9IGZ1bmN0aW9uKGUsIHdpZGdldCkge1xuICAgICAgICAvKlxuXHRpZih3aWRnZXQubmFtZSA9PSBcImRlbW9cIilcblx0e1xuXHRcdHRoaXMubG9hZFZpZGVvKCk7XG5cdH1cblx0ZWxzZSBpZih3aWRnZXQubmFtZSA9PSBcInBsYXlcIilcblx0e1xuXHRcdGlmKHRoaXMuX3ZpZGVvKVxuXHRcdFx0dGhpcy5wbGF5UGF1c2UoKTtcblx0fVxuXHRpZih3aWRnZXQubmFtZSA9PSBcInN0b3BcIilcblx0e1xuXHRcdHRoaXMuc3RvcCgpO1xuXHR9XG5cdGVsc2UgaWYod2lkZ2V0Lm5hbWUgPT0gXCJtdXRlXCIpXG5cdHtcblx0XHRpZih0aGlzLl92aWRlbylcblx0XHRcdHRoaXMuX3ZpZGVvLm11dGVkID0gIXRoaXMuX3ZpZGVvLm11dGVkO1xuXHR9XG5cdCovXG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvdmlkZW9cIiwgSW1hZ2VWaWRlbyk7XG5cbiAgICAvLyBUZXh0dXJlIFdlYmNhbSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIGZ1bmN0aW9uIEltYWdlV2ViY2FtKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIldlYmNhbVwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGZpbHRlckZhY2luZ01vZGU6IGZhbHNlLCBmYWNpbmdNb2RlOiBcInVzZXJcIiB9O1xuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmZyYW1lID0gMDtcbiAgICB9XG5cbiAgICBJbWFnZVdlYmNhbS50aXRsZSA9IFwiV2ViY2FtXCI7XG4gICAgSW1hZ2VXZWJjYW0uZGVzYyA9IFwiV2ViY2FtIGltYWdlXCI7XG4gICAgSW1hZ2VXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5vcGVuU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRVc2VyTWVkaWEoKSBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlciwgdXNlIGNocm9tZSBhbmQgZW5hYmxlIFdlYlJUQyBmcm9tIGFib3V0Oi8vZmxhZ3MnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBOb3Qgc2hvd2luZyB2ZW5kb3IgcHJlZml4ZXMuXG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgIHZpZGVvOiAhdGhpcy5wcm9wZXJ0aWVzLmZpbHRlckZhY2luZ01vZGUgPyB0cnVlIDogeyBmYWNpbmdNb2RlOiB0aGlzLnByb3BlcnRpZXMuZmFjaW5nTW9kZSB9XG4gICAgICAgIH07XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgIC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgICAgICAudGhlbih0aGlzLnN0cmVhbVJlYWR5LmJpbmQodGhpcykpXG4gICAgICAgICAgICAuY2F0Y2gob25GYWlsU29IYXJkKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbFNvSGFyZChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldlYmNhbSByZWplY3RlZFwiLCBlKTtcbiAgICAgICAgICAgIHRoYXQuX3dlYmNhbV9zdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgICAgIHRoYXQudHJpZ2dlcihcInN0cmVhbV9lcnJvclwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdlYmNhbS5wcm90b3R5cGUuY2xvc2VTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYmNhbV9zdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl93ZWJjYW1fc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgICAgICAgaWYgKHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3NbaV0uc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEltYWdlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl93ZWJjYW1fc3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJzdHJlYW1fY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiZmFjaW5nTW9kZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZmFjaW5nTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN0cmVhbSgpO1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5zdHJlYW1SZWFkeSA9IGZ1bmN0aW9uKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fd2ViY2FtX3N0cmVhbSA9IGxvY2FsTWVkaWFTdHJlYW07XG4gICAgICAgIC8vdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiZ3JlZW5cIjtcblxuICAgICAgICB2YXIgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgICAgICB2aWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBsb2NhbE1lZGlhU3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8gPSB2aWRlbztcbiAgICAgICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggdmlkZW8gKTsgLy9kZWJ1Z1xuICAgICAgICAgICAgLy93aGVuIHZpZGVvIGluZm8gaXMgbG9hZGVkIChzaXplIGFuZCBzbylcbiAgICAgICAgICAgIHZpZGVvLm9ubG9hZGVkbWV0YWRhdGEgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZHkgdG8gZ28uIERvIHNvbWUgc3R1ZmYuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgSW1hZ2VXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcihcInN0cmVhbV9yZWFkeVwiLCB2aWRlbyk7XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYmNhbV9zdHJlYW0gPT0gbnVsbCAmJiAhdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbyB8fCAhdGhpcy5fdmlkZW8udmlkZW9XaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlkZW8uZnJhbWUgPSArK3RoaXMuZnJhbWU7XG4gICAgICAgIHRoaXMuX3ZpZGVvLndpZHRoID0gdGhpcy5fdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgdGhpcy5fdmlkZW8uaGVpZ2h0ID0gdGhpcy5fdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92aWRlbyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0cHV0c1tpXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm91dHB1dHNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX3ZpZGVvLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB0eHQgPSAhdGhhdC5wcm9wZXJ0aWVzLnNob3cgPyBcIlNob3cgRnJhbWVcIiA6IFwiSGlkZSBGcmFtZVwiO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHR4dCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucHJvcGVydGllcy5zaG93ID0gIXRoYXQucHJvcGVydGllcy5zaG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5mbGFncy5jb2xsYXBzZWQgfHxcbiAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSA8PSAyMCB8fFxuICAgICAgICAgICAgIXRoaXMucHJvcGVydGllcy5zaG93XG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXIgdG8gZ3JhcGggY2FudmFzXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fdmlkZW8sIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1wid2lkdGhcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJoZWlnaHRcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJzdHJlYW1fcmVhZHlcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcbiAgICAgICAgICAgIFtcInN0cmVhbV9jbG9zZWRcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcbiAgICAgICAgICAgIFtcInN0cmVhbV9lcnJvclwiLCBMaXRlR3JhcGguRVZFTlRdXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3Mvd2ViY2FtXCIsIEltYWdlV2ViY2FtKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XG5cdHZhciBMR3JhcGhDYW52YXMgPSBnbG9iYWwuTEdyYXBoQ2FudmFzO1xuXG4gICAgLy9Xb3JrcyB3aXRoIExpdGVnbC5qcyB0byBjcmVhdGUgV2ViR0wgbm9kZXNcbiAgICBnbG9iYWwuTEdyYXBoVGV4dHVyZSA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIEdMID09IFwidW5kZWZpbmVkXCIpXG5cdFx0cmV0dXJuO1xuXG5cdExHcmFwaENhbnZhcy5saW5rX3R5cGVfY29sb3JzW1wiVGV4dHVyZVwiXSA9IFwiIzk4N1wiO1xuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmUoKSB7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ0ZXhcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibmFtZVwiLCBcInN0cmluZ1wiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiXCIsIGZpbHRlcjogdHJ1ZSB9O1xuXHRcdHRoaXMuc2l6ZSA9IFtcblx0XHRcdExHcmFwaFRleHR1cmUuaW1hZ2VfcHJldmlld19zaXplLFxuXHRcdFx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemVcblx0XHRdO1xuXHR9XG5cblx0Z2xvYmFsLkxHcmFwaFRleHR1cmUgPSBMR3JhcGhUZXh0dXJlO1xuXG5cdExHcmFwaFRleHR1cmUudGl0bGUgPSBcIlRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZS5kZXNjID0gXCJUZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmUud2lkZ2V0c19pbmZvID0ge1xuXHRcdG5hbWU6IHsgd2lkZ2V0OiBcInRleHR1cmVcIiB9LFxuXHRcdGZpbHRlcjogeyB3aWRnZXQ6IFwiY2hlY2tib3hcIiB9XG5cdH07XG5cblx0Ly9SRVBMQUNFIFRISVMgVE8gSU5URUdSQVRFIFdJVEggWU9VUiBGUkFNRVdPUktcblx0TEdyYXBoVGV4dHVyZS5sb2FkVGV4dHVyZUNhbGxiYWNrID0gbnVsbDsgLy9mdW5jdGlvbiBpbiBjaGFyZ2Ugb2YgbG9hZGluZyB0ZXh0dXJlcyB3aGVuIG5vdCBwcmVzZW50IGluIHRoZSBjb250YWluZXJcblx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemUgPSAyNTY7XG5cblx0Ly9mbGFncyB0byBjaG9vc2Ugb3V0cHV0IHRleHR1cmUgdHlwZVxuXHRMR3JhcGhUZXh0dXJlLlVOREVGSU5FRCA9IDA7IC8vbm90IHNwZWNpZmllZFxuXHRMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCA9IDE7IC8vZG8gbm90IGFwcGx5IEZYIChsaWtlIGRpc2FibGUgYnV0IHBhc3NpbmcgdGhlIGluIHRvIHRoZSBvdXQpXG5cdExHcmFwaFRleHR1cmUuQ09QWSA9IDI7IC8vY3JlYXRlIG5ldyB0ZXh0dXJlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb3JpZ2luIHRleHR1cmVcblx0TEdyYXBoVGV4dHVyZS5MT1cgPSAzOyAvL2NyZWF0ZSBuZXcgdGV4dHVyZSB3aXRoIGxvdyBwcmVjaXNpb24gKGJ5dGUpXG5cdExHcmFwaFRleHR1cmUuSElHSCA9IDQ7IC8vY3JlYXRlIG5ldyB0ZXh0dXJlIHdpdGggaGlnaCBwcmVjaXNpb24gKGhhbGYtZmxvYXQpXG5cdExHcmFwaFRleHR1cmUuUkVVU0UgPSA1OyAvL3JldXNlIGlucHV0IHRleHR1cmVcblx0TEdyYXBoVGV4dHVyZS5ERUZBVUxUID0gMjsgLy91c2UgdGhlIGRlZmF1bHRcblxuXHRMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTID0ge1xuXHRcdFwidW5kZWZpbmVkXCI6IExHcmFwaFRleHR1cmUuVU5ERUZJTkVELFxuXHRcdFwicGFzcyB0aHJvdWdoXCI6IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdILFxuXHRcdGNvcHk6IExHcmFwaFRleHR1cmUuQ09QWSxcblx0XHRsb3c6IExHcmFwaFRleHR1cmUuTE9XLFxuXHRcdGhpZ2g6IExHcmFwaFRleHR1cmUuSElHSCxcblx0XHRyZXVzZTogTEdyYXBoVGV4dHVyZS5SRVVTRSxcblx0XHRkZWZhdWx0OiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0fTtcblxuXHQvL3JldHVybnMgdGhlIGNvbnRhaW5lciB3aGVyZSBhbGwgdGhlIGxvYWRlZCB0ZXh0dXJlcyBhcmUgc3RvcmVkIChvdmVyd3JpdGUgaWYgeW91IGhhdmUgYSBSZXNvdXJjZXMgTWFuYWdlcilcblx0TEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlc0NvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnbC50ZXh0dXJlcztcblx0fTtcblxuXHQvL3Byb2Nlc3MgdGhlIGxvYWRpbmcgb2YgYSB0ZXh0dXJlIChvdmVyd3JpdGUgaXQgaWYgeW91IGhhdmUgYSBSZXNvdXJjZXMgTWFuYWdlcilcblx0TEdyYXBoVGV4dHVyZS5sb2FkVGV4dHVyZSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgdXJsID0gbmFtZTtcblx0XHRpZiAodXJsLnN1YnN0cigwLCA3KSA9PSBcImh0dHA6Ly9cIikge1xuXHRcdFx0aWYgKExpdGVHcmFwaC5wcm94eSkge1xuXHRcdFx0XHQvL3Byb3h5IGV4dGVybmFsIGZpbGVzXG5cdFx0XHRcdHVybCA9IExpdGVHcmFwaC5wcm94eSArIHVybC5zdWJzdHIoNyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRhaW5lciA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZXNDb250YWluZXIoKTtcblx0XHR2YXIgdGV4ID0gKGNvbnRhaW5lcltuYW1lXSA9IEdMLlRleHR1cmUuZnJvbVVSTCh1cmwsIG9wdGlvbnMpKTtcblx0XHRyZXR1cm4gdGV4O1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5nZXRUZXh0dXJlc0NvbnRhaW5lcigpO1xuXG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHRocm93IFwiQ2Fubm90IGxvYWQgdGV4dHVyZSwgY29udGFpbmVyIG9mIHRleHR1cmVzIG5vdCBmb3VuZFwiO1xuXHRcdH1cblxuXHRcdHZhciB0ZXggPSBjb250YWluZXJbbmFtZV07XG5cdFx0aWYgKCF0ZXggJiYgbmFtZSAmJiBuYW1lWzBdICE9IFwiOlwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sb2FkVGV4dHVyZShuYW1lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4O1xuXHR9O1xuXG5cdC8vdXNlZCB0byBjb21wdXRlIHRoZSBhcHByb3BpYXRlIG91dHB1dCB0ZXh0dXJlXG5cdExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKG9yaWdpbiwgdGFyZ2V0LCBtb2RlKSB7XG5cdFx0aWYgKCFvcmlnaW4pIHtcblx0XHRcdHRocm93IFwiTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlIGV4cGVjdHMgYSByZWZlcmVuY2UgdGV4dHVyZVwiO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhfdHlwZSA9IG51bGw7XG5cblx0XHRzd2l0Y2ggKG1vZGUpIHtcblx0XHRcdGNhc2UgTEdyYXBoVGV4dHVyZS5MT1c6XG5cdFx0XHRcdHRleF90eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIExHcmFwaFRleHR1cmUuSElHSDpcblx0XHRcdFx0dGV4X3R5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLlJFVVNFOlxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgTEdyYXBoVGV4dHVyZS5DT1BZOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGV4X3R5cGUgPSBvcmlnaW4gPyBvcmlnaW4udHlwZSA6IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0YXJnZXQgfHxcblx0XHRcdHRhcmdldC53aWR0aCAhPSBvcmlnaW4ud2lkdGggfHxcblx0XHRcdHRhcmdldC5oZWlnaHQgIT0gb3JpZ2luLmhlaWdodCB8fFxuXHRcdFx0dGFyZ2V0LnR5cGUgIT0gdGV4X3R5cGUgfHxcblx0XHRcdHRhcmdldC5mb3JtYXQgIT0gb3JpZ2luLmZvcm1hdCBcblx0XHQpIHtcblx0XHRcdHRhcmdldCA9IG5ldyBHTC5UZXh0dXJlKG9yaWdpbi53aWR0aCwgb3JpZ2luLmhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiB0ZXhfdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBvcmlnaW4uZm9ybWF0LFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlID0gZnVuY3Rpb24ocHJlY2lzaW9uLCByZWZfdGV4dHVyZSkge1xuXHRcdHZhciB0eXBlID0gcmVmX3RleHR1cmUgPyByZWZfdGV4dHVyZS50eXBlIDogZ2wuVU5TSUdORURfQllURTtcblx0XHRzd2l0Y2ggKHByZWNpc2lvbikge1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLkhJR0g6XG5cdFx0XHRcdHR5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLkxPVzpcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Ly9ubyBkZWZhdWx0XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUuZ2V0V2hpdGVUZXh0dXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3doaXRlX3RleHR1cmUpIHtcblx0XHRcdHJldHVybiB0aGlzLl93aGl0ZV90ZXh0dXJlO1xuXHRcdH1cblx0XHR2YXIgdGV4dHVyZSA9ICh0aGlzLl93aGl0ZV90ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tTWVtb3J5KFxuXHRcdFx0MSxcblx0XHRcdDEsXG5cdFx0XHRbMjU1LCAyNTUsIDI1NSwgMjU1XSxcblx0XHRcdHsgZm9ybWF0OiBnbC5SR0JBLCB3cmFwOiBnbC5SRVBFQVQsIGZpbHRlcjogZ2wuTkVBUkVTVCB9XG5cdFx0KSk7XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5nZXROb2lzZVRleHR1cmUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbm9pc2VfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX25vaXNlX3RleHR1cmU7XG5cdFx0fVxuXG5cdFx0dmFyIG5vaXNlID0gbmV3IFVpbnQ4QXJyYXkoNTEyICogNTEyICogNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA1MTIgKiA1MTIgKiA0OyArK2kpIHtcblx0XHRcdG5vaXNlW2ldID0gTWF0aC5yYW5kb20oKSAqIDI1NTtcblx0XHR9XG5cblx0XHR2YXIgdGV4dHVyZSA9IEdMLlRleHR1cmUuZnJvbU1lbW9yeSg1MTIsIDUxMiwgbm9pc2UsIHtcblx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdHdyYXA6IGdsLlJFUEVBVCxcblx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdH0pO1xuXHRcdHRoaXMuX25vaXNlX3RleHR1cmUgPSB0ZXh0dXJlO1xuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihkYXRhLCBmaWxlbmFtZSwgZmlsZSkge1xuXHRcdGlmICghZGF0YSkge1xuXHRcdFx0dGhpcy5fZHJvcF90ZXh0dXJlID0gbnVsbDtcblx0XHRcdHRoaXMucHJvcGVydGllcy5uYW1lID0gXCJcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRleHR1cmUgPSBudWxsO1xuXHRcdFx0aWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dGV4dHVyZSA9IEdMLlRleHR1cmUuZnJvbVVSTChkYXRhKTtcblx0XHRcdH0gZWxzZSBpZiAoZmlsZW5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiLmRkc1wiKSAhPSAtMSkge1xuXHRcdFx0XHR0ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tRERTSW5NZW1vcnkoZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtmaWxlXSk7XG5cdFx0XHRcdHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHR0ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tVVJMKHVybCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2Ryb3BfdGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMubmFtZSA9IGZpbGVuYW1lO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLnByb3RvdHlwZS5nZXRFeHRyYU1lbnVPcHRpb25zID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0aWYgKCF0aGlzLl9kcm9wX3RleHR1cmUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0Y29udGVudDogXCJDbGVhclwiLFxuXHRcdFx0XHRjYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5fZHJvcF90ZXh0dXJlID0gbnVsbDtcblx0XHRcdFx0XHR0aGF0LnByb3BlcnRpZXMubmFtZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHR0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHR9XG5cblx0XHRpZiAoIXRleCAmJiB0aGlzLl9kcm9wX3RleHR1cmUpIHtcblx0XHRcdHRleCA9IHRoaXMuX2Ryb3BfdGV4dHVyZTtcblx0XHR9XG5cblx0XHRpZiAoIXRleCAmJiB0aGlzLnByb3BlcnRpZXMubmFtZSkge1xuXHRcdFx0dGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlKHRoaXMucHJvcGVydGllcy5uYW1lKTtcblx0XHR9XG5cblx0XHRpZiAoIXRleCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBudWxsICk7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIDEsIFwiXCIgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXN0X3RleCA9IHRleDtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZmlsdGVyID09PSBmYWxzZSkge1xuXHRcdFx0dGV4LnNldFBhcmFtZXRlcihnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXguc2V0UGFyYW1ldGVyKGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRleCApO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMSwgdGV4LmZ1bGxwYXRoIHx8IHRleC5maWxlbmFtZSApO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG5cdFx0XHRpZiAoIW91dHB1dCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHZhciB2ID0gbnVsbDtcblx0XHRcdGlmIChvdXRwdXQubmFtZSA9PSBcIndpZHRoXCIpIHtcblx0XHRcdFx0diA9IHRleC53aWR0aDtcblx0XHRcdH0gZWxzZSBpZiAob3V0cHV0Lm5hbWUgPT0gXCJoZWlnaHRcIikge1xuXHRcdFx0XHR2ID0gdGV4LmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAob3V0cHV0Lm5hbWUgPT0gXCJhc3BlY3RcIikge1xuXHRcdFx0XHR2ID0gdGV4LndpZHRoIC8gdGV4LmhlaWdodDtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YShpLCB2KTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25SZXNvdXJjZVJlbmFtZWQgPSBmdW5jdGlvbihcblx0XHRvbGRfbmFtZSxcblx0XHRuZXdfbmFtZVxuXHQpIHtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLm5hbWUgPT0gb2xkX25hbWUpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5uYW1lID0gbmV3X25hbWU7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQgfHwgdGhpcy5zaXplWzFdIDw9IDIwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2Ryb3BfdGV4dHVyZSAmJiBjdHgud2ViZ2wpIHtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoXG5cdFx0XHRcdHRoaXMuX2Ryb3BfdGV4dHVyZSxcblx0XHRcdFx0MCxcblx0XHRcdFx0MCxcblx0XHRcdFx0dGhpcy5zaXplWzBdLFxuXHRcdFx0XHR0aGlzLnNpemVbMV1cblx0XHRcdCk7XG5cdFx0XHQvL3RoaXMuX2Ryb3BfdGV4dHVyZS5yZW5kZXJRdWFkKHRoaXMucG9zWzBdLHRoaXMucG9zWzFdLHRoaXMuc2l6ZVswXSx0aGlzLnNpemVbMV0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vRGlmZmVyZW50IHRleHR1cmU/IHRoZW4gZ2V0IGl0IGZyb20gdGhlIEdQVVxuXHRcdGlmICh0aGlzLl9sYXN0X3ByZXZpZXdfdGV4ICE9IHRoaXMuX2xhc3RfdGV4KSB7XG5cdFx0XHRpZiAoY3R4LndlYmdsKSB7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcyA9IHRoaXMuX2xhc3RfdGV4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRleF9jYW52YXMgPSBMR3JhcGhUZXh0dXJlLmdlbmVyYXRlTG93UmVzVGV4dHVyZVByZXZpZXcoXG5cdFx0XHRcdFx0dGhpcy5fbGFzdF90ZXhcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCF0ZXhfY2FudmFzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbGFzdF9wcmV2aWV3X3RleCA9IHRoaXMuX2xhc3RfdGV4O1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjbG9uZUNhbnZhcyh0ZXhfY2FudmFzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX2NhbnZhcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vcmVuZGVyIHRvIGdyYXBoIGNhbnZhc1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKCFjdHgud2ViZ2wpIHtcblx0XHRcdC8vcmV2ZXJzZSBpbWFnZVxuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCB0aGlzLnNpemVbMV0pO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIC0xKTtcblx0XHR9XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLl9jYW52YXMsIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9O1xuXG5cdC8vdmVyeSBzbG93LCB1c2VkIGF0IHlvdXIgb3duIHJpc2tcblx0TEdyYXBoVGV4dHVyZS5nZW5lcmF0ZUxvd1Jlc1RleHR1cmVQcmV2aWV3ID0gZnVuY3Rpb24odGV4KSB7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBzaXplID0gTEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemU7XG5cdFx0dmFyIHRlbXBfdGV4ID0gdGV4O1xuXG5cdFx0aWYgKHRleC5mb3JtYXQgPT0gZ2wuREVQVEhfQ09NUE9ORU5UKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IC8vY2Fubm90IGdlbmVyYXRlIGZyb20gZGVwdGhcblxuXHRcdC8vR2VuZXJhdGUgbG93LWxldmVsIHZlcnNpb24gaW4gdGhlIEdQVSB0byBzcGVlZCB1cFxuXHRcdGlmICh0ZXgud2lkdGggPiBzaXplIHx8IHRleC5oZWlnaHQgPiBzaXplKSB7XG5cdFx0XHR0ZW1wX3RleCA9IHRoaXMuX3ByZXZpZXdfdGVtcF90ZXg7XG5cdFx0XHRpZiAoIXRoaXMuX3ByZXZpZXdfdGVtcF90ZXgpIHtcblx0XHRcdFx0dGVtcF90ZXggPSBuZXcgR0wuVGV4dHVyZShzaXplLCBzaXplLCB7XG5cdFx0XHRcdFx0bWluRmlsdGVyOiBnbC5ORUFSRVNUXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLl9wcmV2aWV3X3RlbXBfdGV4ID0gdGVtcF90ZXg7XG5cdFx0XHR9XG5cblx0XHRcdC8vY29weVxuXHRcdFx0dGV4LmNvcHlUbyh0ZW1wX3RleCk7XG5cdFx0XHR0ZXggPSB0ZW1wX3RleDtcblx0XHR9XG5cblx0XHQvL2NyZWF0ZSBpbnRlcm1lZGlhdGUgY2FudmFzIHdpdGggbG93cXVhbGl0eSB2ZXJzaW9uXG5cdFx0dmFyIHRleF9jYW52YXMgPSB0aGlzLl9wcmV2aWV3X2NhbnZhcztcblx0XHRpZiAoIXRleF9jYW52YXMpIHtcblx0XHRcdHRleF9jYW52YXMgPSBjcmVhdGVDYW52YXMoc2l6ZSwgc2l6ZSk7XG5cdFx0XHR0aGlzLl9wcmV2aWV3X2NhbnZhcyA9IHRleF9jYW52YXM7XG5cdFx0fVxuXG5cdFx0aWYgKHRlbXBfdGV4KSB7XG5cdFx0XHR0ZW1wX3RleC50b0NhbnZhcyh0ZXhfY2FudmFzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRleF9jYW52YXM7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUuZ2V0UmVzb3VyY2VzID0gZnVuY3Rpb24ocmVzKSB7XG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLm5hbWUpXG5cdFx0XHRyZXNbdGhpcy5wcm9wZXJ0aWVzLm5hbWVdID0gR0wuVGV4dHVyZTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJpblwiLCBcIlRleHR1cmVcIl1dO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRbXCJ3aWR0aFwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImhlaWdodFwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImFzcGVjdFwiLCBcIm51bWJlclwiXVxuXHRcdF07XG5cdH07XG5cblx0Ly91c2VkIHRvIHJlcGxhY2Ugc2hhZGVyIGNvZGVcblx0TEdyYXBoVGV4dHVyZS5yZXBsYWNlQ29kZSA9IGZ1bmN0aW9uKCBjb2RlLCBjb250ZXh0IClcblx0e1xuXHRcdHJldHVybiBjb2RlLnJlcGxhY2UoL1xce1xce1thLXpBLVowLTlfXSpcXH1cXH0vZywgZnVuY3Rpb24odil7XG5cdFx0XHR2ID0gdi5yZXBsYWNlKCAvW1xce1xcfV0vZywgXCJcIiApO1xuXHRcdFx0cmV0dXJuIGNvbnRleHRbdl0gfHwgXCJcIjtcblx0XHR9KTtcblx0fVxuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS90ZXh0dXJlXCIsIExHcmFwaFRleHR1cmUpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVByZXZpZXcoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZmxpcFk6IGZhbHNlIH07XG5cdFx0dGhpcy5zaXplID0gW1xuXHRcdFx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemUsXG5cdFx0XHRMR3JhcGhUZXh0dXJlLmltYWdlX3ByZXZpZXdfc2l6ZVxuXHRcdF07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlUHJldmlldy50aXRsZSA9IFwiUHJldmlld1wiO1xuXHRMR3JhcGhUZXh0dXJlUHJldmlldy5kZXNjID0gXCJTaG93IGEgdGV4dHVyZSBpbiB0aGUgZ3JhcGggY2FudmFzXCI7XG5cdExHcmFwaFRleHR1cmVQcmV2aWV3LmFsbG93X3ByZXZpZXcgPSBmYWxzZTtcblxuXHRMR3JhcGhUZXh0dXJlUHJldmlldy5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghY3R4LndlYmdsICYmICFMR3JhcGhUZXh0dXJlUHJldmlldy5hbGxvd19wcmV2aWV3KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL25vdCB3b3JraW5nIHdlbGxcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhfY2FudmFzID0gbnVsbDtcblxuXHRcdGlmICghdGV4LmhhbmRsZSAmJiBjdHgud2ViZ2wpIHtcblx0XHRcdHRleF9jYW52YXMgPSB0ZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleF9jYW52YXMgPSBMR3JhcGhUZXh0dXJlLmdlbmVyYXRlTG93UmVzVGV4dHVyZVByZXZpZXcodGV4KTtcblx0XHR9XG5cblx0XHQvL3JlbmRlciB0byBncmFwaCBjYW52YXNcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZmxpcFkpIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoMCwgdGhpcy5zaXplWzFdKTtcblx0XHRcdGN0eC5zY2FsZSgxLCAtMSk7XG5cdFx0fVxuXHRcdGN0eC5kcmF3SW1hZ2UodGV4X2NhbnZhcywgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3ByZXZpZXdcIiwgTEdyYXBoVGV4dHVyZVByZXZpZXcpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlU2F2ZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ0ZXhcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibmFtZVwiLCBcInN0cmluZ1wiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiXCIsIGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlIH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlU2F2ZS50aXRsZSA9IFwiU2F2ZVwiO1xuXHRMR3JhcGhUZXh0dXJlU2F2ZS5kZXNjID0gXCJTYXZlIGEgdGV4dHVyZSBpbiB0aGUgcmVwb3NpdG9yeVwiO1xuXG5cdExHcmFwaFRleHR1cmVTYXZlLnByb3RvdHlwZS5nZXRQcmV2aWV3VGV4dHVyZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl90ZXh0dXJlO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVNhdmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbWlwbWFwcykge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHR0ZXguc2V0UGFyYW1ldGVyKCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSICk7XG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcCh0ZXgudGV4dHVyZV90eXBlKTtcblx0XHRcdHRleC51bmJpbmQoMCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5uYW1lKSB7XG5cdFx0XHQvL2ZvciBjYXNlcyB3aGVyZSB3ZSB3YW50IHRvIHBlcmZvcm0gc29tZXRoaW5nIHdoZW4gc3RvcmluZyBpdFxuXHRcdFx0aWYgKExHcmFwaFRleHR1cmUuc3RvcmVUZXh0dXJlKSB7XG5cdFx0XHRcdExHcmFwaFRleHR1cmUuc3RvcmVUZXh0dXJlKHRoaXMucHJvcGVydGllcy5uYW1lLCB0ZXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZXNDb250YWluZXIoKTtcblx0XHRcdFx0Y29udGFpbmVyW3RoaXMucHJvcGVydGllcy5uYW1lXSA9IHRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl90ZXh0dXJlID0gdGV4O1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLnByb3BlcnRpZXMubmFtZSk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3NhdmVcIiwgTEdyYXBoVGV4dHVyZVNhdmUpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVPcGVyYXRpb24oKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlQlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcInZhbHVlXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5oZWxwID0gXCI8cD5waXhlbGNvZGUgbXVzdCBiZSB2ZWMzLCB1dmNvZGUgbXVzdCBiZSB2ZWMyLCBpcyBvcHRpb25hbDwvcD5cXFxuXHRcdDxwPjxzdHJvbmc+dXY6PC9zdHJvbmc+IHRleC4gY29vcmRzPC9wPjxwPjxzdHJvbmc+Y29sb3I6PC9zdHJvbmc+IHRleHR1cmUgPHN0cm9uZz5jb2xvckI6PC9zdHJvbmc+IHRleHR1cmVCPC9wPjxwPjxzdHJvbmc+dGltZTo8L3N0cm9uZz4gc2NlbmUgdGltZSA8c3Ryb25nPnZhbHVlOjwvc3Ryb25nPiBpbnB1dCB2YWx1ZTwvcD48cD5Gb3IgbXVsdGlsaW5lIHlvdSBtdXN0IHR5cGU6IHJlc3VsdCA9IC4uLjwvcD5cIjtcblxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHZhbHVlOiAxLFxuXHRcdFx0cGl4ZWxjb2RlOiBcImNvbG9yICsgY29sb3JCICogdmFsdWVcIixcblx0XHRcdHV2Y29kZTogXCJcIixcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzX2Vycm9yID0gZmFsc2U7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLndpZGdldHNfaW5mbyA9IHtcblx0XHR1dmNvZGU6IHsgd2lkZ2V0OiBcImNvZGVcIiB9LFxuXHRcdHBpeGVsY29kZTogeyB3aWRnZXQ6IFwiY29kZVwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24udGl0bGUgPSBcIk9wZXJhdGlvblwiO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLmRlc2MgPSBcIlRleHR1cmUgc2hhZGVyIG9wZXJhdGlvblwiO1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJlc2V0cyA9IHt9O1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihcblx0XHRncmFwaGNhbnZhc1xuXHQpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHR4dCA9ICF0aGF0LnByb3BlcnRpZXMuc2hvdyA/IFwiU2hvdyBUZXh0dXJlXCIgOiBcIkhpZGUgVGV4dHVyZVwiO1xuXHRcdHJldHVybiBbXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnRlbnQ6IHR4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoYXQucHJvcGVydGllcy5zaG93ID0gIXRoYXQucHJvcGVydGllcy5zaG93O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHRoaXMuaGFzX2Vycm9yID0gZmFsc2U7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5mbGFncy5jb2xsYXBzZWQgfHxcblx0XHRcdHRoaXMuc2l6ZVsxXSA8PSAyMCB8fFxuXHRcdFx0IXRoaXMucHJvcGVydGllcy5zaG93XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl90ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL29ubHkgd29ya3MgaWYgdXNpbmcgYSB3ZWJnbCByZW5kZXJlclxuXHRcdGlmICh0aGlzLl90ZXguZ2wgIT0gY3R4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9yZW5kZXIgdG8gZ3JhcGggY2FudmFzXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX3RleCwgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRleEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblxuXHRcdGlmICghdGhpcy5wcm9wZXJ0aWVzLnV2Y29kZSAmJiAhdGhpcy5wcm9wZXJ0aWVzLnBpeGVsY29kZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IDUxMjtcblx0XHR2YXIgaGVpZ2h0ID0gNTEyO1xuXHRcdGlmICh0ZXgpIHtcblx0XHRcdHdpZHRoID0gdGV4LndpZHRoO1xuXHRcdFx0aGVpZ2h0ID0gdGV4LmhlaWdodDtcblx0XHR9IGVsc2UgaWYgKHRleEIpIHtcblx0XHRcdHdpZHRoID0gdGV4Qi53aWR0aDtcblx0XHRcdGhlaWdodCA9IHRleEIuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdGlmKCF0ZXhCKVxuXHRcdFx0dGV4QiA9IEdMLlRleHR1cmUuZ2V0V2hpdGVUZXh0dXJlKCk7XG5cblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIHRleCApO1xuXG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RleCkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUod2lkdGgsIGhlaWdodCwgeyB0eXBlOiB0eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoIHRleCB8fCB0aGlzLl90ZXgsIHRoaXMuX3RleCwgdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdH1cblxuXHRcdHZhciB1dmNvZGUgPSBcIlwiO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMudXZjb2RlKSB7XG5cdFx0XHR1dmNvZGUgPSBcInV2ID0gXCIgKyB0aGlzLnByb3BlcnRpZXMudXZjb2RlO1xuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy51dmNvZGUuaW5kZXhPZihcIjtcIikgIT0gLTEpIHtcblx0XHRcdFx0Ly90aGVyZSBhcmUgbGluZSBicmVha3MsIG1lYW5zIG11bHRpbGluZSBjb2RlXG5cdFx0XHRcdHV2Y29kZSA9IHRoaXMucHJvcGVydGllcy51dmNvZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHBpeGVsY29kZSA9IFwiXCI7XG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5waXhlbGNvZGUpIHtcblx0XHRcdHBpeGVsY29kZSA9IFwicmVzdWx0ID0gXCIgKyB0aGlzLnByb3BlcnRpZXMucGl4ZWxjb2RlO1xuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy5waXhlbGNvZGUuaW5kZXhPZihcIjtcIikgIT0gLTEpIHtcblx0XHRcdFx0Ly90aGVyZSBhcmUgbGluZSBicmVha3MsIG1lYW5zIG11bHRpbGluZSBjb2RlXG5cdFx0XHRcdHBpeGVsY29kZSA9IHRoaXMucHJvcGVydGllcy5waXhlbGNvZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuX3NoYWRlcjtcblxuXHRcdGlmICggIXRoaXMuaGFzX2Vycm9yICYmICghc2hhZGVyIHx8IHRoaXMuX3NoYWRlcl9jb2RlICE9IHV2Y29kZSArIFwifFwiICsgcGl4ZWxjb2RlKSApIHtcblxuXHRcdFx0dmFyIGZpbmFsX3BpeGVsX2NvZGUgPSBMR3JhcGhUZXh0dXJlLnJlcGxhY2VDb2RlKCBMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnBpeGVsX3NoYWRlciwgeyBVVl9DT0RFOnV2Y29kZSwgUElYRUxfQ09ERTpwaXhlbGNvZGUgfSk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgZmluYWxfcGl4ZWxfY29kZSApO1xuXHRcdFx0XHR0aGlzLmJveGNvbG9yID0gXCIjMDBGRjAwXCI7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkVycm9yIGNvbXBpbGluZyBzaGFkZXI6IFwiLCBlcnIsIGZpbmFsX3BpeGVsX2NvZGUgKTtcblx0XHRcdFx0R0wuU2hhZGVyLmR1bXBFcnJvclRvQ29uc29sZShlcnIsU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBmaW5hbF9waXhlbF9jb2RlKTtcblx0XHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiI0ZGMDAwMFwiO1xuXHRcdFx0XHR0aGlzLmhhc19lcnJvciA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NoYWRlciA9IHNoYWRlcjtcblx0XHRcdHRoaXMuX3NoYWRlcl9jb2RlID0gdXZjb2RlICsgXCJ8XCIgKyBwaXhlbGNvZGU7XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMuX3NoYWRlcilcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMudmFsdWUgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbWUgPSB0aGlzLmdyYXBoLmdldFRpbWUoKTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0XHRpZiAodGV4KSB7XG5cdFx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRleEIpIHtcblx0XHRcdFx0dGV4Qi5iaW5kKDEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X3RleHR1cmVCOiAxLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHR0ZXhTaXplOiBbd2lkdGgsIGhlaWdodCwxL3dpZHRoLDEvaGVpZ2h0XSxcblx0XHRcdFx0XHR0aW1lOiB0aW1lXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzQgdGV4U2l6ZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdGltZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdmFsdWU7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0XHRcdHt7VVZfQ09ERX19O1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yNCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2KTtcXG5cXFxuXHRcdFx0dmVjMyBjb2xvciA9IGNvbG9yNC5yZ2I7XFxuXFxcblx0XHRcdHZlYzQgY29sb3I0QiA9IHRleHR1cmUyRCh1X3RleHR1cmVCLCB1dik7XFxuXFxcblx0XHRcdHZlYzMgY29sb3JCID0gY29sb3I0Qi5yZ2I7XFxuXFxcblx0XHRcdHZlYzMgcmVzdWx0ID0gY29sb3I7XFxuXFxcblx0XHRcdGZsb2F0IGFscGhhID0gMS4wO1xcblxcXG5cdFx0XHR7e1BJWEVMX0NPREV9fTtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsIGFscGhhKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQgPSBmdW5jdGlvbiAoIG5hbWUsIGNvZGUgKVxuXHR7XG5cdFx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcmVzZXRzW25hbWVdID0gY29kZTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJcIixcIlwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImJ5cGFzc1wiLFwiY29sb3JcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJhZGRcIixcImNvbG9yICsgY29sb3JCICogdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJzdWJzdHJhY3RcIixcIihjb2xvciAtIGNvbG9yQikgKiB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIm1hdGVcIixcIm1peCggY29sb3IsIGNvbG9yQiwgY29sb3I0Qi5hICogdmFsdWUpXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiaW52ZXJ0XCIsXCJ2ZWMzKDEuMCkgLSBjb2xvclwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIm11bHRpcGx5XCIsXCJjb2xvciAqIGNvbG9yQiAqIHZhbHVlXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiZGl2aWRlXCIsXCIoY29sb3IgLyBjb2xvckIpIC8gdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJkaWZmZXJlbmNlXCIsXCJhYnMoY29sb3IgLSBjb2xvckIpICogdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJtYXhcIixcIm1heChjb2xvciwgY29sb3JCKSAqIHZhbHVlXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwibWluXCIsXCJtaW4oY29sb3IsIGNvbG9yQikgKiB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImRpc3BsYWNlXCIsXCJ0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIChjb2xvckIueHkgLSB2ZWMyKDAuNSkpICogdmFsdWUpLnh5elwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImdyYXlzY2FsZVwiLFwidmVjMyhjb2xvci54ICsgY29sb3IueSArIGNvbG9yLnopICogdmFsdWUgLyAzLjBcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJzYXR1cmF0aW9uXCIsXCJtaXgoIHZlYzMoY29sb3IueCArIGNvbG9yLnkgKyBjb2xvci56KSAvIDMuMCwgY29sb3IsIHZhbHVlIClcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJub3JtYWxtYXBcIixcIlxcblxcXG5cdFx0ZmxvYXQgejAgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoLXRleFNpemUueiwgLXRleFNpemUudykgKS54O1xcblxcXG5cdFx0ZmxvYXQgejEgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoMC4wLCAtdGV4U2l6ZS53KSApLng7XFxuXFxcblx0XHRmbG9hdCB6MiA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMih0ZXhTaXplLnosIC10ZXhTaXplLncpICkueDtcXG5cXFxuXHRcdGZsb2F0IHozID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKC10ZXhTaXplLnosIDAuMCkgKS54O1xcblxcXG5cdFx0ZmxvYXQgejQgPSBjb2xvci54O1xcblxcXG5cdFx0ZmxvYXQgejUgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIodGV4U2l6ZS56LCAwLjApICkueDtcXG5cXFxuXHRcdGZsb2F0IHo2ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKC10ZXhTaXplLnosIHRleFNpemUudykgKS54O1xcblxcXG5cdFx0ZmxvYXQgejcgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoMC4wLCB0ZXhTaXplLncpICkueDtcXG5cXFxuXHRcdGZsb2F0IHo4ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKHRleFNpemUueiwgdGV4U2l6ZS53KSApLng7XFxuXFxcblx0XHR2ZWMzIG5vcm1hbCA9IHZlYzMoIHoyICsgMi4wKno0ICsgejcgLSB6MCAtIDIuMCp6MyAtIHo1LCB6NSArIDIuMCp6NiArIHo3IC16MCAtIDIuMCp6MSAtIHoyLCAxLjAgKTtcXG5cXFxuXHRcdG5vcm1hbC54eSAqPSB2YWx1ZTtcXG5cXFxuXHRcdHJlc3VsdC54eXogPSBub3JtYWxpemUobm9ybWFsKSAqIDAuNSArIHZlYzMoMC41KTtcXG5cXFxuXHRcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJ0aHJlc2hvbGRcIixcInZlYzMoY29sb3IueCA+IGNvbG9yQi54ICogdmFsdWUgPyAxLjAgOiAwLjAsY29sb3IueSA+IGNvbG9yQi55ICogdmFsdWUgPyAxLjAgOiAwLjAsY29sb3IueiA+IGNvbG9yQi56ICogdmFsdWUgPyAxLjAgOiAwLjApXCIpO1xuXG5cdC8vd2ViZ2xzdHVkaW8gc3R1ZmYuLi5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcm90b3R5cGUub25JbnNwZWN0ID0gZnVuY3Rpb24od2lkZ2V0cylcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR3aWRnZXRzLmFkZENvbWJvKFwiUHJlc2V0c1wiLFwiXCIseyB2YWx1ZXM6IE9iamVjdC5rZXlzKExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJlc2V0cyksIGNhbGxiYWNrOiBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBjb2RlID0gTEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcmVzZXRzW3ZdO1xuXHRcdFx0aWYoIWNvZGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHRoYXQuc2V0UHJvcGVydHkoXCJwaXhlbGNvZGVcIixjb2RlKTtcblx0XHRcdHRoYXQudGl0bGUgPSB2O1xuXHRcdFx0d2lkZ2V0cy5yZWZyZXNoKCk7XG5cdFx0fX0pO1xuXHR9XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL29wZXJhdGlvblwiLCBMR3JhcGhUZXh0dXJlT3BlcmF0aW9uKTtcblxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlU2hhZGVyKCkge1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRjb2RlOiBcIlwiLFxuXHRcdFx0dV92YWx1ZTogMSxcblx0XHRcdHVfY29sb3I6IFsxLDEsMSwxXSxcblx0XHRcdHdpZHRoOiA1MTIsXG5cdFx0XHRoZWlnaHQ6IDUxMixcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMucHJvcGVydGllcy5jb2RlID0gTEdyYXBoVGV4dHVyZVNoYWRlci5waXhlbF9zaGFkZXI7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7IHVfdmFsdWU6IDEsIHVfY29sb3I6IHZlYzQuY3JlYXRlKCksIGluX3RleHR1cmU6IDAsIHRleFNpemU6IHZlYzQuY3JlYXRlKCksIHRpbWU6IDAgfTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIudGl0bGUgPSBcIlNoYWRlclwiO1xuXHRMR3JhcGhUZXh0dXJlU2hhZGVyLmRlc2MgPSBcIlRleHR1cmUgc2hhZGVyXCI7XG5cdExHcmFwaFRleHR1cmVTaGFkZXIud2lkZ2V0c19pbmZvID0ge1xuXHRcdGNvZGU6IHsgdHlwZTogXCJjb2RlXCIsIGxhbmc6IFwiZ2xzbFwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oXG5cdFx0bmFtZSxcblx0XHR2YWx1ZVxuXHQpIHtcblx0XHRpZiAobmFtZSAhPSBcImNvZGVcIikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcigpO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly91cGRhdGUgY29ubmVjdGlvbnNcblx0XHR2YXIgdW5pZm9ybXMgPSBzaGFkZXIudW5pZm9ybUluZm87XG5cblx0XHQvL3JlbW92ZSBkZXByZWNhdGVkIHNsb3RzXG5cdFx0aWYgKHRoaXMuaW5wdXRzKSB7XG5cdFx0XHR2YXIgYWxyZWFkeSA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKGkpO1xuXHRcdFx0XHRpZiAoIWluZm8pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh1bmlmb3Jtc1tpbmZvLm5hbWVdICYmICFhbHJlYWR5W2luZm8ubmFtZV0pIHtcblx0XHRcdFx0XHRhbHJlYWR5W2luZm8ubmFtZV0gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW5wdXQoaSk7XG5cdFx0XHRcdGktLTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3VwZGF0ZSBleGlzdGluZyBvbmVzXG5cdFx0Zm9yICh2YXIgaSBpbiB1bmlmb3Jtcykge1xuXHRcdFx0dmFyIGluZm8gPSBzaGFkZXIudW5pZm9ybUluZm9baV07XG5cdFx0XHRpZiAoaW5mby5sb2MgPT09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IC8vaXMgYW4gYXR0cmlidXRlLCBub3QgYSB1bmlmb3JtXG5cdFx0XHRpZiAoaSA9PSBcInRpbWVcIikge1xuXHRcdFx0XHQvL2RlZmF1bHQgb25lXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHRpZiAodGhpcy5fc2hhZGVyLnNhbXBsZXJzW2ldKSB7XG5cdFx0XHRcdHR5cGUgPSBcInRleHR1cmVcIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoaW5mby5zaXplKSB7XG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJ2ZWMyXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJ2ZWMzXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJ2ZWM0XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDk6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJtYXQzXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDE2OlxuXHRcdFx0XHRcdFx0dHlwZSA9IFwibWF0NFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KGkpO1xuXHRcdFx0aWYgKHNsb3QgPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5hZGRJbnB1dChpLCB0eXBlKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbnB1dF9pbmZvID0gdGhpcy5nZXRJbnB1dEluZm8oc2xvdCk7XG5cdFx0XHRpZiAoIWlucHV0X2luZm8pIHtcblx0XHRcdFx0dGhpcy5hZGRJbnB1dChpLCB0eXBlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChpbnB1dF9pbmZvLnR5cGUgPT0gdHlwZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW5wdXQoc2xvdCwgdHlwZSk7XG5cdFx0XHRcdHRoaXMuYWRkSW5wdXQoaSwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucHJvdG90eXBlLmdldFNoYWRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vcmVwbHVnXG5cdFx0aWYgKHRoaXMuX3NoYWRlciAmJiB0aGlzLl9zaGFkZXJfY29kZSA9PSB0aGlzLnByb3BlcnRpZXMuY29kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3NoYWRlcjtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFkZXJfY29kZSA9IHRoaXMucHJvcGVydGllcy5jb2RlO1xuXHRcdHRoaXMuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgdGhpcy5wcm9wZXJ0aWVzLmNvZGUgKTtcblx0XHRpZiAoIXRoaXMuX3NoYWRlcikge1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiZ3JlZW5cIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NoYWRlcjtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlU2hhZGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKCk7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGV4X3Nsb3QgPSAwO1xuXHRcdHZhciBpbl90ZXggPSBudWxsO1xuXG5cdFx0Ly9zZXQgdW5pZm9ybXNcblx0XHRpZih0aGlzLmlucHV0cylcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKGkpO1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YShpKTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLmNvbnN0cnVjdG9yID09PSBHTC5UZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEuYmluZCh0ZXhfc2xvdCk7XG5cdFx0XHRcdGlmICghaW5fdGV4KSB7XG5cdFx0XHRcdFx0aW5fdGV4ID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhID0gdGV4X3Nsb3Q7XG5cdFx0XHRcdHRleF9zbG90Kys7XG5cdFx0XHR9XG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybShpbmZvLm5hbWUsIGRhdGEpOyAvL2RhdGEgaXMgdGV4X3Nsb3Rcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIGluX3RleCApO1xuXG5cdFx0Ly9yZW5kZXIgdG8gdGV4dHVyZVxuXHRcdHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IHRoaXMucHJvcGVydGllcy5oZWlnaHQgfCAwO1xuXHRcdGlmICh3ID09IDApIHtcblx0XHRcdHcgPSBpbl90ZXggPyBpbl90ZXgud2lkdGggOiBnbC5jYW52YXMud2lkdGg7XG5cdFx0fVxuXHRcdGlmIChoID09IDApIHtcblx0XHRcdGggPSBpbl90ZXggPyBpbl90ZXguaGVpZ2h0IDogZ2wuY2FudmFzLmhlaWdodDtcblx0XHR9XG5cdFx0dW5pZm9ybXMudGV4U2l6ZVswXSA9IHc7XG5cdFx0dW5pZm9ybXMudGV4U2l6ZVsxXSA9IGg7XG5cdFx0dW5pZm9ybXMudGV4U2l6ZVsyXSA9IDEvdztcblx0XHR1bmlmb3Jtcy50ZXhTaXplWzNdID0gMS9oO1xuXHRcdHVuaWZvcm1zLnRpbWUgPSB0aGlzLmdyYXBoLmdldFRpbWUoKTtcblx0XHR1bmlmb3Jtcy51X3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLnVfdmFsdWU7XG5cdFx0dW5pZm9ybXMudV9jb2xvci5zZXQoIHRoaXMucHJvcGVydGllcy51X2NvbG9yICk7XG5cblx0XHRpZiAoICF0aGlzLl90ZXggfHwgdGhpcy5fdGV4LnR5cGUgIT0gdHlwZSB8fCAgdGhpcy5fdGV4LndpZHRoICE9IHcgfHwgdGhpcy5fdGV4LmhlaWdodCAhPSBoICkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUodywgaCwgeyAgdHlwZTogdHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9KTtcblx0XHR9XG5cdFx0dmFyIHRleCA9IHRoaXMuX3RleDtcblx0XHR0ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucGl4ZWxfc2hhZGVyID1cblwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcbnVuaWZvcm0gZmxvYXQgdGltZTsgLy90aW1lIGluIHNlY29uZHNcXG5cXFxudW5pZm9ybSB2ZWM0IHRleFNpemU7IC8vdGV4IHJlc29sdXRpb25cXG5cXFxudW5pZm9ybSBmbG9hdCB1X3ZhbHVlO1xcblxcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXG5cXFxudm9pZCBtYWluKCkge1xcblxcXG5cdHZlYzIgdXYgPSB2X2Nvb3JkO1xcblxcXG5cdHZlYzMgY29sb3IgPSB2ZWMzKDAuMCk7XFxuXFxcblx0Ly95b3VyIGNvZGUgaGVyZVxcblxcXG5cdGNvbG9yLnh5PXV2O1xcblxcblxcXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3NoYWRlclwiLCBMR3JhcGhUZXh0dXJlU2hhZGVyKTtcblxuXHQvLyBUZXh0dXJlIFNjYWxlIE9mZnNldFxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVTY2FsZU9mZnNldCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJzY2FsZVwiLCBcInZlYzJcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIm9mZnNldFwiLCBcInZlYzJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdG9mZnNldDogdmVjMi5mcm9tVmFsdWVzKDAsIDApLFxuXHRcdFx0c2NhbGU6IHZlYzIuZnJvbVZhbHVlcygxLCAxKSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC50aXRsZSA9IFwiU2NhbGUvT2Zmc2V0XCI7XG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC5kZXNjID0gXCJBcHBsaWVzIGFuIHNjYWxpbmcgYW5kIG9mZnNldGluZ1wiO1xuXG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIHx8ICF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgd2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cdFx0dmFyIHR5cGUgPSAgdGhpcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuTE9XID8gZ2wuVU5TSUdORURfQllURSA6IGdsLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVDtcblx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuREVGQVVMVCkge1xuXHRcdFx0dHlwZSA9IHRleC50eXBlO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0aGlzLl90ZXggfHxcblx0XHRcdHRoaXMuX3RleC53aWR0aCAhPSB3aWR0aCB8fFxuXHRcdFx0dGhpcy5fdGV4LmhlaWdodCAhPSBoZWlnaHQgfHxcblx0XHRcdHRoaXMuX3RleC50eXBlICE9IHR5cGVcblx0XHQpIHtcblx0XHRcdHRoaXMuX3RleCA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuX3NoYWRlcjtcblxuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYgKHNjYWxlKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuc2NhbGVbMF0gPSBzY2FsZVswXTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5zY2FsZVsxXSA9IHNjYWxlWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZTtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLm9mZnNldFswXSA9IG9mZnNldFswXTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5vZmZzZXRbMV0gPSBvZmZzZXRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMucHJvcGVydGllcy5vZmZzZXQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X3NjYWxlOiBzY2FsZSxcblx0XHRcdFx0XHR1X29mZnNldDogb2Zmc2V0XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X3NjYWxlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzIgdXYgPSB2X2Nvb3JkO1xcblxcXG5cdFx0XHR1diA9IHV2IC8gdV9zY2FsZSAtIHVfb2Zmc2V0O1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1dik7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUvc2NhbGVPZmZzZXRcIixcblx0XHRMR3JhcGhUZXh0dXJlU2NhbGVPZmZzZXRcblx0KTtcblxuXHQvLyBXYXJwIChkaXN0b3J0IGEgdGV4dHVyZSkgKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVXYXJwKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIndhcnBcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJmYWN0b3JcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGZhY3RvcjogMC4wMSxcblx0XHRcdHNjYWxlOiBbMSwxXSxcblx0XHRcdG9mZnNldDogWzAsMF0sXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgXG5cdFx0XHR1X3RleHR1cmU6IDAsIFxuXHRcdFx0dV90ZXh0dXJlQjogMSwgXG5cdFx0XHR1X2ZhY3RvcjogMSwgXG5cdFx0XHR1X3NjYWxlOiB2ZWMyLmNyZWF0ZSgpLFxuXHRcdFx0dV9vZmZzZXQ6IHZlYzIuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVdhcnAud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2FycC50aXRsZSA9IFwiV2FycFwiO1xuXHRMR3JhcGhUZXh0dXJlV2FycC5kZXNjID0gXCJUZXh0dXJlIHdhcnAgb3BlcmF0aW9uXCI7XG5cblx0TEdyYXBoVGV4dHVyZVdhcnAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cblx0XHR2YXIgd2lkdGggPSA1MTI7XG5cdFx0dmFyIGhlaWdodCA9IDUxMjtcblx0XHR2YXIgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRleCkge1xuXHRcdFx0d2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSB0ZXguaGVpZ2h0O1xuXHRcdFx0dHlwZSA9IHRleC50eXBlO1xuXHRcdH0gZWxzZSBpZiAodGV4Qikge1xuXHRcdFx0d2lkdGggPSB0ZXhCLndpZHRoO1xuXHRcdFx0aGVpZ2h0ID0gdGV4Qi5oZWlnaHQ7XG5cdFx0XHR0eXBlID0gdGV4Qi50eXBlO1xuXHRcdH1cblxuXHRcdGlmICghdGV4ICYmICF0aGlzLl90ZXgpIHtcblx0XHRcdHRoaXMuX3RleCA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0dHlwZTpcblx0XHRcdFx0XHR0aGlzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1dcblx0XHRcdFx0XHRcdD8gZ2wuVU5TSUdORURfQllURVxuXHRcdFx0XHRcdFx0OiBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXG5cdFx0XHRcdHRleCB8fCB0aGlzLl90ZXgsXG5cdFx0XHRcdHRoaXMuX3RleCxcblx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuXG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVdhcnAucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBmYWN0b3IgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHRpZiAoZmFjdG9yICE9IG51bGwpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5mYWN0b3IgPSBmYWN0b3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZhY3RvciA9IHBhcnNlRmxvYXQodGhpcy5wcm9wZXJ0aWVzLmZhY3Rvcik7XG5cdFx0fVxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfZmFjdG9yID0gZmFjdG9yO1xuXHRcdHVuaWZvcm1zLnVfc2NhbGUuc2V0KCB0aGlzLnByb3BlcnRpZXMuc2NhbGUgKTtcblx0XHR1bmlmb3Jtcy51X29mZnNldC5zZXQoIHRoaXMucHJvcGVydGllcy5vZmZzZXQgKTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0XHRpZiAodGV4KSB7XG5cdFx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRleEIpIHtcblx0XHRcdFx0dGV4Qi5iaW5kKDEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoIHVuaWZvcm1zIClcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2FycC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZmFjdG9yO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfc2NhbGU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0XHRcdHV2ICs9ICggdGV4dHVyZTJEKHVfdGV4dHVyZUIsIHV2KS5yZyAtIHZlYzIoMC41KSkgKiB1X2ZhY3RvciAqIHVfc2NhbGUgKyB1X29mZnNldDtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3dhcnBcIiwgTEdyYXBoVGV4dHVyZVdhcnApO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdC8vIFRleHR1cmUgdG8gVmlld3BvcnQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGFkZGl0aXZlOiBmYWxzZSxcblx0XHRcdGFudGlhbGlhc2luZzogZmFsc2UsXG5cdFx0XHRmaWx0ZXI6IHRydWUsXG5cdFx0XHRkaXNhYmxlX2FscGhhOiBmYWxzZSxcblx0XHRcdGdhbW1hOiAxLjAsXG5cdFx0XHR2aWV3cG9ydDogWzAsMCwxLDFdXG5cdFx0fTtcblx0XHR0aGlzLnNpemVbMF0gPSAxMzA7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC50aXRsZSA9IFwidG8gVmlld3BvcnRcIjtcblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuZGVzYyA9IFwiVGV4dHVyZSB0byB2aWV3cG9ydFwiO1xuXG5cdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9wcmV2X3ZpZXdwb3J0ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKCBjdHggKVxuXHR7XG5cdFx0aWYgKCB0aGlzLmZsYWdzLmNvbGxhcHNlZCB8fCB0aGlzLnNpemVbMV0gPD0gNDAgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmRyYXdJbWFnZSggY3R4ID09IGdsID8gdGV4IDogZ2wuY2FudmFzLCAxMCwzMCwgdGhpcy5zaXplWzBdIC0yMCwgdGhpcy5zaXplWzFdIC00MCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5kaXNhYmxlX2FscGhhKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRcdGlmICh0aGlzLnByb3BlcnRpZXMuYWRkaXRpdmUpIHtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0dmFyIGdhbW1hID0gdGhpcy5wcm9wZXJ0aWVzLmdhbW1hIHx8IDEuMDtcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHRnYW1tYSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdH1cblxuXHRcdHRleC5zZXRQYXJhbWV0ZXIoXG5cdFx0XHRnbC5URVhUVVJFX01BR19GSUxURVIsXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuZmlsdGVyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVFxuXHRcdCk7XG5cblx0XHR2YXIgb2xkX3ZpZXdwb3J0ID0gTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX3ByZXZfdmlld3BvcnQ7XG5cdFx0b2xkX3ZpZXdwb3J0LnNldCggZ2wudmlld3BvcnRfZGF0YSApO1xuXHRcdHZhciBuZXdfdmlldyA9IHRoaXMucHJvcGVydGllcy52aWV3cG9ydDtcblx0XHRnbC52aWV3cG9ydCggb2xkX3ZpZXdwb3J0WzBdICsgb2xkX3ZpZXdwb3J0WzJdICogbmV3X3ZpZXdbMF0sIG9sZF92aWV3cG9ydFsxXSArIG9sZF92aWV3cG9ydFszXSAqIG5ld192aWV3WzFdLCBvbGRfdmlld3BvcnRbMl0gKiBuZXdfdmlld1syXSwgb2xkX3ZpZXdwb3J0WzNdICogbmV3X3ZpZXdbM10gKTtcblx0XHR2YXIgdmlld3BvcnQgPSBnbC5nZXRWaWV3cG9ydCgpOyAvL2dsLmdldFBhcmFtZXRlcihnbC5WSUVXUE9SVCk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmFudGlhbGlhc2luZykge1xuXHRcdFx0aWYgKCFMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fc2hhZGVyKSB7XG5cdFx0XHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5hYV9waXhlbF9zaGFkZXJcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX3NoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1Vmlld3BvcnRTaXplOiBbdGV4LndpZHRoLCB0ZXguaGVpZ2h0XSxcblx0XHRcdFx0XHR1X2lnYW1tYTogMSAvIGdhbW1hLFxuXHRcdFx0XHRcdGludmVyc2VWUDogWzEgLyB0ZXgud2lkdGgsIDEgLyB0ZXguaGVpZ2h0XVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGdhbW1hICE9IDEuMCkge1xuXHRcdFx0XHRpZiAoIUxHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9nYW1tYV9zaGFkZXIpIHtcblx0XHRcdFx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fZ2FtbWFfc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0LmdhbW1hX3BpeGVsX3NoYWRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4LnRvVmlld3BvcnQoTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX2dhbW1hX3NoYWRlciwge1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X2lnYW1tYTogMSAvIGdhbW1hXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGV4LnRvVmlld3BvcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbC52aWV3cG9ydCggb2xkX3ZpZXdwb3J0WzBdLCBvbGRfdmlld3BvcnRbMV0sIG9sZF92aWV3cG9ydFsyXSwgb2xkX3ZpZXdwb3J0WzNdICk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJnYW1tYVwiLCBcIm51bWJlclwiXV07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuYWFfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVWaWV3cG9ydFNpemU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgaW52ZXJzZVZQO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2lnYW1tYTtcXG5cXFxuXHRcdCNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXFxuXFxcblx0XHQjZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuXFxcblx0XHQjZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcXG5cdFx0XFxuXFxcblx0XHQvKiBmcm9tIG1pdHN1aGlrby93ZWJnbC1tZWluY3JhZnQgYmFzZWQgb24gdGhlIGNvZGUgb24gZ2Vla3MzZC5jb20gKi9cXG5cXFxuXHRcdHZlYzQgYXBwbHlGWEFBKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZnJhZ0Nvb3JkKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcXG5cdFx0XHQvKnZlYzIgaW52ZXJzZVZQID0gdmVjMigxLjAgLyB1Vmlld3BvcnRTaXplLngsIDEuMCAvIHVWaWV3cG9ydFNpemUueSk7Ki9cXG5cXFxuXHRcdFx0dmVjMyByZ2JOVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIC0xLjApKSAqIGludmVyc2VWUCkueHl6O1xcblxcXG5cdFx0XHR2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlApLnh5ejtcXG5cXFxuXHRcdFx0dmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodGV4LCAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIDEuMCkpICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgcmdiTSAgPSB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHR2ZWMyIGRpcjtcXG5cXFxuXHRcdFx0ZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcblxcXG5cdFx0XHRkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHRmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKiAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHRmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG5cXFxuXHRcdFx0ZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksIGRpciAqIHJjcERpck1pbikpICogaW52ZXJzZVZQO1xcblxcXG5cdFx0XHRcXG5cXFxuXHRcdFx0dmVjMyByZ2JBID0gMC41ICogKHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogKyBcXG5cXFxuXHRcdFx0XHR0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMi4wIC8gMy4wIC0gMC41KSkueHl6KTtcXG5cXFxuXHRcdFx0dmVjMyByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAodGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogLTAuNSkueHl6ICsgXFxuXFxcblx0XHRcdFx0dGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogMC41KS54eXopO1xcblxcXG5cdFx0XHRcXG5cXFxuXHRcdFx0Ly9yZXR1cm4gdmVjNChyZ2JBLDEuMCk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcblxcXG5cdFx0XHRpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuXFxcblx0XHRcdFx0Y29sb3IgPSB2ZWM0KHJnYkEsIDEuMCk7XFxuXFxcblx0XHRcdGVsc2VcXG5cXFxuXHRcdFx0XHRjb2xvciA9IHZlYzQocmdiQiwgMS4wKTtcXG5cXFxuXHRcdFx0aWYodV9pZ2FtbWEgIT0gMS4wKVxcblxcXG5cdFx0XHRcdGNvbG9yLnh5eiA9IHBvdyggY29sb3IueHl6LCB2ZWMzKHVfaWdhbW1hKSApO1xcblxcXG5cdFx0XHRyZXR1cm4gY29sb3I7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGFwcGx5RlhBQSggdV90ZXh0dXJlLCB2X2Nvb3JkICogdVZpZXdwb3J0U2l6ZSkgO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuZ2FtbWFfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2lnYW1tYTtcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxuXHRcdFx0Y29sb3IueHl6ID0gcG93KGNvbG9yLnh5eiwgdmVjMyh1X2lnYW1tYSkgKTtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL3Rvdmlld3BvcnRcIixcblx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydFxuXHQpO1xuXG5cdC8vIFRleHR1cmUgQ29weSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQ29weSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHNpemU6IDAsXG5cdFx0XHRnZW5lcmF0ZV9taXBtYXBzOiBmYWxzZSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDb3B5LnRpdGxlID0gXCJDb3B5XCI7XG5cdExHcmFwaFRleHR1cmVDb3B5LmRlc2MgPSBcIkNvcHkgVGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlQ29weS53aWRnZXRzX2luZm8gPSB7XG5cdFx0c2l6ZToge1xuXHRcdFx0d2lkZ2V0OiBcImNvbWJvXCIsXG5cdFx0XHR2YWx1ZXM6IFswLCAzMiwgNjQsIDEyOCwgMjU2LCA1MTIsIDEwMjQsIDIwNDhdXG5cdFx0fSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNvcHkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCAmJiAhdGhpcy5fdGVtcF90ZXh0dXJlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdC8vY29weSB0aGUgdGV4dHVyZVxuXHRcdGlmICh0ZXgpIHtcblx0XHRcdHZhciB3aWR0aCA9IHRleC53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSB0ZXguaGVpZ2h0O1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnNpemUgIT0gMCkge1xuXHRcdFx0XHR3aWR0aCA9IHRoaXMucHJvcGVydGllcy5zaXplO1xuXHRcdFx0XHRoZWlnaHQgPSB0aGlzLnByb3BlcnRpZXMuc2l6ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cblx0XHRcdHZhciB0eXBlID0gdGV4LnR5cGU7XG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cpIHtcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuSElHSCkge1xuXHRcdFx0XHR0eXBlID0gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCF0ZW1wIHx8XG5cdFx0XHRcdHRlbXAud2lkdGggIT0gd2lkdGggfHxcblx0XHRcdFx0dGVtcC5oZWlnaHQgIT0gaGVpZ2h0IHx8XG5cdFx0XHRcdHRlbXAudHlwZSAhPSB0eXBlXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIG1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzICYmXG5cdFx0XHRcdFx0aXNQb3dlck9mVHdvKHdpZHRoKSAmJlxuXHRcdFx0XHRcdGlzUG93ZXJPZlR3byhoZWlnaHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG1pbkZpbHRlciA9IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0XHRtaW5GaWx0ZXI6IG1pbkZpbHRlcixcblx0XHRcdFx0XHRtYWdGaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRleC5jb3B5VG8odGhpcy5fdGVtcF90ZXh0dXJlKTtcblxuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzKSB7XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5iaW5kKDApO1xuXHRcdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLl90ZW1wX3RleHR1cmUudGV4dHVyZV90eXBlKTtcblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLnVuYmluZCgwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY29weVwiLCBMR3JhcGhUZXh0dXJlQ29weSk7XG5cblx0Ly8gVGV4dHVyZSBEb3duc2FtcGxlICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVEb3duc2FtcGxlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0aXRlcmF0aW9uczogMSxcblx0XHRcdGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUudGl0bGUgPSBcIkRvd25zYW1wbGVcIjtcblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUuZGVzYyA9IFwiRG93bnNhbXBsZSBUZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLndpZGdldHNfaW5mbyA9IHtcblx0XHRpdGVyYXRpb25zOiB7IHR5cGU6IFwibnVtYmVyXCIsIHN0ZXA6IDEsIHByZWNpc2lvbjogMCwgbWluOiAwIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RlbXBfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHQvL3dlIGRvIG5vdCBhbGxvdyBhbnkgdGV4dHVyZSBkaWZmZXJlbnQgdGhhbiB0ZXh0dXJlIDJEXG5cdFx0aWYgKCF0ZXggfHwgdGV4LnRleHR1cmVfdHlwZSAhPT0gR0wuVEVYVFVSRV8yRCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuaXRlcmF0aW9ucyA8IDEpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5fc2hhZGVyID0gc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHdpZHRoID0gdGV4LndpZHRoIHwgMDtcblx0XHR2YXIgaGVpZ2h0ID0gdGV4LmhlaWdodCB8IDA7XG5cdFx0dmFyIHR5cGUgPSB0ZXgudHlwZTtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cpIHtcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5ISUdIKSB7XG5cdFx0XHR0eXBlID0gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdH1cblx0XHR2YXIgaXRlcmF0aW9ucyA9IHRoaXMucHJvcGVydGllcy5pdGVyYXRpb25zIHx8IDE7XG5cblx0XHR2YXIgb3JpZ2luID0gdGV4O1xuXHRcdHZhciB0YXJnZXQgPSBudWxsO1xuXG5cdFx0dmFyIHRlbXAgPSBbXTtcblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRmb3JtYXQ6IHRleC5mb3JtYXRcblx0XHR9O1xuXG5cdFx0dmFyIG9mZnNldCA9IHZlYzIuY3JlYXRlKCk7XG5cdFx0dmFyIHVuaWZvcm1zID0ge1xuXHRcdFx0dV9vZmZzZXQ6IG9mZnNldFxuXHRcdH07XG5cblx0XHRpZiAodGhpcy5fdGV4dHVyZSkge1xuXHRcdFx0R0wuVGV4dHVyZS5yZWxlYXNlVGVtcG9yYXJ5KHRoaXMuX3RleHR1cmUpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG5cdFx0XHRvZmZzZXRbMF0gPSAxIC8gd2lkdGg7XG5cdFx0XHRvZmZzZXRbMV0gPSAxIC8gaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aCA+PiAxIHx8IDA7XG5cdFx0XHRoZWlnaHQgPSBoZWlnaHQgPj4gMSB8fCAwO1xuXHRcdFx0dGFyZ2V0ID0gR0wuVGV4dHVyZS5nZXRUZW1wb3Jhcnkod2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG5cdFx0XHR0ZW1wLnB1c2godGFyZ2V0KTtcblx0XHRcdG9yaWdpbi5zZXRQYXJhbWV0ZXIoR0wuVEVYVFVSRV9NQUdfRklMVEVSLCBHTC5ORUFSRVNUKTtcblx0XHRcdG9yaWdpbi5jb3B5VG8odGFyZ2V0LCBzaGFkZXIsIHVuaWZvcm1zKTtcblx0XHRcdGlmICh3aWR0aCA9PSAxICYmIGhlaWdodCA9PSAxKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSAvL25vdGhpbmcgZWxzZSB0byBkb1xuXHRcdFx0b3JpZ2luID0gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdC8va2VlcCB0aGUgbGFzdCB0ZXh0dXJlIHVzZWRcblx0XHR0aGlzLl90ZXh0dXJlID0gdGVtcC5wb3AoKTtcblxuXHRcdC8vZnJlZSB0aGUgcmVzdFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7ICsraSkge1xuXHRcdFx0R0wuVGV4dHVyZS5yZWxlYXNlVGVtcG9yYXJ5KHRlbXBbaV0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbWlwbWFwcykge1xuXHRcdFx0dGhpcy5fdGV4dHVyZS5iaW5kKDApO1xuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fdGV4dHVyZS50ZXh0dXJlX3R5cGUpO1xuXHRcdFx0dGhpcy5fdGV4dHVyZS51bmJpbmQoMCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleHR1cmUpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCApO1xcblxcXG5cdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdmVjMiggdV9vZmZzZXQueCwgMC4wICkgKTtcXG5cXFxuXHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHZlYzIoIDAuMCwgdV9vZmZzZXQueSApICk7XFxuXFxcblx0XHRcdGNvbG9yICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB2ZWMyKCB1X29mZnNldC54LCB1X29mZnNldC55ICkgKTtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogMC4yNTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxuXHRcdFwidGV4dHVyZS9kb3duc2FtcGxlXCIsXG5cdFx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGVcblx0KTtcblxuXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVJlc2l6ZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHNpemU6IFs1MTIsNTEyXSxcblx0XHRcdGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVJlc2l6ZS50aXRsZSA9IFwiUmVzaXplXCI7XG5cdExHcmFwaFRleHR1cmVSZXNpemUuZGVzYyA9IFwiUmVzaXplIFRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZVJlc2l6ZS53aWRnZXRzX2luZm8gPSB7XG5cdFx0aXRlcmF0aW9uczogeyB0eXBlOiBcIm51bWJlclwiLCBzdGVwOiAxLCBwcmVjaXNpb246IDAsIG1pbjogMCB9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlUmVzaXplLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RlbXBfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHQvL3dlIGRvIG5vdCBhbGxvdyBhbnkgdGV4dHVyZSBkaWZmZXJlbnQgdGhhbiB0ZXh0dXJlIDJEXG5cdFx0aWYgKCF0ZXggfHwgdGV4LnRleHR1cmVfdHlwZSAhPT0gR0wuVEVYVFVSRV8yRCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRoaXMucHJvcGVydGllcy5zaXplWzBdIHwgMDtcblx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzLnNpemVbMV0gfCAwO1xuXHRcdGlmKHdpZHRoID09IDApXG5cdFx0XHR3aWR0aCA9IHRleC53aWR0aDtcblx0XHRpZihoZWlnaHQgPT0gMClcblx0XHRcdGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cdFx0dmFyIHR5cGUgPSB0ZXgudHlwZTtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cpIHtcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5ISUdIKSB7XG5cdFx0XHR0eXBlID0gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdH1cblxuXHRcdGlmKCAhdGhpcy5fdGV4dHVyZSB8fCB0aGlzLl90ZXh0dXJlLndpZHRoICE9IHdpZHRoIHx8IHRoaXMuX3RleHR1cmUuaGVpZ2h0ICE9IGhlaWdodCB8fCB0aGlzLl90ZXh0dXJlLnR5cGUgIT0gdHlwZSApXG5cdFx0XHR0aGlzLl90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHdpZHRoLCBoZWlnaHQsIHsgdHlwZTogdHlwZSB9ICk7XG5cblx0XHR0ZXguY29weVRvKCB0aGlzLl90ZXh0dXJlICk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmdlbmVyYXRlX21pcG1hcHMpIHtcblx0XHRcdHRoaXMuX3RleHR1cmUuYmluZCgwKTtcblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuX3RleHR1cmUudGV4dHVyZV90eXBlKTtcblx0XHRcdHRoaXMuX3RleHR1cmUudW5iaW5kKDApO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL3Jlc2l6ZVwiLCBMR3JhcGhUZXh0dXJlUmVzaXplICk7XG5cblx0Ly8gVGV4dHVyZSBBdmVyYWdlICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQXZlcmFnZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ0ZXhcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiYXZnXCIsIFwidmVjNFwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcImx1bVwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHR1c2VfcHJldmlvdXNfZnJhbWU6IHRydWUsIC8vdG8gYXZvaWQgc3RhbGxzIFxuXHRcdFx0aGlnaF9xdWFsaXR5OiBmYWxzZSAvL3RvIHVzZSBhcyBtdWNoIHBpeGVscyBhcyBwb3NzaWJsZVxuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfbWlwbWFwX29mZnNldDogMFxuXHRcdH07XG5cdFx0dGhpcy5fbHVtaW5hbmNlID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnRpdGxlID0gXCJBdmVyYWdlXCI7XG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLmRlc2MgPVxuXHRcdFwiQ29tcHV0ZSBhIHBhcnRpYWwgYXZlcmFnZSAoMzIgcmFuZG9tIHNhbXBsZXMpIG9mIGEgdGV4dHVyZSBhbmQgc3RvcmVzIGl0IGFzIGEgMXgxIHBpeGVsIHRleHR1cmUuXFxuIElmIGhpZ2hfcXVhbGl0eSBpcyB0cnVlLCB0aGVuIGl0IGdlbmVyYXRlcyB0aGUgbWlwbWFwcyBmaXJzdCBhbmQgcmVhZHMgZnJvbSB0aGUgbG93ZXIgb25lLlwiO1xuXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMucHJvcGVydGllcy51c2VfcHJldmlvdXNfZnJhbWUpIHtcblx0XHRcdHRoaXMudXBkYXRlQXZlcmFnZSgpO1xuXHRcdH1cblxuXHRcdHZhciB2ID0gdGhpcy5fbHVtaW5hbmNlO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB2KTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMiwgKHZbMF0gKyB2WzFdICsgdlsyXSkgLyAzKTtcblx0fTtcblxuXHQvL2V4ZWN1dGVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIGZyYW1lXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnByb3RvdHlwZS5vblByZVJlbmRlckV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZUF2ZXJhZ2UoKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5wcm90b3R5cGUudXBkYXRlQXZlcmFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApICYmXG5cdFx0XHQhdGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSAmJlxuXHRcdFx0IXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMilcblx0XHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0XHQvL2NyZWF0ZXMgMjU2IHJhbmRvbSBudW1iZXJzIGFuZCBzdG9yZXMgdGhlbSBpbiB0d28gbWF0NFxuXHRcdFx0dmFyIHNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRzYW1wbGVzW2ldID0gTWF0aC5yYW5kb20oKTsgLy9wb29ybHkgZGlzdHJpYnV0ZWQgc2FtcGxlc1xuXHRcdFx0fVxuXHRcdFx0Ly91cGxvYWQgb25seSBvbmNlXG5cdFx0XHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyLnVuaWZvcm1zKHtcblx0XHRcdFx0dV9zYW1wbGVzX2E6IHNhbXBsZXMuc3ViYXJyYXkoMCwgMTYpLFxuXHRcdFx0XHR1X3NhbXBsZXNfYjogc2FtcGxlcy5zdWJhcnJheSgxNiwgMzIpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHR2YXIgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRleC50eXBlICE9IHR5cGUpIHtcblx0XHRcdC8vZm9yY2UgZmxvYXRzLCBoYWxmIGZsb2F0cyBjYW5ub3QgYmUgcmVhZCB3aXRoIGdsLnJlYWRQaXhlbHNcblx0XHRcdHR5cGUgPSBnbC5GTE9BVDtcblx0XHR9XG5cblx0XHRpZiAoIXRlbXAgfHwgdGVtcC50eXBlICE9IHR5cGUpIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKDEsIDEsIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuaWZvcm1zLnVfbWlwbWFwX29mZnNldCA9IDA7XG5cblx0XHRpZih0aGlzLnByb3BlcnRpZXMuaGlnaF9xdWFsaXR5KVxuXHRcdHtcblx0XHRcdGlmKCAhdGhpcy5fdGVtcF9wb3QyX3RleHR1cmUgfHwgdGhpcy5fdGVtcF9wb3QyX3RleHR1cmUudHlwZSAhPSB0eXBlIClcblx0XHRcdFx0dGhpcy5fdGVtcF9wb3QyX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSg1MTIsIDUxMiwge1xuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRcdG1pbkZpbHRlcjogZ2wuTElORUFSX01JUE1BUF9MSU5FQVIsXG5cdFx0XHRcdFx0bWFnRmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdFx0fSk7XG5cblx0XHRcdHRleC5jb3B5VG8oIHRoaXMuX3RlbXBfcG90Ml90ZXh0dXJlICk7XG5cdFx0XHR0ZXggPSB0aGlzLl90ZW1wX3BvdDJfdGV4dHVyZTtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoR0wuVEVYVFVSRV8yRCk7XG5cdFx0XHR0aGlzLl91bmlmb3Jtcy51X21pcG1hcF9vZmZzZXQgPSA5O1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyO1xuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfbWlwbWFwX29mZnNldCA9IHRoaXMucHJvcGVydGllcy5taXBtYXBfb2Zmc2V0O1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC50b1ZpZXdwb3J0KHNoYWRlciwgdW5pZm9ybXMpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkgfHwgdGhpcy5pc091dHB1dENvbm5lY3RlZCgyKSkge1xuXHRcdFx0dmFyIHBpeGVsID0gdGhpcy5fdGVtcF90ZXh0dXJlLmdldFBpeGVscygpO1xuXHRcdFx0aWYgKHBpeGVsKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy5fbHVtaW5hbmNlO1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3RlbXBfdGV4dHVyZS50eXBlO1xuXHRcdFx0XHR2LnNldChwaXhlbCk7XG5cdFx0XHRcdGlmICh0eXBlID09IGdsLlVOU0lHTkVEX0JZVEUpIHtcblx0XHRcdFx0XHR2ZWM0LnNjYWxlKHYsIHYsIDEgLyAyNTUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdHR5cGUgPT0gR0wuSEFMRl9GTE9BVCB8fFxuXHRcdFx0XHRcdHR5cGUgPT0gR0wuSEFMRl9GTE9BVF9PRVNcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly9ubyBoYWxmIGZsb2F0cyBwb3NzaWJsZSwgaGFyZCB0byByZWFkIGJhY2sgdW5sZXNzIGNvcHllZCB0byBhIEZMT0FUIHRleHR1cmUsIHNvIHRlbXBfdGV4dHVyZSBpcyBhbHdheXMgZm9yY2VkIHRvIEZMT0FUXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUF2ZXJhZ2UucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHVuaWZvcm0gbWF0NCB1X3NhbXBsZXNfYTtcXG5cXFxuXHRcdHVuaWZvcm0gbWF0NCB1X3NhbXBsZXNfYjtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9taXBtYXBfb2Zmc2V0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXFxuXHRcdFx0Ly9yYW5kb20gYXZlcmFnZVxcblxcXG5cdFx0XHRmb3IoaW50IGkgPSAwOyBpIDwgNDsgKytpKVxcblxcXG5cdFx0XHRcdGZvcihpbnQgaiA9IDA7IGogPCA0OyArK2opXFxuXFxcblx0XHRcdFx0e1xcblxcXG5cdFx0XHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdmVjMiggdV9zYW1wbGVzX2FbaV1bal0sIHVfc2FtcGxlc19iW2ldW2pdICksIHVfbWlwbWFwX29mZnNldCApO1xcblxcXG5cdFx0XHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdmVjMiggMS4wIC0gdV9zYW1wbGVzX2FbaV1bal0sIDEuMCAtIHVfc2FtcGxlc19iW2ldW2pdICksIHVfbWlwbWFwX29mZnNldCApO1xcblxcXG5cdFx0XHRcdH1cXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogMC4wMzEyNTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9hdmVyYWdlXCIsIExHcmFwaFRleHR1cmVBdmVyYWdlKTtcblxuXG5cblx0Ly8gQ29tcHV0ZXMgb3BlcmF0aW9uIGJldHdlZW4gcGl4ZWxzIChtYXgsIG1pbikgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVNaW5NYXgoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWluX3RcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWF4X3RcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWluXCIsIFwidmVjNFwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm1heFwiLCBcInZlYzRcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0bW9kZTogXCJtYXhcIixcblx0XHRcdHVzZV9wcmV2aW91c19mcmFtZTogdHJ1ZSAvL3RvIGF2b2lkIHN0YWxscyBcblx0XHR9O1xuXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmU6IDBcblx0XHR9O1xuXG5cdFx0dGhpcy5fbWF4ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblx0XHR0aGlzLl9taW4gPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG5cdFx0dGhpcy5fdGV4dHVyZXNfY2hhaW4gPSBbXTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVNaW5NYXgud2lkZ2V0c19pbmZvID0ge1xuXHRcdG1vZGU6IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogW1wibWluXCIsXCJtYXhcIixcImF2Z1wiXSB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC50aXRsZSA9IFwiTWluTWF4XCI7XG5cdExHcmFwaFRleHR1cmVNaW5NYXguZGVzYyA9IFwiQ29tcHV0ZSB0aGUgc2NlbmUgbWluIG1heFwiO1xuXG5cdExHcmFwaFRleHR1cmVNaW5NYXgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5wcm9wZXJ0aWVzLnVzZV9wcmV2aW91c19mcmFtZSkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fbHVtaW5hbmNlKTtcblx0fTtcblxuXHQvL2V4ZWN1dGVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIGZyYW1lXG5cdExHcmFwaFRleHR1cmVNaW5NYXgucHJvdG90eXBlLm9uUHJlUmVuZGVyRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSAmJiAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlTWluTWF4Ll9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVNaW5NYXguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZU1pbk1heC5waXhlbF9zaGFkZXIgKTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHR2YXIgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRleC50eXBlICE9IHR5cGUpIHtcblx0XHRcdC8vZm9yY2UgZmxvYXRzLCBoYWxmIGZsb2F0cyBjYW5ub3QgYmUgcmVhZCB3aXRoIGdsLnJlYWRQaXhlbHNcblx0XHRcdHR5cGUgPSBnbC5GTE9BVDtcblx0XHR9XG5cblx0XHR2YXIgc2l6ZSA9IDUxMjtcblxuXHRcdGlmKCAhdGhpcy5fdGV4dHVyZXNfY2hhaW4ubGVuZ3RoIHx8IHRoaXMuX3RleHR1cmVzX2NoYWluWzBdLnR5cGUgIT0gdHlwZSApXG5cdFx0e1xuXHRcdFx0dmFyIGluZGV4ID0gMDtcblx0XHRcdHdoaWxlKGkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3RleHR1cmVzX2NoYWluW2ldID0gbmV3IEdMLlRleHR1cmUoIHNpemUsIHNpemUsIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0XHRmaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNpemUgPSBzaXplID4+IDI7XG5cdFx0XHRcdGkrKztcblx0XHRcdFx0aWYoc2l6ZSA9PSAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleC5jb3B5VG8oIHRoaXMuX3RleHR1cmVzX2NoYWluWzBdICk7XG5cdFx0dmFyIHByZXYgPSB0aGlzLl90ZXh0dXJlc19jaGFpblswXTtcblx0XHRmb3IodmFyIGkgPSAxOyBpIDw9IHRoaXMuX3RleHR1cmVzX2NoYWluLmxlbmd0aDsgKytpKVxuXHRcdHtcblx0XHRcdHZhciB0ZXggPSB0aGlzLl90ZXh0dXJlc19jaGFpbltpXTtcblxuXHRcdFx0cHJldiA9IHRleDtcdFx0XHRcdFxuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWluTWF4Ll9zaGFkZXI7XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9taXBtYXBfb2Zmc2V0ID0gdGhpcy5wcm9wZXJ0aWVzLm1pcG1hcF9vZmZzZXQ7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoc2hhZGVyLCB1bmlmb3Jtcyk7XG5cdFx0fSk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBtYXQ0IHVfc2FtcGxlc19hO1xcblxcXG5cdFx0dW5pZm9ybSBtYXQ0IHVfc2FtcGxlc19iO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X21pcG1hcF9vZmZzZXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcXG5cdFx0XHQvL3JhbmRvbSBhdmVyYWdlXFxuXFxcblx0XHRcdGZvcihpbnQgaSA9IDA7IGkgPCA0OyArK2kpXFxuXFxcblx0XHRcdFx0Zm9yKGludCBqID0gMDsgaiA8IDQ7ICsrailcXG5cXFxuXHRcdFx0XHR7XFxuXFxcblx0XHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2ZWMyKCB1X3NhbXBsZXNfYVtpXVtqXSwgdV9zYW1wbGVzX2JbaV1bal0gKSwgdV9taXBtYXBfb2Zmc2V0ICk7XFxuXFxcblx0XHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2ZWMyKCAxLjAgLSB1X3NhbXBsZXNfYVtpXVtqXSwgMS4wIC0gdV9zYW1wbGVzX2JbaV1bal0gKSwgdV9taXBtYXBfb2Zmc2V0ICk7XFxuXFxcblx0XHRcdFx0fVxcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiAwLjAzMTI1O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0Ly9MaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY2x1c3RlcmVkX29wZXJhdGlvblwiLCBMR3JhcGhUZXh0dXJlQ2x1c3RlcmVkT3BlcmF0aW9uKTtcblxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJmYWN0b3JcIiwgXCJOdW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZmFjdG9yOiAwLjUgfTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfdGV4dHVyZUI6IDEsXG5cdFx0XHR1X2ZhY3RvcjogdGhpcy5wcm9wZXJ0aWVzLmZhY3RvclxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGgudGl0bGUgPSBcIlNtb290aFwiO1xuXHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGguZGVzYyA9IFwiU21vb3RoIHRleHR1cmUgb3ZlciB0aW1lXCI7XG5cblx0TEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRpZiAoXG5cdFx0XHQhdGVtcCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodFxuXHRcdCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdFx0fTtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwgb3B0aW9ucyApO1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlMiA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwgb3B0aW9ucyApO1xuXHRcdFx0dGV4LmNvcHlUbyh0aGlzLl90ZW1wX3RleHR1cmUyKTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcEEgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0dmFyIHRlbXBCID0gdGhpcy5fdGVtcF90ZXh0dXJlMjtcblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGguX3NoYWRlcjtcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X2ZhY3RvciA9IDEuMCAtIHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZmFjdG9yXCIpO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR0ZW1wQS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZW1wQi5iaW5kKDEpO1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoc2hhZGVyLCB1bmlmb3Jtcyk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcEEpO1xuXG5cdFx0Ly9zd2FwXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gdGVtcEI7XG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlMiA9IHRlbXBBO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mYWN0b3I7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBtaXgoIHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICksIHRleHR1cmUyRCggdV90ZXh0dXJlQiwgdl9jb29yZCApLCB1X2ZhY3RvciApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS90ZW1wb3JhbF9zbW9vdGhcIiwgTEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoICk7XG5cblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJhdmdcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiYXJyYXlcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgc2FtcGxlczogNjQsIGZyYW1lc19pbnRlcnZhbDogMSB9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV90ZXh0dXJlQjogMSxcblx0XHRcdHVfc2FtcGxlczogdGhpcy5wcm9wZXJ0aWVzLnNhbXBsZXMsXG5cdFx0XHR1X2lzYW1wbGVzOiAxL3RoaXMucHJvcGVydGllcy5zYW1wbGVzXG5cdFx0fTtcblx0XHR0aGlzLmZyYW1lID0gMDtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgudGl0bGUgPSBcIkxpbmVhbCBBdmcgU21vb3RoXCI7XG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGguZGVzYyA9IFwiU21vb3RoIHRleHR1cmUgbGluZWFybHkgb3ZlciB0aW1lXCI7XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aFtcIkBzYW1wbGVzXCJdID0geyB0eXBlOiBcIm51bWJlclwiLCBtaW46IDEsIG1heDogNjQsIHN0ZXA6IDEsIHByZWNpc2lvbjogMSB9O1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgucHJvdG90eXBlLmdldFByZXZpZXdUZXh0dXJlID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3RlbXBfdGV4dHVyZTI7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLl9zaGFkZXJfY29weSA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5waXhlbF9zaGFkZXJfY29weSApO1xuXHRcdFx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5fc2hhZGVyX2F2ZyA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5waXhlbF9zaGFkZXJfYXZnICk7XG5cdFx0fVxuXG5cdFx0dmFyIHNhbXBsZXMgPSBNYXRoLmNsYW1wKHRoaXMucHJvcGVydGllcy5zYW1wbGVzLDAsNjQpO1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuZnJhbWU7XG5cdFx0dmFyIGludGVydmFsID0gdGhpcy5wcm9wZXJ0aWVzLmZyYW1lc19pbnRlcnZhbDtcblxuXHRcdGlmKCBpbnRlcnZhbCA9PSAwIHx8IGZyYW1lICUgaW50ZXJ2YWwgPT0gMCApXG5cdFx0e1xuXHRcdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0XHRpZiAoICF0ZW1wIHx8IHRlbXAudHlwZSAhPSB0ZXgudHlwZSB8fCB0ZW1wLndpZHRoICE9IHNhbXBsZXMgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zID0ge1xuXHRcdFx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0XHRmaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHNhbXBsZXMsIDEsIG9wdGlvbnMgKTtcblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlMiA9IG5ldyBHTC5UZXh0dXJlKCBzYW1wbGVzLCAxLCBvcHRpb25zICk7XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZV9vdXQgPSBuZXcgR0wuVGV4dHVyZSggMSwgMSwgb3B0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGVtcEEgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0XHR2YXIgdGVtcEIgPSB0aGlzLl90ZW1wX3RleHR1cmUyO1xuXG5cdFx0XHR2YXIgc2hhZGVyX2NvcHkgPSBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLl9zaGFkZXJfY29weTtcblx0XHRcdHZhciBzaGFkZXJfYXZnID0gTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5fc2hhZGVyX2F2Zztcblx0XHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdFx0dW5pZm9ybXMudV9zYW1wbGVzID0gc2FtcGxlcztcblx0XHRcdHVuaWZvcm1zLnVfaXNhbXBsZXMgPSAxLjAgLyBzYW1wbGVzO1xuXG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHR0ZW1wQS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRlbXBCLmJpbmQoMSk7XG5cdFx0XHRcdHRleC50b1ZpZXdwb3J0KCBzaGFkZXJfY29weSwgdW5pZm9ybXMgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmVfb3V0LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0dGVtcEEudG9WaWV3cG9ydCggc2hhZGVyX2F2ZywgdW5pZm9ybXMgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMuX3RlbXBfdGV4dHVyZV9vdXQgKTtcblxuXHRcdFx0Ly9zd2FwXG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSB0ZW1wQjtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZTIgPSB0ZW1wQTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZV9vdXQpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLl90ZW1wX3RleHR1cmUyKTtcblx0XHR0aGlzLmZyYW1lKys7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5waXhlbF9zaGFkZXJfY29weSA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2lzYW1wbGVzO1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0aWYoIHZfY29vcmQueCA8PSB1X2lzYW1wbGVzIClcXG5cXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdmVjMigwLjUpICk7XFxuXFxcblx0XHRcdGVsc2VcXG5cXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZUIsIHZfY29vcmQgLSB2ZWMyKHVfaXNhbXBsZXMsMC4wKSApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5waXhlbF9zaGFkZXJfYXZnID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gaW50IHVfc2FtcGxlcztcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9pc2FtcGxlcztcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxcblx0XHRcdGZvcihpbnQgaSA9IDA7IGkgPCA2NDsgKytpKVxcblxcXG5cdFx0XHR7XFxuXFxcblx0XHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZlYzIoIGZsb2F0KGkpKnVfaXNhbXBsZXMsMC4wKSApO1xcblxcXG5cdFx0XHRcdGlmKGkgPT0gKHVfc2FtcGxlcyAtIDEpKVxcblxcXG5cdFx0XHRcdFx0YnJlYWs7XFxuXFxcblx0XHRcdH1cXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3IgKiB1X2lzYW1wbGVzO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL2xpbmVhcl9hdmdfc21vb3RoXCIsIExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGggKTtcblxuXHQvLyBJbWFnZSBUbyBUZXh0dXJlICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaEltYWdlVG9UZXh0dXJlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJJbWFnZVwiLCBcImltYWdlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7fTtcblx0fVxuXG5cdExHcmFwaEltYWdlVG9UZXh0dXJlLnRpdGxlID0gXCJJbWFnZSB0byBUZXh0dXJlXCI7XG5cdExHcmFwaEltYWdlVG9UZXh0dXJlLmRlc2MgPSBcIlVwbG9hZHMgYW4gaW1hZ2UgdG8gdGhlIEdQVVwiO1xuXHQvL0xHcmFwaEltYWdlVG9UZXh0dXJlLndpZGdldHNfaW5mbyA9IHsgc2l6ZTogeyB3aWRnZXQ6XCJjb21ib1wiLCB2YWx1ZXM6WzAsMzIsNjQsMTI4LDI1Niw1MTIsMTAyNCwyMDQ4XX0gfTtcblxuXHRMR3JhcGhJbWFnZVRvVGV4dHVyZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltZyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghaW1nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHdpZHRoID0gaW1nLnZpZGVvV2lkdGggfHwgaW1nLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBpbWcudmlkZW9IZWlnaHQgfHwgaW1nLmhlaWdodDtcblxuXHRcdC8vdGhpcyBpcyBpbiBjYXNlIHdlIGFyZSB1c2luZyBhIHdlYmdsIGNhbnZhcyBhbHJlYWR5LCBubyBuZWVkIHRvIHJldXBsb2FkIGl0XG5cdFx0aWYgKGltZy5nbHRleHR1cmUpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBpbWcuZ2x0ZXh0dXJlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRpZiAoIXRlbXAgfHwgdGVtcC53aWR0aCAhPSB3aWR0aCB8fCB0ZW1wLmhlaWdodCAhPSBoZWlnaHQpIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS51cGxvYWRJbWFnZShpbWcpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XCJpbWFnZSBjb21lcyBmcm9tIGFuIHVuc2FmZSBsb2NhdGlvbiwgY2Fubm90IGJlIHVwbG9hZGVkIHRvIHdlYmdsOiBcIiArXG5cdFx0XHRcdFx0ZXJyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxuXHRcdFwidGV4dHVyZS9pbWFnZVRvVGV4dHVyZVwiLFxuXHRcdExHcmFwaEltYWdlVG9UZXh0dXJlXG5cdCk7XG5cblx0Ly8gVGV4dHVyZSBMVVQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUxVVCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkxVVFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkludGVuc2l0eVwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBlbmFibGVkOiB0cnVlLCBpbnRlbnNpdHk6IDEsIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxULCB0ZXh0dXJlOiBudWxsIH07XG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVMVVQuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUxVVC5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlTFVULnBpeGVsX3NoYWRlciApO1xuXHRcdH1cblx0fVxuXG5cdExHcmFwaFRleHR1cmVMVVQud2lkZ2V0c19pbmZvID0ge1xuXHRcdHRleHR1cmU6IHsgd2lkZ2V0OiBcInRleHR1cmVcIiB9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTFVULnRpdGxlID0gXCJMVVRcIjtcblx0TEdyYXBoVGV4dHVyZUxVVC5kZXNjID0gXCJBcHBseSBMVVQgdG8gVGV4dHVyZVwiO1xuXG5cdExHcmFwaFRleHR1cmVMVVQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0ggfHwgdGhpcy5wcm9wZXJ0aWVzLmVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsdXRfdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cblx0XHRpZiAoIWx1dF90ZXgpIHtcblx0XHRcdGx1dF90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmUodGhpcy5wcm9wZXJ0aWVzLnRleHR1cmUpO1xuXHRcdH1cblxuXHRcdGlmICghbHV0X3RleCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bHV0X3RleC5iaW5kKDApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoXG5cdFx0XHRnbC5URVhUVVJFXzJELFxuXHRcdFx0Z2wuVEVYVFVSRV9XUkFQX1MsXG5cdFx0XHRnbC5DTEFNUF9UT19FREdFXG5cdFx0KTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKFxuXHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdGdsLlRFWFRVUkVfV1JBUF9ULFxuXHRcdFx0Z2wuQ0xBTVBfVE9fRURHRVxuXHRcdCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHR2YXIgaW50ZW5zaXR5ID0gdGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eTtcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDIpKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxuXHRcdFx0dGV4LFxuXHRcdFx0dGhpcy5fdGV4LFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxuXHRcdCk7XG5cblx0XHQvL3ZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0bHV0X3RleC5iaW5kKDEpO1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoTEdyYXBoVGV4dHVyZUxVVC5fc2hhZGVyLCB7XG5cdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0dV90ZXh0dXJlQjogMSxcblx0XHRcdFx0dV9hbW91bnQ6IGludGVuc2l0eVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTFVULnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfYW1vdW50O1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdCBsb3dwIHZlYzQgdGV4dHVyZUNvbG9yID0gY2xhbXAoIHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSApO1xcblxcXG5cdFx0XHQgbWVkaXVtcCBmbG9hdCBibHVlQ29sb3IgPSB0ZXh0dXJlQ29sb3IuYiAqIDYzLjA7XFxuXFxcblx0XHRcdCBtZWRpdW1wIHZlYzIgcXVhZDE7XFxuXFxcblx0XHRcdCBxdWFkMS55ID0gZmxvb3IoZmxvb3IoYmx1ZUNvbG9yKSAvIDguMCk7XFxuXFxcblx0XHRcdCBxdWFkMS54ID0gZmxvb3IoYmx1ZUNvbG9yKSAtIChxdWFkMS55ICogOC4wKTtcXG5cXFxuXHRcdFx0IG1lZGl1bXAgdmVjMiBxdWFkMjtcXG5cXFxuXHRcdFx0IHF1YWQyLnkgPSBmbG9vcihjZWlsKGJsdWVDb2xvcikgLyA4LjApO1xcblxcXG5cdFx0XHQgcXVhZDIueCA9IGNlaWwoYmx1ZUNvbG9yKSAtIChxdWFkMi55ICogOC4wKTtcXG5cXFxuXHRcdFx0IGhpZ2hwIHZlYzIgdGV4UG9zMTtcXG5cXFxuXHRcdFx0IHRleFBvczEueCA9IChxdWFkMS54ICogMC4xMjUpICsgMC41LzUxMi4wICsgKCgwLjEyNSAtIDEuMC81MTIuMCkgKiB0ZXh0dXJlQ29sb3Iucik7XFxuXFxcblx0XHRcdCB0ZXhQb3MxLnkgPSAxLjAgLSAoKHF1YWQxLnkgKiAwLjEyNSkgKyAwLjUvNTEyLjAgKyAoKDAuMTI1IC0gMS4wLzUxMi4wKSAqIHRleHR1cmVDb2xvci5nKSk7XFxuXFxcblx0XHRcdCBoaWdocCB2ZWMyIHRleFBvczI7XFxuXFxcblx0XHRcdCB0ZXhQb3MyLnggPSAocXVhZDIueCAqIDAuMTI1KSArIDAuNS81MTIuMCArICgoMC4xMjUgLSAxLjAvNTEyLjApICogdGV4dHVyZUNvbG9yLnIpO1xcblxcXG5cdFx0XHQgdGV4UG9zMi55ID0gMS4wIC0gKChxdWFkMi55ICogMC4xMjUpICsgMC41LzUxMi4wICsgKCgwLjEyNSAtIDEuMC81MTIuMCkgKiB0ZXh0dXJlQ29sb3IuZykpO1xcblxcXG5cdFx0XHQgbG93cCB2ZWM0IG5ld0NvbG9yMSA9IHRleHR1cmUyRCh1X3RleHR1cmVCLCB0ZXhQb3MxKTtcXG5cXFxuXHRcdFx0IGxvd3AgdmVjNCBuZXdDb2xvcjIgPSB0ZXh0dXJlMkQodV90ZXh0dXJlQiwgdGV4UG9zMik7XFxuXFxcblx0XHRcdCBsb3dwIHZlYzQgbmV3Q29sb3IgPSBtaXgobmV3Q29sb3IxLCBuZXdDb2xvcjIsIGZyYWN0KGJsdWVDb2xvcikpO1xcblxcXG5cdFx0XHQgZ2xfRnJhZ0NvbG9yID0gdmVjNCggbWl4KCB0ZXh0dXJlQ29sb3IucmdiLCBuZXdDb2xvci5yZ2IsIHVfYW1vdW50KSwgdGV4dHVyZUNvbG9yLncpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL0xVVFwiLCBMR3JhcGhUZXh0dXJlTFVUKTtcblxuXG5cdC8vIFRleHR1cmUgTFVUICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVFbmNvZGUoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJBdGxhc1wiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZW5hYmxlZDogdHJ1ZSwgbnVtX3Jvd19zeW1ib2xzOiA0LCBzeW1ib2xfc2l6ZTogMTYsIGJyaWdodG5lc3M6IDEsIGNvbG9yaXplOiBmYWxzZSwgZmlsdGVyOiBmYWxzZSwgaW52ZXJ0OiBmYWxzZSwgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQsIGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlLCB0ZXh0dXJlOiBudWxsIH07XG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVFbmNvZGUuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUVuY29kZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlRW5jb2RlLnBpeGVsX3NoYWRlciApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHRcdHVfdGV4dHVyZUI6IDEsXG5cdFx0XHRcdHVfcm93X3NpbWJvbHM6IDQsXG5cdFx0XHRcdHVfc2ltYm9sX3NpemU6IDE2LFxuXHRcdFx0XHR1X3JlczogdmVjMi5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlRW5jb2RlLndpZGdldHNfaW5mbyA9IHtcblx0XHR0ZXh0dXJlOiB7IHdpZGdldDogXCJ0ZXh0dXJlXCIgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUVuY29kZS50aXRsZSA9IFwiRW5jb2RlXCI7XG5cdExHcmFwaFRleHR1cmVFbmNvZGUuZGVzYyA9IFwiQXBwbHkgYSB0ZXh0dXJlIGF0bGFzIHRvIGVuY29kZSBhIHRleHR1cmVcIjtcblxuXHRMR3JhcGhUZXh0dXJlRW5jb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIIHx8IHRoaXMucHJvcGVydGllcy5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc3ltYm9sc190ZXggPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblxuXHRcdGlmICghc3ltYm9sc190ZXgpIHtcblx0XHRcdHN5bWJvbHNfdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlKHRoaXMucHJvcGVydGllcy50ZXh0dXJlKTtcblx0XHR9XG5cblx0XHRpZiAoIXN5bWJvbHNfdGV4KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzeW1ib2xzX3RleC5iaW5kKDApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLnByb3BlcnRpZXMuZmlsdGVyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLnByb3BlcnRpZXMuZmlsdGVyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X3Jvd19zaW1ib2xzID0gTWF0aC5mbG9vcih0aGlzLnByb3BlcnRpZXMubnVtX3Jvd19zeW1ib2xzKTtcblx0XHR1bmlmb3Jtcy51X3N5bWJvbF9zaXplID0gdGhpcy5wcm9wZXJ0aWVzLnN5bWJvbF9zaXplO1xuXHRcdHVuaWZvcm1zLnVfYnJpZ2h0bmVzcyA9IHRoaXMucHJvcGVydGllcy5icmlnaHRuZXNzO1xuXHRcdHVuaWZvcm1zLnVfaW52ZXJ0ID0gdGhpcy5wcm9wZXJ0aWVzLmludmVydCA/IDEgOiAwO1xuXHRcdHVuaWZvcm1zLnVfY29sb3JpemUgPSB0aGlzLnByb3BlcnRpZXMuY29sb3JpemUgPyAxIDogMDtcblxuXHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZSggdGV4LCB0aGlzLl90ZXgsIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gKTtcblx0XHR1bmlmb3Jtcy51X3Jlc1swXSA9IHRoaXMuX3RleC53aWR0aDtcblx0XHR1bmlmb3Jtcy51X3Jlc1sxXSA9IHRoaXMuX3RleC5oZWlnaHQ7XG5cdFx0dGhpcy5fdGV4LmJpbmQoMCk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHN5bWJvbHNfdGV4LmJpbmQoMSk7XG5cdFx0XHR0ZXgudG9WaWV3cG9ydChMR3JhcGhUZXh0dXJlRW5jb2RlLl9zaGFkZXIsIHVuaWZvcm1zKTtcblx0XHR9KTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbWlwbWFwcykge1xuXHRcdFx0dGhpcy5fdGV4LmJpbmQoMCk7XG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLl90ZXgudGV4dHVyZV90eXBlKTtcblx0XHRcdHRoaXMuX3RleC51bmJpbmQoMCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUVuY29kZS5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3Jvd19zaW1ib2xzO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3N5bWJvbF9zaXplO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3M7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaW52ZXJ0O1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2NvbG9yaXplO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfcmVzO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzIgdG90YWxfc3ltYm9scyA9IHVfcmVzIC8gdV9zeW1ib2xfc2l6ZTtcXG5cXFxuXHRcdFx0dmVjMiB1diA9IGZsb29yKHZfY29vcmQgKiB0b3RhbF9zeW1ib2xzKSAvIHRvdGFsX3N5bWJvbHM7IC8vcGl4ZWxhdGUgXFxuXFxcblx0XHRcdHZlYzIgbG9jYWxfdXYgPSBtb2Qodl9jb29yZCAqIHVfcmVzLCB1X3N5bWJvbF9zaXplKSAvIHVfc3ltYm9sX3NpemU7XFxuXFxcblx0XHRcdGxvd3AgdmVjNCB0ZXh0dXJlQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diApO1xcblxcXG5cdFx0XHRmbG9hdCBsdW0gPSBjbGFtcCh1X2JyaWdodG5lc3MgKiAodGV4dHVyZUNvbG9yLnggKyB0ZXh0dXJlQ29sb3IueSArIHRleHR1cmVDb2xvci56KS8zLjAsMC4wLDEuMCk7XFxuXFxcblx0XHRcdGlmKCB1X2ludmVydCA9PSAxLjAgKSBsdW0gPSAxLjAgLSBsdW07XFxuXFxcblx0XHRcdGZsb2F0IGluZGV4ID0gZmxvb3IoIGx1bSAqICh1X3Jvd19zaW1ib2xzICogdV9yb3dfc2ltYm9scyAtIDEuMCkpO1xcblxcXG5cdFx0XHRmbG9hdCBjb2wgPSBtb2QoIGluZGV4LCB1X3Jvd19zaW1ib2xzICk7XFxuXFxcblx0XHRcdGZsb2F0IHJvdyA9IHVfcm93X3NpbWJvbHMgLSBmbG9vciggaW5kZXggLyB1X3Jvd19zaW1ib2xzICkgLSAxLjA7XFxuXFxcblx0XHRcdHZlYzIgc2ltYm9sX3V2ID0gKCB2ZWMyKCBjb2wsIHJvdyApICsgbG9jYWxfdXYgKSAvIHVfcm93X3NpbWJvbHM7XFxuXFxcblx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZUIsIHNpbWJvbF91diApO1xcblxcXG5cdFx0XHRpZih1X2NvbG9yaXplID09IDEuMClcXG5cXFxuXHRcdFx0XHRjb2xvciAqPSB0ZXh0dXJlQ29sb3I7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2VuY29kZVwiLCBMR3JhcGhUZXh0dXJlRW5jb2RlKTtcblxuXHQvLyBUZXh0dXJlIENoYW5uZWxzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVDaGFubmVscygpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLmFkZE91dHB1dChcIlJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiR1wiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJCXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIkFcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0Ly90aGlzLnByb3BlcnRpZXMgPSB7IHVzZV9zaW5nbGVfY2hhbm5lbDogdHJ1ZSB9O1xuXHRcdGlmICghTEdyYXBoVGV4dHVyZUNoYW5uZWxzLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVDaGFubmVscy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHMucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdExHcmFwaFRleHR1cmVDaGFubmVscy50aXRsZSA9IFwiVGV4dHVyZSB0byBDaGFubmVsc1wiO1xuXHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHMuZGVzYyA9IFwiU3BsaXQgdGV4dHVyZSBjaGFubmVsc1wiO1xuXG5cdExHcmFwaFRleHR1cmVDaGFubmVscy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleEEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX2NoYW5uZWxzKSB7XG5cdFx0XHR0aGlzLl9jaGFubmVscyA9IEFycmF5KDQpO1xuXHRcdH1cblxuXHRcdC8vdmFyIGZvcm1hdCA9IHRoaXMucHJvcGVydGllcy51c2Vfc2luZ2xlX2NoYW5uZWwgPyBnbC5MVU1JTkFOQ0UgOiBnbC5SR0JBOyAvL25vdCBzdXBwb3J0ZWQgYnkgV2ViR0wxXG5cdFx0dmFyIGZvcm1hdCA9IGdsLlJHQjtcblx0XHR2YXIgY29ubmVjdGlvbnMgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZChpKSkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IXRoaXMuX2NoYW5uZWxzW2ldIHx8XG5cdFx0XHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0ud2lkdGggIT0gdGV4QS53aWR0aCB8fFxuXHRcdFx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldLmhlaWdodCAhPSB0ZXhBLmhlaWdodCB8fFxuXHRcdFx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldLnR5cGUgIT0gdGV4QS50eXBlIHx8XG5cdFx0XHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0uZm9ybWF0ICE9IGZvcm1hdFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0aGlzLl9jaGFubmVsc1tpXSA9IG5ldyBHTC5UZXh0dXJlKFxuXHRcdFx0XHRcdFx0dGV4QS53aWR0aCxcblx0XHRcdFx0XHRcdHRleEEuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR0eXBlOiB0ZXhBLnR5cGUsXG5cdFx0XHRcdFx0XHRcdGZvcm1hdDogZm9ybWF0LFxuXHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29ubmVjdGlvbnMrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWNvbm5lY3Rpb25zKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVDaGFubmVscy5fc2hhZGVyO1xuXHRcdHZhciBtYXNrcyA9IFtcblx0XHRcdFsxLCAwLCAwLCAwXSxcblx0XHRcdFswLCAxLCAwLCAwXSxcblx0XHRcdFswLCAwLCAxLCAwXSxcblx0XHRcdFswLCAwLCAwLCAxXVxuXHRcdF07XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0aWYgKCF0aGlzLl9jaGFubmVsc1tpXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0uZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0ZXhBLmJpbmQoMCk7XG5cdFx0XHRcdHNoYWRlclxuXHRcdFx0XHRcdC51bmlmb3Jtcyh7IHVfdGV4dHVyZTogMCwgdV9tYXNrOiBtYXNrc1tpXSB9KVxuXHRcdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fY2hhbm5lbHNbaV0pO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHMucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWM0IHVfbWFzaztcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggbGVuZ3RoKCB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKSAqIHVfbWFzayApKSwgMS4wICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUvdGV4dHVyZUNoYW5uZWxzXCIsXG5cdFx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzXG5cdCk7XG5cblx0Ly8gVGV4dHVyZSBDaGFubmVscyB0byBUZXh0dXJlICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaENoYW5uZWxzVGV4dHVyZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiUlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkdcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiQVwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQsXG5cdFx0XHRSOiAxLFxuXHRcdFx0RzogMSxcblx0XHRcdEI6IDEsXG5cdFx0XHRBOiAxXG5cdFx0fTtcblx0XHR0aGlzLl9jb2xvciA9IHZlYzQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmVSOiAwLFxuXHRcdFx0dV90ZXh0dXJlRzogMSxcblx0XHRcdHVfdGV4dHVyZUI6IDIsXG5cdFx0XHR1X3RleHR1cmVBOiAzLFxuXHRcdFx0dV9jb2xvcjogdGhpcy5fY29sb3Jcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLnRpdGxlID0gXCJDaGFubmVscyB0byBUZXh0dXJlXCI7XG5cdExHcmFwaENoYW5uZWxzVGV4dHVyZS5kZXNjID0gXCJTcGxpdCB0ZXh0dXJlIGNoYW5uZWxzXCI7XG5cdExHcmFwaENoYW5uZWxzVGV4dHVyZS53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaENoYW5uZWxzVGV4dHVyZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHdoaXRlID0gTEdyYXBoVGV4dHVyZS5nZXRXaGl0ZVRleHR1cmUoKTtcblx0XHR2YXIgdGV4UiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApIHx8IHdoaXRlO1xuXHRcdHZhciB0ZXhHID0gdGhpcy5nZXRJbnB1dERhdGEoMSkgfHwgd2hpdGU7XG5cdFx0dmFyIHRleEIgPSB0aGlzLmdldElucHV0RGF0YSgyKSB8fCB3aGl0ZTtcblx0XHR2YXIgdGV4QSA9IHRoaXMuZ2V0SW5wdXREYXRhKDMpIHx8IHdoaXRlO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0aWYgKCFMR3JhcGhDaGFubmVsc1RleHR1cmUuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaENoYW5uZWxzVGV4dHVyZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhDaGFubmVsc1RleHR1cmUuX3NoYWRlcjtcblxuXHRcdHZhciB3ID0gTWF0aC5tYXgodGV4Ui53aWR0aCwgdGV4Ry53aWR0aCwgdGV4Qi53aWR0aCwgdGV4QS53aWR0aCk7XG5cdFx0dmFyIGggPSBNYXRoLm1heChcblx0XHRcdHRleFIuaGVpZ2h0LFxuXHRcdFx0dGV4Ry5oZWlnaHQsXG5cdFx0XHR0ZXhCLmhlaWdodCxcblx0XHRcdHRleEEuaGVpZ2h0XG5cdFx0KTtcblx0XHR2YXIgdHlwZSA9XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09IExHcmFwaFRleHR1cmUuSElHSFxuXHRcdFx0XHQ/IExHcmFwaFRleHR1cmUuSElHSF9QUkVDSVNJT05fRk9STUFUXG5cdFx0XHRcdDogZ2wuVU5TSUdORURfQllURTtcblxuXHRcdGlmIChcblx0XHRcdCF0aGlzLl90ZXh0dXJlIHx8XG5cdFx0XHR0aGlzLl90ZXh0dXJlLndpZHRoICE9IHcgfHxcblx0XHRcdHRoaXMuX3RleHR1cmUuaGVpZ2h0ICE9IGggfHxcblx0XHRcdHRoaXMuX3RleHR1cmUudHlwZSAhPSB0eXBlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLl90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodywgaCwge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgY29sb3IgPSB0aGlzLl9jb2xvcjtcblx0XHRjb2xvclswXSA9IHRoaXMucHJvcGVydGllcy5SO1xuXHRcdGNvbG9yWzFdID0gdGhpcy5wcm9wZXJ0aWVzLkc7XG5cdFx0Y29sb3JbMl0gPSB0aGlzLnByb3BlcnRpZXMuQjtcblx0XHRjb2xvclszXSA9IHRoaXMucHJvcGVydGllcy5BO1xuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXG5cdFx0dGhpcy5fdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXhSLmJpbmQoMCk7XG5cdFx0XHR0ZXhHLmJpbmQoMSk7XG5cdFx0XHR0ZXhCLmJpbmQoMik7XG5cdFx0XHR0ZXhBLmJpbmQoMyk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleHR1cmUpO1xuXHR9O1xuXG5cdExHcmFwaENoYW5uZWxzVGV4dHVyZS5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVSO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlRztcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVBO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiB2ZWM0KCBcXFxuXHRcdFx0XHRcdHRleHR1cmUyRCh1X3RleHR1cmVSLCB2X2Nvb3JkKS5yLFxcXG5cdFx0XHRcdFx0dGV4dHVyZTJEKHVfdGV4dHVyZUcsIHZfY29vcmQpLnIsXFxcblx0XHRcdFx0XHR0ZXh0dXJlMkQodV90ZXh0dXJlQiwgdl9jb29yZCkucixcXFxuXHRcdFx0XHRcdHRleHR1cmUyRCh1X3RleHR1cmVBLCB2X2Nvb3JkKS5yKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxuXHRcdFwidGV4dHVyZS9jaGFubmVsc1RleHR1cmVcIixcblx0XHRMR3JhcGhDaGFubmVsc1RleHR1cmVcblx0KTtcblxuXHQvLyBUZXh0dXJlIENvbG9yICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVDb2xvcigpIHtcblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5fdGV4X2NvbG9yID0gdmVjNC5jcmVhdGUoKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRjb2xvcjogdmVjNC5jcmVhdGUoKSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDb2xvci50aXRsZSA9IFwiQ29sb3JcIjtcblx0TEdyYXBoVGV4dHVyZUNvbG9yLmRlc2MgPVxuXHRcdFwiR2VuZXJhdGVzIGEgMXgxIHRleHR1cmUgd2l0aCBhIGNvbnN0YW50IGNvbG9yXCI7XG5cblx0TEdyYXBoVGV4dHVyZUNvbG9yLndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNvbG9yLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIGMgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9XG5cdFx0XHRcInJnYihcIiArXG5cdFx0XHRNYXRoLmZsb29yKE1hdGguY2xhbXAoY1swXSwgMCwgMSkgKiAyNTUpICtcblx0XHRcdFwiLFwiICtcblx0XHRcdE1hdGguZmxvb3IoTWF0aC5jbGFtcChjWzFdLCAwLCAxKSAqIDI1NSkgK1xuXHRcdFx0XCIsXCIgK1xuXHRcdFx0TWF0aC5mbG9vcihNYXRoLmNsYW1wKGNbMl0sIDAsIDEpICogMjU1KSArXG5cdFx0XHRcIilcIjtcblx0XHRpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBjdHguZmlsbFN0eWxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ29sb3IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlID1cblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT0gTEdyYXBoVGV4dHVyZS5ISUdIXG5cdFx0XHRcdD8gTEdyYXBoVGV4dHVyZS5ISUdIX1BSRUNJU0lPTl9GT1JNQVRcblx0XHRcdFx0OiBnbC5VTlNJR05FRF9CWVRFO1xuXG5cdFx0aWYgKCF0aGlzLl90ZXggfHwgdGhpcy5fdGV4LnR5cGUgIT0gdHlwZSkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUoMSwgMSwge1xuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG1pbkZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHZhciBjb2xvciA9IHRoaXMucHJvcGVydGllcy5jb2xvcjtcblxuXHRcdGlmICh0aGlzLmlucHV0cykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcblx0XHRcdFx0aWYgKHYgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAoaW5wdXQubmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgXCJSR0JcIjpcblx0XHRcdFx0XHRjYXNlIFwiUkdCQVwiOlxuXHRcdFx0XHRcdFx0Y29sb3Iuc2V0KHYpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIlJcIjpcblx0XHRcdFx0XHRcdGNvbG9yWzBdID0gdjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJHXCI6XG5cdFx0XHRcdFx0XHRjb2xvclsxXSA9IHY7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiQlwiOlxuXHRcdFx0XHRcdFx0Y29sb3JbMl0gPSB2O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkFcIjpcblx0XHRcdFx0XHRcdGNvbG9yWzNdID0gdjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHZlYzQuc3FyRGlzdCh0aGlzLl90ZXhfY29sb3IsIGNvbG9yKSA+IDAuMDAxKSB7XG5cdFx0XHR0aGlzLl90ZXhfY29sb3Iuc2V0KGNvbG9yKTtcblx0XHRcdHRoaXMuX3RleC5maWxsKGNvbG9yKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNvbG9yLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRbXCJSR0JcIiwgXCJ2ZWMzXCJdLFxuXHRcdFx0W1wiUkdCQVwiLCBcInZlYzRcIl0sXG5cdFx0XHRbXCJSXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiR1wiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIkJcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJBXCIsIFwibnVtYmVyXCJdXG5cdFx0XTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY29sb3JcIiwgTEdyYXBoVGV4dHVyZUNvbG9yKTtcblxuXHQvLyBUZXh0dXJlIENoYW5uZWxzIHRvIFRleHR1cmUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUdyYWRpZW50KCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwiY29sb3JcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIiwgXCJjb2xvclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0YW5nbGU6IDAsXG5cdFx0XHRzY2FsZTogMSxcblx0XHRcdEE6IFswLCAwLCAwXSxcblx0XHRcdEI6IFsxLCAxLCAxXSxcblx0XHRcdHRleHR1cmVfc2l6ZTogMzJcblx0XHR9O1xuXHRcdGlmICghTEdyYXBoVGV4dHVyZUdyYWRpZW50Ll9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVHcmFkaWVudC5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlR3JhZGllbnQucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV9hbmdsZTogMCxcblx0XHRcdHVfY29sb3JBOiB2ZWMzLmNyZWF0ZSgpLFxuXHRcdFx0dV9jb2xvckI6IHZlYzMuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50LnRpdGxlID0gXCJHcmFkaWVudFwiO1xuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnQuZGVzYyA9IFwiR2VuZXJhdGVzIGEgZ3JhZGllbnRcIjtcblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50W1wiQEFcIl0gPSB7IHR5cGU6IFwiY29sb3JcIiB9O1xuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnRbXCJAQlwiXSA9IHsgdHlwZTogXCJjb2xvclwiIH07XG5cdExHcmFwaFRleHR1cmVHcmFkaWVudFtcIkB0ZXh0dXJlX3NpemVcIl0gPSB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiBbMzIsIDY0LCAxMjgsIDI1NiwgNTEyXVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVHcmFkaWVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHZhciBtZXNoID0gR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVHcmFkaWVudC5fc2hhZGVyO1xuXG5cdFx0dmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIUEpIHtcblx0XHRcdEEgPSB0aGlzLnByb3BlcnRpZXMuQTtcblx0XHR9XG5cdFx0dmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoIUIpIHtcblx0XHRcdEIgPSB0aGlzLnByb3BlcnRpZXMuQjtcblx0XHR9XG5cblx0XHQvL2FuZ2xlIGFuZCBzY2FsZVxuXHRcdGZvciAodmFyIGkgPSAyOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xuXHRcdFx0dmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcblx0XHRcdGlmICh2ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByb3BlcnRpZXNbaW5wdXQubmFtZV0gPSB2O1xuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHRoaXMuX3VuaWZvcm1zLnVfYW5nbGUgPSB0aGlzLnByb3BlcnRpZXMuYW5nbGUgKiBERUcyUkFEO1xuXHRcdHRoaXMuX3VuaWZvcm1zLnVfc2NhbGUgPSB0aGlzLnByb3BlcnRpZXMuc2NhbGU7XG5cdFx0dmVjMy5jb3B5KHVuaWZvcm1zLnVfY29sb3JBLCBBKTtcblx0XHR2ZWMzLmNvcHkodW5pZm9ybXMudV9jb2xvckIsIEIpO1xuXG5cdFx0dmFyIHNpemUgPSBwYXJzZUludCh0aGlzLnByb3BlcnRpZXMudGV4dHVyZV9zaXplKTtcblx0XHRpZiAoIXRoaXMuX3RleCB8fCB0aGlzLl90ZXgud2lkdGggIT0gc2l6ZSkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUoc2l6ZSwgc2l6ZSwge1xuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQixcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbW1wiYW5nbGVcIiwgXCJudW1iZXJcIl0sIFtcInNjYWxlXCIsIFwibnVtYmVyXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnQucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2FuZ2xlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMzIHVfY29sb3JBO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMzIHVfY29sb3JCO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2ZWMyIHJvdGF0ZSh2ZWMyIHYsIGZsb2F0IGFuZ2xlKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHR2ZWMyIHJlc3VsdDtcXG5cXFxuXHRcdFx0ZmxvYXQgX2NvcyA9IGNvcyhhbmdsZSk7XFxuXFxcblx0XHRcdGZsb2F0IF9zaW4gPSBzaW4oYW5nbGUpO1xcblxcXG5cdFx0XHRyZXN1bHQueCA9IHYueCAqIF9jb3MgLSB2LnkgKiBfc2luO1xcblxcXG5cdFx0XHRyZXN1bHQueSA9IHYueCAqIF9zaW4gKyB2LnkgKiBfY29zO1xcblxcXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRmbG9hdCBmID0gKHJvdGF0ZSh1X3NjYWxlICogKHZfY29vcmQgLSB2ZWMyKDAuNSkpLCB1X2FuZ2xlKSArIHZlYzIoMC41KSkueDtcXG5cXFxuXHRcdFx0dmVjMyBjb2xvciA9IG1peCh1X2NvbG9yQSx1X2NvbG9yQixjbGFtcChmLDAuMCwxLjApKTtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsMS4wKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9ncmFkaWVudFwiLCBMR3JhcGhUZXh0dXJlR3JhZGllbnQpO1xuXG5cdC8vIFRleHR1cmUgTWl4ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVNaXgoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiTWl4ZXJcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGZhY3RvcjogMC41LCBzaXplX2Zyb21fYmlnZ2VzdDogdHJ1ZSwgaW52ZXJ0OiBmYWxzZSwgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQgfTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZUE6IDAsXG5cdFx0XHR1X3RleHR1cmVCOiAxLFxuXHRcdFx0dV90ZXh0dXJlTWl4OiAyLFxuXHRcdFx0dV9taXg6IHZlYzQuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZU1peC50aXRsZSA9IFwiTWl4XCI7XG5cdExHcmFwaFRleHR1cmVNaXguZGVzYyA9IFwiR2VuZXJhdGVzIGEgdGV4dHVyZSBtaXhpbmcgdHdvIHRleHR1cmVzXCI7XG5cblx0TEdyYXBoVGV4dHVyZU1peC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVNaXgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXhBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4QSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRleEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoIXRleEEgfHwgIXRleEIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGV4TWl4ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cblx0XHR2YXIgZmFjdG9yID0gdGhpcy5nZXRJbnB1dERhdGEoMyk7XG5cblx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuc2l6ZV9mcm9tX2JpZ2dlc3QgJiYgdGV4Qi53aWR0aCA+IHRleEEud2lkdGggPyB0ZXhCIDogdGV4QSxcblx0XHRcdHRoaXMuX3RleCxcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cblx0XHQpO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0dmFyIHNoYWRlciA9IG51bGw7XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0aWYgKHRleE1peCkge1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoVGV4dHVyZU1peC5fc2hhZGVyX3RleDtcblx0XHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVNaXguX3NoYWRlcl90ZXggPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUZXh0dXJlTWl4LnBpeGVsX3NoYWRlcixcblx0XHRcdFx0XHR7IE1JWF9URVg6IFwiXCIgfVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWl4Ll9zaGFkZXJfZmFjdG9yO1xuXHRcdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdFx0c2hhZGVyID0gTEdyYXBoVGV4dHVyZU1peC5fc2hhZGVyX2ZhY3RvciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdExHcmFwaFRleHR1cmVNaXgucGl4ZWxfc2hhZGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZiA9IGZhY3RvciA9PSBudWxsID8gdGhpcy5wcm9wZXJ0aWVzLmZhY3RvciA6IGZhY3Rvcjtcblx0XHRcdHVuaWZvcm1zLnVfbWl4LnNldChbZiwgZiwgZiwgZl0pO1xuXHRcdH1cblxuXHRcdHZhciBpbnZlcnQgPSB0aGlzLnByb3BlcnRpZXMuaW52ZXJ0O1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleEEuYmluZCggaW52ZXJ0ID8gMSA6IDAgKTtcblx0XHRcdHRleEIuYmluZCggaW52ZXJ0ID8gMCA6IDEgKTtcblx0XHRcdGlmICh0ZXhNaXgpIHtcblx0XHRcdFx0dGV4TWl4LmJpbmQoMik7XG5cdFx0XHR9XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWl4LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbW1wiZmFjdG9yXCIsIFwibnVtYmVyXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWl4LnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUE7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0I2lmZGVmIE1JWF9URVhcXG5cXFxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlTWl4O1xcblxcXG5cdFx0I2Vsc2VcXG5cXFxuXHRcdFx0dW5pZm9ybSB2ZWM0IHVfbWl4O1xcblxcXG5cdFx0I2VuZGlmXFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0I2lmZGVmIE1JWF9URVhcXG5cXFxuXHRcdFx0ICAgdmVjNCBmID0gdGV4dHVyZTJEKHVfdGV4dHVyZU1peCwgdl9jb29yZCk7XFxuXFxcblx0XHRcdCNlbHNlXFxuXFxcblx0XHRcdCAgIHZlYzQgZiA9IHVfbWl4O1xcblxcXG5cdFx0XHQjZW5kaWZcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IG1peCggdGV4dHVyZTJEKHVfdGV4dHVyZUEsIHZfY29vcmQpLCB0ZXh0dXJlMkQodV90ZXh0dXJlQiwgdl9jb29yZCksIGYgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9taXhcIiwgTEdyYXBoVGV4dHVyZU1peCk7XG5cblx0Ly8gVGV4dHVyZSBFZGdlcyBkZXRlY3Rpb24gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUVkZ2VzKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXguXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiRWRnZXNcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGludmVydDogdHJ1ZSxcblx0XHRcdHRocmVzaG9sZDogZmFsc2UsXG5cdFx0XHRmYWN0b3I6IDEsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVFZGdlcy5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlRWRnZXMuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZUVkZ2VzLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlRWRnZXMudGl0bGUgPSBcIkVkZ2VzXCI7XG5cdExHcmFwaFRleHR1cmVFZGdlcy5kZXNjID0gXCJEZXRlY3RzIGVkZ2VzXCI7XG5cblx0TEdyYXBoVGV4dHVyZUVkZ2VzLndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUVkZ2VzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcblx0XHRcdHRleCxcblx0XHRcdHRoaXMuX3RleCxcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cblx0XHQpO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVFZGdlcy5fc2hhZGVyO1xuXHRcdHZhciBpbnZlcnQgPSB0aGlzLnByb3BlcnRpZXMuaW52ZXJ0O1xuXHRcdHZhciBmYWN0b3IgPSB0aGlzLnByb3BlcnRpZXMuZmFjdG9yO1xuXHRcdHZhciB0aHJlc2hvbGQgPSB0aGlzLnByb3BlcnRpZXMudGhyZXNob2xkID8gMSA6IDA7XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXJcblx0XHRcdFx0LnVuaWZvcm1zKHtcblx0XHRcdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHRcdFx0dV9pc2l6ZTogWzEgLyB0ZXgud2lkdGgsIDEgLyB0ZXguaGVpZ2h0XSxcblx0XHRcdFx0XHR1X2ZhY3RvcjogZmFjdG9yLFxuXHRcdFx0XHRcdHVfdGhyZXNob2xkOiB0aHJlc2hvbGQsXG5cdFx0XHRcdFx0dV9pbnZlcnQ6IGludmVydCA/IDEgOiAwXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUVkZ2VzLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X2lzaXplO1xcblxcXG5cdFx0dW5pZm9ybSBpbnQgdV9pbnZlcnQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZmFjdG9yO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3RocmVzaG9sZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNlbnRlciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXG5cdFx0XHR2ZWM0IHVwID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfaXNpemUgKiB2ZWMyKDAuMCwxLjApICk7XFxuXFxcblx0XHRcdHZlYzQgZG93biA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X2lzaXplICogdmVjMigwLjAsLTEuMCkgKTtcXG5cXFxuXHRcdFx0dmVjNCBsZWZ0ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfaXNpemUgKiB2ZWMyKDEuMCwwLjApICk7XFxuXFxcblx0XHRcdHZlYzQgcmlnaHQgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9pc2l6ZSAqIHZlYzIoLTEuMCwwLjApICk7XFxuXFxcblx0XHRcdHZlYzQgZGlmZiA9IGFicyhjZW50ZXIgLSB1cCkgKyBhYnMoY2VudGVyIC0gZG93bikgKyBhYnMoY2VudGVyIC0gbGVmdCkgKyBhYnMoY2VudGVyIC0gcmlnaHQpO1xcblxcXG5cdFx0XHRkaWZmICo9IHVfZmFjdG9yO1xcblxcXG5cdFx0XHRpZih1X2ludmVydCA9PSAxKVxcblxcXG5cdFx0XHRcdGRpZmYueHl6ID0gdmVjMygxLjApIC0gZGlmZi54eXo7XFxuXFxcblx0XHRcdGlmKCB1X3RocmVzaG9sZCA9PSAwLjAgKVxcblxcXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmYueHl6LCBjZW50ZXIuYSApO1xcblxcXG5cdFx0XHRlbHNlXFxuXFxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggZGlmZi54ID4gMC41ID8gMS4wIDogMC4wLCBkaWZmLnkgPiAwLjUgPyAxLjAgOiAwLjAsIGRpZmYueiA+IDAuNSA/IDEuMCA6IDAuMCwgY2VudGVyLmEgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9lZGdlc1wiLCBMR3JhcGhUZXh0dXJlRWRnZXMpO1xuXG5cdC8vIFRleHR1cmUgRGVwdGggKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJEaXN0YW5jZVwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiUmFuZ2VcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRkaXN0YW5jZTogMTAwLFxuXHRcdFx0cmFuZ2U6IDUwLFxuXHRcdFx0b25seV9kZXB0aDogZmFsc2UsXG5cdFx0XHRoaWdoX3ByZWNpc2lvbjogZmFsc2Vcblx0XHR9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV9kaXN0YW5jZTogMTAwLFxuXHRcdFx0dV9yYW5nZTogNTAsXG5cdFx0XHR1X2NhbWVyYV9wbGFuZXM6IG51bGxcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UudGl0bGUgPSBcIkRlcHRoIFJhbmdlXCI7XG5cdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLmRlc2MgPSBcIkdlbmVyYXRlcyBhIHRleHR1cmUgd2l0aCBhIGRlcHRoIHJhbmdlXCI7XG5cblx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcHJlY2lzaW9uID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmhpZ2hfcHJlY2lzaW9uKSB7XG5cdFx0XHRwcmVjaXNpb24gPSBnbC5oYWxmX2Zsb2F0X2V4dCA/IGdsLkhBTEZfRkxPQVRfT0VTIDogZ2wuRkxPQVQ7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuX3RlbXBfdGV4dHVyZSB8fFxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLnR5cGUgIT0gcHJlY2lzaW9uIHx8XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUuaGVpZ2h0ICE9IHRleC5oZWlnaHRcblx0XHQpIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiBwcmVjaXNpb24sXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXG5cdFx0Ly9pdGVyYXRpb25zXG5cdFx0dmFyIGRpc3RhbmNlID0gdGhpcy5wcm9wZXJ0aWVzLmRpc3RhbmNlO1xuXHRcdGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcblx0XHRcdGRpc3RhbmNlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR9XG5cblx0XHR2YXIgcmFuZ2UgPSB0aGlzLnByb3BlcnRpZXMucmFuZ2U7XG5cdFx0aWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgyKSkge1xuXHRcdFx0cmFuZ2UgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5yYW5nZSA9IHJhbmdlO1xuXHRcdH1cblxuXHRcdHVuaWZvcm1zLnVfZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR1bmlmb3Jtcy51X3JhbmdlID0gcmFuZ2U7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0XHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5fc2hhZGVyX29ubHlkZXB0aCA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UucGl4ZWxfc2hhZGVyLFxuXHRcdFx0XHR7IE9OTFlfREVQVEg6IFwiXCIgfVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0dmFyIHNoYWRlciA9IHRoaXMucHJvcGVydGllcy5vbmx5X2RlcHRoXG5cdFx0XHQ/IExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLl9zaGFkZXJfb25seWRlcHRoXG5cdFx0XHQ6IExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLl9zaGFkZXI7XG5cblx0XHQvL05FQVIgQU5EIEZBUiBQTEFORVNcblx0XHR2YXIgcGxhbmVzID0gbnVsbDtcblx0XHRpZiAodGV4Lm5lYXJfZmFyX3BsYW5lcykge1xuXHRcdFx0cGxhbmVzID0gdGV4Lm5lYXJfZmFyX3BsYW5lcztcblx0XHR9IGVsc2UgaWYgKHdpbmRvdy5MUyAmJiBMUy5SZW5kZXJlci5fbWFpbl9jYW1lcmEpIHtcblx0XHRcdHBsYW5lcyA9IExTLlJlbmRlcmVyLl9tYWluX2NhbWVyYS5fdW5pZm9ybXMudV9jYW1lcmFfcGxhbmVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwbGFuZXMgPSBbMC4xLCAxMDAwXTtcblx0XHR9IC8vaGFyZGNvZGVkXG5cdFx0dW5pZm9ybXMudV9jYW1lcmFfcGxhbmVzID0gcGxhbmVzO1xuXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLm5lYXJfZmFyX3BsYW5lcyA9IHBsYW5lcztcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9jYW1lcmFfcGxhbmVzO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2Rpc3RhbmNlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3JhbmdlO1xcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBMaW5lYXJEZXB0aCgpXFxuXFxcblx0XHR7XFxuXFxcblx0XHRcdGZsb2F0IHpOZWFyID0gdV9jYW1lcmFfcGxhbmVzLng7XFxuXFxcblx0XHRcdGZsb2F0IHpGYXIgPSB1X2NhbWVyYV9wbGFuZXMueTtcXG5cXFxuXHRcdFx0ZmxvYXQgZGVwdGggPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKS54O1xcblxcXG5cdFx0XHRkZXB0aCA9IGRlcHRoICogMi4wIC0gMS4wO1xcblxcXG5cdFx0XHRyZXR1cm4gek5lYXIgKiAoZGVwdGggKyAxLjApIC8gKHpGYXIgKyB6TmVhciAtIGRlcHRoICogKHpGYXIgLSB6TmVhcikpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdGZsb2F0IGRlcHRoID0gTGluZWFyRGVwdGgoKTtcXG5cXFxuXHRcdFx0I2lmZGVmIE9OTFlfREVQVEhcXG5cXFxuXHRcdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkZXB0aCk7XFxuXFxcblx0XHRcdCNlbHNlXFxuXFxcblx0XHRcdFx0ZmxvYXQgZGlmZiA9IGFicyhkZXB0aCAqIHVfY2FtZXJhX3BsYW5lcy55IC0gdV9kaXN0YW5jZSk7XFxuXFxcblx0XHRcdFx0ZmxvYXQgZG9mID0gMS4wO1xcblxcXG5cdFx0XHRcdGlmKGRpZmYgPD0gdV9yYW5nZSlcXG5cXFxuXHRcdFx0XHRcdGRvZiA9IGRpZmYgLyB1X3JhbmdlO1xcblxcXG5cdFx0XHQgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRvZik7XFxuXFxcblx0XHRcdCNlbmRpZlxcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS9kZXB0aF9yYW5nZVwiLCBMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZSApO1xuXG5cblx0Ly8gVGV4dHVyZSBEZXB0aCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGgoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQsXG5cdFx0XHRpbnZlcnQ6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfY2FtZXJhX3BsYW5lczogbnVsbCwgLy9maWxsZWQgbGF0ZXJcblx0XHRcdHVfaXJlczogdmVjMi5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGgud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGgudGl0bGUgPSBcIkxpbmVhciBEZXB0aFwiO1xuXHRMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGguZGVzYyA9IFwiQ3JlYXRlcyBhIGNvbG9yIHRleHR1cmUgd2l0aCBsaW5lYXIgZGVwdGhcIjtcblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggfHwgKHRleC5mb3JtYXQgIT0gZ2wuREVQVEhfQ09NUE9ORU5UICYmIHRleC5mb3JtYXQgIT0gZ2wuREVQVEhfU1RFTkNJTCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHByZWNpc2lvbiA9IHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT0gTEdyYXBoVGV4dHVyZS5ISUdIID8gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUIDogZ2wuVU5TSUdORURfQllURTtcblxuXHRcdGlmICggIXRoaXMuX3RlbXBfdGV4dHVyZSB8fCB0aGlzLl90ZW1wX3RleHR1cmUudHlwZSAhPSBwcmVjaXNpb24gfHwgdGhpcy5fdGVtcF90ZXh0dXJlLndpZHRoICE9IHRleC53aWR0aCB8fCB0aGlzLl90ZW1wX3RleHR1cmUuaGVpZ2h0ICE9IHRleC5oZWlnaHQgKSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogcHJlY2lzaW9uLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQixcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfaW52ZXJ0ID0gdGhpcy5wcm9wZXJ0aWVzLmludmVydCA/IDEgOiAwO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdGlmKCFMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGguX3NoYWRlcilcblx0XHRcdExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGgucGl4ZWxfc2hhZGVyKTtcblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLl9zaGFkZXI7XG5cblx0XHQvL05FQVIgQU5EIEZBUiBQTEFORVNcblx0XHR2YXIgcGxhbmVzID0gbnVsbDtcblx0XHRpZiAodGV4Lm5lYXJfZmFyX3BsYW5lcykge1xuXHRcdFx0cGxhbmVzID0gdGV4Lm5lYXJfZmFyX3BsYW5lcztcblx0XHR9IGVsc2UgaWYgKHdpbmRvdy5MUyAmJiBMUy5SZW5kZXJlci5fbWFpbl9jYW1lcmEpIHtcblx0XHRcdHBsYW5lcyA9IExTLlJlbmRlcmVyLl9tYWluX2NhbWVyYS5fdW5pZm9ybXMudV9jYW1lcmFfcGxhbmVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwbGFuZXMgPSBbMC4xLCAxMDAwXTtcblx0XHR9IC8vaGFyZGNvZGVkXG5cdFx0dW5pZm9ybXMudV9jYW1lcmFfcGxhbmVzID0gcGxhbmVzO1xuXHRcdC8vdW5pZm9ybXMudV9pcmVzLnNldChbMS90ZXgud2lkdGgsIDEvdGV4LmhlaWdodF0pO1xuXHRcdHVuaWZvcm1zLnVfaXJlcy5zZXQoWzAsMF0pO1xuXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLm5lYXJfZmFyX3BsYW5lcyA9IHBsYW5lcztcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGgucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfY2FtZXJhX3BsYW5lcztcXG5cXFxuXHRcdHVuaWZvcm0gaW50IHVfaW52ZXJ0O1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfaXJlcztcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRmbG9hdCB6TmVhciA9IHVfY2FtZXJhX3BsYW5lcy54O1xcblxcXG5cdFx0XHRmbG9hdCB6RmFyID0gdV9jYW1lcmFfcGxhbmVzLnk7XFxuXFxcblx0XHRcdGZsb2F0IGRlcHRoID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfaXJlcyowLjUpLnggKiAyLjAgLSAxLjA7XFxuXFxcblx0XHRcdGZsb2F0IGYgPSB6TmVhciAqIChkZXB0aCArIDEuMCkgLyAoekZhciArIHpOZWFyIC0gZGVwdGggKiAoekZhciAtIHpOZWFyKSk7XFxuXFxcblx0XHRcdGlmKCB1X2ludmVydCA9PSAxIClcXG5cXFxuXHRcdFx0XHRmID0gMS4wIC0gZjtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGYpLDEuMCk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL2xpbmVhcl9kZXB0aFwiLCBMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGggKTtcblxuXHQvLyBUZXh0dXJlIEJsdXIgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUJsdXIoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJJdGVyYXRpb25zXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJJbnRlbnNpdHlcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJCbHVycmVkXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRpbnRlbnNpdHk6IDEsXG5cdFx0XHRpdGVyYXRpb25zOiAxLFxuXHRcdFx0cHJlc2VydmVfYXNwZWN0OiBmYWxzZSxcblx0XHRcdHNjYWxlOiBbMSwgMV0sXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQmx1ci50aXRsZSA9IFwiQmx1clwiO1xuXHRMR3JhcGhUZXh0dXJlQmx1ci5kZXNjID0gXCJCbHVyIGEgdGV4dHVyZVwiO1xuXG5cdExHcmFwaFRleHR1cmVCbHVyLndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUJsdXIubWF4X2l0ZXJhdGlvbnMgPSAyMDtcblxuXHRMR3JhcGhUZXh0dXJlQmx1ci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fZmluYWxfdGV4dHVyZTtcblxuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHQvL3dlIG5lZWQgdHdvIHRleHR1cmVzIHRvIGRvIHRoZSBibHVycmluZ1xuXHRcdFx0Ly90aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSggdGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7IHR5cGU6IHRleC50eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH0pO1xuXHRcdFx0dGVtcCA9IHRoaXMuX2ZpbmFsX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0dGV4LndpZHRoLFxuXHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHR7IHR5cGU6IHRleC50eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly9pdGVyYXRpb25zXG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSB0aGlzLnByb3BlcnRpZXMuaXRlcmF0aW9ucztcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHRpdGVyYXRpb25zID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG5cdFx0fVxuXHRcdGl0ZXJhdGlvbnMgPSBNYXRoLm1pbihcblx0XHRcdE1hdGguZmxvb3IoaXRlcmF0aW9ucyksXG5cdFx0XHRMR3JhcGhUZXh0dXJlQmx1ci5tYXhfaXRlcmF0aW9uc1xuXHRcdCk7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPT0gMCkge1xuXHRcdFx0Ly9za2lwIGJsdXJyaW5nXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW50ZW5zaXR5ID0gdGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eTtcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDIpKSB7XG5cdFx0XHRpbnRlbnNpdHkgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG5cdFx0fVxuXG5cdFx0Ly9ibHVyIHNvbWV0aW1lcyBuZWVkcyBhbiBhc3BlY3QgY29ycmVjdGlvblxuXHRcdHZhciBhc3BlY3QgPSBMaXRlR3JhcGguY2FtZXJhX2FzcGVjdDtcblx0XHRpZiAoIWFzcGVjdCAmJiB3aW5kb3cuZ2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXNwZWN0ID0gZ2wuY2FudmFzLmhlaWdodCAvIGdsLmNhbnZhcy53aWR0aDtcblx0XHR9XG5cdFx0aWYgKCFhc3BlY3QpIHtcblx0XHRcdGFzcGVjdCA9IDE7XG5cdFx0fVxuXHRcdGFzcGVjdCA9IHRoaXMucHJvcGVydGllcy5wcmVzZXJ2ZV9hc3BlY3QgPyBhc3BlY3QgOiAxO1xuXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlIHx8IFsxLCAxXTtcblx0XHR0ZXguYXBwbHlCbHVyKGFzcGVjdCAqIHNjYWxlWzBdLCBzY2FsZVsxXSwgaW50ZW5zaXR5LCB0ZW1wKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuXHRcdFx0dGVtcC5hcHBseUJsdXIoXG5cdFx0XHRcdGFzcGVjdCAqIHNjYWxlWzBdICogKGkgKyAxKSxcblx0XHRcdFx0c2NhbGVbMV0gKiAoaSArIDEpLFxuXHRcdFx0XHRpbnRlbnNpdHlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdC8qXG5MR3JhcGhUZXh0dXJlQmx1ci5waXhlbF9zaGFkZXIgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTtcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdCAgIHZlYzQgc3VtID0gdmVjNCgwLjApO1xcblxcXG5cdFx0ICAgdmVjNCBjZW50ZXIgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAtNC4wKSAqIDAuMDUvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAtMy4wKSAqIDAuMDkvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAtMi4wKSAqIDAuMTIvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAtMS4wKSAqIDAuMTUvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSBjZW50ZXIgKiAwLjE2LzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogNC4wKSAqIDAuMDUvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAzLjApICogMC4wOS8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIDIuMCkgKiAwLjEyLzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogMS4wKSAqIDAuMTUvMC45ODtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IHVfaW50ZW5zaXR5ICogc3VtO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG4qL1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9ibHVyXCIsIExHcmFwaFRleHR1cmVCbHVyKTtcblxuXHQvL0luZGVwZW5kZW50IGdsb3cgRlhcblx0Ly9iYXNlZCBvbiBodHRwczovL2NhdGxpa2Vjb2RpbmcuY29tL3VuaXR5L3R1dG9yaWFscy9hZHZhbmNlZC1yZW5kZXJpbmcvYmxvb20vXG5cdGZ1bmN0aW9uIEZYR2xvdygpXG5cdHtcblx0XHR0aGlzLmludGVuc2l0eSA9IDAuNTtcblx0XHR0aGlzLnBlcnNpc3RlbmNlID0gMC42O1xuXHRcdHRoaXMuaXRlcmF0aW9ucyA9IDg7XG5cdFx0dGhpcy50aHJlc2hvbGQgPSAwLjg7XG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cblx0XHR0aGlzLmRpcnRfdGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5kaXJ0X2ZhY3RvciA9IDAuNTtcblxuXHRcdHRoaXMuX3RleHR1cmVzID0gW107XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X2ludGVuc2l0eTogMSxcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfZ2xvd190ZXh0dXJlOiAxLFxuXHRcdFx0dV90aHJlc2hvbGQ6IDAsXG5cdFx0XHR1X3RleGVsX3NpemU6IHZlYzIuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0RlhHbG93LnByb3RvdHlwZS5hcHBseUZYID0gZnVuY3Rpb24oIHRleCwgb3V0cHV0X3RleHR1cmUsIGdsb3dfdGV4dHVyZSwgYXZlcmFnZV90ZXh0dXJlICkge1xuXG5cdFx0dmFyIHdpZHRoID0gdGV4LndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSB0ZXguaGVpZ2h0O1xuXG5cdFx0dmFyIHRleHR1cmVfaW5mbyA9IHtcblx0XHRcdGZvcm1hdDogdGV4LmZvcm1hdCxcblx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0bWluRmlsdGVyOiBHTC5MSU5FQVIsXG5cdFx0XHRtYWdGaWx0ZXI6IEdMLkxJTkVBUixcblx0XHRcdHdyYXA6IGdsLkNMQU1QX1RPX0VER0Vcblx0XHR9O1xuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dmFyIHRleHR1cmVzID0gdGhpcy5fdGV4dHVyZXM7XG5cblx0XHQvL2N1dFxuXHRcdHZhciBzaGFkZXIgPSBGWEdsb3cuX2N1dF9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IEZYR2xvdy5fY3V0X3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0RlhHbG93LmN1dF9waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuXHRcdHVuaWZvcm1zLnVfdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQ7XG5cdFx0dmFyIGN1cnJlbnREZXN0aW5hdGlvbiA9ICh0ZXh0dXJlc1swXSA9IEdMLlRleHR1cmUuZ2V0VGVtcG9yYXJ5KFxuXHRcdFx0d2lkdGgsXG5cdFx0XHRoZWlnaHQsXG5cdFx0XHR0ZXh0dXJlX2luZm9cblx0XHQpKTtcblx0XHR0ZXguYmxpdCggY3VycmVudERlc3RpbmF0aW9uLCBzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpICk7XG5cdFx0dmFyIGN1cnJlbnRTb3VyY2UgPSBjdXJyZW50RGVzdGluYXRpb247XG5cblx0XHR2YXIgaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9ucztcblx0XHRpdGVyYXRpb25zID0gTWF0aC5jbGFtcChpdGVyYXRpb25zLCAxLCAxNikgfCAwO1xuXHRcdHZhciB0ZXhlbF9zaXplID0gdW5pZm9ybXMudV90ZXhlbF9zaXplO1xuXHRcdHZhciBpbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuXHRcdHVuaWZvcm1zLnVfaW50ZW5zaXR5ID0gMTtcblx0XHR1bmlmb3Jtcy51X2RlbHRhID0gdGhpcy5zY2FsZTsgLy8xXG5cblx0XHQvL2Rvd25zY2FsZS91cHNjYWxlIHNoYWRlclxuXHRcdHZhciBzaGFkZXIgPSBGWEdsb3cuX3NoYWRlcjtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gRlhHbG93Ll9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdEZYR2xvdy5zY2FsZV9waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGkgPSAxO1xuXHRcdC8vZG93bnNjYWxlXG5cdFx0Zm9yICg7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0XHRcdHdpZHRoID0gd2lkdGggPj4gMTtcblx0XHRcdGlmICgoaGVpZ2h0IHwgMCkgPiAxKSB7XG5cdFx0XHRcdGhlaWdodCA9IGhlaWdodCA+PiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHdpZHRoIDwgMikge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGN1cnJlbnREZXN0aW5hdGlvbiA9IHRleHR1cmVzW2ldID0gR0wuVGV4dHVyZS5nZXRUZW1wb3JhcnkoXG5cdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdHRleHR1cmVfaW5mb1xuXHRcdFx0KTtcblx0XHRcdHRleGVsX3NpemVbMF0gPSAxIC8gY3VycmVudFNvdXJjZS53aWR0aDtcblx0XHRcdHRleGVsX3NpemVbMV0gPSAxIC8gY3VycmVudFNvdXJjZS5oZWlnaHQ7XG5cdFx0XHRjdXJyZW50U291cmNlLmJsaXQoXG5cdFx0XHRcdGN1cnJlbnREZXN0aW5hdGlvbixcblx0XHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKVxuXHRcdFx0KTtcblx0XHRcdGN1cnJlbnRTb3VyY2UgPSBjdXJyZW50RGVzdGluYXRpb247XG5cdFx0fVxuXG5cdFx0Ly9hdmVyYWdlXG5cdFx0aWYgKGF2ZXJhZ2VfdGV4dHVyZSkge1xuXHRcdFx0dGV4ZWxfc2l6ZVswXSA9IDEgLyBjdXJyZW50U291cmNlLndpZHRoO1xuXHRcdFx0dGV4ZWxfc2l6ZVsxXSA9IDEgLyBjdXJyZW50U291cmNlLmhlaWdodDtcblx0XHRcdHVuaWZvcm1zLnVfaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xuXHRcdFx0dW5pZm9ybXMudV9kZWx0YSA9IDE7XG5cdFx0XHRjdXJyZW50U291cmNlLmJsaXQoYXZlcmFnZV90ZXh0dXJlLCBzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpKTtcblx0XHR9XG5cblx0XHQvL3Vwc2NhbGUgYW5kIGJsZW5kXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuXHRcdHVuaWZvcm1zLnVfaW50ZW5zaXR5ID0gdGhpcy5wZXJzaXN0ZW5jZTtcblx0XHR1bmlmb3Jtcy51X2RlbHRhID0gMC41O1xuXG5cdFx0Ly8gaS09MiA9PiAtMSB0byBwb2ludCB0byBsYXN0IGVsZW1lbnQgaW4gYXJyYXksIC0xIHRvIGdvIHRvIHRleHR1cmUgYWJvdmVcblx0XHRmb3IgKCBpIC09IDI7IGkgPj0gMDsgaS0tICkgXG5cdFx0e1xuXHRcdFx0Y3VycmVudERlc3RpbmF0aW9uID0gdGV4dHVyZXNbaV07XG5cdFx0XHR0ZXh0dXJlc1tpXSA9IG51bGw7XG5cdFx0XHR0ZXhlbF9zaXplWzBdID0gMSAvIGN1cnJlbnRTb3VyY2Uud2lkdGg7XG5cdFx0XHR0ZXhlbF9zaXplWzFdID0gMSAvIGN1cnJlbnRTb3VyY2UuaGVpZ2h0O1xuXHRcdFx0Y3VycmVudFNvdXJjZS5ibGl0KFxuXHRcdFx0XHRjdXJyZW50RGVzdGluYXRpb24sXG5cdFx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3Jtcylcblx0XHRcdCk7XG5cdFx0XHRHTC5UZXh0dXJlLnJlbGVhc2VUZW1wb3JhcnkoY3VycmVudFNvdXJjZSk7XG5cdFx0XHRjdXJyZW50U291cmNlID0gY3VycmVudERlc3RpbmF0aW9uO1xuXHRcdH1cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuXHRcdC8vZ2xvd1xuXHRcdGlmIChnbG93X3RleHR1cmUpIHtcblx0XHRcdGN1cnJlbnRTb3VyY2UuYmxpdChnbG93X3RleHR1cmUpO1xuXHRcdH1cblxuXHRcdC8vZmluYWwgY29tcG9zaXRpb25cblx0XHRpZiAoIG91dHB1dF90ZXh0dXJlICkge1xuXHRcdFx0dmFyIGZpbmFsX3RleHR1cmUgPSBvdXRwdXRfdGV4dHVyZTtcblx0XHRcdHZhciBkaXJ0X3RleHR1cmUgPSB0aGlzLmRpcnRfdGV4dHVyZTtcblx0XHRcdHZhciBkaXJ0X2ZhY3RvciA9IHRoaXMuZGlydF9mYWN0b3I7XG5cdFx0XHR1bmlmb3Jtcy51X2ludGVuc2l0eSA9IGludGVuc2l0eTtcblxuXHRcdFx0c2hhZGVyID0gZGlydF90ZXh0dXJlXG5cdFx0XHRcdD8gRlhHbG93Ll9kaXJ0X2ZpbmFsX3NoYWRlclxuXHRcdFx0XHQ6IEZYR2xvdy5fZmluYWxfc2hhZGVyO1xuXHRcdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdFx0aWYgKGRpcnRfdGV4dHVyZSkge1xuXHRcdFx0XHRcdHNoYWRlciA9IEZYR2xvdy5fZGlydF9maW5hbF9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdFx0RlhHbG93LmZpbmFsX3BpeGVsX3NoYWRlcixcblx0XHRcdFx0XHRcdHsgVVNFX0RJUlQ6IFwiXCIgfVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2hhZGVyID0gRlhHbG93Ll9maW5hbF9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRcdFx0RlhHbG93LmZpbmFsX3BpeGVsX3NoYWRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZmluYWxfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0XHRjdXJyZW50U291cmNlLmJpbmQoMSk7XG5cdFx0XHRcdGlmIChkaXJ0X3RleHR1cmUpIHtcblx0XHRcdFx0XHRzaGFkZXIuc2V0VW5pZm9ybShcInVfZGlydF9mYWN0b3JcIiwgZGlydF9mYWN0b3IpO1xuXHRcdFx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKFxuXHRcdFx0XHRcdFx0XCJ1X2RpcnRfdGV4dHVyZVwiLFxuXHRcdFx0XHRcdFx0ZGlydF90ZXh0dXJlLmJpbmQoMilcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNoYWRlci50b1ZpZXdwb3J0KHVuaWZvcm1zKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdEdMLlRleHR1cmUucmVsZWFzZVRlbXBvcmFyeShjdXJyZW50U291cmNlKTtcblx0fTtcblxuXHRGWEdsb3cuY3V0X3BpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV90aHJlc2hvbGQ7XFxuXFxcblx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gbWF4KCB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdl9jb29yZCApIC0gdmVjNCggdV90aHJlc2hvbGQgKSwgdmVjNCgwLjApICk7XFxuXFxcblx0fVwiO1xuXG5cdEZYR2xvdy5zY2FsZV9waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHR1bmlmb3JtIHZlYzIgdV90ZXhlbF9zaXplO1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9kZWx0YTtcXG5cXFxuXHR1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcXG5cdFxcblxcXG5cdHZlYzQgc2FtcGxlQm94KHZlYzIgdXYpIHtcXG5cXFxuXHRcdHZlYzQgbyA9IHVfdGV4ZWxfc2l6ZS54eXh5ICogdmVjMigtdV9kZWx0YSwgdV9kZWx0YSkueHh5eTtcXG5cXFxuXHRcdHZlYzQgcyA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB1diArIG8ueHkgKSArIHRleHR1cmUyRCggdV90ZXh0dXJlLCB1diArIG8uenkpICsgdGV4dHVyZTJEKCB1X3RleHR1cmUsIHV2ICsgby54dykgKyB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdXYgKyBvLnp3KTtcXG5cXFxuXHRcdHJldHVybiBzICogMC4yNTtcXG5cXFxuXHR9XFxuXFxcblx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdV9pbnRlbnNpdHkgKiBzYW1wbGVCb3goIHZfY29vcmQgKTtcXG5cXFxuXHR9XCI7XG5cblx0RlhHbG93LmZpbmFsX3BpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHVfZ2xvd190ZXh0dXJlO1xcblxcXG5cdCNpZmRlZiBVU0VfRElSVFxcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9kaXJ0X3RleHR1cmU7XFxuXFxcblx0I2VuZGlmXFxuXFxcblx0dW5pZm9ybSB2ZWMyIHVfdGV4ZWxfc2l6ZTtcXG5cXFxuXHR1bmlmb3JtIGZsb2F0IHVfZGVsdGE7XFxuXFxcblx0dW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTtcXG5cXFxuXHR1bmlmb3JtIGZsb2F0IHVfZGlydF9mYWN0b3I7XFxuXFxcblx0XFxuXFxcblx0dmVjNCBzYW1wbGVCb3godmVjMiB1dikge1xcblxcXG5cdFx0dmVjNCBvID0gdV90ZXhlbF9zaXplLnh5eHkgKiB2ZWMyKC11X2RlbHRhLCB1X2RlbHRhKS54eHl5O1xcblxcXG5cdFx0dmVjNCBzID0gdGV4dHVyZTJEKCB1X2dsb3dfdGV4dHVyZSwgdXYgKyBvLnh5ICkgKyB0ZXh0dXJlMkQoIHVfZ2xvd190ZXh0dXJlLCB1diArIG8uenkpICsgdGV4dHVyZTJEKCB1X2dsb3dfdGV4dHVyZSwgdXYgKyBvLnh3KSArIHRleHR1cmUyRCggdV9nbG93X3RleHR1cmUsIHV2ICsgby56dyk7XFxuXFxcblx0XHRyZXR1cm4gcyAqIDAuMjU7XFxuXFxcblx0fVxcblxcXG5cdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdHZlYzQgZ2xvdyA9IHNhbXBsZUJveCggdl9jb29yZCApO1xcblxcXG5cdFx0I2lmZGVmIFVTRV9ESVJUXFxuXFxcblx0XHRcdGdsb3cgPSBtaXgoIGdsb3csIGdsb3cgKiB0ZXh0dXJlMkQoIHVfZGlydF90ZXh0dXJlLCB2X2Nvb3JkICksIHVfZGlydF9mYWN0b3IgKTtcXG5cXFxuXHRcdCNlbmRpZlxcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKSArIHVfaW50ZW5zaXR5ICogZ2xvdztcXG5cXFxuXHR9XCI7XG5cblxuXHQvLyBUZXh0dXJlIEdsb3cgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUdsb3coKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiZGlydFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiZ2xvd1wiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdGludGVuc2l0eTogMSxcblx0XHRcdHBlcnNpc3RlbmNlOiAwLjk5LFxuXHRcdFx0aXRlcmF0aW9uczogMTYsXG5cdFx0XHR0aHJlc2hvbGQ6IDAsXG5cdFx0XHRzY2FsZTogMSxcblx0XHRcdGRpcnRfZmFjdG9yOiAwLjUsXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cblx0XHR0aGlzLmZ4ID0gbmV3IEZYR2xvdygpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUdsb3cudGl0bGUgPSBcIkdsb3dcIjtcblx0TEdyYXBoVGV4dHVyZUdsb3cuZGVzYyA9IFwiRmlsdGVycyBhIHRleHR1cmUgZ2l2aW5nIGl0IGEgZ2xvdyBlZmZlY3RcIjtcblxuXHRMR3JhcGhUZXh0dXJlR2xvdy53aWRnZXRzX2luZm8gPSB7XG5cdFx0aXRlcmF0aW9uczoge1xuXHRcdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogMTYsXG5cdFx0XHRzdGVwOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiAwXG5cdFx0fSxcblx0XHR0aHJlc2hvbGQ6IHtcblx0XHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XHRtaW46IDAsXG5cdFx0XHRtYXg6IDEwLFxuXHRcdFx0c3RlcDogMC4wMSxcblx0XHRcdHByZWNpc2lvbjogMlxuXHRcdH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVHbG93LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRbXCJlbmFibGVkXCIsIFwiYm9vbGVhblwiXSxcblx0XHRcdFtcInRocmVzaG9sZFwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImludGVuc2l0eVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcInBlcnNpc3RlbmNlXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiaXRlcmF0aW9uc1wiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImRpcnRfZmFjdG9yXCIsIFwibnVtYmVyXCJdXG5cdFx0XTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlR2xvdy5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJhdmVyYWdlXCIsIFwiVGV4dHVyZVwiXV07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUdsb3cucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc0FueU91dHB1dENvbm5lY3RlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmIChcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIIHx8XG5cdFx0XHR0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImVuYWJsZWRcIikgPT09IGZhbHNlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgd2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cblx0XHR2YXIgZnggPSB0aGlzLmZ4O1xuXHRcdGZ4LnRocmVzaG9sZCA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwidGhyZXNob2xkXCIpO1xuXHRcdGZ4Lml0ZXJhdGlvbnMgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIml0ZXJhdGlvbnNcIik7XG5cdFx0ZnguaW50ZW5zaXR5ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJpbnRlbnNpdHlcIik7XG5cdFx0ZngucGVyc2lzdGVuY2UgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInBlcnNpc3RlbmNlXCIpO1xuXHRcdGZ4LmRpcnRfdGV4dHVyZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGZ4LmRpcnRfZmFjdG9yID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJkaXJ0X2ZhY3RvclwiKTtcblx0XHRmeC5zY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZTtcblxuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiwgdGV4ICk7XG5cblx0XHR2YXIgYXZlcmFnZV90ZXh0dXJlID0gbnVsbDtcblx0XHRpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgyKSkge1xuXHRcdFx0YXZlcmFnZV90ZXh0dXJlID0gdGhpcy5fYXZlcmFnZV90ZXh0dXJlO1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhYXZlcmFnZV90ZXh0dXJlIHx8XG5cdFx0XHRcdGF2ZXJhZ2VfdGV4dHVyZS50eXBlICE9IHRleC50eXBlIHx8XG5cdFx0XHRcdGF2ZXJhZ2VfdGV4dHVyZS5mb3JtYXQgIT0gdGV4LmZvcm1hdFxuXHRcdFx0KSB7XG5cdFx0XHRcdGF2ZXJhZ2VfdGV4dHVyZSA9IHRoaXMuX2F2ZXJhZ2VfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKFxuXHRcdFx0XHRcdDEsXG5cdFx0XHRcdFx0MSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0eXBlOiB0ZXgudHlwZSxcblx0XHRcdFx0XHRcdGZvcm1hdDogdGV4LmZvcm1hdCxcblx0XHRcdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBnbG93X3RleHR1cmUgPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHRnbG93X3RleHR1cmUgPSB0aGlzLl9nbG93X3RleHR1cmU7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFnbG93X3RleHR1cmUgfHxcblx0XHRcdFx0Z2xvd190ZXh0dXJlLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0XHRnbG93X3RleHR1cmUuaGVpZ2h0ICE9IHRleC5oZWlnaHQgfHxcblx0XHRcdFx0Z2xvd190ZXh0dXJlLnR5cGUgIT0gdHlwZSB8fFxuXHRcdFx0XHRnbG93X3RleHR1cmUuZm9ybWF0ICE9IHRleC5mb3JtYXRcblx0XHRcdCkge1xuXHRcdFx0XHRnbG93X3RleHR1cmUgPSB0aGlzLl9nbG93X3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0XHR0ZXgud2lkdGgsXG5cdFx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0XHR7IHR5cGU6IHR5cGUsIGZvcm1hdDogdGV4LmZvcm1hdCwgZmlsdGVyOiBnbC5MSU5FQVIgfVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBmaW5hbF90ZXh0dXJlID0gbnVsbDtcblx0XHRpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0ZmluYWxfdGV4dHVyZSA9IHRoaXMuX2ZpbmFsX3RleHR1cmU7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFmaW5hbF90ZXh0dXJlIHx8XG5cdFx0XHRcdGZpbmFsX3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHRcdGZpbmFsX3RleHR1cmUuaGVpZ2h0ICE9IHRleC5oZWlnaHQgfHxcblx0XHRcdFx0ZmluYWxfdGV4dHVyZS50eXBlICE9IHR5cGUgfHxcblx0XHRcdFx0ZmluYWxfdGV4dHVyZS5mb3JtYXQgIT0gdGV4LmZvcm1hdFxuXHRcdFx0KSB7XG5cdFx0XHRcdGZpbmFsX3RleHR1cmUgPSB0aGlzLl9maW5hbF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdFx0dGV4LndpZHRoLFxuXHRcdFx0XHRcdHRleC5oZWlnaHQsXG5cdFx0XHRcdFx0eyB0eXBlOiB0eXBlLCBmb3JtYXQ6IHRleC5mb3JtYXQsIGZpbHRlcjogZ2wuTElORUFSIH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vYXBwbHkgRlhcblx0XHRmeC5hcHBseUZYKHRleCwgZmluYWxfdGV4dHVyZSwgZ2xvd190ZXh0dXJlLCBhdmVyYWdlX3RleHR1cmUgKTtcblxuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIGZpbmFsX3RleHR1cmUpO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkpXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMSwgYXZlcmFnZV90ZXh0dXJlKTtcblxuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDIpKVxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDIsIGdsb3dfdGV4dHVyZSk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2dsb3dcIiwgTEdyYXBoVGV4dHVyZUdsb3cpO1xuXG5cdC8vIFRleHR1cmUgRmlsdGVyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlcigpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJGaWx0ZXJlZFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBpbnRlbnNpdHk6IDEsIHJhZGl1czogNSB9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLnRpdGxlID0gXCJLdXdhaGFyYSBGaWx0ZXJcIjtcblx0TEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLmRlc2MgPVxuXHRcdFwiRmlsdGVycyBhIHRleHR1cmUgZ2l2aW5nIGFuIGFydGlzdGljIG9pbCBjYW52YXMgcGFpbnRpbmdcIjtcblxuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIubWF4X3JhZGl1cyA9IDEwO1xuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuX3NoYWRlcnMgPSBbXTtcblxuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblxuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogdGV4LnR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vaXRlcmF0aW9uc1xuXHRcdHZhciByYWRpdXMgPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzO1xuXHRcdHJhZGl1cyA9IE1hdGgubWluKFxuXHRcdFx0TWF0aC5mbG9vcihyYWRpdXMpLFxuXHRcdFx0TEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLm1heF9yYWRpdXNcblx0XHQpO1xuXHRcdGlmIChyYWRpdXMgPT0gMCkge1xuXHRcdFx0Ly9za2lwIGJsdXJyaW5nXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW50ZW5zaXR5ID0gdGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eTtcblxuXHRcdC8vYmx1ciBzb21ldGltZXMgbmVlZHMgYW4gYXNwZWN0IGNvcnJlY3Rpb25cblx0XHR2YXIgYXNwZWN0ID0gTGl0ZUdyYXBoLmNhbWVyYV9hc3BlY3Q7XG5cdFx0aWYgKCFhc3BlY3QgJiYgd2luZG93LmdsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFzcGVjdCA9IGdsLmNhbnZhcy5oZWlnaHQgLyBnbC5jYW52YXMud2lkdGg7XG5cdFx0fVxuXHRcdGlmICghYXNwZWN0KSB7XG5cdFx0XHRhc3BlY3QgPSAxO1xuXHRcdH1cblx0XHRhc3BlY3QgPSB0aGlzLnByb3BlcnRpZXMucHJlc2VydmVfYXNwZWN0ID8gYXNwZWN0IDogMTtcblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLl9zaGFkZXJzW3JhZGl1c10pIHtcblx0XHRcdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5fc2hhZGVyc1tyYWRpdXNdID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIucGl4ZWxfc2hhZGVyLFxuXHRcdFx0XHR7IFJBRElVUzogcmFkaXVzLnRvRml4ZWQoMCkgfVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLl9zaGFkZXJzW3JhZGl1c107XG5cdFx0dmFyIG1lc2ggPSBHTC5NZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHR0ZXguYmluZCgwKTtcblxuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRzaGFkZXJcblx0XHRcdFx0LnVuaWZvcm1zKHtcblx0XHRcdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHRcdFx0dV9pbnRlbnNpdHk6IGludGVuc2l0eSxcblx0XHRcdFx0XHR1X3Jlc29sdXRpb246IFt0ZXgud2lkdGgsIHRleC5oZWlnaHRdLFxuXHRcdFx0XHRcdHVfaVJlc29sdXRpb246IFsxIC8gdGV4LndpZHRoLCAxIC8gdGV4LmhlaWdodF1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHQvL2Zyb20gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L01zWFN6NFxuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIucGl4ZWxfc2hhZGVyID1cblx0XHRcIlxcblxcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcbnZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcbnVuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7XFxuXFxcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXFxcbnVuaWZvcm0gdmVjMiB1X2lSZXNvbHV0aW9uO1xcblxcXG4jaWZuZGVmIFJBRElVU1xcblxcXG5cdCNkZWZpbmUgUkFESVVTIDdcXG5cXFxuI2VuZGlmXFxuXFxcbnZvaWQgbWFpbigpIHtcXG5cXFxuXFxuXFxcblx0Y29uc3QgaW50IHJhZGl1cyA9IFJBRElVUztcXG5cXFxuXHR2ZWMyIGZyYWdDb29yZCA9IHZfY29vcmQ7XFxuXFxcblx0dmVjMiBzcmNfc2l6ZSA9IHVfaVJlc29sdXRpb247XFxuXFxcblx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0ZmxvYXQgbiA9IGZsb2F0KChyYWRpdXMgKyAxKSAqIChyYWRpdXMgKyAxKSk7XFxuXFxcblx0aW50IGk7XFxuXFxcblx0aW50IGo7XFxuXFxcblx0dmVjMyBtMCA9IHZlYzMoMC4wKTsgdmVjMyBtMSA9IHZlYzMoMC4wKTsgdmVjMyBtMiA9IHZlYzMoMC4wKTsgdmVjMyBtMyA9IHZlYzMoMC4wKTtcXG5cXFxuXHR2ZWMzIHMwID0gdmVjMygwLjApOyB2ZWMzIHMxID0gdmVjMygwLjApOyB2ZWMzIHMyID0gdmVjMygwLjApOyB2ZWMzIHMzID0gdmVjMygwLjApO1xcblxcXG5cdHZlYzMgYztcXG5cXFxuXHRcXG5cXFxuXHRmb3IgKGludCBqID0gLXJhZGl1czsgaiA8PSAwOyArK2opICB7XFxuXFxcblx0XHRmb3IgKGludCBpID0gLXJhZGl1czsgaSA8PSAwOyArK2kpICB7XFxuXFxcblx0XHRcdGMgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoaSxqKSAqIHNyY19zaXplKS5yZ2I7XFxuXFxcblx0XHRcdG0wICs9IGM7XFxuXFxcblx0XHRcdHMwICs9IGMgKiBjO1xcblxcXG5cdFx0fVxcblxcXG5cdH1cXG5cXFxuXHRcXG5cXFxuXHRmb3IgKGludCBqID0gLXJhZGl1czsgaiA8PSAwOyArK2opICB7XFxuXFxcblx0XHRmb3IgKGludCBpID0gMDsgaSA8PSByYWRpdXM7ICsraSkgIHtcXG5cXFxuXHRcdFx0YyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMihpLGopICogc3JjX3NpemUpLnJnYjtcXG5cXFxuXHRcdFx0bTEgKz0gYztcXG5cXFxuXHRcdFx0czEgKz0gYyAqIGM7XFxuXFxcblx0XHR9XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAwOyBqIDw9IHJhZGl1czsgKytqKSAge1xcblxcXG5cdFx0Zm9yIChpbnQgaSA9IDA7IGkgPD0gcmFkaXVzOyArK2kpICB7XFxuXFxcblx0XHRcdGMgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoaSxqKSAqIHNyY19zaXplKS5yZ2I7XFxuXFxcblx0XHRcdG0yICs9IGM7XFxuXFxcblx0XHRcdHMyICs9IGMgKiBjO1xcblxcXG5cdFx0fVxcblxcXG5cdH1cXG5cXFxuXHRcXG5cXFxuXHRmb3IgKGludCBqID0gMDsgaiA8PSByYWRpdXM7ICsraikgIHtcXG5cXFxuXHRcdGZvciAoaW50IGkgPSAtcmFkaXVzOyBpIDw9IDA7ICsraSkgIHtcXG5cXFxuXHRcdFx0YyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMihpLGopICogc3JjX3NpemUpLnJnYjtcXG5cXFxuXHRcdFx0bTMgKz0gYztcXG5cXFxuXHRcdFx0czMgKz0gYyAqIGM7XFxuXFxcblx0XHR9XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdGZsb2F0IG1pbl9zaWdtYTIgPSAxZSsyO1xcblxcXG5cdG0wIC89IG47XFxuXFxcblx0czAgPSBhYnMoczAgLyBuIC0gbTAgKiBtMCk7XFxuXFxcblx0XFxuXFxcblx0ZmxvYXQgc2lnbWEyID0gczAuciArIHMwLmcgKyBzMC5iO1xcblxcXG5cdGlmIChzaWdtYTIgPCBtaW5fc2lnbWEyKSB7XFxuXFxcblx0XHRtaW5fc2lnbWEyID0gc2lnbWEyO1xcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChtMCwgMS4wKTtcXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0bTEgLz0gbjtcXG5cXFxuXHRzMSA9IGFicyhzMSAvIG4gLSBtMSAqIG0xKTtcXG5cXFxuXHRcXG5cXFxuXHRzaWdtYTIgPSBzMS5yICsgczEuZyArIHMxLmI7XFxuXFxcblx0aWYgKHNpZ21hMiA8IG1pbl9zaWdtYTIpIHtcXG5cXFxuXHRcdG1pbl9zaWdtYTIgPSBzaWdtYTI7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KG0xLCAxLjApO1xcblxcXG5cdH1cXG5cXFxuXHRcXG5cXFxuXHRtMiAvPSBuO1xcblxcXG5cdHMyID0gYWJzKHMyIC8gbiAtIG0yICogbTIpO1xcblxcXG5cdFxcblxcXG5cdHNpZ21hMiA9IHMyLnIgKyBzMi5nICsgczIuYjtcXG5cXFxuXHRpZiAoc2lnbWEyIDwgbWluX3NpZ21hMikge1xcblxcXG5cdFx0bWluX3NpZ21hMiA9IHNpZ21hMjtcXG5cXFxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQobTIsIDEuMCk7XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdG0zIC89IG47XFxuXFxcblx0czMgPSBhYnMoczMgLyBuIC0gbTMgKiBtMyk7XFxuXFxcblx0XFxuXFxcblx0c2lnbWEyID0gczMuciArIHMzLmcgKyBzMy5iO1xcblxcXG5cdGlmIChzaWdtYTIgPCBtaW5fc2lnbWEyKSB7XFxuXFxcblx0XHRtaW5fc2lnbWEyID0gc2lnbWEyO1xcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChtMywgMS4wKTtcXG5cXFxuXHR9XFxuXFxcbn1cXG5cXFxuXCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL2t1d2FoYXJhXCIsXG5cdFx0TEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyXG5cdCk7XG5cblx0Ly8gVGV4dHVyZSAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiRmlsdGVyZWRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHNpZ21hOiAxLjQsXG5cdFx0XHRrOiAxLjYsXG5cdFx0XHRwOiAyMS43LFxuXHRcdFx0ZXBzaWxvbjogNzksXG5cdFx0XHRwaGk6IDAuMDE3XG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLnRpdGxlID0gXCJYRG9HIEZpbHRlclwiO1xuXHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci5kZXNjID1cblx0XHRcIkZpbHRlcnMgYSB0ZXh0dXJlIGdpdmluZyBhbiBhcnRpc3RpYyBpbmsgc3R5bGVcIjtcblxuXHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci5tYXhfcmFkaXVzID0gMTA7XG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLl9zaGFkZXJzID0gW107XG5cblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRpZiAoXG5cdFx0XHQhdGVtcCB8fFxuXHRcdFx0dGVtcC53aWR0aCAhPSB0ZXgud2lkdGggfHxcblx0XHRcdHRlbXAuaGVpZ2h0ICE9IHRleC5oZWlnaHQgfHxcblx0XHRcdHRlbXAudHlwZSAhPSB0ZXgudHlwZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7XG5cdFx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVYRG9HRmlsdGVyLl94ZG9nX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3hkb2dfc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci54ZG9nX3BpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLl94ZG9nX3NoYWRlcjtcblx0XHR2YXIgbWVzaCA9IEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXG5cdFx0dmFyIHNpZ21hID0gdGhpcy5wcm9wZXJ0aWVzLnNpZ21hO1xuXHRcdHZhciBrID0gdGhpcy5wcm9wZXJ0aWVzLms7XG5cdFx0dmFyIHAgPSB0aGlzLnByb3BlcnRpZXMucDtcblx0XHR2YXIgZXBzaWxvbiA9IHRoaXMucHJvcGVydGllcy5lcHNpbG9uO1xuXHRcdHZhciBwaGkgPSB0aGlzLnByb3BlcnRpZXMucGhpO1xuXHRcdHRleC5iaW5kKDApO1xuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRzaGFkZXJcblx0XHRcdFx0LnVuaWZvcm1zKHtcblx0XHRcdFx0XHRzcmM6IDAsXG5cdFx0XHRcdFx0c2lnbWE6IHNpZ21hLFxuXHRcdFx0XHRcdGs6IGssXG5cdFx0XHRcdFx0cDogcCxcblx0XHRcdFx0XHRlcHNpbG9uOiBlcHNpbG9uLFxuXHRcdFx0XHRcdHBoaTogcGhpLFxuXHRcdFx0XHRcdGN2c1dpZHRoOiB0ZXgud2lkdGgsXG5cdFx0XHRcdFx0Y3ZzSGVpZ2h0OiB0ZXguaGVpZ2h0XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XG5cdH07XG5cblx0Ly9mcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXltb25kTWNHdWlyZS9HUFUtQmFzZWQtSW1hZ2UtUHJvY2Vzc2luZy1Ub29scy9ibG9iL21hc3Rlci9saWJfd2ViZ2wvc2NyaXB0cy9tYWluLmpzXG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLnhkb2dfcGl4ZWxfc2hhZGVyID1cblx0XHRcIlxcblxcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHNyYztcXG5cXG5cXFxudW5pZm9ybSBmbG9hdCBjdnNIZWlnaHQ7XFxuXFxcbnVuaWZvcm0gZmxvYXQgY3ZzV2lkdGg7XFxuXFxuXFxcbnVuaWZvcm0gZmxvYXQgc2lnbWE7XFxuXFxcbnVuaWZvcm0gZmxvYXQgaztcXG5cXFxudW5pZm9ybSBmbG9hdCBwO1xcblxcXG51bmlmb3JtIGZsb2F0IGVwc2lsb247XFxuXFxcbnVuaWZvcm0gZmxvYXQgcGhpO1xcblxcXG52YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXG5cXFxuZmxvYXQgY29zaChmbG9hdCB2YWwpXFxuXFxcbntcXG5cXFxuXHRmbG9hdCB0bXAgPSBleHAodmFsKTtcXG5cXFxuXHRmbG9hdCBjb3NIID0gKHRtcCArIDEuMCAvIHRtcCkgLyAyLjA7XFxuXFxcblx0cmV0dXJuIGNvc0g7XFxuXFxcbn1cXG5cXG5cXFxuZmxvYXQgdGFuaChmbG9hdCB2YWwpXFxuXFxcbntcXG5cXFxuXHRmbG9hdCB0bXAgPSBleHAodmFsKTtcXG5cXFxuXHRmbG9hdCB0YW5IID0gKHRtcCAtIDEuMCAvIHRtcCkgLyAodG1wICsgMS4wIC8gdG1wKTtcXG5cXFxuXHRyZXR1cm4gdGFuSDtcXG5cXFxufVxcblxcblxcXG5mbG9hdCBzaW5oKGZsb2F0IHZhbClcXG5cXFxue1xcblxcXG5cdGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcblxcXG5cdGZsb2F0IHNpbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvIDIuMDtcXG5cXFxuXHRyZXR1cm4gc2luSDtcXG5cXFxufVxcblxcblxcXG52b2lkIG1haW4odm9pZCl7XFxuXFxcblx0dmVjMyBkZXN0Q29sb3IgPSB2ZWMzKDAuMCk7XFxuXFxcblx0ZmxvYXQgdEZyYWcgPSAxLjAgLyBjdnNIZWlnaHQ7XFxuXFxcblx0ZmxvYXQgc0ZyYWcgPSAxLjAgLyBjdnNXaWR0aDtcXG5cXFxuXHR2ZWMyIEZyYWcgPSB2ZWMyKHNGcmFnLHRGcmFnKTtcXG5cXFxuXHR2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnN0O1xcblxcXG5cdGZsb2F0IHR3b1NpZ21hRVNxdWFyZWQgPSAyLjAgKiBzaWdtYSAqIHNpZ21hO1xcblxcXG5cdGZsb2F0IHR3b1NpZ21hUlNxdWFyZWQgPSB0d29TaWdtYUVTcXVhcmVkICogayAqIGs7XFxuXFxcblx0aW50IGhhbGZXaWR0aCA9IGludChjZWlsKCAxLjAgKiBzaWdtYSAqIGsgKSk7XFxuXFxuXFxcblx0Y29uc3QgaW50IE1BWF9OVU1fSVRFUkFUSU9OID0gOTk5OTk7XFxuXFxcblx0dmVjMiBzdW0gPSB2ZWMyKDAuMCk7XFxuXFxcblx0dmVjMiBub3JtID0gdmVjMigwLjApO1xcblxcblxcXG5cdGZvcihpbnQgY250PTA7Y250PE1BWF9OVU1fSVRFUkFUSU9OO2NudCsrKXtcXG5cXFxuXHRcdGlmKGNudCA+ICgyKmhhbGZXaWR0aCsxKSooMipoYWxmV2lkdGgrMSkpe2JyZWFrO31cXG5cXFxuXHRcdGludCBpID0gaW50KGNudCAvICgyKmhhbGZXaWR0aCsxKSkgLSBoYWxmV2lkdGg7XFxuXFxcblx0XHRpbnQgaiA9IGNudCAtIGhhbGZXaWR0aCAtIGludChjbnQgLyAoMipoYWxmV2lkdGgrMSkpICogKDIqaGFsZldpZHRoKzEpO1xcblxcblxcXG5cdFx0ZmxvYXQgZCA9IGxlbmd0aCh2ZWMyKGksaikpO1xcblxcXG5cdFx0dmVjMiBrZXJuZWwgPSB2ZWMyKCBleHAoIC1kICogZCAvIHR3b1NpZ21hRVNxdWFyZWQgKSwgXFxuXFxcblx0XHRcdFx0XHRcdFx0ZXhwKCAtZCAqIGQgLyB0d29TaWdtYVJTcXVhcmVkICkpO1xcblxcblxcXG5cdFx0dmVjMiBMID0gdGV4dHVyZTJEKHNyYywgKHV2ICsgdmVjMihpLGopKSAqIEZyYWcpLnh4O1xcblxcblxcXG5cdFx0bm9ybSArPSBrZXJuZWw7XFxuXFxcblx0XHRzdW0gKz0ga2VybmVsICogTDtcXG5cXFxuXHR9XFxuXFxuXFxcblx0c3VtIC89IG5vcm07XFxuXFxuXFxcblx0ZmxvYXQgSCA9IDEwMC4wICogKCgxLjAgKyBwKSAqIHN1bS54IC0gcCAqIHN1bS55KTtcXG5cXFxuXHRmbG9hdCBlZGdlID0gKCBIID4gZXBzaWxvbiApPyAxLjAgOiAxLjAgKyB0YW5oKCBwaGkgKiAoSCAtIGVwc2lsb24pKTtcXG5cXFxuXHRkZXN0Q29sb3IgPSB2ZWMzKGVkZ2UpO1xcblxcXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoZGVzdENvbG9yLCAxLjApO1xcblxcXG59XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3hEb0dcIiwgTEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIpO1xuXG5cdC8vIFRleHR1cmUgV2ViY2FtICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVXZWJjYW0oKSB7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJXZWJjYW1cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgdGV4dHVyZV9uYW1lOiBcIlwiLCBmYWNpbmdNb2RlOiBcInVzZXJcIiB9O1xuXHRcdHRoaXMuYm94Y29sb3IgPSBcImJsYWNrXCI7XG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0udGl0bGUgPSBcIldlYmNhbVwiO1xuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLmRlc2MgPSBcIldlYmNhbSB0ZXh0dXJlXCI7XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IGZhbHNlO1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLm9wZW5TdHJlYW0gPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEpIHtcblx0XHRcdC8vY29uc29sZS5sb2coJ2dldFVzZXJNZWRpYSgpIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLCB1c2UgY2hyb21lIGFuZCBlbmFibGUgV2ViUlRDIGZyb20gYWJvdXQ6Ly9mbGFncycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uID0gdHJ1ZTtcblxuXHRcdC8vIE5vdCBzaG93aW5nIHZlbmRvciBwcmVmaXhlcy5cblx0XHR2YXIgY29uc3RyYWludHMgPSB7XG5cdFx0XHRhdWRpbzogZmFsc2UsXG5cdFx0XHR2aWRlbzogeyBmYWNpbmdNb2RlOiB0aGlzLnByb3BlcnRpZXMuZmFjaW5nTW9kZSB9XG5cdFx0fTtcblx0XHRuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG5cdFx0XHQuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuXHRcdFx0LnRoZW4odGhpcy5zdHJlYW1SZWFkeS5iaW5kKHRoaXMpKVxuXHRcdFx0LmNhdGNoKG9uRmFpbFNvSGFyZCk7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0ZnVuY3Rpb24gb25GYWlsU29IYXJkKGUpIHtcblx0XHRcdExHcmFwaFRleHR1cmVXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcblx0XHRcdGNvbnNvbGUubG9nKFwiV2ViY2FtIHJlamVjdGVkXCIsIGUpO1xuXHRcdFx0dGhhdC5fd2ViY2FtX3N0cmVhbSA9IGZhbHNlO1xuXHRcdFx0dGhhdC5ib3hjb2xvciA9IFwicmVkXCI7XG5cdFx0XHR0aGF0LnRyaWdnZXIoXCJzdHJlYW1fZXJyb3JcIik7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLmNsb3NlU3RyZWFtID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3dlYmNhbV9zdHJlYW0pIHtcblx0XHRcdHZhciB0cmFja3MgPSB0aGlzLl93ZWJjYW1fc3RyZWFtLmdldFRyYWNrcygpO1xuXHRcdFx0aWYgKHRyYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHR0cmFja3NbaV0uc3RvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRMR3JhcGhUZXh0dXJlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG5cdFx0XHR0aGlzLl93ZWJjYW1fc3RyZWFtID0gbnVsbDtcblx0XHRcdHRoaXMuX3ZpZGVvID0gbnVsbDtcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcImJsYWNrXCI7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJzdHJlYW1fY2xvc2VkXCIpO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5zdHJlYW1SZWFkeSA9IGZ1bmN0aW9uKGxvY2FsTWVkaWFTdHJlYW0pIHtcblx0XHR0aGlzLl93ZWJjYW1fc3RyZWFtID0gbG9jYWxNZWRpYVN0cmVhbTtcblx0XHQvL3RoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5ib3hjb2xvciA9IFwiZ3JlZW5cIjtcblx0XHR2YXIgdmlkZW8gPSB0aGlzLl92aWRlbztcblx0XHRpZiAoIXZpZGVvKSB7XG5cdFx0XHR2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcblx0XHRcdHZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcblx0XHRcdHZpZGVvLnNyY09iamVjdCA9IGxvY2FsTWVkaWFTdHJlYW07XG5cdFx0XHR0aGlzLl92aWRlbyA9IHZpZGVvO1xuXHRcdFx0Ly9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCB2aWRlbyApOyAvL2RlYnVnXG5cdFx0XHQvL3doZW4gdmlkZW8gaW5mbyBpcyBsb2FkZWQgKHNpemUgYW5kIHNvKVxuXHRcdFx0dmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Ly8gUmVhZHkgdG8gZ28uIERvIHNvbWUgc3R1ZmYuXG5cdFx0XHRcdExHcmFwaFRleHR1cmVXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSB0cnVlO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHRoaXMudHJpZ2dlcihcInN0cmVhbV9yZWFkeVwiLCB2aWRlbyk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihcblx0XHRuYW1lLFxuXHRcdHZhbHVlXG5cdCkge1xuXHRcdGlmIChuYW1lID09IFwiZmFjaW5nTW9kZVwiKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuZmFjaW5nTW9kZSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5jbG9zZVN0cmVhbSgpO1xuXHRcdFx0dGhpcy5vcGVuU3RyZWFtKCk7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fd2ViY2FtX3N0cmVhbSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0cmFja3MgPSB0aGlzLl93ZWJjYW1fc3RyZWFtLmdldFRyYWNrcygpO1xuXHRcdGlmICh0cmFja3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0cmFja3NbaV0uc3RvcCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3dlYmNhbV9zdHJlYW0gPSBudWxsO1xuXHRcdHRoaXMuX3ZpZGVvID0gbnVsbDtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkIHx8IHRoaXMuc2l6ZVsxXSA8PSAyMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fdmlkZW8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL3JlbmRlciB0byBncmFwaCBjYW52YXNcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICghY3R4LndlYmdsKSB7XG5cdFx0XHQvL3JldmVyc2UgaW1hZ2Vcblx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5fdmlkZW8sIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX3ZpZGVvX3RleHR1cmUpIHtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShcblx0XHRcdFx0XHR0aGlzLl92aWRlb190ZXh0dXJlLFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR0aGlzLnNpemVbMF0sXG5cdFx0XHRcdFx0dGhpcy5zaXplWzFdXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3dlYmNhbV9zdHJlYW0gPT0gbnVsbCAmJiAhdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24pIHtcblx0XHRcdHRoaXMub3BlblN0cmVhbSgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fdmlkZW8gfHwgIXRoaXMuX3ZpZGVvLnZpZGVvV2lkdGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgd2lkdGggPSB0aGlzLl92aWRlby52aWRlb1dpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLl92aWRlby52aWRlb0hlaWdodDtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdmlkZW9fdGV4dHVyZTtcblx0XHRpZiAoIXRlbXAgfHwgdGVtcC53aWR0aCAhPSB3aWR0aCB8fCB0ZW1wLmhlaWdodCAhPSBoZWlnaHQpIHtcblx0XHRcdHRoaXMuX3ZpZGVvX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCB7XG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlkZW9fdGV4dHVyZS51cGxvYWRJbWFnZSh0aGlzLl92aWRlbyk7XG5cdFx0dGhpcy5fdmlkZW9fdGV4dHVyZS52ZXJzaW9uID0gKyt0aGlzLnZlcnNpb247XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnRleHR1cmVfbmFtZSkge1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZXNDb250YWluZXIoKTtcblx0XHRcdGNvbnRhaW5lclt0aGlzLnByb3BlcnRpZXMudGV4dHVyZV9uYW1lXSA9IHRoaXMuX3ZpZGVvX3RleHR1cmU7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZpZGVvX3RleHR1cmUpO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRpZiAoIXRoaXMub3V0cHV0c1tpXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAodGhpcy5vdXRwdXRzW2ldLm5hbWUpIHtcblx0XHRcdFx0Y2FzZSBcIndpZHRoXCI6XG5cdFx0XHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX3ZpZGVvLnZpZGVvV2lkdGgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiaGVpZ2h0XCI6XG5cdFx0XHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX3ZpZGVvLnZpZGVvSGVpZ2h0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcIndpZHRoXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiaGVpZ2h0XCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wic3RyZWFtX3JlYWR5XCIsIExpdGVHcmFwaC5FVkVOVF0sXG5cdFx0XHRbXCJzdHJlYW1fY2xvc2VkXCIsIExpdGVHcmFwaC5FVkVOVF0sXG5cdFx0XHRbXCJzdHJlYW1fZXJyb3JcIiwgTGl0ZUdyYXBoLkVWRU5UXVxuXHRcdF07XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3dlYmNhbVwiLCBMR3JhcGhUZXh0dXJlV2ViY2FtKTtcblxuXHQvL2Zyb20gaHR0cHM6Ly9naXRodWIuY29tL3NwaXRlL1dhZ25lclxuXHRmdW5jdGlvbiBMR3JhcGhMZW5zRlgoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiZlwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdGZhY3RvcjogMSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5MT1dcblx0XHR9O1xuXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7IHVfdGV4dHVyZTogMCwgdV9mYWN0b3I6IDEgfTtcblx0fVxuXG5cdExHcmFwaExlbnNGWC50aXRsZSA9IFwiTGVucyBGWFwiO1xuXHRMR3JhcGhMZW5zRlguZGVzYyA9IFwiZGlzdG9ydGlvbiBhbmQgY2hyb21hdGljIGFiZXJyYXRpb25cIjtcblxuXHRMR3JhcGhMZW5zRlgud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhMZW5zRlgucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJlbmFibGVkXCIsIFwiYm9vbGVhblwiXV07XG5cdH07XG5cblx0TEdyYXBoTGVuc0ZYLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0ggfHxcblx0XHRcdHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZW5hYmxlZFwiKSA9PT0gZmFsc2Vcblx0XHQpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0eyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhMZW5zRlguX3NoYWRlcjtcblx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoTGVuc0ZYLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaExlbnNGWC5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGZhY3RvciA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdGlmIChmYWN0b3IgPT0gbnVsbCkge1xuXHRcdFx0ZmFjdG9yID0gdGhpcy5wcm9wZXJ0aWVzLmZhY3Rvcjtcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X2ZhY3RvciA9IGZhY3RvcjtcblxuXHRcdC8vYXBwbHkgc2hhZGVyXG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR0ZW1wLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wKTtcblx0fTtcblxuXHRMR3JhcGhMZW5zRlgucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ZhY3RvcjtcXG5cXFxuXHRcdHZlYzIgYmFycmVsRGlzdG9ydGlvbih2ZWMyIGNvb3JkLCBmbG9hdCBhbXQpIHtcXG5cXFxuXHRcdFx0dmVjMiBjYyA9IGNvb3JkIC0gMC41O1xcblxcXG5cdFx0XHRmbG9hdCBkaXN0ID0gZG90KGNjLCBjYyk7XFxuXFxcblx0XHRcdHJldHVybiBjb29yZCArIGNjICogZGlzdCAqIGFtdDtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0ZmxvYXQgc2F0KCBmbG9hdCB0IClcXG5cXFxuXHRcdHtcXG5cXFxuXHRcdFx0cmV0dXJuIGNsYW1wKCB0LCAwLjAsIDEuMCApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBsaW50ZXJwKCBmbG9hdCB0ICkge1xcblxcXG5cdFx0XHRyZXR1cm4gc2F0KCAxLjAgLSBhYnMoIDIuMCp0IC0gMS4wICkgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0ZmxvYXQgcmVtYXAoIGZsb2F0IHQsIGZsb2F0IGEsIGZsb2F0IGIgKSB7XFxuXFxcblx0XHRcdHJldHVybiBzYXQoICh0IC0gYSkgLyAoYiAtIGEpICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZlYzQgc3BlY3RydW1fb2Zmc2V0KCBmbG9hdCB0ICkge1xcblxcXG5cdFx0XHR2ZWM0IHJldDtcXG5cXFxuXHRcdFx0ZmxvYXQgbG8gPSBzdGVwKHQsMC41KTtcXG5cXFxuXHRcdFx0ZmxvYXQgaGkgPSAxLjAtbG87XFxuXFxcblx0XHRcdGZsb2F0IHcgPSBsaW50ZXJwKCByZW1hcCggdCwgMS4wLzYuMCwgNS4wLzYuMCApICk7XFxuXFxcblx0XHRcdHJldCA9IHZlYzQobG8sMS4wLGhpLCAxLikgKiB2ZWM0KDEuMC13LCB3LCAxLjAtdywgMS4pO1xcblxcXG5cdFx0XFxuXFxcblx0XHRcdHJldHVybiBwb3coIHJldCwgdmVjNCgxLjAvMi4yKSApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRjb25zdCBmbG9hdCBtYXhfZGlzdG9ydCA9IDIuMjtcXG5cXFxuXHRcdGNvbnN0IGludCBudW1faXRlciA9IDEyO1xcblxcXG5cdFx0Y29uc3QgZmxvYXQgcmVjaV9udW1faXRlcl9mID0gMS4wIC8gZmxvYXQobnVtX2l0ZXIpO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKVxcblxcXG5cdFx0e1x0XFxuXFxcblx0XHRcdHZlYzIgdXY9dl9jb29yZDtcXG5cXFxuXHRcdFx0dmVjNCBzdW1jb2wgPSB2ZWM0KDAuMCk7XFxuXFxcblx0XHRcdHZlYzQgc3VtdyA9IHZlYzQoMC4wKTtcdFxcblxcXG5cdFx0XHRmb3IgKCBpbnQgaT0wOyBpPG51bV9pdGVyOysraSApXFxuXFxcblx0XHRcdHtcXG5cXFxuXHRcdFx0XHRmbG9hdCB0ID0gZmxvYXQoaSkgKiByZWNpX251bV9pdGVyX2Y7XFxuXFxcblx0XHRcdFx0dmVjNCB3ID0gc3BlY3RydW1fb2Zmc2V0KCB0ICk7XFxuXFxcblx0XHRcdFx0c3VtdyArPSB3O1xcblxcXG5cdFx0XHRcdHN1bWNvbCArPSB3ICogdGV4dHVyZTJEKCB1X3RleHR1cmUsIGJhcnJlbERpc3RvcnRpb24odXYsIC42ICogbWF4X2Rpc3RvcnQqdCAqIHVfZmFjdG9yICkgKTtcXG5cXFxuXHRcdFx0fVxcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBzdW1jb2wgLyBzdW13O1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9sZW5zZnhcIiwgTEdyYXBoTGVuc0ZYKTtcblxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVGcm9tRGF0YSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuTE9XLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBjaGFubmVsczogMSB9O1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVGcm9tRGF0YS50aXRsZSA9IFwiRGF0YS0+VGV4XCI7XG5cdExHcmFwaFRleHR1cmVGcm9tRGF0YS5kZXNjID0gXCJHZW5lcmF0ZXMgb3IgYXBwbGllcyBhIGN1cnZlIHRvIGEgdGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlRnJvbURhdGEud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlRnJvbURhdGEucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmKCFkYXRhKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIGNoYW5uZWxzID0gdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxzO1xuXHRcdHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5wcm9wZXJ0aWVzLmhlaWdodDtcblx0XHRpZighdyB8fCAhaClcblx0XHR7XG5cdFx0XHR3ID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIGNoYW5uZWxzKTtcblx0XHRcdGggPSAxO1xuXHRcdH1cblx0XHR2YXIgZm9ybWF0ID0gZ2wuUkdCQTtcblx0XHRpZiggY2hhbm5lbHMgPT0gMyApXG5cdFx0XHRmb3JtYXQgPSBnbC5SR0I7XG5cdFx0ZWxzZSBpZiggY2hhbm5lbHMgPT0gMSApXG5cdFx0XHRmb3JtYXQgPSBnbC5MVU1JTkFOQ0U7XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gKTtcblx0XHRpZiAoICF0ZW1wIHx8IHRlbXAud2lkdGggIT0gdyB8fCB0ZW1wLmhlaWdodCAhPSBoIHx8IHRlbXAudHlwZSAhPSB0eXBlICkge1xuXHRcdFx0dGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKCB3LCBoLCB7IHR5cGU6IHR5cGUsIGZvcm1hdDogZm9ybWF0LCBmaWx0ZXI6IGdsLkxJTkVBUiB9ICk7XG5cdFx0fVxuXG5cdFx0dGVtcC51cGxvYWREYXRhKCBkYXRhICk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2Zyb21kYXRhXCIsIExHcmFwaFRleHR1cmVGcm9tRGF0YSk7XG5cblx0Ly9hcHBsaWVzIGEgY3VydmUgKG9yIGdlbmVyYXRlcyBvbmUpXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVDdXJ2ZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5MT1csIHNwbGl0X2NoYW5uZWxzOiBmYWxzZSB9O1xuXHRcdHRoaXMuX3ZhbHVlcyA9IG5ldyBVaW50OEFycmF5KDI1Nio0KTtcblx0XHR0aGlzLl92YWx1ZXMuZmlsbCgyNTUpO1xuXHRcdHRoaXMuX2N1cnZlX3RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0geyB1X3RleHR1cmU6IDAsIHVfY3VydmU6IDEsIHVfcmFuZ2U6IDEuMCB9O1xuXHRcdHRoaXMuX211c3RfdXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9wb2ludHMgPSB7XG5cdFx0XHRSR0I6IFtbMCwwXSxbMSwxXV0sXG5cdFx0XHRSOiBbWzAsMF0sWzEsMV1dLFxuXHRcdFx0RzogW1swLDBdLFsxLDFdXSxcblx0XHRcdEI6IFtbMCwwXSxbMSwxXV1cblx0XHR9O1xuXHRcdHRoaXMuY3VydmVfZWRpdG9yID0gbnVsbDtcblx0XHR0aGlzLmFkZFdpZGdldChcInRvZ2dsZVwiLFwiU3BsaXQgQ2hhbm5lbHNcIixmYWxzZSxcInNwbGl0X2NoYW5uZWxzXCIpO1xuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcIkNoYW5uZWxcIixcIlJHQlwiLHsgdmFsdWVzOltcIlJHQlwiLFwiUlwiLFwiR1wiLFwiQlwiXX0pO1xuXHRcdHRoaXMuY3VydmVfb2Zmc2V0ID0gNjg7XG5cdFx0dGhpcy5zaXplID0gWyAyNDAsIDE2MCBdO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnRpdGxlID0gXCJDdXJ2ZVwiO1xuXHRMR3JhcGhUZXh0dXJlQ3VydmUuZGVzYyA9IFwiR2VuZXJhdGVzIG9yIGFwcGxpZXMgYSBjdXJ2ZSB0byBhIHRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZUN1cnZlLndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0aWYoIXRleCkgLy9nZW5lcmF0ZSBvbmUgdGV4dHVyZSwgbm90aGluZyBlbHNlXG5cdFx0e1xuXHRcdFx0aWYodGhpcy5fbXVzdF91cGRhdGUgfHwgIXRoaXMuX2N1cnZlX3RleHR1cmUgKVxuXHRcdFx0XHR0aGlzLnVwZGF0ZUN1cnZlKCk7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fY3VydmVfdGV4dHVyZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGUgPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlKCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uLCB0ZXggKTtcblx0XHRcblx0XHQvL2FwcGx5IGN1cnZlIHRvIGlucHV0IHRleHR1cmVcblx0XHRpZiAoICF0ZW1wIHx8IHRlbXAudHlwZSAhPSB0eXBlIHx8IHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8IHRlbXAuaGVpZ2h0ICE9IHRleC5oZWlnaHQgfHwgdGVtcC5mb3JtYXQgIT0gdGV4LmZvcm1hdClcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSggdGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7IHR5cGU6IHR5cGUsIGZvcm1hdDogdGV4LmZvcm1hdCwgZmlsdGVyOiBnbC5MSU5FQVIgfSApO1xuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVDdXJ2ZS5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhUZXh0dXJlQ3VydmUuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUN1cnZlLnBpeGVsX3NoYWRlciApO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuX211c3RfdXBkYXRlIHx8ICF0aGlzLl9jdXJ2ZV90ZXh0dXJlIClcblx0XHRcdHRoaXMudXBkYXRlQ3VydmUoKTtcblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHZhciBjdXJ2ZV90ZXh0dXJlID0gdGhpcy5fY3VydmVfdGV4dHVyZTtcblxuXHRcdC8vYXBwbHkgc2hhZGVyXG5cdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRjdXJ2ZV90ZXh0dXJlLmJpbmQoMSk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZSA9IGZ1bmN0aW9uKGYscG9pbnRzKVxuXHR7XG5cdFx0dmFyIHBvaW50cyA9IHBvaW50cyB8fCB0aGlzLl9wb2ludHMuUkdCO1xuXHRcdGlmKCFwb2ludHMpXG5cdFx0XHRyZXR1cm47XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHR2YXIgcG4gPSBwb2ludHNbaSsxXTtcblx0XHRcdGlmKHBuWzBdIDwgZilcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgciA9IChwblswXSAtIHBbMF0pO1xuXHRcdFx0aWYoIE1hdGguYWJzKHIpIDwgMC4wMDAwMSApXG5cdFx0XHRcdHJldHVybiBwWzFdO1xuXHRcdFx0dmFyIGxvY2FsX2YgPSAoZiAtIHBbMF0pIC8gcjtcblx0XHRcdHJldHVybiBwWzFdICogKDEuMCAtIGxvY2FsX2YpICsgcG5bMV0gKiBsb2NhbF9mO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5wcm90b3R5cGUudXBkYXRlQ3VydmUgPSBmdW5jdGlvbigpXG5cdHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuXHRcdHZhciBudW0gPSB2YWx1ZXMubGVuZ3RoIC8gNDtcblx0XHR2YXIgc3BsaXQgPSB0aGlzLnByb3BlcnRpZXMuc3BsaXRfY2hhbm5lbHM7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG51bTsgKytpKVxuXHRcdHtcblx0XHRcdGlmKHNwbGl0KVxuXHRcdFx0e1xuXHRcdFx0XHR2YWx1ZXNbaSo0XSA9IE1hdGguY2xhbXAoIHRoaXMuc2FtcGxlQ3VydmUoaS9udW0sdGhpcy5fcG9pbnRzLlIpKjI1NSwwLDI1NSk7XG5cdFx0XHRcdHZhbHVlc1tpKjQrMV0gPSBNYXRoLmNsYW1wKCB0aGlzLnNhbXBsZUN1cnZlKGkvbnVtLHRoaXMuX3BvaW50cy5HKSoyNTUsMCwyNTUpO1xuXHRcdFx0XHR2YWx1ZXNbaSo0KzJdID0gTWF0aC5jbGFtcCggdGhpcy5zYW1wbGVDdXJ2ZShpL251bSx0aGlzLl9wb2ludHMuQikqMjU1LDAsMjU1KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnNhbXBsZUN1cnZlKGkvbnVtKTsvL3NhbXBsZSBjdXJ2ZVxuXHRcdFx0XHR2YWx1ZXNbaSo0XSA9IHZhbHVlc1tpKjQrMV0gPSB2YWx1ZXNbaSo0KzJdID0gTWF0aC5jbGFtcCh2KjI1NSwwLDI1NSk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZXNbaSo0KzNdID0gMjU1OyAvL2FscGhhIGZpeGVkXG5cdFx0fVxuXHRcdGlmKCF0aGlzLl9jdXJ2ZV90ZXh0dXJlKVxuXHRcdFx0dGhpcy5fY3VydmVfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKDI1NiwxLHsgZm9ybWF0OiBnbC5SR0JBLCBtYWdGaWx0ZXI6IGdsLkxJTkVBUiwgd3JhcDogZ2wuQ0xBTVBfVE9fRURHRSB9KTtcblx0XHR0aGlzLl9jdXJ2ZV90ZXh0dXJlLnVwbG9hZERhdGEodmFsdWVzLG51bGwsdHJ1ZSk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uU2VyaWFsaXplID0gZnVuY3Rpb24obylcblx0e1xuXHRcdHZhciBjdXJ2ZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgaW4gdGhpcy5fcG9pbnRzKVxuXHRcdFx0Y3VydmVzW2ldID0gdGhpcy5fcG9pbnRzW2ldLmNvbmNhdCgpO1xuXHRcdG8uY3VydmVzID0gY3VydmVzO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pXG5cdHtcblx0XHR0aGlzLl9wb2ludHMgPSBvLmN1cnZlcztcblx0XHRpZih0aGlzLmN1cnZlX2VkaXRvcilcblx0XHRcdGN1cnZlX2VkaXRvci5wb2ludHMgPSB0aGlzLl9wb2ludHM7XG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGxvY2FscG9zLCBncmFwaGNhbnZhcylcblx0e1xuXHRcdGlmKHRoaXMuY3VydmVfZWRpdG9yKVxuXHRcdHtcblx0XHRcdHZhciByID0gdGhpcy5jdXJ2ZV9lZGl0b3Iub25Nb3VzZURvd24oW2xvY2FscG9zWzBdLGxvY2FscG9zWzFdLXRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMpO1xuXHRcdFx0aWYocilcblx0XHRcdFx0dGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSwgbG9jYWxwb3MsIGdyYXBoY2FudmFzKVxuXHR7XG5cdFx0aWYodGhpcy5jdXJ2ZV9lZGl0b3IpXG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJ2ZV9lZGl0b3Iub25Nb3VzZU1vdmUoW2xvY2FscG9zWzBdLGxvY2FscG9zWzFdLXRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlLCBsb2NhbHBvcywgZ3JhcGhjYW52YXMpXG5cdHtcblx0XHRpZih0aGlzLmN1cnZlX2VkaXRvcilcblx0XHRcdHJldHVybiB0aGlzLmN1cnZlX2VkaXRvci5vbk1vdXNlVXAoW2xvY2FscG9zWzBdLGxvY2FscG9zWzFdLXRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMpO1xuXHRcdHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzID0geyBcIlJHQlwiOlwiIzY2NlwiLFwiUlwiOlwiI0YzM1wiLFwiR1wiOlwiIzNGM1wiLFwiQlwiOlwiIzMzRlwiIH07XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4LCBncmFwaGNhbnZhcylcblx0e1xuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYoIXRoaXMuY3VydmVfZWRpdG9yKVxuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IgPSBuZXcgTGl0ZUdyYXBoLkN1cnZlRWRpdG9yKHRoaXMuX3BvaW50cy5SKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC50cmFuc2xhdGUoMCx0aGlzLmN1cnZlX29mZnNldCk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLndpZGdldHNbMV0udmFsdWU7XG5cblx0XHRpZih0aGlzLnByb3BlcnRpZXMuc3BsaXRfY2hhbm5lbHMpXG5cdFx0e1xuXHRcdFx0aWYoY2hhbm5lbCA9PSBcIlJHQlwiKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLndpZGdldHNbMV0udmFsdWUgPSBjaGFubmVsID0gXCJSXCI7XG5cdFx0XHRcdHRoaXMud2lkZ2V0c1sxXS5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IucG9pbnRzID0gdGhpcy5fcG9pbnRzLlI7XG5cdFx0XHR0aGlzLmN1cnZlX2VkaXRvci5kcmF3KCBjdHgsIFt0aGlzLnNpemVbMF0sdGhpcy5zaXplWzFdIC0gdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcywgXCIjMTExXCIsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzLlIsIHRydWUgKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImxpZ2h0ZW5cIjtcblx0XHRcdHRoaXMuY3VydmVfZWRpdG9yLnBvaW50cyA9IHRoaXMuX3BvaW50cy5HO1xuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IuZHJhdyggY3R4LCBbdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSAtIHRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMsIG51bGwsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzLkcsIHRydWUgKTtcblx0XHRcdHRoaXMuY3VydmVfZWRpdG9yLnBvaW50cyA9IHRoaXMuX3BvaW50cy5CO1xuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IuZHJhdyggY3R4LCBbdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSAtIHRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMsIG51bGwsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzLkIsIHRydWUgKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLndpZGdldHNbMV0udmFsdWUgPSBjaGFubmVsID0gXCJSR0JcIjtcblx0XHRcdHRoaXMud2lkZ2V0c1sxXS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJ2ZV9lZGl0b3IucG9pbnRzID0gdGhpcy5fcG9pbnRzW2NoYW5uZWxdO1xuXHRcdHRoaXMuY3VydmVfZWRpdG9yLmRyYXcoIGN0eCwgW3RoaXMuc2l6ZVswXSx0aGlzLnNpemVbMV0gLSB0aGlzLmN1cnZlX29mZnNldF0sIGdyYXBoY2FudmFzLCB0aGlzLnByb3BlcnRpZXMuc3BsaXRfY2hhbm5lbHMgPyBudWxsIDogXCIjMTExXCIsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzW2NoYW5uZWxdICApO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9jdXJ2ZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9yYW5nZTtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKSAqIHVfcmFuZ2U7XFxuXFxcblx0XHRcdGNvbG9yLnggPSB0ZXh0dXJlMkQoIHVfY3VydmUsIHZlYzIoIGNvbG9yLngsIDAuNSApICkueDtcXG5cXFxuXHRcdFx0Y29sb3IueSA9IHRleHR1cmUyRCggdV9jdXJ2ZSwgdmVjMiggY29sb3IueSwgMC41ICkgKS55O1xcblxcXG5cdFx0XHRjb2xvci56ID0gdGV4dHVyZTJEKCB1X2N1cnZlLCB2ZWMyKCBjb2xvci56LCAwLjUgKSApLno7XFxuXFxcblx0XHRcdC8vY29sb3IudyA9IHRleHR1cmUyRCggdV9jdXJ2ZSwgdmVjMiggY29sb3IudywgMC41ICkgKS53O1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxuXHRcdH1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY3VydmVcIiwgTEdyYXBoVGV4dHVyZUN1cnZlKTtcblxuXHQvL3NpbXBsZSBleHBvc2l0aW9uLCBidXQgcGxhbiB0byBleHBhbmQgaXQgdG8gc3VwcG9ydCBkaWZmZXJlbnQgZ2FtbWEgY3VydmVzXG5cdGZ1bmN0aW9uIExHcmFwaEV4cG9zaXRpb24oKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiZXhwXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGV4cG9zaXRpb246IDEsIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5MT1cgfTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiAwLCB1X2V4cG9zaXRpb246IDEgfTtcblx0fVxuXG5cdExHcmFwaEV4cG9zaXRpb24udGl0bGUgPSBcIkV4cG9zaXRpb25cIjtcblx0TEdyYXBoRXhwb3NpdGlvbi5kZXNjID0gXCJDb250cm9scyB0ZXh0dXJlIGV4cG9zaXRpb25cIjtcblxuXHRMR3JhcGhFeHBvc2l0aW9uLndpZGdldHNfaW5mbyA9IHtcblx0XHRleHBvc2l0aW9uOiB7IHdpZGdldDogXCJzbGlkZXJcIiwgbWluOiAwLCBtYXg6IDMgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoRXhwb3NpdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0eyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhFeHBvc2l0aW9uLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaEV4cG9zaXRpb24uX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoRXhwb3NpdGlvbi5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGV4cCA9IHRoaXMucHJvcGVydGllcy5leHBvc2l0aW9uO1xuXHRcdHZhciBleHBfaW5wdXQgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoZXhwX2lucHV0ICE9IG51bGwpIHtcblx0XHRcdGV4cCA9IHRoaXMucHJvcGVydGllcy5leHBvc2l0aW9uID0gZXhwX2lucHV0O1xuXHRcdH1cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3JtcztcblxuXHRcdC8vYXBwbHkgc2hhZGVyXG5cdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdExHcmFwaEV4cG9zaXRpb24ucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2V4cG9zaXRpb247XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICk7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLnh5eiAqIHVfZXhwb3NpdGlvbiwgY29sb3IuYSApO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9leHBvc2l0aW9uXCIsIExHcmFwaEV4cG9zaXRpb24pO1xuXG5cdGZ1bmN0aW9uIExHcmFwaFRvbmVNYXBwaW5nKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcImF2Z1wiLCBcIm51bWJlcixUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0c2NhbGU6IDEsXG5cdFx0XHRnYW1tYTogMSxcblx0XHRcdGF2ZXJhZ2VfbHVtOiAxLFxuXHRcdFx0bHVtX3doaXRlOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPV1xuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfbHVtd2hpdGUyOiAxLFxuXHRcdFx0dV9pZ2FtbWE6IDEsXG5cdFx0XHR1X3NjYWxlOiAxLFxuXHRcdFx0dV9hdmVyYWdlX2x1bTogMVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUb25lTWFwcGluZy50aXRsZSA9IFwiVG9uZSBNYXBwaW5nXCI7XG5cdExHcmFwaFRvbmVNYXBwaW5nLmRlc2MgPVxuXHRcdFwiQXBwbGllcyBUb25lIE1hcHBpbmcgdG8gY29udmVydCBmcm9tIGhpZ2ggdG8gbG93XCI7XG5cblx0TEdyYXBoVG9uZU1hcHBpbmcud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUb25lTWFwcGluZy5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUb25lTWFwcGluZy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmIChcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIIHx8XG5cdFx0XHR0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImVuYWJsZWRcIikgPT09IGZhbHNlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblxuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0eyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBhdmcgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoYXZnID09IG51bGwpIHtcblx0XHRcdGF2ZyA9IHRoaXMucHJvcGVydGllcy5hdmVyYWdlX2x1bTtcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR2YXIgc2hhZGVyID0gbnVsbDtcblxuXHRcdGlmIChhdmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmF2ZXJhZ2VfbHVtID0gYXZnO1xuXHRcdFx0dW5pZm9ybXMudV9hdmVyYWdlX2x1bSA9IHRoaXMucHJvcGVydGllcy5hdmVyYWdlX2x1bTtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRvbmVNYXBwaW5nLl9zaGFkZXI7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRzaGFkZXIgPSBMR3JhcGhUb25lTWFwcGluZy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0TEdyYXBoVG9uZU1hcHBpbmcucGl4ZWxfc2hhZGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChhdmcuY29uc3RydWN0b3IgPT09IEdMLlRleHR1cmUpIHtcblx0XHRcdHVuaWZvcm1zLnVfYXZlcmFnZV90ZXh0dXJlID0gYXZnLmJpbmQoMSk7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhUb25lTWFwcGluZy5fc2hhZGVyX3RleHR1cmU7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRzaGFkZXIgPSBMR3JhcGhUb25lTWFwcGluZy5fc2hhZGVyX3RleHR1cmUgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUb25lTWFwcGluZy5waXhlbF9zaGFkZXIsXG5cdFx0XHRcdFx0eyBBVkdfVEVYVFVSRTogXCJcIiB9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMudV9sdW13aGl0ZTIgPVxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmx1bV93aGl0ZSAqIHRoaXMucHJvcGVydGllcy5sdW1fd2hpdGU7XG5cdFx0dW5pZm9ybXMudV9zY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZTtcblx0XHR1bmlmb3Jtcy51X2lnYW1tYSA9IDEgLyB0aGlzLnByb3BlcnRpZXMuZ2FtbWE7XG5cblx0XHQvL2FwcGx5IHNoYWRlclxuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhHTC5NZXNoLmdldFNjcmVlblF1YWQoKSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMR3JhcGhUb25lTWFwcGluZy5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxuXFxcblx0XHQjaWZkZWYgQVZHX1RFWFRVUkVcXG5cXFxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9hdmVyYWdlX3RleHR1cmU7XFxuXFxcblx0XHQjZWxzZVxcblxcXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfYXZlcmFnZV9sdW07XFxuXFxcblx0XHQjZW5kaWZcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9sdW13aGl0ZTI7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaWdhbW1hO1xcblxcXG5cdFx0dmVjMyBSR0IyeHlZICh2ZWMzIHJnYilcXG5cXFxuXHRcdHtcXG5cXFxuXHRcdFx0IGNvbnN0IG1hdDMgUkdCMlhZWiA9IG1hdDMoMC40MTI0LCAwLjM1NzYsIDAuMTgwNSxcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgMC4yMTI2LCAwLjcxNTIsIDAuMDcyMixcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgMC4wMTkzLCAwLjExOTIsIDAuOTUwNSk7XFxuXFxcblx0XHRcdHZlYzMgWFlaID0gUkdCMlhZWiAqIHJnYjtcXG5cXFxuXHRcdFx0XFxuXFxcblx0XHRcdGZsb2F0IGYgPSAoWFlaLnggKyBYWVoueSArIFhZWi56KTtcXG5cXFxuXHRcdFx0cmV0dXJuIHZlYzMoWFlaLnggLyBmLFxcblxcXG5cdFx0XHRcdFx0XHRYWVoueSAvIGYsXFxuXFxcblx0XHRcdFx0XHRcdFhZWi55KTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKTtcXG5cXFxuXHRcdFx0dmVjMyByZ2IgPSBjb2xvci54eXo7XFxuXFxcblx0XHRcdGZsb2F0IGF2ZXJhZ2VfbHVtID0gMC4wO1xcblxcXG5cdFx0XHQjaWZkZWYgQVZHX1RFWFRVUkVcXG5cXFxuXHRcdFx0XHR2ZWMzIHBpeGVsID0gdGV4dHVyZTJEKHVfYXZlcmFnZV90ZXh0dXJlLHZlYzIoMC41KSkueHl6O1xcblxcXG5cdFx0XHRcdGF2ZXJhZ2VfbHVtID0gKHBpeGVsLnggKyBwaXhlbC55ICsgcGl4ZWwueikgLyAzLjA7XFxuXFxcblx0XHRcdCNlbHNlXFxuXFxcblx0XHRcdFx0YXZlcmFnZV9sdW0gPSB1X2F2ZXJhZ2VfbHVtO1xcblxcXG5cdFx0XHQjZW5kaWZcXG5cXFxuXHRcdFx0Ly9MZCAtIHRoaXMgcGFydCBvZiB0aGUgY29kZSBpcyB0aGUgc2FtZSBmb3IgYm90aCB2ZXJzaW9uc1xcblxcXG5cdFx0XHRmbG9hdCBsdW0gPSBkb3QocmdiLCB2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgTCA9ICh1X3NjYWxlIC8gYXZlcmFnZV9sdW0pICogbHVtO1xcblxcXG5cdFx0XHRmbG9hdCBMZCA9IChMICogKDEuMCArIEwgLyB1X2x1bXdoaXRlMikpIC8gKDEuMCArIEwpO1xcblxcXG5cdFx0XHQvL2ZpcnN0XFxuXFxcblx0XHRcdC8vdmVjMyB4eVkgPSBSR0IyeHlZKHJnYik7XFxuXFxcblx0XHRcdC8veHlZLnogKj0gTGQ7XFxuXFxcblx0XHRcdC8vcmdiID0geHlZdG9SR0IoeHlZKTtcXG5cXFxuXHRcdFx0Ly9zZWNvbmRcXG5cXFxuXHRcdFx0cmdiID0gKHJnYiAvIGx1bSkgKiBMZDtcXG5cXFxuXHRcdFx0cmdiID0gbWF4KHJnYix2ZWMzKDAuMDAxKSk7XFxuXFxcblx0XHRcdHJnYiA9IHBvdyggcmdiLCB2ZWMzKCB1X2lnYW1tYSApICk7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHJnYiwgY29sb3IuYSApO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS90b25lbWFwcGluZ1wiLCBMR3JhcGhUb25lTWFwcGluZyk7XG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVBlcmxpbigpIHtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0d2lkdGg6IDUxMixcblx0XHRcdGhlaWdodDogNTEyLFxuXHRcdFx0c2VlZDogMCxcblx0XHRcdHBlcnNpc3RlbmNlOiAwLjEsXG5cdFx0XHRvY3RhdmVzOiA4LFxuXHRcdFx0c2NhbGU6IDEsXG5cdFx0XHRvZmZzZXQ6IFswLCAwXSxcblx0XHRcdGFtcGxpdHVkZTogMSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0XHR0aGlzLl9rZXkgPSAwO1xuXHRcdHRoaXMuX3RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV9wZXJzaXN0ZW5jZTogMC4xLFxuXHRcdFx0dV9zZWVkOiAwLFxuXHRcdFx0dV9vZmZzZXQ6IHZlYzIuY3JlYXRlKCksXG5cdFx0XHR1X3NjYWxlOiAxLFxuXHRcdFx0dV92aWV3cG9ydDogdmVjMi5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlUGVybGluLnRpdGxlID0gXCJQZXJsaW5cIjtcblx0TEdyYXBoVGV4dHVyZVBlcmxpbi5kZXNjID0gXCJHZW5lcmF0ZXMgYSBwZXJsaW4gbm9pc2UgdGV4dHVyZVwiO1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH0sXG5cdFx0d2lkdGg6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxIH0sXG5cdFx0aGVpZ2h0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHByZWNpc2lvbjogMCwgc3RlcDogMSB9LFxuXHRcdG9jdGF2ZXM6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxLCBtaW46IDEsIG1heDogNTAgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcInNlZWRcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJwZXJzaXN0ZW5jZVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIm9jdGF2ZXNcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJzY2FsZVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImFtcGxpdHVkZVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIm9mZnNldFwiLCBcInZlYzJcIl1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdyA9IHRoaXMucHJvcGVydGllcy53aWR0aCB8IDA7XG5cdFx0dmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0IHwgMDtcblx0XHRpZiAodyA9PSAwKSB7XG5cdFx0XHR3ID0gZ2wudmlld3BvcnRfZGF0YVsyXTtcblx0XHR9IC8vMCBtZWFucyBkZWZhdWx0XG5cdFx0aWYgKGggPT0gMCkge1xuXHRcdFx0aCA9IGdsLnZpZXdwb3J0X2RhdGFbM107XG5cdFx0fSAvLzAgbWVhbnMgZGVmYXVsdFxuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uKTtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGV4dHVyZTtcblx0XHRpZiAoXG5cdFx0XHQhdGVtcCB8fFxuXHRcdFx0dGVtcC53aWR0aCAhPSB3IHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSBoIHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdHlwZVxuXHRcdCkge1xuXHRcdFx0dGVtcCA9IHRoaXMuX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3LCBoLCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHBlcnNpc3RlbmNlID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJwZXJzaXN0ZW5jZVwiKTtcblx0XHR2YXIgb2N0YXZlcyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwib2N0YXZlc1wiKTtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJvZmZzZXRcIik7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJzY2FsZVwiKTtcblx0XHR2YXIgYW1wbGl0dWRlID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJhbXBsaXR1ZGVcIik7XG5cdFx0dmFyIHNlZWQgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInNlZWRcIik7XG5cblx0XHQvL3JldXNpbmcgb2xkIHRleHR1cmVcblx0XHR2YXIga2V5ID1cblx0XHRcdFwiXCIgK1xuXHRcdFx0dyArXG5cdFx0XHRoICtcblx0XHRcdHR5cGUgK1xuXHRcdFx0cGVyc2lzdGVuY2UgK1xuXHRcdFx0b2N0YXZlcyArXG5cdFx0XHRzY2FsZSArXG5cdFx0XHRzZWVkICtcblx0XHRcdG9mZnNldFswXSArXG5cdFx0XHRvZmZzZXRbMV0gK1xuXHRcdFx0YW1wbGl0dWRlO1xuXHRcdGlmIChrZXkgPT0gdGhpcy5fa2V5KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2tleSA9IGtleTtcblxuXHRcdC8vZ2F0aGVyIHVuaWZvcm1zXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuXHRcdHVuaWZvcm1zLnVfb2N0YXZlcyA9IG9jdGF2ZXM7XG5cdFx0dW5pZm9ybXMudV9vZmZzZXQuc2V0KG9mZnNldCk7XG5cdFx0dW5pZm9ybXMudV9zY2FsZSA9IHNjYWxlO1xuXHRcdHVuaWZvcm1zLnVfYW1wbGl0dWRlID0gYW1wbGl0dWRlO1xuXHRcdHVuaWZvcm1zLnVfc2VlZCA9IHNlZWQgKiAxMjg7XG5cdFx0dW5pZm9ybXMudV92aWV3cG9ydFswXSA9IHc7XG5cdFx0dW5pZm9ybXMudV92aWV3cG9ydFsxXSA9IGg7XG5cblx0XHQvL3JlbmRlclxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlUGVybGluLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVQZXJsaW4uX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVBlcmxpbi5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHRlbXAuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlUGVybGluLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wZXJzaXN0ZW5jZTtcXG5cXFxuXHRcdHVuaWZvcm0gaW50IHVfb2N0YXZlcztcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9hbXBsaXR1ZGU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV92aWV3cG9ydDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zZWVkO1xcblxcXG5cdFx0I2RlZmluZSBNX1BJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDZcXG5cXFxuXHRcdFxcblxcXG5cdFx0ZmxvYXQgcmFuZCh2ZWMyIGMpe1x0cmV0dXJuIGZyYWN0KHNpbihkb3QoYy54eSAsdmVjMiggMTIuOTg5OCArIHVfc2VlZCw3OC4yMzMgKyB1X3NlZWQpKSkgKiA0Mzc1OC41NDUzKTsgfVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBub2lzZSh2ZWMyIHAsIGZsb2F0IGZyZXEgKXtcXG5cXFxuXHRcdFx0ZmxvYXQgdW5pdCA9IHVfdmlld3BvcnQueC9mcmVxO1xcblxcXG5cdFx0XHR2ZWMyIGlqID0gZmxvb3IocC91bml0KTtcXG5cXFxuXHRcdFx0dmVjMiB4eSA9IG1vZChwLHVuaXQpL3VuaXQ7XFxuXFxcblx0XHRcdC8veHkgPSAzLip4eSp4eS0yLip4eSp4eSp4eTtcXG5cXFxuXHRcdFx0eHkgPSAuNSooMS4tY29zKE1fUEkqeHkpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgYSA9IHJhbmQoKGlqK3ZlYzIoMC4sMC4pKSk7XFxuXFxcblx0XHRcdGZsb2F0IGIgPSByYW5kKChpait2ZWMyKDEuLDAuKSkpO1xcblxcXG5cdFx0XHRmbG9hdCBjID0gcmFuZCgoaWordmVjMigwLiwxLikpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgZCA9IHJhbmQoKGlqK3ZlYzIoMS4sMS4pKSk7XFxuXFxcblx0XHRcdGZsb2F0IHgxID0gbWl4KGEsIGIsIHh5LngpO1xcblxcXG5cdFx0XHRmbG9hdCB4MiA9IG1peChjLCBkLCB4eS54KTtcXG5cXFxuXHRcdFx0cmV0dXJuIG1peCh4MSwgeDIsIHh5LnkpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBwTm9pc2UodmVjMiBwLCBpbnQgcmVzKXtcXG5cXFxuXHRcdFx0ZmxvYXQgcGVyc2lzdGFuY2UgPSB1X3BlcnNpc3RlbmNlO1xcblxcXG5cdFx0XHRmbG9hdCBuID0gMC47XFxuXFxcblx0XHRcdGZsb2F0IG5vcm1LID0gMC47XFxuXFxcblx0XHRcdGZsb2F0IGYgPSA0LjtcXG5cXFxuXHRcdFx0ZmxvYXQgYW1wID0gMS4wO1xcblxcXG5cdFx0XHRpbnQgaUNvdW50ID0gMDtcXG5cXFxuXHRcdFx0Zm9yIChpbnQgaSA9IDA7IGk8NTA7IGkrKyl7XFxuXFxcblx0XHRcdFx0bis9YW1wKm5vaXNlKHAsIGYpO1xcblxcXG5cdFx0XHRcdGYqPTIuO1xcblxcXG5cdFx0XHRcdG5vcm1LKz1hbXA7XFxuXFxcblx0XHRcdFx0YW1wKj1wZXJzaXN0YW5jZTtcXG5cXFxuXHRcdFx0XHRpZiAoaUNvdW50ID49IHJlcylcXG5cXFxuXHRcdFx0XHRcdGJyZWFrO1xcblxcXG5cdFx0XHRcdGlDb3VudCsrO1xcblxcXG5cdFx0XHR9XFxuXFxcblx0XHRcdGZsb2F0IG5mID0gbi9ub3JtSztcXG5cXFxuXHRcdFx0cmV0dXJuIG5mKm5mKm5mKm5mO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWMyIHV2ID0gdl9jb29yZCAqIHVfc2NhbGUgKiB1X3ZpZXdwb3J0ICsgdV9vZmZzZXQgKiB1X3NjYWxlO1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCggcE5vaXNlKCB1diwgdV9vY3RhdmVzICkgKiB1X2FtcGxpdHVkZSApO1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxuXHRcdH1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvcGVybGluXCIsIExHcmFwaFRleHR1cmVQZXJsaW4pO1xuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVDYW52YXMyRCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwidlwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0Y29kZTogTEdyYXBoVGV4dHVyZUNhbnZhczJELmRlZmF1bHRfY29kZSxcblx0XHRcdHdpZHRoOiA1MTIsXG5cdFx0XHRoZWlnaHQ6IDUxMixcblx0XHRcdGNsZWFyOiB0cnVlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQsXG5cdFx0XHR1c2VfaHRtbF9jYW52YXM6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLl9mdW5jID0gbnVsbDtcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuY29tcGlsZUNvZGUoKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC50aXRsZSA9IFwiQ2FudmFzMkRcIjtcblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELmRlc2MgPSBcIkV4ZWN1dGVzIENhbnZhczJEIGNvZGUgaW5zaWRlIGEgdGV4dHVyZSBvciB0aGUgdmlld3BvcnQuXCI7XG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC5oZWxwID0gXCJTZXQgd2lkdGggYW5kIGhlaWdodCB0byAwIHRvIG1hdGNoIHZpZXdwb3J0IHNpemUuXCI7XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELmRlZmF1bHRfY29kZSA9IFwiLy92YXJzOiBjYW52YXMsY3R4LHRpbWVcXG5jdHguZmlsbFN0eWxlPSdyZWQnO1xcbmN0eC5maWxsUmVjdCgwLDAsNTAsNTApO1xcblwiO1xuXG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfSxcblx0XHRjb2RlOiB7IHR5cGU6IFwiY29kZVwiIH0sXG5cdFx0d2lkdGg6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxIH0sXG5cdFx0aGVpZ2h0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHByZWNpc2lvbjogMCwgc3RlcDogMSB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRpZiAobmFtZSA9PSBcImNvZGVcIiApXG5cdFx0XHR0aGlzLmNvbXBpbGVDb2RlKCB2YWx1ZSApO1xuXHR9XG5cdFxuXHRMR3JhcGhUZXh0dXJlQ2FudmFzMkQucHJvdG90eXBlLmNvbXBpbGVDb2RlID0gZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dGhpcy5fZnVuYyA9IG51bGw7XG5cdFx0aWYoICFMaXRlR3JhcGguYWxsb3dfc2NyaXB0cyApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fZnVuYyA9IG5ldyBGdW5jdGlvbiggXCJjYW52YXNcIiwgXCJjdHhcIiwgXCJ0aW1lXCIsIFwic2NyaXB0XCIsXCJ2XCIsIGNvZGUgKTtcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiMwMEZGMDBcIjtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiNGRjAwMDBcIjtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIHNjcmlwdFwiKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnVuYyA9IHRoaXMuX2Z1bmM7XG5cdFx0aWYgKCFmdW5jIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZXhlY3V0ZURyYXcoIGZ1bmMgKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC5wcm90b3R5cGUuZXhlY3V0ZURyYXcgPSBmdW5jdGlvbiggZnVuY19jb250ZXh0ICkge1xuXG5cdFx0dmFyIHdpZHRoID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHx8IGdsLmNhbnZhcy53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzLmhlaWdodCB8fCBnbC5jYW52YXMuaGVpZ2h0O1xuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdGlmICghdGVtcCB8fCB0ZW1wLndpZHRoICE9IHdpZHRoIHx8IHRlbXAuaGVpZ2h0ICE9IGhlaWdodCB8fCB0ZW1wLnR5cGUgIT0gdHlwZSApIHtcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCB7XG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVIsXG5cdFx0XHRcdHR5cGU6IHR5cGVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHRpbWUgPSB0aGlzLmdyYXBoLmdldFRpbWUoKTtcblx0XHR2YXIgY3R4ID0gZ2w7XG5cdFx0dmFyIGNhbnZhcyA9IGdsLmNhbnZhcztcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLnVzZV9odG1sX2NhbnZhcyB8fCAhZ2xvYmFsLmVuYWJsZVdlYkdMQ2FudmFzIClcblx0XHR7XG5cdFx0XHRpZighdGhpcy5fY2FudmFzKVxuXHRcdFx0e1xuXHRcdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXMgPSBjcmVhdGVDYW52YXMod2lkdGguaGVpZ2h0KTtcblx0XHRcdFx0Y3R4ID0gdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdFx0XHRjdHggPSB0aGlzLl9jdHg7XG5cdFx0XHR9XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXG5cdFx0aWYoY3R4ID09IGdsKSAvL3VzaW5nIENhbnZhczJEdG9XZWJHTFxuXHRcdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGdsLnN0YXJ0MkQoKTtcblx0XHRcdFx0aWYocHJvcGVydGllcy5jbGVhcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGdsLmNsZWFyQ29sb3IoMCwwLDAsMCk7XG5cdFx0XHRcdFx0Z2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKGZ1bmNfY29udGV4dC5kcmF3KSB7XG5cdFx0XHRcdFx0XHRmdW5jX2NvbnRleHQuZHJhdy5jYWxsKHRoYXQsIGNhbnZhcywgY3R4LCB0aW1lLCBmdW5jX2NvbnRleHQsIHYpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmdW5jX2NvbnRleHQuY2FsbCh0aGF0LCBjYW52YXMsIGN0eCwgdGltZSwgZnVuY19jb250ZXh0LHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGF0LmJveGNvbG9yID0gXCIjMDBGRjAwXCI7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdHRoYXQuYm94Y29sb3IgPSBcIiNGRjAwMDBcIjtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZXhlY3V0aW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wuZmluaXNoMkQoKTtcblx0XHRcdH0pO1xuXHRcdGVsc2UgLy9yZW5kZXJpbmcgdG8gb2Zmc2NyZW4gY2FudmFzIGFuZCB1cGxvYWRpbmcgdG8gdGV4dHVyZVxuXHRcdHtcblx0XHRcdGlmKHByb3BlcnRpZXMuY2xlYXIpXG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwwLGNhbnZhcy53aWR0aCxjYW52YXMuaGVpZ2h0KTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKGZ1bmNfY29udGV4dC5kcmF3KSB7XG5cdFx0XHRcdFx0ZnVuY19jb250ZXh0LmRyYXcuY2FsbCh0aGlzLCBjYW52YXMsIGN0eCwgdGltZSwgZnVuY19jb250ZXh0LCB2KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmdW5jX2NvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMsIGN0eCwgdGltZSwgZnVuY19jb250ZXh0LHYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiMwMEZGMDBcIjtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHR0aGlzLmJveGNvbG9yID0gXCIjRkYwMDAwXCI7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleGVjdXRpbmcgc2NyaXB0XCIpO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHR9XG5cdFx0XHR0ZW1wLnVwbG9hZEltYWdlKCBjYW52YXMgKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2NhbnZhczJEXCIsIExHcmFwaFRleHR1cmVDYW52YXMyRCk7XG5cblx0Ly8gVG8gZG8gY2hyb21hIGtleWluZyAqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVNYXR0ZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGtleV9jb2xvcjogdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApLFxuXHRcdFx0dGhyZXNob2xkOiAwLjgsXG5cdFx0XHRzbG9wZTogMC4yLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZU1hdHRlLnRpdGxlID0gXCJNYXR0ZVwiO1xuXHRMR3JhcGhUZXh0dXJlTWF0dGUuZGVzYyA9IFwiRXh0cmFjdHMgYmFja2dyb3VuZFwiO1xuXG5cdExHcmFwaFRleHR1cmVNYXR0ZS53aWRnZXRzX2luZm8gPSB7XG5cdFx0a2V5X2NvbG9yOiB7IHdpZGdldDogXCJjb2xvclwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVNYXR0ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXG5cdFx0XHR0ZXgsXG5cdFx0XHR0aGlzLl90ZXgsXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXG5cdFx0KTtcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cblx0XHRpZiAoIXRoaXMuX3VuaWZvcm1zKSB7XG5cdFx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHR1X2tleV9jb2xvcjogdGhpcy5wcm9wZXJ0aWVzLmtleV9jb2xvcixcblx0XHRcdFx0dV90aHJlc2hvbGQ6IDEsXG5cdFx0XHRcdHVfc2xvcGU6IDFcblx0XHRcdH07XG5cdFx0fVxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZU1hdHRlLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVNYXR0ZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlTWF0dGUucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHVuaWZvcm1zLnVfa2V5X2NvbG9yID0gdGhpcy5wcm9wZXJ0aWVzLmtleV9jb2xvcjtcblx0XHR1bmlmb3Jtcy51X3RocmVzaG9sZCA9IHRoaXMucHJvcGVydGllcy50aHJlc2hvbGQ7XG5cdFx0dW5pZm9ybXMudV9zbG9wZSA9IHRoaXMucHJvcGVydGllcy5zbG9wZTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVNYXR0ZS5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzMgdV9rZXlfY29sb3I7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfdGhyZXNob2xkO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3Nsb3BlO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzMgY29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdl9jb29yZCApLnh5ejtcXG5cXFxuXHRcdFx0ZmxvYXQgZGlmZiA9IGxlbmd0aCggbm9ybWFsaXplKGNvbG9yKSAtIG5vcm1hbGl6ZSh1X2tleV9jb2xvcikgKTtcXG5cXFxuXHRcdFx0ZmxvYXQgZWRnZSA9IHVfdGhyZXNob2xkICogKDEuMCAtIHVfc2xvcGUpO1xcblxcXG5cdFx0XHRmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoIGVkZ2UsIHVfdGhyZXNob2xkLCBkaWZmKTtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIGFscGhhICk7XFxuXFxcblx0XHR9XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL21hdHRlXCIsIExHcmFwaFRleHR1cmVNYXR0ZSk7XG5cblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhDdWJlbWFwVG9UZXh0dXJlMkQoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwidGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwieWF3XCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwidGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHlhdzogMCB9O1xuXHR9XG5cblx0TEdyYXBoQ3ViZW1hcFRvVGV4dHVyZTJELnRpdGxlID0gXCJDdWJlbWFwVG9UZXh0dXJlMkRcIjtcblx0TEdyYXBoQ3ViZW1hcFRvVGV4dHVyZTJELmRlc2MgPSBcIlRyYW5zZm9ybXMgYSBDVUJFTUFQIHRleHR1cmUgaW50byBhIFRFWFRVUkUyRCBpbiBQb2xhciBSZXByZXNlbnRhdGlvblwiO1xuXG5cdExHcmFwaEN1YmVtYXBUb1RleHR1cmUyRC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICggIXRleCB8fCB0ZXgudGV4dHVyZV90eXBlICE9IEdMLlRFWFRVUkVfQ1VCRV9NQVAgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmKCB0aGlzLl9sYXN0X3RleCAmJiAoIHRoaXMuX2xhc3RfdGV4LmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8IHRoaXMuX2xhc3RfdGV4LnR5cGUgIT0gdGV4LnR5cGUgKSlcblx0XHRcdHRoaXMuX2xhc3RfdGV4ID0gbnVsbDtcblx0XHR2YXIgeWF3ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ5YXdcIik7XG5cdFx0dGhpcy5fbGFzdF90ZXggPSBHTC5UZXh0dXJlLmN1YmVtYXBUb1RleHR1cmUyRCggdGV4LCB0ZXguaGVpZ2h0LCB0aGlzLl9sYXN0X3RleCwgdHJ1ZSwgeWF3ICk7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0aGlzLl9sYXN0X3RleCApO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInRleHR1cmUvY3ViZW1hcFRvVGV4dHVyZTJEXCIsIExHcmFwaEN1YmVtYXBUb1RleHR1cmUyRCApO1xufSkodGhpcyk7XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIEdMID09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRyZXR1cm47XHJcblxyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblx0dmFyIExHcmFwaENhbnZhcyA9IGdsb2JhbC5MR3JhcGhDYW52YXM7XHJcblxyXG5cdHZhciBTSEFERVJOT0RFU19DT0xPUiA9IFwiIzM0NVwiO1xyXG5cclxuXHR2YXIgTEdTaGFkZXJzID0gTGl0ZUdyYXBoLlNoYWRlcnMgPSB7fTtcclxuXHJcblx0dmFyIEdMU0xfdHlwZXMgPSBMR1NoYWRlcnMuR0xTTF90eXBlcyA9IFtcImZsb2F0XCIsXCJ2ZWMyXCIsXCJ2ZWMzXCIsXCJ2ZWM0XCIsXCJtYXQzXCIsXCJtYXQ0XCIsXCJzYW1wbGVyMkRcIixcInNhbXBsZXJDdWJlXCJdO1xyXG5cdHZhciBHTFNMX3R5cGVzX2NvbnN0ID0gTEdTaGFkZXJzLkdMU0xfdHlwZXNfY29uc3QgPSBbXCJmbG9hdFwiLFwidmVjMlwiLFwidmVjM1wiLFwidmVjNFwiXTtcclxuXHJcblx0dmFyIEdMU0xfZnVuY3Rpb25zX2Rlc2MgPSB7XHJcblx0XHRcInJhZGlhbnNcIjogXCJUIHJhZGlhbnMoVCBkZWdyZWVzKVwiLFxyXG5cdFx0XCJkZWdyZWVzXCI6IFwiVCBkZWdyZWVzKFQgcmFkaWFucylcIixcclxuXHRcdFwic2luXCI6IFwiVCBzaW4oVCBhbmdsZSlcIixcclxuXHRcdFwiY29zXCI6IFwiVCBjb3MoVCBhbmdsZSlcIixcclxuXHRcdFwidGFuXCI6IFwiVCB0YW4oVCBhbmdsZSlcIixcclxuXHRcdFwiYXNpblwiOiBcIlQgYXNpbihUIHgpXCIsXHJcblx0XHRcImFjb3NcIjogXCJUIGFjb3MoVCB4KVwiLFxyXG5cdFx0XCJhdGFuXCI6IFwiVCBhdGFuKFQgeClcIixcclxuXHRcdFwiYXRhbjJcIjogXCJUIGF0YW4oVCB4LFQgeSlcIixcclxuXHRcdFwicG93XCI6IFwiVCBwb3coVCB4LFQgeSlcIixcclxuXHRcdFwiZXhwXCI6IFwiVCBleHAoVCB4KVwiLFxyXG5cdFx0XCJsb2dcIjogXCJUIGxvZyhUIHgpXCIsXHJcblx0XHRcImV4cDJcIjogXCJUIGV4cDIoVCB4KVwiLFxyXG5cdFx0XCJsb2cyXCI6IFwiVCBsb2cyKFQgeClcIixcclxuXHRcdFwic3FydFwiOiBcIlQgc3FydChUIHgpXCIsXHJcblx0XHRcImludmVyc2VzcXJ0XCI6IFwiVCBpbnZlcnNlc3FydChUIHgpXCIsXHJcblx0XHRcImFic1wiOiBcIlQgYWJzKFQgeClcIixcclxuXHRcdFwic2lnblwiOiBcIlQgc2lnbihUIHgpXCIsXHJcblx0XHRcImZsb29yXCI6IFwiVCBmbG9vcihUIHgpXCIsXHJcblx0XHRcInJvdW5kXCI6IFwiVCByb3VuZChUIHgpXCIsXHJcblx0XHRcImNlaWxcIjogXCJUIGNlaWwoVCB4KVwiLFxyXG5cdFx0XCJmcmFjdFwiOiBcIlQgZnJhY3QoVCB4KVwiLFxyXG5cdFx0XCJtb2RcIjogXCJUIG1vZChUIHgsVCB5KVwiLCAvL1wiVCBtb2QoVCB4LGZsb2F0IHkpXCJcclxuXHRcdFwibWluXCI6IFwiVCBtaW4oVCB4LFQgeSlcIixcclxuXHRcdFwibWF4XCI6IFwiVCBtYXgoVCB4LFQgeSlcIixcclxuXHRcdFwiY2xhbXBcIjogXCJUIGNsYW1wKFQgeCxUIG1pblZhbCA9IDAuMCxUIG1heFZhbCA9IDEuMClcIixcclxuXHRcdFwibWl4XCI6IFwiVCBtaXgoVCB4LFQgeSxUIGEpXCIsIC8vXCJUIG1peChUIHgsVCB5LGZsb2F0IGEpXCJcclxuXHRcdFwic3RlcFwiOiBcIlQgc3RlcChUIGVkZ2UsIFQgZWRnZTIsIFQgeClcIiwgLy9cIlQgc3RlcChmbG9hdCBlZGdlLCBUIHgpXCJcclxuXHRcdFwic21vb3Roc3RlcFwiOiBcIlQgc21vb3Roc3RlcChUIGVkZ2UsIFQgZWRnZTIsIFQgeClcIiwgLy9cIlQgc21vb3Roc3RlcChmbG9hdCBlZGdlLCBUIHgpXCJcclxuXHRcdFwibGVuZ3RoXCI6XCJmbG9hdCBsZW5ndGgoVCB4KVwiLFxyXG5cdFx0XCJkaXN0YW5jZVwiOlwiZmxvYXQgZGlzdGFuY2UoVCBwMCwgVCBwMSlcIixcclxuXHRcdFwibm9ybWFsaXplXCI6XCJUIG5vcm1hbGl6ZShUIHgpXCIsXHJcblx0XHRcImRvdFwiOiBcImZsb2F0IGRvdChUIHgsVCB5KVwiLFxyXG5cdFx0XCJjcm9zc1wiOiBcInZlYzMgY3Jvc3ModmVjMyB4LHZlYzMgeSlcIixcclxuXHRcdFwicmVmbGVjdFwiOiBcInZlYzMgcmVmbGVjdCh2ZWMzIFYsdmVjMyBOKVwiLFxyXG5cdFx0XCJyZWZyYWN0XCI6IFwidmVjMyByZWZyYWN0KHZlYzMgVix2ZWMzIE4sIGZsb2F0IElPUilcIlxyXG5cdH07XHJcblxyXG5cdC8vcGFyc2UgdGhlbVxyXG5cdHZhciBHTFNMX2Z1bmN0aW9ucyA9IHt9O1xyXG5cdHZhciBHTFNMX2Z1bmN0aW9uc19uYW1lID0gW107XHJcblx0cGFyc2VHTFNMRGVzY3JpcHRpb25zKCk7XHJcblxyXG5cdExHU2hhZGVycy5BTExfVFlQRVMgPSBcImZsb2F0LHZlYzIsdmVjMyx2ZWM0XCI7XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlR0xTTERlc2NyaXB0aW9ucygpXHJcblx0e1xyXG5cdFx0R0xTTF9mdW5jdGlvbnNfbmFtZS5sZW5ndGggPSAwO1xyXG5cclxuXHRcdGZvcih2YXIgaSBpbiBHTFNMX2Z1bmN0aW9uc19kZXNjKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgb3AgPSBHTFNMX2Z1bmN0aW9uc19kZXNjW2ldO1xyXG5cdFx0XHR2YXIgaW5kZXggPSBvcC5pbmRleE9mKFwiIFwiKTtcclxuXHRcdFx0dmFyIHJldHVybl90eXBlID0gb3Auc3Vic3RyKDAsaW5kZXgpO1xyXG5cdFx0XHR2YXIgaW5kZXgyID0gb3AuaW5kZXhPZihcIihcIixpbmRleCk7XHJcblx0XHRcdHZhciBmdW5jX25hbWUgPSBvcC5zdWJzdHIoaW5kZXgsaW5kZXgyLWluZGV4KS50cmltKCk7XHJcblx0XHRcdHZhciBwYXJhbXMgPSBvcC5zdWJzdHIoaW5kZXgyICsgMSwgb3AubGVuZ3RoIC0gaW5kZXgyIC0gMikuc3BsaXQoXCIsXCIpO1xyXG5cdFx0XHRmb3IodmFyIGogaW4gcGFyYW1zKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHAgPSBwYXJhbXNbal0uc3BsaXQoXCIgXCIpLmZpbHRlcihmdW5jdGlvbihhKXsgcmV0dXJuIGE7IH0pO1xyXG5cdFx0XHRcdHBhcmFtc1tqXSA9IHsgdHlwZTogcFswXS50cmltKCksIG5hbWU6IHBbMV0udHJpbSgpIH07XHJcblx0XHRcdFx0aWYocFsyXSA9PSBcIj1cIilcclxuXHRcdFx0XHRcdHBhcmFtc1tqXS52YWx1ZSA9IHBbM10udHJpbSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdEdMU0xfZnVuY3Rpb25zW2ldID0geyByZXR1cm5fdHlwZTogcmV0dXJuX3R5cGUsIGZ1bmM6IGZ1bmNfbmFtZSwgcGFyYW1zOiBwYXJhbXMgfTtcclxuXHRcdFx0R0xTTF9mdW5jdGlvbnNfbmFtZS5wdXNoKCBmdW5jX25hbWUgKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyggR0xTTF9mdW5jdGlvbnNbaV0gKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vY29tbW9uIGFjdGlvbnMgdG8gYWxsIHNoYWRlciBub2RlIGNsYXNzZXNcclxuXHRmdW5jdGlvbiByZWdpc3RlclNoYWRlck5vZGUoIHR5cGUsIG5vZGVfY3RvciApXHJcblx0e1xyXG5cdFx0Ly9zdGF0aWMgYXR0cmlidXRlc1xyXG5cdFx0bm9kZV9jdG9yLmNvbG9yID0gU0hBREVSTk9ERVNfQ09MT1I7XHJcblx0XHRub2RlX2N0b3IuZmlsdGVyID0gXCJzaGFkZXJcIjtcclxuXHJcblx0XHQvL2NvbW1vbiBtZXRob2RzXHJcblx0XHRub2RlX2N0b3IucHJvdG90eXBlLmNsZWFyRGVzdGluYXRpb24gPSBmdW5jdGlvbigpeyB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiA9IHt9OyAgfVxyXG5cdFx0bm9kZV9jdG9yLnByb3RvdHlwZS5wcm9wYWdhdGVEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uIHByb3BhZ2F0ZURlc3RpbmF0aW9uKCBkZXN0X25hbWUgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNoYWRlcl9kZXN0aW5hdGlvblsgZGVzdF9uYW1lIF0gPSB0cnVlO1xyXG5cdFx0XHRpZih0aGlzLmlucHV0cylcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIG9yaWdpbl9ub2RlID0gdGhpcy5nZXRJbnB1dE5vZGUoaSk7XHJcblx0XHRcdFx0aWYob3JpZ2luX25vZGUpXHJcblx0XHRcdFx0XHRvcmlnaW5fbm9kZS5wcm9wYWdhdGVEZXN0aW5hdGlvbiggZGVzdF9uYW1lICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmKCFub2RlX2N0b3IucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkKVxyXG5cdFx0XHRub2RlX2N0b3IucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0XHRcdCB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0aWYoIW5vZGVfY3Rvci5wcm90b3R5cGUub25HZXRDb2RlKVxyXG5cdFx0XHRub2RlX2N0b3IucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdC8vY2hlY2sgZGVzdGluYXRpb24gdG8gYXZvaWQgbG9uZWx5IG5vZGVzXHJcblx0XHRcdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdC8vZ3JhYiBpbnB1dHMgd2l0aCB0eXBlc1xyXG5cdFx0XHRcdHZhciBpbnB1dHMgPSBbXTtcclxuXHRcdFx0XHRpZih0aGlzLmlucHV0cylcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0XHRpbnB1dHMucHVzaCh7IHR5cGU6IHRoaXMuZ2V0SW5wdXREYXRhKGkpLCBuYW1lOiBnZXRJbnB1dExpbmtJRCh0aGlzLGkpIH0pO1xyXG5cdFx0XHRcdHZhciBvdXRwdXRzID0gW107XHJcblx0XHRcdFx0aWYodGhpcy5vdXRwdXRzKVxyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0XHRvdXRwdXRzLnB1c2goeyBuYW1lOiBnZXRPdXRwdXRMaW5rSUQodGhpcyxpKSB9KTtcclxuXHRcdFx0XHQvL3Bhc3MgdG8gY29kZSBmdW5jXHJcblx0XHRcdFx0dmFyIHJlc3VsdHMgPSB0aGlzLmV4dHJhY3RDb2RlKGlucHV0cyk7XHJcblx0XHRcdFx0Ly9ncmFiIG91dHB1dCwgcGFzcyB0byBuZXh0XHJcblx0XHRcdFx0aWYocmVzdWx0cylcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7ICsraSlcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgciA9IHJlc3VsdHNbaV07XHJcblx0XHRcdFx0XHRpZighcilcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR0aGlzLnNldE91dHB1dERhdGEoaSxyLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCovXHJcblxyXG5cdFx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwic2hhZGVyOjpcIiArIHR5cGUsIG5vZGVfY3RvciApO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0U2hhZGVyTm9kZVZhck5hbWUoIG5vZGUsIG5hbWUgKVxyXG5cdHtcclxuXHRcdHJldHVybiBcIlZBUl9cIiArIChuYW1lIHx8IFwiVEVNUFwiKSArIFwiX1wiICsgbm9kZS5pZDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldElucHV0TGlua0lEKCBub2RlLCBzbG90IClcclxuXHR7XHJcblx0XHRpZighbm9kZS5pbnB1dHMpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0dmFyIGxpbmsgPSBub2RlLmdldElucHV0TGluayggc2xvdCApO1xyXG5cdFx0aWYoICFsaW5rIClcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR2YXIgb3JpZ2luX25vZGUgPSBub2RlLmdyYXBoLmdldE5vZGVCeUlkKCBsaW5rLm9yaWdpbl9pZCApO1xyXG5cdFx0aWYoICFvcmlnaW5fbm9kZSApXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0aWYob3JpZ2luX25vZGUuZ2V0T3V0cHV0VmFyTmFtZSlcclxuXHRcdFx0cmV0dXJuIG9yaWdpbl9ub2RlLmdldE91dHB1dFZhck5hbWUobGluay5vcmlnaW5fc2xvdCk7XHJcblx0XHQvL2dlbmVyYXRlXHJcblx0XHRyZXR1cm4gXCJsaW5rX1wiICsgb3JpZ2luX25vZGUuaWQgKyBcIl9cIiArIGxpbmsub3JpZ2luX3Nsb3Q7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRPdXRwdXRMaW5rSUQoIG5vZGUsIHNsb3QgKVxyXG5cdHtcclxuXHRcdGlmICghbm9kZS5pc091dHB1dENvbm5lY3RlZChzbG90KSlcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRyZXR1cm4gXCJsaW5rX1wiICsgbm9kZS5pZCArIFwiX1wiICsgc2xvdDtcclxuXHR9XHJcblxyXG5cdExHU2hhZGVycy5yZWdpc3RlclNoYWRlck5vZGUgPSByZWdpc3RlclNoYWRlck5vZGU7XHJcblx0TEdTaGFkZXJzLmdldElucHV0TGlua0lEID0gZ2V0SW5wdXRMaW5rSUQ7XHJcblx0TEdTaGFkZXJzLmdldE91dHB1dExpbmtJRCA9IGdldE91dHB1dExpbmtJRDtcclxuXHRMR1NoYWRlcnMuZ2V0U2hhZGVyTm9kZVZhck5hbWUgPSBnZXRTaGFkZXJOb2RlVmFyTmFtZTtcclxuXHRMR1NoYWRlcnMucGFyc2VHTFNMRGVzY3JpcHRpb25zID0gcGFyc2VHTFNMRGVzY3JpcHRpb25zO1xyXG5cclxuXHQvL2dpdmVuIGEgY29uc3QgbnVtYmVyLCBpdCB0cmFuc2Zvcm0gaXQgdG8gYSBzdHJpbmcgdGhhdCBtYXRjaGVzIGEgdHlwZVxyXG5cdHZhciB2YWx1ZVRvR0xTTCA9IExpdGVHcmFwaC52YWx1ZVRvR0xTTCA9IGZ1bmN0aW9uIHZhbHVlVG9HTFNMKCB2LCB0eXBlLCBwcmVjaXNpb24gKVxyXG5cdHtcclxuXHRcdHZhciBuID0gNTsgLy9udW0gZGVjaW1hbHNcclxuXHRcdGlmKHByZWNpc2lvbiAhPSBudWxsKVxyXG5cdFx0XHRuID0gcHJlY2lzaW9uO1xyXG5cdFx0aWYoIXR5cGUpXHJcblx0XHR7XHJcblx0XHRcdGlmKHYuY29uc3RydWN0b3IgPT09IE51bWJlcilcclxuXHRcdFx0XHR0eXBlID0gXCJmbG9hdFwiO1xyXG5cdFx0XHRlbHNlIGlmKHYubGVuZ3RoKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c3dpdGNoKHYubGVuZ3RoKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGNhc2UgMjogdHlwZSA9IFwidmVjMlwiOyBicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgMzogdHlwZSA9IFwidmVjM1wiOyBicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgNDogdHlwZSA9IFwidmVjNFwiOyBicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgOTogdHlwZSA9IFwibWF0M1wiOyBicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgMTY6IHR5cGUgPSBcIm1hdDRcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHR0aHJvdyhcInVua25vd24gdHlwZSBmb3IgZ2xzbCB2YWx1ZSBzaXplXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhyb3coXCJ1bmtub3duIHR5cGUgZm9yIGdsc2wgdmFsdWU6IFwiICsgdi5jb25zdHJ1Y3Rvcik7XHJcblx0XHR9XHJcblx0XHRzd2l0Y2godHlwZSlcclxuXHRcdHtcclxuXHRcdFx0Y2FzZSAnZmxvYXQnOiByZXR1cm4gdi50b0ZpeGVkKG4pOyBicmVhaztcclxuXHRcdFx0Y2FzZSAndmVjMic6IHJldHVybiBcInZlYzIoXCIgKyB2WzBdLnRvRml4ZWQobikgKyBcIixcIiArIHZbMV0udG9GaXhlZChuKSArIFwiKVwiOyBicmVhaztcclxuXHRcdFx0Y2FzZSAnY29sb3IzJzpcclxuXHRcdFx0Y2FzZSAndmVjMyc6IHJldHVybiBcInZlYzMoXCIgKyB2WzBdLnRvRml4ZWQobikgKyBcIixcIiArIHZbMV0udG9GaXhlZChuKSArIFwiLFwiICsgdlsyXS50b0ZpeGVkKG4pICsgXCIpXCI7IGJyZWFrO1xyXG5cdFx0XHRjYXNlICdjb2xvcjQnOlxyXG5cdFx0XHRjYXNlICd2ZWM0JzogcmV0dXJuIFwidmVjNChcIiArIHZbMF0udG9GaXhlZChuKSArIFwiLFwiICsgdlsxXS50b0ZpeGVkKG4pICsgXCIsXCIgKyB2WzJdLnRvRml4ZWQobikgKyBcIixcIiArIHZbM10udG9GaXhlZChuKSArIFwiKVwiOyBicmVhaztcclxuXHRcdFx0Y2FzZSAnbWF0Myc6IHJldHVybiBcIm1hdDMoMS4wLDAuMCwwLjAsMC4wLDEuMCwwLjAsMC4wLDAuMCwxLjApXCI7IGJyZWFrOyAvL25vdCBmdWxseSBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdGNhc2UgJ21hdDQnOiByZXR1cm4gXCJtYXQ0KDEuMCwwLjAsMC4wLDAuMCwwLjAsMS4wLDAuMCwwLjAsMC4wLDAuMCwwLjAsMS4wLDAuMCwwLjAsMC4wLDAuMCwxLjApXCI7IGJyZWFrOy8vbm90IGZ1bGx5IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyhcInVua25vd24gZ2xzbCB0eXBlIGluIHZhbHVlVG9HTFNMOlwiLCB0eXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gXCJcIjtcclxuXHR9XHJcblxyXG5cdC8vbWFrZXMgc3VyZSB0aGF0IGEgdmFyIGlzIG9mIGEgdHlwZSwgYW5kIGlmIG5vdCwgaXQgY29udmVydHMgaXRcclxuXHR2YXIgdmFyVG9UeXBlR0xTTCA9IExpdGVHcmFwaC52YXJUb1R5cGVHTFNMID0gZnVuY3Rpb24gdmFyVG9UeXBlR0xTTCggdiwgaW5wdXRfdHlwZSwgb3V0cHV0X3R5cGUgKVxyXG5cdHtcclxuXHRcdGlmKGlucHV0X3R5cGUgPT0gb3V0cHV0X3R5cGUpXHJcblx0XHRcdHJldHVybiB2O1xyXG5cdFx0aWYodiA9PSBudWxsKVxyXG5cdFx0XHRzd2l0Y2gob3V0cHV0X3R5cGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjYXNlIFwiZmxvYXRcIjogcmV0dXJuIFwiMC4wXCI7XHJcblx0XHRcdFx0Y2FzZSBcInZlYzJcIjogIHJldHVybiBcInZlYzIoMC4wKVwiO1xyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMzXCI6ICByZXR1cm4gXCJ2ZWMzKDAuMClcIjtcclxuXHRcdFx0XHRjYXNlIFwidmVjNFwiOiAgcmV0dXJuIFwidmVjNCgwLjAsMC4wLDAuMCwxLjApXCI7XHJcblx0XHRcdFx0ZGVmYXVsdDogLy9udWxsXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdGlmKCFvdXRwdXRfdHlwZSlcclxuXHRcdFx0dGhyb3coXCJlcnJvcjogbm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkXCIpO1xyXG5cdFx0aWYob3V0cHV0X3R5cGUgPT0gXCJmbG9hdFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRzd2l0Y2goaW5wdXRfdHlwZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdC8vY2FzZSBcImZsb2F0XCI6XHJcblx0XHRcdFx0Y2FzZSBcInZlYzJcIjpcclxuXHRcdFx0XHRjYXNlIFwidmVjM1wiOlxyXG5cdFx0XHRcdGNhc2UgXCJ2ZWM0XCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gdiArIFwiLnhcIjtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vbnVsbFxyXG5cdFx0XHRcdFx0cmV0dXJuIFwiMC4wXCI7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihvdXRwdXRfdHlwZSA9PSBcInZlYzJcIilcclxuXHRcdHtcclxuXHRcdFx0c3dpdGNoKGlucHV0X3R5cGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjYXNlIFwiZmxvYXRcIjpcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzIoXCIrditcIilcIjtcclxuXHRcdFx0XHQvL2Nhc2UgXCJ2ZWMyXCI6XHJcblx0XHRcdFx0Y2FzZSBcInZlYzNcIjpcclxuXHRcdFx0XHRjYXNlIFwidmVjNFwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIHYgKyBcIi54eVwiO1xyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vbnVsbFxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjMigwLjApXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYob3V0cHV0X3R5cGUgPT0gXCJ2ZWMzXCIpXHJcblx0XHR7XHJcblx0XHRcdHN3aXRjaChpbnB1dF90eXBlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y2FzZSBcImZsb2F0XCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWMzKFwiK3YrXCIpXCI7XHJcblx0XHRcdFx0Y2FzZSBcInZlYzJcIjpcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzMoXCIgKyB2ICsgXCIsMC4wKVwiO1xyXG5cdFx0XHRcdC8vY2FzZSBcInZlYzNcIjpcclxuXHRcdFx0XHRjYXNlIFwidmVjNFwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIHYgKyBcIi54eXpcIjtcclxuXHRcdFx0XHRkZWZhdWx0OiAvL251bGxcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzMoMC4wKVwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKG91dHB1dF90eXBlID09IFwidmVjNFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRzd2l0Y2goaW5wdXRfdHlwZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNhc2UgXCJmbG9hdFwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjNChcIit2K1wiKVwiO1xyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMyXCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KFwiICsgdiArIFwiLDAuMCwxLjApXCI7XHJcblx0XHRcdFx0Y2FzZSBcInZlYzNcIjpcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzQoXCIgKyB2ICsgXCIsMS4wKVwiO1xyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vbnVsbFxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjNCgwLjAsMC4wLDAuMCwxLjApXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRocm93KFwidHlwZSBjYW5ub3QgYmUgY29udmVydGVkXCIpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vdXNlZCB0byBwbHVnIGluY29tcGF0aWJsZSBzdHVmZlxyXG5cdHZhciBjb252ZXJ0VmFyVG9HTFNMVHlwZSA9IExpdGVHcmFwaC5jb252ZXJ0VmFyVG9HTFNMVHlwZSA9IGZ1bmN0aW9uIGNvbnZlcnRWYXJUb0dMU0xUeXBlKCB2YXJuYW1lLCB0eXBlLCB0YXJnZXRfdHlwZSApXHJcblx0e1xyXG5cdFx0aWYodHlwZSA9PSB0YXJnZXRfdHlwZSlcclxuXHRcdFx0cmV0dXJuIHZhcm5hbWU7XHJcblx0XHRpZih0eXBlID09IFwiZmxvYXRcIilcclxuXHRcdFx0cmV0dXJuIHRhcmdldF90eXBlICsgXCIoXCIgKyB2YXJuYW1lICsgXCIpXCI7XHJcblx0XHRpZih0YXJnZXRfdHlwZSA9PSBcInZlYzJcIikgLy93b3JrcyBmb3IgdmVjMix2ZWMzIGFuZCB2ZWM0XHJcblx0XHRcdHJldHVybiBcInZlYzIoXCIgKyB2YXJuYW1lICsgXCIueHkpXCI7XHJcblx0XHRpZih0YXJnZXRfdHlwZSA9PSBcInZlYzNcIikgLy93b3JrcyBmb3IgdmVjMix2ZWMzIGFuZCB2ZWM0XHJcblx0XHR7XHJcblx0XHRcdGlmKHR5cGUgPT0gXCJ2ZWMyXCIpXHJcblx0XHRcdFx0cmV0dXJuIFwidmVjMyhcIiArIHZhcm5hbWUgKyBcIiwwLjApXCI7XHJcblx0XHRcdGlmKHR5cGUgPT0gXCJ2ZWM0XCIpXHJcblx0XHRcdFx0cmV0dXJuIFwidmVjNChcIiArIHZhcm5hbWUgKyBcIi54eXopXCI7XHJcblx0XHR9XHJcblx0XHRpZih0YXJnZXRfdHlwZSA9PSBcInZlYzRcIilcclxuXHRcdHtcclxuXHRcdFx0aWYodHlwZSA9PSBcInZlYzJcIilcclxuXHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KFwiICsgdmFybmFtZSArIFwiLDAuMCwwLjApXCI7XHJcblx0XHRcdGlmKHRhcmdldF90eXBlID09IFwidmVjM1wiKVxyXG5cdFx0XHRcdHJldHVybiBcInZlYzQoXCIgKyB2YXJuYW1lICsgXCIsMS4wKVwiO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHQvL3VzZWQgdG8gaG9zdCBhIHNoYWRlciBib2R5ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0ZnVuY3Rpb24gTEdTaGFkZXJDb250ZXh0KClcclxuXHR7XHJcblx0XHQvL3RvIHN0b3JlIHRoZSBjb2RlIHRlbXBsYXRlXHJcblx0XHR0aGlzLnZzX3RlbXBsYXRlID0gXCJcIjtcclxuXHRcdHRoaXMuZnNfdGVtcGxhdGUgPSBcIlwiO1xyXG5cclxuXHRcdC8vcmVxdWlyZWQgc28gbm9kZXMgbm93IHdoZXJlIHRvIGZldGNoIHRoZSBpbnB1dCBkYXRhXHJcblx0XHR0aGlzLmJ1ZmZlcl9uYW1lcyA9IHtcclxuXHRcdFx0dXZzOiBcInZfY29vcmRcIlxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmV4dHJhID0ge307IC8vdG8gc3RvcmUgY3VzdG9tIGluZm8gZnJvbSB0aGUgbm9kZXMgKGxpa2UgaWYgdGhpcyBzaGFkZXIgc3VwcG9ydHMgYSBmZWF0dXJlLCBldGMpXHJcblxyXG5cdFx0dGhpcy5fZnVuY3Rpb25zID0ge307XHJcblx0XHR0aGlzLl91bmlmb3JtcyA9IHt9O1xyXG5cdFx0dGhpcy5fY29kZXBhcnRzID0ge307XHJcblx0XHR0aGlzLl91bmlmb3JtX3ZhbHVlID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcclxuXHRcdHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xyXG5cdFx0dGhpcy5fY29kZXBhcnRzID0ge307XHJcblx0XHR0aGlzLl91bmlmb3JtX3ZhbHVlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmV4dHJhID0ge307XHJcblx0fVxyXG5cclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmFkZFVuaWZvcm0gPSBmdW5jdGlvbiggbmFtZSwgdHlwZSwgdmFsdWUgKVxyXG5cdHtcclxuXHRcdHRoaXMuX3VuaWZvcm1zWyBuYW1lIF0gPSB0eXBlO1xyXG5cdFx0aWYodmFsdWUgIT0gbnVsbClcclxuXHRcdHtcclxuXHRcdFx0aWYoIXRoaXMuX3VuaWZvcm1fdmFsdWUpXHJcblx0XHRcdFx0dGhpcy5fdW5pZm9ybV92YWx1ZSA9IHt9O1xyXG5cdFx0XHR0aGlzLl91bmlmb3JtX3ZhbHVlW25hbWVdID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmFkZEZ1bmN0aW9uID0gZnVuY3Rpb24oIG5hbWUsIGNvZGUgKVxyXG5cdHtcclxuXHRcdHRoaXMuX2Z1bmN0aW9uc1tuYW1lXSA9IGNvZGU7XHJcblx0fVxyXG5cclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmFkZENvZGUgPSBmdW5jdGlvbiggaG9vaywgY29kZSwgZGVzdGluYXRpb25zIClcclxuXHR7XHJcblx0XHRkZXN0aW5hdGlvbnMgPSBkZXN0aW5hdGlvbnMgfHwge1wiXCI6XCJcIn07XHJcblx0XHRmb3IodmFyIGkgaW4gZGVzdGluYXRpb25zKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgaCA9IGkgPyBpICsgXCJfXCIgKyBob29rIDogaG9vaztcclxuXHRcdFx0aWYoIXRoaXMuX2NvZGVwYXJ0c1sgaCBdKVxyXG5cdFx0XHRcdHRoaXMuX2NvZGVwYXJ0c1sgaCBdID0gY29kZSArIFwiXFxuXCI7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aGlzLl9jb2RlcGFydHNbIGggXSArPSBjb2RlICsgXCJcXG5cIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vdGhlIHN5c3RlbSB3b3JrcyBieSBncmFiYmluZyBjb2RlIGZyYWdtZW50cyBmcm9tIGV2ZXJ5IG5vZGUgYW5kIGNvbmNhdGVuYXRpbmcgdGhlbSBpbiBibG9ja3MgZGVwZW5kaW5nIG9uIHdoZXJlIG11c3QgdGhleSBiZSBhdHRhY2hlZFxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuY29tcHV0ZUNvZGVCbG9ja3MgPSBmdW5jdGlvbiggZ3JhcGgsIGV4dHJhX3VuaWZvcm1zIClcclxuXHR7XHJcblx0XHQvL3ByZXBhcmUgY29udGV4dFxyXG5cdFx0dGhpcy5jbGVhcigpO1xyXG5cclxuXHRcdC8vZ3JhYiBvdXRwdXQgbm9kZXNcclxuXHRcdHZhciB2ZXJ0ZXhvdXQgPSBncmFwaC5maW5kTm9kZXNCeVR5cGUoXCJzaGFkZXI6Om91dHB1dC92ZXJ0ZXhcIik7XHJcblx0XHR2ZXJ0ZXhvdXQgPSB2ZXJ0ZXhvdXQgJiYgdmVydGV4b3V0Lmxlbmd0aCA/IHZlcnRleG91dFswXSA6IG51bGw7XHJcblx0XHR2YXIgZnJhZ21lbnRvdXQgPSBncmFwaC5maW5kTm9kZXNCeVR5cGUoXCJzaGFkZXI6Om91dHB1dC9mcmFnY29sb3JcIik7XHJcblx0XHRmcmFnbWVudG91dCA9IGZyYWdtZW50b3V0ICYmIGZyYWdtZW50b3V0Lmxlbmd0aCA/IGZyYWdtZW50b3V0WzBdIDogbnVsbDtcclxuXHRcdGlmKCFmcmFnbWVudG91dCkgLy8/P1xyXG5cdFx0XHRyZXR1cm4gbnVsbDsgXHJcblxyXG5cdFx0Ly9wcm9wYWdhdGUgYmFjayBkZXN0aW5hdGlvbnNcclxuXHRcdGdyYXBoLnNlbmRFdmVudFRvQWxsTm9kZXMoIFwiY2xlYXJEZXN0aW5hdGlvblwiICk7XHJcblx0XHRpZih2ZXJ0ZXhvdXQpXHJcblx0XHRcdHZlcnRleG91dC5wcm9wYWdhdGVEZXN0aW5hdGlvbihcInZzXCIpO1xyXG5cdFx0aWYoZnJhZ21lbnRvdXQpXHJcblx0XHRcdGZyYWdtZW50b3V0LnByb3BhZ2F0ZURlc3RpbmF0aW9uKFwiZnNcIik7XHJcblxyXG5cdFx0Ly9nZXRzIGNvZGUgZnJvbSBncmFwaFxyXG5cdFx0Z3JhcGguc2VuZEV2ZW50VG9BbGxOb2RlcyhcIm9uR2V0Q29kZVwiLCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIHVuaWZvcm1zID0gXCJcIjtcclxuXHRcdGZvcih2YXIgaSBpbiB0aGlzLl91bmlmb3JtcylcclxuXHRcdFx0dW5pZm9ybXMgKz0gXCJ1bmlmb3JtIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0gKyBcIiBcIiArIGkgKyBcIjtcXG5cIjtcclxuXHRcdGlmKGV4dHJhX3VuaWZvcm1zKVxyXG5cdFx0XHRmb3IodmFyIGkgaW4gZXh0cmFfdW5pZm9ybXMpXHJcblx0XHRcdFx0dW5pZm9ybXMgKz0gXCJ1bmlmb3JtIFwiICsgZXh0cmFfdW5pZm9ybXNbaV0gKyBcIiBcIiArIGkgKyBcIjtcXG5cIjtcclxuXHJcblx0XHR2YXIgZnVuY3Rpb25zID0gXCJcIjtcclxuXHRcdGZvcih2YXIgaSBpbiB0aGlzLl9mdW5jdGlvbnMpXHJcblx0XHRcdGZ1bmN0aW9ucyArPSBcIi8vXCIgKyBpICsgXCJcXG5cIiArIHRoaXMuX2Z1bmN0aW9uc1tpXSArIFwiXFxuXCI7XHJcblxyXG5cdFx0dmFyIGJsb2NrcyA9IHRoaXMuX2NvZGVwYXJ0cztcclxuXHRcdGJsb2Nrcy51bmlmb3JtcyA9IHVuaWZvcm1zO1xyXG5cdFx0YmxvY2tzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcclxuXHRcdHJldHVybiBibG9ja3M7XHJcblx0fVxyXG5cclxuXHQvL3JlcGxhY2VzIGJsb2NrcyB1c2luZyB0aGUgdnMgYW5kIGZzIHRlbXBsYXRlIGFuZCByZXR1cm5zIHRoZSBmaW5hbCBjb2Rlc1xyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuY29tcHV0ZVNoYWRlckNvZGUgPSBmdW5jdGlvbiggZ3JhcGggKVxyXG5cdHtcclxuXHRcdHZhciBibG9ja3MgPSB0aGlzLmNvbXB1dGVDb2RlQmxvY2tzKCBncmFwaCApO1xyXG5cdFx0dmFyIHZzX2NvZGUgPSBHTC5TaGFkZXIucmVwbGFjZUNvZGVVc2luZ0NvbnRleHQoIHRoaXMudnNfdGVtcGxhdGUsIGJsb2NrcyApO1xyXG5cdFx0dmFyIGZzX2NvZGUgPSBHTC5TaGFkZXIucmVwbGFjZUNvZGVVc2luZ0NvbnRleHQoIHRoaXMuZnNfdGVtcGxhdGUsIGJsb2NrcyApO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dnNfY29kZTogdnNfY29kZSxcclxuXHRcdFx0ZnNfY29kZTogZnNfY29kZVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8vZ2VuZXJhdGVzIHRoZSBzaGFkZXIgY29kZSBmcm9tIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIFxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuY29tcHV0ZVNoYWRlciA9IGZ1bmN0aW9uKCBncmFwaCwgc2hhZGVyIClcclxuXHR7XHJcblx0XHR2YXIgZmluYWxjb2RlID0gdGhpcy5jb21wdXRlU2hhZGVyQ29kZSggZ3JhcGggKTtcclxuXHRcdGNvbnNvbGUubG9nKCBmaW5hbGNvZGUudnNfY29kZSwgZmluYWxjb2RlLmZzX2NvZGUgKTtcclxuXHJcblx0XHRpZighTGl0ZUdyYXBoLmNhdGNoX2V4Y2VwdGlvbnMpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuX3NoYWRlcl9lcnJvciA9IHRydWU7XHJcblx0XHRcdGlmKHNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIudXBkYXRlU2hhZGVyKCBmaW5hbGNvZGUudnNfY29kZSwgZmluYWxjb2RlLmZzX2NvZGUgKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoIGZpbmFsY29kZS52c19jb2RlLCBmaW5hbGNvZGUuZnNfY29kZSApO1xyXG5cdFx0XHR0aGlzLl9zaGFkZXJfZXJyb3IgPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuIHNoYWRlcjtcclxuXHRcdH1cclxuXHJcblx0XHR0cnlcclxuXHRcdHtcclxuXHRcdFx0aWYoc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlci51cGRhdGVTaGFkZXIoIGZpbmFsY29kZS52c19jb2RlLCBmaW5hbGNvZGUuZnNfY29kZSApO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0c2hhZGVyID0gbmV3IEdMLlNoYWRlciggZmluYWxjb2RlLnZzX2NvZGUsIGZpbmFsY29kZS5mc19jb2RlICk7XHJcblx0XHRcdHRoaXMuX3NoYWRlcl9lcnJvciA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cdFx0fVxyXG5cdFx0Y2F0Y2ggKGVycilcclxuXHRcdHtcclxuXHRcdFx0aWYoIXRoaXMuX3NoYWRlcl9lcnJvcilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuXHRcdFx0XHRpZihlcnIuaW5kZXhPZihcIkZyYWdtZW50IHNoYWRlclwiKSAhPSAtMSlcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBmaW5hbGNvZGUuZnNfY29kZS5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24odixpKXsgcmV0dXJuIGkgKyBcIi4tIFwiICsgdjsgfSkuam9pbihcIlxcblwiKSApO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBmaW5hbGNvZGUudnNfY29kZSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3NoYWRlcl9lcnJvciA9IHRydWU7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsOy8vbmV2ZXIgaGVyZVxyXG5cdH1cclxuXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5nZXRTaGFkZXIgPSBmdW5jdGlvbiggZ3JhcGggKVxyXG5cdHtcclxuXHRcdC8vaWYgZ3JhcGggbm90IGNoYW5nZWQ/XHJcblx0XHRpZih0aGlzLl9zaGFkZXIgJiYgdGhpcy5fc2hhZGVyLl92ZXJzaW9uID09IGdyYXBoLl92ZXJzaW9uKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5fc2hhZGVyO1xyXG5cclxuXHRcdC8vY29tcGlsZSBzaGFkZXJcclxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLmNvbXB1dGVTaGFkZXIoIGdyYXBoLCB0aGlzLl9zaGFkZXIgKTtcclxuXHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHJcblx0XHR0aGlzLl9zaGFkZXIgPSBzaGFkZXI7XHJcblx0XHRzaGFkZXIuX3ZlcnNpb24gPSBncmFwaC5fdmVyc2lvbjtcclxuXHRcdHJldHVybiBzaGFkZXI7XHJcblx0fVxyXG5cclxuXHQvL3NvbWUgc2hhZGVyIG5vZGVzIGNvdWxkIHJlcXVpcmUgdG8gZmlsbCB0aGUgYm94IHdpdGggc29tZSB1bmlmb3Jtc1xyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuZmlsbFVuaWZvcm1zID0gZnVuY3Rpb24oIHVuaWZvcm1zLCBwYXJhbSApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuX3VuaWZvcm1fdmFsdWUpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRmb3IodmFyIGkgaW4gdGhpcy5fdW5pZm9ybV92YWx1ZSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHYgPSB0aGlzLl91bmlmb3JtX3ZhbHVlW2ldO1xyXG5cdFx0XHRpZih2ID09IG51bGwpXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdGlmKHYuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKVxyXG5cdFx0XHRcdHVuaWZvcm1zW2ldID0gdi5jYWxsKCB0aGlzLCBwYXJhbSApO1xyXG5cdFx0XHRlbHNlIGlmKHYuY29uc3RydWN0b3IgPT09IEdMLlRleHR1cmUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL3RvZG8uLi5cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dW5pZm9ybXNbaV0gPSB2O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLlNoYWRlckNvbnRleHQgPSBMaXRlR3JhcGguU2hhZGVycy5Db250ZXh0ID0gTEdTaGFkZXJDb250ZXh0O1xyXG5cclxuXHQvLyBMR3JhcGhTaGFkZXJHcmFwaCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdC8vIGFwcGxpZXMgYSBzaGFkZXIgZ3JhcGggdG8gdGV4dHVyZSwgaXQgY2FuIGJlIHVzZXMgYXMgYW4gZXhhbXBsZVxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJHcmFwaCgpIHtcclxuXHJcblx0XHQvL2JlZm9yZSBpbnB1dHNcclxuICAgICAgICB0aGlzLnN1YmdyYXBoID0gbmV3IExpdGVHcmFwaC5MR3JhcGgoKTtcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLl9zdWJncmFwaF9ub2RlID0gdGhpcztcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLl9pc19zdWJncmFwaCA9IHRydWU7XHJcblx0XHR0aGlzLnN1YmdyYXBoLmZpbHRlciA9IFwic2hhZGVyXCI7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwidGV4dHVyZVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwidGV4dHVyZVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCwgYWxwaGE6IGZhbHNlLCBwcmVjaXNpb246IHR5cGVvZihMR3JhcGhUZXh0dXJlKSAhPSBcInVuZGVmaW5lZFwiID8gTEdyYXBoVGV4dHVyZS5ERUZBVUxUIDogMiB9O1xyXG5cclxuXHRcdHZhciBpbnB1dE5vZGUgPSB0aGlzLnN1YmdyYXBoLmZpbmROb2Rlc0J5VHlwZShcInNoYWRlcjo6aW5wdXQvdW5pZm9ybVwiKVswXTtcclxuXHRcdGlucHV0Tm9kZS5wb3MgPSBbMjAwLDMwMF07XHJcblxyXG5cdFx0dmFyIHNhbXBsZXIgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcInNoYWRlcjo6dGV4dHVyZS9zYW1wbGVyMkRcIik7XHJcblx0XHRzYW1wbGVyLnBvcyA9IFs0MDAsMzAwXTtcclxuXHRcdHRoaXMuc3ViZ3JhcGguYWRkKCBzYW1wbGVyICk7XHJcblxyXG5cdFx0dmFyIG91dG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcInNoYWRlcjo6b3V0cHV0L2ZyYWdjb2xvclwiKTtcclxuXHRcdG91dG5vZGUucG9zID0gWzYwMCwzMDBdO1xyXG5cdFx0dGhpcy5zdWJncmFwaC5hZGQoIG91dG5vZGUgKTtcclxuXHJcblx0XHRpbnB1dE5vZGUuY29ubmVjdCggMCwgc2FtcGxlciApO1xyXG5cdFx0c2FtcGxlci5jb25uZWN0KCAwLCBvdXRub2RlICk7XHJcblxyXG5cdFx0dGhpcy5zaXplID0gWzE4MCw2MF07XHJcblx0XHR0aGlzLnJlZHJhd19vbl9tb3VzZSA9IHRydWU7IC8vZm9yY2UgcmVkcmF3XHJcblxyXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcclxuXHRcdHRoaXMuX3NoYWRlciA9IG51bGw7XHJcblx0XHR0aGlzLl9jb250ZXh0ID0gbmV3IExHU2hhZGVyQ29udGV4dCgpO1xyXG5cdFx0dGhpcy5fY29udGV4dC52c190ZW1wbGF0ZSA9IFwiI2RlZmluZSBWRVJURVhcXG5cIiArIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUjtcclxuXHRcdHRoaXMuX2NvbnRleHQuZnNfdGVtcGxhdGUgPSBMR3JhcGhTaGFkZXJHcmFwaC50ZW1wbGF0ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnRlbXBsYXRlID0gXCJcXG5cXFxyXG4jZGVmaW5lIEZSQUdNRU5UXFxuXFxcclxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcbnZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcbnt7dmFyeWluZ319XFxuXFxcclxue3t1bmlmb3Jtc319XFxuXFxcclxue3tmdW5jdGlvbnN9fVxcblxcXHJcbnt7ZnNfZnVuY3Rpb25zfX1cXG5cXFxyXG52b2lkIG1haW4oKSB7XFxuXFxuXFxcclxudmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcclxudmVjNCBmcmFnY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxcclxudmVjNCBmcmFnY29sb3IxID0gdmVjNCgwLjApO1xcblxcXHJcbnt7ZnNfY29kZX19XFxuXFxcclxuZ2xfRnJhZ0NvbG9yID0gZnJhZ2NvbG9yO1xcblxcXHJcbn1cXG5cXFxyXG5cdFwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgudGl0bGUgPSBcIlNoYWRlckdyYXBoXCI7XHJcblx0TEdyYXBoU2hhZGVyR3JhcGguZGVzYyA9IFwiQnVpbGRzIGEgc2hhZGVyIHVzaW5nIGEgZ3JhcGhcIjtcclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5pbnB1dF9ub2RlX3R5cGUgPSBcImlucHV0L3VuaWZvcm1cIjtcclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5vdXRwdXRfbm9kZV90eXBlID0gXCJvdXRwdXQvZnJhZ2NvbG9yXCI7XHJcblx0TEdyYXBoU2hhZGVyR3JhcGgudGl0bGVfY29sb3IgPSBTSEFERVJOT0RFU19DT0xPUjtcclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uU2VyaWFsaXplID0gZnVuY3Rpb24obylcclxuXHR7XHJcblx0XHRvLnN1YmdyYXBoID0gdGhpcy5zdWJncmFwaC5zZXJpYWxpemUoKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pXHJcblx0e1xyXG5cdFx0dGhpcy5zdWJncmFwaC5jb25maWd1cmUoby5zdWJncmFwaCk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHQvL3JlYWQgaW5wdXQgdGV4dHVyZVxyXG5cdFx0dmFyIGludGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZihpbnRleCAmJiBpbnRleC5jb25zdHJ1Y3RvciAhPSBHTC5UZXh0dXJlKVxyXG5cdFx0XHRpbnRleCA9IG51bGw7XHJcblxyXG5cdFx0dmFyIHcgPSB0aGlzLnByb3BlcnRpZXMud2lkdGggfCAwO1xyXG5cdFx0dmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0IHwgMDtcclxuXHRcdGlmICh3ID09IDApIHtcclxuXHRcdFx0dyA9IGludGV4ID8gaW50ZXgud2lkdGggOiBnbC52aWV3cG9ydF9kYXRhWzJdO1xyXG5cdFx0fSAvLzAgbWVhbnMgZGVmYXVsdFxyXG5cdFx0aWYgKGggPT0gMCkge1xyXG5cdFx0XHRoID0gaW50ZXggPyBpbnRleC5oZWlnaHQgOiBnbC52aWV3cG9ydF9kYXRhWzNdO1xyXG5cdFx0fSAvLzAgbWVhbnMgZGVmYXVsdFxyXG5cclxuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiwgaW50ZXggKTtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XHJcblx0XHRpZiAoICF0ZXh0dXJlIHx8IHRleHR1cmUud2lkdGggIT0gdyB8fCB0ZXh0dXJlLmhlaWdodCAhPSBoIHx8IHRleHR1cmUudHlwZSAhPSB0eXBlICkge1xyXG5cdFx0XHR0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHcsIGgsIHtcclxuXHRcdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHRcdGZvcm1hdDogdGhpcy5hbHBoYSA/IGdsLlJHQkEgOiBnbC5SR0IsXHJcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlciggdGhpcy5zdWJncmFwaCApO1xyXG5cdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xyXG5cdFx0dGhpcy5fY29udGV4dC5maWxsVW5pZm9ybXMoIHVuaWZvcm1zICk7XHJcblxyXG5cdFx0dmFyIHRleF9zbG90ID0gMDtcclxuXHRcdGlmKHRoaXMuaW5wdXRzKVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuXHRcdFx0aWYoaW5wdXQudHlwZSA9PSBcInRleHR1cmVcIilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKCFkYXRhKVxyXG5cdFx0XHRcdFx0ZGF0YSA9IEdMLlRleHR1cmUuZ2V0V2hpdGVUZXh0dXJlKCk7XHJcblx0XHRcdFx0ZGF0YSA9IGRhdGEuYmluZCh0ZXhfc2xvdCsrKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZGF0YSAhPSBudWxsKVxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVfXCIgKyBpbnB1dC5uYW1lIF0gPSBkYXRhO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtZXNoID0gR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCk7XHJcblxyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHR0ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpe1xyXG5cdFx0XHRzaGFkZXIudW5pZm9ybXMoIHVuaWZvcm1zICk7XHJcblx0XHRcdHNoYWRlci5kcmF3KCBtZXNoICk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvL3VzZSBzdWJncmFwaCBvdXRwdXQgXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4dHVyZSApO1xyXG5cdH07XHJcblxyXG5cdC8vYWRkIGlucHV0IG5vZGUgaW5zaWRlIHN1YmdyYXBoXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uSW5wdXRBZGRlZCA9IGZ1bmN0aW9uKCBzbG90X2luZm8gKVxyXG5cdHtcclxuXHRcdHZhciBzdWJub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJzaGFkZXI6OmlucHV0L3VuaWZvcm1cIik7XHJcblx0XHRzdWJub2RlLnNldFByb3BlcnR5KFwibmFtZVwiLHNsb3RfaW5mby5uYW1lKTtcclxuXHRcdHN1Ym5vZGUuc2V0UHJvcGVydHkoXCJ0eXBlXCIsc2xvdF9pbmZvLnR5cGUpO1xyXG5cdFx0dGhpcy5zdWJncmFwaC5hZGQoIHN1Ym5vZGUgKTtcclxuXHR9XHJcblxyXG5cdC8vcmVtb3ZlIGFsbFxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbklucHV0UmVtb3ZlZCA9IGZ1bmN0aW9uKCBzbG90LCBzbG90X2luZm8gKVxyXG5cdHtcclxuXHRcdHZhciBub2RlcyA9IHRoaXMuc3ViZ3JhcGguZmluZE5vZGVzQnlUeXBlKFwic2hhZGVyOjppbnB1dC91bmlmb3JtXCIpO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgbm9kZSA9IG5vZGVzW2ldO1xyXG5cdFx0XHRpZihub2RlLnByb3BlcnRpZXMubmFtZSA9PSBzbG90X2luZm8ubmFtZSApXHJcblx0XHRcdFx0dGhpcy5zdWJncmFwaC5yZW1vdmUoIG5vZGUgKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgbnVtX2lucHV0cyA9IHRoaXMuaW5wdXRzID8gdGhpcy5pbnB1dHMubGVuZ3RoIDogMDtcclxuXHRcdHZhciBudW1fb3V0cHV0cyA9IHRoaXMub3V0cHV0cyA/IHRoaXMub3V0cHV0cy5sZW5ndGggOiAwO1xyXG5cdFx0cmV0dXJuIFsgMjAwLCBNYXRoLm1heChudW1faW5wdXRzLG51bV9vdXRwdXRzKSAqIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMTBdO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLmdldFNoYWRlciA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgc2hhZGVyID0gdGhpcy5fY29udGV4dC5nZXRTaGFkZXIoIHRoaXMuc3ViZ3JhcGggKTtcclxuXHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLmJveGNvbG9yID0gbnVsbDtcclxuXHRcdHJldHVybiBzaGFkZXI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCwgZ3JhcGhjYW52YXMsIGNhbnZhcywgcG9zKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly9hbGxvd3MgdG8gcHJldmlldyB0aGUgbm9kZSBpZiB0aGUgY2FudmFzIGlzIGEgd2ViZ2wgY2FudmFzXHJcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRPdXRwdXREYXRhKDApO1xyXG5cdFx0dmFyIGlucHV0c195ID0gdGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCA6IDA7XHJcblx0XHRpZiAodGV4ICYmIGN0eCA9PSB0ZXguZ2wgJiYgdGhpcy5zaXplWzFdID4gaW5wdXRzX3kgKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKSB7XHJcblx0XHRcdGN0eC5kcmF3SW1hZ2UoIHRleCwgMTAseSwgdGhpcy5zaXplWzBdIC0gMjAsIHRoaXMuc2l6ZVsxXSAtIGlucHV0c195IC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHkgPSB0aGlzLnNpemVbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAwLjU7XHJcblxyXG5cdFx0Ly9idXR0b25cclxuXHRcdHZhciBvdmVyID0gTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKHBvc1swXSxwb3NbMV0sdGhpcy5wb3NbMF0sdGhpcy5wb3NbMV0gKyB5LHRoaXMuc2l6ZVswXSxMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IG92ZXIgPyBcIiM1NTVcIiA6IFwiIzIyMlwiO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0aWYgKHRoaXMuX3NoYXBlID09IExpdGVHcmFwaC5CT1hfU0hBUEUpXHJcblx0XHRcdGN0eC5yZWN0KDAsIHksIHRoaXMuc2l6ZVswXSsxLCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRjdHgucm91bmRSZWN0KCAwLCB5LCB0aGlzLnNpemVbMF0rMSwgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hULCAwLCA4KTtcclxuXHRcdGN0eC5maWxsKCk7XHJcblxyXG5cdFx0Ly9idXR0b25cclxuXHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG5cdFx0Y3R4LmZvbnQgPSBcIjI0cHggQXJpYWxcIjtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBvdmVyID8gXCIjREREXCIgOiBcIiM5OTlcIjtcclxuXHRcdGN0eC5maWxsVGV4dCggXCIrXCIsIHRoaXMuc2l6ZVswXSAqIDAuNSwgeSArIDI0ICk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBsb2NhbHBvcywgZ3JhcGhjYW52YXMpXHJcblx0e1xyXG5cdFx0dmFyIHkgPSB0aGlzLnNpemVbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAwLjU7XHJcblx0XHRpZihsb2NhbHBvc1sxXSA+IHkpXHJcblx0XHR7XHJcblx0XHRcdGdyYXBoY2FudmFzLnNob3dTdWJncmFwaFByb3BlcnRpZXNEaWFsb2codGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25EcmF3U3ViZ3JhcGhCYWNrZ3JvdW5kID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpXHJcblx0e1xyXG5cdFx0Ly9UT0RPXHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUuZ2V0RXh0cmFNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKGdyYXBoY2FudmFzKVxyXG5cdHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25zID0gW3sgY29udGVudDogXCJQcmludCBDb2RlXCIsIGNhbGxiYWNrOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgY29kZSA9IHRoYXQuX2NvbnRleHQuY29tcHV0ZVNoYWRlckNvZGUoKTtcclxuXHRcdFx0Y29uc29sZS5sb2coIGNvZGUudnNfY29kZSwgY29kZS5mc19jb2RlICk7XHJcblx0XHR9fV07XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL3NoYWRlckdyYXBoXCIsIExHcmFwaFNoYWRlckdyYXBoICk7XHJcblxyXG5cdGZ1bmN0aW9uIHNoYWRlck5vZGVGcm9tRnVuY3Rpb24oIGNsYXNzbmFtZSwgcGFyYW1zLCByZXR1cm5fdHlwZSwgY29kZSApXHJcblx0e1xyXG5cdFx0Ly9UT0RPXHJcblx0fVxyXG5cclxuXHQvL1NoYWRlciBOb2RlcyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHQvL2FwcGxpZXMgYSBzaGFkZXIgZ3JhcGggdG8gYSBjb2RlXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyVW5pZm9ybSgpIHtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBuYW1lOiBcIlwiLCB0eXBlOiBcIlwiIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJVbmlmb3JtLnRpdGxlID0gXCJVbmlmb3JtXCI7XHJcblx0TEdyYXBoU2hhZGVyVW5pZm9ybS5kZXNjID0gXCJJbnB1dCBkYXRhIGZvciB0aGUgc2hhZGVyXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlclVuaWZvcm0ucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKCB0aGlzLnByb3BlcnRpZXMubmFtZSAmJiB0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJvcGVydGllcy50eXBlICsgXCIgXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZTtcclxuXHRcdHJldHVybiBcIlVuaWZvcm1cIjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclVuaWZvcm0ucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHR0aGlzLm91dHB1dHNbMF0ubmFtZSA9IHRoaXMucHJvcGVydGllcy50eXBlICsgXCIgXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclVuaWZvcm0ucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xyXG5cdFx0aWYoICF0eXBlIClcclxuXHRcdHtcclxuXHRcdFx0aWYoICFjb250ZXh0Lm9uR2V0UHJvcGVydHlJbmZvIClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHZhciBpbmZvID0gY29udGV4dC5vbkdldFByb3BlcnR5SW5mbyggdGhpcy5wcm9wZXJ0eS5uYW1lICk7XHJcblx0XHRcdGlmKCFpbmZvKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dHlwZSA9IGluZm8udHlwZTtcclxuXHRcdH1cclxuXHRcdGlmKHR5cGUgPT0gXCJudW1iZXJcIilcclxuXHRcdFx0dHlwZSA9IFwiZmxvYXRcIjtcclxuXHRcdGVsc2UgaWYodHlwZSA9PSBcInRleHR1cmVcIilcclxuXHRcdFx0dHlwZSA9IFwic2FtcGxlcjJEXCI7XHJcblx0XHRpZiAoIExHU2hhZGVycy5HTFNMX3R5cGVzLmluZGV4T2YodHlwZSkgPT0gLTEgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Y29udGV4dC5hZGRVbmlmb3JtKCBcInVfXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZSwgdHlwZSApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0eXBlICk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJVbmlmb3JtLnByb3RvdHlwZS5nZXRPdXRwdXRWYXJOYW1lID0gZnVuY3Rpb24oc2xvdClcclxuXHR7XHJcblx0XHRyZXR1cm4gXCJ1X1wiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiaW5wdXQvdW5pZm9ybVwiLCBMR3JhcGhTaGFkZXJVbmlmb3JtICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJBdHRyaWJ1dGUoKSB7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcInZlYzJcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiY29vcmRcIiwgdHlwZTogXCJ2ZWMyXCIgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckF0dHJpYnV0ZS50aXRsZSA9IFwiQXR0cmlidXRlXCI7XHJcblx0TEdyYXBoU2hhZGVyQXR0cmlidXRlLmRlc2MgPSBcIklucHV0IGRhdGEgZnJvbSBtZXNoIGF0dHJpYnV0ZVwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHJldHVybiBcImF0dC4gXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XHJcblx0XHRpZiggIXR5cGUgfHwgTEdTaGFkZXJzLkdMU0xfdHlwZXMuaW5kZXhPZih0eXBlKSA9PSAtMSApXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKHR5cGUgPT0gXCJudW1iZXJcIilcclxuXHRcdFx0dHlwZSA9IFwiZmxvYXRcIjtcclxuXHRcdGlmKCB0aGlzLnByb3BlcnRpZXMubmFtZSAhPSBcImNvb3JkXCIpXHJcblx0XHR7XHJcblx0XHRcdGNvbnRleHQuYWRkQ29kZSggXCJ2YXJ5aW5nXCIsIFwiIHZhcnlpbmcgXCIgKyB0eXBlICtcIiB2X1wiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWUgKyBcIjtcIiApO1xyXG5cdFx0XHQvL2lmKCAhY29udGV4dC52YXJ5aW5nc1sgdGhpcy5wcm9wZXJ0aWVzLm5hbWUgXSApXHJcblx0XHRcdC8vY29udGV4dC5hZGRDb2RlKCBcInZzX2NvZGVcIiwgXCJ2X1wiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWUgKyBcIiA9IFwiICsgaW5wdXRfbmFtZSArIFwiO1wiICk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHR5cGUgKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGUuZ2V0T3V0cHV0VmFyTmFtZSA9IGZ1bmN0aW9uKHNsb3QpXHJcblx0e1xyXG5cdFx0cmV0dXJuIFwidl9cIiArIHRoaXMucHJvcGVydGllcy5uYW1lO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImlucHV0L2F0dHJpYnV0ZVwiLCBMR3JhcGhTaGFkZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyU2FtcGxlcjJEKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInRleFwiLCBcInNhbXBsZXIyRFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ1dlwiLCBcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInJnYmFcIiwgXCJ2ZWM0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJyZ2JcIiwgXCJ2ZWMzXCIpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyU2FtcGxlcjJELnRpdGxlID0gXCJTYW1wbGVyMkRcIjtcclxuXHRMR3JhcGhTaGFkZXJTYW1wbGVyMkQuZGVzYyA9IFwiUmVhZHMgYSBwaXhlbCBmcm9tIGEgdGV4dHVyZVwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJTYW1wbGVyMkQucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgdGV4bmFtZSA9IGdldElucHV0TGlua0lEKCB0aGlzLCAwICk7XHJcblx0XHR2YXIgdmFybmFtZSA9IGdldFNoYWRlck5vZGVWYXJOYW1lKHRoaXMpO1xyXG5cdFx0dmFyIGNvZGUgPSBcInZlYzQgXCIgKyB2YXJuYW1lICsgXCIgPSB2ZWM0KDAuMCk7XFxuXCI7XHJcblx0XHRpZih0ZXhuYW1lKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdXZuYW1lID0gZ2V0SW5wdXRMaW5rSUQoIHRoaXMsIDEgKSB8fCBjb250ZXh0LmJ1ZmZlcl9uYW1lcy51dnM7XHJcblx0XHRcdGNvZGUgKz0gdmFybmFtZSArIFwiID0gdGV4dHVyZTJEKFwiK3RleG5hbWUrXCIsXCIrdXZuYW1lK1wiKTtcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluazAgPSBnZXRPdXRwdXRMaW5rSUQoIHRoaXMsIDAgKTtcclxuXHRcdGlmKGxpbmswKVxyXG5cdFx0XHRjb2RlICs9IFwidmVjNCBcIiArIGdldE91dHB1dExpbmtJRCggdGhpcywgMCApICsgXCIgPSBcIit2YXJuYW1lK1wiO1xcblwiO1xyXG5cclxuXHRcdHZhciBsaW5rMSA9IGdldE91dHB1dExpbmtJRCggdGhpcywgMSApO1xyXG5cdFx0aWYobGluazEpXHJcblx0XHRcdGNvZGUgKz0gXCJ2ZWMzIFwiICsgZ2V0T3V0cHV0TGlua0lEKCB0aGlzLCAxICkgKyBcIiA9IFwiK3Zhcm5hbWUrXCIueHl6O1xcblwiO1xyXG5cclxuXHRcdGNvbnRleHQuYWRkQ29kZSggXCJjb2RlXCIsIGNvZGUsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIFwidmVjNFwiICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDEsIFwidmVjM1wiICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwidGV4dHVyZS9zYW1wbGVyMkRcIiwgTEdyYXBoU2hhZGVyU2FtcGxlcjJEICk7XHJcblxyXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckNvbnN0YW50KClcclxuXHR7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLFwiZmxvYXRcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHR0eXBlOiBcImZsb2F0XCIsXHJcblx0XHRcdHZhbHVlOiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcInR5cGVcIixcImZsb2F0XCIsbnVsbCwgeyB2YWx1ZXM6IEdMU0xfdHlwZXNfY29uc3QsIHByb3BlcnR5OiBcInR5cGVcIiB9ICk7XHJcblx0XHR0aGlzLnVwZGF0ZVdpZGdldHMoKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckNvbnN0YW50LnRpdGxlID0gXCJjb25zdFwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJDb25zdGFudC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXHJcblx0XHRcdHJldHVybiB2YWx1ZVRvR0xTTCggdGhpcy5wcm9wZXJ0aWVzLnZhbHVlLCB0aGlzLnByb3BlcnRpZXMudHlwZSwgMiApO1xyXG5cdFx0cmV0dXJuIFwiQ29uc3RcIjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckNvbnN0YW50LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0aWYobmFtZSA9PSBcInR5cGVcIilcclxuXHRcdHtcclxuXHRcdFx0aWYodGhpcy5vdXRwdXRzWzBdLnR5cGUgIT0gdmFsdWUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RPdXRwdXQoMCk7XHJcblx0XHRcdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLndpZGdldHMubGVuZ3RoID0gMTsgLy9yZW1vdmUgZXh0cmEgd2lkZ2V0c1xyXG5cdFx0XHR0aGlzLnVwZGF0ZVdpZGdldHMoKTtcclxuXHRcdH1cclxuXHRcdGlmKG5hbWUgPT0gXCJ2YWx1ZVwiKVxyXG5cdFx0e1xyXG5cdFx0XHRpZighdmFsdWUubGVuZ3RoKVxyXG5cdFx0XHRcdHRoaXMud2lkZ2V0c1sxXS52YWx1ZSA9IHZhbHVlO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLndpZGdldHNbMV0udmFsdWUgPSB2YWx1ZVsxXTtcclxuXHRcdFx0XHRpZih2YWx1ZS5sZW5ndGggPiAyKVxyXG5cdFx0XHRcdFx0dGhpcy53aWRnZXRzWzJdLnZhbHVlID0gdmFsdWVbMl07XHJcblx0XHRcdFx0aWYodmFsdWUubGVuZ3RoID4gMylcclxuXHRcdFx0XHRcdHRoaXMud2lkZ2V0c1szXS52YWx1ZSA9IHZhbHVlWzNdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJDb25zdGFudC5wcm90b3R5cGUudXBkYXRlV2lkZ2V0cyA9IGZ1bmN0aW9uKCBvbGRfdmFsdWUgKVxyXG5cdHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHZhciBvbGRfdmFsdWUgPSB0aGlzLnByb3BlcnRpZXMudmFsdWU7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHsgc3RlcDogMC4wMSB9O1xyXG5cdFx0c3dpdGNoKHRoaXMucHJvcGVydGllcy50eXBlKVxyXG5cdFx0e1xyXG5cdFx0XHRjYXNlICdmbG9hdCc6IFxyXG5cdFx0XHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IDA7XHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInZcIiwwLHsgc3RlcDowLjAxLCBwcm9wZXJ0eTogXCJ2YWx1ZVwiIH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICd2ZWMyJzogXHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gb2xkX3ZhbHVlICYmIG9sZF92YWx1ZS5sZW5ndGggPT0gMiA/IFtvbGRfdmFsdWVbMF0sb2xkX3ZhbHVlWzFdXSA6IFswLDAsMF07XHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInhcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMF0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMF0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwieVwiLHRoaXMucHJvcGVydGllcy52YWx1ZVsxXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVsxXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICd2ZWMzJzogXHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gb2xkX3ZhbHVlICYmIG9sZF92YWx1ZS5sZW5ndGggPT0gMyA/IFtvbGRfdmFsdWVbMF0sb2xkX3ZhbHVlWzFdLG9sZF92YWx1ZVsyXV0gOiBbMCwwLDBdO1xyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ4XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzBdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzBdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInlcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMV0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMV0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwielwiLHRoaXMucHJvcGVydGllcy52YWx1ZVsyXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVsyXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICd2ZWM0JzogXHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gb2xkX3ZhbHVlICYmIG9sZF92YWx1ZS5sZW5ndGggPT0gNCA/IFtvbGRfdmFsdWVbMF0sb2xkX3ZhbHVlWzFdLG9sZF92YWx1ZVsyXSxvbGRfdmFsdWVbM11dIDogWzAsMCwwLDBdO1xyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ4XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzBdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzBdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInlcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMV0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMV0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwielwiLHRoaXMucHJvcGVydGllcy52YWx1ZVsyXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVsyXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ3XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzNdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzNdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcInVua25vd24gdHlwZSBmb3IgY29uc3RhbnRcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJDb25zdGFudC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciB2YWx1ZSA9IHZhbHVlVG9HTFNMKCB0aGlzLnByb3BlcnRpZXMudmFsdWUsIHRoaXMucHJvcGVydGllcy50eXBlICk7XHJcblx0XHR2YXIgbGlua19uYW1lID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHRpZighbGlua19uYW1lKSAvL25vdCBjb25uZWN0ZWRcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBjb2RlID0gXCJcdFwiICsgdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKyBcIiBcIiArIGxpbmtfbmFtZSArIFwiID0gXCIgKyB2YWx1ZSArIFwiO1wiO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKCBcImNvZGVcIiwgY29kZSwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMucHJvcGVydGllcy50eXBlICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiY29uc3QvY29uc3RcIiwgTEdyYXBoU2hhZGVyQ29uc3RhbnQgKTtcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyVmVjMigpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh5XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInhcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInlcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4eVwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInlcIixcImZsb2F0XCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgeDogMCwgeTogMCB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjMi50aXRsZSA9IFwidmVjMlwiO1xyXG5cdExHcmFwaFNoYWRlclZlYzIudmFybW9kZXMgPSBbXCJ4eVwiLFwieFwiLFwieVwiXTtcclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjMi5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0IHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzIucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XHJcblxyXG5cdFx0dmFyIHZhcm5hbWUgPSBnZXRTaGFkZXJOb2RlVmFyTmFtZSh0aGlzKTtcclxuXHRcdHZhciBjb2RlID0gXCJcdHZlYzIgXCIgKyB2YXJuYW1lICsgXCIgPSBcIiArIHZhbHVlVG9HTFNMKFtwcm9wcy54LHByb3BzLnldKSArIFwiO1xcblwiO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7aSA8IExHcmFwaFNoYWRlclZlYzIudmFybW9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2YXJtb2RlID0gTEdyYXBoU2hhZGVyVmVjMi52YXJtb2Rlc1tpXTtcclxuXHRcdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsaSk7XHJcblx0XHRcdGlmKCFpbmxpbmspXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdGNvZGUgKz0gXCJcdFwiICsgdmFybmFtZSArIFwiLlwiK3Zhcm1vZGUrXCIgPSBcIiArIGlubGluayArIFwiO1xcblwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7aSA8IExHcmFwaFNoYWRlclZlYzIudmFybW9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2YXJtb2RlID0gTEdyYXBoU2hhZGVyVmVjMi52YXJtb2Rlc1tpXTtcclxuXHRcdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcyxpKTtcclxuXHRcdFx0aWYoIW91dGxpbmspXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHZhciB0eXBlID0gR0xTTF90eXBlc19jb25zdFt2YXJtb2RlLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRjb2RlICs9IFwiXHRcIit0eXBlK1wiIFwiICsgb3V0bGluayArIFwiID0gXCIgKyB2YXJuYW1lICsgXCIuXCIgKyB2YXJtb2RlICsgXCI7XFxuXCI7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggaSwgdHlwZSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQuYWRkQ29kZSggXCJjb2RlXCIsIGNvZGUsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiY29uc3QvdmVjMlwiLCBMR3JhcGhTaGFkZXJWZWMyICk7XHRcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyVmVjMygpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh5elwiLFwidmVjM1wiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ5XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ6XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4eVwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4elwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ5elwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHl6XCIsXCJ2ZWMzXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieVwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInpcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4eVwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHpcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInl6XCIsXCJ2ZWMyXCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgeDowLCB5OiAwLCB6OiAwIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWMzLnRpdGxlID0gXCJ2ZWMzXCI7XHJcblx0TEdyYXBoU2hhZGVyVmVjMy52YXJtb2RlcyA9IFtcInh5elwiLFwieFwiLFwieVwiLFwielwiLFwieHlcIixcInh6XCIsXCJ5elwiXTtcclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjMy5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0dGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjMy5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcclxuXHJcblx0XHR2YXIgdmFybmFtZSA9IGdldFNoYWRlck5vZGVWYXJOYW1lKHRoaXMpO1xyXG5cdFx0dmFyIGNvZGUgPSBcInZlYzMgXCIgKyB2YXJuYW1lICsgXCIgPSBcIiArIHZhbHVlVG9HTFNMKFtwcm9wcy54LHByb3BzLnkscHJvcHMuel0pICsgXCI7XFxuXCI7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDtpIDwgTEdyYXBoU2hhZGVyVmVjMy52YXJtb2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhcm1vZGUgPSBMR3JhcGhTaGFkZXJWZWMzLnZhcm1vZGVzW2ldO1xyXG5cdFx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcyxpKTtcclxuXHRcdFx0aWYoIWlubGluaylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0Y29kZSArPSBcIlx0XCIgKyB2YXJuYW1lICsgXCIuXCIrdmFybW9kZStcIiA9IFwiICsgaW5saW5rICsgXCI7XFxuXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IExHcmFwaFNoYWRlclZlYzMudmFybW9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2YXJtb2RlID0gTEdyYXBoU2hhZGVyVmVjMy52YXJtb2Rlc1tpXTtcclxuXHRcdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcyxpKTtcclxuXHRcdFx0aWYoIW91dGxpbmspXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHZhciB0eXBlID0gR0xTTF90eXBlc19jb25zdFt2YXJtb2RlLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRjb2RlICs9IFwiXHRcIit0eXBlK1wiIFwiICsgb3V0bGluayArIFwiID0gXCIgKyB2YXJuYW1lICsgXCIuXCIgKyB2YXJtb2RlICsgXCI7XFxuXCI7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggaSwgdHlwZSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQuYWRkQ29kZSggXCJjb2RlXCIsIGNvZGUsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiY29uc3QvdmVjM1wiLCBMR3JhcGhTaGFkZXJWZWMzICk7XHRcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclZlYzQoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4eXp3XCIsXCJ2ZWM0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInh5elwiLFwidmVjM1wiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ5XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ6XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ3XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4eVwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ5elwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ6d1wiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHl6d1wiLFwidmVjNFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHl6XCIsXCJ2ZWMzXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieVwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInpcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ4eVwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieXpcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInp3XCIsXCJ2ZWMyXCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgeDowLCB5OiAwLCB6OiAwLCB3OiAwIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWM0LnRpdGxlID0gXCJ2ZWM0XCI7XHJcblx0TEdyYXBoU2hhZGVyVmVjNC52YXJtb2RlcyA9IFtcInh5endcIixcInh5elwiLFwieFwiLFwieVwiLFwielwiLFwid1wiLFwieHlcIixcInl6XCIsXCJ6d1wiXTtcclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjNC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0dGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjNC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcclxuXHJcblx0XHR2YXIgdmFybmFtZSA9IGdldFNoYWRlck5vZGVWYXJOYW1lKHRoaXMpO1xyXG5cdFx0dmFyIGNvZGUgPSBcInZlYzQgXCIgKyB2YXJuYW1lICsgXCIgPSBcIiArIHZhbHVlVG9HTFNMKFtwcm9wcy54LHByb3BzLnkscHJvcHMueixwcm9wcy53XSkgKyBcIjtcXG5cIjtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwO2kgPCBMR3JhcGhTaGFkZXJWZWM0LnZhcm1vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdmFybW9kZSA9IExHcmFwaFNoYWRlclZlYzQudmFybW9kZXNbaV07XHJcblx0XHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLGkpO1xyXG5cdFx0XHRpZighaW5saW5rKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRjb2RlICs9IFwiXHRcIiArIHZhcm5hbWUgKyBcIi5cIit2YXJtb2RlK1wiID0gXCIgKyBpbmxpbmsgKyBcIjtcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwO2kgPCBMR3JhcGhTaGFkZXJWZWM0LnZhcm1vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdmFybW9kZSA9IExHcmFwaFNoYWRlclZlYzQudmFybW9kZXNbaV07XHJcblx0XHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsaSk7XHJcblx0XHRcdGlmKCFvdXRsaW5rKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgdHlwZSA9IEdMU0xfdHlwZXNfY29uc3RbdmFybW9kZS5sZW5ndGggLSAxXTtcclxuXHRcdFx0Y29kZSArPSBcIlx0XCIrdHlwZStcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiICsgdmFybmFtZSArIFwiLlwiICsgdmFybW9kZSArIFwiO1xcblwiO1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIGksIHR5cGUgKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0LmFkZENvZGUoIFwiY29kZVwiLCBjb2RlLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJjb25zdC92ZWM0XCIsIExHcmFwaFNoYWRlclZlYzQgKTtcdFxyXG5cdFxyXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckZyYWdDb2xvcigpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJjb2xvclwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmJsb2NrX2RlbGV0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJGcmFnQ29sb3IudGl0bGUgPSBcIkZyYWdDb2xvclwiO1xyXG5cdExHcmFwaFNoYWRlckZyYWdDb2xvci5kZXNjID0gXCJQaXhlbCBmaW5hbCBjb2xvclwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJGcmFnQ29sb3IucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHR2YXIgbGlua19uYW1lID0gZ2V0SW5wdXRMaW5rSUQoIHRoaXMsIDAgKTtcclxuXHRcdGlmKCFsaW5rX25hbWUpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHZhciB0eXBlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHR2YXIgY29kZSA9IHZhclRvVHlwZUdMU0woIGxpbmtfbmFtZSwgdHlwZSwgXCJ2ZWM0XCIgKTtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImZzX2NvZGVcIiwgXCJmcmFnY29sb3IgPSBcIiArIGNvZGUgKyBcIjtcIik7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwib3V0cHV0L2ZyYWdjb2xvclwiLCBMR3JhcGhTaGFkZXJGcmFnQ29sb3IgKTtcclxuXHJcblxyXG5cdC8qXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyRGlzY2FyZCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInZcIixcIlRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWluXCIsXCJUXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBtaW5fdmFsdWU6IDAuMCB9O1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcIm1pblwiLDAseyBzdGVwOiAwLjAxLCBwcm9wZXJ0eTogXCJtaW5fdmFsdWVcIiB9KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckRpc2NhcmQudGl0bGUgPSBcIkRpc2NhcmRcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyRGlzY2FyZC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHR2YXIgaW5saW5rMSA9IGdldElucHV0TGlua0lEKHRoaXMsMSk7XHJcblxyXG5cdFx0aWYoIWlubGluayAmJiAhaW5saW5rMSkgLy9ub3QgY29ubmVjdGVkXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9ICggKFwiICsgaW5saW5rICsgXCIgLSBcIittaW52K1wiKSAvIChcIisgbWF4ditcIiAtIFwiK21pbnYrXCIpICkgKiAoXCIrIG1heHYyK1wiIC0gXCIrbWludjIrXCIpICsgXCIgKyBtaW52MiArIFwiO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCByZXR1cm5fdHlwZSApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm91dHB1dC9kaXNjYXJkXCIsIExHcmFwaFNoYWRlckRpc2NhcmQgKTtcclxuXHQqL1xyXG5cclxuXHJcblx0Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJPcGVyYXRpb24oKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJCXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsXCJcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdG9wZXJhdGlvbjogXCIqXCJcclxuXHRcdH07XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJvcC5cIix0aGlzLnByb3BlcnRpZXMub3BlcmF0aW9uLHsgcHJvcGVydHk6IFwib3BlcmF0aW9uXCIsIHZhbHVlczogTEdyYXBoU2hhZGVyT3BlcmF0aW9uLm9wZXJhdGlvbnMgfSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJPcGVyYXRpb24udGl0bGUgPSBcIk9wZXJhdGlvblwiO1xyXG5cdExHcmFwaFNoYWRlck9wZXJhdGlvbi5vcGVyYXRpb25zID0gW1wiK1wiLFwiLVwiLFwiKlwiLFwiL1wiXTtcclxuXHJcblx0TEdyYXBoU2hhZGVyT3BlcmF0aW9uLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuXHRcdFx0cmV0dXJuIFwiQVwiICsgdGhpcy5wcm9wZXJ0aWVzLm9wZXJhdGlvbiArIFwiQlwiO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gXCJPcGVyYXRpb25cIjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlck9wZXJhdGlvbi5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGlua3MgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCAzOyArK2kpXHJcblx0XHRcdGlubGlua3MucHVzaCggeyBuYW1lOiBnZXRJbnB1dExpbmtJRCh0aGlzLGkpLCB0eXBlOiB0aGlzLmdldElucHV0RGF0YShpKSB8fCBcImZsb2F0XCIgfSApO1xyXG5cclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHRpZighb3V0bGluaykgLy9ub3QgY29ubmVjdGVkXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHQvL2Z1bmNfZGVzY1xyXG5cdFx0dmFyIGJhc2VfdHlwZSA9IGlubGlua3NbMF0udHlwZTtcclxuXHRcdHZhciByZXR1cm5fdHlwZSA9IGJhc2VfdHlwZTtcclxuXHRcdHZhciBvcCA9IHRoaXMucHJvcGVydGllcy5vcGVyYXRpb247XHJcblxyXG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IDI7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHBhcmFtX2NvZGUgPSBpbmxpbmtzW2ldLm5hbWU7XHJcblx0XHRcdGlmKHBhcmFtX2NvZGUgPT0gbnVsbCkgLy9ub3QgcGx1Z2dlZFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cGFyYW1fY29kZSA9IHAudmFsdWUgIT0gbnVsbCA/IHAudmFsdWUgOiBcIigxLjApXCI7XHJcblx0XHRcdFx0aW5saW5rc1tpXS50eXBlID0gXCJmbG9hdFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnZlcnRcclxuXHRcdFx0aWYoIGlubGlua3NbaV0udHlwZSAhPSBiYXNlX3R5cGUgKSBcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKCBpbmxpbmtzW2ldLnR5cGUgPT0gXCJmbG9hdFwiICYmIChvcCA9PSBcIipcIiB8fCBvcCA9PSBcIi9cIikgKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdC8vSSBmaW5kIGhhcmQgdG8gY3JlYXRlIHRoZSBvcHBvc2l0ZSBjb25kaXRpb24gbm93LCBzbyBJIHByZWZlZXIgYW4gZWxzZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRwYXJhbV9jb2RlID0gY29udmVydFZhclRvR0xTTFR5cGUoIHBhcmFtX2NvZGUsIGlubGlua3NbaV0udHlwZSwgYmFzZV90eXBlICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGFyYW1zLnB1c2goIHBhcmFtX2NvZGUgKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gXCIrIHBhcmFtc1swXSArIG9wICsgcGFyYW1zWzFdICsgXCI7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHJldHVybl90eXBlICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwibWF0aC9vcGVyYXRpb25cIiwgTEdyYXBoU2hhZGVyT3BlcmF0aW9uICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJGdW5jKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQVwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLFwiXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRmdW5jOiBcImZsb29yXCJcclxuXHRcdH07XHJcblx0XHR0aGlzLl9jdXJyZW50ID0gXCJmbG9vclwiO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwiZnVuY1wiLHRoaXMucHJvcGVydGllcy5mdW5jLHsgcHJvcGVydHk6IFwiZnVuY1wiLCB2YWx1ZXM6IEdMU0xfZnVuY3Rpb25zX25hbWUgfSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJGdW5jLnRpdGxlID0gXCJGdW5jXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckZ1bmMucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblxyXG5cdFx0aWYobmFtZSA9PSBcImZ1bmNcIilcclxuXHRcdHtcclxuXHRcdFx0dmFyIGZ1bmNfZGVzYyA9IEdMU0xfZnVuY3Rpb25zWyB2YWx1ZSBdO1xyXG5cdFx0XHRpZighZnVuY19kZXNjKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdC8vcmVtb3ZlIGV4dHJhIGlucHV0c1xyXG5cdFx0XHRmb3IodmFyIGkgPSBmdW5jX2Rlc2MucGFyYW1zLmxlbmd0aDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdHRoaXMucmVtb3ZlSW5wdXQoaSk7XHJcblxyXG5cdFx0XHQvL2FkZCBhbmQgdXBkYXRlIGlucHV0c1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZnVuY19kZXNjLnBhcmFtcy5sZW5ndGg7ICsraSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBwID0gZnVuY19kZXNjLnBhcmFtc1tpXTtcclxuXHRcdFx0XHRpZiggdGhpcy5pbnB1dHNbaV0gKVxyXG5cdFx0XHRcdFx0dGhpcy5pbnB1dHNbaV0ubmFtZSA9IHAubmFtZSArIChwLnZhbHVlID8gXCIgKFwiICsgcC52YWx1ZSArIFwiKVwiIDogXCJcIik7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0dGhpcy5hZGRJbnB1dCggcC5uYW1lLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckZ1bmMucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmZ1bmM7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBcIkZ1bmNcIjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckZ1bmMucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZighdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmtzID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKVxyXG5cdFx0XHRpbmxpbmtzLnB1c2goIHsgbmFtZTogZ2V0SW5wdXRMaW5rSUQodGhpcyxpKSwgdHlwZTogdGhpcy5nZXRJbnB1dERhdGEoaSkgfHwgXCJmbG9hdFwiIH0gKTtcclxuXHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0aWYoIW91dGxpbmspIC8vbm90IGNvbm5lY3RlZFxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGZ1bmNfZGVzYyA9IEdMU0xfZnVuY3Rpb25zWyB0aGlzLnByb3BlcnRpZXMuZnVuYyBdO1xyXG5cdFx0aWYoIWZ1bmNfZGVzYylcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vZnVuY19kZXNjXHJcblx0XHR2YXIgYmFzZV90eXBlID0gaW5saW5rc1swXS50eXBlO1xyXG5cdFx0dmFyIHJldHVybl90eXBlID0gZnVuY19kZXNjLnJldHVybl90eXBlO1xyXG5cdFx0aWYoIHJldHVybl90eXBlID09IFwiVFwiIClcclxuXHRcdFx0cmV0dXJuX3R5cGUgPSBiYXNlX3R5cGU7XHJcblxyXG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGZ1bmNfZGVzYy5wYXJhbXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBwID0gZnVuY19kZXNjLnBhcmFtc1tpXTtcclxuXHRcdFx0dmFyIHBhcmFtX2NvZGUgPSBpbmxpbmtzW2ldLm5hbWU7XHJcblx0XHRcdGlmKHBhcmFtX2NvZGUgPT0gbnVsbCkgLy9ub3QgcGx1Z2dlZFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cGFyYW1fY29kZSA9IHAudmFsdWUgIT0gbnVsbCA/IHAudmFsdWUgOiBcIigxLjApXCI7XHJcblx0XHRcdFx0aW5saW5rc1tpXS50eXBlID0gXCJmbG9hdFwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCAocC50eXBlID09IFwiVFwiICYmIGlubGlua3NbaV0udHlwZSAhPSBiYXNlX3R5cGUpIHx8XHJcblx0XHRcdFx0KHAudHlwZSAhPSBcIlRcIiAmJiBpbmxpbmtzW2ldLnR5cGUgIT0gYmFzZV90eXBlKSApXHJcblx0XHRcdFx0cGFyYW1fY29kZSA9IGNvbnZlcnRWYXJUb0dMU0xUeXBlKCBwYXJhbV9jb2RlLCBpbmxpbmtzW2ldLnR5cGUsIGJhc2VfdHlwZSApO1xyXG5cdFx0XHRwYXJhbXMucHVzaCggcGFyYW1fY29kZSApO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRjb250ZXh0LmFkZEZ1bmN0aW9uKFwicm91bmRcIixcImZsb2F0IHJvdW5kKGZsb2F0IHYpeyByZXR1cm4gZmxvb3IodiswLjUpOyB9XFxudmVjMiByb3VuZCh2ZWMyIHYpeyByZXR1cm4gZmxvb3Iodit2ZWMyKDAuNSkpO31cXG52ZWMzIHJvdW5kKHZlYzMgdil7IHJldHVybiBmbG9vcih2K3ZlYzMoMC41KSk7fVxcbnZlYzQgcm91bmQodmVjNCB2KXsgcmV0dXJuIGZsb29yKHYrdmVjNCgwLjUpKTsgfVxcblwiKTtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiK2Z1bmNfZGVzYy5mdW5jK1wiKFwiK3BhcmFtcy5qb2luKFwiLFwiKStcIik7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCByZXR1cm5fdHlwZSApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm1hdGgvZnVuY1wiLCBMR3JhcGhTaGFkZXJGdW5jICk7XHJcblxyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyU25pcHBldCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJDXCIsXCJ2ZWM0XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRjb2RlOlwiQyA9IEErQlwiLFxyXG5cdFx0XHR0eXBlOiBcInZlYzRcIlxyXG5cdFx0fVxyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJjb2RlXCIsdGhpcy5wcm9wZXJ0aWVzLmNvZGUseyBwcm9wZXJ0eTogXCJjb2RlXCIgfSk7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJ0eXBlXCIsdGhpcy5wcm9wZXJ0aWVzLnR5cGUseyB2YWx1ZXM6W1wiZmxvYXRcIixcInZlYzJcIixcInZlYzNcIixcInZlYzRcIl0sIHByb3BlcnR5OiBcInR5cGVcIiB9KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclNuaXBwZXQudGl0bGUgPSBcIlNuaXBwZXRcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyU25pcHBldC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHJcblx0XHRpZihuYW1lID09IFwidHlwZVwiJiYgdGhpcy5vdXRwdXRzWzBdLnR5cGUgIT0gdmFsdWUpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuZGlzY29ubmVjdE91dHB1dCgwKTtcclxuXHRcdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclNuaXBwZXQucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmNvZGU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBcIlNuaXBwZXRcIjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclNuaXBwZXQucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rQSA9IGdldElucHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHRpZighaW5saW5rQSlcclxuXHRcdFx0aW5saW5rQSA9IFwiMS4wXCI7XHJcblx0XHR2YXIgaW5saW5rQiA9IGdldElucHV0TGlua0lEKHRoaXMsMSk7XHJcblx0XHRpZighaW5saW5rQilcclxuXHRcdFx0aW5saW5rQiA9IFwiMS4wXCI7XHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0aWYoIW91dGxpbmspIC8vbm90IGNvbm5lY3RlZFxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGluQV90eXBlID0gdGhpcy5nZXRJbnB1dERhdGEoMCkgfHwgXCJmbG9hdFwiO1xyXG5cdFx0dmFyIGluQl90eXBlID0gdGhpcy5nZXRJbnB1dERhdGEoMSkgfHwgXCJmbG9hdFwiO1xyXG5cdFx0dmFyIHJldHVybl90eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XHJcblxyXG5cdFx0Ly9jYW5ub3QgcmVzb2x2ZSBpbnB1dFxyXG5cdFx0aWYoaW5BX3R5cGUgPT0gXCJUXCIgfHwgaW5CX3R5cGUgPT0gXCJUXCIpXHJcblx0XHR7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmdW5jbmFtZSA9IFwiZnVuY1NuaXBwZXRcIiArIHRoaXMuaWQ7XHJcblxyXG5cdFx0dmFyIGZ1bmNfY29kZSA9IFwiXFxuXCIgKyByZXR1cm5fdHlwZSArIFwiIFwiICsgZnVuY25hbWUgKyBcIiggXCIgKyBpbkFfdHlwZSArIFwiIEEsIFwiICsgaW5CX3R5cGUgKyBcIiBCKSB7XFxuXCI7XHJcblx0XHRmdW5jX2NvZGUgKz0gXCJcdFwiICsgcmV0dXJuX3R5cGUgKyBcIiBDID0gXCIgKyByZXR1cm5fdHlwZSArIFwiKDAuMCk7XFxuXCI7XHJcblx0XHRmdW5jX2NvZGUgKz0gXCJcdFwiICsgdGhpcy5wcm9wZXJ0aWVzLmNvZGUgKyBcIjtcXG5cIjtcclxuXHRcdGZ1bmNfY29kZSArPSBcIlx0cmV0dXJuIEM7XFxufVxcblwiO1xyXG5cclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImZ1bmN0aW9uc1wiLCBmdW5jX2NvZGUsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIitmdW5jbmFtZStcIihcIitpbmxpbmtBK1wiLFwiK2lubGlua0IrXCIpO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgcmV0dXJuX3R5cGUgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJ1dGlscy9zbmlwcGV0XCIsIExHcmFwaFNoYWRlclNuaXBwZXQgKTtcclxuXHJcblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyUmFuZCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIixcImZsb2F0XCIpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyUmFuZC50aXRsZSA9IFwiUmFuZFwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJSYW5kLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHJcblx0XHRjb250ZXh0LmFkZFVuaWZvcm0oIFwidV9yYW5kXCIgKyB0aGlzLmlkLCBcImZsb2F0XCIsIGZ1bmN0aW9uKCl7IHJldHVybiBNYXRoLnJhbmRvbSgpOyB9KTtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgXCJmbG9hdCBcIiArIG91dGxpbmsgKyBcIiA9IHVfcmFuZFwiICsgdGhpcy5pZCArXCI7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIFwiZmxvYXRcIiApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImlucHV0L3JhbmRcIiwgTEdyYXBoU2hhZGVyUmFuZCApO1xyXG5cclxuXHQvL25vaXNlXHJcblx0Ly9odHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXRyaWNpb2dvbnphbGV6dml2by82NzBjMjJmMzk2NmU2NjJkMmY4M1xyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlck5vaXNlKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwib3V0XCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJzY2FsZVwiLCBcImZsb2F0XCIgKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0dHlwZTogXCJub2lzZVwiLFxyXG5cdFx0XHRzY2FsZTogMVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcInR5cGVcIiwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUsIHsgcHJvcGVydHk6IFwidHlwZVwiLCB2YWx1ZXM6IExHcmFwaFNoYWRlck5vaXNlLk5PSVNFX1RZUEVTIH0pO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInNjYWxlXCIsIHRoaXMucHJvcGVydGllcy5zY2FsZSwgeyBwcm9wZXJ0eTogXCJzY2FsZVwiIH0pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyTm9pc2UuTk9JU0VfVFlQRVMgPSBbXCJub2lzZVwiLFwicmFuZFwiXTtcclxuXHJcblx0TEdyYXBoU2hhZGVyTm9pc2UudGl0bGUgPSBcIm5vaXNlXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlck5vaXNlLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cclxuXHRcdHZhciBpbnR5cGUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFpbmxpbmspXHJcblx0XHR7XHJcblx0XHRcdGludHlwZSA9IFwidmVjMlwiO1xyXG5cdFx0XHRpbmxpbmsgPSBjb250ZXh0LmJ1ZmZlcl9uYW1lcy51dnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGV4dC5hZGRGdW5jdGlvbihcIm5vaXNlXCIsTEdyYXBoU2hhZGVyTm9pc2Uuc2hhZGVyX2Z1bmN0aW9ucyk7XHJcblx0XHRjb250ZXh0LmFkZFVuaWZvcm0oIFwidV9ub2lzZV9zY2FsZVwiICsgdGhpcy5pZCwgXCJmbG9hdFwiLCB0aGlzLnByb3BlcnRpZXMuc2NhbGUgKTtcclxuXHRcdGlmKCBpbnR5cGUgPT0gXCJmbG9hdFwiIClcclxuXHRcdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCBcImZsb2F0IFwiICsgb3V0bGluayArIFwiID0gc25vaXNlKCB2ZWMyKFwiICsgaW5saW5rICtcIikgKiB1X25vaXNlX3NjYWxlXCIgKyB0aGlzLmlkICtcIik7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHRlbHNlIGlmKCBpbnR5cGUgPT0gXCJ2ZWMyXCIgfHwgaW50eXBlID09IFwidmVjM1wiIClcclxuXHRcdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCBcImZsb2F0IFwiICsgb3V0bGluayArIFwiID0gc25vaXNlKFwiICsgaW5saW5rICtcIiAqIHVfbm9pc2Vfc2NhbGVcIiArIHRoaXMuaWQgK1wiKTtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdGVsc2UgaWYoIGludHlwZSA9PSBcInZlYzRcIiApXHJcblx0XHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgXCJmbG9hdCBcIiArIG91dGxpbmsgKyBcIiA9IHNub2lzZShcIiArIGlubGluayArXCIueHl6ICogdV9ub2lzZV9zY2FsZVwiICsgdGhpcy5pZCArXCIpO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBcImZsb2F0XCIgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJtYXRoL25vaXNlXCIsIExHcmFwaFNoYWRlck5vaXNlICk7XHJcblxyXG5MR3JhcGhTaGFkZXJOb2lzZS5zaGFkZXJfZnVuY3Rpb25zID0gXCJcXG5cXFxyXG52ZWMzIHBlcm11dGUodmVjMyB4KSB7IHJldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApOyB9XFxuXFxcclxuXFxuXFxcclxuZmxvYXQgc25vaXNlKHZlYzIgdil7XFxuXFxcclxuICBjb25zdCB2ZWM0IEMgPSB2ZWM0KDAuMjExMzI0ODY1NDA1MTg3LCAwLjM2NjAyNTQwMzc4NDQzOSwtMC41NzczNTAyNjkxODk2MjYsIDAuMDI0MzkwMjQzOTAyNDM5KTtcXG5cXFxyXG4gIHZlYzIgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXkpICk7XFxuXFxcclxuICB2ZWMyIHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4KTtcXG5cXFxyXG4gIHZlYzIgaTE7XFxuXFxcclxuICBpMSA9ICh4MC54ID4geDAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xcblxcXHJcbiAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xcblxcXHJcbiAgeDEyLnh5IC09IGkxO1xcblxcXHJcbiAgaSA9IG1vZChpLCAyODkuMCk7XFxuXFxcclxuICB2ZWMzIHAgPSBwZXJtdXRlKCBwZXJtdXRlKCBpLnkgKyB2ZWMzKDAuMCwgaTEueSwgMS4wICkpXFxuXFxcclxuICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjAgKSk7XFxuXFxcclxuICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAseDApLCBkb3QoeDEyLnh5LHgxMi54eSksZG90KHgxMi56dyx4MTIuencpKSwgMC4wKTtcXG5cXFxyXG4gIG0gPSBtKm0gO1xcblxcXHJcbiAgbSA9IG0qbSA7XFxuXFxcclxuICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xcblxcXHJcbiAgdmVjMyBoID0gYWJzKHgpIC0gMC41O1xcblxcXHJcbiAgdmVjMyBveCA9IGZsb29yKHggKyAwLjUpO1xcblxcXHJcbiAgdmVjMyBhMCA9IHggLSBveDtcXG5cXFxyXG4gIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoIGEwKmEwICsgaCpoICk7XFxuXFxcclxuICB2ZWMzIGc7XFxuXFxcclxuICBnLnggID0gYTAueCAgKiB4MC54ICArIGgueCAgKiB4MC55O1xcblxcXHJcbiAgZy55eiA9IGEwLnl6ICogeDEyLnh6ICsgaC55eiAqIHgxMi55dztcXG5cXFxyXG4gIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcXG5cXFxyXG59XFxuXFxcclxudmVjNCBwZXJtdXRlKHZlYzQgeCl7cmV0dXJuIG1vZCgoKHgqMzQuMCkrMS4wKSp4LCAyODkuMCk7fVxcblxcXHJcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpe3JldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7fVxcblxcXHJcblxcblxcXHJcbmZsb2F0IHNub2lzZSh2ZWMzIHYpeyBcXG5cXFxyXG4gIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcXG5cXFxyXG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuXFxcclxuXFxuXFxcclxuLy8gRmlyc3QgY29ybmVyXFxuXFxcclxuICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcXG5cXFxyXG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuXFxcclxuXFxuXFxcclxuLy8gT3RoZXIgY29ybmVyc1xcblxcXHJcbiAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XFxuXFxcclxuICB2ZWMzIGwgPSAxLjAgLSBnO1xcblxcXHJcbiAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuXFxcclxuICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcXG5cXFxyXG5cXG5cXFxyXG4gIC8vICB4MCA9IHgwIC0gMC4gKyAwLjAgKiBDIFxcblxcXHJcbiAgdmVjMyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4eDtcXG5cXFxyXG4gIHZlYzMgeDIgPSB4MCAtIGkyICsgMi4wICogQy54eHg7XFxuXFxcclxuICB2ZWMzIHgzID0geDAgLSAxLiArIDMuMCAqIEMueHh4O1xcblxcXHJcblxcblxcXHJcbi8vIFBlcm11dGF0aW9uc1xcblxcXHJcbiAgaSA9IG1vZChpLCAyODkuMCApOyBcXG5cXFxyXG4gIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIFxcblxcXHJcbiAgICAgICAgICAgICBpLnogKyB2ZWM0KDAuMCwgaTEueiwgaTIueiwgMS4wICkpXFxuXFxcclxuICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSkgXFxuXFxcclxuICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxuXFxcclxuXFxuXFxcclxuLy8gR3JhZGllbnRzXFxuXFxcclxuLy8gKCBOKk4gcG9pbnRzIHVuaWZvcm1seSBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLilcXG5cXFxyXG4gIGZsb2F0IG5fID0gMS4wLzcuMDsgLy8gTj03XFxuXFxcclxuICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKm5zLnopOyAgLy8gIG1vZChwLE4qTilcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XFxuXFxcclxuICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXFxuXFxcclxuXFxuXFxcclxuICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XFxuXFxcclxuICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XFxuXFxcclxuICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XFxuXFxcclxuXFxuXFxcclxuICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xcblxcXHJcbiAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcblxcXHJcbiAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxuXFxcclxuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcXG5cXFxyXG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcXG5cXFxyXG5cXG5cXFxyXG4gIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XFxuXFxcclxuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcblxcXHJcbiAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXG5cXFxyXG4gIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XFxuXFxcclxuXFxuXFxcclxuLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXFxuXFxcclxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG5cXFxyXG4gIHAwICo9IG5vcm0ueDtcXG5cXFxyXG4gIHAxICo9IG5vcm0ueTtcXG5cXFxyXG4gIHAyICo9IG5vcm0uejtcXG5cXFxyXG4gIHAzICo9IG5vcm0udztcXG5cXFxyXG5cXG5cXFxyXG4vLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcXG5cXFxyXG4gIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xcblxcXHJcbiAgbSA9IG0gKiBtO1xcblxcXHJcbiAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcXG5cXFxyXG59XFxuXFxcclxuXFxuXFxcclxudmVjMyBoYXNoMyggdmVjMiBwICl7XFxuXFxcclxuICAgIHZlYzMgcSA9IHZlYzMoIGRvdChwLHZlYzIoMTI3LjEsMzExLjcpKSwgXFxuXFxcclxuXHRcdFx0XHQgICBkb3QocCx2ZWMyKDI2OS41LDE4My4zKSksIFxcblxcXHJcblx0XHRcdFx0ICAgZG90KHAsdmVjMig0MTkuMiwzNzEuOSkpICk7XFxuXFxcclxuXHRyZXR1cm4gZnJhY3Qoc2luKHEpKjQzNzU4LjU0NTMpO1xcblxcXHJcbn1cXG5cXFxyXG52ZWM0IGhhc2g0KCB2ZWMzIHAgKXtcXG5cXFxyXG4gICAgdmVjNCBxID0gdmVjNCggZG90KHAsdmVjMygxMjcuMSwzMTEuNywyNTcuMykpLCBcXG5cXFxyXG5cdFx0XHRcdCAgIGRvdChwLHZlYzMoMjY5LjUsMTgzLjMsMzM1LjEpKSwgXFxuXFxcclxuXHRcdFx0XHQgICBkb3QocCx2ZWMzKDMxNC41LDIzNS4xLDQ2Ny4zKSksIFxcblxcXHJcblx0XHRcdFx0ICAgZG90KHAsdmVjMyg0MTkuMiwzNzEuOSwxMTQuOSkpICk7XFxuXFxcclxuXHRyZXR1cm4gZnJhY3Qoc2luKHEpKjQzNzU4LjU0NTMpO1xcblxcXHJcbn1cXG5cXFxyXG5cXG5cXFxyXG5mbG9hdCBpcW5vaXNlKCBpbiB2ZWMyIHgsIGZsb2F0IHUsIGZsb2F0IHYgKXtcXG5cXFxyXG4gICAgdmVjMiBwID0gZmxvb3IoeCk7XFxuXFxcclxuICAgIHZlYzIgZiA9IGZyYWN0KHgpO1xcblxcXHJcblx0XFxuXFxcclxuXHRmbG9hdCBrID0gMS4wKzYzLjAqcG93KDEuMC12LDQuMCk7XFxuXFxcclxuXHRcXG5cXFxyXG5cdGZsb2F0IHZhID0gMC4wO1xcblxcXHJcblx0ZmxvYXQgd3QgPSAwLjA7XFxuXFxcclxuICAgIGZvciggaW50IGo9LTI7IGo8PTI7IGorKyApXFxuXFxcclxuICAgIGZvciggaW50IGk9LTI7IGk8PTI7IGkrKyApXFxuXFxcclxuICAgIHtcXG5cXFxyXG4gICAgICAgIHZlYzIgZyA9IHZlYzIoIGZsb2F0KGkpLGZsb2F0KGopICk7XFxuXFxcclxuXHRcdHZlYzMgbyA9IGhhc2gzKCBwICsgZyApKnZlYzModSx1LDEuMCk7XFxuXFxcclxuXHRcdHZlYzIgciA9IGcgLSBmICsgby54eTtcXG5cXFxyXG5cdFx0ZmxvYXQgZCA9IGRvdChyLHIpO1xcblxcXHJcblx0XHRmbG9hdCB3dyA9IHBvdyggMS4wLXNtb290aHN0ZXAoMC4wLDEuNDE0LHNxcnQoZCkpLCBrICk7XFxuXFxcclxuXHRcdHZhICs9IG8ueip3dztcXG5cXFxyXG5cdFx0d3QgKz0gd3c7XFxuXFxcclxuICAgIH1cXG5cXFxyXG5cdFxcblxcXHJcbiAgICByZXR1cm4gdmEvd3Q7XFxuXFxcclxufVxcblxcXHJcblwiXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclRpbWUoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsXCJmbG9hdFwiKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclRpbWUudGl0bGUgPSBcIlRpbWVcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyVGltZS5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblxyXG5cdFx0Y29udGV4dC5hZGRVbmlmb3JtKCBcInVfdGltZVwiICsgdGhpcy5pZCwgXCJmbG9hdFwiLCBmdW5jdGlvbigpeyByZXR1cm4gZ2V0VGltZSgpICogMC4wMDE7IH0pO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCBcImZsb2F0IFwiICsgb3V0bGluayArIFwiID0gdV90aW1lXCIgKyB0aGlzLmlkICtcIjtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgXCJmbG9hdFwiICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiaW5wdXQvdGltZVwiLCBMR3JhcGhTaGFkZXJUaW1lICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJEaXRoZXIoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLFwiVFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsXCJmbG9hdFwiKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckRpdGhlci50aXRsZSA9IFwiRGl0aGVyXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckRpdGhlci5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0dmFyIHJldHVybl90eXBlID0gXCJmbG9hdFwiO1xyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdHZhciBpbnR5cGUgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlubGluayA9IHZhclRvVHlwZUdMU0woIGlubGluaywgaW50eXBlLCBcImZsb2F0XCIgKTtcclxuXHRcdGNvbnRleHQuYWRkRnVuY3Rpb24oXCJkaXRoZXI4eDhcIiwgTEdyYXBoU2hhZGVyRGl0aGVyLmRpdGhlcl9mdW5jKTtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9IGRpdGhlcjh4OChcIisgaW5saW5rICtcIik7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHJldHVybl90eXBlICk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJEaXRoZXIuZGl0aGVyX3ZhbHVlcyA9IFswLjUxNTYyNSwwLjE0MDYyNSwwLjY0MDYyNSwwLjA0Njg3NSwwLjU0Njg3NSwwLjE3MTg3NSwwLjY3MTg3NSwwLjc2NTYyNSwwLjI2NTYyNSwwLjg5MDYyNSwwLjM5MDYyNSwwLjc5Njg3NSwwLjI5Njg3NSwwLjkyMTg3NSwwLjQyMTg3NSwwLjIwMzEyNSwwLjcwMzEyNSwwLjA3ODEyNSwwLjU3ODEyNSwwLjIzNDM3NSwwLjczNDM3NSwwLjEwOTM3NSwwLjYwOTM3NSwwLjk1MzEyNSwwLjQ1MzEyNSwwLjgyODEyNSwwLjMyODEyNSwwLjk4NDM3NSwwLjQ4NDM3NSwwLjg1OTM3NSwwLjM1OTM3NSwwLjA2MjUsMC41NjI1LDAuMTg3NSwwLjY4NzUsMC4wMzEyNSwwLjUzMTI1LDAuMTU2MjUsMC42NTYyNSwwLjgxMjUsMC4zMTI1LDAuOTM3NSwwLjQzNzUsMC43ODEyNSwwLjI4MTI1LDAuOTA2MjUsMC40MDYyNSwwLjI1LDAuNzUsMC4xMjUsMC42MjUsMC4yMTg3NSwwLjcxODc1LDAuMDkzNzUsMC41OTM3NSwxLjAwMDEsMC41LDAuODc1LDAuMzc1LDAuOTY4NzUsMC40Njg3NSwwLjg0Mzc1LDAuMzQzNzVdO1xyXG5cdFxyXG5cdExHcmFwaFNoYWRlckRpdGhlci5kaXRoZXJfZnVuYyA9IFwiXFxuXFxcclxuXHRcdGZsb2F0IGRpdGhlcjh4OChmbG9hdCBicmlnaHRuZXNzKSB7XFxuXFxcclxuXHRcdCAgdmVjMiBwb3NpdGlvbiA9IHZlYzIoMC4wKTtcXG5cXFxyXG5cdFx0ICAjaWZkZWYgRlJBR01FTlRcXG5cXFxyXG5cdFx0XHRwb3NpdGlvbiA9IGdsX0ZyYWdDb29yZC54eTtcXG5cXFxyXG5cdFx0ICAjZW5kaWZcXG5cXFxyXG5cdFx0ICBpbnQgeCA9IGludChtb2QocG9zaXRpb24ueCwgOC4wKSk7XFxuXFxcclxuXHRcdCAgaW50IHkgPSBpbnQobW9kKHBvc2l0aW9uLnksIDguMCkpO1xcblxcXHJcblx0XHQgIGludCBpbmRleCA9IHggKyB5ICogODtcXG5cXFxyXG5cdFx0ICBmbG9hdCBsaW1pdCA9IDAuMDtcXG5cXFxyXG5cdFx0ICBpZiAoeCA8IDgpIHtcXG5cXFxyXG5cdFx0XHRpZihpbmRleD09MCkgbGltaXQgPSAwLjAxNTYyNTtcXG5cXFxyXG5cdFx0XHRcIisoTEdyYXBoU2hhZGVyRGl0aGVyLmRpdGhlcl92YWx1ZXMubWFwKCBmdW5jdGlvbih2LGkpeyByZXR1cm4gXCJlbHNlIGlmKGluZGV4PT0gXCIrKGkrMSkrXCIpIGxpbWl0ID0gXCIgKyB2ICsgXCI7XCJ9KS5qb2luKFwiXFxuXCIpKStcIlxcblxcXHJcblx0XHQgIH1cXG5cXFxyXG5cdFx0ICByZXR1cm4gYnJpZ2h0bmVzcyA8IGxpbWl0ID8gMC4wIDogMS4wO1xcblxcXHJcblx0XHR9XFxuXCIsXHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJtYXRoL2RpdGhlclwiLCBMR3JhcGhTaGFkZXJEaXRoZXIgKTtcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyUmVtYXAoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIixcIlwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0bWluX3ZhbHVlOiAwLFxyXG5cdFx0XHRtYXhfdmFsdWU6IDEsXHJcblx0XHRcdG1pbl92YWx1ZTI6IDAsXHJcblx0XHRcdG1heF92YWx1ZTI6IDFcclxuXHRcdH07XHJcblx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwibWluXCIsMCx7IHN0ZXA6IDAuMSwgcHJvcGVydHk6IFwibWluX3ZhbHVlXCIgfSk7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwibWF4XCIsMSx7IHN0ZXA6IDAuMSwgcHJvcGVydHk6IFwibWF4X3ZhbHVlXCIgfSk7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwibWluMlwiLDAseyBzdGVwOiAwLjEsIHByb3BlcnR5OiBcIm1pbl92YWx1ZTJcIn0pO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcIm1heDJcIiwxLHsgc3RlcDogMC4xLCBwcm9wZXJ0eTogXCJtYXhfdmFsdWUyXCJ9KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclJlbWFwLnRpdGxlID0gXCJSZW1hcFwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJSZW1hcC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0dGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyUmVtYXAucHJvdG90eXBlLm9uQ29ubmVjdGlvbnNDaGFuZ2UgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIHJldHVybl90eXBlID0gdGhpcy5nZXRJbnB1dERhdGFUeXBlKDApO1xyXG5cdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSByZXR1cm5fdHlwZSB8fCBcIlRcIjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclJlbWFwLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0aWYoIWlubGluayAmJiAhb3V0bGluaykgLy9ub3QgY29ubmVjdGVkXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgcmV0dXJuX3R5cGUgPSB0aGlzLmdldElucHV0RGF0YVR5cGUoMCk7XHJcblx0XHR0aGlzLm91dHB1dHNbMF0udHlwZSA9IHJldHVybl90eXBlO1xyXG5cdFx0aWYocmV0dXJuX3R5cGUgPT0gXCJUXCIpXHJcblx0XHR7XHJcblx0XHRcdGNvbnNvbGUud2FybihcIm5vZGUgdHlwZSBpcyBUIGFuZCBjYW5ub3QgYmUgcmVzb2x2ZWRcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZighaW5saW5rKVxyXG5cdFx0e1xyXG5cdFx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsXCJcdFwiICsgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiICsgcmV0dXJuX3R5cGUgKyBcIigwLjApO1xcblwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtaW52ID0gdmFsdWVUb0dMU0woIHRoaXMucHJvcGVydGllcy5taW5fdmFsdWUgKTtcclxuXHRcdHZhciBtYXh2ID0gdmFsdWVUb0dMU0woIHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgKTtcclxuXHRcdHZhciBtaW52MiA9IHZhbHVlVG9HTFNMKCB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlMiApO1xyXG5cdFx0dmFyIG1heHYyID0gdmFsdWVUb0dMU0woIHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUyICk7XHJcblxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gKCAoXCIgKyBpbmxpbmsgKyBcIiAtIFwiK21pbnYrXCIpIC8gKFwiKyBtYXh2K1wiIC0gXCIrbWluditcIikgKSAqIChcIisgbWF4djIrXCIgLSBcIittaW52MitcIikgKyBcIiArIG1pbnYyICsgXCI7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHJldHVybl90eXBlICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwibWF0aC9yZW1hcFwiLCBMR3JhcGhTaGFkZXJSZW1hcCApO1xyXG5cclxufSkodGhpcyk7XHJcblxyXG5cclxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcblx0dmFyIHZpZXdfbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblx0dmFyIHByb2plY3Rpb25fbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblx0dmFyIHZpZXdwcm9qZWN0aW9uX21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cdHZhciBtb2RlbF9tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHR2YXIgZ2xvYmFsX3VuaWZvcm1zID0ge1xyXG5cdFx0dV92aWV3OiB2aWV3X21hdHJpeCxcclxuXHRcdHVfcHJvamVjdGlvbjogcHJvamVjdGlvbl9tYXRyaXgsXHJcblx0XHR1X3ZpZXdwcm9qZWN0aW9uOiB2aWV3cHJvamVjdGlvbl9tYXRyaXgsXHJcblx0XHR1X21vZGVsOiBtb2RlbF9tYXRyaXggXHJcblx0fTtcclxuXHJcblx0TGl0ZUdyYXBoLkxHcmFwaFJlbmRlciA9IHtcclxuXHRcdG9uUmVxdWVzdENhbWVyYU1hdHJpY2VzOiBudWxsIC8vb3ZlcndyaXRlIHdpdGggeW91ciAzRCBlbmdpbmUgc3BlY2lmaWNzLCBpdCB3aWxsIHJlY2VpdmUgKHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXgpIGFuZCBtdXN0IGJlIGZpbGxlZFxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlR2VvbWV0cnlJZCgpIHtcclxuXHRcdHJldHVybiAoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCl8MDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFBvaW50czNEKCkge1xyXG5cclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJvYmpcIiwgXCJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwicmFkaXVzXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInBvaW50c1wiLCBcIlt2ZWMzXVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0cmFkaXVzOiAxLFxyXG5cdFx0XHRudW1fcG9pbnRzOiA0MDk2LFxyXG5cdFx0XHRnZW5lcmF0ZV9ub3JtYWxzOiB0cnVlLFxyXG5cdFx0XHRyZWd1bGFyOiBmYWxzZSxcclxuXHRcdFx0bW9kZTogTEdyYXBoUG9pbnRzM0QuU1BIRVJFLFxyXG5cdFx0XHRmb3JjZV91cGRhdGU6IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5wcm9wZXJ0aWVzLm51bV9wb2ludHMgKiAzICk7XHJcblx0XHR0aGlzLm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnByb3BlcnRpZXMubnVtX3BvaW50cyAqIDMgKTtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLFwidXBkYXRlXCIsbnVsbCwgZnVuY3Rpb24oKXsgdGhhdC5tdXN0X3VwZGF0ZSA9IHRydWU7IH0pO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSB7XHJcblx0XHRcdHZlcnRpY2VzOiBudWxsLFxyXG5cdFx0XHRfaWQ6IGdlbmVyYXRlR2VvbWV0cnlJZCgpXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fb2xkX29iaiA9IG51bGw7XHJcblx0XHR0aGlzLl9sYXN0X3JhZGl1cyA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRnbG9iYWwuTEdyYXBoUG9pbnRzM0QgPSBMR3JhcGhQb2ludHMzRDtcclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuUkVDVEFOR0xFID0gMTtcclxuXHRMR3JhcGhQb2ludHMzRC5DSVJDTEUgPSAyO1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5DVUJFID0gMTA7XHJcblx0TEdyYXBoUG9pbnRzM0QuU1BIRVJFID0gMTE7XHJcblx0TEdyYXBoUG9pbnRzM0QuSEVNSVNQSEVSRSA9IDEyO1xyXG5cdExHcmFwaFBvaW50czNELklOU0lERV9TUEhFUkUgPSAxMztcclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuT0JKRUNUID0gMjA7XHJcblx0TEdyYXBoUG9pbnRzM0QuT0JKRUNUX1VOSUZPUk1MWSA9IDIxO1xyXG5cdExHcmFwaFBvaW50czNELk9CSkVDVF9JTlNJREUgPSAyMjtcclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuTU9ERV9WQUxVRVMgPSB7IFwicmVjdGFuZ2xlXCI6TEdyYXBoUG9pbnRzM0QuUkVDVEFOR0xFLCBcImNpcmNsZVwiOkxHcmFwaFBvaW50czNELkNJUkNMRSwgXCJjdWJlXCI6TEdyYXBoUG9pbnRzM0QuQ1VCRSwgXCJzcGhlcmVcIjpMR3JhcGhQb2ludHMzRC5TUEhFUkUsIFwiaGVtaXNwaGVyZVwiOkxHcmFwaFBvaW50czNELkhFTUlTUEhFUkUsIFwiaW5zaWRlX3NwaGVyZVwiOkxHcmFwaFBvaW50czNELklOU0lERV9TUEhFUkUsIFwib2JqZWN0XCI6TEdyYXBoUG9pbnRzM0QuT0JKRUNULCBcIm9iamVjdF91bmlmb3JtbHlcIjpMR3JhcGhQb2ludHMzRC5PQkpFQ1RfVU5JRk9STUxZLCBcIm9iamVjdF9pbnNpZGVcIjpMR3JhcGhQb2ludHMzRC5PQkpFQ1RfSU5TSURFIH07XHJcblxyXG5cdExHcmFwaFBvaW50czNELndpZGdldHNfaW5mbyA9IHtcclxuXHRcdG1vZGU6IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoUG9pbnRzM0QuTU9ERV9WQUxVRVMgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaFBvaW50czNELnRpdGxlID0gXCJsaXN0IG9mIHBvaW50c1wiO1xyXG5cdExHcmFwaFBvaW50czNELmRlc2MgPSBcInJldHVybnMgYW4gYXJyYXkgb2YgcG9pbnRzXCI7XHJcblxyXG5cdExHcmFwaFBvaW50czNELnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIG9iaiAhPSB0aGlzLl9vbGRfb2JqIHx8IChvYmogJiYgb2JqLl92ZXJzaW9uICE9IHRoaXMuX29sZF9vYmpfdmVyc2lvbikgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLl9vbGRfb2JqID0gb2JqO1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHRpZihyYWRpdXMgPT0gbnVsbClcclxuXHRcdFx0cmFkaXVzID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1cztcclxuXHRcdGlmKCB0aGlzLl9sYXN0X3JhZGl1cyAhPSByYWRpdXMgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLl9sYXN0X3JhZGl1cyA9IHJhZGl1cztcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5tdXN0X3VwZGF0ZSB8fCB0aGlzLnByb3BlcnRpZXMuZm9yY2VfdXBkYXRlIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZVBvaW50cygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkudmVydGljZXMgPSB0aGlzLnBvaW50cztcclxuXHRcdHRoaXMuZ2VvbWV0cnkubm9ybWFscyA9IHRoaXMubm9ybWFscztcclxuXHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSB0aGlzLnZlcnNpb247XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0aGlzLmdlb21ldHJ5ICk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5wcm90b3R5cGUudXBkYXRlUG9pbnRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbnVtX3BvaW50cyA9IHRoaXMucHJvcGVydGllcy5udW1fcG9pbnRzfDA7XHJcblx0XHRpZihudW1fcG9pbnRzIDwgMSlcclxuXHRcdFx0bnVtX3BvaW50cyA9IDE7XHJcblxyXG5cdFx0aWYoIXRoaXMucG9pbnRzIHx8IHRoaXMucG9pbnRzLmxlbmd0aCAhPSBudW1fcG9pbnRzICogMylcclxuXHRcdFx0dGhpcy5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1fcG9pbnRzICogMyApO1xyXG5cclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9ub3JtYWxzKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoIXRoaXMubm9ybWFscyB8fCB0aGlzLm5vcm1hbHMubGVuZ3RoICE9IHRoaXMucG9pbnRzLmxlbmd0aClcclxuXHRcdFx0XHR0aGlzLm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnBvaW50cy5sZW5ndGggKTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5ub3JtYWxzID0gbnVsbDtcclxuXHJcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5fbGFzdF9yYWRpdXMgfHwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1cztcclxuXHRcdHZhciBtb2RlID0gdGhpcy5wcm9wZXJ0aWVzLm1vZGU7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dGhpcy5fb2xkX29ial92ZXJzaW9uID0gb2JqID8gb2JqLl92ZXJzaW9uIDogbnVsbDtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IExHcmFwaFBvaW50czNELmdlbmVyYXRlUG9pbnRzKCByYWRpdXMsIG51bV9wb2ludHMsIG1vZGUsIHRoaXMucG9pbnRzLCB0aGlzLm5vcm1hbHMsIHRoaXMucHJvcGVydGllcy5yZWd1bGFyLCBvYmogKTtcclxuXHJcblx0XHR0aGlzLnZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdC8vZ2xvYmFsXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVQb2ludHMgPSBmdW5jdGlvbiggcmFkaXVzLCBudW1fcG9pbnRzLCBtb2RlLCBwb2ludHMsIG5vcm1hbHMsIHJlZ3VsYXIsIG9iaiApXHJcblx0e1xyXG5cdFx0dmFyIHNpemUgPSBudW1fcG9pbnRzICogMztcclxuXHRcdGlmKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCAhPSBzaXplKVxyXG5cdFx0XHRwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplICk7XHJcblx0XHR2YXIgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcblx0XHR2YXIgVVAgPSBuZXcgRmxvYXQzMkFycmF5KFswLDEsMF0pO1xyXG5cclxuXHRcdGlmKHJlZ3VsYXIpXHJcblx0XHR7XHJcblx0XHRcdGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELlJFQ1RBTkdMRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBzaWRlID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobnVtX3BvaW50cykpO1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaWRlOyArK2kpXHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHNpZGU7ICsrailcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgcG9zID0gaSozICsgaiozKnNpZGU7XHJcblx0XHRcdFx0XHRwb2ludHNbcG9zXSA9ICgoaS9zaWRlKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdFx0cG9pbnRzW3BvcysxXSA9IDA7XHJcblx0XHRcdFx0XHRwb2ludHNbcG9zKzJdID0gKChqL3NpZGUpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvaW50cy5zdWJhcnJheSgwLHNpZGUqc2lkZSozKSApO1xyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0XHRcdFx0XHRub3JtYWxzLnNldChVUCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuU1BIRVJFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHNpZGUgPSBNYXRoLmZsb29yKE1hdGguc3FydChudW1fcG9pbnRzKSk7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpZGU7ICsraSlcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgc2lkZTsgKytqKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBwb3MgPSBpKjMgKyBqKjMqc2lkZTtcclxuXHRcdFx0XHRcdHBvbGFyVG9DYXJ0ZXNpYW4oIHRlbXAsIChpL3NpZGUpICogMiAqIE1hdGguUEksICgoai9zaWRlKSAtIDAuNSkgKiAyICogTWF0aC5QSSwgcmFkaXVzICk7XHJcblx0XHRcdFx0XHRwb2ludHNbcG9zXSA9IHRlbXBbMF07XHJcblx0XHRcdFx0XHRwb2ludHNbcG9zKzFdID0gdGVtcFsxXTtcclxuXHRcdFx0XHRcdHBvaW50c1twb3MrMl0gPSB0ZW1wWzJdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCBwb2ludHMuc3ViYXJyYXkoMCxzaWRlKnNpZGUqMykgKTtcclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzKCBwb2ludHMsIG5vcm1hbHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELkNJUkNMRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBhbmdsZSA9IDIgKiBNYXRoLlBJICogKGkvc2l6ZSk7XHJcblx0XHRcdFx0XHRwb2ludHNbaV0gPSBNYXRoLmNvcyggYW5nbGUgKSAqIHJhZGl1cztcclxuXHRcdFx0XHRcdHBvaW50c1tpKzFdID0gMDtcclxuXHRcdFx0XHRcdHBvaW50c1tpKzJdID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0XHRcdFx0XHRub3JtYWxzLnNldChVUCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIC8vbm9uIHJlZ3VsYXJcclxuXHRcdHtcclxuXHRcdFx0aWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuUkVDVEFOR0xFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0cG9pbnRzW2ldID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHRcdHBvaW50c1tpKzFdID0gMDtcclxuXHRcdFx0XHRcdHBvaW50c1tpKzJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrPTMpXHJcblx0XHRcdFx0XHRcdG5vcm1hbHMuc2V0KFVQLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5DVUJFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0cG9pbnRzW2ldID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHRcdHBvaW50c1tpKzFdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHRcdHBvaW50c1tpKzJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrPTMpXHJcblx0XHRcdFx0XHRcdG5vcm1hbHMuc2V0KFVQLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5TUEhFUkUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyZSggcG9pbnRzLCBzaXplLCByYWRpdXMgKTtcclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzKCBwb2ludHMsIG5vcm1hbHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELkhFTUlTUEhFUkUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUhlbWlzcGhlcmUoIHBvaW50cywgc2l6ZSwgcmFkaXVzICk7XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyggcG9pbnRzLCBub3JtYWxzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5DSVJDTEUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUluc2lkZUNpcmNsZSggcG9pbnRzLCBzaXplLCByYWRpdXMgKTtcclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzKCBwb2ludHMsIG5vcm1hbHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELklOU0lERV9TUEhFUkUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUluc2lkZVNwaGVyZSggcG9pbnRzLCBzaXplLCByYWRpdXMgKTtcclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmljYWxOb3JtYWxzKCBwb2ludHMsIG5vcm1hbHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELk9CSkVDVClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlRnJvbU9iamVjdCggcG9pbnRzLCBub3JtYWxzLCBzaXplLCBvYmosIGZhbHNlICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5PQkpFQ1RfVU5JRk9STUxZKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVGcm9tT2JqZWN0KCBwb2ludHMsIG5vcm1hbHMsIHNpemUsIG9iaiwgdHJ1ZSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuT0JKRUNUX0lOU0lERSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlRnJvbUluc2lkZU9iamVjdCggcG9pbnRzLCBzaXplLCBvYmogKTtcclxuXHRcdFx0XHQvL2lmKG5vcm1hbHMpXHJcblx0XHRcdFx0Ly9cdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyggcG9pbnRzLCBub3JtYWxzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIndyb25nIG1vZGUgaW4gTEdyYXBoUG9pbnRzM0RcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyA9IGZ1bmN0aW9uKHBvaW50cywgbm9ybWFscylcclxuXHR7XHJcblx0XHR2YXIgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHRlbXBbMF0gPSBwb2ludHNbaV07XHJcblx0XHRcdHRlbXBbMV0gPSBwb2ludHNbaSsxXTtcclxuXHRcdFx0dGVtcFsyXSA9IHBvaW50c1tpKzJdO1xyXG5cdFx0XHR2ZWMzLm5vcm1hbGl6ZSh0ZW1wLHRlbXApO1xyXG5cdFx0XHRub3JtYWxzLnNldCh0ZW1wLGkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmUgPSBmdW5jdGlvbiAocG9pbnRzLCBzaXplLCByYWRpdXMpXHJcblx0e1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHZhciByMSA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciByMiA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciB4ID0gMiAqIE1hdGguY29zKCAyICogTWF0aC5QSSAqIHIxICkgKiBNYXRoLnNxcnQoIHIyICogKDEtcjIpICk7XHJcblx0XHRcdHZhciB5ID0gMSAtIDIgKiByMjtcclxuXHRcdFx0dmFyIHogPSAyICogTWF0aC5zaW4oIDIgKiBNYXRoLlBJICogcjEgKSAqIE1hdGguc3FydCggcjIgKiAoMS1yMikgKTtcclxuXHRcdFx0cG9pbnRzW2ldID0geCAqIHJhZGl1cztcclxuXHRcdFx0cG9pbnRzW2krMV0gPSB5ICogcmFkaXVzO1xyXG5cdFx0XHRwb2ludHNbaSsyXSA9IHogKiByYWRpdXM7XHJcblx0XHR9XHRcdFx0XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUhlbWlzcGhlcmUgPSBmdW5jdGlvbiAocG9pbnRzLCBzaXplLCByYWRpdXMpXHJcblx0e1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHZhciByMSA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciByMiA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciB4ID0gTWF0aC5jb3MoIDIgKiBNYXRoLlBJICogcjEgKSAqIE1hdGguc3FydCgxIC0gcjIqcjIgKTtcclxuXHRcdFx0dmFyIHkgPSByMjtcclxuXHRcdFx0dmFyIHogPSBNYXRoLnNpbiggMiAqIE1hdGguUEkgKiByMSApICogTWF0aC5zcXJ0KDEgLSByMipyMiApO1xyXG5cdFx0XHRwb2ludHNbaV0gPSB4ICogcmFkaXVzO1xyXG5cdFx0XHRwb2ludHNbaSsxXSA9IHkgKiByYWRpdXM7XHJcblx0XHRcdHBvaW50c1tpKzJdID0geiAqIHJhZGl1cztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlSW5zaWRlQ2lyY2xlID0gZnVuY3Rpb24gKHBvaW50cywgc2l6ZSwgcmFkaXVzKVxyXG5cdHtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgcjEgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgcjIgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgeCA9IE1hdGguY29zKCAyICogTWF0aC5QSSAqIHIxICkgKiBNYXRoLnNxcnQoMSAtIHIyKnIyICk7XHJcblx0XHRcdHZhciB5ID0gcjI7XHJcblx0XHRcdHZhciB6ID0gTWF0aC5zaW4oIDIgKiBNYXRoLlBJICogcjEgKSAqIE1hdGguc3FydCgxIC0gcjIqcjIgKTtcclxuXHRcdFx0cG9pbnRzW2ldID0geCAqIHJhZGl1cztcclxuXHRcdFx0cG9pbnRzW2krMV0gPSAwO1xyXG5cdFx0XHRwb2ludHNbaSsyXSA9IHogKiByYWRpdXM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUluc2lkZVNwaGVyZSA9IGZ1bmN0aW9uIChwb2ludHMsIHNpemUsIHJhZGl1cylcclxuXHR7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dmFyIHUgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgdiA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciB0aGV0YSA9IHUgKiAyLjAgKiBNYXRoLlBJO1xyXG5cdFx0XHR2YXIgcGhpID0gTWF0aC5hY29zKDIuMCAqIHYgLSAxLjApO1xyXG5cdFx0XHR2YXIgciA9IE1hdGguY2JydChNYXRoLnJhbmRvbSgpKSAqIHJhZGl1cztcclxuXHRcdFx0dmFyIHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xyXG5cdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XHJcblx0XHRcdHZhciBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHR2YXIgY29zUGhpID0gTWF0aC5jb3MocGhpKTtcclxuXHRcdFx0cG9pbnRzW2ldID0gciAqIHNpblBoaSAqIGNvc1RoZXRhO1xyXG5cdFx0XHRwb2ludHNbaSsxXSA9IHIgKiBzaW5QaGkgKiBzaW5UaGV0YTtcclxuXHRcdFx0cG9pbnRzW2krMl0gPSByICogY29zUGhpO1xyXG5cdFx0fVx0XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmaW5kUmFuZG9tVHJpYW5nbGUoIGFyZWFzLCBmIClcclxuXHR7XHJcblx0XHR2YXIgbCA9IGFyZWFzLmxlbmd0aDtcclxuXHRcdHZhciBpbWluID0gMDtcclxuXHRcdHZhciBpbWlkID0gMDtcclxuXHRcdHZhciBpbWF4ID0gbDtcclxuXHJcblx0XHRpZihsID09IDApXHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdGlmKGwgPT0gMSlcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHQvL2RpY2hvdGltaWMgc2VhcmNoXHJcblx0XHR3aGlsZSAoaW1heCA+PSBpbWluKVxyXG5cdFx0e1xyXG5cdFx0XHRpbWlkID0gKChpbWF4ICsgaW1pbikqMC41KXwwO1xyXG5cdFx0XHR2YXIgdCA9IGFyZWFzWyBpbWlkIF07XHJcblx0XHRcdGlmKCB0ID09IGYgKVxyXG5cdFx0XHRcdHJldHVybiBpbWlkOyBcclxuXHRcdFx0aWYoIGltaW4gPT0gKGltYXggLSAxKSApXHJcblx0XHRcdFx0cmV0dXJuIGltaW47XHJcblx0XHRcdGlmICh0IDwgZilcclxuXHRcdFx0XHRpbWluID0gaW1pZDtcclxuXHRcdFx0ZWxzZSAgICAgICAgIFxyXG5cdFx0XHRcdGltYXggPSBpbWlkO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGltaWQ7XHRcdFxyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVGcm9tT2JqZWN0ID0gZnVuY3Rpb24oIHBvaW50cywgbm9ybWFscywgc2l6ZSwgb2JqLCBldmVubHkgKVxyXG5cdHtcclxuXHRcdGlmKCFvYmopXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBudWxsO1xyXG5cdFx0dmFyIG1lc2hfbm9ybWFscyA9IG51bGw7XHJcblx0XHR2YXIgaW5kaWNlcyA9IG51bGw7XHJcblx0XHR2YXIgYXJlYXMgPSBudWxsO1xyXG5cdFx0aWYoIG9iai5jb25zdHJ1Y3RvciA9PT0gR0wuTWVzaCApXHJcblx0XHR7XHJcblx0XHRcdHZlcnRpY2VzID0gb2JqLnZlcnRleEJ1ZmZlcnMudmVydGljZXMuZGF0YTtcclxuXHRcdFx0bWVzaF9ub3JtYWxzID0gb2JqLnZlcnRleEJ1ZmZlcnMubm9ybWFscyA/IG9iai52ZXJ0ZXhCdWZmZXJzLm5vcm1hbHMuZGF0YSA6IG51bGw7XHJcblx0XHRcdGluZGljZXMgPSBvYmouaW5kZXhCdWZmZXJzLmluZGljZXMgPyBvYmouaW5kZXhCdWZmZXJzLmluZGljZXMuZGF0YSA6IG51bGw7XHJcblx0XHRcdGlmKCFpbmRpY2VzKVxyXG5cdFx0XHRcdGluZGljZXMgPSBvYmouaW5kZXhCdWZmZXJzLnRyaWFuZ2xlcyA/IG9iai5pbmRleEJ1ZmZlcnMudHJpYW5nbGVzLmRhdGEgOiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYoIXZlcnRpY2VzKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBudW1fdHJpYW5nbGVzID0gaW5kaWNlcyA/IGluZGljZXMubGVuZ3RoIC8gMyA6IHZlcnRpY2VzLmxlbmd0aCAvICgzKjMpO1xyXG5cdFx0dmFyIHRvdGFsX2FyZWEgPSAwOyAvL3N1bSBvZiBhcmVhcyBvZiBhbGwgdHJpYW5nbGVzXHJcblxyXG5cdFx0aWYoZXZlbmx5KVxyXG5cdFx0e1xyXG5cdFx0XHRhcmVhcyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtX3RyaWFuZ2xlcyk7IC8vYWNjdW1cclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG51bV90cmlhbmdsZXM7ICsraSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKGluZGljZXMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0YSA9IGluZGljZXNbaSozXSozO1xyXG5cdFx0XHRcdFx0YiA9IGluZGljZXNbaSozKzFdKjM7XHJcblx0XHRcdFx0XHRjID0gaW5kaWNlc1tpKjMrMl0qMztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGEgPSBpKjk7XHJcblx0XHRcdFx0XHRiID0gaSo5KzM7XHJcblx0XHRcdFx0XHRjID0gaSo5KzY7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBQMSA9IHZlcnRpY2VzLnN1YmFycmF5KGEsYSszKTtcclxuXHRcdFx0XHR2YXIgUDIgPSB2ZXJ0aWNlcy5zdWJhcnJheShiLGIrMyk7XHJcblx0XHRcdFx0dmFyIFAzID0gdmVydGljZXMuc3ViYXJyYXkoYyxjKzMpO1xyXG5cdFx0XHRcdHZhciBhTCA9IHZlYzMuZGlzdGFuY2UoIFAxLCBQMiApO1xyXG5cdFx0XHRcdHZhciBiTCA9IHZlYzMuZGlzdGFuY2UoIFAyLCBQMyApO1xyXG5cdFx0XHRcdHZhciBjTCA9IHZlYzMuZGlzdGFuY2UoIFAzLCBQMSApO1xyXG5cdFx0XHRcdHZhciBzID0gKGFMICsgYkwrIGNMKSAvIDI7XHJcblx0XHRcdFx0dG90YWxfYXJlYSArPSBNYXRoLnNxcnQocyAqIChzIC0gYUwpICogKHMgLSBiTCkgKiAocyAtIGNMKSk7XHJcblx0XHRcdFx0YXJlYXNbaV0gPSB0b3RhbF9hcmVhO1xyXG5cdFx0XHR9XHRcdFx0XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBudW1fdHJpYW5nbGVzOyArK2kpIC8vbm9ybWFsaXplXHJcblx0XHRcdFx0YXJlYXNbaV0gLz0gdG90YWxfYXJlYTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dmFyIHIgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgaW5kZXggPSBldmVubHkgPyBmaW5kUmFuZG9tVHJpYW5nbGUoIGFyZWFzLCByICkgOiBNYXRoLmZsb29yKHIgKiBudW1fdHJpYW5nbGVzICk7XHJcblx0XHRcdC8vZ2V0IHJhbmRvbSB0cmlhbmdsZVxyXG5cdFx0XHR2YXIgYSA9IDA7XHJcblx0XHRcdHZhciBiID0gMDtcclxuXHRcdFx0dmFyIGMgPSAwO1xyXG5cdFx0XHRpZihpbmRpY2VzKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0YSA9IGluZGljZXNbaW5kZXgqM10qMztcclxuXHRcdFx0XHRiID0gaW5kaWNlc1tpbmRleCozKzFdKjM7XHJcblx0XHRcdFx0YyA9IGluZGljZXNbaW5kZXgqMysyXSozO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGEgPSBpbmRleCo5O1xyXG5cdFx0XHRcdGIgPSBpbmRleCo5KzM7XHJcblx0XHRcdFx0YyA9IGluZGV4KjkrNjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgcyA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciB0ID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHNxcnRfcyA9IE1hdGguc3FydChzKTtcclxuXHRcdFx0dmFyIGFmID0gMSAtIHNxcnRfcztcclxuXHRcdFx0dmFyIGJmID0gc3FydF9zICogKCAxIC0gdCk7XHJcblx0XHRcdHZhciBjZiA9IHQgKiBzcXJ0X3M7XHJcblx0XHRcdHBvaW50c1tpXSA9IGFmICogdmVydGljZXNbYV0gKyBiZip2ZXJ0aWNlc1tiXSArIGNmKnZlcnRpY2VzW2NdO1xyXG5cdFx0XHRwb2ludHNbaSsxXSA9IGFmICogdmVydGljZXNbYSsxXSArIGJmKnZlcnRpY2VzW2IrMV0gKyBjZip2ZXJ0aWNlc1tjKzFdO1xyXG5cdFx0XHRwb2ludHNbaSsyXSA9IGFmICogdmVydGljZXNbYSsyXSArIGJmKnZlcnRpY2VzW2IrMl0gKyBjZip2ZXJ0aWNlc1tjKzJdO1xyXG5cdFx0XHRpZihub3JtYWxzICYmIG1lc2hfbm9ybWFscylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5vcm1hbHNbaV0gPSBhZiAqIG1lc2hfbm9ybWFsc1thXSArIGJmKm1lc2hfbm9ybWFsc1tiXSArIGNmKm1lc2hfbm9ybWFsc1tjXTtcclxuXHRcdFx0XHRub3JtYWxzW2krMV0gPSBhZiAqIG1lc2hfbm9ybWFsc1thKzFdICsgYmYqbWVzaF9ub3JtYWxzW2IrMV0gKyBjZiptZXNoX25vcm1hbHNbYysxXTtcclxuXHRcdFx0XHRub3JtYWxzW2krMl0gPSBhZiAqIG1lc2hfbm9ybWFsc1thKzJdICsgYmYqbWVzaF9ub3JtYWxzW2IrMl0gKyBjZiptZXNoX25vcm1hbHNbYysyXTtcclxuXHRcdFx0XHR2YXIgTiA9IG5vcm1hbHMuc3ViYXJyYXkoaSxpKzMpO1xyXG5cdFx0XHRcdHZlYzMubm9ybWFsaXplKE4sTik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlRnJvbUluc2lkZU9iamVjdCA9IGZ1bmN0aW9uKCBwb2ludHMsIHNpemUsIG1lc2ggKVxyXG5cdHtcclxuXHRcdGlmKCFtZXNoIHx8IG1lc2guY29uc3RydWN0b3IgIT09IEdMLk1lc2gpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgYWFiYiA9IG1lc2guZ2V0Qm91bmRpbmdCb3goKTtcclxuXHRcdGlmKCFtZXNoLm9jdHJlZSlcclxuXHRcdFx0bWVzaC5vY3RyZWUgPSBuZXcgR0wuT2N0cmVlKCBtZXNoICk7XHJcblx0XHR2YXIgb2N0cmVlID0gbWVzaC5vY3RyZWU7XHJcblx0XHR2YXIgb3JpZ2luID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciBkaXJlY3Rpb24gPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xyXG5cdFx0dmFyIHRlbXAgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIGkgPSAwO1xyXG5cdFx0dmFyIHRyaWVzID0gMDtcclxuXHRcdHdoaWxlKGkgPCBzaXplICYmIHRyaWVzIDwgcG9pbnRzLmxlbmd0aCAqIDEwKSAvL2xpbWl0IHRvIGF2b2lkIHByb2JsZW1zXHJcblx0XHR7XHJcblx0XHRcdHRyaWVzICs9IDFcclxuXHRcdFx0dmFyIHIgPSB2ZWMzLnJhbmRvbSh0ZW1wKTsgLy9yYW5kb20gcG9pbnQgaW5zaWRlIHRoZSBhYWJiXHJcblx0XHRcdHJbMF0gPSAoclswXSAqIDIgLSAxKSAqIGFhYmJbM10gKyBhYWJiWzBdO1xyXG5cdFx0XHRyWzFdID0gKHJbMV0gKiAyIC0gMSkgKiBhYWJiWzRdICsgYWFiYlsxXTtcclxuXHRcdFx0clsyXSA9IChyWzJdICogMiAtIDEpICogYWFiYls1XSArIGFhYmJbMl07XHJcblx0XHRcdG9yaWdpbi5zZXQocik7XHJcblx0XHRcdHZhciBoaXQgPSBvY3RyZWUudGVzdFJheSggb3JpZ2luLCBkaXJlY3Rpb24sIDAsIDEwMDAwLCB0cnVlLCBHTC5PY3RyZWUuQUxMICk7XHJcblx0XHRcdGlmKCFoaXQgfHwgaGl0Lmxlbmd0aCAlIDIgPT0gMCkgLy9ub3QgaW5zaWRlXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHBvaW50cy5zZXQoIHIsIGkgKTtcclxuXHRcdFx0aSs9MztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3BvaW50czNEXCIsIExHcmFwaFBvaW50czNEICk7XHJcblxyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwicG9pbnRzXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcImluc3RhbmNlc1wiLCBcIlttYXQ0XVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0bW9kZTogMSxcclxuXHRcdFx0YXV0b3VwZGF0ZTogdHJ1ZVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMubWF0cmljZXMgPSBbXTtcclxuXHRcdHRoaXMuZmlyc3RfdGltZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5OT1JNQUwgPSAwO1xyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlZFUlRJQ0FMID0gMTtcclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5TUEhFUklDQUwgPSAyO1xyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlJBTkRPTSA9IDM7XHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuUkFORE9NX1ZFUlRJQ0FMID0gNDtcclxuXHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMubW9kZXMgPSB7XCJub3JtYWxcIjowLFwidmVydGljYWxcIjoxLFwic3BoZXJpY2FsXCI6MixcInJhbmRvbVwiOjMsXCJyYW5kb21fdmVydGljYWxcIjo0fTtcclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRtb2RlOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLm1vZGVzIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy50aXRsZSA9IFwicG9pbnRzIHRvIGluc3RcIjtcclxuXHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgZ2VvID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZiggIWdlbyApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLG51bGwpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBoYXNfY2hhbmdlZCA9IChnZW8uX3ZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbiB8fCBnZW8uX2lkICE9IHRoaXMuX2dlb21ldHJ5X2lkKTtcclxuXHJcblx0XHRpZiggaGFzX2NoYW5nZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmF1dG91cGRhdGUgfHwgdGhpcy5maXJzdF90aW1lIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5maXJzdF90aW1lID0gZmFsc2U7XHJcblx0XHRcdHRoaXMudXBkYXRlSW5zdGFuY2VzKCBnZW8gKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMubWF0cmljZXMgKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLnByb3RvdHlwZS51cGRhdGVJbnN0YW5jZXMgPSBmdW5jdGlvbiggZ2VvbWV0cnkgKVxyXG5cdHtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0aWYoIXZlcnRpY2VzKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBub3JtYWxzID0gZ2VvbWV0cnkubm9ybWFscztcclxuXHJcblx0XHR2YXIgbWF0cmljZXMgPSB0aGlzLm1hdHJpY2VzO1xyXG5cdFx0dmFyIG51bV9wb2ludHMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xyXG5cdFx0aWYoIG1hdHJpY2VzLmxlbmd0aCAhPSBudW1fcG9pbnRzKVxyXG5cdFx0XHRtYXRyaWNlcy5sZW5ndGggPSBudW1fcG9pbnRzO1xyXG5cdFx0dmFyIGlkZW50aXR5ID0gbWF0NC5jcmVhdGUoKTtcclxuXHRcdHZhciB0ZW1wID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciB6ZXJvID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciBVUCA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XHJcblx0XHR2YXIgRlJPTlQgPSB2ZWMzLmZyb21WYWx1ZXMoMCwwLC0xKTtcclxuXHRcdHZhciBSSUdIVCA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XHJcblx0XHR2YXIgUiA9IHF1YXQuY3JlYXRlKCk7XHJcblxyXG5cdFx0dmFyIGZyb250ID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciByaWdodCA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgdG9wID0gdmVjMy5jcmVhdGUoKTtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDMpXHJcblx0XHR7XHJcblx0XHRcdHZhciBpbmRleCA9IGkvMztcclxuXHRcdFx0dmFyIG0gPSBtYXRyaWNlc1tpbmRleF07XHJcblx0XHRcdGlmKCFtKVxyXG5cdFx0XHRcdG0gPSBtYXRyaWNlc1tpbmRleF0gPSBtYXQ0LmNyZWF0ZSgpO1xyXG5cdFx0XHRtLnNldCggaWRlbnRpdHkgKTtcclxuXHRcdFx0dmFyIHBvaW50ID0gdmVydGljZXMuc3ViYXJyYXkoaSxpKzMpO1xyXG5cclxuXHRcdFx0c3dpdGNoKHRoaXMucHJvcGVydGllcy5tb2RlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y2FzZSBMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5OT1JNQUw6IFxyXG5cdFx0XHRcdFx0bWF0NC5zZXRUcmFuc2xhdGlvbiggbSwgcG9pbnQgKTtcclxuXHRcdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHZhciBub3JtYWwgPSBub3JtYWxzLnN1YmFycmF5KGksaSszKTtcclxuXHRcdFx0XHRcdFx0dG9wLnNldCggbm9ybWFsICk7XHJcblx0XHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCB0b3AsIHRvcCApO1xyXG5cdFx0XHRcdFx0XHR2ZWMzLmNyb3NzKCByaWdodCwgRlJPTlQsIHRvcCApO1xyXG5cdFx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggcmlnaHQsIHJpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdHZlYzMuY3Jvc3MoIGZyb250LCByaWdodCwgdG9wICk7XHJcblx0XHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCBmcm9udCwgZnJvbnQgKTtcclxuXHRcdFx0XHRcdFx0bS5zZXQocmlnaHQsMCk7XHJcblx0XHRcdFx0XHRcdG0uc2V0KHRvcCw0KTtcclxuXHRcdFx0XHRcdFx0bS5zZXQoZnJvbnQsOCk7XHJcblx0XHRcdFx0XHRcdG1hdDQuc2V0VHJhbnNsYXRpb24oIG0sIHBvaW50ICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlZFUlRJQ0FMOiBcclxuXHRcdFx0XHRcdG1hdDQuc2V0VHJhbnNsYXRpb24oIG0sIHBvaW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlNQSEVSSUNBTDogXHJcblx0XHRcdFx0XHRmcm9udC5zZXQoIHBvaW50ICk7XHJcblx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggZnJvbnQsIGZyb250ICk7XHJcblx0XHRcdFx0XHR2ZWMzLmNyb3NzKCByaWdodCwgVVAsIGZyb250ICk7XHJcblx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggcmlnaHQsIHJpZ2h0ICk7XHJcblx0XHRcdFx0XHR2ZWMzLmNyb3NzKCB0b3AsIGZyb250LCByaWdodCApO1xyXG5cdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIHRvcCwgdG9wICk7XHJcblx0XHRcdFx0XHRtLnNldChyaWdodCwwKTtcclxuXHRcdFx0XHRcdG0uc2V0KHRvcCw0KTtcclxuXHRcdFx0XHRcdG0uc2V0KGZyb250LDgpO1xyXG5cdFx0XHRcdFx0bWF0NC5zZXRUcmFuc2xhdGlvbiggbSwgcG9pbnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuUkFORE9NOlxyXG5cdFx0XHRcdFx0dGVtcFswXSA9IE1hdGgucmFuZG9tKCkqMiAtIDE7XHJcblx0XHRcdFx0XHR0ZW1wWzFdID0gTWF0aC5yYW5kb20oKSoyIC0gMTtcclxuXHRcdFx0XHRcdHRlbXBbMl0gPSBNYXRoLnJhbmRvbSgpKjIgLSAxO1xyXG5cdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIHRlbXAsIHRlbXAgKTtcclxuXHRcdFx0XHRcdHF1YXQuc2V0QXhpc0FuZ2xlKCBSLCB0ZW1wLCBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEkgKTtcclxuXHRcdFx0XHRcdG1hdDQuZnJvbVF1YXQobSwgUik7XHJcblx0XHRcdFx0XHRtYXQ0LnNldFRyYW5zbGF0aW9uKCBtLCBwb2ludCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5SQU5ET01fVkVSVElDQUw6XHJcblx0XHRcdFx0XHRxdWF0LnNldEF4aXNBbmdsZSggUiwgVVAsIE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSSApO1xyXG5cdFx0XHRcdFx0bWF0NC5mcm9tUXVhdChtLCBSKTtcclxuXHRcdFx0XHRcdG1hdDQuc2V0VHJhbnNsYXRpb24oIG0sIHBvaW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3ZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHRcdHRoaXMuX2dlb21ldHJ5X2lkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvcG9pbnRzX3RvX2luc3RhbmNlc1wiLCBMR3JhcGhQb2ludHNUb0luc3RhbmNlcyApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlUcmFuc2Zvcm0oKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeSxbbWF0NF1cIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWF0NFwiLCBcIm1hdDRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge307XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IHtcclxuXHRcdFx0dHlwZTogXCJ0cmlhbmdsZXNcIixcclxuXHRcdFx0dmVydGljZXM6IG51bGwsXHJcblx0XHRcdF9pZDogZ2VuZXJhdGVHZW9tZXRyeUlkKCksXHJcblx0XHRcdF92ZXJzaW9uOiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuX2xhc3RfZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMuX2xhc3RfdmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5fbGFzdF9rZXkgPSBcIlwiO1xyXG5cclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlUcmFuc2Zvcm0udGl0bGUgPSBcIlRyYW5zZm9ybVwiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVRyYW5zZm9ybS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHR2YXIgbW9kZWwgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHJcblx0XHRpZighaW5wdXQpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHQvL2FycmF5IG9mIG1hdHJpY2VzXHJcblx0XHRpZihpbnB1dC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXHJcblx0XHR7XHJcblx0XHRcdGlmKGlucHV0Lmxlbmd0aCA9PSAwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSBcIlttYXQ0XVwiO1xyXG5cdFx0XHRpZiggIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdGlmKCFtb2RlbClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLGlucHV0KTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCF0aGlzLl9vdXRwdXQpXHJcblx0XHRcdFx0dGhpcy5fb3V0cHV0ID0gbmV3IEFycmF5KCk7XHJcblx0XHRcdGlmKHRoaXMuX291dHB1dC5sZW5ndGggIT0gaW5wdXQubGVuZ3RoKVxyXG5cdFx0XHRcdHRoaXMuX291dHB1dC5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBtID0gdGhpcy5fb3V0cHV0W2ldO1xyXG5cdFx0XHRcdGlmKCFtKVxyXG5cdFx0XHRcdFx0bSA9IHRoaXMuX291dHB1dFtpXSA9IG1hdDQuY3JlYXRlKCk7XHJcblx0XHRcdFx0bWF0NC5tdWx0aXBseShtLGlucHV0W2ldLG1vZGVsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLl9vdXRwdXQpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9nZW9tZXRyeVxyXG5cdFx0aWYoIWlucHV0LnZlcnRpY2VzIHx8ICFpbnB1dC52ZXJ0aWNlcy5sZW5ndGgpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHZhciBnZW8gPSBpbnB1dDtcclxuXHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gXCJnZW9tZXRyeVwiO1xyXG5cdFx0aWYoICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYoIW1vZGVsKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxnZW8pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGtleSA9IHR5cGVkQXJyYXlUb0FycmF5KG1vZGVsKS5qb2luKFwiLFwiKTtcclxuXHJcblx0XHRpZiggdGhpcy5tdXN0X3VwZGF0ZSB8fCBnZW8uX2lkICE9IHRoaXMuX2xhc3RfZ2VvbWV0cnlfaWQgfHwgZ2VvLl92ZXJzaW9uICE9IHRoaXMuX2xhc3RfdmVyc2lvbiB8fCBrZXkgIT0gdGhpcy5fbGFzdF9rZXkgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUdlb21ldHJ5KGdlbywgbW9kZWwpO1xyXG5cdFx0XHR0aGlzLl9sYXN0X2tleSA9IGtleTtcclxuXHRcdFx0dGhpcy5fbGFzdF92ZXJzaW9uID0gZ2VvLl92ZXJzaW9uO1xyXG5cdFx0XHR0aGlzLl9sYXN0X2dlb21ldHJ5X2lkID0gZ2VvLl9pZDtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuZ2VvbWV0cnkpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlUcmFuc2Zvcm0ucHJvdG90eXBlLnVwZGF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oZ2VvbWV0cnksIG1vZGVsKSB7XHJcblx0XHR2YXIgb2xkX3ZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0aWYoICF2ZXJ0aWNlcyB8fCB2ZXJ0aWNlcy5sZW5ndGggIT0gb2xkX3ZlcnRpY2VzLmxlbmd0aCApXHJcblx0XHRcdHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG9sZF92ZXJ0aWNlcy5sZW5ndGggKTtcclxuXHRcdHZhciB0ZW1wID0gdmVjMy5jcmVhdGUoKTtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dGVtcFswXSA9IG9sZF92ZXJ0aWNlc1tpXTsgdGVtcFsxXSA9IG9sZF92ZXJ0aWNlc1tpKzFdOyB0ZW1wWzJdID0gb2xkX3ZlcnRpY2VzW2krMl07IFxyXG5cdFx0XHRtYXQ0Lm11bHRpcGx5VmVjMyggdGVtcCwgbW9kZWwsIHRlbXAgKTtcclxuXHRcdFx0dmVydGljZXNbaV0gPSB0ZW1wWzBdOyB2ZXJ0aWNlc1tpKzFdID0gdGVtcFsxXTsgdmVydGljZXNbaSsyXSA9IHRlbXBbMl07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoZ2VvbWV0cnkubm9ybWFscylcclxuXHRcdHtcclxuXHRcdFx0aWYoICF0aGlzLmdlb21ldHJ5Lm5vcm1hbHMgfHwgdGhpcy5nZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAhPSBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCApXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeS5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKTtcclxuXHRcdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmdlb21ldHJ5Lm5vcm1hbHM7XHJcblx0XHRcdHZhciBub3JtYWxfbW9kZWwgPSBtYXQ0LmludmVydChtYXQ0LmNyZWF0ZSgpLCBtb2RlbCk7XHJcblx0XHRcdGlmKG5vcm1hbF9tb2RlbClcclxuXHRcdFx0XHRtYXQ0LnRyYW5zcG9zZShub3JtYWxfbW9kZWwsIG5vcm1hbF9tb2RlbCk7XHJcblx0XHRcdHZhciBvbGRfbm9ybWFscyA9IGdlb21ldHJ5Lm5vcm1hbHM7XHJcblx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGw7IGkrPTMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0ZW1wWzBdID0gb2xkX25vcm1hbHNbaV07IHRlbXBbMV0gPSBvbGRfbm9ybWFsc1tpKzFdOyB0ZW1wWzJdID0gb2xkX25vcm1hbHNbaSsyXTsgXHJcblx0XHRcdFx0bWF0NC5tdWx0aXBseVZlYzMoIHRlbXAsIG5vcm1hbF9tb2RlbCwgdGVtcCApO1xyXG5cdFx0XHRcdG5vcm1hbHNbaV0gPSB0ZW1wWzBdOyBub3JtYWxzW2krMV0gPSB0ZW1wWzFdOyBub3JtYWxzW2krMl0gPSB0ZW1wWzJdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS50eXBlID0gZ2VvbWV0cnkudHlwZTtcclxuXHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3RyYW5zZm9ybVwiLCBMR3JhcGhHZW9tZXRyeVRyYW5zZm9ybSApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlQb2x5Z29uKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInNpZGVzXCIsIFwibnVtYmVyXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInJhZGl1c1wiLCBcIm51bWJlclwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHNpZGVzOiA2LCByYWRpdXM6IDEsIHV2czogZmFsc2UgfVxyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSB7XHJcblx0XHRcdHR5cGU6IFwibGluZV9sb29wXCIsXHJcblx0XHRcdHZlcnRpY2VzOiBudWxsLFxyXG5cdFx0XHRfaWQ6IGdlbmVyYXRlR2VvbWV0cnlJZCgpXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmxhc3RfaW5mbyA9IHsgc2lkZXM6IC0xLCByYWRpdXM6IC0xIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVBvbHlnb24udGl0bGUgPSBcIlBvbHlnb25cIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQb2x5Z29uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiggIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHNpZGVzID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJzaWRlc1wiKTtcclxuXHRcdHZhciByYWRpdXMgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInJhZGl1c1wiKTtcclxuXHRcdHNpZGVzID0gTWF0aC5tYXgoMyxzaWRlcyl8MDtcclxuXHJcblx0XHQvL3VwZGF0ZVxyXG5cdFx0aWYoIHRoaXMubGFzdF9pbmZvLnNpZGVzICE9IHNpZGVzIHx8IHRoaXMubGFzdF9pbmZvLnJhZGl1cyAhPSByYWRpdXMgKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZUdlb21ldHJ5KHNpZGVzLCByYWRpdXMpO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuZ2VvbWV0cnkpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQb2x5Z29uLnByb3RvdHlwZS51cGRhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKHNpZGVzLCByYWRpdXMpIHtcclxuXHRcdHZhciBudW0gPSAzKnNpZGVzO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdGlmKCAhdmVydGljZXMgfHwgdmVydGljZXMubGVuZ3RoICE9IG51bSApXHJcblx0XHRcdHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDMqc2lkZXMgKTtcclxuXHRcdHZhciBkZWx0YSA9IChNYXRoLlBJICogMikgLyBzaWRlcztcclxuXHRcdHZhciBnZW5fdXZzID0gdGhpcy5wcm9wZXJ0aWVzLnV2cztcclxuXHRcdGlmKGdlbl91dnMpXHJcblx0XHR7XHJcblx0XHRcdHV2cyA9IHRoaXMuZ2VvbWV0cnkuY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggMypzaWRlcyApO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXM7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIGFuZ2xlID0gZGVsdGEgKiAtaTtcclxuXHRcdFx0dmFyIHggPSBNYXRoLmNvcyggYW5nbGUgKSAqIHJhZGl1cztcclxuXHRcdFx0dmFyIHkgPSAwO1xyXG5cdFx0XHR2YXIgeiA9IE1hdGguc2luKCBhbmdsZSApICogcmFkaXVzO1xyXG5cdFx0XHR2ZXJ0aWNlc1tpKjNdID0geDtcclxuXHRcdFx0dmVydGljZXNbaSozKzFdID0geTtcclxuXHRcdFx0dmVydGljZXNbaSozKzJdID0gejtcclxuXHJcblx0XHRcdGlmKGdlbl91dnMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuZ2VvbWV0cnkuX2lkID0gKyt0aGlzLmdlb21ldHJ5X2lkO1xyXG5cdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9ICsrdGhpcy52ZXJzaW9uO1xyXG5cdFx0dGhpcy5sYXN0X2luZm8uc2lkZXMgPSBzaWRlcztcclxuXHRcdHRoaXMubGFzdF9pbmZvLnJhZGl1cyA9IHJhZGl1cztcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3BvbHlnb25cIiwgTEdyYXBoR2VvbWV0cnlQb2x5Z29uICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhHZW9tZXRyeUV4dHJ1ZGUoKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnB1dChcIlwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgdG9wX2NhcDogdHJ1ZSwgYm90dG9tX2NhcDogdHJ1ZSwgb2Zmc2V0OiBbMCwxMDAsMF0gfTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cclxuXHRcdHRoaXMuX2xhc3RfZ2VvX3ZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMuX211c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXh0cnVkZS50aXRsZSA9IFwiZXh0cnVkZVwiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV4dHJ1ZGUucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpXHJcblx0e1xyXG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFeHRydWRlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIGdlbyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoICFnZW8gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoZ2VvLnZlcnNpb24gIT0gdGhpcy5fbGFzdF9nZW9fdmVyc2lvbiB8fCB0aGlzLl9tdXN0X3VwZGF0ZSlcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5fZ2VvID0gdGhpcy5leHRydWRlR2VvbWV0cnkoIGdlbywgdGhpcy5fZ2VvICk7XHJcblx0XHRcdGlmKHRoaXMuX2dlbylcclxuXHRcdFx0XHR0aGlzLl9nZW8udmVyc2lvbiA9IHRoaXMudmVyc2lvbisrO1xyXG5cdFx0XHR0aGlzLl9tdXN0X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9nZW8pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFeHRydWRlLnByb3RvdHlwZS5leHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiggZ2VvIClcclxuXHR7XHJcblx0XHQvL2ZvciBldmVyeSBwYWlyIG9mIHZlcnRpY2VzXHJcblx0XHR2YXIgdmVydGljZXMgPSBnZW8udmVydGljZXM7XHJcblx0XHR2YXIgbnVtX3BvaW50cyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XHJcblxyXG5cdFx0dmFyIHRlbXBBID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciB0ZW1wQiA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgdGVtcEMgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHRlbXBEID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciBvZmZzZXQgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnByb3BlcnRpZXMub2Zmc2V0ICk7XHJcblxyXG5cdFx0aWYoZ2VvLnR5cGUgPT0gXCJsaW5lX2xvb3BcIilcclxuXHRcdHtcclxuXHRcdFx0dmFyIG5ld192ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bV9wb2ludHMgKiA2ICogMyApOyAvL2V2ZXJ5IHBvaW50cyBiZWNvbWUgNiAoIGNhcHMgbm90IGluY2x1ZGVkIClcclxuXHRcdFx0dmFyIG5wb3MgPSAwO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGVtcEFbMF0gPSB2ZXJ0aWNlc1tpXTsgdGVtcEFbMV0gPSB2ZXJ0aWNlc1tpKzFdOyB0ZW1wQVsyXSA9IHZlcnRpY2VzW2krMl07XHJcblxyXG5cdFx0XHRcdGlmKCBpKzMgPCBsICkgLy9sb29wXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dGVtcEJbMF0gPSB2ZXJ0aWNlc1tpKzNdOyB0ZW1wQlsxXSA9IHZlcnRpY2VzW2krNF07IHRlbXBCWzJdID0gdmVydGljZXNbaSs1XTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRlbXBCWzBdID0gdmVydGljZXNbMF07IHRlbXBCWzFdID0gdmVydGljZXNbMV07IHRlbXBCWzJdID0gdmVydGljZXNbMl07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2ZWMzLmFkZCggdGVtcEMsIHRlbXBBLCBvZmZzZXQgKTtcclxuXHRcdFx0XHR2ZWMzLmFkZCggdGVtcEQsIHRlbXBCLCBvZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0bmV3X3ZlcnRpY2VzLnNldCggdGVtcEEsIG5wb3MgKTsgbnBvcyArPSAzO1xyXG5cdFx0XHRcdG5ld192ZXJ0aWNlcy5zZXQoIHRlbXBCLCBucG9zICk7IG5wb3MgKz0gMztcclxuXHRcdFx0XHRuZXdfdmVydGljZXMuc2V0KCB0ZW1wQywgbnBvcyApOyBucG9zICs9IDM7XHJcblxyXG5cdFx0XHRcdG5ld192ZXJ0aWNlcy5zZXQoIHRlbXBCLCBucG9zICk7IG5wb3MgKz0gMztcclxuXHRcdFx0XHRuZXdfdmVydGljZXMuc2V0KCB0ZW1wRCwgbnBvcyApOyBucG9zICs9IDM7XHJcblx0XHRcdFx0bmV3X3ZlcnRpY2VzLnNldCggdGVtcEMsIG5wb3MgKTsgbnBvcyArPSAzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG91dF9nZW8gPSB7XHJcblx0XHRcdF9pZDogZ2VuZXJhdGVHZW9tZXRyeUlkKCksXHJcblx0XHRcdHR5cGU6IFwidHJpYW5nbGVzXCIsXHJcblx0XHRcdHZlcnRpY2VzOiBuZXdfdmVydGljZXNcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIG91dF9nZW87XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9leHRydWRlXCIsIExHcmFwaEdlb21ldHJ5RXh0cnVkZSApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlFdmFsKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0Y29kZTogXCJWWzFdICs9IDAuMDEgKiBNYXRoLnNpbihJICsgVCowLjAwMSk7XCIsXHJcblx0XHRcdGV4ZWN1dGVfZXZlcnlfZnJhbWU6IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzID0gbnVsbDtcclxuXHRcdHRoaXMuZnVuYyA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwudGl0bGUgPSBcImdlb2V2YWxcIjtcclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwuZGVzYyA9IFwiZXZhbCBjb2RlXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRjb2RlOiB7IHdpZGdldDogXCJjb2RlXCIgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC5wcm90b3R5cGUub25Db25maWd1cmUgPSBmdW5jdGlvbihvKVxyXG5cdHtcclxuXHRcdHRoaXMuY29tcGlsZUNvZGUoKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC5wcm90b3R5cGUuY29tcGlsZUNvZGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMucHJvcGVydGllcy5jb2RlKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dHJ5XHJcblx0XHR7XHJcblx0XHRcdHRoaXMuZnVuYyA9IG5ldyBGdW5jdGlvbihcIlZcIixcIklcIixcIlRcIiwgdGhpcy5wcm9wZXJ0aWVzLmNvZGUpOyBcclxuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiI0FGQVwiO1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGNhdGNoIChlcnIpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKVxyXG5cdHtcclxuXHRcdGlmKG5hbWUgPT0gXCJjb2RlXCIpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMucHJvcGVydGllcy5jb2RlID0gdmFsdWU7XHJcblx0XHRcdHRoaXMuY29tcGlsZUNvZGUoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFnZW9tZXRyeSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCF0aGlzLmZ1bmMpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLGdlb21ldHJ5KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCB0aGlzLmdlb21ldHJ5X2lkICE9IGdlb21ldHJ5Ll9pZCB8fCB0aGlzLnZlcnNpb24gIT0gZ2VvbWV0cnkuX3ZlcnNpb24gfHwgdGhpcy5tdXN0X3VwZGF0ZSB8fCB0aGlzLnByb3BlcnRpZXMuZXhlY3V0ZV9ldmVyeV9mcmFtZSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeV9pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdFx0aWYodGhpcy5wcm9wZXJ0aWVzLmV4ZWN1dGVfZXZlcnlfZnJhbWUpXHJcblx0XHRcdFx0dGhpcy52ZXJzaW9uKys7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aGlzLnZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHRcdFx0dmFyIGZ1bmMgPSB0aGlzLmZ1bmM7XHJcblx0XHRcdHZhciBUID0gZ2V0VGltZSgpO1xyXG5cclxuXHRcdFx0Ly9jbG9uZVxyXG5cdFx0XHRpZighdGhpcy5nZW9tZXRyeSlcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5ID0ge307XHJcblx0XHRcdGZvcih2YXIgaSBpbiBnZW9tZXRyeSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKGdlb21ldHJ5W2ldID09IG51bGwpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRpZiggZ2VvbWV0cnlbaV0uY29uc3RydWN0b3IgPT0gRmxvYXQzMkFycmF5IClcclxuXHRcdFx0XHRcdHRoaXMuZ2VvbWV0cnlbaV0gPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeVtpXSApO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHRoaXMuZ2VvbWV0cnlbaV0gPSBnZW9tZXRyeVtpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll9pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdFx0aWYodGhpcy5wcm9wZXJ0aWVzLmV4ZWN1dGVfZXZlcnlfZnJhbWUpXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbiArIDE7XHJcblxyXG5cdFx0XHR2YXIgViA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcblx0XHRcdGlmKCF2ZXJ0aWNlcyB8fCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAhPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGgpXHJcblx0XHRcdFx0dmVydGljZXMgPSB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHZlcnRpY2VzLnNldCggZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSs9MylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFZbMF0gPSB2ZXJ0aWNlc1tpXTtcclxuXHRcdFx0XHRWWzFdID0gdmVydGljZXNbaSsxXTtcclxuXHRcdFx0XHRWWzJdID0gdmVydGljZXNbaSsyXTtcclxuXHRcdFx0XHRmdW5jKFYsaS8zLFQpO1xyXG5cdFx0XHRcdHZlcnRpY2VzW2ldID0gVlswXTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1tpKzFdID0gVlsxXTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1tpKzJdID0gVlsyXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzID0gdmVydGljZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5nZW9tZXRyeSk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9ldmFsXCIsIExHcmFwaEdlb21ldHJ5RXZhbCApO1xyXG5cclxuLypcclxuZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlEaXNwbGFjZSgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImltZ1wiLCBcImltYWdlXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGdyaWRfc2l6ZTogMVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gbnVsbDtcclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeURpc3BsYWNlLnRpdGxlID0gXCJkaXNwbGFjZVwiO1xyXG5cdExHcmFwaEdlb21ldHJ5RGlzcGxhY2UuZGVzYyA9IFwiZGlzcGxhY2UgcG9pbnRzXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RGlzcGxhY2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKCFnZW9tZXRyeSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCFpbWFnZSlcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsZ2VvbWV0cnkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIHRoaXMuZ2VvbWV0cnlfaWQgIT0gZ2VvbWV0cnkuX2lkIHx8IHRoaXMudmVyc2lvbiAhPSBnZW9tZXRyeS5fdmVyc2lvbiB8fCB0aGlzLm11c3RfdXBkYXRlIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5X2lkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0XHR0aGlzLnZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHJcblx0XHRcdC8vY29weVxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0ge307XHJcblx0XHRcdGZvcih2YXIgaSBpbiBnZW9tZXRyeSlcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5W2ldID0gZ2VvbWV0cnlbaV07XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX2lkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb24gKyAxO1xyXG5cclxuXHRcdFx0dmFyIGdyaWRfc2l6ZSA9IHRoaXMucHJvcGVydGllcy5ncmlkX3NpemU7XHJcblx0XHRcdGlmKGdyaWRfc2l6ZSAhPSAwKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuXHRcdFx0XHRpZighdmVydGljZXMgfHwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggIT0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGgpXHJcblx0XHRcdFx0XHR2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzICk7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSs9MylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1tpXSA9IE1hdGgucm91bmQodmVydGljZXNbaV0vZ3JpZF9zaXplKSAqIGdyaWRfc2l6ZTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzW2krMV0gPSBNYXRoLnJvdW5kKHZlcnRpY2VzW2krMV0vZ3JpZF9zaXplKSAqIGdyaWRfc2l6ZTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzW2krMl0gPSBNYXRoLnJvdW5kKHZlcnRpY2VzW2krMl0vZ3JpZF9zaXplKSAqIGdyaWRfc2l6ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5nZW9tZXRyeSk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9kaXNwbGFjZVwiLCBMR3JhcGhHZW9tZXRyeURpc3BsYWNlICk7XHJcbiovXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaENvbm5lY3RQb2ludHMoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRtaW5fZGlzdDogMC40LFxyXG5cdFx0XHRtYXhfZGlzdDogMC41LFxyXG5cdFx0XHRtYXhfY29ubmVjdGlvbnM6IDAsXHJcblx0XHRcdHByb2JhYmlsaXR5OiAxXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5teV92ZXJzaW9uID0gMTtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoQ29ubmVjdFBvaW50cy50aXRsZSA9IFwiY29ubmVjdCBwb2ludHNcIjtcclxuXHRMR3JhcGhDb25uZWN0UG9pbnRzLmRlc2MgPSBcImFkZHMgaW5kaWNlcyBiZXR3ZWVuIG5lYXIgcG9pbnRzXCI7XHJcblxyXG5cdExHcmFwaENvbm5lY3RQb2ludHMucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaENvbm5lY3RQb2ludHMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighZ2VvbWV0cnkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZiggdGhpcy5nZW9tZXRyeV9pZCAhPSBnZW9tZXRyeS5faWQgfHwgdGhpcy52ZXJzaW9uICE9IGdlb21ldHJ5Ll92ZXJzaW9uIHx8IHRoaXMubXVzdF91cGRhdGUgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHRcdHRoaXMudmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cclxuXHRcdFx0Ly9jb3B5XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkgPSB7fTtcclxuXHRcdFx0Zm9yKHZhciBpIGluIGdlb21ldHJ5KVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnlbaV0gPSBnZW9tZXRyeVtpXTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5faWQgPSBnZW5lcmF0ZUdlb21ldHJ5SWQoKTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9IHRoaXMubXlfdmVyc2lvbisrO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRcdHZhciBsID0gdmVydGljZXMubGVuZ3RoO1xyXG5cdFx0XHR2YXIgbWluX2Rpc3QgPSB0aGlzLnByb3BlcnRpZXMubWluX2Rpc3Q7XHJcblx0XHRcdHZhciBtYXhfZGlzdCA9IHRoaXMucHJvcGVydGllcy5tYXhfZGlzdDtcclxuXHRcdFx0dmFyIHByb2JhYmlsaXR5ID0gdGhpcy5wcm9wZXJ0aWVzLnByb2JhYmlsaXR5O1xyXG5cdFx0XHR2YXIgbWF4X2Nvbm5lY3Rpb25zID0gdGhpcy5wcm9wZXJ0aWVzLm1heF9jb25uZWN0aW9ucztcclxuXHRcdFx0dmFyIGluZGljZXMgPSBbXTtcclxuXHRcdFx0XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKz0zKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIHggPSB2ZXJ0aWNlc1tpXTtcclxuXHRcdFx0XHR2YXIgeSA9IHZlcnRpY2VzW2krMV07XHJcblx0XHRcdFx0dmFyIHogPSB2ZXJ0aWNlc1tpKzJdO1xyXG5cdFx0XHRcdHZhciBjb25uZWN0aW9ucyA9IDA7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gaSszOyBqIDwgbDsgais9MylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgeDIgPSB2ZXJ0aWNlc1tqXTtcclxuXHRcdFx0XHRcdHZhciB5MiA9IHZlcnRpY2VzW2orMV07XHJcblx0XHRcdFx0XHR2YXIgejIgPSB2ZXJ0aWNlc1tqKzJdO1xyXG5cdFx0XHRcdFx0dmFyIGRpc3QgPSBNYXRoLnNxcnQoICh4LXgyKSooeC14MikgKyAoeS15MikqKHkteTIpICsgKHotejIpKih6LXoyKSk7XHJcblx0XHRcdFx0XHRpZihkaXN0ID4gbWF4X2Rpc3QgfHwgZGlzdCA8IG1pbl9kaXN0IHx8IChwcm9iYWJpbGl0eSA8IDEgJiYgcHJvYmFiaWxpdHkgPCBNYXRoLnJhbmRvbSgpKSApXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGkvMyxqLzMpO1xyXG5cdFx0XHRcdFx0Y29ubmVjdGlvbnMgKz0gMTtcclxuXHRcdFx0XHRcdGlmKG1heF9jb25uZWN0aW9ucyAmJiBjb25uZWN0aW9ucyA+IG1heF9jb25uZWN0aW9ucylcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLmluZGljZXMgJiYgdGhpcy5pbmRpY2VzLmxlbmd0aClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5pbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMuZ2VvbWV0cnkgKTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBudWxsICk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9jb25uZWN0UG9pbnRzXCIsIExHcmFwaENvbm5lY3RQb2ludHMgKTtcclxuXHJcbiAgICAvL1dvcmtzIHdpdGggTGl0ZWdsLmpzIHRvIGNyZWF0ZSBXZWJHTCBub2Rlc1xyXG4gICAgaWYgKHR5cGVvZiBHTCA9PSBcInVuZGVmaW5lZFwiKSAvL0xpdGVHTCBSRUxBVEVEICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHRcdHJldHVybjtcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoVG9HZW9tZXRyeSgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtZXNoXCIsIFwibWVzaFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IHt9O1xyXG5cdFx0dGhpcy5sYXN0X21lc2ggPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoVG9HZW9tZXRyeS50aXRsZSA9IFwidG8gZ2VvbWV0cnlcIjtcclxuXHRMR3JhcGhUb0dlb21ldHJ5LmRlc2MgPSBcImNvbnZlcnRzIGEgbWVzaCB0byBnZW9tZXRyeVwiO1xyXG5cclxuXHRMR3JhcGhUb0dlb21ldHJ5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZXNoID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighbWVzaClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKG1lc2ggIT0gdGhpcy5sYXN0X21lc2gpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMubGFzdF9tZXNoID0gbWVzaDtcclxuXHRcdFx0Zm9yKGkgaW4gbWVzaC52ZXJ0ZXhCdWZmZXJzKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIGJ1ZmZlciA9IG1lc2gudmVydGV4QnVmZmVyc1tpXTtcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5W2ldID0gYnVmZmVyLmRhdGFcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihtZXNoLmluZGV4QnVmZmVyc1tcInRyaWFuZ2xlc1wiXSlcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5LmluZGljZXMgPSBtZXNoLmluZGV4QnVmZmVyc1tcInRyaWFuZ2xlc1wiXS5kYXRhO1xyXG5cclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5faWQgPSBnZW5lcmF0ZUdlb21ldHJ5SWQoKTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5nZW9tZXRyeSk7XHJcblx0XHRpZih0aGlzLmdlb21ldHJ5KVxyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMSx0aGlzLmdlb21ldHJ5LnZlcnRpY2VzKTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3RvR2VvbWV0cnlcIiwgTEdyYXBoVG9HZW9tZXRyeSApO1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhHZW9tZXRyeVRvTWVzaCgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJtZXNoXCIsIFwibWVzaFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHt9O1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm1lc2ggPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlUb01lc2gudGl0bGUgPSBcIkdlbyB0byBNZXNoXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5VG9NZXNoLnByb3RvdHlwZS51cGRhdGVNZXNoID0gZnVuY3Rpb24oZ2VvbWV0cnkpXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMubWVzaClcclxuXHRcdFx0dGhpcy5tZXNoID0gbmV3IEdMLk1lc2goKTtcclxuXHJcblx0XHRmb3IodmFyIGkgaW4gZ2VvbWV0cnkpXHJcblx0XHR7XHJcblx0XHRcdGlmKGlbMF0gPT0gXCJfXCIpXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR2YXIgYnVmZmVyX2RhdGEgPSBnZW9tZXRyeVtpXTtcclxuXHJcblx0XHRcdHZhciBpbmZvID0gR0wuTWVzaC5jb21tb25fYnVmZmVyc1tpXTtcclxuXHRcdFx0aWYoIWluZm8gJiYgaSAhPSBcImluZGljZXNcIikgLy91bmtub3duIGJ1ZmZlclxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgc3BhY2luZyA9IGluZm8gPyBpbmZvLnNwYWNpbmcgOiAzO1xyXG5cdFx0XHR2YXIgbWVzaF9idWZmZXIgPSB0aGlzLm1lc2gudmVydGV4QnVmZmVyc1tpXTtcclxuXHJcblx0XHRcdGlmKCFtZXNoX2J1ZmZlciB8fCBtZXNoX2J1ZmZlci5kYXRhLmxlbmd0aCAhPSBidWZmZXJfZGF0YS5sZW5ndGgpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRtZXNoX2J1ZmZlciA9IG5ldyBHTC5CdWZmZXIoIGkgPT0gXCJpbmRpY2VzXCIgPyBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IEdMLkFSUkFZX0JVRkZFUiwgYnVmZmVyX2RhdGEsIHNwYWNpbmcsIEdMLkRZTkFNSUNfRFJBVyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG1lc2hfYnVmZmVyLmRhdGEuc2V0KCBidWZmZXJfZGF0YSApO1xyXG5cdFx0XHRcdG1lc2hfYnVmZmVyLnVwbG9hZChHTC5EWU5BTUlDX0RSQVcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1lc2guYWRkQnVmZmVyKCBpLCBtZXNoX2J1ZmZlciApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMubWVzaC52ZXJ0ZXhCdWZmZXJzLm5vcm1hbHMgJiZ0aGlzLm1lc2gudmVydGV4QnVmZmVycy5ub3JtYWxzLmRhdGEubGVuZ3RoICE9IHRoaXMubWVzaC52ZXJ0ZXhCdWZmZXJzLnZlcnRpY2VzLmRhdGEubGVuZ3RoIClcclxuXHRcdHtcclxuXHRcdFx0dmFyIG4gPSBuZXcgRmxvYXQzMkFycmF5KFswLDEsMF0pO1xyXG5cdFx0XHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMubWVzaC52ZXJ0ZXhCdWZmZXJzLnZlcnRpY2VzLmRhdGEubGVuZ3RoICk7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSs9IDMpXHJcblx0XHRcdFx0bm9ybWFscy5zZXQoIG4sIGkgKTtcclxuXHRcdFx0bWVzaF9idWZmZXIgPSBuZXcgR0wuQnVmZmVyKCBHTC5BUlJBWV9CVUZGRVIsIG5vcm1hbHMsIDMgKTtcclxuXHRcdFx0dGhpcy5tZXNoLmFkZEJ1ZmZlciggXCJub3JtYWxzXCIsIG1lc2hfYnVmZmVyICk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tZXNoLnVwZGF0ZUJvdW5kaW5nQm94KCk7XHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gdGhpcy5tZXNoLmlkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gdGhpcy5tZXNoLnZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHRcdHJldHVybiB0aGlzLm1lc2g7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVRvTWVzaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighZ2VvbWV0cnkpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKCB0aGlzLnZlcnNpb24gIT0gZ2VvbWV0cnkuX3ZlcnNpb24gfHwgdGhpcy5nZW9tZXRyeV9pZCAhPSBnZW9tZXRyeS5faWQgKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1lc2goIGdlb21ldHJ5ICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5tZXNoKTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3RvTWVzaFwiLCBMR3JhcGhHZW9tZXRyeVRvTWVzaCApO1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhSZW5kZXJNZXNoKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1lc2hcIiwgXCJtZXNoXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1hdDRcIiwgXCJtYXQ0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInRleFwiLCBcInRleHR1cmVcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRlbmFibGVkOiB0cnVlLFxyXG5cdFx0XHRwcmltaXRpdmU6IEdMLlRSSUFOR0xFUyxcclxuXHRcdFx0YWRkaXRpdmU6IGZhbHNlLFxyXG5cdFx0XHRjb2xvcjogWzEsMSwxXSxcclxuXHRcdFx0b3BhY2l0eTogMVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gdmVjNC5jcmVhdGUoWzEsMSwxLDFdKTtcclxuXHRcdHRoaXMubW9kZWxfbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuXHRcdHRoaXMudW5pZm9ybXMgPSB7XHJcblx0XHRcdHVfY29sb3I6IHRoaXMuY29sb3IsXHJcblx0XHRcdHVfbW9kZWw6IHRoaXMubW9kZWxfbWF0cml4XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUmVuZGVyTWVzaC50aXRsZSA9IFwiUmVuZGVyIE1lc2hcIjtcclxuXHRMR3JhcGhSZW5kZXJNZXNoLmRlc2MgPSBcInJlbmRlcnMgYSBtZXNoIGZsYXRcIjtcclxuXHJcblx0TEdyYXBoUmVuZGVyTWVzaC5QUklNSVRJVkVfVkFMVUVTID0geyBcInBvaW50c1wiOkdMLlBPSU5UUywgXCJsaW5lc1wiOkdMLkxJTkVTLCBcImxpbmVfbG9vcFwiOkdMLkxJTkVfTE9PUCxcImxpbmVfc3RyaXBcIjpHTC5MSU5FX1NUUklQLCBcInRyaWFuZ2xlc1wiOkdMLlRSSUFOR0xFUywgXCJ0cmlhbmdsZV9mYW5cIjpHTC5UUklBTkdMRV9GQU4sIFwidHJpYW5nbGVfc3RyaXBcIjpHTC5UUklBTkdMRV9TVFJJUCB9O1xyXG5cclxuXHRMR3JhcGhSZW5kZXJNZXNoLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdHByaW1pdGl2ZTogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhSZW5kZXJNZXNoLlBSSU1JVElWRV9WQUxVRVMgfSxcclxuXHRcdGNvbG9yOiB7IHdpZGdldDogXCJjb2xvclwiIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhSZW5kZXJNZXNoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZighdGhpcy5wcm9wZXJ0aWVzLmVuYWJsZWQpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgbWVzaCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIW1lc2gpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZighTGl0ZUdyYXBoLkxHcmFwaFJlbmRlci5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcylcclxuXHRcdHtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiY2Fubm90IHJlbmRlciBnZW9tZXRyeSwgTGl0ZUdyYXBoLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzIGlzIG51bGwsIHJlbWVtYmVyIHRvIGZpbGwgdGhpcyB3aXRoIGEgY2FsbGJhY2sodmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCkgdG8gdXNlIDNEIHJlbmRlcmluZyBmcm9tIHRoZSBncmFwaFwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdExpdGVHcmFwaC5MR3JhcGhSZW5kZXIub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMoIHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXggKTtcclxuXHRcdHZhciBzaGFkZXIgPSBudWxsO1xyXG5cdFx0dmFyIHRleHR1cmUgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuXHRcdGlmKHRleHR1cmUpXHJcblx0XHR7XHJcblx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJ0ZXh0dXJlZFwiXTtcclxuXHRcdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1widGV4dHVyZWRcIl0gPSBuZXcgR0wuU2hhZGVyKCBMR3JhcGhSZW5kZXJQb2ludHMudmVydGV4X3NoYWRlcl9jb2RlLCBMR3JhcGhSZW5kZXJQb2ludHMuZnJhZ21lbnRfc2hhZGVyX2NvZGUsIHsgVVNFX1RFWFRVUkU6XCJcIiB9KTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcImZsYXRcIl07XHJcblx0XHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcImZsYXRcIl0gPSBuZXcgR0wuU2hhZGVyKCBMR3JhcGhSZW5kZXJQb2ludHMudmVydGV4X3NoYWRlcl9jb2RlLCBMR3JhcGhSZW5kZXJQb2ludHMuZnJhZ21lbnRfc2hhZGVyX2NvZGUgKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbG9yLnNldCggdGhpcy5wcm9wZXJ0aWVzLmNvbG9yICk7XHJcblx0XHR0aGlzLmNvbG9yWzNdID0gdGhpcy5wcm9wZXJ0aWVzLm9wYWNpdHk7XHJcblxyXG5cdFx0dmFyIG1vZGVsX21hdHJpeCA9IHRoaXMubW9kZWxfbWF0cml4O1xyXG5cdFx0dmFyIG0gPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKG0pXHJcblx0XHRcdG1vZGVsX21hdHJpeC5zZXQobSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG1hdDQuaWRlbnRpdHkoIG1vZGVsX21hdHJpeCApO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMudV9wb2ludF9zaXplID0gMTtcclxuXHRcdHZhciBwcmltaXRpdmUgPSB0aGlzLnByb3BlcnRpZXMucHJpbWl0aXZlO1xyXG5cclxuXHRcdHNoYWRlci51bmlmb3JtcyggZ2xvYmFsX3VuaWZvcm1zICk7XHJcblx0XHRzaGFkZXIudW5pZm9ybXMoIHRoaXMudW5pZm9ybXMgKTtcclxuXHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMub3BhY2l0eSA+PSAxKVxyXG5cdFx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRnbC5lbmFibGUoIGdsLkJMRU5EICk7XHJcblx0XHRnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdGlmKCB0aGlzLnByb3BlcnRpZXMuYWRkaXRpdmUgKVxyXG5cdFx0e1xyXG5cdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XHJcblx0XHRcdGdsLmRlcHRoTWFzayggZmFsc2UgKTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFwiaW5kaWNlc1wiO1xyXG5cdFx0aWYoIG1lc2guaW5kZXhCdWZmZXJzLnRyaWFuZ2xlcyApXHJcblx0XHRcdGluZGljZXMgPSBcInRyaWFuZ2xlc1wiO1xyXG5cdFx0c2hhZGVyLmRyYXcoIG1lc2gsIHByaW1pdGl2ZSwgaW5kaWNlcyApO1xyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvcmVuZGVyX21lc2hcIiwgTEdyYXBoUmVuZGVyTWVzaCApO1xyXG5cclxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZSgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJzaXplXCIsIFwibnVtYmVyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJtZXNoXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB0eXBlOiAxLCBzaXplOiAxLCBzdWJkaXZpc2lvbnM6IDMyIH07XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApfDA7XHJcblx0XHR0aGlzLmxhc3RfaW5mbyA9IHsgdHlwZTogLTEsIHNpemU6IC0xLCBzdWJkaXZpc2lvbnM6IC0xIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZS50aXRsZSA9IFwiUHJpbWl0aXZlXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlLlZBTElEID0geyBcIkNVQkVcIjoxLCBcIlBMQU5FXCI6MiwgXCJDWUxJTkRFUlwiOjMsIFwiU1BIRVJFXCI6NCwgXCJDSVJDTEVcIjo1LCBcIkhFTUlTUEhFUkVcIjo2LCBcIklDT1NBSEVEUk9OXCI6NywgXCJDT05FXCI6OCwgXCJRVUFEXCI6OSB9O1xyXG5cdExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlLndpZGdldHNfaW5mbyA9IHtcclxuXHRcdHR5cGU6IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoR2VvbWV0cnlQcmltaXRpdmUuVkFMSUQgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiggIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHNpemUgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInNpemVcIik7XHJcblxyXG5cdFx0Ly91cGRhdGVcclxuXHRcdGlmKCB0aGlzLmxhc3RfaW5mby50eXBlICE9IHRoaXMucHJvcGVydGllcy50eXBlIHx8IHRoaXMubGFzdF9pbmZvLnNpemUgIT0gc2l6ZSB8fCB0aGlzLmxhc3RfaW5mby5zdWJkaXZpc2lvbnMgIT0gdGhpcy5wcm9wZXJ0aWVzLnN1YmRpdmlzaW9ucyApXHJcblx0XHRcdHRoaXMudXBkYXRlTWVzaCggdGhpcy5wcm9wZXJ0aWVzLnR5cGUsIHNpemUsIHRoaXMucHJvcGVydGllcy5zdWJkaXZpc2lvbnMgKTtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLl9tZXNoKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlLnByb3RvdHlwZS51cGRhdGVNZXNoID0gZnVuY3Rpb24odHlwZSwgc2l6ZSwgc3ViZGl2aXNpb25zKVxyXG5cdHtcclxuXHRcdHN1YmRpdmlzaW9ucyA9IE1hdGgubWF4KDAsc3ViZGl2aXNpb25zKXwwO1xyXG5cclxuXHRcdHN3aXRjaCAodHlwZSlcclxuXHRcdHtcclxuXHRcdFx0Y2FzZSAxOiAvL0NVQkU6IFxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLmN1YmUoe3NpemU6IHNpemUsIG5vcm1hbHM6dHJ1ZSxjb29yZHM6dHJ1ZX0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IC8vUExBTkU6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2gucGxhbmUoe3NpemU6IHNpemUsIHh6OiB0cnVlLCBkZXRhaWw6IHN1YmRpdmlzaW9ucywgbm9ybWFsczp0cnVlLGNvb3Jkczp0cnVlfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgMzogLy9DWUxJTkRFUjpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5jeWxpbmRlcih7c2l6ZTogc2l6ZSwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMsIG5vcm1hbHM6dHJ1ZSxjb29yZHM6dHJ1ZX0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDQ6IC8vU1BIRVJFOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLnNwaGVyZSh7c2l6ZTogc2l6ZSwgXCJsb25nXCI6IHN1YmRpdmlzaW9ucywgbGF0OiBzdWJkaXZpc2lvbnMsIG5vcm1hbHM6dHJ1ZSxjb29yZHM6dHJ1ZX0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDU6IC8vQ0lSQ0xFOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLmNpcmNsZSh7c2l6ZTogc2l6ZSwgc2xpY2VzOiBzdWJkaXZpc2lvbnMsIG5vcm1hbHM6dHJ1ZSwgY29vcmRzOnRydWV9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA2OiAvL0hFTUlTUEhFUkU6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guc3BoZXJlKHtzaXplOiBzaXplLCBcImxvbmdcIjogc3ViZGl2aXNpb25zLCBsYXQ6IHN1YmRpdmlzaW9ucywgbm9ybWFsczp0cnVlLCBjb29yZHM6dHJ1ZSwgaGVtaTogdHJ1ZX0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDc6IC8vSUNPU0FIRURST046XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guaWNvc2FoZWRyb24oe3NpemU6IHNpemUsIHN1YmRpdmlzaW9uczpzdWJkaXZpc2lvbnMgfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgODogLy9DT05FOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLmNvbmUoe3JhZGl1czogc2l6ZSwgaGVpZ2h0OiBzaXplLCBzdWJkaXZpc2lvbnM6c3ViZGl2aXNpb25zIH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDk6IC8vUVVBRDpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5wbGFuZSh7c2l6ZTogc2l6ZSwgeHo6IGZhbHNlLCBkZXRhaWw6IHN1YmRpdmlzaW9ucywgbm9ybWFsczp0cnVlLCBjb29yZHM6dHJ1ZSB9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmxhc3RfaW5mby50eXBlID0gdHlwZTtcclxuXHRcdHRoaXMubGFzdF9pbmZvLnNpemUgPSBzaXplO1xyXG5cdFx0dGhpcy5sYXN0X2luZm8uc3ViZGl2aXNpb25zID0gc3ViZGl2aXNpb25zO1xyXG5cdFx0dGhpcy5fbWVzaC52ZXJzaW9uID0gdGhpcy52ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9tZXNoX3ByaW1pdGl2ZVwiLCBMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZSApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoUmVuZGVyUG9pbnRzKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWF0NFwiLCBcIm1hdDRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidGV4XCIsIFwidGV4dHVyZVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdFx0cG9pbnRfc2l6ZTogMC4xLFxyXG5cdFx0XHRmaXhlZF9zaXplOiBmYWxzZSxcclxuXHRcdFx0YWRkaXRpdmU6IHRydWUsXHJcblx0XHRcdGNvbG9yOiBbMSwxLDFdLFxyXG5cdFx0XHRvcGFjaXR5OiAxXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSB2ZWM0LmNyZWF0ZShbMSwxLDEsMV0pO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMgPSB7XHJcblx0XHRcdHVfcG9pbnRfc2l6ZTogMSxcclxuXHRcdFx0dV9wZXJzcGVjdGl2ZTogMSxcclxuXHRcdFx0dV9wb2ludF9wZXJzcGVjdGl2ZTogMSxcclxuXHRcdFx0dV9jb2xvcjogdGhpcy5jb2xvclxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubWVzaCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhSZW5kZXJQb2ludHMudGl0bGUgPSBcInJlbmRlclBvaW50c1wiO1xyXG5cdExHcmFwaFJlbmRlclBvaW50cy5kZXNjID0gXCJyZW5kZXIgcG9pbnRzIHdpdGggYSB0ZXh0dXJlXCI7XHJcblxyXG5cdExHcmFwaFJlbmRlclBvaW50cy53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRjb2xvcjogeyB3aWRnZXQ6IFwiY29sb3JcIiB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLnByb3RvdHlwZS51cGRhdGVNZXNoID0gZnVuY3Rpb24oZ2VvbWV0cnkpXHJcblx0e1xyXG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG5cdFx0aWYoIXRoaXMuYnVmZmVyIHx8ICF0aGlzLmJ1ZmZlci5kYXRhIHx8IHRoaXMuYnVmZmVyLmRhdGEubGVuZ3RoICE9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aClcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgR0wuQnVmZmVyKCBHTC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5LnZlcnRpY2VzLDMsR0wuRFlOQU1JQ19EUkFXKTtcclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5idWZmZXIuZGF0YS5zZXQoIGdlb21ldHJ5LnZlcnRpY2VzICk7XHJcblx0XHRcdHRoaXMuYnVmZmVyLnVwbG9hZChHTC5EWU5BTUlDX0RSQVcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCF0aGlzLm1lc2gpXHJcblx0XHRcdHRoaXMubWVzaCA9IG5ldyBHTC5NZXNoKCk7XHJcblxyXG5cdFx0dGhpcy5tZXNoLmFkZEJ1ZmZlcihcInZlcnRpY2VzXCIsdGhpcy5idWZmZXIpO1xyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IHRoaXMubWVzaC5pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdHRoaXMudmVyc2lvbiA9IHRoaXMubWVzaC52ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblx0fVxyXG5cclxuXHRMR3JhcGhSZW5kZXJQb2ludHMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGlmKCF0aGlzLnByb3BlcnRpZXMuZW5hYmxlZClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWdlb21ldHJ5KVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRpZih0aGlzLnZlcnNpb24gIT0gZ2VvbWV0cnkuX3ZlcnNpb24gfHwgdGhpcy5nZW9tZXRyeV9pZCAhPSBnZW9tZXRyeS5faWQgKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1lc2goIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0aWYoIUxpdGVHcmFwaC5MR3JhcGhSZW5kZXIub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMpXHJcblx0XHR7XHJcblx0XHRcdGNvbnNvbGUud2FybihcImNhbm5vdCByZW5kZXIgZ2VvbWV0cnksIExpdGVHcmFwaC5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcyBpcyBudWxsLCByZW1lbWJlciB0byBmaWxsIHRoaXMgd2l0aCBhIGNhbGxiYWNrKHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXgpIHRvIHVzZSAzRCByZW5kZXJpbmcgZnJvbSB0aGUgZ3JhcGhcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRMaXRlR3JhcGguTEdyYXBoUmVuZGVyLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzKCB2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4ICk7XHJcblx0XHR2YXIgc2hhZGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG5cdFx0XHJcblx0XHRpZih0ZXh0dXJlKVxyXG5cdFx0e1xyXG5cdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1widGV4dHVyZWRfcG9pbnRzXCJdO1xyXG5cdFx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJ0ZXh0dXJlZF9wb2ludHNcIl0gPSBuZXcgR0wuU2hhZGVyKCBMR3JhcGhSZW5kZXJQb2ludHMudmVydGV4X3NoYWRlcl9jb2RlLCBMR3JhcGhSZW5kZXJQb2ludHMuZnJhZ21lbnRfc2hhZGVyX2NvZGUsIHsgVVNFX1RFWFRVUkVEX1BPSU5UUzpcIlwiIH0pO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1wicG9pbnRzXCJdO1xyXG5cdFx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJwb2ludHNcIl0gPSBuZXcgR0wuU2hhZGVyKCBMR3JhcGhSZW5kZXJQb2ludHMudmVydGV4X3NoYWRlcl9jb2RlLCBMR3JhcGhSZW5kZXJQb2ludHMuZnJhZ21lbnRfc2hhZGVyX2NvZGUsIHsgVVNFX1BPSU5UUzogXCJcIiB9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbG9yLnNldCggdGhpcy5wcm9wZXJ0aWVzLmNvbG9yICk7XHJcblx0XHR0aGlzLmNvbG9yWzNdID0gdGhpcy5wcm9wZXJ0aWVzLm9wYWNpdHk7XHJcblxyXG5cdFx0dmFyIG0gPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKG0pXHJcblx0XHRcdG1vZGVsX21hdHJpeC5zZXQobSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG1hdDQuaWRlbnRpdHkoIG1vZGVsX21hdHJpeCApO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMudV9wb2ludF9zaXplID0gdGhpcy5wcm9wZXJ0aWVzLnBvaW50X3NpemU7XHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcG9pbnRfcGVyc3BlY3RpdmUgPSB0aGlzLnByb3BlcnRpZXMuZml4ZWRfc2l6ZSA/IDAgOiAxO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BlcnNwZWN0aXZlID0gZ2wudmlld3BvcnRfZGF0YVszXSAqIHByb2plY3Rpb25fbWF0cml4WzVdO1xyXG5cclxuXHRcdHNoYWRlci51bmlmb3JtcyggZ2xvYmFsX3VuaWZvcm1zICk7XHJcblx0XHRzaGFkZXIudW5pZm9ybXMoIHRoaXMudW5pZm9ybXMgKTtcclxuXHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMub3BhY2l0eSA+PSAxKVxyXG5cdFx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRnbC5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0Z2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLmFkZGl0aXZlIClcclxuXHRcdHtcclxuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cdFx0XHRnbC5kZXB0aE1hc2soIGZhbHNlICk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0c2hhZGVyLmRyYXcoIHRoaXMubWVzaCwgR0wuUE9JTlRTICk7XHJcblxyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvcmVuZGVyX3BvaW50c1wiLCBMR3JhcGhSZW5kZXJQb2ludHMgKTtcclxuXHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLnZlcnRleF9zaGFkZXJfY29kZSA9ICdcXFxyXG5cdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxcclxuXHRcdGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4O1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzMgdl92ZXJ0ZXg7XFxuXFxcclxuXHRcdGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0YXR0cmlidXRlIHZlYzIgYV9jb29yZDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfU0laRVxcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSBmbG9hdCBhX2V4dHJhO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIG1hdDQgdV9tb2RlbDtcXG5cXFxyXG5cdFx0I2Vsc2VcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIG1hdDQgdV9tb2RlbDtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdHVuaWZvcm0gbWF0NCB1X3ZpZXdwcm9qZWN0aW9uO1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfcG9pbnRfc2l6ZTtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BlcnNwZWN0aXZlO1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfcG9pbnRfcGVyc3BlY3RpdmU7XFxuXFxcclxuXHRcdGZsb2F0IGNvbXB1dGVQb2ludFNpemUoZmxvYXQgcmFkaXVzLCBmbG9hdCB3KVxcblxcXHJcblx0XHR7XFxuXFxcclxuXHRcdFx0aWYocmFkaXVzIDwgMC4wKVxcblxcXHJcblx0XHRcdFx0cmV0dXJuIC1yYWRpdXM7XFxuXFxcclxuXHRcdFx0cmV0dXJuIHVfcGVyc3BlY3RpdmUgKiByYWRpdXMgLyB3O1xcblxcXHJcblx0XHR9XFxuXFxcclxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHR2X2Nvb3JkID0gYV9jb29yZDtcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yID0gYV9jb2xvcjtcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHR2X3ZlcnRleCA9ICggdV9tb2RlbCAqIHZlYzQoIGFfdmVydGV4LCAxLjAgKSkueHl6O1xcblxcXHJcblx0XHRcdHZfbm9ybWFsID0gKCB1X21vZGVsICogdmVjNCggYV9ub3JtYWwsIDAuMCApKS54eXo7XFxuXFxcclxuXHRcdFx0Z2xfUG9zaXRpb24gPSB1X3ZpZXdwcm9qZWN0aW9uICogdmVjNCh2X3ZlcnRleCwxLjApO1xcblxcXHJcblx0XHRcdGdsX1BvaW50U2l6ZSA9IHVfcG9pbnRfc2l6ZTtcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX1NJWkVcXG5cXFxyXG5cdFx0XHRcdGdsX1BvaW50U2l6ZSA9IGFfZXh0cmE7XFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0aWYodV9wb2ludF9wZXJzcGVjdGl2ZSAhPSAwLjApXFxuXFxcclxuXHRcdFx0XHRnbF9Qb2ludFNpemUgPSBjb21wdXRlUG9pbnRTaXplKCBnbF9Qb2ludFNpemUsIGdsX1Bvc2l0aW9uLncgKTtcXG5cXFxyXG5cdFx0fVxcXHJcblx0JztcclxuXHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLmZyYWdtZW50X3NoYWRlcl9jb2RlID0gJ1xcXHJcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXFxyXG5cdFx0dW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHR2ZWM0IGNvbG9yID0gdV9jb2xvcjtcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX1RFWFRVUkVEX1BPSU5UU1xcblxcXHJcblx0XHRcdFx0Y29sb3IgKj0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgZ2xfUG9pbnRDb29yZC54eSk7XFxuXFxcclxuXHRcdFx0I2Vsc2VcXG5cXFxyXG5cdFx0XHRcdCNpZmRlZiBVU0VfVEVYVFVSRVxcblxcXHJcblx0XHRcdFx0ICBjb2xvciAqPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdCAgaWYoY29sb3IuYSA8IDAuMSlcXG5cXFxyXG5cdFx0XHRcdFx0ZGlzY2FyZDtcXG5cXFxyXG5cdFx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdFx0I2lmZGVmIFVTRV9QT0lOVFNcXG5cXFxyXG5cdFx0XHRcdFx0ZmxvYXQgZGlzdCA9IGxlbmd0aCggZ2xfUG9pbnRDb29yZC54eSAtIHZlYzIoMC41KSApO1xcblxcXHJcblx0XHRcdFx0XHRpZiggZGlzdCA+IDAuNDUgKVxcblxcXHJcblx0XHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcclxuXHRcdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0XHRjb2xvciAqPSB2X2NvbG9yO1xcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXHJcblx0XHR9XFxcclxuXHQnO1xyXG5cclxuXHQvL2Jhc2VkIG9uIGh0dHBzOi8vaW5jb252ZXJnZW50Lm5ldC8yMDE5L2RlcHRoLW9mLWZpZWxkL1xyXG5cdC8qXHJcblx0ZnVuY3Rpb24gTEdyYXBoUmVuZGVyR2VvbWV0cnlET0YoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtYXQ0XCIsIFwibWF0NFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ0ZXhcIiwgXCJ0ZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRlbmFibGVkOiB0cnVlLFxyXG5cdFx0XHRsaW5lczogdHJ1ZSxcclxuXHRcdFx0cG9pbnRfc2l6ZTogMC4xLFxyXG5cdFx0XHRmaXhlZF9zaXplOiBmYWxzZSxcclxuXHRcdFx0YWRkaXRpdmU6IHRydWUsXHJcblx0XHRcdGNvbG9yOiBbMSwxLDFdLFxyXG5cdFx0XHRvcGFjaXR5OiAxXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSB2ZWM0LmNyZWF0ZShbMSwxLDEsMV0pO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMgPSB7XHJcblx0XHRcdHVfcG9pbnRfc2l6ZTogMSxcclxuXHRcdFx0dV9wZXJzcGVjdGl2ZTogMSxcclxuXHRcdFx0dV9wb2ludF9wZXJzcGVjdGl2ZTogMSxcclxuXHRcdFx0dV9jb2xvcjogdGhpcy5jb2xvclxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubWVzaCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRjb2xvcjogeyB3aWRnZXQ6IFwiY29sb3JcIiB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoUmVuZGVyR2VvbWV0cnlET0YucHJvdG90eXBlLnVwZGF0ZU1lc2ggPSBmdW5jdGlvbihnZW9tZXRyeSlcclxuXHR7XHJcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcblx0XHRpZighdGhpcy5idWZmZXIgfHwgdGhpcy5idWZmZXIuZGF0YS5sZW5ndGggIT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoKVxyXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBHTC5CdWZmZXIoIEdMLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkudmVydGljZXMsMyxHTC5EWU5BTUlDX0RSQVcpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmJ1ZmZlci5kYXRhLnNldCggZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0dGhpcy5idWZmZXIudXBsb2FkKEdMLkRZTkFNSUNfRFJBVyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIXRoaXMubWVzaClcclxuXHRcdFx0dGhpcy5tZXNoID0gbmV3IEdMLk1lc2goKTtcclxuXHJcblx0XHR0aGlzLm1lc2guYWRkQnVmZmVyKFwidmVydGljZXNcIix0aGlzLmJ1ZmZlcik7XHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gdGhpcy5tZXNoLmlkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gdGhpcy5tZXNoLnZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHR9XHJcblxyXG5cdExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZighdGhpcy5wcm9wZXJ0aWVzLmVuYWJsZWQpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFnZW9tZXRyeSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYodGhpcy52ZXJzaW9uICE9IGdlb21ldHJ5Ll92ZXJzaW9uIHx8IHRoaXMuZ2VvbWV0cnlfaWQgIT0gZ2VvbWV0cnkuX2lkIClcclxuXHRcdFx0dGhpcy51cGRhdGVNZXNoKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmKCFMaXRlR3JhcGguTEdyYXBoUmVuZGVyLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzKVxyXG5cdFx0e1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJjYW5ub3QgcmVuZGVyIGdlb21ldHJ5LCBMaXRlR3JhcGgub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMgaXMgbnVsbCwgcmVtZW1iZXIgdG8gZmlsbCB0aGlzIHdpdGggYSBjYWxsYmFjayh2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4KSB0byB1c2UgM0QgcmVuZGVyaW5nIGZyb20gdGhlIGdyYXBoXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0TGl0ZUdyYXBoLkxHcmFwaFJlbmRlci5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcyggdmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCApO1xyXG5cdFx0dmFyIHNoYWRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuXHRcdFxyXG5cdFx0aWYodGV4dHVyZSlcclxuXHRcdHtcclxuXHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInRleHR1cmVkX3BvaW50c1wiXTtcclxuXHRcdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1widGV4dHVyZWRfcG9pbnRzXCJdID0gbmV3IEdMLlNoYWRlciggTEdyYXBoUmVuZGVyR2VvbWV0cnlET0YudmVydGV4X3NoYWRlcl9jb2RlLCBMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi5mcmFnbWVudF9zaGFkZXJfY29kZSwgeyBVU0VfVEVYVFVSRURfUE9JTlRTOlwiXCIgfSk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJwb2ludHNcIl07XHJcblx0XHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInBvaW50c1wiXSA9IG5ldyBHTC5TaGFkZXIoIExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLnZlcnRleF9zaGFkZXJfY29kZSwgTEdyYXBoUmVuZGVyR2VvbWV0cnlET0YuZnJhZ21lbnRfc2hhZGVyX2NvZGUsIHsgVVNFX1BPSU5UUzogXCJcIiB9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbG9yLnNldCggdGhpcy5wcm9wZXJ0aWVzLmNvbG9yICk7XHJcblx0XHR0aGlzLmNvbG9yWzNdID0gdGhpcy5wcm9wZXJ0aWVzLm9wYWNpdHk7XHJcblxyXG5cdFx0dmFyIG0gPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKG0pXHJcblx0XHRcdG1vZGVsX21hdHJpeC5zZXQobSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG1hdDQuaWRlbnRpdHkoIG1vZGVsX21hdHJpeCApO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMudV9wb2ludF9zaXplID0gdGhpcy5wcm9wZXJ0aWVzLnBvaW50X3NpemU7XHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcG9pbnRfcGVyc3BlY3RpdmUgPSB0aGlzLnByb3BlcnRpZXMuZml4ZWRfc2l6ZSA/IDAgOiAxO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BlcnNwZWN0aXZlID0gZ2wudmlld3BvcnRfZGF0YVszXSAqIHByb2plY3Rpb25fbWF0cml4WzVdO1xyXG5cclxuXHRcdHNoYWRlci51bmlmb3JtcyggZ2xvYmFsX3VuaWZvcm1zICk7XHJcblx0XHRzaGFkZXIudW5pZm9ybXMoIHRoaXMudW5pZm9ybXMgKTtcclxuXHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMub3BhY2l0eSA+PSAxKVxyXG5cdFx0XHRnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRnbC5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0Z2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLmFkZGl0aXZlIClcclxuXHRcdHtcclxuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cdFx0XHRnbC5kZXB0aE1hc2soIGZhbHNlICk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0c2hhZGVyLmRyYXcoIHRoaXMubWVzaCwgR0wuUE9JTlRTICk7XHJcblxyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvcmVuZGVyX2RvZlwiLCBMR3JhcGhSZW5kZXJHZW9tZXRyeURPRiApO1xyXG5cclxuXHRMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi52ZXJ0ZXhfc2hhZGVyX2NvZGUgPSAnXFxcclxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcXHJcblx0XHRhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMzIHZfdmVydGV4O1xcblxcXHJcblx0XHRhdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcblxcXHJcblx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFfY29vcmQ7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHQjaWZkZWYgVVNFX1NJWkVcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgZmxvYXQgYV9leHRyYTtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSBtYXQ0IHVfbW9kZWw7XFxuXFxcclxuXHRcdCNlbHNlXFxuXFxcclxuXHRcdFx0dW5pZm9ybSBtYXQ0IHVfbW9kZWw7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHR1bmlmb3JtIG1hdDQgdV92aWV3cHJvamVjdGlvbjtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BvaW50X3NpemU7XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wZXJzcGVjdGl2ZTtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BvaW50X3BlcnNwZWN0aXZlO1xcblxcXHJcblx0XHRmbG9hdCBjb21wdXRlUG9pbnRTaXplKGZsb2F0IHJhZGl1cywgZmxvYXQgdylcXG5cXFxyXG5cdFx0e1xcblxcXHJcblx0XHRcdGlmKHJhZGl1cyA8IDAuMClcXG5cXFxyXG5cdFx0XHRcdHJldHVybiAtcmFkaXVzO1xcblxcXHJcblx0XHRcdHJldHVybiB1X3BlcnNwZWN0aXZlICogcmFkaXVzIC8gdztcXG5cXFxyXG5cdFx0fVxcblxcXHJcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0dl9jb29yZCA9IGFfY29vcmQ7XFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdFx0dl9jb2xvciA9IGFfY29sb3I7XFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0dl92ZXJ0ZXggPSAoIHVfbW9kZWwgKiB2ZWM0KCBhX3ZlcnRleCwgMS4wICkpLnh5ejtcXG5cXFxyXG5cdFx0XHR2X25vcm1hbCA9ICggdV9tb2RlbCAqIHZlYzQoIGFfbm9ybWFsLCAwLjAgKSkueHl6O1xcblxcXHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdV92aWV3cHJvamVjdGlvbiAqIHZlYzQodl92ZXJ0ZXgsMS4wKTtcXG5cXFxyXG5cdFx0XHRnbF9Qb2ludFNpemUgPSB1X3BvaW50X3NpemU7XFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9TSVpFXFxuXFxcclxuXHRcdFx0XHRnbF9Qb2ludFNpemUgPSBhX2V4dHJhO1xcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdGlmKHVfcG9pbnRfcGVyc3BlY3RpdmUgIT0gMC4wKVxcblxcXHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gY29tcHV0ZVBvaW50U2l6ZSggZ2xfUG9pbnRTaXplLCBnbF9Qb3NpdGlvbi53ICk7XFxuXFxcclxuXHRcdH1cXFxyXG5cdCc7XHJcblxyXG5cdExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLmZyYWdtZW50X3NoYWRlcl9jb2RlID0gJ1xcXHJcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXFxyXG5cdFx0dW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHR2ZWM0IGNvbG9yID0gdV9jb2xvcjtcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX1RFWFRVUkVEX1BPSU5UU1xcblxcXHJcblx0XHRcdFx0Y29sb3IgKj0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgZ2xfUG9pbnRDb29yZC54eSk7XFxuXFxcclxuXHRcdFx0I2Vsc2VcXG5cXFxyXG5cdFx0XHRcdCNpZmRlZiBVU0VfVEVYVFVSRVxcblxcXHJcblx0XHRcdFx0ICBjb2xvciAqPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdCAgaWYoY29sb3IuYSA8IDAuMSlcXG5cXFxyXG5cdFx0XHRcdFx0ZGlzY2FyZDtcXG5cXFxyXG5cdFx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdFx0I2lmZGVmIFVTRV9QT0lOVFNcXG5cXFxyXG5cdFx0XHRcdFx0ZmxvYXQgZGlzdCA9IGxlbmd0aCggZ2xfUG9pbnRDb29yZC54eSAtIHZlYzIoMC41KSApO1xcblxcXHJcblx0XHRcdFx0XHRpZiggZGlzdCA+IDAuNDUgKVxcblxcXHJcblx0XHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcclxuXHRcdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0XHRjb2xvciAqPSB2X2NvbG9yO1xcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXHJcblx0XHR9XFxcclxuXHQnO1xyXG5cdCovXHJcblxyXG5cclxuXHJcbn0pKHRoaXMpO1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcbiAgICB2YXIgTEdyYXBoVGV4dHVyZSA9IGdsb2JhbC5MR3JhcGhUZXh0dXJlO1xyXG5cclxuICAgIC8vV29ya3Mgd2l0aCBMaXRlZ2wuanMgdG8gY3JlYXRlIFdlYkdMIG5vZGVzXHJcbiAgICBpZiAodHlwZW9mIEdMICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAvLyBUZXh0dXJlIExlbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICBmdW5jdGlvbiBMR3JhcGhGWExlbnMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFiZXJyYXRpb25cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJEaXN0b3J0aW9uXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiQmx1clwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICAgICAgYWJlcnJhdGlvbjogMS4wLFxyXG4gICAgICAgICAgICAgICAgZGlzdG9ydGlvbjogMS4wLFxyXG4gICAgICAgICAgICAgICAgYmx1cjogMS4wLFxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICghTEdyYXBoRlhMZW5zLl9zaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIExHcmFwaEZYTGVucy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcclxuICAgICAgICAgICAgICAgICAgICBHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXHJcbiAgICAgICAgICAgICAgICAgICAgTEdyYXBoRlhMZW5zLnBpeGVsX3NoYWRlclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIExHcmFwaEZYTGVucy5fdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKDMsIDEsIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGdsLlJHQixcclxuICAgICAgICAgICAgICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19FREdFLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogZ2wuTElORUFSLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlcjogZ2wuTElORUFSLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsX2RhdGE6IFsyNTUsIDAsIDAsIDAsIDI1NSwgMCwgMCwgMCwgMjU1XVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExHcmFwaEZYTGVucy50aXRsZSA9IFwiTGVuc1wiO1xyXG4gICAgICAgIExHcmFwaEZYTGVucy5kZXNjID0gXCJDYW1lcmEgTGVucyBkaXN0b3J0aW9uXCI7XHJcbiAgICAgICAgTEdyYXBoRlhMZW5zLndpZGdldHNfaW5mbyA9IHtcclxuICAgICAgICAgICAgcHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYTGVucy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0ZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxyXG4gICAgICAgICAgICAgICAgdGV4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFiZXJyYXRpb24gPSB0aGlzLnByb3BlcnRpZXMuYWJlcnJhdGlvbjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgxKSkge1xyXG4gICAgICAgICAgICAgICAgYWJlcnJhdGlvbiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmFiZXJyYXRpb24gPSBhYmVycmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlzdG9ydGlvbiA9IHRoaXMucHJvcGVydGllcy5kaXN0b3J0aW9uO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDIpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0b3J0aW9uID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZGlzdG9ydGlvbiA9IGRpc3RvcnRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBibHVyID0gdGhpcy5wcm9wZXJ0aWVzLmJsdXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMykpIHtcclxuICAgICAgICAgICAgICAgIGJsdXIgPSB0aGlzLmdldElucHV0RGF0YSgzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5ibHVyID0gYmx1cjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgICAgIHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBMR3JhcGhGWExlbnMuX3NoYWRlcjtcclxuICAgICAgICAgICAgLy92YXIgY2FtZXJhID0gTFMuUmVuZGVyZXIuX2N1cnJlbnRfY2FtZXJhO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRleC5iaW5kKDApO1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnVuaWZvcm1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXh0dXJlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2FiZXJyYXRpb246IGFiZXJyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfZGlzdG9ydGlvbjogZGlzdG9ydGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9ibHVyOiBibHVyXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZHJhdyhtZXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWExlbnMucGl4ZWxfc2hhZGVyID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9jYW1lcmFfcGxhbmVzO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9hYmVycmF0aW9uO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9kaXN0b3J0aW9uO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzIgY29vcmQgPSB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHZlYzIoMC41KSwgY29vcmQpO1xcblxcXHJcblx0XHRcdFx0dmVjMiBkaXN0X2Nvb3JkID0gY29vcmQgLSB2ZWMyKDAuNSk7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBwZXJjZW50ID0gMS4wICsgKCgwLjUgLSBkaXN0KSAvIDAuNSkgKiB1X2Rpc3RvcnRpb247XFxuXFxcclxuXHRcdFx0XHRkaXN0X2Nvb3JkICo9IHBlcmNlbnQ7XFxuXFxcclxuXHRcdFx0XHRjb29yZCA9IGRpc3RfY29vcmQgKyB2ZWMyKDAuNSk7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSxjb29yZCwgdV9ibHVyICogZGlzdCk7XFxuXFxcclxuXHRcdFx0XHRjb2xvci5yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSx2ZWMyKDAuNSkgKyBkaXN0X2Nvb3JkICogKDEuMCswLjAxKnVfYWJlcnJhdGlvbiksIHVfYmx1ciAqIGRpc3QgKS5yO1xcblxcXHJcblx0XHRcdFx0Y29sb3IuYiA9IHRleHR1cmUyRCh1X3RleHR1cmUsdmVjMigwLjUpICsgZGlzdF9jb29yZCAqICgxLjAtMC4wMSp1X2FiZXJyYXRpb24pLCB1X2JsdXIgKiBkaXN0ICkuYjtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXHJcblx0XHRcdH1cXG5cXFxyXG5cdFx0XHRcIjtcclxuICAgICAgICAvKlxyXG5cdFx0XHRmbG9hdCBub3JtYWxpemVkX3R1bmFibGVfc2lnbW9pZChmbG9hdCB4cywgZmxvYXQgaylcXG5cXFxyXG5cdFx0XHR7XFxuXFxcclxuXHRcdFx0XHR4cyA9IHhzICogMi4wIC0gMS4wO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgc2lnbnggPSBzaWduKHhzKTtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IGFic3ggPSBhYnMoeHMpO1xcblxcXHJcblx0XHRcdFx0cmV0dXJuIHNpZ254ICogKCgtayAtIDEuMCkqYWJzeCkvKDIuMCooLTIuMCprKmFic3gray0xLjApKSArIDAuNTtcXG5cXFxyXG5cdFx0XHR9XFxuXFxcclxuXHRcdCovXHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZngvbGVuc1wiLCBMR3JhcGhGWExlbnMpO1xyXG4gICAgICAgIGdsb2JhbC5MR3JhcGhGWExlbnMgPSBMR3JhcGhGWExlbnM7XHJcblxyXG4gICAgICAgIC8qIG5vdCB3b3JraW5nIHlldFxyXG5cdGZ1bmN0aW9uIExHcmFwaERlcHRoT2ZGaWVsZCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkNvbG9yXCIsXCJUZXh0dXJlXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkxpbmVhciBEZXB0aFwiLFwiVGV4dHVyZVwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJDYW1lcmFcIixcImNhbWVyYVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLFwiVGV4dHVyZVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgaGlnaF9wcmVjaXNpb246IGZhbHNlIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhEZXB0aE9mRmllbGQudGl0bGUgPSBcIkRlcHRoIE9mIEZpZWxkXCI7XHJcblx0TEdyYXBoRGVwdGhPZkZpZWxkLmRlc2MgPSBcIkFwcGxpZXMgYSBkZXB0aCBvZiBmaWVsZCBlZmZlY3RcIjtcclxuXHJcblx0TEdyYXBoRGVwdGhPZkZpZWxkLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIGRlcHRoID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHR2YXIgY2FtZXJhID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcblxyXG5cdFx0aWYoIXRleCB8fCAhZGVwdGggfHwgIWNhbWVyYSkgXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWNpc2lvbiA9IGdsLlVOU0lHTkVEX0JZVEU7XHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMuaGlnaF9wcmVjaXNpb24pXHJcblx0XHRcdHByZWNpc2lvbiA9IGdsLmhhbGZfZmxvYXRfZXh0ID8gZ2wuSEFMRl9GTE9BVF9PRVMgOiBnbC5GTE9BVDtcdFx0XHRcclxuXHRcdGlmKCF0aGlzLl90ZW1wX3RleHR1cmUgfHwgdGhpcy5fdGVtcF90ZXh0dXJlLnR5cGUgIT0gcHJlY2lzaW9uIHx8XHJcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS53aWR0aCAhPSB0ZXgud2lkdGggfHwgdGhpcy5fdGVtcF90ZXh0dXJlLmhlaWdodCAhPSB0ZXguaGVpZ2h0KVxyXG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSggdGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7IHR5cGU6IHByZWNpc2lvbiwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9KTtcclxuXHJcblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoRGVwdGhPZkZpZWxkLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKCBHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsIExHcmFwaERlcHRoT2ZGaWVsZC5fcGl4ZWxfc2hhZGVyICk7XHJcblxyXG5cdFx0dmFyIHNjcmVlbl9tZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XHJcblxyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHR2YXIgY2FtZXJhX3Bvc2l0aW9uID0gY2FtZXJhLmdldEV5ZSgpO1xyXG5cdFx0dmFyIGZvY3VzX3BvaW50ID0gY2FtZXJhLmdldENlbnRlcigpO1xyXG5cdFx0dmFyIGRpc3RhbmNlID0gdmVjMy5kaXN0YW5jZSggY2FtZXJhX3Bvc2l0aW9uLCBmb2N1c19wb2ludCApO1xyXG5cdFx0dmFyIGZhciA9IGNhbWVyYS5mYXI7XHJcblx0XHR2YXIgZm9jdXNfcmFuZ2UgPSBkaXN0YW5jZSAqIDAuNTtcclxuXHJcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGV4LmJpbmQoMCk7XHJcblx0XHRcdGRlcHRoLmJpbmQoMSk7XHJcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh7dV90ZXh0dXJlOjAsIHVfZGVwdGhfdGV4dHVyZToxLCB1X3Jlc29sdXRpb246IFsxL3RleC53aWR0aCwgMS90ZXguaGVpZ2h0XSwgdV9mYXI6IGZhciwgdV9mb2N1c19wb2ludDogZGlzdGFuY2UsIHVfZm9jdXNfc2NhbGU6IGZvY3VzX3JhbmdlIH0pLmRyYXcoc2NyZWVuX21lc2gpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XHJcblx0fVxyXG5cclxuXHQvL2Zyb20gaHR0cDovL3R1eGVkb2xhYnMuYmxvZ3Nwb3QuY29tLmVzLzIwMTgvMDUvYm9rZWgtZGVwdGgtb2YtZmllbGQtaW4tc2luZ2xlLXBhc3MuaHRtbFxyXG5cdExHcmFwaERlcHRoT2ZGaWVsZC5fcGl4ZWxfc2hhZGVyID0gXCJcXG5cXFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlOyAvL0ltYWdlIHRvIGJlIHByb2Nlc3NlZFxcblxcXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X2RlcHRoX3RleHR1cmU7IC8vTGluZWFyIGRlcHRoLCB3aGVyZSAxLjAgPT0gZmFyIHBsYW5lXFxuXFxcclxuXHRcdHVuaWZvcm0gdmVjMiB1X2lyZXNvbHV0aW9uOyAvL1RoZSBzaXplIG9mIGEgcGl4ZWw6IHZlYzIoMS4wL3dpZHRoLCAxLjAvaGVpZ2h0KVxcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfZmFyOyAvLyBGYXIgcGxhbmVcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ZvY3VzX3BvaW50O1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfZm9jdXNfc2NhbGU7XFxuXFxcclxuXHRcdFxcblxcXHJcblx0XHRjb25zdCBmbG9hdCBHT0xERU5fQU5HTEUgPSAyLjM5OTk2MzIzO1xcblxcXHJcblx0XHRjb25zdCBmbG9hdCBNQVhfQkxVUl9TSVpFID0gMjAuMDtcXG5cXFxyXG5cdFx0Y29uc3QgZmxvYXQgUkFEX1NDQUxFID0gMC41OyAvLyBTbWFsbGVyID0gbmljZXIgYmx1ciwgbGFyZ2VyID0gZmFzdGVyXFxuXFxcclxuXHRcdFxcblxcXHJcblx0XHRmbG9hdCBnZXRCbHVyU2l6ZShmbG9hdCBkZXB0aCwgZmxvYXQgZm9jdXNQb2ludCwgZmxvYXQgZm9jdXNTY2FsZSlcXG5cXFxyXG5cdFx0e1xcblxcXHJcblx0XHQgZmxvYXQgY29jID0gY2xhbXAoKDEuMCAvIGZvY3VzUG9pbnQgLSAxLjAgLyBkZXB0aCkqZm9jdXNTY2FsZSwgLTEuMCwgMS4wKTtcXG5cXFxyXG5cdFx0IHJldHVybiBhYnMoY29jKSAqIE1BWF9CTFVSX1NJWkU7XFxuXFxcclxuXHRcdH1cXG5cXFxyXG5cdFx0XFxuXFxcclxuXHRcdHZlYzMgZGVwdGhPZkZpZWxkKHZlYzIgdGV4Q29vcmQsIGZsb2F0IGZvY3VzUG9pbnQsIGZsb2F0IGZvY3VzU2NhbGUpXFxuXFxcclxuXHRcdHtcXG5cXFxyXG5cdFx0IGZsb2F0IGNlbnRlckRlcHRoID0gdGV4dHVyZTJEKHVfZGVwdGhfdGV4dHVyZSwgdGV4Q29vcmQpLnIgKiB1X2ZhcjtcXG5cXFxyXG5cdFx0IGZsb2F0IGNlbnRlclNpemUgPSBnZXRCbHVyU2l6ZShjZW50ZXJEZXB0aCwgZm9jdXNQb2ludCwgZm9jdXNTY2FsZSk7XFxuXFxcclxuXHRcdCB2ZWMzIGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCkucmdiO1xcblxcXHJcblx0XHQgZmxvYXQgdG90ID0gMS4wO1xcblxcXHJcblx0XHRcXG5cXFxyXG5cdFx0IGZsb2F0IHJhZGl1cyA9IFJBRF9TQ0FMRTtcXG5cXFxyXG5cdFx0IGZvciAoZmxvYXQgYW5nID0gMC4wOyBhbmcgPCAxMDAuMDsgYW5nICs9IEdPTERFTl9BTkdMRSlcXG5cXFxyXG5cdFx0IHtcXG5cXFxyXG5cdFx0ICB2ZWMyIHRjID0gdGV4Q29vcmQgKyB2ZWMyKGNvcyhhbmcpLCBzaW4oYW5nKSkgKiB1X2lyZXNvbHV0aW9uICogcmFkaXVzO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHQgIHZlYzMgc2FtcGxlQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB0YykucmdiO1xcblxcXHJcblx0XHQgIGZsb2F0IHNhbXBsZURlcHRoID0gdGV4dHVyZTJEKHVfZGVwdGhfdGV4dHVyZSwgdGMpLnIgKiB1X2ZhcjtcXG5cXFxyXG5cdFx0ICBmbG9hdCBzYW1wbGVTaXplID0gZ2V0Qmx1clNpemUoIHNhbXBsZURlcHRoLCBmb2N1c1BvaW50LCBmb2N1c1NjYWxlICk7XFxuXFxcclxuXHRcdCAgaWYgKHNhbXBsZURlcHRoID4gY2VudGVyRGVwdGgpXFxuXFxcclxuXHRcdCAgIHNhbXBsZVNpemUgPSBjbGFtcChzYW1wbGVTaXplLCAwLjAsIGNlbnRlclNpemUqMi4wKTtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0ICBmbG9hdCBtID0gc21vb3Roc3RlcChyYWRpdXMtMC41LCByYWRpdXMrMC41LCBzYW1wbGVTaXplKTtcXG5cXFxyXG5cdFx0ICBjb2xvciArPSBtaXgoY29sb3IvdG90LCBzYW1wbGVDb2xvciwgbSk7XFxuXFxcclxuXHRcdCAgdG90ICs9IDEuMDtcXG5cXFxyXG5cdFx0ICByYWRpdXMgKz0gUkFEX1NDQUxFL3JhZGl1cztcXG5cXFxyXG5cdFx0ICBpZihyYWRpdXM+PU1BWF9CTFVSX1NJWkUpXFxuXFxcclxuXHRcdFx0IHJldHVybiBjb2xvciAvIHRvdDtcXG5cXFxyXG5cdFx0IH1cXG5cXFxyXG5cdFx0IHJldHVybiBjb2xvciAvIHRvdDtcXG5cXFxyXG5cdFx0fVxcblxcXHJcblx0XHR2b2lkIG1haW4oKVxcblxcXHJcblx0XHR7XFxuXFxcclxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggZGVwdGhPZkZpZWxkKCB2X2Nvb3JkLCB1X2ZvY3VzX3BvaW50LCB1X2ZvY3VzX3NjYWxlICksIDEuMCApO1xcblxcXHJcblx0XHRcdC8vZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKHVfZGVwdGhfdGV4dHVyZSwgdl9jb29yZCkuciApO1xcblxcXHJcblx0XHR9XFxuXFxcclxuXHRcdFwiO1xyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImZ4L0RPRlwiLCBMR3JhcGhEZXB0aE9mRmllbGQgKTtcclxuXHRnbG9iYWwuTEdyYXBoRGVwdGhPZkZpZWxkID0gTEdyYXBoRGVwdGhPZkZpZWxkO1xyXG5cdCovXHJcblxyXG4gICAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgICAgICBmdW5jdGlvbiBMR3JhcGhGWEJva2VoKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCbHVycmVkXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIk1hc2tcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiVGhyZXNob2xkXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZTogXCJcIixcclxuICAgICAgICAgICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgICAgICAgICAgYWxwaGE6IDEuMCxcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMS4wLFxyXG4gICAgICAgICAgICAgICAgaGlnaF9wcmVjaXNpb246IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLnRpdGxlID0gXCJCb2tlaFwiO1xyXG4gICAgICAgIExHcmFwaEZYQm9rZWguZGVzYyA9IFwiYXBwbGllcyBhbiBCb2tlaCBlZmZlY3RcIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC53aWRnZXRzX2luZm8gPSB7IHNoYXBlOiB7IHdpZGdldDogXCJ0ZXh0dXJlXCIgfSB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICB2YXIgYmx1cnJlZF90ZXggPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgdmFyIG1hc2tfdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgICAgIGlmICghdGV4IHx8ICFtYXNrX3RleCB8fCAhdGhpcy5wcm9wZXJ0aWVzLnNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFibHVycmVkX3RleCkge1xyXG4gICAgICAgICAgICAgICAgYmx1cnJlZF90ZXggPSB0ZXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZV90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmUodGhpcy5wcm9wZXJ0aWVzLnNoYXBlKTtcclxuICAgICAgICAgICAgaWYgKCFzaGFwZV90ZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IHRoaXMucHJvcGVydGllcy50aHJlc2hvbGQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMykpIHtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMuZ2V0SW5wdXREYXRhKDMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnRocmVzaG9sZCA9IHRocmVzaG9sZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGdsLlVOU0lHTkVEX0JZVEU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGlnaF9wcmVjaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IGdsLmhhbGZfZmxvYXRfZXh0ID8gZ2wuSEFMRl9GTE9BVF9PRVMgOiBnbC5GTE9BVDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5fdGVtcF90ZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wX3RleHR1cmUudHlwZSAhPSBwcmVjaXNpb24gfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBfdGV4dHVyZS53aWR0aCAhPSB0ZXgud2lkdGggfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHByZWNpc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGdsLlJHQkEsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBnbC5MSU5FQVJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2l0ZXJhdGlvbnNcclxuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnByb3BlcnRpZXMuc2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmaXJzdF9zaGFkZXIgPSBMR3JhcGhGWEJva2VoLl9maXJzdF9zaGFkZXI7XHJcbiAgICAgICAgICAgIGlmICghZmlyc3Rfc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdF9zaGFkZXIgPSBMR3JhcGhGWEJva2VoLl9maXJzdF9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgICAgICAgICBMR3JhcGhGWEJva2VoLl9maXJzdF9waXhlbF9zaGFkZXJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRfc2hhZGVyID0gTEdyYXBoRlhCb2tlaC5fc2Vjb25kX3NoYWRlcjtcclxuICAgICAgICAgICAgaWYgKCFzZWNvbmRfc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmRfc2hhZGVyID0gTEdyYXBoRlhCb2tlaC5fc2Vjb25kX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgTEdyYXBoRlhCb2tlaC5fc2Vjb25kX3ZlcnRleF9zaGFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgTEdyYXBoRlhCb2tlaC5fc2Vjb25kX3BpeGVsX3NoYWRlclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBvaW50c19tZXNoID0gdGhpcy5fcG9pbnRzX21lc2g7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICFwb2ludHNfbWVzaCB8fFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzX21lc2guX3dpZHRoICE9IHRleC53aWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzX21lc2guX2hlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XHJcbiAgICAgICAgICAgICAgICBwb2ludHNfbWVzaC5fc3BhY2luZyAhPSAyXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzX21lc2ggPSB0aGlzLmNyZWF0ZVBvaW50c01lc2godGV4LndpZHRoLCB0ZXguaGVpZ2h0LCAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNjcmVlbl9tZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9pbnRfc2l6ZSA9IHRoaXMucHJvcGVydGllcy5zaXplO1xyXG4gICAgICAgICAgICB2YXIgbWluX2xpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzLm1pbl9saWdodDtcclxuICAgICAgICAgICAgdmFyIGFscGhhID0gdGhpcy5wcm9wZXJ0aWVzLmFscGhhO1xyXG5cclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGV4LmJpbmQoMCk7XHJcbiAgICAgICAgICAgICAgICBibHVycmVkX3RleC5iaW5kKDEpO1xyXG4gICAgICAgICAgICAgICAgbWFza190ZXguYmluZCgyKTtcclxuICAgICAgICAgICAgICAgIGZpcnN0X3NoYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC51bmlmb3Jtcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4dHVyZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXh0dXJlX2JsdXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfbWFzazogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXhzaXplOiBbdGV4LndpZHRoLCB0ZXguaGVpZ2h0XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRyYXcoc2NyZWVuX21lc2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NsZWFyIGJlY2F1c2Ugd2UgdXNlIGJsZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAvL2dsLmNsZWFyQ29sb3IoMC4wLDAuMCwwLjAsMS4wKTtcclxuICAgICAgICAgICAgICAgIC8vZ2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgKTtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRleC5iaW5kKDApO1xyXG4gICAgICAgICAgICAgICAgc2hhcGVfdGV4LmJpbmQoMyk7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmRfc2hhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnVuaWZvcm1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXh0dXJlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X21hc2s6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfc2hhcGU6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfYWxwaGE6IGFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RocmVzaG9sZDogdGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3BvaW50U2l6ZTogcG9pbnRfc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9pdGV4c2l6ZTogWzEuMCAvIHRleC53aWR0aCwgMS4wIC8gdGV4LmhlaWdodF1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5kcmF3KHBvaW50c19tZXNoLCBnbC5QT0lOVFMpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWgucHJvdG90eXBlLmNyZWF0ZVBvaW50c01lc2ggPSBmdW5jdGlvbihcclxuICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgICAgc3BhY2luZ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgbndpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAvIHNwYWNpbmcpO1xyXG4gICAgICAgICAgICB2YXIgbmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0IC8gc3BhY2luZyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KG53aWR0aCAqIG5oZWlnaHQgKiAyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBueSA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgZHggPSAoMiAvIHdpZHRoKSAqIHNwYWNpbmc7XHJcbiAgICAgICAgICAgIHZhciBkeSA9ICgyIC8gaGVpZ2h0KSAqIHNwYWNpbmc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbmhlaWdodDsgKyt5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnggPSAtMTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbndpZHRoOyArK3gpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0geSAqIG53aWR0aCAqIDIgKyB4ICogMjtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1twb3NdID0gbng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbcG9zICsgMV0gPSBueTtcclxuICAgICAgICAgICAgICAgICAgICBueCArPSBkeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG55ICs9IGR5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHNfbWVzaCA9IEdMLk1lc2gubG9hZCh7IHZlcnRpY2VzMkQ6IHZlcnRpY2VzIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHNfbWVzaC5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzX21lc2guX2hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzX21lc2guX3NwYWNpbmcgPSBzcGFjaW5nO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50c19tZXNoO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qXHJcblx0TEdyYXBoVGV4dHVyZUJva2VoLl9waXhlbF9zaGFkZXIgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgYV9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9zaGFwZTtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIGdsX1BvaW50Q29vcmQgKTtcXG5cXFxyXG5cdFx0XHRcdGNvbG9yICo9IHZfY29sb3IgKiB1X2FscGhhO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cdCovXHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWguX2ZpcnN0X3BpeGVsX3NoYWRlciA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlX2JsdXI7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9tYXNrO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgYmx1cnJlZF9jb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmVfYmx1ciwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBtYXNrID0gdGV4dHVyZTJEKHVfbWFzaywgdl9jb29yZCkueDtcXG5cXFxyXG5cdFx0XHQgICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IsIGJsdXJyZWRfY29sb3IsIG1hc2spO1xcblxcXHJcblx0XHRcdH1cXG5cXFxyXG5cdFx0XHRcIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC5fc2Vjb25kX3ZlcnRleF9zaGFkZXIgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleDJEO1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X21hc2s7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfaXRleHNpemU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3BvaW50U2l6ZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdGhyZXNob2xkO1xcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzIgY29vcmQgPSBhX3ZlcnRleDJEICogMC41ICsgMC41O1xcblxcXHJcblx0XHRcdFx0dl9jb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCBjb29yZCApO1xcblxcXHJcblx0XHRcdFx0dl9jb2xvciArPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgY29vcmQgKyB2ZWMyKHVfaXRleHNpemUueCwgMC4wKSApO1xcblxcXHJcblx0XHRcdFx0dl9jb2xvciArPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgY29vcmQgKyB2ZWMyKDAuMCwgdV9pdGV4c2l6ZS55KSk7XFxuXFxcclxuXHRcdFx0XHR2X2NvbG9yICs9IHRleHR1cmUyRCggdV90ZXh0dXJlLCBjb29yZCArIHVfaXRleHNpemUpO1xcblxcXHJcblx0XHRcdFx0dl9jb2xvciAqPSAwLjI1O1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgbWFzayA9IHRleHR1cmUyRCh1X21hc2ssIGNvb3JkKS54O1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgbHVtaW5hbmNlID0gbGVuZ3RoKHZfY29sb3IpICogbWFzaztcXG5cXFxyXG5cdFx0XHRcdC8qbHVtaW5hbmNlIC89ICh1X3BvaW50U2l6ZSp1X3BvaW50U2l6ZSkqMC4wMSAqLztcXG5cXFxyXG5cdFx0XHRcdGx1bWluYW5jZSAtPSB1X3RocmVzaG9sZDtcXG5cXFxyXG5cdFx0XHRcdGlmKGx1bWluYW5jZSA8IDAuMClcXG5cXFxyXG5cdFx0XHRcdHtcXG5cXFxyXG5cdFx0XHRcdFx0Z2xfUG9zaXRpb24ueCA9IC0xMDAuMDtcXG5cXFxyXG5cdFx0XHRcdFx0cmV0dXJuO1xcblxcXHJcblx0XHRcdFx0fVxcblxcXHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gdV9wb2ludFNpemU7XFxuXFxcclxuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoYV92ZXJ0ZXgyRCwwLjAsMS4wKTtcXG5cXFxyXG5cdFx0XHR9XFxuXFxcclxuXHRcdFx0XCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWguX3NlY29uZF9waXhlbF9zaGFkZXIgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3NoYXBlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9hbHBoYTtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3NoYXBlLCBnbF9Qb2ludENvb3JkICk7XFxuXFxcclxuXHRcdFx0XHRjb2xvciAqPSB2X2NvbG9yICogdV9hbHBoYTtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJmeC9ib2tlaFwiLCBMR3JhcGhGWEJva2VoKTtcclxuICAgICAgICBnbG9iYWwuTEdyYXBoRlhCb2tlaCA9IExHcmFwaEZYQm9rZWg7XHJcblxyXG4gICAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIExHcmFwaEZYR2VuZXJpYygpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwidmFsdWUxXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwidmFsdWUyXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBmeDogXCJoYWxmdG9uZVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUxOiAxLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUyOiAxLFxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy50aXRsZSA9IFwiRlhcIjtcclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMuZGVzYyA9IFwiYXBwbGllcyBhbiBGWCBmcm9tIGEgbGlzdFwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMud2lkZ2V0c19pbmZvID0ge1xyXG4gICAgICAgICAgICBmeDoge1xyXG4gICAgICAgICAgICAgICAgd2lkZ2V0OiBcImNvbWJvXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcImhhbGZ0b25lXCIsIFwicGl4ZWxhdGVcIiwgXCJsb3dwYWxldHRlXCIsIFwibm9pc2VcIiwgXCJnYW1tYVwiXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMuc2hhZGVycyA9IHt9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSAvL3NhdmVzIHdvcmtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0ZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxyXG4gICAgICAgICAgICAgICAgdGV4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy9pdGVyYXRpb25zXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTEgPSB0aGlzLnByb3BlcnRpZXMudmFsdWUxO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTEgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTEgPSB2YWx1ZTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTIgPSB0aGlzLnByb3BlcnRpZXMudmFsdWUyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTIgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTIgPSB2YWx1ZTI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmeCA9IHRoaXMucHJvcGVydGllcy5meDtcclxuICAgICAgICAgICAgdmFyIHNoYWRlciA9IExHcmFwaEZYR2VuZXJpYy5zaGFkZXJzW2Z4XTtcclxuICAgICAgICAgICAgaWYgKCFzaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbF9zaGFkZXJfY29kZSA9IExHcmFwaEZYR2VuZXJpY1tcInBpeGVsX3NoYWRlcl9cIiArIGZ4XTtcclxuICAgICAgICAgICAgICAgIGlmICghcGl4ZWxfc2hhZGVyX2NvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gTEdyYXBoRlhHZW5lcmljLnNoYWRlcnNbZnhdID0gbmV3IEdMLlNoYWRlcihcclxuICAgICAgICAgICAgICAgICAgICBTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxfc2hhZGVyX2NvZGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICB2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xyXG4gICAgICAgICAgICB2YXIgY2FtZXJhID0gZ2xvYmFsLkxTID8gTFMuUmVuZGVyZXIuX2N1cnJlbnRfY2FtZXJhIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNhbWVyYV9wbGFuZXM7XHJcbiAgICAgICAgICAgIGlmIChjYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIGNhbWVyYV9wbGFuZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgTFMuUmVuZGVyZXIuX2N1cnJlbnRfY2FtZXJhLm5lYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgTFMuUmVuZGVyZXIuX2N1cnJlbnRfY2FtZXJhLmZhclxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbWVyYV9wbGFuZXMgPSBbMSwgMTAwXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5vaXNlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGZ4ID09IFwibm9pc2VcIikge1xyXG4gICAgICAgICAgICAgICAgbm9pc2UgPSBMR3JhcGhUZXh0dXJlLmdldE5vaXNlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGV4LmJpbmQoMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnggPT0gXCJub2lzZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9pc2UuYmluZCgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICAudW5pZm9ybXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHR1cmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfbm9pc2U6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfc2l6ZTogW3RleC53aWR0aCwgdGV4LmhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfcmFuZDogW01hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3ZhbHVlMTogdmFsdWUxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3ZhbHVlMjogdmFsdWUyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2NhbWVyYV9wbGFuZXM6IGNhbWVyYV9wbGFuZXNcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5kcmF3KG1lc2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5waXhlbF9zaGFkZXJfaGFsZnRvbmUgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfY2FtZXJhX3BsYW5lcztcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9zaXplO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMjtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHRmbG9hdCBwYXR0ZXJuKCkge1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgcyA9IHNpbih1X3ZhbHVlMSAqIDMuMTQxNSksIGMgPSBjb3ModV92YWx1ZTEgKiAzLjE0MTUpO1xcblxcXHJcblx0XHRcdFx0dmVjMiB0ZXggPSB2X2Nvb3JkICogdV9zaXplLnh5O1xcblxcXHJcblx0XHRcdFx0dmVjMiBwb2ludCA9IHZlYzIoXFxuXFxcclxuXHRcdFx0XHQgICBjICogdGV4LnggLSBzICogdGV4LnkgLFxcblxcXHJcblx0XHRcdFx0ICAgcyAqIHRleC54ICsgYyAqIHRleC55IFxcblxcXHJcblx0XHRcdFx0KSAqIHVfdmFsdWUyO1xcblxcXHJcblx0XHRcdFx0cmV0dXJuIChzaW4ocG9pbnQueCkgKiBzaW4ocG9pbnQueSkpICogNC4wO1xcblxcXHJcblx0XHRcdH1cXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoYXZlcmFnZSAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkpLCBjb2xvci5hKTtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5waXhlbF9zaGFkZXJfcGl4ZWxhdGUgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfY2FtZXJhX3BsYW5lcztcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9zaXplO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMjtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWMyIGNvb3JkID0gdmVjMiggZmxvb3Iodl9jb29yZC54ICogdV92YWx1ZTEpIC8gdV92YWx1ZTEsIGZsb29yKHZfY29vcmQueSAqIHVfdmFsdWUyKSAvIHVfdmFsdWUyICk7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgY29vcmQpO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMucGl4ZWxfc2hhZGVyX2xvd3BhbGV0dGUgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfY2FtZXJhX3BsYW5lcztcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9zaXplO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMjtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBmbG9vcihjb2xvciAqIHVfdmFsdWUxKSAvIHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnBpeGVsX3NoYWRlcl9ub2lzZSA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X25vaXNlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X3NpemU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUyO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X3JhbmQ7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0dmVjMyBub2lzZSA9IHRleHR1cmUyRCh1X25vaXNlLCB2X2Nvb3JkICogdmVjMih1X3NpemUueCAvIDUxMi4wLCB1X3NpemUueSAvIDUxMi4wKSArIHVfcmFuZCkueHl6IC0gdmVjMygwLjUpO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IueHl6ICsgbm9pc2UgKiB1X3ZhbHVlMSwgY29sb3IuYSApO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnBpeGVsX3NoYWRlcl9nYW1tYSA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IGdhbW1hID0gMS4wIC8gdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwb3coIGNvbG9yLnh5eiwgdmVjMyhnYW1tYSkgKSwgY29sb3IuYSApO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJmeC9nZW5lcmljXCIsIExHcmFwaEZYR2VuZXJpYyk7XHJcbiAgICAgICAgZ2xvYmFsLkxHcmFwaEZYR2VuZXJpYyA9IExHcmFwaEZYR2VuZXJpYztcclxuXHJcbiAgICAgICAgLy8gVmlnbmV0aW5nICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgICAgICBmdW5jdGlvbiBMR3JhcGhGWFZpZ25ldGluZygpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIlRleC5cIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiaW50ZW5zaXR5XCIsIFwibnVtYmVyXCIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICAgICAgaW50ZW5zaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgaW52ZXJ0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIUxHcmFwaEZYVmlnbmV0aW5nLl9zaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy5waXhlbF9zaGFkZXJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLnRpdGxlID0gXCJWaWduZXRpbmdcIjtcclxuICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy5kZXNjID0gXCJWaWduZXRpbmdcIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcud2lkZ2V0c19pbmZvID0ge1xyXG4gICAgICAgICAgICBwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICB0ZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZW5zaXR5ID0gdGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgxKSkge1xyXG4gICAgICAgICAgICAgICAgaW50ZW5zaXR5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBMR3JhcGhGWFZpZ25ldGluZy5fc2hhZGVyO1xyXG4gICAgICAgICAgICB2YXIgaW52ZXJ0ID0gdGhpcy5wcm9wZXJ0aWVzLmludmVydDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXguYmluZCgwKTtcclxuICAgICAgICAgICAgICAgIHNoYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC51bmlmb3Jtcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4dHVyZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9pbnRlbnNpdHk6IGludGVuc2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9pc2l6ZTogWzEgLyB0ZXgud2lkdGgsIDEgLyB0ZXguaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9pbnZlcnQ6IGludmVydCA/IDEgOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZHJhdyhtZXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy5waXhlbF9zaGFkZXIgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBpbnQgdV9pbnZlcnQ7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgbHVtaW5hbmNlID0gMS4wIC0gbGVuZ3RoKCB2X2Nvb3JkIC0gdmVjMigwLjUpICkgKiAxLjQxNDtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdGlmKHVfaW52ZXJ0ID09IDEpXFxuXFxcclxuXHRcdFx0XHRcdGx1bWluYW5jZSA9IDEuMCAtIGx1bWluYW5jZTtcXG5cXFxyXG5cdFx0XHRcdGx1bWluYW5jZSA9IG1peCgxLjAsIGx1bWluYW5jZSwgdV9pbnRlbnNpdHkpO1xcblxcXHJcblx0XHRcdCAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGx1bWluYW5jZSAqIGNvbG9yLnh5eiwgY29sb3IuYSk7XFxuXFxcclxuXHRcdFx0fVxcblxcXHJcblx0XHRcdFwiO1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImZ4L3ZpZ25ldGluZ1wiLCBMR3JhcGhGWFZpZ25ldGluZyk7XHJcbiAgICAgICAgZ2xvYmFsLkxHcmFwaEZYVmlnbmV0aW5nID0gTEdyYXBoRlhWaWduZXRpbmc7XHJcbiAgICB9XHJcbn0pKHRoaXMpO1xyXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG4gICAgdmFyIE1JRElfQ09MT1IgPSBcIiMyNDNcIjtcclxuXHJcbiAgICBmdW5jdGlvbiBNSURJRXZlbnQoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IDA7XHJcbiAgICAgICAgdGhpcy5jbWQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MzJBcnJheSgzKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXR1cChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLk1JRElFdmVudCA9IE1JRElFdmVudDtcclxuXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24obykge1xyXG4gICAgICAgIHRoaXMuc2V0dXAoby5kYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB2YXIgcmF3X2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIGlmIChkYXRhLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgcmF3X2RhdGEgPSBkYXRhLmRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRhdGEuc2V0KHJhd19kYXRhKTtcclxuXHJcbiAgICAgICAgdmFyIG1pZGlTdGF0dXMgPSByYXdfZGF0YVswXTtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IG1pZGlTdGF0dXM7XHJcblxyXG4gICAgICAgIHZhciBtaWRpQ29tbWFuZCA9IG1pZGlTdGF0dXMgJiAweGYwO1xyXG5cclxuICAgICAgICBpZiAobWlkaVN0YXR1cyA+PSAweGYwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY21kID0gbWlkaVN0YXR1cztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNtZCA9IG1pZGlDb21tYW5kO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY21kID09IE1JRElFdmVudC5OT1RFT04gJiYgdGhpcy52ZWxvY2l0eSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY21kID0gTUlESUV2ZW50Lk5PVEVPRkY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNtZF9zdHIgPSBNSURJRXZlbnQuY29tbWFuZHNbdGhpcy5jbWRdIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgbWlkaUNvbW1hbmQgPj0gTUlESUV2ZW50Lk5PVEVPTiB8fFxyXG4gICAgICAgICAgICBtaWRpQ29tbWFuZCA8PSBNSURJRXZlbnQuTk9URU9GRlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwgPSBtaWRpU3RhdHVzICYgMHgwZjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNSURJRXZlbnQucHJvdG90eXBlLCBcInZlbG9jaXR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzJdID0gdjsgLy8gIHYgLyAxMjc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICBNSURJRXZlbnQubm90ZXMgPSBbXHJcbiAgICAgICAgXCJBXCIsXHJcbiAgICAgICAgXCJBI1wiLFxyXG4gICAgICAgIFwiQlwiLFxyXG4gICAgICAgIFwiQ1wiLFxyXG4gICAgICAgIFwiQyNcIixcclxuICAgICAgICBcIkRcIixcclxuICAgICAgICBcIkQjXCIsXHJcbiAgICAgICAgXCJFXCIsXHJcbiAgICAgICAgXCJGXCIsXHJcbiAgICAgICAgXCJGI1wiLFxyXG4gICAgICAgIFwiR1wiLFxyXG4gICAgICAgIFwiRyNcIlxyXG4gICAgXTtcclxuICAgIE1JRElFdmVudC5ub3RlX3RvX2luZGV4ID0ge1xyXG4gICAgICAgIEE6IDAsXHJcbiAgICAgICAgXCJBI1wiOiAxLFxyXG4gICAgICAgIEI6IDIsXHJcbiAgICAgICAgQzogMyxcclxuICAgICAgICBcIkMjXCI6IDQsXHJcbiAgICAgICAgRDogNSxcclxuICAgICAgICBcIkQjXCI6IDYsXHJcbiAgICAgICAgRTogNyxcclxuICAgICAgICBGOiA4LFxyXG4gICAgICAgIFwiRiNcIjogOSxcclxuICAgICAgICBHOiAxMCxcclxuICAgICAgICBcIkcjXCI6IDExXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNSURJRXZlbnQucHJvdG90eXBlLCBcIm5vdGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNtZCAhPSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC50b05vdGVTdHJpbmcodGhpcy5kYXRhWzFdLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICB0aHJvdyBcIm5vdGVzIGNhbm5vdCBiZSBhc3NpZ25lZCB0aGlzIHdheSwgbXVzdCBtb2RpZnkgdGhlIGRhdGFbMV1cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNSURJRXZlbnQucHJvdG90eXBlLCBcIm9jdGF2ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY21kICE9IE1JRElFdmVudC5OT1RFT04pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb2N0YXZlID0gdGhpcy5kYXRhWzFdIC0gMjQ7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG9jdGF2ZSAvIDEyICsgMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJvY3RhdmUgY2Fubm90IGJlIGFzc2lnbmVkIHRoaXMgd2F5LCBtdXN0IG1vZGlmeSB0aGUgZGF0YVsxXVwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy9yZXR1cm5zIEhac1xyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5nZXRQaXRjaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAodGhpcy5kYXRhWzFdIC0gNjkpIC8gMTIpICogNDQwO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQuY29tcHV0ZVBpdGNoID0gZnVuY3Rpb24obm90ZSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAobm90ZSAtIDY5KSAvIDEyKSAqIDQ0MDtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5nZXRDQyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMV07XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuZ2V0Q0NWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMl07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vbm90IHRlc3RlZCwgdGhlcmUgaXMgYSBmb3JtdWxhIG1pc3NpbmcgaGVyZVxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5nZXRQaXRjaEJlbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzFdICsgKHRoaXMuZGF0YVsyXSA8PCA3KSAtIDgxOTI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21wdXRlUGl0Y2hCZW5kID0gZnVuY3Rpb24odjEsIHYyKSB7XHJcbiAgICAgICAgcmV0dXJuIHYxICsgKHYyIDw8IDcpIC0gODE5MjtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5zZXRDb21tYW5kRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHRoaXMuY21kID0gTUlESUV2ZW50LmNvbXB1dGVDb21tYW5kRnJvbVN0cmluZyhzdHIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQuY29tcHV0ZUNvbW1hbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgaWYgKCFzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RyICYmIHN0ci5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICBzd2l0Y2ggKHN0cikge1xyXG4gICAgICAgICAgICBjYXNlIFwiTk9URSBPTlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiTk9URU9OXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50Lk5PVEVPTjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiTk9URSBPRkZcIjpcclxuICAgICAgICAgICAgY2FzZSBcIk5PVEVPRkZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuTk9URU9OO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJLRVkgUFJFU1NVUkVcIjpcclxuICAgICAgICAgICAgY2FzZSBcIktFWVBSRVNTVVJFXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LktFWVBSRVNTVVJFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJDT05UUk9MTEVSIENIQU5HRVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiQ09OVFJPTExFUkNIQU5HRVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiQ0NcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuQ09OVFJPTExFUkNIQU5HRTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiUFJPR1JBTSBDSEFOR0VcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlBST0dSQU1DSEFOR0VcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlBDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LlBST0dSQU1DSEFOR0U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIkNIQU5ORUwgUFJFU1NVUkVcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkNIQU5ORUxQUkVTU1VSRVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5DSEFOTkVMUFJFU1NVUkU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlBJVENIIEJFTkRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlBJVENIQkVORFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5QSVRDSEJFTkQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlRJTUUgVElDS1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiVElNRVRJQ0tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuVElNRVRJQ0s7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoc3RyKTsgLy9hc3VtZSBpdHMgYSBoZXggY29kZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy90cmFuc2Zvcm0gZnJvbSBhIHBpdGNoIG51bWJlciB0byBzdHJpbmcgbGlrZSBcIkM0XCJcclxuICAgIE1JRElFdmVudC50b05vdGVTdHJpbmcgPSBmdW5jdGlvbihkLCBza2lwX29jdGF2ZSkge1xyXG4gICAgICAgIGQgPSBNYXRoLnJvdW5kKGQpOyAvL2luIGNhc2UgaXQgaGFzIGRlY2ltYWxzXHJcbiAgICAgICAgdmFyIG5vdGUgPSBkIC0gMjE7XHJcbiAgICAgICAgdmFyIG9jdGF2ZSA9IE1hdGguZmxvb3IoKGQgLSAyNCkgLyAxMiArIDEpO1xyXG4gICAgICAgIG5vdGUgPSBub3RlICUgMTI7XHJcbiAgICAgICAgaWYgKG5vdGUgPCAwKSB7XHJcbiAgICAgICAgICAgIG5vdGUgPSAxMiArIG5vdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNSURJRXZlbnQubm90ZXNbbm90ZV0gKyAoc2tpcF9vY3RhdmUgPyBcIlwiIDogb2N0YXZlKTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50Lk5vdGVTdHJpbmdUb1BpdGNoID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgdmFyIG5vdGUgPSBzdHJbMF07XHJcbiAgICAgICAgdmFyIG9jdGF2ZSA9IDQ7XHJcblxyXG4gICAgICAgIGlmIChzdHJbMV0gPT0gXCIjXCIpIHtcclxuICAgICAgICAgICAgbm90ZSArPSBcIiNcIjtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICBvY3RhdmUgPSBOdW1iZXIoc3RyWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgb2N0YXZlID0gTnVtYmVyKHN0clsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBpdGNoID0gTUlESUV2ZW50Lm5vdGVfdG9faW5kZXhbbm90ZV07XHJcbiAgICAgICAgaWYgKHBpdGNoID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAob2N0YXZlIC0gMSkgKiAxMiArIHBpdGNoICsgMjE7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RyID0gXCJcIiArIHRoaXMuY2hhbm5lbCArIFwiLiBcIjtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuY21kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50Lk5PVEVPTjpcclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIk5PVEVPTiBcIiArIE1JRElFdmVudC50b05vdGVTdHJpbmcodGhpcy5kYXRhWzFdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5OT1RFT0ZGOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiTk9URU9GRiBcIiArIE1JRElFdmVudC50b05vdGVTdHJpbmcodGhpcy5kYXRhWzFdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5DT05UUk9MTEVSQ0hBTkdFOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiQ0MgXCIgKyB0aGlzLmRhdGFbMV0gKyBcIiBcIiArIHRoaXMuZGF0YVsyXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5QUk9HUkFNQ0hBTkdFOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiUEMgXCIgKyB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNSURJRXZlbnQuUElUQ0hCRU5EOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiUElUQ0hCRU5EIFwiICsgdGhpcy5nZXRQaXRjaEJlbmQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5LRVlQUkVTU1VSRTpcclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIktFWVBSRVNTIFwiICsgdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3RyICs9IHRoaXMuZGF0YVtpXS50b1N0cmluZygxNikgKyBcIiBcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogW3RoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl1dLFxyXG4gICAgICAgICAgICBvYmplY3RfY2xhc3M6IFwiTUlESUV2ZW50XCJcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQuTk9URU9GRiA9IDB4ODA7XHJcbiAgICBNSURJRXZlbnQuTk9URU9OID0gMHg5MDtcclxuICAgIE1JRElFdmVudC5LRVlQUkVTU1VSRSA9IDB4YTA7XHJcbiAgICBNSURJRXZlbnQuQ09OVFJPTExFUkNIQU5HRSA9IDB4YjA7XHJcbiAgICBNSURJRXZlbnQuUFJPR1JBTUNIQU5HRSA9IDB4YzA7XHJcbiAgICBNSURJRXZlbnQuQ0hBTk5FTFBSRVNTVVJFID0gMHhkMDtcclxuICAgIE1JRElFdmVudC5QSVRDSEJFTkQgPSAweGUwO1xyXG4gICAgTUlESUV2ZW50LlRJTUVUSUNLID0gMHhmODtcclxuXHJcbiAgICBNSURJRXZlbnQuY29tbWFuZHMgPSB7XHJcbiAgICAgICAgMHg4MDogXCJub3RlIG9mZlwiLFxyXG4gICAgICAgIDB4OTA6IFwibm90ZSBvblwiLFxyXG4gICAgICAgIDB4YTA6IFwia2V5IHByZXNzdXJlXCIsXHJcbiAgICAgICAgMHhiMDogXCJjb250cm9sbGVyIGNoYW5nZVwiLFxyXG4gICAgICAgIDB4YzA6IFwicHJvZ3JhbSBjaGFuZ2VcIixcclxuICAgICAgICAweGQwOiBcImNoYW5uZWwgcHJlc3N1cmVcIixcclxuICAgICAgICAweGUwOiBcInBpdGNoIGJlbmRcIixcclxuICAgICAgICAweGYwOiBcInN5c3RlbVwiLFxyXG4gICAgICAgIDB4ZjI6IFwiU29uZyBwb3NcIixcclxuICAgICAgICAweGYzOiBcIlNvbmcgc2VsZWN0XCIsXHJcbiAgICAgICAgMHhmNjogXCJUdW5lIHJlcXVlc3RcIixcclxuICAgICAgICAweGY4OiBcInRpbWUgdGlja1wiLFxyXG4gICAgICAgIDB4ZmE6IFwiU3RhcnQgU29uZ1wiLFxyXG4gICAgICAgIDB4ZmI6IFwiQ29udGludWUgU29uZ1wiLFxyXG4gICAgICAgIDB4ZmM6IFwiU3RvcCBTb25nXCIsXHJcbiAgICAgICAgMHhmZTogXCJTZW5zaW5nXCIsXHJcbiAgICAgICAgMHhmZjogXCJSZXNldFwiXHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21tYW5kc19zaG9ydCA9IHtcclxuICAgICAgICAweDgwOiBcIk5PVEVPRkZcIixcclxuICAgICAgICAweDkwOiBcIk5PVEVPRkZcIixcclxuICAgICAgICAweGEwOiBcIktFWVBcIixcclxuICAgICAgICAweGIwOiBcIkNDXCIsXHJcbiAgICAgICAgMHhjMDogXCJQQ1wiLFxyXG4gICAgICAgIDB4ZDA6IFwiQ1BcIixcclxuICAgICAgICAweGUwOiBcIlBCXCIsXHJcbiAgICAgICAgMHhmMDogXCJTWVNcIixcclxuICAgICAgICAweGYyOiBcIlBPU1wiLFxyXG4gICAgICAgIDB4ZjM6IFwiU0VMRUNUXCIsXHJcbiAgICAgICAgMHhmNjogXCJUVU5FUkVRXCIsXHJcbiAgICAgICAgMHhmODogXCJUVFwiLFxyXG4gICAgICAgIDB4ZmE6IFwiU1RBUlRcIixcclxuICAgICAgICAweGZiOiBcIkNPTlRJTlVFXCIsXHJcbiAgICAgICAgMHhmYzogXCJTVE9QXCIsXHJcbiAgICAgICAgMHhmZTogXCJTRU5TXCIsXHJcbiAgICAgICAgMHhmZjogXCJSRVNFVFwiXHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21tYW5kc19yZXZlcnNlZCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSBpbiBNSURJRXZlbnQuY29tbWFuZHMpIHtcclxuICAgICAgICBNSURJRXZlbnQuY29tbWFuZHNfcmV2ZXJzZWRbTUlESUV2ZW50LmNvbW1hbmRzW2ldXSA9IGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9NSURJIHdyYXBwZXIsIGluc3RhbnRpYXRlIGJ5IE1JRElJbiBhbmQgTUlESU91dFxyXG4gICAgZnVuY3Rpb24gTUlESUludGVyZmFjZShvbl9yZWFkeSwgb25fZXJyb3IpIHtcclxuICAgICAgICBpZiAoIW5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2Vzcykge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gXCJub3Qgc3VwcG9vcnRlZFwiO1xyXG4gICAgICAgICAgICBpZiAob25fZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uX2Vycm9yKFwiTm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNSURJIE5PVCBTVVBQT1JURUQsIGVuYWJsZSBieSBjaHJvbWU6Ly9mbGFnc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9uX3JlYWR5ID0gb25fcmVhZHk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIG5vdGU6IFtdLFxyXG4gICAgICAgICAgICBjYzogW11cclxuICAgICAgICB9O1xyXG5cclxuXHRcdHRoaXMuaW5wdXRfcG9ydHMgPSBudWxsO1xyXG5cdFx0dGhpcy5pbnB1dF9wb3J0c19pbmZvID0gW107XHJcblx0XHR0aGlzLm91dHB1dF9wb3J0cyA9IG51bGw7XHJcblx0XHR0aGlzLm91dHB1dF9wb3J0c19pbmZvID0gW107XHJcblxyXG4gICAgICAgIG5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2VzcygpLnRoZW4odGhpcy5vbk1JRElTdWNjZXNzLmJpbmQodGhpcyksIHRoaXMub25NSURJRmFpbHVyZS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLmlucHV0ID0gbnVsbDtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLk1JRElFdmVudCA9IE1JRElFdmVudDtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS5vbk1JRElTdWNjZXNzID0gZnVuY3Rpb24obWlkaUFjY2Vzcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTUlESSByZWFkeSFcIik7XHJcbiAgICAgICAgY29uc29sZS5sb2cobWlkaUFjY2Vzcyk7XHJcbiAgICAgICAgdGhpcy5taWRpID0gbWlkaUFjY2VzczsgLy8gc3RvcmUgaW4gdGhlIGdsb2JhbCAoaW4gcmVhbCB1c2FnZSwgd291bGQgcHJvYmFibHkga2VlcCBpbiBhbiBvYmplY3QgaW5zdGFuY2UpXHJcbiAgICAgICAgdGhpcy51cGRhdGVQb3J0cygpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vbl9yZWFkeSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uX3JlYWR5KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTUlESUludGVyZmFjZS5wcm90b3R5cGUudXBkYXRlUG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbWlkaSA9IHRoaXMubWlkaTtcclxuICAgICAgICB0aGlzLmlucHV0X3BvcnRzID0gbWlkaS5pbnB1dHM7XHJcblx0XHR0aGlzLmlucHV0X3BvcnRzX2luZm8gPSBbXTtcclxuICAgICAgICB0aGlzLm91dHB1dF9wb3J0cyA9IG1pZGkub3V0cHV0cztcclxuXHRcdHRoaXMub3V0cHV0X3BvcnRzX2luZm8gPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIG51bSA9IDA7XHJcblxyXG4gICAgICAgIHZhciBpdCA9IHRoaXMuaW5wdXRfcG9ydHMudmFsdWVzKCk7XHJcbiAgICAgICAgdmFyIGl0X3ZhbHVlID0gaXQubmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChpdF92YWx1ZSAmJiBpdF92YWx1ZS5kb25lID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB2YXIgcG9ydF9pbmZvID0gaXRfdmFsdWUudmFsdWU7XHJcblx0XHRcdHRoaXMuaW5wdXRfcG9ydHNfaW5mby5wdXNoKHBvcnRfaW5mbyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIklucHV0IHBvcnQgW3R5cGU6J1wiICsgcG9ydF9pbmZvLnR5cGUgKyBcIiddIGlkOidcIiArIHBvcnRfaW5mby5pZCArIFwiJyBtYW51ZmFjdHVyZXI6J1wiICsgcG9ydF9pbmZvLm1hbnVmYWN0dXJlciArIFwiJyBuYW1lOidcIiArIHBvcnRfaW5mby5uYW1lICsgXCInIHZlcnNpb246J1wiICsgcG9ydF9pbmZvLnZlcnNpb24gKyBcIidcIiApO1xyXG4gICAgICAgICAgICBudW0rKztcclxuICAgICAgICAgICAgaXRfdmFsdWUgPSBpdC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubnVtX2lucHV0X3BvcnRzID0gbnVtO1xyXG5cclxuICAgICAgICBudW0gPSAwO1xyXG4gICAgICAgIHZhciBpdCA9IHRoaXMub3V0cHV0X3BvcnRzLnZhbHVlcygpO1xyXG4gICAgICAgIHZhciBpdF92YWx1ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB3aGlsZSAoaXRfdmFsdWUgJiYgaXRfdmFsdWUuZG9uZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdmFyIHBvcnRfaW5mbyA9IGl0X3ZhbHVlLnZhbHVlO1xyXG5cdFx0XHR0aGlzLm91dHB1dF9wb3J0c19pbmZvLnB1c2gocG9ydF9pbmZvKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coIFwiT3V0cHV0IHBvcnQgW3R5cGU6J1wiICsgcG9ydF9pbmZvLnR5cGUgKyBcIiddIGlkOidcIiArIHBvcnRfaW5mby5pZCArIFwiJyBtYW51ZmFjdHVyZXI6J1wiICsgcG9ydF9pbmZvLm1hbnVmYWN0dXJlciArIFwiJyBuYW1lOidcIiArIHBvcnRfaW5mby5uYW1lICsgXCInIHZlcnNpb246J1wiICsgcG9ydF9pbmZvLnZlcnNpb24gKyBcIidcIiApO1xyXG4gICAgICAgICAgICBudW0rKztcclxuICAgICAgICAgICAgaXRfdmFsdWUgPSBpdC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubnVtX291dHB1dF9wb3J0cyA9IG51bTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUludGVyZmFjZS5wcm90b3R5cGUub25NSURJRmFpbHVyZSA9IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IE1JREkgYWNjZXNzIC0gXCIgKyBtc2cpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS5vcGVuSW5wdXRQb3J0ID0gZnVuY3Rpb24ocG9ydCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgaW5wdXRfcG9ydCA9IHRoaXMuaW5wdXRfcG9ydHMuZ2V0KFwiaW5wdXQtXCIgKyBwb3J0KTtcclxuICAgICAgICBpZiAoIWlucHV0X3BvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBNSURJSW50ZXJmYWNlLmlucHV0ID0gdGhpcztcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlucHV0X3BvcnQub25taWRpbWVzc2FnZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KGEuZGF0YSk7XHJcbiAgICAgICAgICAgIHRoYXQudXBkYXRlU3RhdGUobWlkaV9ldmVudCk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYS5kYXRhLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTUlESUludGVyZmFjZS5vbl9tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBNSURJSW50ZXJmYWNlLm9uX21lc3NhZ2UoYS5kYXRhLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJwb3J0IG9wZW46IFwiLCBpbnB1dF9wb3J0KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUludGVyZmFjZS5wYXJzZU1zZyA9IGZ1bmN0aW9uKGRhdGEpIHt9O1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UucHJvdG90eXBlLnVwZGF0ZVN0YXRlID0gZnVuY3Rpb24obWlkaV9ldmVudCkge1xyXG4gICAgICAgIHN3aXRjaCAobWlkaV9ldmVudC5jbWQpIHtcclxuICAgICAgICAgICAgY2FzZSBNSURJRXZlbnQuTk9URU9OOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5ub3RlW21pZGlfZXZlbnQudmFsdWUxIHwgMF0gPSBtaWRpX2V2ZW50LnZhbHVlMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5OT1RFT0ZGOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5ub3RlW21pZGlfZXZlbnQudmFsdWUxIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LkNPTlRST0xMRVJDSEFOR0U6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNjW21pZGlfZXZlbnQuZ2V0Q0MoKV0gPSBtaWRpX2V2ZW50LmdldENDVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTUlESUludGVyZmFjZS5wcm90b3R5cGUuc2VuZE1JREkgPSBmdW5jdGlvbihwb3J0LCBtaWRpX2RhdGEpIHtcclxuICAgICAgICBpZiAoIW1pZGlfZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb3V0cHV0X3BvcnQgPSB0aGlzLm91dHB1dF9wb3J0c19pbmZvW3BvcnRdOy8vdGhpcy5vdXRwdXRfcG9ydHMuZ2V0KFwib3V0cHV0LVwiICsgcG9ydCk7XHJcbiAgICAgICAgaWYgKCFvdXRwdXRfcG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNSURJSW50ZXJmYWNlLm91dHB1dCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChtaWRpX2RhdGEuY29uc3RydWN0b3IgPT09IE1JRElFdmVudCkge1xyXG4gICAgICAgICAgICBvdXRwdXRfcG9ydC5zZW5kKG1pZGlfZGF0YS5kYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRwdXRfcG9ydC5zZW5kKG1pZGlfZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElJbigpIHtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm1pZGlcIik7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBwb3J0OiAwIH07XHJcbiAgICAgICAgdGhpcy5fbGFzdF9taWRpX2V2ZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50X21pZGlfZXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBQUFcIjtcclxuICAgICAgICB0aGlzLl9sYXN0X3RpbWUgPSAwO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgbmV3IE1JRElJbnRlcmZhY2UoZnVuY3Rpb24obWlkaSkge1xyXG4gICAgICAgICAgICAvL29wZW5cclxuICAgICAgICAgICAgdGhhdC5fbWlkaSA9IG1pZGk7XHJcbiAgICAgICAgICAgIGlmICh0aGF0Ll93YWl0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm9uU3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Ll93YWl0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJSW4uTUlESUludGVyZmFjZSA9IE1JRElJbnRlcmZhY2U7XHJcblxyXG4gICAgTEdNSURJSW4udGl0bGUgPSBcIk1JREkgSW5wdXRcIjtcclxuICAgIExHTUlESUluLmRlc2MgPSBcIlJlYWRzIE1JREkgZnJvbSBhIGlucHV0IHBvcnRcIjtcclxuICAgIExHTUlESUluLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElJbi5wcm90b3R5cGUuZ2V0UHJvcGVydHlJbmZvID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWlkaSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSA9PSBcInBvcnRcIikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWlkaS5pbnB1dF9wb3J0c19pbmZvLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9taWRpLmlucHV0X3BvcnRzX2luZm9baV07XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSBpICsgXCIuLSBcIiArIGlucHV0Lm5hbWUgKyBcIiB2ZXJzaW9uOlwiICsgaW5wdXQudmVyc2lvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudW1cIiwgdmFsdWVzOiB2YWx1ZXMgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21pZGkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWlkaS5vcGVuSW5wdXRQb3J0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnBvcnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTUlESUV2ZW50LmJpbmQodGhpcylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vbk1JRElFdmVudCA9IGZ1bmN0aW9uKGRhdGEsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICB0aGlzLl9sYXN0X21pZGlfZXZlbnQgPSBtaWRpX2V2ZW50O1xyXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBRkFcIjtcclxuICAgICAgICB0aGlzLl9sYXN0X3RpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX21pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgaWYgKG1pZGlfZXZlbnQuY21kID09IE1JRElFdmVudC5OT1RFT04pIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fbm90ZW9uXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPRkYpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fbm90ZW9mZlwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1pZGlfZXZlbnQuY21kID09IE1JRElFdmVudC5DT05UUk9MTEVSQ0hBTkdFKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX2NjXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50LlBST0dSQU1DSEFOR0UpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fcGNcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuUElUQ0hCRU5EKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX3BpdGNoYmVuZFwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FBQVwiO1xyXG4gICAgICAgIGlmICghdGhpcy5mbGFncy5jb2xsYXBzZWQgJiYgdGhpcy5fbGFzdF9taWRpX2V2ZW50KSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB2YXIgZiA9IDEuMCAtIE1hdGgubWF4KDAsIChub3cgLSB0aGlzLl9sYXN0X3RpbWUpICogMC4wMDEpO1xyXG4gICAgICAgICAgICBpZiAoZiA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IGY7XHJcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IFwiMTJweCBUYWhvbWFcIjtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0X21pZGlfZXZlbnQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAqIDAuNSArIDNcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAvL2N0eC5maWxsUmVjdCgwLDAsdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSk7XHJcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElJbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuX2xhc3RfbWlkaV9ldmVudDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG91dHB1dC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pZGlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX21pZGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsYXN0X21pZGlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGxhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElJbi5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wibGFzdF9taWRpXCIsIFwibWlkaVwiXSxcclxuICAgICAgICAgICAgW1wib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJvbl9ub3Rlb25cIiwgTGl0ZUdyYXBoLkVWRU5UXSxcclxuICAgICAgICAgICAgW1wib25fbm90ZW9mZlwiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJvbl9jY1wiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJvbl9wY1wiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJvbl9waXRjaGJlbmRcIiwgTGl0ZUdyYXBoLkVWRU5UXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9pbnB1dFwiLCBMR01JRElJbik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJT3V0KCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzZW5kXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBwb3J0OiAwIH07XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBuZXcgTUlESUludGVyZmFjZShmdW5jdGlvbihtaWRpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX21pZGkgPSBtaWRpO1xyXG5cdFx0XHR0aGF0LndpZGdldC5vcHRpb25zLnZhbHVlcyA9IHRoYXQuZ2V0TUlESU91dHB1dHMoKTtcclxuICAgICAgICB9KTtcclxuXHRcdHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwiRGV2aWNlXCIsdGhpcy5wcm9wZXJ0aWVzLnBvcnQseyBwcm9wZXJ0eTogXCJwb3J0XCIsIHZhbHVlczogdGhpcy5nZXRNSURJT3V0cHV0cy5iaW5kKHRoaXMpIH0pO1xyXG5cdFx0dGhpcy5zaXplID0gWzM0MCw2MF07XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJT3V0Lk1JRElJbnRlcmZhY2UgPSBNSURJSW50ZXJmYWNlO1xyXG5cclxuICAgIExHTUlESU91dC50aXRsZSA9IFwiTUlESSBPdXRwdXRcIjtcclxuICAgIExHTUlESU91dC5kZXNjID0gXCJTZW5kcyBNSURJIHRvIG91dHB1dCBjaGFubmVsXCI7XHJcbiAgICBMR01JRElPdXQuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESU91dC5wcm90b3R5cGUub25HZXRQcm9wZXJ0eUluZm8gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taWRpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09IFwicG9ydFwiKSB7XHJcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldE1JRElPdXRwdXRzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW51bVwiLCB2YWx1ZXM6IHZhbHVlcyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblx0TEdNSURJT3V0LmRlZmF1bHRfcG9ydHMgPSB7MDpcInVua25vd25cIn07XHJcblxyXG5cdExHTUlESU91dC5wcm90b3R5cGUuZ2V0TUlESU91dHB1dHMgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xyXG5cdFx0aWYoIXRoaXMuX21pZGkpXHJcblx0XHRcdHJldHVybiBMR01JRElPdXQuZGVmYXVsdF9wb3J0cztcclxuXHRcdGlmKHRoaXMuX21pZGkub3V0cHV0X3BvcnRzX2luZm8pXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21pZGkub3V0cHV0X3BvcnRzX2luZm8ubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0dmFyIG91dHB1dCA9IHRoaXMuX21pZGkub3V0cHV0X3BvcnRzX2luZm9baV07XHJcblx0XHRcdGlmKCFvdXRwdXQpXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHZhciBuYW1lID0gaSArIFwiLi0gXCIgKyBvdXRwdXQubmFtZSArIFwiIHZlcnNpb246XCIgKyBvdXRwdXQudmVyc2lvbjtcclxuXHRcdFx0dmFsdWVzW2ldID0gbmFtZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fVxyXG5cclxuICAgIExHTUlESU91dC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2cobWlkaV9ldmVudCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taWRpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50ID09IFwic2VuZFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21pZGkuc2VuZE1JREkodGhpcy5wcm9wZXJ0aWVzLnBvcnQsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJtaWRpXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElPdXQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJzZW5kXCIsIExpdGVHcmFwaC5BQ1RJT05dXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJT3V0LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9vdXRwdXRcIiwgTEdNSURJT3V0KTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJU2hvdygpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuX3N0ciA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzIwMCwgNDBdO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESVNob3cudGl0bGUgPSBcIk1JREkgU2hvd1wiO1xyXG4gICAgTEdNSURJU2hvdy5kZXNjID0gXCJTaG93cyBNSURJIGluIHRoZSBncmFwaFwiO1xyXG4gICAgTEdNSURJU2hvdy5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVNob3cucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICBpZiAoIW1pZGlfZXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWlkaV9ldmVudC5jb25zdHJ1Y3RvciA9PT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ciA9IG1pZGlfZXZlbnQudG9TdHJpbmcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHIgPSBcIj8/P1wiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RyIHx8IHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN0eC5mb250ID0gXCIzMHB4IEFyaWFsXCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuX3N0ciwgMTAsIHRoaXMuc2l6ZVsxXSAqIDAuOCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVNob3cucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJpblwiLCBMaXRlR3JhcGguQUNUSU9OXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVNob3cucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlRdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL3Nob3dcIiwgTEdNSURJU2hvdyk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJRmlsdGVyKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgY2hhbm5lbDogLTEsXHJcbiAgICAgICAgICAgIGNtZDogLTEsXHJcbiAgICAgICAgICAgIG1pbl92YWx1ZTogLTEsXHJcbiAgICAgICAgICAgIG1heF92YWx1ZTogLTFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGVhcm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLCBcIkxlYXJuXCIsIFwiXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0Ll9sZWFybmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiNGQTNcIjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FBQVwiO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESUZpbHRlci50aXRsZSA9IFwiTUlESSBGaWx0ZXJcIjtcclxuICAgIExHTUlESUZpbHRlci5kZXNjID0gXCJGaWx0ZXJzIE1JREkgbWVzc2FnZXNcIjtcclxuICAgIExHTUlESUZpbHRlci5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJRmlsdGVyW1wiQGNtZFwiXSA9IHtcclxuICAgICAgICB0eXBlOiBcImVudW1cIixcclxuICAgICAgICB0aXRsZTogXCJDb21tYW5kXCIsXHJcbiAgICAgICAgdmFsdWVzOiBNSURJRXZlbnQuY29tbWFuZHNfcmV2ZXJzZWRcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJRmlsdGVyLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzdHIgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY21kID09IC0xKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IFwiTm90aGluZ1wiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ciA9IE1JRElFdmVudC5jb21tYW5kc19zaG9ydFt0aGlzLnByb3BlcnRpZXMuY21kXSB8fCBcIlVua25vd25cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSAhPSAtMSAmJlxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlICE9IC0xXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHN0ciArPVxyXG4gICAgICAgICAgICAgICAgXCIgXCIgK1xyXG4gICAgICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5taW5fdmFsdWUgPT0gdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSArXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIi4uXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1heF92YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gXCJGaWx0ZXI6IFwiICsgc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElGaWx0ZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImNtZFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkge1xyXG4gICAgICAgICAgICAgICAgbnVtID0gTUlESUV2ZW50LmNvbW1hbmRzW3ZhbHVlXSB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jbWQgPSBudW07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElGaWx0ZXIucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICBpZiAoIW1pZGlfZXZlbnQgfHwgbWlkaV9ldmVudC5jb25zdHJ1Y3RvciAhPT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9sZWFybmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWFybmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUFBXCI7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsID0gbWlkaV9ldmVudC5jaGFubmVsO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY21kID0gbWlkaV9ldmVudC5jbWQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW5fdmFsdWUgPSB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlID1cclxuICAgICAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVsxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbCAhPSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5jaGFubmVsICE9IHRoaXMucHJvcGVydGllcy5jaGFubmVsXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jbWQgIT0gLTEgJiZcclxuICAgICAgICAgICAgICAgIG1pZGlfZXZlbnQuY21kICE9IHRoaXMucHJvcGVydGllcy5jbWRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSAhPSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzFdIDwgdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlICE9IC0xICYmXHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMV0gPiB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9taWRpXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvZmlsdGVyXCIsIExHTUlESUZpbHRlcik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBjaGFubmVsOiAwLFxyXG4gICAgICAgICAgICBjbWQ6IDE0NCwgLy8weDkwXHJcbiAgICAgICAgICAgIHZhbHVlMTogMSxcclxuICAgICAgICAgICAgdmFsdWUyOiAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNlbmRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiYXNzaWduXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblxyXG4gICAgICAgIHRoaXMubWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICB0aGlzLmdhdGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElFdmVudC50aXRsZSA9IFwiTUlESUV2ZW50XCI7XHJcbiAgICBMR01JRElFdmVudC5kZXNjID0gXCJDcmVhdGUgYSBNSURJIEV2ZW50XCI7XHJcbiAgICBMR01JRElFdmVudC5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJRXZlbnQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJhc3NpZ25cIikge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbCA9IG1pZGlfZXZlbnQuY2hhbm5lbDtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCA9IG1pZGlfZXZlbnQuY21kO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUxID0gbWlkaV9ldmVudC5kYXRhWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUyID0gbWlkaV9ldmVudC5kYXRhWzJdO1xyXG4gICAgICAgICAgICBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuTk9URU9GRikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZW5kXHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSB0aGlzLm1pZGlfZXZlbnQ7XHJcbiAgICAgICAgbWlkaV9ldmVudC5jaGFubmVsID0gdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWw7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jbWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmNtZC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIG1pZGlfZXZlbnQuc2V0Q29tbWFuZEZyb21TdHJpbmcodGhpcy5wcm9wZXJ0aWVzLmNtZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5jbWQgPSB0aGlzLnByb3BlcnRpZXMuY21kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMF0gPSBtaWRpX2V2ZW50LmNtZCB8IG1pZGlfZXZlbnQuY2hhbm5lbDtcclxuICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMV0gPSBOdW1iZXIodGhpcy5wcm9wZXJ0aWVzLnZhbHVlMSk7XHJcbiAgICAgICAgbWlkaV9ldmVudC5kYXRhWzJdID0gTnVtYmVyKHRoaXMucHJvcGVydGllcy52YWx1ZTIpO1xyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9taWRpXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElFdmVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbnB1dC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBNSURJRXZlbnQuTm90ZVN0cmluZ1RvUGl0Y2godik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUxID0gKHYgfCAwKSAlIDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY21kXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jbWQgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZTFcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlMSA9IE1hdGguY2xhbXAodnwwLDAsMTI3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWUyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTIgPSBNYXRoLmNsYW1wKHZ8MCwwLDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG91dHB1dC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pZGlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zZXR1cChbcHJvcHMuY21kLCBwcm9wcy52YWx1ZTEsIHByb3BzLnZhbHVlMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmNoYW5uZWwgPSBwcm9wcy5jaGFubmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tbWFuZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcHJvcHMuY21kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2NcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHByb3BzLnZhbHVlMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNjX3ZhbHVlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwcm9wcy52YWx1ZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub3RlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuY21kID09IE1JRElFdmVudC5OT1RFT04gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNtZCA9PSBNSURJRXZlbnQuTk9URU9GRlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcHMudmFsdWUxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVsb2NpdHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHByb3BzLmNtZCA9PSBNSURJRXZlbnQuTk9URU9OID8gcHJvcHMudmFsdWUyIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBpdGNoXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuY21kID09IE1JRElFdmVudC5OT1RFT05cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1JRElFdmVudC5jb21wdXRlUGl0Y2gocHJvcHMudmFsdWUxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBpdGNoYmVuZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNtZCA9PSBNSURJRXZlbnQuUElUQ0hCRU5EXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBNSURJRXZlbnQuY29tcHV0ZVBpdGNoQmVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy52YWx1ZTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMudmFsdWUyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2F0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElFdmVudC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiY21kXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCA9IE1JRElFdmVudC5jb21wdXRlQ29tbWFuZEZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJRXZlbnQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJjbWRcIiwgXCJudW1iZXJcIl0sW1wibm90ZVwiLCBcIm51bWJlclwiXSxbXCJ2YWx1ZTFcIiwgXCJudW1iZXJcIl0sW1widmFsdWUyXCIsIFwibnVtYmVyXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJRXZlbnQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcIm1pZGlcIiwgXCJtaWRpXCJdLFxyXG4gICAgICAgICAgICBbXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcImNvbW1hbmRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIm5vdGVcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInZlbG9jaXR5XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJjY1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiY2NfdmFsdWVcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInBpdGNoXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJnYXRlXCIsIFwiYm9vbFwiXSxcclxuICAgICAgICAgICAgW1wicGl0Y2hiZW5kXCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2V2ZW50XCIsIExHTUlESUV2ZW50KTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElDQygpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIC8vXHRcdGNoYW5uZWw6IDAsXHJcbiAgICAgICAgICAgIGNjOiAxLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmFsdWVcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJQ0MudGl0bGUgPSBcIk1JRElDQ1wiO1xyXG4gICAgTEdNSURJQ0MuZGVzYyA9IFwiZ2V0cyBhIENvbnRyb2xsZXIgQ2hhbmdlXCI7XHJcbiAgICBMR01JRElDQy5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJQ0MucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcclxuICAgICAgICBpZiAoTUlESUludGVyZmFjZS5pbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgTUlESUludGVyZmFjZS5pbnB1dC5zdGF0ZS5jY1t0aGlzLnByb3BlcnRpZXMuY2NdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2NjXCIsIExHTUlESUNDKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElHZW5lcmF0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImdlbmVyYXRlXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzY2FsZVwiLCBcInN0cmluZ1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwib2N0YXZlXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwibm90ZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgbm90ZXM6IFwiQSxBIyxCLEMsQyMsRCxEIyxFLEYsRiMsRyxHI1wiLFxyXG4gICAgICAgICAgICBvY3RhdmU6IDIsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXHJcbiAgICAgICAgICAgIG1vZGU6IFwic2VxdWVuY2VcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMubm90ZXNfcGl0Y2hlcyA9IExHTUlESUdlbmVyYXRvci5wcm9jZXNzU2NhbGUoXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5ub3Rlc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZV9pbmRleCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJR2VuZXJhdG9yLnRpdGxlID0gXCJNSURJIEdlbmVyYXRvclwiO1xyXG4gICAgTEdNSURJR2VuZXJhdG9yLmRlc2MgPSBcIkdlbmVyYXRlcyBhIHJhbmRvbSBNSURJIG5vdGVcIjtcclxuICAgIExHTUlESUdlbmVyYXRvci5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJR2VuZXJhdG9yLnByb2Nlc3NTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XHJcbiAgICAgICAgdmFyIG5vdGVzID0gc2NhbGUuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBub3Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKChuLmxlbmd0aCA9PSAyICYmIG5bMV0gIT0gXCIjXCIpIHx8IG4ubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgbm90ZXNbaV0gPSAtTGl0ZUdyYXBoLk1JRElFdmVudC5Ob3RlU3RyaW5nVG9QaXRjaChuKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vdGVzW2ldID0gTUlESUV2ZW50Lm5vdGVfdG9faW5kZXhbbl0gfHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm90ZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUdlbmVyYXRvci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwibm90ZXNcIikge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGVzX3BpdGNoZXMgPSBMR01JRElHZW5lcmF0b3IucHJvY2Vzc1NjYWxlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUdlbmVyYXRvci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9jdGF2ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgIGlmIChvY3RhdmUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMub2N0YXZlID0gb2N0YXZlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHNjYWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90ZXNfcGl0Y2hlcyA9IExHTUlESUdlbmVyYXRvci5wcm9jZXNzU2NhbGUoc2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJR2VuZXJhdG9yLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgLy92YXIgcmFuZ2UgPSB0aGlzLnByb3BlcnRpZXMubWF4IC0gdGhpcy5wcm9wZXJ0aWVzLm1pbjtcclxuICAgICAgICAvL3ZhciBwaXRjaCA9IHRoaXMucHJvcGVydGllcy5taW4gKyAoKE1hdGgucmFuZG9tKCkgKiByYW5nZSl8MCk7XHJcbiAgICAgICAgdmFyIHBpdGNoID0gMDtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLm5vdGVzX3BpdGNoZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMubW9kZSA9PSBcInNlcXVlbmNlXCIpIHtcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnNlcXVlbmNlX2luZGV4ID0gKHRoaXMuc2VxdWVuY2VfaW5kZXggKyAxKSAlIHJhbmdlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0aWVzLm1vZGUgPT0gXCJyYW5kb21cIikge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3RlID0gdGhpcy5ub3Rlc19waXRjaGVzW2luZGV4XTtcclxuICAgICAgICBpZiAobm90ZSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHBpdGNoID0gbm90ZSArICh0aGlzLnByb3BlcnRpZXMub2N0YXZlIC0gMSkgKiAxMiArIDMzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBpdGNoID0gLW5vdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICBtaWRpX2V2ZW50LnNldHVwKFtNSURJRXZlbnQuTk9URU9OLCBwaXRjaCwgMTBdKTtcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnByb3BlcnRpZXMuZHVyYXRpb24gfHwgMTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG5cclxuICAgICAgICAvL25vdGVvZmZcclxuICAgICAgICBzZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5zZXR1cChbTUlESUV2ZW50Lk5PVEVPRkYsIHBpdGNoLCAwXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIGR1cmF0aW9uICogMTAwMFxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9nZW5lcmF0b3JcIiwgTEdNSURJR2VuZXJhdG9yKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElUcmFuc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBhbW91bnQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiYW1vdW50XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblxyXG4gICAgICAgIHRoaXMubWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElUcmFuc3Bvc2UudGl0bGUgPSBcIk1JREkgVHJhbnNwb3NlXCI7XHJcbiAgICBMR01JRElUcmFuc3Bvc2UuZGVzYyA9IFwiVHJhbnNwb3NlIGEgTUlESSBub3RlXCI7XHJcbiAgICBMR01JRElUcmFuc3Bvc2UuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESVRyYW5zcG9zZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCB8fCBtaWRpX2V2ZW50LmNvbnN0cnVjdG9yICE9PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPTiB8fFxyXG4gICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPRkZcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQuc2V0dXAobWlkaV9ldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50LmRhdGFbMV0gPSBNYXRoLnJvdW5kKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50LmRhdGFbMV0gKyB0aGlzLnByb3BlcnRpZXMuYW1vdW50XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm91dFwiLCB0aGlzLm1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIm91dFwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVRyYW5zcG9zZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFtb3VudCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChhbW91bnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuYW1vdW50ID0gYW1vdW50O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL3RyYW5zcG9zZVwiLCBMR01JRElUcmFuc3Bvc2UpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESVF1YW50aXplKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgc2NhbGU6IFwiQSxBIyxCLEMsQyMsRCxEIyxFLEYsRiMsRyxHI1wiXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwibm90ZVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2NhbGVcIiwgXCJzdHJpbmdcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHJcbiAgICAgICAgdGhpcy52YWxpZF9ub3RlcyA9IG5ldyBBcnJheSgxMik7XHJcbiAgICAgICAgdGhpcy5vZmZzZXRfbm90ZXMgPSBuZXcgQXJyYXkoMTIpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1NjYWxlKHRoaXMucHJvcGVydGllcy5zY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJUXVhbnRpemUudGl0bGUgPSBcIk1JREkgUXVhbnRpemUgUGl0Y2hcIjtcclxuICAgIExHTUlESVF1YW50aXplLmRlc2MgPSBcIlRyYW5zcG9zZSBhIE1JREkgbm90ZSB0cCBmaXQgYW4gc2NhbGVcIjtcclxuICAgIExHTUlESVF1YW50aXplLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElRdWFudGl6ZS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwic2NhbGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NTY2FsZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElRdWFudGl6ZS5wcm90b3R5cGUucHJvY2Vzc1NjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50X3NjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgdGhpcy5ub3Rlc19waXRjaGVzID0gTEdNSURJR2VuZXJhdG9yLnByb2Nlc3NTY2FsZShzY2FsZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRfbm90ZXNbaV0gPSB0aGlzLm5vdGVzX3BpdGNoZXMuaW5kZXhPZihpKSAhPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkX25vdGVzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldF9ub3Rlc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IDEyOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkX25vdGVzWyhpIC0gaikgJSAxMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldF9ub3Rlc1tpXSA9IC1qO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRfbm90ZXNbKGkgKyBqKSAlIDEyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0X25vdGVzW2ldID0gajtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJUXVhbnRpemUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICBpZiAoIW1pZGlfZXZlbnQgfHwgbWlkaV9ldmVudC5jb25zdHJ1Y3RvciAhPT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT04gfHxcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT0ZGXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50LnNldHVwKG1pZGlfZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBub3RlID0gbWlkaV9ldmVudC5ub3RlO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBNSURJRXZlbnQubm90ZV90b19pbmRleFtub3RlXTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0X25vdGVzW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50LmRhdGFbMV0gKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvdXRcIiwgdGhpcy5taWRpX2V2ZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvdXRcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElRdWFudGl6ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwgJiYgc2NhbGUgIT0gdGhpcy5fY3VycmVudF9zY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NTY2FsZShzY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvcXVhbnRpemVcIiwgTEdNSURJUXVhbnRpemUpO1xyXG5cclxuXHRmdW5jdGlvbiBMR01JRElGcm9tRmlsZSgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHVybDogXCJcIixcclxuXHRcdFx0YXV0b3BsYXk6IHRydWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwicGxheVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwicGF1c2VcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJub3RlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblx0XHR0aGlzLl9taWRpID0gbnVsbDtcclxuXHRcdHRoaXMuX2N1cnJlbnRfdGltZSA9IDA7XHJcblx0XHR0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgTWlkaVBhcnNlciA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIm1pZGktcGFyc2VyLmpzIG5vdCBpbmNsdWRlZCwgTEdNaWRpUGxheSByZXF1aXJlcyB0aGF0IGxpYnJhcnk6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9jb2x4aS9taWRpLXBhcnNlci1qcy9tYXN0ZXIvc3JjL21haW4uanNcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuICAgIExHTUlESUZyb21GaWxlLnRpdGxlID0gXCJNSURJIGZyb21GaWxlXCI7XHJcbiAgICBMR01JRElGcm9tRmlsZS5kZXNjID0gXCJQbGF5cyBhIE1JREkgZmlsZVwiO1xyXG4gICAgTEdNSURJRnJvbUZpbGUuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuXHRMR01JRElGcm9tRmlsZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbiggbmFtZSApXHJcblx0e1xyXG5cdFx0aWYobmFtZSA9PSBcInBsYXlcIilcclxuXHRcdFx0dGhpcy5wbGF5KCk7XHJcblx0XHRlbHNlIGlmKG5hbWUgPT0gXCJwYXVzZVwiKVxyXG5cdFx0XHR0aGlzLl9wbGF5aW5nID0gIXRoaXMuX3BsYXlpbmc7XHJcblx0fVxyXG5cclxuXHRMR01JRElGcm9tRmlsZS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdGlmKG5hbWUgPT0gXCJ1cmxcIilcclxuXHRcdFx0dGhpcy5sb2FkTUlESUZpbGUodmFsdWUpO1xyXG5cdH1cclxuXHJcbiAgICBMR01JRElGcm9tRmlsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZighdGhpcy5fbWlkaSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKCF0aGlzLl9wbGF5aW5nKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dGhpcy5fY3VycmVudF90aW1lICs9IHRoaXMuZ3JhcGguZWxhcHNlZF90aW1lO1xyXG5cdFx0dmFyIGN1cnJlbnRfdGltZSA9IHRoaXMuX2N1cnJlbnRfdGltZSAqIDEwMDtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWlkaS50cmFja3M7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHRyYWNrID0gdGhpcy5fbWlkaS50cmFja1tpXTtcclxuXHRcdFx0aWYoIXRyYWNrLl9sYXN0X3BvcylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRyYWNrLl9sYXN0X3BvcyA9IDA7XHJcblx0XHRcdFx0dHJhY2suX3RpbWUgPSAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZWxlbSA9IHRyYWNrLmV2ZW50WyB0cmFjay5fbGFzdF9wb3MgXTtcclxuXHRcdFx0aWYoZWxlbSAmJiAodHJhY2suX3RpbWUgKyBlbGVtLmRlbHRhVGltZSkgPD0gY3VycmVudF90aW1lIClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRyYWNrLl9sYXN0X3BvcysrO1xyXG5cdFx0XHRcdHRyYWNrLl90aW1lICs9IGVsZW0uZGVsdGFUaW1lO1xyXG5cclxuXHRcdFx0XHRpZihlbGVtLmRhdGEpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIG1pZGlfY21kID0gZWxlbS50eXBlIDw8IDQgKyBlbGVtLmNoYW5uZWw7XHJcblx0XHRcdFx0XHR2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuXHRcdFx0XHRcdG1pZGlfZXZlbnQuc2V0dXAoW21pZGlfY21kLCBlbGVtLmRhdGFbMF0sIGVsZW0uZGF0YVsxXV0pO1xyXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcbiAgICB9O1xyXG5cclxuXHRMR01JRElGcm9tRmlsZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2N1cnJlbnRfdGltZSA9IDA7XHJcblx0XHRpZighdGhpcy5fbWlkaSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9taWRpLnRyYWNrczsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdHJhY2sgPSB0aGlzLl9taWRpLnRyYWNrW2ldO1xyXG5cdFx0XHR0cmFjay5fbGFzdF9wb3MgPSAwO1xyXG5cdFx0XHR0cmFjay5fdGltZSA9IDA7XHJcblx0XHR9XHRcdFxyXG5cdH1cclxuXHJcblx0TEdNSURJRnJvbUZpbGUucHJvdG90eXBlLmxvYWRNSURJRmlsZSA9IGZ1bmN0aW9uKHVybClcclxuXHR7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRMaXRlR3JhcGguZmV0Y2hGaWxlKCB1cmwsIFwiYXJyYXlidWZmZXJcIiwgZnVuY3Rpb24oZGF0YSlcclxuXHRcdHtcclxuXHRcdFx0dGhhdC5ib3hjb2xvciA9IFwiI0FGQVwiO1xyXG5cdFx0XHR0aGF0Ll9taWRpID0gTWlkaVBhcnNlci5wYXJzZSggbmV3IFVpbnQ4QXJyYXkoZGF0YSkgKTtcclxuXHRcdFx0aWYodGhhdC5wcm9wZXJ0aWVzLmF1dG9wbGF5KVxyXG5cdFx0XHRcdHRoYXQucGxheSgpO1xyXG5cdFx0fSwgZnVuY3Rpb24oZXJyKXtcclxuXHRcdFx0dGhhdC5ib3hjb2xvciA9IFwiI0ZBQVwiO1xyXG5cdFx0XHR0aGF0Ll9taWRpID0gbnVsbDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0TEdNSURJRnJvbUZpbGUucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKVxyXG5cdHtcclxuXHRcdHRoaXMucHJvcGVydGllcy51cmwgPSBcIlwiO1xyXG5cdFx0dGhpcy5sb2FkTUlESUZpbGUoIGZpbGUgKTtcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2Zyb21GaWxlXCIsIExHTUlESUZyb21GaWxlKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJUGxheSgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHZvbHVtZTogMC41LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZvbHVtZVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZHVyYXRpb25cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJub3RlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgQXVkaW9TeW50aCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIkF1ZGlvc3ludGguanMgbm90IGluY2x1ZGVkLCBMR01pZGlQbGF5IHJlcXVpcmVzIHRoYXQgbGlicmFyeVwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBTeW50aCA9ICh0aGlzLnN5bnRoID0gbmV3IEF1ZGlvU3ludGgoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1bWVudCA9IFN5bnRoLmNyZWF0ZUluc3RydW1lbnQoXCJwaWFub1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJUGxheS50aXRsZSA9IFwiTUlESSBQbGF5XCI7XHJcbiAgICBMR01JRElQbGF5LmRlc2MgPSBcIlBsYXlzIGEgTUlESSBub3RlXCI7XHJcbiAgICBMR01JRElQbGF5LmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElQbGF5LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgaWYgKCFtaWRpX2V2ZW50IHx8IG1pZGlfZXZlbnQuY29uc3RydWN0b3IgIT09IE1JRElFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pbnN0cnVtZW50ICYmIG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgIHZhciBub3RlID0gbWlkaV9ldmVudC5ub3RlOyAvL0MjXHJcbiAgICAgICAgICAgIGlmICghbm90ZSB8fCBub3RlID09IFwidW5kZWZpbmVkXCIgfHwgbm90ZS5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pbnN0cnVtZW50LnBsYXkoXHJcbiAgICAgICAgICAgICAgICBub3RlLFxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5vY3RhdmUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudm9sdW1lXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVBsYXkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2b2x1bWUgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAodm9sdW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZvbHVtZSA9IHZvbHVtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgIGlmIChkdXJhdGlvbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL3BsYXlcIiwgTEdNSURJUGxheSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJS2V5cygpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIG51bV9vY3RhdmVzOiAyLFxyXG4gICAgICAgICAgICBzdGFydF9vY3RhdmU6IDJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJub3RlXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJyZXNldFwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNDAwLCAxMDBdO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xhc3Rfa2V5ID0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJS2V5cy50aXRsZSA9IFwiTUlESSBLZXlzXCI7XHJcbiAgICBMR01JRElLZXlzLmRlc2MgPSBcIktleWJvYXJkIHRvIHBsYXkgbm90ZXNcIjtcclxuICAgIExHTUlESUtleXMuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESUtleXMua2V5cyA9IFtcclxuICAgICAgICB7IHg6IDAsIHc6IDEsIGg6IDEsIHQ6IDAgfSxcclxuICAgICAgICB7IHg6IDAuNzUsIHc6IDAuNSwgaDogMC42LCB0OiAxIH0sXHJcbiAgICAgICAgeyB4OiAxLCB3OiAxLCBoOiAxLCB0OiAwIH0sXHJcbiAgICAgICAgeyB4OiAxLjc1LCB3OiAwLjUsIGg6IDAuNiwgdDogMSB9LFxyXG4gICAgICAgIHsgeDogMiwgdzogMSwgaDogMSwgdDogMCB9LFxyXG4gICAgICAgIHsgeDogMi43NSwgdzogMC41LCBoOiAwLjYsIHQ6IDEgfSxcclxuICAgICAgICB7IHg6IDMsIHc6IDEsIGg6IDEsIHQ6IDAgfSxcclxuICAgICAgICB7IHg6IDQsIHc6IDEsIGg6IDEsIHQ6IDAgfSxcclxuICAgICAgICB7IHg6IDQuNzUsIHc6IDAuNSwgaDogMC42LCB0OiAxIH0sXHJcbiAgICAgICAgeyB4OiA1LCB3OiAxLCBoOiAxLCB0OiAwIH0sXHJcbiAgICAgICAgeyB4OiA1Ljc1LCB3OiAwLjUsIGg6IDAuNiwgdDogMSB9LFxyXG4gICAgICAgIHsgeDogNiwgdzogMSwgaDogMSwgdDogMCB9XHJcbiAgICBdO1xyXG5cclxuICAgIExHTUlESUtleXMucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG51bV9rZXlzID0gdGhpcy5wcm9wZXJ0aWVzLm51bV9vY3RhdmVzICogMTI7XHJcbiAgICAgICAgdGhpcy5rZXlzLmxlbmd0aCA9IG51bV9rZXlzO1xyXG4gICAgICAgIHZhciBrZXlfd2lkdGggPSB0aGlzLnNpemVbMF0gLyAodGhpcy5wcm9wZXJ0aWVzLm51bV9vY3RhdmVzICogNyk7XHJcbiAgICAgICAgdmFyIGtleV9oZWlnaHQgPSB0aGlzLnNpemVbMV07XHJcblxyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcblxyXG4gICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICAgICAgayA8IDI7XHJcbiAgICAgICAgICAgIGsrKyAvL2RyYXcgZmlyc3Qgd2hpdGVzICgwKSB0aGVuIGJsYWNrcyAoMSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fa2V5czsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5X2luZm8gPSBMR01JRElLZXlzLmtleXNbaSAlIDEyXTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlfaW5mby50ICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKGkgLyAxMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG9jdGF2ZSAqIDcgKiBrZXlfd2lkdGggKyBrZXlfaW5mby54ICoga2V5X3dpZHRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmtleXNbaV0gPyBcIiNDQ0NcIiA6IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMua2V5c1tpXSA/IFwiIzMzM1wiIDogXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIHggKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5X3dpZHRoICoga2V5X2luZm8udyAtIDIsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5X2hlaWdodCAqIGtleV9pbmZvLmhcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUtleXMucHJvdG90eXBlLmdldEtleUluZGV4ID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAgICAgdmFyIG51bV9rZXlzID0gdGhpcy5wcm9wZXJ0aWVzLm51bV9vY3RhdmVzICogMTI7XHJcbiAgICAgICAgdmFyIGtleV93aWR0aCA9IHRoaXMuc2l6ZVswXSAvICh0aGlzLnByb3BlcnRpZXMubnVtX29jdGF2ZXMgKiA3KTtcclxuICAgICAgICB2YXIga2V5X2hlaWdodCA9IHRoaXMuc2l6ZVsxXTtcclxuXHJcbiAgICAgICAgZm9yIChcclxuICAgICAgICAgICAgdmFyIGsgPSAxO1xyXG4gICAgICAgICAgICBrID49IDA7XHJcbiAgICAgICAgICAgIGstLSAvL3Rlc3QgYmxhY2tzIGZpcnN0ICgxKSB0aGVuIHdoaXRlcyAoMClcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlfaW5mbyA9IExHTUlESUtleXMua2V5c1tpICUgMTJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleV9pbmZvLnQgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9jdGF2ZSA9IE1hdGguZmxvb3IoaSAvIDEyKTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gb2N0YXZlICogNyAqIGtleV93aWR0aCArIGtleV9pbmZvLnggKiBrZXlfd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGtleV93aWR0aCAqIGtleV9pbmZvLnc7XHJcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGtleV9oZWlnaHQgKiBrZXlfaW5mby5oO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc1swXSA8IHggfHwgcG9zWzBdID4geCArIHcgfHwgcG9zWzFdID4gaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElLZXlzLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBwYXJhbXMpIHtcclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJyZXNldFwiKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleXNbaV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXBhcmFtcyB8fCBwYXJhbXMuY29uc3RydWN0b3IgIT09IE1JRElFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaWRpX2V2ZW50ID0gcGFyYW1zO1xyXG4gICAgICAgIHZhciBzdGFydF9ub3RlID0gKHRoaXMucHJvcGVydGllcy5zdGFydF9vY3RhdmUgLSAxKSAqIDEyICsgMjk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gbWlkaV9ldmVudC5kYXRhWzFdIC0gc3RhcnRfbm90ZTtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMua2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleXNbaW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPRkYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpbmRleF0gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJS2V5cy5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBwb3MpIHtcclxuICAgICAgICBpZiAocG9zWzFdIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgocG9zKTtcclxuICAgICAgICB0aGlzLmtleXNbaW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9sYXN0X2tleSA9IGluZGV4O1xyXG4gICAgICAgIHZhciBwaXRjaCA9ICh0aGlzLnByb3BlcnRpZXMuc3RhcnRfb2N0YXZlIC0gMSkgKiAxMiArIDI5ICsgaW5kZXg7XHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgbWlkaV9ldmVudC5zZXR1cChbTUlESUV2ZW50Lk5PVEVPTiwgcGl0Y2gsIDEwMF0pO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUtleXMucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHBvc1sxXSA8IDAgfHwgdGhpcy5fbGFzdF9rZXkgPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgocG9zKTtcclxuICAgICAgICBpZiAodGhpcy5fbGFzdF9rZXkgPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMua2V5c1t0aGlzLl9sYXN0X2tleV0gPSBmYWxzZTtcclxuICAgICAgICB2YXIgcGl0Y2ggPVxyXG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnN0YXJ0X29jdGF2ZSAtIDEpICogMTIgKyAyOSArIHRoaXMuX2xhc3Rfa2V5O1xyXG4gICAgICAgIHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuc2V0dXAoW01JRElFdmVudC5OT1RFT0ZGLCBwaXRjaCwgMTAwXSk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5rZXlzW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgdmFyIHBpdGNoID0gKHRoaXMucHJvcGVydGllcy5zdGFydF9vY3RhdmUgLSAxKSAqIDEyICsgMjkgKyBpbmRleDtcclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICBtaWRpX2V2ZW50LnNldHVwKFtNSURJRXZlbnQuTk9URU9OLCBwaXRjaCwgMTAwXSk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5fbGFzdF9rZXkgPSBpbmRleDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJS2V5cy5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24oZSwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHBvc1sxXSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEtleUluZGV4KHBvcyk7XHJcbiAgICAgICAgdGhpcy5rZXlzW2luZGV4XSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2xhc3Rfa2V5ID0gLTE7XHJcbiAgICAgICAgdmFyIHBpdGNoID0gKHRoaXMucHJvcGVydGllcy5zdGFydF9vY3RhdmUgLSAxKSAqIDEyICsgMjkgKyBpbmRleDtcclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICBtaWRpX2V2ZW50LnNldHVwKFtNSURJRXZlbnQuTk9URU9GRiwgcGl0Y2gsIDEwMF0pO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9rZXlzXCIsIExHTUlESUtleXMpO1xyXG5cclxuICAgIGZ1bmN0aW9uIG5vdygpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfVxyXG59KSh0aGlzKTtcclxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICB2YXIgTEdBdWRpbyA9IHt9O1xyXG4gICAgZ2xvYmFsLkxHQXVkaW8gPSBMR0F1ZGlvO1xyXG5cclxuICAgIExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hdWRpb19jb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPVxyXG4gICAgICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdWRpb0NvbnRleHQgbm90IHN1cHBvcnRlZCBieSBicm93c2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9fY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9fY29udGV4dC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibXNnXCIsIG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvX2NvbnRleHQub25lbmRlZCA9IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbmRlZFwiLCBtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb19jb250ZXh0Lm9uY29tcGxldGUgPSBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29tcGxldGVcIiwgbXNnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaW4gY2FzZSBpdCBjcmFzaGVzXHJcbiAgICAgICAgLy9pZih0aGlzLl9hdWRpb19jb250ZXh0LnN0YXRlID09IFwic3VzcGVuZGVkXCIpXHJcbiAgICAgICAgLy9cdHRoaXMuX2F1ZGlvX2NvbnRleHQucmVzdW1lKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1ZGlvX2NvbnRleHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY29ubmVjdCA9IGZ1bmN0aW9uKGF1ZGlvbm9kZUEsIGF1ZGlvbm9kZUIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhdWRpb25vZGVBLmNvbm5lY3QoYXVkaW9ub2RlQik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxHcmFwaEF1ZGlvOlwiLCBlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5kaXNjb25uZWN0ID0gZnVuY3Rpb24oYXVkaW9ub2RlQSwgYXVkaW9ub2RlQikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF1ZGlvbm9kZUEuZGlzY29ubmVjdChhdWRpb25vZGVCKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTEdyYXBoQXVkaW86XCIsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNoYW5nZUFsbEF1ZGlvc0Nvbm5lY3Rpb25zID0gZnVuY3Rpb24obm9kZSwgY29ubmVjdCkge1xyXG4gICAgICAgIGlmIChub2RlLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSBub2RlLmdyYXBoLmxpbmtzW2lucHV0LmxpbmtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luX25vZGUgPSBub2RlLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby5vcmlnaW5faWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbl9hdWRpb25vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbl9ub2RlLmdldEF1ZGlvTm9kZUluT3V0cHV0U2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbl9hdWRpb25vZGUgPSBvcmlnaW5fbm9kZS5nZXRBdWRpb05vZGVJbk91dHB1dFNsb3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby5vcmlnaW5fc2xvdFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbl9hdWRpb25vZGUgPSBvcmlnaW5fbm9kZS5hdWRpb25vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldF9hdWRpb25vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRfYXVkaW9ub2RlID0gbm9kZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdChpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X2F1ZGlvbm9kZSA9IG5vZGUuYXVkaW9ub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTEdBdWRpby5jb25uZWN0KG9yaWdpbl9hdWRpb25vZGUsIHRhcmdldF9hdWRpb25vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBMR0F1ZGlvLmRpc2Nvbm5lY3Qob3JpZ2luX2F1ZGlvbm9kZSwgdGFyZ2V0X2F1ZGlvbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dHB1dC5saW5rcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSBub2RlLmdyYXBoLmxpbmtzW291dHB1dC5saW5rc1tqXV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luX2F1ZGlvbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXVkaW9Ob2RlSW5PdXRwdXRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbl9hdWRpb25vZGUgPSBub2RlLmdldEF1ZGlvTm9kZUluT3V0cHV0U2xvdChpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5fYXVkaW9ub2RlID0gbm9kZS5hdWRpb25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSBub2RlLmdyYXBoLmdldE5vZGVCeUlkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X2lkXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X2F1ZGlvbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldF9ub2RlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9hdWRpb25vZGUgPSB0YXJnZXRfbm9kZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby50YXJnZXRfc2xvdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9hdWRpb25vZGUgPSB0YXJnZXRfbm9kZS5hdWRpb25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMR0F1ZGlvLmNvbm5lY3Qob3JpZ2luX2F1ZGlvbm9kZSwgdGFyZ2V0X2F1ZGlvbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTEdBdWRpby5kaXNjb25uZWN0KG9yaWdpbl9hdWRpb25vZGUsIHRhcmdldF9hdWRpb25vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy91c2VkIGJ5IG1hbnkgbm9kZXNcclxuICAgIExHQXVkaW8ub25Db25uZWN0aW9uc0NoYW5nZSA9IGZ1bmN0aW9uKFxyXG4gICAgICAgIGNvbm5lY3Rpb24sXHJcbiAgICAgICAgc2xvdCxcclxuICAgICAgICBjb25uZWN0ZWQsXHJcbiAgICAgICAgbGlua19pbmZvXHJcbiAgICApIHtcclxuICAgICAgICAvL29ubHkgcHJvY2VzcyB0aGUgb3V0cHV0cyBldmVudHNcclxuICAgICAgICBpZiAoY29ubmVjdGlvbiAhPSBMaXRlR3JhcGguT1VUUFVUKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGxpbmtfaW5mbykge1xyXG4gICAgICAgICAgICB0YXJnZXRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLnRhcmdldF9pZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRhcmdldF9ub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZ2V0IG9yaWdpbiBhdWRpb25vZGVcclxuICAgICAgICB2YXIgbG9jYWxfYXVkaW9ub2RlID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5nZXRBdWRpb05vZGVJbk91dHB1dFNsb3QpIHtcclxuICAgICAgICAgICAgbG9jYWxfYXVkaW9ub2RlID0gdGhpcy5nZXRBdWRpb05vZGVJbk91dHB1dFNsb3Qoc2xvdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG9jYWxfYXVkaW9ub2RlID0gdGhpcy5hdWRpb25vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2dldCB0YXJnZXQgYXVkaW9ub2RlXHJcbiAgICAgICAgdmFyIHRhcmdldF9hdWRpb25vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmICh0YXJnZXRfbm9kZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdCkge1xyXG4gICAgICAgICAgICB0YXJnZXRfYXVkaW9ub2RlID0gdGFyZ2V0X25vZGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QoXHJcbiAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRfYXVkaW9ub2RlID0gdGFyZ2V0X25vZGUuYXVkaW9ub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kbyB0aGUgY29ubmVjdGlvbi9kaXNjb25uZWN0aW9uXHJcbiAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICBMR0F1ZGlvLmNvbm5lY3QobG9jYWxfYXVkaW9ub2RlLCB0YXJnZXRfYXVkaW9ub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBMR0F1ZGlvLmRpc2Nvbm5lY3QobG9jYWxfYXVkaW9ub2RlLCB0YXJnZXRfYXVkaW9ub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vdGhpcyBmdW5jdGlvbiBoZWxwcyBjcmVhdGluZyB3cmFwcGVycyB0byBleGlzdGluZyBjbGFzc2VzXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIgPSBmdW5jdGlvbihjbGFzc19vYmplY3QpIHtcclxuICAgICAgICB2YXIgb2xkX2Z1bmMgPSBjbGFzc19vYmplY3QucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkO1xyXG5cclxuICAgICAgICBjbGFzc19vYmplY3QucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKG9sZF9mdW5jKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRfZnVuYy5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmF1ZGlvbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5hdWRpb25vZGVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5hdWRpb25vZGVbbmFtZV0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbbmFtZV0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjbGFzc19vYmplY3QucHJvdG90eXBlLm9uQ29ubmVjdGlvbnNDaGFuZ2UgPVxyXG4gICAgICAgICAgICBMR0F1ZGlvLm9uQ29ubmVjdGlvbnNDaGFuZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vY29udGFpbnMgdGhlIHNhbXBsZXMgZGVjb2RlZCBvZiB0aGUgbG9hZGVkIGF1ZGlvcyBpbiBBdWRpb0J1ZmZlciBmb3JtYXRcclxuICAgIExHQXVkaW8uY2FjaGVkX2F1ZGlvcyA9IHt9O1xyXG5cclxuICAgIExHQXVkaW8ubG9hZFNvdW5kID0gZnVuY3Rpb24odXJsLCBvbl9jb21wbGV0ZSwgb25fZXJyb3IpIHtcclxuICAgICAgICBpZiAoTEdBdWRpby5jYWNoZWRfYXVkaW9zW3VybF0gJiYgdXJsLmluZGV4T2YoXCJibG9iOlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAob25fY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIG9uX2NvbXBsZXRlKExHQXVkaW8uY2FjaGVkX2F1ZGlvc1t1cmxdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoTEdBdWRpby5vblByb2Nlc3NBdWRpb1VSTCkge1xyXG4gICAgICAgICAgICB1cmwgPSBMR0F1ZGlvLm9uUHJvY2Vzc0F1ZGlvVVJMKHVybCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xvYWQgbmV3IHNhbXBsZVxyXG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuXHJcbiAgICAgICAgLy8gRGVjb2RlIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBdWRpb1NvdXJjZSBsb2FkZWRcIik7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW9Tb3VyY2UgZGVjb2RlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBMR0F1ZGlvLmNhY2hlZF9hdWRpb3NbdXJsXSA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25fY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25fY29tcGxldGUoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW8gbG9hZGluZyBzYW1wbGUgZXJyb3I6XCIsIGVycik7XHJcbiAgICAgICAgICAgIGlmIChvbl9lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb25fZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9Tb3VyY2UoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBzcmM6IFwiXCIsXHJcbiAgICAgICAgICAgIGdhaW46IDAuNSxcclxuICAgICAgICAgICAgbG9vcDogdHJ1ZSxcclxuICAgICAgICAgICAgYXV0b3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdfYXVkaW8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hdWRpb2J1ZmZlciA9IG51bGw7IC8vcG9pbnRzIHRvIEF1ZGlvQnVmZmVyIHdpdGggdGhlIGF1ZGlvIHNhbXBsZXMgZGVjb2RlZFxyXG4gICAgICAgIHRoaXMuX2F1ZGlvbm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9sYXN0X3NvdXJjZW5vZGUgPSBudWxsOyAvL3RoZSBsYXN0IEF1ZGlvQnVmZmVyU291cmNlTm9kZSAodGhlcmUgY291bGQgYmUgbW9yZSBpZiB0aGVyZSBhcmUgc2V2ZXJhbCBzb3VuZHMgcGxheWluZylcclxuXHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZ2FpblwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAgICAgLy9pbml0IGNvbnRleHRcclxuICAgICAgICB2YXIgY29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGdhaW4gbm9kZSB0byBjb250cm9sIHZvbHVtZVxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ3JhcGhub2RlID0gdGhpcztcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW47XHJcblxyXG4gICAgICAgIC8vZGVidWdcclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnNyYykge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRTb3VuZCh0aGlzLnByb3BlcnRpZXMuc3JjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cdExHQXVkaW9Tb3VyY2UuZGVzYyA9IFwiUGxheXMgYW4gYXVkaW8gZmlsZVwiO1xyXG4gICAgTEdBdWRpb1NvdXJjZVtcIkBzcmNcIl0gPSB7IHdpZGdldDogXCJyZXNvdXJjZVwiIH07XHJcbiAgICBMR0F1ZGlvU291cmNlLnN1cHBvcnRlZF9leHRlbnNpb25zID0gW1wid2F2XCIsIFwib2dnXCIsIFwibXAzXCJdO1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbihncmFwaCkge1xyXG4gICAgICAgIGlmIChncmFwaC5zdGF0dXMgPT09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2F1ZGlvYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuYXV0b3BsYXkpIHtcclxuXHRcdFx0dGhpcy5wbGF5QnVmZmVyKHRoaXMuX2F1ZGlvYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcEFsbFNvdW5kcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vblBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5wYXVzZUFsbFNvdW5kcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vblVucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnVucGF1c2VBbGxTb3VuZHMoKTtcclxuICAgICAgICAvL3RoaXMub25TdGFydCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vblJlbW92ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0b3BBbGxTb3VuZHMoKTtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcHBlZF91cmwpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl91cmwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUuc3RvcEFsbFNvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vaXRlcmF0ZSBhbmQgc3RvcFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYXVkaW9ub2Rlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYXVkaW9ub2Rlc1tpXS5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb25vZGVzW2ldLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvbm9kZXNbaV0uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdGhpcy5fYXVkaW9ub2Rlc1tpXS5kaXNjb25uZWN0KCB0aGlzLmF1ZGlvbm9kZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hdWRpb25vZGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLnBhdXNlQWxsU291bmRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5zdXNwZW5kKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLnVucGF1c2VBbGxTb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLnJlc3VtZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lm5hbWUgPT0gXCJnYWluXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5uYW1lID09IFwic3JjXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KFwic3JjXCIsdik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm5hbWUgPT0gXCJwbGF5YmFja1JhdGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wbGF5YmFja1JhdGUgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fYXVkaW9ub2Rlcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb25vZGVzW2pdLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5uYW1lID09IFwiYnVmZmVyXCIgJiYgdGhpcy5fYXVkaW9idWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fYXVkaW9idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F1ZGlvYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudCA9PSBcIlBsYXlcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5QnVmZmVyKHRoaXMuX2F1ZGlvYnVmZmVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PSBcIlN0b3BcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQWxsU291bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInNyY1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFNvdW5kKHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJnYWluXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcInBsYXliYWNrUmF0ZVwiKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fYXVkaW9ub2Rlcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9ub2Rlc1tqXS5wbGF5YmFja1JhdGUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUucGxheUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgY29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGEgbmV3IGF1ZGlvbm9kZSAodGhpcyBpcyBtYW5kYXRvcnksIEF1ZGlvQVBJIGRvZXNudCBsaWtlIHRvIHJldXNlIG9sZCBvbmVzKVxyXG4gICAgICAgIHZhciBhdWRpb25vZGUgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpOyAvL2NyZWF0ZSBhIEF1ZGlvQnVmZmVyU291cmNlTm9kZVxyXG4gICAgICAgIHRoaXMuX2xhc3Rfc291cmNlbm9kZSA9IGF1ZGlvbm9kZTtcclxuICAgICAgICBhdWRpb25vZGUuZ3JhcGhub2RlID0gdGhpcztcclxuICAgICAgICBhdWRpb25vZGUuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgIGF1ZGlvbm9kZS5sb29wID0gdGhpcy5wcm9wZXJ0aWVzLmxvb3A7XHJcbiAgICAgICAgYXVkaW9ub2RlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5wbGF5YmFja1JhdGU7XHJcbiAgICAgICAgdGhpcy5fYXVkaW9ub2Rlcy5wdXNoKGF1ZGlvbm9kZSk7XHJcbiAgICAgICAgYXVkaW9ub2RlLmNvbm5lY3QodGhpcy5hdWRpb25vZGUpOyAvL2Nvbm5lY3QgdG8gZ2FpblxyXG5cclxuXHRcdHRoaXMuX2F1ZGlvbm9kZXMucHVzaChhdWRpb25vZGUpO1xyXG5cclxuXHRcdHRoaXMudHJpZ2dlcihcInN0YXJ0XCIpO1xyXG5cclxuICAgICAgICBhdWRpb25vZGUub25lbmRlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZW5kZWQhXCIpO1xyXG4gICAgICAgICAgICB0aGF0LnRyaWdnZXIoXCJlbmRlZFwiKTtcclxuICAgICAgICAgICAgLy9yZW1vdmVcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhhdC5fYXVkaW9ub2Rlcy5pbmRleE9mKGF1ZGlvbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fYXVkaW9ub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCFhdWRpb25vZGUuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICBhdWRpb25vZGUuc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGF1ZGlvbm9kZS5zdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXVkaW9ub2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5sb2FkU291bmQgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8va2lsbCBwcmV2aW91cyBsb2FkXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2F1ZGlvYnVmZmVyID0gbnVsbDsgLy9wb2ludHMgdG8gdGhlIGF1ZGlvYnVmZmVyIG9uY2UgdGhlIGF1ZGlvIGlzIGxvYWRlZFxyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdfYXVkaW8gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IExHQXVkaW8ubG9hZFNvdW5kKHVybCwgaW5uZXIpO1xyXG5cclxuICAgICAgICB0aGlzLl9sb2FkaW5nX2F1ZGlvID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUE0XCI7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9CT1hDT0xPUjtcclxuICAgICAgICAgICAgdGhhdC5fYXVkaW9idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoYXQuX2xvYWRpbmdfYXVkaW8gPSBmYWxzZTtcclxuICAgICAgICAgICAgLy9pZiBpcyBwbGF5aW5nLCB0aGVuIHBsYXkgaXRcclxuICAgICAgICAgICAgaWYgKHRoYXQuZ3JhcGggJiYgdGhhdC5ncmFwaC5zdGF0dXMgPT09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vblN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0gLy90aGlzIGNvbnRyb2xzIHRoZSBhdXRvcGxheSBhbHJlYWR5XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL0hlbHBzIGNvbm5lY3QvZGlzY29ubmVjdCBBdWRpb05vZGVzIHdoZW4gbmV3IGNvbm5lY3Rpb25zIGFyZSBtYWRlIGluIHRoZSBub2RlXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25zQ2hhbmdlID0gTEdBdWRpby5vbkNvbm5lY3Rpb25zQ2hhbmdlO1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wicGxheWJhY2tSYXRlXCIsIFwibnVtYmVyXCJdLFxyXG5cdFx0XHRbXCJzcmNcIixcInN0cmluZ1wiXSxcclxuICAgICAgICAgICAgW1wiUGxheVwiLCBMaXRlR3JhcGguQUNUSU9OXSxcclxuICAgICAgICAgICAgW1wiU3RvcFwiLCBMaXRlR3JhcGguQUNUSU9OXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiYnVmZmVyXCIsIFwiYXVkaW9idWZmZXJcIl0sIFtcInN0YXJ0XCIsIExpdGVHcmFwaC5FVkVOVF0sIFtcImVuZGVkXCIsIExpdGVHcmFwaC5FVkVOVF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkRyb3BGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kcm9wcGVkX3VybCkge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX2Ryb3BwZWRfdXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnNyYyA9IHVybDtcclxuICAgICAgICB0aGlzLmxvYWRTb3VuZCh1cmwpO1xyXG4gICAgICAgIHRoaXMuX2Ryb3BwZWRfdXJsID0gdXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnRpdGxlID0gXCJTb3VyY2VcIjtcclxuICAgIExHQXVkaW9Tb3VyY2UuZGVzYyA9IFwiUGxheXMgYXVkaW9cIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vc291cmNlXCIsIExHQXVkaW9Tb3VyY2UpO1xyXG5cclxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9NZWRpYVNvdXJjZSgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGdhaW46IDAuNVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2F1ZGlvbm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9tZWRpYV9zdHJlYW0gPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJnYWluXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBnYWluIG5vZGUgdG8gY29udHJvbCB2b2x1bWVcclxuICAgICAgICB2YXIgY29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5ncmFwaG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbjtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbihncmFwaCkge1xyXG4gICAgICAgIGlmIChncmFwaC5zdGF0dXMgPT09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tZWRpYV9zdHJlYW0gPT0gbnVsbCAmJiAhdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uUGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vblVucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW47XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9zb3VyY2Vfbm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvc291cmNlX25vZGUuZGlzY29ubmVjdCh0aGlzLmF1ZGlvbm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9zb3VyY2Vfbm9kZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9tZWRpYV9zdHJlYW0pIHtcclxuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuX21lZGlhX3N0cmVhbS5nZXRUcmFja3MoKTtcclxuICAgICAgICAgICAgaWYgKHRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrc1swXS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub3BlblN0cmVhbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgIFwiZ2V0VXNlck1lZGlhKCkgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIsIHVzZSBjaHJvbWUgYW5kIGVuYWJsZSBXZWJSVEMgZnJvbSBhYm91dDovL2ZsYWdzXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBOb3Qgc2hvd2luZyB2ZW5kb3IgcHJlZml4ZXMuXHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xyXG4gICAgICAgICAgICAuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZSB9KVxyXG4gICAgICAgICAgICAudGhlbih0aGlzLnN0cmVhbVJlYWR5LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgIC5jYXRjaChvbkZhaWxTb0hhcmQpO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgZnVuY3Rpb24gb25GYWlsU29IYXJkKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1lZGlhIHJlamVjdGVkXCIsIGVycik7XHJcbiAgICAgICAgICAgIHRoYXQuX21lZGlhX3N0cmVhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCJyZWRcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUuc3RyZWFtUmVhZHkgPSBmdW5jdGlvbihsb2NhbE1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgdGhpcy5fbWVkaWFfc3RyZWFtID0gbG9jYWxNZWRpYVN0cmVhbTtcclxuICAgICAgICAvL3RoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vaW5pdCBjb250ZXh0XHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9zb3VyY2Vfbm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvc291cmNlX25vZGUuZGlzY29ubmVjdCh0aGlzLmF1ZGlvbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvc291cmNlX25vZGUgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKFxyXG4gICAgICAgICAgICBsb2NhbE1lZGlhU3RyZWFtXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmF1ZGlvc291cmNlX25vZGUuZ3JhcGhub2RlID0gdGhpcztcclxuICAgICAgICB0aGlzLmF1ZGlvc291cmNlX25vZGUuY29ubmVjdCh0aGlzLmF1ZGlvbm9kZSk7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwid2hpdGVcIjtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWVkaWFfc3RyZWFtID09IG51bGwgJiYgIXRoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5uYW1lID09IFwiZ2FpblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluID0gdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50ID09IFwiUGxheVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbjtcclxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09IFwiU3RvcFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJnYWluXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy9IZWxwcyBjb25uZWN0L2Rpc2Nvbm5lY3QgQXVkaW9Ob2RlcyB3aGVuIG5ldyBjb25uZWN0aW9ucyBhcmUgbWFkZSBpbiB0aGUgbm9kZVxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25zQ2hhbmdlID1cclxuICAgICAgICBMR0F1ZGlvLm9uQ29ubmVjdGlvbnNDaGFuZ2U7XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcInBsYXliYWNrUmF0ZVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiUGxheVwiLCBMaXRlR3JhcGguQUNUSU9OXSxcclxuICAgICAgICAgICAgW1wiU3RvcFwiLCBMaXRlR3JhcGguQUNUSU9OXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS50aXRsZSA9IFwiTWVkaWFTb3VyY2VcIjtcclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5kZXNjID0gXCJQbGF5cyBtaWNyb3Bob25lXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL21lZGlhX3NvdXJjZVwiLCBMR0F1ZGlvTWVkaWFTb3VyY2UpO1xyXG5cclxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvQW5hbHlzZXIoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBmZnRTaXplOiAyMDQ4LFxyXG4gICAgICAgICAgICBtaW5EZWNpYmVsczogLTEwMCxcclxuICAgICAgICAgICAgbWF4RGVjaWJlbHM6IC0xMCxcclxuICAgICAgICAgICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgY29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdyYXBobm9kZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZmZ0U2l6ZSA9IHRoaXMucHJvcGVydGllcy5mZnRTaXplO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm1pbkRlY2liZWxzID0gdGhpcy5wcm9wZXJ0aWVzLm1pbkRlY2liZWxzO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm1heERlY2liZWxzID0gdGhpcy5wcm9wZXJ0aWVzLm1heERlY2liZWxzO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLnNtb290aGluZ1RpbWVDb25zdGFudCA9IHRoaXMucHJvcGVydGllcy5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZnJlcXNcIiwgXCJhcnJheVwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInNhbXBsZXNcIiwgXCJhcnJheVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZnJlcV9iaW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RpbWVfYmluID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvQW5hbHlzZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQW5hbHlzZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XHJcbiAgICAgICAgICAgIC8vc2VuZCBGRlRcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IHRoaXMuYXVkaW9ub2RlLmZyZXF1ZW5jeUJpbkNvdW50O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZyZXFfYmluIHx8IHRoaXMuX2ZyZXFfYmluLmxlbmd0aCAhPSBidWZmZXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyZXFfYmluID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nZXRCeXRlRnJlcXVlbmN5RGF0YSh0aGlzLl9mcmVxX2Jpbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9mcmVxX2Jpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NlbmQgYW5hbHl6ZXJcclxuICAgICAgICBpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSkge1xyXG4gICAgICAgICAgICAvL3NlbmQgU2FtcGxlc1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gdGhpcy5hdWRpb25vZGUuZnJlcXVlbmN5QmluQ291bnQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGltZV9iaW4gfHwgdGhpcy5fdGltZV9iaW4ubGVuZ3RoICE9IGJ1ZmZlckxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZV9iaW4gPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdldEJ5dGVUaW1lRG9tYWluRGF0YSh0aGlzLl90aW1lX2Jpbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLl90aW1lX2Jpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3Byb3BlcnRpZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtpbnB1dC5uYW1lXS52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGltZSBkb21haW5cclxuICAgICAgICAvL3RoaXMuYXVkaW9ub2RlLmdldEZsb2F0VGltZURvbWFpbkRhdGEoIGRhdGFBcnJheSApO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQW5hbHlzZXIucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wibWluRGVjaWJlbHNcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIm1heERlY2liZWxzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJzbW9vdGhpbmdUaW1lQ29uc3RhbnRcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQW5hbHlzZXIucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiZnJlcXNcIiwgXCJhcnJheVwiXSwgW1wic2FtcGxlc1wiLCBcImFycmF5XCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0FuYWx5c2VyLnRpdGxlID0gXCJBbmFseXNlclwiO1xyXG4gICAgTEdBdWRpb0FuYWx5c2VyLmRlc2MgPSBcIkF1ZGlvIEFuYWx5c2VyXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2FuYWx5c2VyXCIsIExHQXVkaW9BbmFseXNlcik7XHJcblxyXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9HYWluKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZ2FpbjogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImdhaW5cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvR2Fpbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW2lucHV0Lm5hbWVdLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9HYWluKTtcclxuXHJcbiAgICBMR0F1ZGlvR2Fpbi50aXRsZSA9IFwiR2FpblwiO1xyXG4gICAgTEdBdWRpb0dhaW4uZGVzYyA9IFwiQXVkaW8gZ2FpblwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9nYWluXCIsIExHQXVkaW9HYWluKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvQ29udm9sdmVyKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgaW1wdWxzZV9zcmM6IFwiXCIsXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVDb252b2x2ZXIoKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvQ29udm9sdmVyKTtcclxuXHJcbiAgICBMR0F1ZGlvQ29udm9sdmVyLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kcm9wcGVkX3VybCkge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX2Ryb3BwZWRfdXJsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Db252b2x2ZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImltcHVsc2Vfc3JjXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkSW1wdWxzZSh2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwibm9ybWFsaXplXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUubm9ybWFsaXplID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQ29udm9sdmVyLnByb3RvdHlwZS5vbkRyb3BGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kcm9wcGVkX3VybCkge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX2Ryb3BwZWRfdXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZHJvcHBlZF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcy5pbXB1bHNlX3NyYyA9IHRoaXMuX2Ryb3BwZWRfdXJsO1xyXG4gICAgICAgIHRoaXMubG9hZEltcHVsc2UodGhpcy5fZHJvcHBlZF91cmwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQ29udm9sdmVyLnByb3RvdHlwZS5sb2FkSW1wdWxzZSA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgLy9raWxsIHByZXZpb3VzIGxvYWRcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFib3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5faW1wdWxzZV9idWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdfaW1wdWxzZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIXVybCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xvYWQgbmV3IHNhbXBsZVxyXG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSBMR0F1ZGlvLmxvYWRTb3VuZCh1cmwsIGlubmVyKTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nX2ltcHVsc2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBEZWNvZGUgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICBmdW5jdGlvbiBpbm5lcihidWZmZXIpIHtcclxuICAgICAgICAgICAgdGhhdC5faW1wdWxzZV9idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoYXQuYXVkaW9ub2RlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbXB1bHNlIHNpZ25hbCBzZXRcIik7XHJcbiAgICAgICAgICAgIHRoYXQuX2xvYWRpbmdfaW1wdWxzZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0NvbnZvbHZlci50aXRsZSA9IFwiQ29udm9sdmVyXCI7XHJcbiAgICBMR0F1ZGlvQ29udm9sdmVyLmRlc2MgPSBcIkNvbnZvbHZlcyB0aGUgc2lnbmFsICh1c2VkIGZvciByZXZlcmIpXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2NvbnZvbHZlclwiLCBMR0F1ZGlvQ29udm9sdmVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgdGhyZXNob2xkOiAtNTAsXHJcbiAgICAgICAgICAgIGtuZWU6IDQwLFxyXG4gICAgICAgICAgICByYXRpbzogMTIsXHJcbiAgICAgICAgICAgIHJlZHVjdGlvbjogLTIwLFxyXG4gICAgICAgICAgICBhdHRhY2s6IDAsXHJcbiAgICAgICAgICAgIHJlbGVhc2U6IDAuMjVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3Nvcik7XHJcblxyXG4gICAgTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3Nvci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbaW5wdXQubmFtZV0udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcInRocmVzaG9sZFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wia25lZVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmF0aW9cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJlZHVjdGlvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYXR0YWNrXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJyZWxlYXNlXCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3Nvci50aXRsZSA9IFwiRHluYW1pY3NDb21wcmVzc29yXCI7XHJcbiAgICBMR0F1ZGlvRHluYW1pY3NDb21wcmVzc29yLmRlc2MgPSBcIkR5bmFtaWNzIENvbXByZXNzb3JcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxyXG4gICAgICAgIFwiYXVkaW8vZHluYW1pY3NDb21wcmVzc29yXCIsXHJcbiAgICAgICAgTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3NvclxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvV2F2ZVNoYXBlcigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZVdhdmVTaGFwZXIoKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2hhcGVcIiwgXCJ3YXZlc2hhcGVcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvV2F2ZVNoYXBlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cyB8fCAhdGhpcy5pbnB1dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuY3VydmUgPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvV2F2ZVNoYXBlci5wcm90b3R5cGUuc2V0V2F2ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5jdXJ2ZSA9IHNoYXBlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb1dhdmVTaGFwZXIpO1xyXG5cclxuICAgIC8qIGRpc2FibGVkIHRpbGwgSSBkb250IGZpbmQgYSB3YXkgdG8gZG8gYSB3YXZlIHNoYXBlXHJcbkxHQXVkaW9XYXZlU2hhcGVyLnRpdGxlID0gXCJXYXZlU2hhcGVyXCI7XHJcbkxHQXVkaW9XYXZlU2hhcGVyLmRlc2MgPSBcIkRpc3RvcnRpb24gdXNpbmcgd2F2ZSBzaGFwZVwiO1xyXG5MaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL3dhdmVTaGFwZXJcIiwgTEdBdWRpb1dhdmVTaGFwZXIpO1xyXG4qL1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9NaXhlcigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGdhaW4xOiAwLjUsXHJcbiAgICAgICAgICAgIGdhaW4yOiAwLjVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZTEgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZTEuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluMTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZTIgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZTIuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluMjtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUxLmNvbm5lY3QodGhpcy5hdWRpb25vZGUpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlMi5jb25uZWN0KHRoaXMuYXVkaW9ub2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluMVwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbjEgZ2FpblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW4yXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluMiBnYWluXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9NaXhlci5wcm90b3R5cGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QgPSBmdW5jdGlvbihzbG90KSB7XHJcbiAgICAgICAgaWYgKHNsb3QgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdWRpb25vZGUxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2xvdCA9PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1ZGlvbm9kZTI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWl4ZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImdhaW4xXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUxLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJnYWluMlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlMi5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWl4ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCB8fCBpbnB1dC50eXBlID09IFwiYXVkaW9cIikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZTEuZ2Fpbi52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZTIuZ2Fpbi52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvTWl4ZXIpO1xyXG5cclxuICAgIExHQXVkaW9NaXhlci50aXRsZSA9IFwiTWl4ZXJcIjtcclxuICAgIExHQXVkaW9NaXhlci5kZXNjID0gXCJBdWRpbyBtaXhlclwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9taXhlclwiLCBMR0F1ZGlvTWl4ZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9BRFNSKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgQTogMC4xLFxyXG4gICAgICAgICAgICBEOiAwLjEsXHJcbiAgICAgICAgICAgIFM6IDAuMSxcclxuICAgICAgICAgICAgUjogMC4xXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gMDtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZ2F0ZVwiLCBcImJvb2xcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmdhdGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvQURTUi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGF1ZGlvQ29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgdmFyIG5vdyA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYXVkaW9ub2RlO1xyXG4gICAgICAgIHZhciBnYWluID0gbm9kZS5nYWluO1xyXG4gICAgICAgIHZhciBjdXJyZW50X2dhdGUgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIkFcIik7XHJcbiAgICAgICAgdmFyIEQgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIkRcIik7XHJcbiAgICAgICAgdmFyIFMgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIlNcIik7XHJcbiAgICAgICAgdmFyIFIgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIlJcIik7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5nYXRlICYmIGN1cnJlbnRfZ2F0ZSkge1xyXG4gICAgICAgICAgICBnYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcclxuICAgICAgICAgICAgZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCBub3cpO1xyXG4gICAgICAgICAgICBnYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDEsIG5vdyArIEEpO1xyXG4gICAgICAgICAgICBnYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKFMsIG5vdyArIEEgKyBEKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2F0ZSAmJiAhY3VycmVudF9nYXRlKSB7XHJcbiAgICAgICAgICAgIGdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xyXG4gICAgICAgICAgICBnYWluLnNldFZhbHVlQXRUaW1lKGdhaW4udmFsdWUsIG5vdyk7XHJcbiAgICAgICAgICAgIGdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgbm93ICsgUik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdhdGUgPSBjdXJyZW50X2dhdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9BRFNSLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcIkFcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIkRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIlNcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIlJcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb0FEU1IpO1xyXG5cclxuICAgIExHQXVkaW9BRFNSLnRpdGxlID0gXCJBRFNSXCI7XHJcbiAgICBMR0F1ZGlvQURTUi5kZXNjID0gXCJBdWRpbyBlbnZlbG9wZVwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9hZHNyXCIsIExHQXVkaW9BRFNSKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvRGVsYXkoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBkZWxheVRpbWU6IDAuNVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVEZWxheSgxMCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZGVsYXlUaW1lLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmRlbGF5VGltZTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwidGltZVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvRGVsYXkpO1xyXG5cclxuICAgIExHQXVkaW9EZWxheS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmRlbGF5VGltZS52YWx1ZSA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvRGVsYXkudGl0bGUgPSBcIkRlbGF5XCI7XHJcbiAgICBMR0F1ZGlvRGVsYXkuZGVzYyA9IFwiQXVkaW8gZGVsYXlcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vZGVsYXlcIiwgTEdBdWRpb0RlbGF5KTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvQmlxdWFkRmlsdGVyKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZnJlcXVlbmN5OiAzNTAsXHJcbiAgICAgICAgICAgIGRldHVuZTogMCxcclxuICAgICAgICAgICAgUTogMVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInR5cGVcIiwgXCJsb3dwYXNzXCIsIFwiZW51bVwiLCB7XHJcbiAgICAgICAgICAgIHZhbHVlczogW1xyXG4gICAgICAgICAgICAgICAgXCJsb3dwYXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcImhpZ2hwYXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcImJhbmRwYXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcImxvd3NoZWxmXCIsXHJcbiAgICAgICAgICAgICAgICBcImhpZ2hzaGVsZlwiLFxyXG4gICAgICAgICAgICAgICAgXCJwZWFraW5nXCIsXHJcbiAgICAgICAgICAgICAgICBcIm5vdGNoXCIsXHJcbiAgICAgICAgICAgICAgICBcImFsbHBhc3NcIlxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIG5vZGVcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XHJcblxyXG4gICAgICAgIC8vc2xvdHNcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9CaXF1YWRGaWx0ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtpbnB1dC5uYW1lXS52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9CaXF1YWRGaWx0ZXIucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJmcmVxdWVuY3lcIiwgXCJudW1iZXJcIl0sIFtcImRldHVuZVwiLCBcIm51bWJlclwiXSwgW1wiUVwiLCBcIm51bWJlclwiXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvQmlxdWFkRmlsdGVyKTtcclxuXHJcbiAgICBMR0F1ZGlvQmlxdWFkRmlsdGVyLnRpdGxlID0gXCJCaXF1YWRGaWx0ZXJcIjtcclxuICAgIExHQXVkaW9CaXF1YWRGaWx0ZXIuZGVzYyA9IFwiQXVkaW8gZmlsdGVyXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2JpcXVhZGZpbHRlclwiLCBMR0F1ZGlvQmlxdWFkRmlsdGVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvT3NjaWxsYXRvck5vZGUoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBmcmVxdWVuY3k6IDQ0MCxcclxuICAgICAgICAgICAgZGV0dW5lOiAwLFxyXG4gICAgICAgICAgICB0eXBlOiBcInNpbmVcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInR5cGVcIiwgXCJzaW5lXCIsIFwiZW51bVwiLCB7XHJcbiAgICAgICAgICAgIHZhbHVlczogW1wic2luZVwiLCBcInNxdWFyZVwiLCBcInNhd3Rvb3RoXCIsIFwidHJpYW5nbGVcIiwgXCJjdXN0b21cIl1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgbm9kZVxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcblxyXG4gICAgICAgIC8vc2xvdHNcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hdWRpb25vZGUuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9ub2RlLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm9uUGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm9uU3RvcCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm9uVW5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMub25TdGFydCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQubGluayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtpbnB1dC5uYW1lXS52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJmcmVxdWVuY3lcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImRldHVuZVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1widHlwZVwiLCBcInN0cmluZ1wiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvT3NjaWxsYXRvck5vZGUpO1xyXG5cclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS50aXRsZSA9IFwiT3NjaWxsYXRvclwiO1xyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLmRlc2MgPSBcIk9zY2lsbGF0b3JcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vb3NjaWxsYXRvclwiLCBMR0F1ZGlvT3NjaWxsYXRvck5vZGUpO1xyXG5cclxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICAvL0VYVFJBXHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb1Zpc3VhbGl6YXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBjb250aW51b3VzOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXJrOiAtMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkYXRhXCIsIFwiYXJyYXlcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm1hcmtcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzMwMCwgMjAwXTtcclxuICAgICAgICB0aGlzLl9sYXN0X2J1ZmZlciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb1Zpc3VhbGl6YXRpb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RfYnVmZmVyID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXJrID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0X2J1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fbGFzdF9idWZmZXI7XHJcblxyXG4gICAgICAgIC8vZGVsdGEgcmVwcmVzZW50cyBob3cgbWFueSBzYW1wbGVzIHdlIGFkdmFuY2UgcGVyIHBpeGVsXHJcbiAgICAgICAgdmFyIGRlbHRhID0gYnVmZmVyLmxlbmd0aCAvIHRoaXMuc2l6ZVswXTtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuc2l6ZVsxXTtcclxuXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcclxuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmNvbnRpbnVvdXMpIHtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCBoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IGRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIGggLSAoYnVmZmVyW2kgfCAwXSAvIDI1NSkgKiBoKTtcclxuICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSBkZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgMC41LCBoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIDAuNSwgaCAtIChidWZmZXJbaSB8IDBdIC8gMjU1KSAqIGgpO1xyXG4gICAgICAgICAgICAgICAgeCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrID49IDApIHtcclxuICAgICAgICAgICAgdmFyIHNhbXBsZXJhdGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLnNhbXBsZVJhdGU7XHJcbiAgICAgICAgICAgIHZhciBiaW5mcmVxID0gc2FtcGxlcmF0ZSAvIGJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKDIgKiAodGhpcy5wcm9wZXJ0aWVzLm1hcmsgLyBiaW5mcmVxKSkgLyBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHggPj0gdGhpcy5zaXplWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5zaXplWzBdIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgaCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgMCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9WaXN1YWxpemF0aW9uLnRpdGxlID0gXCJWaXN1YWxpemF0aW9uXCI7XHJcbiAgICBMR0F1ZGlvVmlzdWFsaXphdGlvbi5kZXNjID0gXCJBdWRpbyBWaXN1YWxpemF0aW9uXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL3Zpc3VhbGl6YXRpb25cIiwgTEdBdWRpb1Zpc3VhbGl6YXRpb24pO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9CYW5kU2lnbmFsKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgYmFuZDogNDQwLFxyXG4gICAgICAgICAgICBhbXBsaXR1ZGU6IDFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZnJlcXNcIiwgXCJhcnJheVwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInNpZ25hbFwiLCBcIm51bWJlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvQmFuZFNpZ25hbC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fZnJlcXMgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZyZXFzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBiYW5kID0gdGhpcy5wcm9wZXJ0aWVzLmJhbmQ7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJhbmQgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNhbXBsZXJhdGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLnNhbXBsZVJhdGU7XHJcbiAgICAgICAgdmFyIGJpbmZyZXEgPSBzYW1wbGVyYXRlIC8gdGhpcy5fZnJlcXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDIgKiAoYmFuZCAvIGJpbmZyZXEpO1xyXG4gICAgICAgIHZhciB2ID0gMDtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHYgPSB0aGlzLl9mcmVxc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX2ZyZXFzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2ID0gdGhpcy5fZnJlcXNbdGhpcy5fZnJlcXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IGluZGV4IHwgMDtcclxuICAgICAgICAgICAgdmFyIHYwID0gdGhpcy5fZnJlcXNbcG9zXTtcclxuICAgICAgICAgICAgdmFyIHYxID0gdGhpcy5fZnJlcXNbcG9zICsgMV07XHJcbiAgICAgICAgICAgIHZhciBmID0gaW5kZXggLSBwb3M7XHJcbiAgICAgICAgICAgIHYgPSB2MCAqICgxIC0gZikgKyB2MSAqIGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgKHYgLyAyNTUpICogdGhpcy5wcm9wZXJ0aWVzLmFtcGxpdHVkZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9CYW5kU2lnbmFsLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiYmFuZFwiLCBcIm51bWJlclwiXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9CYW5kU2lnbmFsLnRpdGxlID0gXCJTaWduYWxcIjtcclxuICAgIExHQXVkaW9CYW5kU2lnbmFsLmRlc2MgPSBcImV4dHJhY3QgdGhlIHNpZ25hbCBvZiBzb21lIGZyZXF1ZW5jeVwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9zaWduYWxcIiwgTEdBdWRpb0JhbmRTaWduYWwpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9TY3JpcHQoKSB7XHJcbiAgICAgICAgaWYgKCFMR0F1ZGlvU2NyaXB0LmRlZmF1bHRfY29kZSkge1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IExHQXVkaW9TY3JpcHQuZGVmYXVsdF9mdW5jdGlvbi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjb2RlLmluZGV4T2YoXCJ7XCIpICsgMTtcclxuICAgICAgICAgICAgdmFyIGluZGV4MiA9IGNvZGUubGFzdEluZGV4T2YoXCJ9XCIpO1xyXG4gICAgICAgICAgICBMR0F1ZGlvU2NyaXB0LmRlZmF1bHRfY29kZSA9IGNvZGUuc3Vic3RyKGluZGV4LCBpbmRleDIgLSBpbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IExHQXVkaW9TY3JpcHQuZGVmYXVsdF9jb2RlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgbm9kZVxyXG4gICAgICAgIHZhciBjdHggPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgICAgIGlmIChjdHguY3JlYXRlU2NyaXB0UHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlID0gY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcig0MDk2LCAxLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9idWZmZXIgc2l6ZSwgaW5wdXQgY2hhbm5lbHMsIG91dHB1dCBjaGFubmVsc1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTY3JpcHRQcm9jZXNzb3JOb2RlIGRlcHJlY2F0ZWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlID0gY3R4LmNyZWF0ZUdhaW4oKTsgLy9ieXBhc3MgYXVkaW9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc0NvZGUoKTtcclxuICAgICAgICBpZiAoIUxHQXVkaW9TY3JpcHQuX2J5cGFzc19mdW5jdGlvbikge1xyXG4gICAgICAgICAgICBMR0F1ZGlvU2NyaXB0Ll9ieXBhc3NfZnVuY3Rpb24gPSB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2xvdHNcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImF1ZGlvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbihncmFwaCkge1xyXG4gICAgICAgIGlmIChncmFwaC5zdGF0dXMgPT0gTEdyYXBoLlNUQVRVU19SVU5OSU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5fY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0W1wiQGNvZGVcIl0gPSB7IHdpZGdldDogXCJjb2RlXCIsIHR5cGU6IFwiY29kZVwiIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5fY2FsbGJhY2s7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gTEdBdWRpb1NjcmlwdC5fYnlwYXNzX2Z1bmN0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vblBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSBMR0F1ZGlvU2NyaXB0Ll9ieXBhc3NfZnVuY3Rpb247XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uVW5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5fY2FsbGJhY2s7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vbm90aGluZyEgYmVjYXVzZSB3ZSBuZWVkIGFuIG9uRXhlY3V0ZSB0byByZWNlaXZlIG9uU3RhcnQuLi4gZml4IHRoYXRcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSBMR0F1ZGlvU2NyaXB0Ll9ieXBhc3NfZnVuY3Rpb247XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLnByb2Nlc3NDb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJwcm9wZXJ0aWVzXCIsIHRoaXMucHJvcGVydGllcy5jb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5fc2NyaXB0ID0gbmV3IGZ1bmModGhpcy5wcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgdGhpcy5fb2xkX2NvZGUgPSB0aGlzLnByb3BlcnRpZXMuY29kZTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSB0aGlzLl9zY3JpcHQub25hdWRpb3Byb2Nlc3M7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBvbmF1ZGlvcHJvY2VzcyBjb2RlXCIsIGVycik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrID0gTEdBdWRpb1NjcmlwdC5fYnlwYXNzX2Z1bmN0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IHRoaXMuX2NhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiY29kZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jb2RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvZGUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGggJiYgdGhpcy5ncmFwaC5zdGF0dXMgPT0gTEdyYXBoLlNUQVRVU19SVU5OSU5HKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IHRoaXMuX2NhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LmRlZmF1bHRfZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24oYXVkaW9Qcm9jZXNzaW5nRXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgc29uZyB3ZSBsb2FkZWQgZWFybGllclxyXG4gICAgICAgICAgICB2YXIgaW5wdXRCdWZmZXIgPSBhdWRpb1Byb2Nlc3NpbmdFdmVudC5pbnB1dEJ1ZmZlcjtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyIGNvbnRhaW5zIHRoZSBzYW1wbGVzIHRoYXQgd2lsbCBiZSBtb2RpZmllZCBhbmQgcGxheWVkXHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRCdWZmZXIgPSBhdWRpb1Byb2Nlc3NpbmdFdmVudC5vdXRwdXRCdWZmZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIG91dHB1dCBjaGFubmVscyAoaW4gdGhpcyBjYXNlIHRoZXJlIGlzIG9ubHkgb25lKVxyXG4gICAgICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSAwO1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbCA8IG91dHB1dEJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbCsrXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0RGF0YSA9IGlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dERhdGEgPSBvdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSA0MDk2IHNhbXBsZXNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNhbXBsZSA9IDA7IHNhbXBsZSA8IGlucHV0QnVmZmVyLmxlbmd0aDsgc2FtcGxlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIG91dHB1dCBlcXVhbCB0byB0aGUgc2FtZSBhcyB0aGUgaW5wdXRcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXREYXRhW3NhbXBsZV0gPSBpbnB1dERhdGFbc2FtcGxlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvU2NyaXB0KTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnRpdGxlID0gXCJTY3JpcHRcIjtcclxuICAgIExHQXVkaW9TY3JpcHQuZGVzYyA9IFwiYXBwbHkgc2NyaXB0IHRvIHNpZ25hbFwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9zY3JpcHRcIiwgTEdBdWRpb1NjcmlwdCk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0Rlc3RpbmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5kZXN0aW5hdGlvbjtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvRGVzdGluYXRpb24udGl0bGUgPSBcIkRlc3RpbmF0aW9uXCI7XHJcbiAgICBMR0F1ZGlvRGVzdGluYXRpb24uZGVzYyA9IFwiQXVkaW8gb3V0cHV0XCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2Rlc3RpbmF0aW9uXCIsIExHQXVkaW9EZXN0aW5hdGlvbik7XHJcbn0pKHRoaXMpO1xyXG5cbi8vZXZlbnQgcmVsYXRlZCBub2Rlc1xyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICBmdW5jdGlvbiBMR1dlYlNvY2tldCgpIHtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDIwXTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VuZFwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInJlY2VpdmVkXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIDApO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgdXJsOiBcIlwiLFxyXG4gICAgICAgICAgICByb29tOiBcImxncmFwaFwiLCAvL2FsbG93cyB0byBmaWx0ZXIgbWVzc2FnZXMsXHJcbiAgICAgICAgICAgIG9ubHlfc2VuZF9jaGFuZ2VzOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl93cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGFzdF9zZW50X2RhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLl9sYXN0X3JlY2VpdmVkX2RhdGEgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBMR1dlYlNvY2tldC50aXRsZSA9IFwiV2ViU29ja2V0XCI7XHJcbiAgICBMR1dlYlNvY2tldC5kZXNjID0gXCJTZW5kIGRhdGEgdGhyb3VnaCBhIHdlYnNvY2tldFwiO1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ1cmxcIikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RTb2NrZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3dzICYmIHRoaXMucHJvcGVydGllcy51cmwpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0U29ja2V0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3dzIHx8IHRoaXMuX3dzLnJlYWR5U3RhdGUgIT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJvb20gPSB0aGlzLnByb3BlcnRpZXMucm9vbTtcclxuICAgICAgICB2YXIgb25seV9jaGFuZ2VzID0gdGhpcy5wcm9wZXJ0aWVzLm9ubHlfc2VuZF9jaGFuZ2VzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBqc29uO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAganNvbiA9IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvb206IHJvb20sXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogaSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob25seV9jaGFuZ2VzICYmIHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldID09IGpzb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSA9IGpzb247XHJcbiAgICAgICAgICAgIHRoaXMuX3dzLnNlbmQoanNvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fbGFzdF9yZWNlaXZlZF9kYXRhW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmJveGNvbG9yID09IFwiI0FGQVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiM2QzZcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5jb25uZWN0U29ja2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnByb3BlcnRpZXMudXJsO1xyXG4gICAgICAgIGlmICh1cmwuc3Vic3RyKDAsIDIpICE9IFwid3NcIikge1xyXG4gICAgICAgICAgICB1cmwgPSBcIndzOi8vXCIgKyB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCh1cmwpO1xyXG4gICAgICAgIHRoaXMuX3dzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYWR5XCIpO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjNkM2XCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl93cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiNBRkFcIjtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGUuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnJvb20gJiYgZGF0YS5yb29tICE9IHRoYXQucHJvcGVydGllcy5yb29tKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhLm9iamVjdF9jbGFzcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaFtkYXRhLmRhdGEub2JqZWN0X2NsYXNzXVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IExpdGVHcmFwaFtkYXRhLmRhdGEub2JqZWN0X2NsYXNzXShkYXRhLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJTbG90KDAsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlclNsb3QoMCwgZGF0YS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2xhc3RfcmVjZWl2ZWRfZGF0YVtkYXRhLmNoYW5uZWwgfHwgMF0gPSBkYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3dzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY291bGRudCBjb25uZWN0IHRvIHdlYnNvY2tldFwiKTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0U4OFwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fd3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0aW9uIGNsb3NlZFwiKTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiIzAwMFwiO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fd3MgfHwgdGhpcy5fd3MucmVhZHlTdGF0ZSAhPSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3dzLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAxLCBtc2c6IGRhdGEgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93cyB8fCB0aGlzLl93cy5yZWFkeVN0YXRlICE9IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd3Muc2VuZCh7XHJcbiAgICAgICAgICAgIHR5cGU6IDEsXHJcbiAgICAgICAgICAgIHJvb206IHRoaXMucHJvcGVydGllcy5yb29tLFxyXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcclxuICAgICAgICAgICAgZGF0YTogcGFyYW1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJpblwiLCAwXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcIm91dFwiLCAwXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibmV0d29yay93ZWJzb2NrZXRcIiwgTEdXZWJTb2NrZXQpO1xyXG5cclxuICAgIC8vSXQgaXMgbGlrZSBhIHdlYnNvY2tldCBidXQgdXNpbmcgdGhlIFNpbGx5U2VydmVyLmpzIHNlcnZlciB0aGF0IGJvdW5jZXMgcGFja2V0cyBiYWNrIHRvIGFsbCBjbGllbnRzIGNvbm5lY3RlZDpcclxuICAgIC8vRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9qYWdlbmpvL1NpbGx5U2VydmVyLmpzXHJcblxyXG4gICAgZnVuY3Rpb24gTEdTaWxseUNsaWVudCgpIHtcclxuICAgICAgICAvL3RoaXMuc2l6ZSA9IFs2MCwyMF07XHJcbiAgICAgICAgdGhpcy5yb29tX3dpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFxyXG4gICAgICAgICAgICBcInRleHRcIixcclxuICAgICAgICAgICAgXCJSb29tXCIsXHJcbiAgICAgICAgICAgIFwibGdyYXBoXCIsXHJcbiAgICAgICAgICAgIHRoaXMuc2V0Um9vbS5iaW5kKHRoaXMpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmFkZFdpZGdldChcclxuICAgICAgICAgICAgXCJidXR0b25cIixcclxuICAgICAgICAgICAgXCJSZWNvbm5lY3RcIixcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0U29ja2V0LmJpbmQodGhpcylcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VuZFwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInJlY2VpdmVkXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIDApO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgdXJsOiBcInRhbWF0cy5jb206NTUwMDBcIixcclxuICAgICAgICAgICAgcm9vbTogXCJsZ3JhcGhcIixcclxuICAgICAgICAgICAgb25seV9zZW5kX2NoYW5nZXM6IHRydWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFNvY2tldCgpO1xyXG4gICAgICAgIHRoaXMuX2xhc3Rfc2VudF9kYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5fbGFzdF9yZWNlaXZlZF9kYXRhID0gW107XHJcblxyXG5cdFx0aWYodHlwZW9mKFNpbGx5Q2xpZW50KSA9PSBcInVuZGVmaW5lZFwiKVxyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJyZW1lbWJlciB0byBhZGQgU2lsbHlDbGllbnQuanMgdG8geW91ciBwcm9qZWN0OiBodHRwczovL3RhbWF0cy5jb20vcHJvamVjdHMvc2lsbHlzZXJ2ZXIvc3JjL3NpbGx5Y2xpZW50LmpzXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHU2lsbHlDbGllbnQudGl0bGUgPSBcIlNpbGx5Q2xpZW50XCI7XHJcbiAgICBMR1NpbGx5Q2xpZW50LmRlc2MgPSBcIkNvbm5lY3RzIHRvIFNpbGx5U2VydmVyIHRvIGJyb2FkY2FzdCBtZXNzYWdlc1wiO1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInJvb21cIikge1xyXG4gICAgICAgICAgICB0aGlzLnJvb21fd2lkZ2V0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdFNvY2tldCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5zZXRSb29tID0gZnVuY3Rpb24ocm9vbV9uYW1lKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvb20gPSByb29tX25hbWU7XHJcbiAgICAgICAgdGhpcy5yb29tX3dpZGdldC52YWx1ZSA9IHJvb21fbmFtZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RTb2NrZXQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy9mb3JjZSBsYWJlbCBuYW1lc1xyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgc2xvdC5sYWJlbCA9IFwiaW5fXCIgKyBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgc2xvdC5sYWJlbCA9IFwib3V0X1wiICsgaTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2VydmVyIHx8ICF0aGlzLl9zZXJ2ZXIuaXNfY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvbmx5X3NlbmRfY2hhbmdlcyA9IHRoaXMucHJvcGVydGllcy5vbmx5X3NlbmRfY2hhbmdlcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG5cdFx0XHR2YXIgcHJldl9kYXRhID0gdGhpcy5fbGFzdF9zZW50X2RhdGFbaV07XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbmx5X3NlbmRfY2hhbmdlcylcclxuXHRcdFx0XHR7XHRcclxuXHRcdFx0XHRcdHZhciBpc19lcXVhbCA9IHRydWU7XHJcblx0XHRcdFx0XHRpZiggZGF0YSAmJiBkYXRhLmxlbmd0aCAmJiBwcmV2X2RhdGEgJiYgcHJldl9kYXRhLmxlbmd0aCA9PSBkYXRhLmxlbmd0aCAmJiBkYXRhLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgKytqKVxyXG5cdFx0XHRcdFx0XHRcdGlmKCBwcmV2X2RhdGFbal0gIT0gZGF0YVtqXSApXHJcblx0XHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdFx0aXNfZXF1YWwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYodGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gIT0gZGF0YSlcclxuXHRcdFx0XHRcdFx0aXNfZXF1YWwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGlmKGlzX2VxdWFsKVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VydmVyLnNlbmRNZXNzYWdlKHsgdHlwZTogMCwgY2hhbm5lbDogaSwgZGF0YTogZGF0YSB9KTtcclxuXHRcdFx0XHRpZiggZGF0YS5sZW5ndGggJiYgZGF0YS5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nIClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpZiggdGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gKVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXS5sZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyArK2opXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGFzdF9zZW50X2RhdGFbaV1bal0gPSBkYXRhW2pdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSAvL2NyZWF0ZVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRpZihkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheSlcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSA9IGRhdGEuY29uY2F0KCk7XHJcblx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKCBkYXRhICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gPSBkYXRhOyAvL3Nob3VsZCBiZSBjbG9uZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX2xhc3RfcmVjZWl2ZWRfZGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5ib3hjb2xvciA9PSBcIiNBRkFcIikge1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjNkM2XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5jb25uZWN0U29ja2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgU2lsbHlDbGllbnQgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiU2lsbHlDbGllbnQgbm9kZSBjYW5ub3QgYmUgdXNlZCwgeW91IG11c3QgaW5jbHVkZSBTaWxseVNlcnZlci5qc1wiXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyID0gbmV3IFNpbGx5Q2xpZW50KCk7XHJcbiAgICAgICAgdGhpcy5fc2VydmVyLm9uX3JlYWR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVhZHlcIik7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiM2QzZcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3NlcnZlci5vbl9tZXNzYWdlID0gZnVuY3Rpb24oaWQsIG1zZykge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShtc2cpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvL0VWRU5UIHNsb3RcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGEub2JqZWN0X2NsYXNzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoW2RhdGEuZGF0YS5vYmplY3RfY2xhc3NdXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgTGl0ZUdyYXBoW2RhdGEuZGF0YS5vYmplY3RfY2xhc3NdKGRhdGEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlclNsb3QoMCwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyU2xvdCgwLCBkYXRhLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IC8vZm9yIEZMT1cgc2xvdHNcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9sYXN0X3JlY2VpdmVkX2RhdGFbZGF0YS5jaGFubmVsIHx8IDBdID0gZGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiNBRkFcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3NlcnZlci5vbl9lcnJvciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb3VsZG50IGNvbm5lY3QgdG8gd2Vic29ja2V0XCIpO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjRTg4XCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXIub25fY2xvc2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29ubmVjdGlvbiBjbG9zZWRcIik7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiMwMDBcIjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnVybCAmJiB0aGlzLnByb3BlcnRpZXMucm9vbSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VydmVyLmNvbm5lY3QodGhpcy5wcm9wZXJ0aWVzLnVybCwgdGhpcy5wcm9wZXJ0aWVzLnJvb20pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTaWxseVNlcnZlciBlcnJvcjogXCIgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VydmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9maW5hbF91cmwgPSB0aGlzLnByb3BlcnRpZXMudXJsICsgXCIvXCIgKyB0aGlzLnByb3BlcnRpZXMucm9vbTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zZXJ2ZXIgfHwgIXRoaXMuX3NlcnZlci5pc19jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXJ2ZXIuc2VuZE1lc3NhZ2UoeyB0eXBlOiAxLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3NlcnZlciB8fCAhdGhpcy5fc2VydmVyLmlzX2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NlcnZlci5zZW5kTWVzc2FnZSh7IHR5cGU6IDEsIGFjdGlvbjogYWN0aW9uLCBkYXRhOiBwYXJhbSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImluXCIsIDBdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJvdXRcIiwgMF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm5ldHdvcmsvc2lsbHljbGllbnRcIiwgTEdTaWxseUNsaWVudCk7XHJcbn0pKHRoaXMpO1xyXG5cbiIsImltcG9ydCB7IFNwbGluZSB9IGZyb20gXCJkZWVwc2xhdGVcIjtcbmltcG9ydCB7IExpdGVHcmFwaCwgTEdyYXBoLCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIElDb250ZXh0TWVudU9wdGlvbnMgfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5pbXBvcnQgeyBDb25zdGFudERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuLi9ub2Rlcy9jb25zdGFudF9kZW5zaXR5X2Z1bmN0aW9uXCI7XG5pbXBvcnQgeyBEZW5zaXR5RnVuY3Rpb24gfSBmcm9tIFwiLi4vbm9kZXMvZGVuc2l0eV9mdW5jdGlvblwiO1xuaW1wb3J0IHsgRGVuc2l0eUZ1bmN0aW9uT3V0cHV0IH0gZnJvbSBcIi4uL25vZGVzL2RlbnNpdHlfZnVuY3Rpb25fb3V0cHV0XCI7XG5pbXBvcnQgeyBTcGxpbmVEZW5zaXR5RnVuY3Rpb24gfSBmcm9tIFwiLi4vbm9kZXMvZGVuc2l0eV9mdW5jdGlvbl9zcGxpbmVcIjtcbmltcG9ydCB7IE5hbWVkRGVuc2l0eUZ1bmN0aW9uIH0gZnJvbSBcIi4uL25vZGVzL25hbWVkX2RlbnNpdHlfZnVuY3Rpb25cIjtcbmltcG9ydCB7IHJlZ2lzdGVyTm9kZXMgfSBmcm9tIFwiLi4vbm9kZXMvcmVnaXN0ZXJcIjtcbmltcG9ydCB7IE1lbnVNYW5hZ2VyIH0gZnJvbSBcIi4vTWVudU1hbmFnZXJcIjtcblxuZXhwb3J0IGNsYXNzIEdyYXBoTWFuYWdlciB7XG4gICAgc3RhdGljIG91dHB1dF9ub2RlOiBMR3JhcGhOb2RlXG4gICAgc3RhdGljIGdyYXBoOiBMR3JhcGhcbiAgICBzdGF0aWMgY2FudmFzOiBMR3JhcGhDYW52YXNcblxuICAgIHN0YXRpYyBuYW1lZF9ub2RlczogeyBba2V5OiBzdHJpbmddOiBOYW1lZERlbnNpdHlGdW5jdGlvbiB9XG5cbiAgICBzdGF0aWMgaW5pdCgpIHtcbiAgICAgICAgTGl0ZUdyYXBoLmNsZWFyUmVnaXN0ZXJlZFR5cGVzKCkgLy8gZG9uJ3QgdXNlIGRlZmF1bHQgbm9kZSB0eXBlc1xuICAgICAgICByZWdpc3Rlck5vZGVzKClcblxuICAgICAgICB0aGlzLmdyYXBoID0gbmV3IExHcmFwaCgpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IExHcmFwaENhbnZhcyhcIiNteWNhbnZhc1wiLCB0aGlzLmdyYXBoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYXV0b3Jlc2l6ZSA9IHRydWVcbiAgICAgICAgdGhpcy5jYW52YXMuY2FudmFzLm9ucmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZGlydHlfY2FudmFzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLm9uRHJhd0xpbmtUb29sdGlwID0gKGN0eCwgbGluaywgY2FudmFzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMub25TaG93Tm9kZVBhbmVsID0gKG4pID0+IHsgfVxuXG4gICAgICAgIHRoaXMub3V0cHV0X25vZGUgPSBuZXcgRGVuc2l0eUZ1bmN0aW9uT3V0cHV0KCk7IC8vIG5vdCByZWdpc3RlcmVkIGFzIG9ubHkgb25lIGV4aXN0c1xuICAgICAgICB0aGlzLm91dHB1dF9ub2RlLnBvcyA9IFs5MDAsIDQwMF07XG4gICAgICAgIHRoaXMuZ3JhcGguYWRkKHRoaXMub3V0cHV0X25vZGUpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGguc3RhcnQoKVxuXG5cbiAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gKGV2OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkgJiYgZXYua2V5ID09PSBcInNcIikge1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICBNZW51TWFuYWdlci5zYXZlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMucHJvY2Vzc0tleShldilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5ncmFwaC5jbGVhcigpXG4gICAgICAgIHRoaXMubmFtZWRfbm9kZXMgPSB7fVxuXG4gICAgICAgIHRoaXMub3V0cHV0X25vZGUgPSBuZXcgRGVuc2l0eUZ1bmN0aW9uT3V0cHV0KCk7IC8vIG5vdCByZWdpc3RlcmVkIGFzIG9ubHkgb25lIGV4aXN0c1xuICAgICAgICB0aGlzLm91dHB1dF9ub2RlLnBvcyA9IFs5MDAsIDQwMF07XG4gICAgICAgIHRoaXMuZ3JhcGguYWRkKHRoaXMub3V0cHV0X25vZGUpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGgucnVuU3RlcCgpXG4gICAgfVxuXG4gICAgc3RhdGljIGdldEpTT04oKTogYW55IHtcbiAgICAgICAgdGhpcy5ncmFwaC5ydW5TdGVwKClcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0X25vZGUuZ2V0SW5wdXREYXRhQnlOYW1lKFwicmVzdWx0XCIpID8/IHt9XG4gICAgfVxuXG4gICAgc3RhdGljIGxvYWRKU09OKGpzb246IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoanNvbi5ub2lzZV9yb3V0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG1lbnVfaW5mbzogYW55ID0gW11cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzb24ubm9pc2Vfcm91dGVyKS5mb3JFYWNoKChlbGVtZW50KSA9PiBtZW51X2luZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRKU09OKGpzb24ubm9pc2Vfcm91dGVyW2VsZW1lbnRdKVxuICAgICAgICAgICAgICAgICAgICBNZW51TWFuYWdlci5maWxlTmFtZSA9IGVsZW1lbnQgKyBcIi5qc29uXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHRvcDogMjAwLCBsZWZ0OiAyMDAgfVxuICAgICAgICAgICAgY29uc3QgZSA9IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSAoKSA9PiB7IH1cbiAgICAgICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShtZW51X2luZm8sIG9wdGlvbnMgYXMgSUNvbnRleHRNZW51T3B0aW9ucywgdGhpcy5jYW52YXMuZ2V0Q2FudmFzV2luZG93KCkpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciA9IGVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5jbGVhcigpXG4gICAgICAgICAgICB0aGlzLm5hbWVkX25vZGVzID0ge31cblxuICAgICAgICAgICAgdGhpcy5vdXRwdXRfbm9kZSA9IG5ldyBEZW5zaXR5RnVuY3Rpb25PdXRwdXQoKTsgLy8gbm90IHJlZ2lzdGVyZWQgYXMgb25seSBvbmUgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZCh0aGlzLm91dHB1dF9ub2RlKTtcblxuICAgICAgICAgICAgY29uc3QgW24sIHldID0gdGhpcy5jcmVhdGVOb2RlRnJvbUpzb24oanNvbiwgWzkwMCAtIDI1MCwgNDAwXSlcblxuICAgICAgICAgICAgbi5jb25uZWN0KDAsIHRoaXMub3V0cHV0X25vZGUsIDApXG4gICAgICAgICAgICB0aGlzLm91dHB1dF9ub2RlLnBvcyA9IFs5MDAsIHkgLyAyXTtcblxuICAgICAgICAgICAgdGhpcy5ncmFwaC5ydW5TdGVwKClcbiAgICAgICAgICAgIE1lbnVNYW5hZ2VyLnNldEVkaXRlZChmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVOb2RlRnJvbUpzb24oanNvbjogYW55LCBwb3M6IFtudW1iZXIsIG51bWJlcl0pOiBbTEdyYXBoTm9kZSwgbnVtYmVyXSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGpzb24gaW4gdGhpcy5uYW1lZF9ub2RlcyAmJiB0aGlzLm5hbWVkX25vZGVzW2pzb25dLnBvc1swXSA8PSBwb3NbMF0gKyA0MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMubmFtZWRfbm9kZXNbanNvbl0sIHBvc1sxXV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwiZGVuc2l0eV9mdW5jdGlvbi9uYW1lZFwiKTtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuaWQgPSBqc29uXG4gICAgICAgICAgICAgICAgICAgIDsgKG5vZGUgYXMgTmFtZWREZW5zaXR5RnVuY3Rpb24pLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICAgICAgICAgIG5vZGUucG9zID0gcG9zO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuY29sbGFwc2UoZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lZF9ub2Rlc1tqc29uXSA9IChub2RlIGFzIE5hbWVkRGVuc2l0eUZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBbbm9kZSwgcG9zWzFdICsgMTUwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBqc29uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJkZW5zaXR5X2Z1bmN0aW9uL2NvbnN0YW50XCIpO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnZhbHVlID0ganNvblxuICAgICAgICAgICAgICAgIDsgKG5vZGUgYXMgQ29uc3RhbnREZW5zaXR5RnVuY3Rpb24pLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICAgICAgbm9kZS5wb3MgPSBwb3M7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUuY29sbGFwc2UoZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gW25vZGUsIHBvc1sxXSArIDE1MF1cbiAgICAgICAgfSBlbHNlIGlmIChqc29uLnR5cGUgPT09IFwibWluZWNyYWZ0OnNwbGluZVwiKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHBvc1sxXVxuXG4gICAgICAgICAgICBjb25zdCBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJkZW5zaXR5X2Z1bmN0aW9uL3NwbGluZVwiKSBhcyBTcGxpbmVEZW5zaXR5RnVuY3Rpb25cblxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLm1pbl92YWx1ZSA9IGpzb24ubWluX3ZhbHVlXG4gICAgICAgICAgICBub2RlLnByb3BlcnRpZXMubWF4X3ZhbHVlID0ganNvbi5tYXhfdmFsdWVcblxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25zID0gW11cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdXG4gICAgICAgICAgICBjb25zdCBkZXJpdmF0aXZlcyA9IFtdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGpzb24uc3BsaW5lLnBvaW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQudmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJNdWx0aWRpbWVuaW9uYWwgU3BsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCAoeWV0KVwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11bHRpZGltZW5pb25hbCBTcGxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkICh5ZXQpXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5wdXNoKHBvaW50LmxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCgpID0+IHBvaW50LnZhbHVlKVxuICAgICAgICAgICAgICAgIGRlcml2YXRpdmVzLnB1c2gocG9pbnQuZGVyaXZhdGl2ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5zcGxpbmVXaWRnZXQudmFsdWUgPSBuZXcgU3BsaW5lPG51bWJlcj4oXCJzcGluZVwiLCAoYykgPT4gYywgbG9jYXRpb25zLCB2YWx1ZXMsIGRlcml2YXRpdmVzKTtcbiAgICAgICAgICAgIG5vZGUuc3BsaW5lV2lkZ2V0Lm1pbl9pbnB1dCA9IGxvY2F0aW9uc1swXSAtIDAuMVxuICAgICAgICAgICAgbm9kZS5zcGxpbmVXaWRnZXQubWF4X2lucHV0ID0gbG9jYXRpb25zW2xvY2F0aW9ucy5sZW5ndGggLSAxXSArIDAuMVxuXG4gICAgICAgICAgICBub2RlLnVwZGF0ZVdpZGdldHMoKVxuXG4gICAgICAgICAgICB2YXIgbjogTEdyYXBoTm9kZVxuICAgICAgICAgICAgW24sIHldID0gdGhpcy5jcmVhdGVOb2RlRnJvbUpzb24oanNvbi5zcGxpbmUuY29vcmRpbmF0ZSwgW3Bvc1swXSAtIDI1MCwgeV0pXG4gICAgICAgICAgICBuLmNvbm5lY3QoMCwgbm9kZSwgXCJjb29yZGluYXRlXCIpXG4gICAgICAgICAgICBub2RlLnBvcyA9IFtwb3NbMF0sIChwb3NbMV0gKyB5IC0gMTUwKSAvIDJdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gW25vZGUsIHldXG4gICAgICAgIH0gZWxzZSBpZiAoanNvbi50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJkZW5zaXR5X2Z1bmN0aW9uL1wiICsgKGpzb24udHlwZS5yZXBsYWNlKFwibWluZWNyYWZ0OlwiLCBcIlwiKSkpIGFzIERlbnNpdHlGdW5jdGlvblxuICAgICAgICAgICAgdmFyIHkgPSBwb3NbMV1cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPSBqc29uW3Byb3BlcnR5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWlzc2luZyBwcm9wZXJ0eSBcIiArIHByb3BlcnR5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlV2lkZ2V0cygpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5wdXRfbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBub2RlLmlucHV0X25hbWVzW2ldXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uW2lucHV0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjogTEdyYXBoTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgW24sIHldID0gdGhpcy5jcmVhdGVOb2RlRnJvbUpzb24oanNvbltpbnB1dF0sIFtwb3NbMF0gLSAyNTAsIHldKVxuICAgICAgICAgICAgICAgICAgICAgICAgbi5jb25uZWN0KDAsIG5vZGUsIGlucHV0KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWlzc2luZyBkZW5zaXR5IGZ1bmN0aW9uIFwiICsgaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnBvcyA9IFtwb3NbMF0sIChwb3NbMV0gKyB5IC0gMTUwKSAvIDJdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gW25vZGUsIHldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgbG9hZCBkZW5zaXR5IGZ1bmN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkoanNvbikpXG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgR3JhcGhNYW5hZ2VyIH0gZnJvbSBcIi4vR3JhcGhNYW5hZ2VyXCJcblxuZXhwb3J0IGNsYXNzIE1lbnVNYW5hZ2VyIHtcblxuICAgIHN0YXRpYyBmaWxlSGFuZGxlOiBGaWxlU3lzdGVtRmlsZUhhbmRsZVxuICAgIHN0YXRpYyBmaWxlTmFtZTogc3RyaW5nID0gXCJkZW5zaXR5X2Z1bmN0aW9uLmpzb25cIlxuXG4gICAgc3RhdGljIGVkaXRlZDogYm9vbGVhbiA9IGZhbHNlXG4gICAgc3RhdGljIHNhdmVfYnV0dG9uOiBIVE1MRWxlbWVudFxuXG4gICAgc3RhdGljIGFkZEhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLnNhdmVfYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1zYXZlXCIpXG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1uZXdcIikub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRlZCAmJiAhY29uZmlybShcIllvdSBoYXZlIHVuc2F2ZWQgY2hhbmdlcywgY29udGludWU/XCIpKXtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdyYXBoTWFuYWdlci5jbGVhcigpXG4gICAgICAgICAgICB0aGlzLmZpbGVIYW5kbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImRlbnNpdHlfZnVuY3Rpb24uanNvblwiXG4gICAgICAgICAgICB0aGlzLnNhdmVfYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKVxuICAgICAgICAgICAgdGhpcy5lZGl0ZWQgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1vcGVuXCIpLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0ZWQgJiYgIWNvbmZpcm0oXCJZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMsIGNvbnRpbnVlP1wiKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJzaG93T3BlbkZpbGVQaWNrZXJcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICBbdGhpcy5maWxlSGFuZGxlXSA9IGF3YWl0IHdpbmRvdy5zaG93T3BlbkZpbGVQaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkFsbCBKU09OIGZpbGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiBbXCIuanNvblwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5maWxlSGFuZGxlLmdldEZpbGUoKVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBhd2FpdCBmaWxlLnRleHQoKVxuICAgICAgICAgICAgICAgIGlmIChHcmFwaE1hbmFnZXIubG9hZEpTT04oSlNPTi5wYXJzZShqc29uU3RyaW5nKSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlSGFuZGxlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZGlzYWJsZWRcIilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVIYW5kbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwiZGVuc2l0eV9mdW5jdGlvbi5qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlX2J1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9ICdmaWxlJ1xuICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdCA9ICcuanNvbidcblxuICAgICAgICAgICAgICAgIGlucHV0Lm9uY2hhbmdlID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuZmlsZXNbMF1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlLCAnVVRGLTgnKVxuXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZXZ0OiBQcm9ncmVzc0V2ZW50PEZpbGVSZWFkZXI+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gZXZ0LnRhcmdldC5yZXN1bHQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVIYW5kbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChHcmFwaE1hbmFnZXIubG9hZEpTT04oSlNPTi5wYXJzZShqc29uU3RyaW5nKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwiZGVuc2l0eV9mdW5jdGlvbi5qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0LmNsaWNrKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51LWJ1dHRvbi1zYXZlLWFzXCIpLm9uY2xpY2sgPSBhc3luYyAoKSA9PntcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZUFzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2F2ZV9idXR0b24ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZSgpXG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBzYXZlKCl7XG4gICAgICAgIGlmICh0aGlzLmZpbGVIYW5kbGUpe1xuICAgICAgICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KEdyYXBoTWFuYWdlci5nZXRKU09OKCksIG51bGwsIDIpXG5cbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlID0gYXdhaXQgdGhpcy5maWxlSGFuZGxlLmNyZWF0ZVdyaXRhYmxlKClcbiAgICAgICAgICAgIGF3YWl0IHdyaXRhYmxlLndyaXRlKGpzb25TdHJpbmcpXG4gICAgICAgICAgICBhd2FpdCB3cml0YWJsZS5jbG9zZSgpXG4gICAgICAgICAgICB0aGlzLmVkaXRlZCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNhdmVBcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgc2F2ZUFzKCl7XG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShHcmFwaE1hbmFnZXIuZ2V0SlNPTigpLCBudWxsLCAyKVxuICAgICAgICBpZiAoXCJzaG93U2F2ZUZpbGVQaWNrZXJcIiBpbiB3aW5kb3cpe1xuICAgICAgICAgICAgdGhpcy5maWxlSGFuZGxlID0gYXdhaXQgd2luZG93LnNob3dTYXZlRmlsZVBpY2tlcihcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQWxsIEpTT04gZmlsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiBbXCIuanNvblwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSwgc3VnZ2VzdGVkTmFtZTogdGhpcy5maWxlTmFtZVxuICAgICAgICAgICAgfSApXG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlSGFuZGxlLm5hbWVcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlID0gYXdhaXQgdGhpcy5maWxlSGFuZGxlLmNyZWF0ZVdyaXRhYmxlKClcbiAgICAgICAgICAgIGF3YWl0IHdyaXRhYmxlLndyaXRlKGpzb25TdHJpbmcpXG4gICAgICAgICAgICBhd2FpdCB3cml0YWJsZS5jbG9zZSgpXG5cbiAgICAgICAgICAgIHRoaXMuZWRpdGVkID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuc2F2ZV9idXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRpc2FibGVkXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiYiA9IG5ldyBCbG9iKFtqc29uU3RyaW5nXSwge3R5cGU6ICd0ZXh0L3BsYWluJ30pXG4gICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgICAgICBhLmRvd25sb2FkID0gdGhpcy5maWxlTmFtZVxuICAgICAgICAgICAgYS5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmIpXG4gICAgICAgICAgICBhLmNsaWNrKClcbiAgICAgICAgICAgIHRoaXMuZWRpdGVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzZXRFZGl0ZWQoZm9yY2U6IGJvb2xlYW4gPSB0cnVlKXtcbiAgICAgICAgdGhpcy5lZGl0ZWQgPSBmb3JjZVxuICAgIH1cbn0iLCJpbXBvcnQgeyBJQ29udGV4dE1lbnVJdGVtLCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUgfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5pbXBvcnQgeyBNZW51TWFuYWdlciB9IGZyb20gXCIuLi9VSS9NZW51TWFuYWdlclwiO1xuXG5cbmV4cG9ydCBjbGFzcyBMR3JhcGhOb2RlRml4ZWQgZXh0ZW5kcyBMR3JhcGhOb2Rle1xuICAgIG9uUHJvcGVydHlDaGFuZ2VkKCkge1xuICAgICAgICBNZW51TWFuYWdlci5zZXRFZGl0ZWQoKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBvbkNvbm5lY3Rpb25zQ2hhbmdlKCl7XG4gICAgICAgIE1lbnVNYW5hZ2VyLnNldEVkaXRlZCgpXG4gICAgfVxuXG4gICAgb25BZGRlZCgpe1xuICAgICAgICBNZW51TWFuYWdlci5zZXRFZGl0ZWQoKVxuICAgIH1cblxuICAgIG9uUmVtb3ZlZCgpe1xuICAgICAgICBNZW51TWFuYWdlci5zZXRFZGl0ZWQoKVxuICAgIH1cblxuICAgIGdldE1lbnVPcHRpb25zKG9uRXhlY3V0ZTogTEdyYXBoQ2FudmFzKTogSUNvbnRleHRNZW51SXRlbVtde1xuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICB1cGRhdGVXaWRnZXRzKCk6IHZvaWQge31cbn0iLCJpbXBvcnQgeyBJQ29udGV4dE1lbnVJdGVtLCBJV2lkZ2V0LCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIExpdGVHcmFwaCB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IE1lbnVNYW5hZ2VyIH0gZnJvbSBcIi4uL1VJL01lbnVNYW5hZ2VyXCI7XG5pbXBvcnQgeyBMR3JhcGhOb2RlRml4ZWQgfSBmcm9tIFwiLi9MR3JhcGhOb2RlRml4ZWRcIjtcblxuZXhwb3J0IGNsYXNzIENvbnN0YW50RGVuc2l0eUZ1bmN0aW9uIGV4dGVuZHMgTEdyYXBoTm9kZUZpeGVke1xuICAgIHN0YXRpYyB0aXRsZSA9IFwiY29uc3RhbnRcIlxuXG4gICAgcHJpdmF0ZSB3ZGd0OiBJV2lkZ2V0XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuYWRkT3V0cHV0KFwib3V0cHV0XCIsXCJkZW5zaXR5RnVuY3Rpb25cIiwge2xvY2tlZDogdHJ1ZSwgbmFtZUxvY2tlZDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidmFsdWVcIiwgMCwgXCJudW1iZXJcIilcbiAgICAgICAgdGhpcy53ZGd0ID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIiwgXCJWYWx1ZVwiLCAwLCAodmFsdWUpID0+IHt0aGlzLnByb3BlcnRpZXMudmFsdWUgPSB2YWx1ZX0pXG4gICAgICAgIHRoaXMudGl0bGUgPSBcIkNvbnN0YW50XCJcbiAgICAgICAgdGhpcy5jb2xvciA9IFwiIzAwMzMzM1wiXG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVdpZGdldHMoKSB7XG4gICAgICAgIHRoaXMud2RndC52YWx1ZSA9IHRoaXMucHJvcGVydGllcy52YWx1ZVxuICAgIH1cblxuICAgIGdldFRpdGxlKCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcblxuICAgIG9uRXhlY3V0ZSgpe1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgSUNvbnRleHRNZW51SXRlbSwgSU5vZGVJbnB1dFNsb3QsIElXaWRnZXQsIExHcmFwaENhbnZhcywgTEdyYXBoTm9kZSwgTGl0ZUdyYXBoIH0gZnJvbSBcImxpdGVncmFwaC5qc1wiO1xuaW1wb3J0IHsgTWVudU1hbmFnZXIgfSBmcm9tIFwiLi4vVUkvTWVudU1hbmFnZXJcIjtcbmltcG9ydCB7IExHcmFwaE5vZGVGaXhlZCB9IGZyb20gXCIuL0xHcmFwaE5vZGVGaXhlZFwiO1xuXG5jb25zdCBzcGxpbmVfdmFsdWVzID0gW1wib2Zmc2V0XCIsIFwiZmFjdG9yXCIsIFwiamFnZ2VkbmVzc1wiXVxuY29uc3Qgc2FtcGxlcl90eXBlcyA9IFtcInR5cGVfMVwiLCBcInR5cGVfMlwiXVxuXG5leHBvcnQgY2xhc3MgRGVuc2l0eUZ1bmN0aW9uIGV4dGVuZHMgTEdyYXBoTm9kZUZpeGVke1xuXG4gICAgXG5cbiAgICBwdWJsaWMgaW5wdXRfbmFtZXM6IHN0cmluZ1tdXG4gICAgcHJpdmF0ZSB3ZGdzOiB7W2tleTogc3RyaW5nXTogSVdpZGdldH0gPSB7fVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBuYW1lOiBzdHJpbmcsIGFyZ3M6IE1hcDxzdHJpbmcsIHN0cmluZz4pe1xuICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgdGhpcy5pbnB1dF9uYW1lcyA9IFtdXG5cbiAgICAgICAgYXJncy5mb3JFYWNoKCh0eXBlLCBhcmd1bWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZGVuc2l0eUZ1bmN0aW9uXCIpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoYXJndW1lbnQsIFwiZGVuc2l0eUZ1bmN0aW9uXCIsIHtsYWJlbDogYXJndW1lbnQsIGxvY2tlZDogdHJ1ZSwgbmFtZUxvY2tlZDogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dF9uYW1lcy5wdXNoKGFyZ3VtZW50KVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShhcmd1bWVudCwgMCwgXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICB0aGlzLndkZ3NbYXJndW1lbnRdID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIiwgYXJndW1lbnQsIDAsICh2YWx1ZSkgPT4ge3RoaXMucHJvcGVydGllc1thcmd1bWVudF0gPSB2YWx1ZX0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3BsaW5lXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFByb3BlcnR5KGFyZ3VtZW50LCAwLCBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMud2Rnc1thcmd1bWVudF0gPSB0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsIGFyZ3VtZW50LCBcIm9mZnNldFwiLCAodmFsdWUpID0+IHt0aGlzLnByb3BlcnRpZXNbYXJndW1lbnRdID0gdmFsdWV9LCB7dmFsdWVzOiBzcGxpbmVfdmFsdWVzfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJub2lzZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShhcmd1bWVudCwgMCwgXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aGlzLndkZ3NbYXJndW1lbnRdID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsIGFyZ3VtZW50LCBcIm1pbmVjcmFmdDpcIiwgKHZhbHVlKSA9PiB7dGhpcy5wcm9wZXJ0aWVzW2FyZ3VtZW50XSA9IHZhbHVlfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzYW1wbGVyX3R5cGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvcGVydHkoYXJndW1lbnQsIDAsIFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy53ZGdzW2FyZ3VtZW50XSA9IHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIiwgYXJndW1lbnQsIFwidHlwZV8xXCIsICh2YWx1ZSkgPT4ge3RoaXMucHJvcGVydGllc1thcmd1bWVudF0gPSB2YWx1ZX0sIHt2YWx1ZXM6IHNhbXBsZXJfdHlwZXN9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0cHV0XCIsXCJkZW5zaXR5RnVuY3Rpb25cIiwge2xvY2tlZDogdHJ1ZSwgbmFtZUxvY2tlZDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLnRpdGxlID0gbmFtZS5yZXBsYWNlKFwibWluZWNyYWZ0OlwiLCBcIlwiKVxuICAgICAgICB0aGlzLmNvbG9yID0gXCIjMDAwMDMzXCJcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlV2lkZ2V0cygpe1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHRoaXMucHJvcGVydGllcyl7XG4gICAgICAgICAgICB0aGlzLndkZ3NbcHJvcGVydHldLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5XVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25FeGVjdXRlKCl7XG4gICAgICAgIGNvbnN0IGlucHV0czogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0X25hbWVzLmZvckVhY2goKGlucHV0KSA9PiBpbnB1dHNbaW5wdXRdID0gdGhpcy5nZXRJbnB1dERhdGFCeU5hbWUoaW5wdXQpKVxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwge3R5cGU6IHRoaXMubmFtZSwgLi4udGhpcy5wcm9wZXJ0aWVzLCAuLi5pbnB1dHN9KVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgSUNvbnRleHRNZW51SXRlbSwgTEdyYXBoQ2FudmFzLCBMR3JhcGhOb2RlLCBMaXRlR3JhcGggfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBEZW5zaXR5RnVuY3Rpb25PdXRwdXQgZXh0ZW5kcyBMR3JhcGhOb2Rle1xuICAgIHN0YXRpYyB0aXRsZSA9IFwiT3V0cHV0XCJcbiAgICByZW1vdmFibGU6IGJvb2xlYW47XG4gICAgY2xvbmFibGU6IGJvb2xlYW47XG4gICAgLy9zdGF0aWMgcmVtb3ZhYmxlID0gZmFsc2VcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy50aXRsZSA9IFwiT3V0cHV0XCJcbiAgICAgICAgdGhpcy5jb2xvciA9IFwiIzMzMzMwMFwiXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJyZXN1bHRcIiwgXCJkZW5zaXR5RnVuY3Rpb25cIiwge2xhYmVsOiBcInJlc3VsdFwiLCBsb2NrZWQ6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KVxuICAgICAgICB0aGlzLnJlbW92YWJsZSA9IGZhbHNlXG4gICAgICAgIHRoaXMuY2xvbmFibGUgPSBmYWxzZVxuICAgIH1cblxuICAgIGdldE1lbnVPcHRpb25zKG9uRXhlY3V0ZTogTEdyYXBoQ2FudmFzKTogSUNvbnRleHRNZW51SXRlbVtde1xuICAgICAgICByZXR1cm4gW11cbiAgICB9XG59XG5cbiIsImltcG9ydCB7IElDb250ZXh0TWVudUl0ZW0sIElOb2RlSW5wdXRTbG90LCBJV2lkZ2V0LCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIExpdGVHcmFwaCB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IE1lbnVNYW5hZ2VyIH0gZnJvbSBcIi4uL1VJL01lbnVNYW5hZ2VyXCI7XG5pbXBvcnQgeyBTcGxpbmVXaWRnZXQgfSBmcm9tIFwiLi4vd2lkZ2V0cy9TcGxpbmVXaWRnZXRcIjtcbmltcG9ydCB7IExHcmFwaE5vZGVGaXhlZCB9IGZyb20gXCIuL0xHcmFwaE5vZGVGaXhlZFwiO1xuXG5jb25zdCBzcGxpbmVfdmFsdWVzID0gW1wib2Zmc2V0XCIsIFwiZmFjdG9yXCIsIFwiamFnZ2VkbmVzc1wiXVxuY29uc3Qgc2FtcGxlcl90eXBlcyA9IFtcInR5cGVfMVwiLCBcInR5cGVfMlwiXVxuXG5leHBvcnQgY2xhc3MgU3BsaW5lRGVuc2l0eUZ1bmN0aW9uIGV4dGVuZHMgTEdyYXBoTm9kZUZpeGVke1xuXG4gICAgc3RhdGljIHRpdGxlID0gXCJzcGxpbmVcIlxuICAgIFxuXG4gICAgcHJpdmF0ZSB3ZGdzOiB7W2tleTogc3RyaW5nXTogSVdpZGdldH0gPSB7fVxuICAgIHB1YmxpYyBzcGxpbmVXaWRnZXQ6IFNwbGluZVdpZGdldFxuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb29yZGluYXRlXCIsIFwiZGVuc2l0eUZ1bmN0aW9uXCIsIHtsYWJlbDogXCJjb29yZGluYXRlXCIsIGxvY2tlZDogdHJ1ZSwgbmFtZUxvY2tlZDogdHJ1ZX0pXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0cHV0XCIsIFwiZGVuc2l0eUZ1bmN0aW9uXCIsIHtsb2NrZWQ6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5zcGxpbmVXaWRnZXQgPSB0aGlzLmFkZEN1c3RvbVdpZGdldDxTcGxpbmVXaWRnZXQ+KG5ldyBTcGxpbmVXaWRnZXQoKSlcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1pbl92YWx1ZVwiLCAtMSwgXCJudW1iZXJcIilcbiAgICAgICAgdGhpcy53ZGdzLm1pbl92YWx1ZSA9IHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsIFwibWluX3ZhbHVlXCIsIC0xLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW5fdmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zcGxpbmVXaWRnZXQubWluX3ZhbHVlID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1heF92YWx1ZVwiLCAxLCBcIm51bWJlclwiKVxuICAgICAgICB0aGlzLndkZ3MubWF4X3ZhbHVlID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIiwgXCJtYXhfdmFsdWVcIiwgMSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIHRoaXMuc3BsaW5lV2lkZ2V0Lm1heF92YWx1ZSA9IHZhbHVlXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy50aXRsZSA9IFwic3BsaW5lXCJcbiAgICAgICAgdGhpcy5jb2xvciA9IFwiIzAwMDAzM1wiXG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVdpZGdldHMoKXtcbiAgICAgICAgdGhpcy53ZGdzLm1pbl92YWx1ZS52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5taW5fdmFsdWVcbiAgICAgICAgdGhpcy53ZGdzLm1heF92YWx1ZS52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWVcbiAgICAgICAgdGhpcy5zcGxpbmVXaWRnZXQubWluX3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZVxuICAgICAgICB0aGlzLnNwbGluZVdpZGdldC5tYXhfdmFsdWUgPSB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXG4gICAgfVxuXG4gICAgb25FeGVjdXRlKCl7XG5cbiAgICAgICAgY29uc3QgcG9pbnRzID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5zcGxpbmVXaWRnZXQudmFsdWUubG9jYXRpb25zLmxlbmd0aCA7IGkrKyl7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHRoaXMuc3BsaW5lV2lkZ2V0LnZhbHVlLmxvY2F0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zcGxpbmVXaWRnZXQudmFsdWUudmFsdWVzW2ldKDApLFxuICAgICAgICAgICAgICAgIGRlcml2YXRpdmU6IHRoaXMuc3BsaW5lV2lkZ2V0LnZhbHVlLmRlcml2YXRpdmVzW2ldXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWluZWNyYWZ0OnNwbGluZVwiLFxuICAgICAgICAgICAgbWluX3ZhbHVlOiB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlLFxuICAgICAgICAgICAgbWF4X3ZhbHVlOiB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlLFxuICAgICAgICAgICAgc3BsaW5lOiB7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZTogdGhpcy5nZXRJbnB1dERhdGFCeU5hbWUoXCJjb29yZGluYXRlXCIpLFxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBJQ29udGV4dE1lbnVJdGVtLCBJV2lkZ2V0LCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIExpdGVHcmFwaCB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IE1lbnVNYW5hZ2VyIH0gZnJvbSBcIi4uL1VJL01lbnVNYW5hZ2VyXCI7XG5pbXBvcnQgeyBMR3JhcGhOb2RlRml4ZWQgfSBmcm9tIFwiLi9MR3JhcGhOb2RlRml4ZWRcIjtcblxuZXhwb3J0IGNsYXNzIE5hbWVkRGVuc2l0eUZ1bmN0aW9uIGV4dGVuZHMgTEdyYXBoTm9kZUZpeGVke1xuICAgIHN0YXRpYyB0aXRsZSA9IFwiTmFtZWQgRGVuc2l0eSBGdW5jdGlvblwiXG5cbiAgICBwcml2YXRlIHdkZ3Q6IElXaWRnZXRcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRwdXRcIixcImRlbnNpdHlGdW5jdGlvblwiLCB7bG9ja2VkOiB0cnVlLCBuYW1lTG9ja2VkOiB0cnVlfSk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJpZFwiLCBcIlwiLCBcInN0cmluZ1wiKVxuICAgICAgICB0aGlzLndkZ3QgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIiwgXCJJZFwiLCBcIlwiLCAodmFsdWUpID0+IHt0aGlzLnByb3BlcnRpZXMuaWQgPSB2YWx1ZX0pXG4gICAgICAgIHRoaXMudGl0bGUgPSBcIk5hbWVkIERlbnNpdHkgRnVuY3Rpb25cIlxuICAgICAgICB0aGlzLmNvbG9yID0gXCIjMzMwMDAwXCJcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlV2lkZ2V0cygpIHtcbiAgICAgICAgdGhpcy53ZGd0LnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmlkXG4gICAgfVxuXG4gICAgZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB2YXIgaWQ6c3RyaW5nID0gdGhpcy5wcm9wZXJ0aWVzLmlkXG4gICAgICAgICAgICBpZiAoaWQubGVuZ3RoID4gMjApe1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKGlkLmxhc3RJbmRleE9mKFwiL1wiKSsxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH07XG5cbiAgICBvbkV4ZWN1dGUoKXtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy5pZClcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IExpdGVHcmFwaCB9IGZyb20gXCJsaXRlZ3JhcGguanNcIjtcbmltcG9ydCB7IHNjaGVtYXMgfSBmcm9tIFwiLi4vdmFuaWxsYS9zY2hlbWFzXCI7XG5pbXBvcnQgeyBDb25zdGFudERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL2NvbnN0YW50X2RlbnNpdHlfZnVuY3Rpb25cIjtcbmltcG9ydCB7IERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL2RlbnNpdHlfZnVuY3Rpb25cIjtcbmltcG9ydCB7IFNwbGluZURlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL2RlbnNpdHlfZnVuY3Rpb25fc3BsaW5lXCI7XG5pbXBvcnQgeyBOYW1lZERlbnNpdHlGdW5jdGlvbiB9IGZyb20gXCIuL25hbWVkX2RlbnNpdHlfZnVuY3Rpb25cIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJOb2Rlcygpe1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZGVuc2l0eV9mdW5jdGlvbi9uYW1lZFwiLCBOYW1lZERlbnNpdHlGdW5jdGlvbiApO1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZGVuc2l0eV9mdW5jdGlvbi9jb25zdGFudFwiLCBDb25zdGFudERlbnNpdHlGdW5jdGlvbiApO1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZGVuc2l0eV9mdW5jdGlvbi9zcGxpbmVcIiwgU3BsaW5lRGVuc2l0eUZ1bmN0aW9uICk7XG5cbiAgICBzY2hlbWFzLmZvckVhY2goKHNjaGVtYSwgbikgPT4ge1xuICAgICAgICBjbGFzcyBmIGV4dGVuZHMgRGVuc2l0eUZ1bmN0aW9ue1xuICAgICAgICAgICAgc3RhdGljIHRpdGxlID0gbi5yZXBsYWNlKFwibWluZWNyYWZ0OlwiLCBcIlwiKVxuXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAgICAgICAgIHN1cGVyKG4sIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc2NoZW1hKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJkZW5zaXR5X2Z1bmN0aW9uL1wiICsgKG4ucmVwbGFjZShcIm1pbmVjcmFmdDpcIiwgXCJcIikpLCBmKVxuICAgIH0pXG5cblxuXG59IiwiZXhwb3J0IGNvbnN0IHNjaGVtYXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHtcbiAgICAnbWluZWNyYWZ0OmFicyc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmFkZCc6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmJlYXJkaWZpZXInOiB7fSxcbiAgICAnbWluZWNyYWZ0OmJsZW5kX2FscGhhJzoge30sXG4gICAgJ21pbmVjcmFmdDpibGVuZF9kZW5zaXR5Jzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6YmxlbmRfb2Zmc2V0Jzoge30sXG4gICAgJ21pbmVjcmFmdDpjYWNoZV8yZCc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmNhY2hlX2FsbF9pbl9jZWxsJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6Y2FjaGVfb25jZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmNsYW1wJzoge1xuICAgICAgICBpbnB1dDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgbWluOiBcIm51bWJlclwiLFxuICAgICAgICBtYXg6IFwibnVtYmVyXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmN1YmUnOiB7XG4gICAgICAgIGFyZ3VtZW50OiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgIH0sXG4gICAgXCJtaW5lY3JhZnQ6ZW5kX2lzbGFuZHNcIjoge30sXG4gICAgJ21pbmVjcmFmdDpmbGF0X2NhY2hlJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6aGFsZl9uZWdhdGl2ZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OmludGVycG9sYXRlZCc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om1heCc6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om1pbic6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om11bCc6IHtcbiAgICAgICAgYXJndW1lbnQxOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBhcmd1bWVudDI6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0Om5vaXNlJzoge1xuICAgICAgICBub2lzZTogXCJub2lzZVwiLFxuICAgICAgICB4el9zY2FsZTogXCJudW1iZXJcIixcbiAgICAgICAgeV9zY2FsZTogXCJudW1iZXJcIixcbiAgICB9LFxuICAgIFwibWluZWNyYWZ0Om9sZF9ibGVuZGVkX25vaXNlXCI6IHt9LFxuICAgICdtaW5lY3JhZnQ6cXVhcnRlcl9uZWdhdGl2ZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnJhbmdlX2Nob2ljZSc6IHtcbiAgICAgICAgaW5wdXQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgICAgIG1pbl9pbmNsdXNpdmU6IFwibnVtYmVyXCIsXG4gICAgICAgIG1heF9leGNsdXNpdmU6IFwibnVtYmVyXCIsXG4gICAgICAgIHdoZW5faW5fcmFuZ2U6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgICAgIHdoZW5fb3V0X29mX3JhbmdlOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgIH0sXG4gICAgJ21pbmVjcmFmdDpzaGlmdCc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnNoaWZ0X2EnOiB7XG4gICAgICAgIGFyZ3VtZW50OiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgIH0sXG4gICAgJ21pbmVjcmFmdDpzaGlmdF9iJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6c2hpZnRlZF9ub2lzZSc6IHtcbiAgICAgICAgc2hpZnRfeDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgc2hpZnRfeTogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgc2hpZnRfejogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICAgICAgbm9pc2U6IFwibm9pc2VcIixcbiAgICAgICAgeHpfc2NhbGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHlfc2NhbGU6IFwibnVtYmVyXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnNsaWRlJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6c3F1YXJlJzoge1xuICAgICAgICBhcmd1bWVudDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6c3F1ZWV6ZSc6IHtcbiAgICAgICAgYXJndW1lbnQ6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OnRlcnJhaW5fc2hhcGVyX3NwbGluZSc6IHtcbiAgICAgICAgc3BsaW5lOiBcInNwbGluZVwiLFxuICAgICAgICBtaW5fdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgIG1heF92YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgY29udGluZW50YWxuZXNzOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICBlcm9zaW9uOiBcImRlbnNpdHlGdW5jdGlvblwiLFxuICAgICAgICB3ZWlyZG5lc3M6IFwiZGVuc2l0eUZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICAnbWluZWNyYWZ0OndlaXJkX3NjYWxlZF9zYW1wbGVyJzoge1xuICAgICAgICByYXJpdHlfdmFsdWVfbWFwcGVyOiBcInNhbXBsZXJfdHlwZVwiLFxuICAgICAgICBub2lzZTogXCJub2lzZVwiLFxuICAgICAgICBpbnB1dDogXCJkZW5zaXR5RnVuY3Rpb25cIixcbiAgICB9LFxuICAgICdtaW5lY3JhZnQ6eV9jbGFtcGVkX2dyYWRpZW50Jzoge1xuICAgICAgICBmcm9tX3k6IFwibnVtYmVyXCIsXG4gICAgICAgIHRvX3k6IFwibnVtYmVyXCIsXG4gICAgICAgIGZyb21fdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgIHRvX3ZhbHVlOiBcIm51bWJlclwiLFxuICAgIH1cbn0pKVxuXG5leHBvcnQgY29uc3Qgbm9pc2Vfcm91dGVyX2ZpZWxkcyA9IFtcbiAgICBcImZpbmFsX2RlbnNpdHlcIixcbiAgICBcInZlaW5fdG9nZ2xlXCIsXG4gICAgXCJ2ZWluX3JpZGdlZFwiLFxuICAgIFwidmVpbl9nYXBcIixcbiAgICBcImVyb3Npb25cIixcbiAgICBcImRlcHRoXCIsXG4gICAgXCJyaWRnZXNcIixcbiAgICBcImluaXRpYWxfZGVuc2l0eV93aXRob3V0X2phZ2dlZG5lc3NcIixcbiAgICBcImxhdmFcIixcbiAgICBcInRlbXBlcmF0dXJlXCIsXG4gICAgXCJ2ZWdldGF0aW9uXCIsXG4gICAgXCJjb250aW5lbnRzXCIsXG4gICAgXCJiYXJyaWVyXCIsXG4gICAgXCJmbHVpZF9sZXZlbF9mbG9vZGVkbmVzc1wiLFxuICAgIFwiZmx1aWRfbGV2ZWxfc3ByZWFkXCJcbl0iLCJcbmltcG9ydCB7IFNwbGluZSB9IGZyb20gJ2RlZXBzbGF0ZSc7XG5pbXBvcnQgeyBJV2lkZ2V0LCBMR3JhcGhDYW52YXMsIExHcmFwaE5vZGUsIFZlY3RvcjIsIFdpZGdldENhbGxiYWNrLCB3aWRnZXRUeXBlcyB9IGZyb20gJ2xpdGVncmFwaC5qcydcblxuZXhwb3J0IGNsYXNzIFNwbGluZVdpZGdldCBpbXBsZW1lbnRzIElXaWRnZXQ8U3BsaW5lPG51bWJlcj4+e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZTogU3BsaW5lPG51bWJlcj4gPSBuZXcgU3BsaW5lPG51bWJlcj4oXCJzcGluZVwiLCAoYykgPT4gYywgWy0xLCAxXSwgWygpID0+IC0xLCAoKSA9PiAxXSwgWzEsIDFdKTtcblxuICAgIHB1YmxpYyBtaW5faW5wdXQ6IG51bWJlciA9IC0xO1xuICAgIHB1YmxpYyBtYXhfaW5wdXQ6IG51bWJlciA9IDE7XG4gICAgcHVibGljIG1pbl92YWx1ZTogbnVtYmVyID0gLTE7XG4gICAgcHVibGljIG1heF92YWx1ZTogbnVtYmVyID0gMTtcblxuICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgcHJpdmF0ZSB3aWRnZWRfd2lkdGg6IG51bWJlclxuICAgIHByaXZhdGUgd2lkZ2V0X3Bvc3k6IG51bWJlclxuXG4gICAgcHJpdmF0ZSBkcmFnZ2luZ19pZDogbnVtYmVyID0gLTFcbiAgICBwcml2YXRlIHNlbGVjdGVkX2lkOiBudW1iZXIgPSAtMVxuICAgIHByaXZhdGUgZHJhZ2dpbmdfZGVyaXZhdGl2ZTogYm9vbGVhbiA9IGZhbHNlXG4gICAgcHJpdmF0ZSBsYXN0X2NsaWNrX3RpbWU6IG51bWJlciA9IDAgXG5cbiAgICBwcml2YXRlIG5vZGU6IExHcmFwaE5vZGVcblxuICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG5vZGU6IExHcmFwaE5vZGUsIHdpZHRoOiBudW1iZXIsIHBvc1k6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGVcblxuICAgICAgICBjdHguc2F2ZSgpXG4gICAgICAgIHdpZHRoLT0yMDtcbiAgICAgICAgdGhpcy53aWRnZWRfd2lkdGggPSB3aWR0aFxuICAgICAgICB0aGlzLndpZGdldF9wb3N5ID0gcG9zWVxuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCJcbiAgICAgICAgY3R4LnJlY3QoMTAsIHBvc1ksIHdpZHRoLCB3aWR0aClcbiAgICAgICAgY3R4LmNsaXAoKVxuICAgICAgICBjdHguZmlsbFJlY3QoMTAsIHBvc1ksIHdpZHRoLCB3aWR0aClcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMC41XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiZ3JheVwiXG4gICAgICAgIGZvciAodmFyIGxvY2F0aW9uID0gTWF0aC5mbG9vcih0aGlzLm1pbl9pbnB1dCAvIDIpICogMiA7IGxvY2F0aW9uIDw9IHRoaXMubWF4X2lucHV0IDsgbG9jYXRpb24rPTAuNSl7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3MobG9jYXRpb24sIHdpZHRoKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBwb3NZKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBwb3NZICsgd2lkdGgpXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB2YWx1ZSA9IE1hdGguZmxvb3IodGhpcy5taW5fdmFsdWUgLyAyKSAqIDIgOyB2YWx1ZSA8PSB0aGlzLm1heF92YWx1ZSA7IHZhbHVlKz0wLjUpe1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5vdXRwdXRUb1Bvcyh2YWx1ZSwgd2lkdGgpXG4gICAgICAgICAgICBjdHgubGluZVRvKDEwLCB5KVxuICAgICAgICAgICAgY3R4LmxpbmVUbygxMCt3aWR0aCwgeSlcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDFcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjb25zdCBzdGVwID0gNVxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeDw9d2lkdGg7IHgrPXN0ZXApe1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4KzEwLCB0aGlzLm91dHB1dFRvUG9zKHRoaXMudmFsdWUuYXBwbHkodGhpcy5wb3NUb0lucHV0KHggKyAxMCwgd2lkdGgpKSwgd2lkdGgpKVxuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lVG8od2lkdGgrMTAsIHRoaXMub3V0cHV0VG9Qb3ModGhpcy52YWx1ZS5hcHBseSh0aGlzLnBvc1RvSW5wdXQod2lkdGggKyAxMCwgd2lkdGgpKSwgd2lkdGgpKVxuICAgICAgICBjdHguc3Ryb2tlKClcblxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGk8dGhpcy52YWx1ZS5sb2NhdGlvbnMubGVuZ3RoIDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3ModGhpcy52YWx1ZS5sb2NhdGlvbnNbaV0sIHdpZHRoKVxuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMub3V0cHV0VG9Qb3ModGhpcy52YWx1ZS52YWx1ZXNbaV0oMCksIHdpZHRoKVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGkgPT0gdGhpcy5zZWxlY3RlZF9pZCA/IFwib3JhbmdlXCIgOiBcIndoaXRlXCJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBpID09IHRoaXMuc2VsZWN0ZWRfaWQgPyAzIDogMiwgMCwgMiAqIE1hdGguUEkpOyAgXG4gICAgICAgICAgICBjdHguZmlsbCgpICAgXG4gICAgICAgICAgICBpZiAoaSA9PSB0aGlzLnNlbGVjdGVkX2lkKXtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIm9yYW5nZVwiXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2YXRpdmUgPSB0aGlzLnZhbHVlLmRlcml2YXRpdmVzW2ldICogKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpIC8gKHRoaXMubWF4X3ZhbHVlIC0gdGhpcy5taW5fdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4oZGVyaXZhdGl2ZSlcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSAzMCpNYXRoLmNvcyhhbmdsZSksIHkgKyAzMCpNYXRoLnNpbihhbmdsZSkpXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMzAqTWF0aC5jb3MoYW5nbGUpLCB5IC0gMzAqTWF0aC5zaW4oYW5nbGUpKVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8vY3R4LmZpbGxUZXh0KHRoaXMubWF4X3ZhbHVlLnRvRml4ZWQoMiksIDEwLCBwb3NZKzEyKVxuICAgICAgIC8vY3R4LmZpbGxUZXh0KHRoaXMubWluX3ZhbHVlLnRvRml4ZWQoMiksIDEwLCBwb3NZK3dpZHRoLTEpXG5cbiAgICAgICBjdHgucmVzdG9yZSgpXG5cbiAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiXG4gICAgICAgY3R4LmZpbGxUZXh0KHRoaXMubWluX2lucHV0LnRvRml4ZWQoMiksIDEwLCBwb3NZK3dpZHRoKzEyKVxuICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm1heF9pbnB1dC50b0ZpeGVkKDIpLCAxMCt3aWR0aC1jdHgubWVhc3VyZVRleHQodGhpcy5tYXhfaW5wdXQudG9GaXhlZCgyKSkud2lkdGgsIHBvc1krd2lkdGgrMTIpXG4gICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfaWQgPj0gMCl7XG4gICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIm9yYW5nZVwiXG4gICAgICAgICAgIGNvbnN0IHRleHQgPSBcIihcIiArIHRoaXMudmFsdWUubG9jYXRpb25zW3RoaXMuc2VsZWN0ZWRfaWRdLnRvRml4ZWQoMikgKyBcIiwgXCIgKyB0aGlzLnZhbHVlLnZhbHVlc1t0aGlzLnNlbGVjdGVkX2lkXSgwKS50b0ZpeGVkKDIpICsgXCIpXCJcbiAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIDEwK3dpZHRoLzItY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoLzIsIHBvc1krd2lkdGgrMTIpXG4gICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcG9zVG9JbnB1dChwb3M6IG51bWJlciwgd2lkdGg6IG51bWJlcil7XG4gICAgICAgIHJldHVybiAocG9zIC0gMTApL3dpZHRoICogKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpICsgdGhpcy5taW5faW5wdXRcbiAgICB9IFxuXG4gICAgcHJpdmF0ZSBpbnB1dFRvUG9zKGlucHV0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpe1xuICAgICAgICByZXR1cm4gKGlucHV0IC0gdGhpcy5taW5faW5wdXQpIC8gKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpICogd2lkdGggKyAxMFxuICAgIH0gXG5cbiAgICBwcml2YXRlIHBvc1RvT3V0cHV0KHBvczogbnVtYmVyLCB3aWR0aDogbnVtYmVyKXtcbiAgICAgICAgcmV0dXJuICgxIC0gKChwb3MgLSB0aGlzLndpZGdldF9wb3N5KSAvd2lkdGgpKSAqICh0aGlzLm1heF92YWx1ZSAtIHRoaXMubWluX3ZhbHVlKSArIHRoaXMubWluX3ZhbHVlXG4gICAgfSBcblxuICAgIHByaXZhdGUgb3V0cHV0VG9Qb3Mob3V0cHV0OiBudW1iZXIsIGhlaWdodDogbnVtYmVyKXtcbiAgICAgICAgcmV0dXJuICgxIC0gKChvdXRwdXQgLSB0aGlzLm1pbl92YWx1ZSkgLyAodGhpcy5tYXhfdmFsdWUgLSB0aGlzLm1pbl92YWx1ZSkpKSAqIGhlaWdodCArIHRoaXMud2lkZ2V0X3Bvc3lcbiAgICB9XG5cbiAgICBtb3VzZShldmVudDogTW91c2VFdmVudCwgcG9zOiBWZWN0b3IyLCBub2RlOiBMR3JhcGhOb2RlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlZG93blwiKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaTx0aGlzLnZhbHVlLmxvY2F0aW9ucy5sZW5ndGggOyBpKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3ModGhpcy52YWx1ZS5sb2NhdGlvbnNbaV0sIHRoaXMud2lkZ2VkX3dpZHRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLm91dHB1dFRvUG9zKHRoaXMudmFsdWUudmFsdWVzW2ldKDApLCB0aGlzLndpZGdlZF93aWR0aClcblxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAoeCAtIHBvc1swXSkqKHggLSBwb3NbMF0pICsgKHkgLSBwb3NbMV0pKih5IC0gcG9zWzFdKVxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDEwMCl7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX2lkID09IGkgJiYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0X2NsaWNrX3RpbWUpPCA1MDAgJiYgdGhpcy52YWx1ZS5sb2NhdGlvbnMubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9ucy5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudmFsdWVzLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXJpdmF0aXZlcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfaWQgPSAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9pZCA9IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfaWQgPSBpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2lkID0gaVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19kZXJpdmF0aXZlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdF9jbGlja190aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNocmluaygpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAxMDAwICYmIGkgPT0gdGhpcy5zZWxlY3RlZF9pZCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2YXRpdmUgPSB0aGlzLnZhbHVlLmRlcml2YXRpdmVzW2ldICogKHRoaXMubWF4X2lucHV0IC0gdGhpcy5taW5faW5wdXQpIC8gKHRoaXMubWF4X3ZhbHVlIC0gdGhpcy5taW5fdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlX2FuZ2xlID0gTWF0aC5hdGFuKCh5IC0gcG9zWzFdKS8gKC14ICsgcG9zWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVyaXZhdGl2ZV9hbmdsZSA9IE1hdGguYXRhbihkZXJpdmF0aXZlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobW91c2VfYW5nbGUgLSBkZXJpdmF0aXZlX2FuZ2xlKTwwLjEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19pZCA9IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfZGVyaXZhdGl2ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNocmluaygpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnBvc1RvSW5wdXQocG9zWzBdLCB0aGlzLndpZGdlZF93aWR0aClcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wb3NUb091dHB1dChwb3NbMV0sIHRoaXMud2lkZ2VkX3dpZHRoKVxuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5vdXRwdXRUb1Bvcyh0aGlzLnZhbHVlLmFwcGx5KGxvY2F0aW9uKSwgdGhpcy53aWRnZWRfd2lkdGgpIC0gcG9zWzFdKSA8IDEwKXtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnZhbHVlLmxvY2F0aW9ucy5maW5kSW5kZXgoKGxvYykgPT4gbG9jID4gbG9jYXRpb24pXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnZhbHVlLmxvY2F0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9ucy5zcGxpY2UoaW5kZXgsIDAsIGxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudmFsdWVzLnNwbGljZShpbmRleCwgMCwgKCkgPT4gdmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXJpdmF0aXZlcy5zcGxpY2UoaW5kZXgsIDAsIDApXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19pZCA9IGluZGV4XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9pZCA9IGluZGV4XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19kZXJpdmF0aXZlID0gZmFsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTaHJpbmsoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSAgIFxuXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2lkID0gLTFcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaWQgPSAtMVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgJiYgdGhpcy5kcmFnZ2luZ19pZCA+PSAwKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nX2Rlcml2YXRpdmUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmlucHV0VG9Qb3ModGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0sIHRoaXMud2lkZ2VkX3dpZHRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLm91dHB1dFRvUG9zKHRoaXMudmFsdWUudmFsdWVzW3RoaXMuZHJhZ2dpbmdfaWRdKDApLCB0aGlzLndpZGdlZF93aWR0aClcblxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSAoeSAtIHBvc1sxXSkvICgteCArIHBvc1swXSkgLyAodGhpcy5tYXhfaW5wdXQgLSB0aGlzLm1pbl9pbnB1dCkgKiAodGhpcy5tYXhfdmFsdWUgLSB0aGlzLm1pbl92YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc1swXSA8IDApe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RXhwYW5kKFwibGVmdFwiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zWzBdID4gdGhpcy53aWRnZWRfd2lkdGggKyAyMCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFeHBhbmQoXCJyaWdodFwiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEV4cGFuZCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBNYXRoLmNsYW1wKHRoaXMucG9zVG9JbnB1dChwb3NbMF0sIHRoaXMud2lkZ2VkX3dpZHRoKSwgdGhpcy5taW5faW5wdXQsIHRoaXMubWF4X2lucHV0KVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gTWF0aC5jbGFtcCh0aGlzLnBvc1RvT3V0cHV0KHBvc1sxXSwgdGhpcy53aWRnZWRfd2lkdGgpLCB0aGlzLm1pbl92YWx1ZSwgdGhpcy5tYXhfdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgZGVyaXZhdGl2ZSA9IHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF1cblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmRyYWdnaW5nX2lkID4gMCAmJiBsb2NhdGlvbiA8IHRoaXMudmFsdWUubG9jYXRpb25zW3RoaXMuZHJhZ2dpbmdfaWQtMV0pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkXSA9IHRoaXMudmFsdWUubG9jYXRpb25zW3RoaXMuZHJhZ2dpbmdfaWQtMV1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXJpdmF0aXZlc1t0aGlzLmRyYWdnaW5nX2lkXSA9IHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZC0xXVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnZhbHVlc1t0aGlzLmRyYWdnaW5nX2lkXSA9IHRoaXMudmFsdWUudmFsdWVzW3RoaXMuZHJhZ2dpbmdfaWQtMV1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19pZC0tXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaWQtLVxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5kcmFnZ2luZ19pZCA8IHRoaXMudmFsdWUubG9jYXRpb25zLmxlbmd0aCAtIDEgJiYgbG9jYXRpb24gPiB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkKzFdKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkKzFdXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLnZhbHVlLmRlcml2YXRpdmVzW3RoaXMuZHJhZ2dpbmdfaWQrMV1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS52YWx1ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLnZhbHVlLnZhbHVlc1t0aGlzLmRyYWdnaW5nX2lkKzFdXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfaWQrK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2lkKytcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLmRyYWdnaW5nX2lkXSA9IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS52YWx1ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSAoKSA9PiB2YWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVyaXZhdGl2ZXNbdGhpcy5kcmFnZ2luZ19pZF0gPSBkZXJpdmF0aXZlXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2V1cFwiKXtcbiAgICAgICAgICAgIHRoaXMuc3RvcEV4cGFuZCgpXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2lkID0gLTFcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaHJpbmsoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29tcHV0ZVNpemUod2lkdGg6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICByZXR1cm4gW3dpZHRoLCB3aWR0aC0yMCsxNV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRfdGltZXI6IE5vZGVKUy5UaW1lciA9IHVuZGVmaW5lZFxuICAgIHByaXZhdGUgc3RhcnRFeHBhbmQoZGlyZWN0aW9uOiBcImxlZnRcInxcInJpZ2h0XCIpe1xuICAgICAgICBpZiAoIXRoaXMuZXhwYW5kX3RpbWVyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZF90aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5faW5wdXQgLT0gMC4wMlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLm1pbl9pbnB1dFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhfaW5wdXQgKz0gMC4wMlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbnNbdGhpcy5kcmFnZ2luZ19pZF0gPSB0aGlzLm1heF9pbnB1dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZT8uc2V0RGlydHlDYW52YXModHJ1ZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfSwgMjApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0b3BFeHBhbmQoKXtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kX3RpbWVyKXtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5leHBhbmRfdGltZXIpXG4gICAgICAgICAgICB0aGlzLmV4cGFuZF90aW1lciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaHJpbmtfdGltZXI6IE5vZGVKUy5UaW1lciA9IHVuZGVmaW5lZFxuICAgIHByaXZhdGUgc3RhcnRTaHJpbmsoKXtcbiAgICAgICAgaWYgKCF0aGlzLnNocmlua190aW1lcil7XG4gICAgICAgICAgICB0aGlzLnNocmlua190aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluX2lucHV0IDwgdGhpcy52YWx1ZS5sb2NhdGlvbnNbMF0tMC4zKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5faW5wdXQgKz0gMC4wMlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhfaW5wdXQgPiB0aGlzLnZhbHVlLmxvY2F0aW9uc1t0aGlzLnZhbHVlLmxvY2F0aW9ucy5sZW5ndGggLSAxXSswLjMpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heF9pbnB1dCAtPSAwLjAyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNocmluaygpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlPy5zZXREaXJ0eUNhbnZhcyh0cnVlLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RvcFNocmluaygpe1xuICAgICAgICBpZiAodGhpcy5zaHJpbmtfdGltZXIpe1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNocmlua190aW1lcilcbiAgICAgICAgICAgIHRoaXMuc2hyaW5rX3RpbWVyID0gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9XG59IiwiXG4vKiEgcGFrbyAyLjAuNCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28gQGxpY2Vuc2UgKE1JVCBBTkQgWmxpYikgKi9cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQkMSAgICAgICAgICAgICAgID0gNDtcbi8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbmNvbnN0IFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG5jb25zdCBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbmNvbnN0IFpfVU5LTk9XTiQxICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvJDEoYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIJDEgICAgPSAzO1xuY29uc3QgTUFYX01BVENIJDEgICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbmNvbnN0IExFTkdUSF9DT0RFUyQxICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG5jb25zdCBMX0NPREVTJDEgICAgICAgPSBMSVRFUkFMUyQxICsgMSArIExFTkdUSF9DT0RFUyQxO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IERfQ09ERVMkMSAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbmNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSQxICAgICA9IDIgKiBMX0NPREVTJDEgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxuY29uc3QgTUFYX0JJVFMkMSAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTJDEgKyAyKSAqIDIpO1xuemVybyQxKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbmNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxICogMik7XG56ZXJvJDEoc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxuY29uc3QgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8kMShfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbmNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIJDEgLSBNSU5fTUFUQ0gkMSArIDEpO1xuemVybyQxKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTJDEpO1xuemVybyQxKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxKTtcbnplcm8kMShiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICBjb25zdCBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICBjb25zdCBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICBjb25zdCBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICBsZXQgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgbGV0IG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIGxldCB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICBsZXQgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICBsZXQgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRSQxOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuY29uc3QgZ2VuX2NvZGVzID0gKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgPT5cbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgY29uc3QgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTJDEgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgbGV0IGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgbGV0IGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmNvbnN0IHRyX3N0YXRpY19pbml0ID0gKCkgPT4ge1xuXG4gIGxldCBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgbGV0IGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIGxldCBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyQxIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTJDE7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMkMSArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMkMSArIDEsIExfQ09ERVMkMSwgTUFYX0JJVFMkMSk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUyQxLCBNQVhfQklUUyQxKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMkMSwgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuY29uc3QgaW5pdF9ibG9jayA9IChzKSA9PiB7XG5cbiAgbGV0IG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUyQxOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUyQxOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5jb25zdCBiaV93aW5kdXAgPSAocykgPT5cbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuY29uc3QgY29weV9ibG9jayA9IChzLCBidWYsIGxlbiwgaGVhZGVyKSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgcy5wZW5kaW5nX2J1Zi5zZXQocy53aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmNvbnN0IHNtYWxsZXIgPSAodHJlZSwgbiwgbSwgZGVwdGgpID0+IHtcblxuICBjb25zdCBfbjIgPSBuICogMjtcbiAgY29uc3QgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5jb25zdCBwcWRvd25oZWFwID0gKHMsIHRyZWUsIGspID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIGNvbnN0IHYgPSBzLmhlYXBba107XG4gIGxldCBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn07XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gY29uc3QgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5jb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgbGV0IGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICBsZXQgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgbGV0IGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTJDEgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuY29uc3QgYnVpbGRfdHJlZSA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgbGV0IG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIGxldCBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkUkMTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5jb25zdCBzZW5kX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5jb25zdCBidWlsZF9ibF90cmVlID0gKHMpID0+IHtcblxuICBsZXQgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMkMSAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmNvbnN0IHNlbmRfYWxsX3RyZWVzID0gKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgbGV0IHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuY29uc3QgZGV0ZWN0X2RhdGFfdHlwZSA9IChzKSA9PiB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgbGV0IGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICBsZXQgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUyQxOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59O1xuXG5cbmxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5jb25zdCBfdHJfaW5pdCQxID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayQxID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmNvbnN0IF90cl9hbGlnbiQxID0gKHMpID0+IHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmNvbnN0IF90cl9mbHVzaF9ibG9jayQxID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIGxldCBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTiQxKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEJDEgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkkMSA9IChzLCBkaXN0LCBsYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL2xldCBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTJDEgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufTtcblxudmFyIF90cl9pbml0XzEgID0gX3RyX2luaXQkMTtcbnZhciBfdHJfc3RvcmVkX2Jsb2NrXzEgPSBfdHJfc3RvcmVkX2Jsb2NrJDE7XG52YXIgX3RyX2ZsdXNoX2Jsb2NrXzEgID0gX3RyX2ZsdXNoX2Jsb2NrJDE7XG52YXIgX3RyX3RhbGx5XzEgPSBfdHJfdGFsbHkkMTtcbnZhciBfdHJfYWxpZ25fMSA9IF90cl9hbGlnbiQxO1xuXG52YXIgdHJlZXMgPSB7XG5cdF90cl9pbml0OiBfdHJfaW5pdF8xLFxuXHRfdHJfc3RvcmVkX2Jsb2NrOiBfdHJfc3RvcmVkX2Jsb2NrXzEsXG5cdF90cl9mbHVzaF9ibG9jazogX3RyX2ZsdXNoX2Jsb2NrXzEsXG5cdF90cl90YWxseTogX3RyX3RhbGx5XzEsXG5cdF90cl9hbGlnbjogX3RyX2FsaWduXzFcbn07XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IGFkbGVyMzIgPSAoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgbGV0IHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn07XG5cblxudmFyIGFkbGVyMzJfMSA9IGFkbGVyMzI7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuY29uc3QgbWFrZVRhYmxlID0gKCkgPT4ge1xuICBsZXQgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn07XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG5jb25zdCBjcmNUYWJsZSA9IG5ldyBVaW50MzJBcnJheShtYWtlVGFibGUoKSk7XG5cblxuY29uc3QgY3JjMzIgPSAoY3JjLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGNvbnN0IHQgPSBjcmNUYWJsZTtcbiAgY29uc3QgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufTtcblxuXG52YXIgY3JjMzJfMSA9IGNyYzMyO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIGNvbnN0YW50cyQyID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIFpfTUVNX0VSUk9SOiAgICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCB7IF90cl9pbml0LCBfdHJfc3RvcmVkX2Jsb2NrLCBfdHJfZmx1c2hfYmxvY2ssIF90cl90YWxseSwgX3RyX2FsaWduIH0gPSB0cmVlcztcblxuXG5cblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSDogWl9OT19GTFVTSCQyLCBaX1BBUlRJQUxfRkxVU0gsIFpfRlVMTF9GTFVTSDogWl9GVUxMX0ZMVVNIJDEsIFpfRklOSVNIOiBaX0ZJTklTSCQzLCBaX0JMT0NLOiBaX0JMT0NLJDEsXG4gIFpfT0s6IFpfT0skMywgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMywgWl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SJDIsIFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SJDIsIFpfQlVGX0VSUk9SOiBaX0JVRl9FUlJPUiQxLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxLFxuICBaX0ZJTFRFUkVELCBaX0hVRkZNQU5fT05MWSwgWl9STEUsIFpfRklYRUQsIFpfREVGQVVMVF9TVFJBVEVHWTogWl9ERUZBVUxUX1NUUkFURUdZJDEsXG4gIFpfVU5LTk9XTixcbiAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQyXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbmNvbnN0IE1BWF9XQklUUyQxID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbmNvbnN0IExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5jb25zdCBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuY29uc3QgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgTUlOX01BVENIID0gMztcbmNvbnN0IE1BWF9NQVRDSCA9IDI1ODtcbmNvbnN0IE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbmNvbnN0IFBSRVNFVF9ESUNUID0gMHgyMDtcblxuY29uc3QgSU5JVF9TVEFURSA9IDQyO1xuY29uc3QgRVhUUkFfU1RBVEUgPSA2OTtcbmNvbnN0IE5BTUVfU1RBVEUgPSA3MztcbmNvbnN0IENPTU1FTlRfU1RBVEUgPSA5MTtcbmNvbnN0IEhDUkNfU1RBVEUgPSAxMDM7XG5jb25zdCBCVVNZX1NUQVRFID0gMTEzO1xuY29uc3QgRklOSVNIX1NUQVRFID0gNjY2O1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn07XG5cbmNvbnN0IHplcm8gPSAoYnVmKSA9PiB7XG4gIGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH1cbn07XG5cblxuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xubGV0IEhBU0hfWkxJQiA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgcy5oYXNoX3NoaWZ0KSBeIGRhdGEpICYgcy5oYXNoX21hc2s7XG4vLyBUaGlzIGhhc2ggY2F1c2VzIGxlc3MgY29sbGlzaW9ucywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2lzc3Vlcy8xMzVcbi8vIEJ1dCBicmVha3MgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vbGV0IEhBU0hfRkFTVCA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgOCkgKyAocHJldiA+PiA4KSArIChkYXRhIDw8IDQpKSAmIHMuaGFzaF9tYXNrO1xubGV0IEhBU0ggPSBIQVNIX1pMSUI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmNvbnN0IGZsdXNoX3BlbmRpbmcgPSAoc3RybSkgPT4ge1xuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICBsZXQgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHN0cm0ub3V0cHV0LnNldChzLnBlbmRpbmdfYnVmLnN1YmFycmF5KHMucGVuZGluZ19vdXQsIHMucGVuZGluZ19vdXQgKyBsZW4pLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59O1xuXG5cbmNvbnN0IGZsdXNoX2Jsb2NrX29ubHkgPSAocywgbGFzdCkgPT4ge1xuICBfdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn07XG5cblxuY29uc3QgcHV0X2J5dGUgPSAocywgYikgPT4ge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuY29uc3QgcHV0U2hvcnRNU0IgPSAocywgYikgPT4ge1xuXG4gIC8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5jb25zdCByZWFkX2J1ZiA9IChzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSA9PiB7XG5cbiAgbGV0IGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIGJ1Zi5zZXQoc3RybS5pbnB1dC5zdWJhcnJheShzdHJtLm5leHRfaW4sIHN0cm0ubmV4dF9pbiArIGxlbiksIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyXzEoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmNvbnN0IGxvbmdlc3RfbWF0Y2ggPSAocywgY3VyX21hdGNoKSA9PiB7XG5cbiAgbGV0IGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgbGV0IHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIGxldCBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgbGV0IG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgY29uc3QgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgY29uc3Qgd21hc2sgPSBzLndfbWFzaztcbiAgY29uc3QgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgY29uc3Qgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgbGV0IHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICBsZXQgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuY29uc3QgZmlsbF93aW5kb3cgPSAocykgPT4ge1xuXG4gIGNvbnN0IF93X3NpemUgPSBzLndfc2l6ZTtcbiAgbGV0IHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KF93X3NpemUsIF93X3NpemUgKyBfd19zaXplKSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIGNvbnN0IGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICBsZXQgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IGRlZmxhdGVfc3RvcmVkID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICBsZXQgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgY29uc3QgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuY29uc3QgZGVmbGF0ZV9mYXN0ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmNvbnN0IGRlZmxhdGVfc2xvdyA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgbGV0IG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5jb25zdCBkZWZsYXRlX3JsZSA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgbGV0IHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfaHVmZiA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcblxuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxuY29uc3QgY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5jb25zdCBsbV9pbml0ID0gKHMpID0+IHtcblxuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufTtcblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQkMjsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IFVpbnQxNkFycmF5KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmNvbnN0IGRlZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIJDI7XG4gIF90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGNvbnN0IHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0skMykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZVNldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQyOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlSW5pdDIgPSAoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSkge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEJDIgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgVWludDE2QXJyYXkocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgVWludDE2QXJyYXkocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuY29uc3QgZGVmbGF0ZUluaXQgPSAoc3RybSwgbGV2ZWwpID0+IHtcblxuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVEJDIsIE1BWF9XQklUUyQxLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kkMSk7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGUkMiA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0skMSB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKSA6IFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCQzKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SJDEgOiBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICBsZXQgaGVhZGVyID0gKFpfREVGTEFURUQkMiArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIGxldCBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIJDMpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SJDEpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IkMSk7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCQyICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICBfdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSyQxKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gkMSkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCQzKSB7IHJldHVybiBaX09LJDM7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQkMzsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LJDMgOiBaX1NUUkVBTV9FTkQkMztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUiQyKSA6IFpfT0skMztcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5jb25zdCBkZWZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG5cbiAgbGV0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGNvbnN0IHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgbGV0IHRtcERpY3QgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSk7XG4gICAgdG1wRGljdC5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShkaWN0TGVuZ3RoIC0gcy53X3NpemUsIGRpY3RMZW5ndGgpLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgY29uc3QgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBjb25zdCBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBjb25zdCBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBsZXQgc3RyID0gcy5zdHJzdGFydDtcbiAgICBsZXQgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG52YXIgZGVmbGF0ZUluaXRfMSA9IGRlZmxhdGVJbml0O1xudmFyIGRlZmxhdGVJbml0Ml8xID0gZGVmbGF0ZUluaXQyO1xudmFyIGRlZmxhdGVSZXNldF8xID0gZGVmbGF0ZVJlc2V0O1xudmFyIGRlZmxhdGVSZXNldEtlZXBfMSA9IGRlZmxhdGVSZXNldEtlZXA7XG52YXIgZGVmbGF0ZVNldEhlYWRlcl8xID0gZGVmbGF0ZVNldEhlYWRlcjtcbnZhciBkZWZsYXRlXzIkMSA9IGRlZmxhdGUkMjtcbnZhciBkZWZsYXRlRW5kXzEgPSBkZWZsYXRlRW5kO1xudmFyIGRlZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbnZhciBkZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG5cbnZhciBkZWZsYXRlXzEkMiA9IHtcblx0ZGVmbGF0ZUluaXQ6IGRlZmxhdGVJbml0XzEsXG5cdGRlZmxhdGVJbml0MjogZGVmbGF0ZUluaXQyXzEsXG5cdGRlZmxhdGVSZXNldDogZGVmbGF0ZVJlc2V0XzEsXG5cdGRlZmxhdGVSZXNldEtlZXA6IGRlZmxhdGVSZXNldEtlZXBfMSxcblx0ZGVmbGF0ZVNldEhlYWRlcjogZGVmbGF0ZVNldEhlYWRlcl8xLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzIkMSxcblx0ZGVmbGF0ZUVuZDogZGVmbGF0ZUVuZF8xLFxuXHRkZWZsYXRlU2V0RGljdGlvbmFyeTogZGVmbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0ZGVmbGF0ZUluZm86IGRlZmxhdGVJbmZvXG59O1xuXG5jb25zdCBfaGFzID0gKG9iaiwga2V5KSA9PiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbnZhciBmbGF0dGVuQ2h1bmtzID0gKGNodW5rcykgPT4ge1xuICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgbGV0IGxlbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gIH1cblxuICAvLyBqb2luIGNodW5rc1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNvbW1vbiA9IHtcblx0YXNzaWduOiBhc3NpZ24sXG5cdGZsYXR0ZW5DaHVua3M6IGZsYXR0ZW5DaHVua3Ncbn07XG5cbi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG5sZXQgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbmNvbnN0IF91dGY4bGVuID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAobGV0IHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IChzdHIpID0+IHtcbiAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyAmJiBUZXh0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICB9XG5cbiAgbGV0IGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXJcbmNvbnN0IGJ1ZjJiaW5zdHJpbmcgPSAoYnVmLCBsZW4pID0+IHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zi5sZW5ndGggPT09IGxlbiA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG52YXIgYnVmMnN0cmluZyA9IChidWYsIG1heCkgPT4ge1xuICBjb25zdCBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIFRleHREZWNvZGVyID09PSAnZnVuY3Rpb24nICYmIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1Zi5zdWJhcnJheSgwLCBtYXgpKTtcbiAgfVxuXG4gIGxldCBpLCBvdXQ7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgY29uc3QgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGxldCBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IChidWYsIG1heCkgPT4ge1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIGxldCBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG52YXIgc3RyaW5ncyA9IHtcblx0c3RyaW5nMmJ1Zjogc3RyaW5nMmJ1Zixcblx0YnVmMnN0cmluZzogYnVmMnN0cmluZyxcblx0dXRmOGJvcmRlcjogdXRmOGJvcmRlclxufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG52YXIgenN0cmVhbSA9IFpTdHJlYW07XG5cbmNvbnN0IHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDEsIFpfU1lOQ19GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSDogWl9GSU5JU0gkMixcbiAgWl9PSzogWl9PSyQyLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQyLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gIFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQxXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlJDEob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBjb21tb24uYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCQxLFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWVxuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBsZXQgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LJDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIGRlZmxhdGVfMSQyLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIGxldCBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmckMS5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LJDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0XG4gKiBoYXZlIGBmbHVzaF9tb2RlYCBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmdcbiAqIGJ1ZmZlcnMgYW5kIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0uXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUkMS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCQyIDogWl9OT19GTFVTSCQxO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXZhaWxfb3V0ID4gNiB0byBhdm9pZCByZXBlYXRpbmcgbWFya2Vyc1xuICAgIGlmICgoX2ZsdXNoX21vZGUgPT09IFpfU1lOQ19GTFVTSCB8fCBfZmx1c2hfbW9kZSA9PT0gWl9GVUxMX0ZMVVNIKSAmJiBzdHJtLmF2YWlsX291dCA8PSA2KSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2hcbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMikge1xuICAgICAgaWYgKHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSyQyO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIG91dCBidWZmZXIgZnVsbFxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgcmVxdWVzdGVkIGFuZCBoYXMgZGF0YVxuICAgIGlmIChfZmx1c2hfbW9kZSA+IDAgJiYgc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5KTogb3V0cHV0IGRhdGEuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlJDEucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZSQxLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSyQyKSB7XG4gICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBkZWZsYXRvciA9IG5ldyBEZWZsYXRlJDEob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbWVzc2FnZXNbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3JDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAkMShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxudmFyIERlZmxhdGVfMSQxID0gRGVmbGF0ZSQxO1xudmFyIGRlZmxhdGVfMiA9IGRlZmxhdGUkMTtcbnZhciBkZWZsYXRlUmF3XzEkMSA9IGRlZmxhdGVSYXckMTtcbnZhciBnemlwXzEkMSA9IGd6aXAkMTtcbnZhciBjb25zdGFudHMkMSA9IGNvbnN0YW50cyQyO1xuXG52YXIgZGVmbGF0ZV8xJDEgPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSQxLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzIsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSQxLFxuXHRnemlwOiBnemlwXzEkMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHMkMVxufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbmNvbnN0IEJBRCQxID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0IFRZUEUkMSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xudmFyIGluZmZhc3QgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgbGV0IF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICBsZXQgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgbGV0IGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgbGV0IHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICBsZXQgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICBsZXQgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIGxldCBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIGxldCBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgbGV0IGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgbGV0IGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICBsZXQgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgbGV0IGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICBsZXQgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgbGV0IGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuXG5cbiAgbGV0IGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgTUFYQklUUyA9IDE1O1xuY29uc3QgRU5PVUdIX0xFTlMkMSA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyQxID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgQ09ERVMkMSA9IDA7XG5jb25zdCBMRU5TJDEgPSAxO1xuY29uc3QgRElTVFMkMSA9IDI7XG5cbmNvbnN0IGxiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl0pO1xuXG5jb25zdCBsZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl0pO1xuXG5jb25zdCBkYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl0pO1xuXG5jb25zdCBkZXh0ID0gbmV3IFVpbnQ4QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl0pO1xuXG5jb25zdCBpbmZsYXRlX3RhYmxlID0gKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpID0+XG57XG4gIGNvbnN0IGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIGxldCBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIGxldCBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICBsZXQgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgbGV0IHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgbGV0IGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgbGV0IGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICBsZXQgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIGxldCB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIGxldCBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICBsZXQgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgbGV0IGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICBsZXQgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgbGV0IG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICBsZXQgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgYmFzZV9pbmRleCA9IDA7XG4vLyAgbGV0IHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgY29uc3QgY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgY29uc3Qgb2ZmcyA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICBsZXQgZXh0cmEgPSBudWxsO1xuICBsZXQgZXh0cmFfaW5kZXggPSAwO1xuXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyQxIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUyQxKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TJDEpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TJDEgJiYgdXNlZCA+IEVOT1VHSF9MRU5TJDEpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTJDEgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUyQxKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TJDEgJiYgdXNlZCA+IEVOT1VHSF9MRU5TJDEpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG5cblxudmFyIGluZnRyZWVzID0gaW5mbGF0ZV90YWJsZTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5cblxuXG5cblxuY29uc3QgQ09ERVMgPSAwO1xuY29uc3QgTEVOUyA9IDE7XG5jb25zdCBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfRklOSVNIOiBaX0ZJTklTSCQxLCBaX0JMT0NLLCBaX1RSRUVTLFxuICBaX09LOiBaX09LJDEsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDEsIFpfTkVFRF9ESUNUOiBaX05FRURfRElDVCQxLCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMSwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMSwgWl9NRU1fRVJST1I6IFpfTUVNX0VSUk9SJDEsIFpfQlVGX0VSUk9SLFxuICBaX0RFRkxBVEVEXG59ID0gY29uc3RhbnRzJDI7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG5jb25zdCAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG5jb25zdCAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xuY29uc3QgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG5jb25zdCAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbmNvbnN0ICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG5jb25zdCAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbmNvbnN0ICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xuY29uc3QgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xuY29uc3QgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xuY29uc3QgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbmNvbnN0ICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG5jb25zdCAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG5jb25zdCAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG5jb25zdCAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbmNvbnN0ICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG5jb25zdCAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxuY29uc3QgRU5PVUdIX0xFTlMgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxuY29uc3QgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5jb25zdCB6c3dhcDMyID0gKHEpID0+IHtcblxuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn07XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IFVpbnQxNkFycmF5KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSyQxO1xufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuICBsZXQgd3JhcDtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBjb25zdCBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSyQxKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0ID0gKHN0cm0pID0+IHtcblxuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59O1xuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbmxldCB2aXJnaW4gPSB0cnVlO1xuXG5sZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5cbmNvbnN0IGZpeGVkdGFibGVzID0gKHN0YXRlKSA9PiB7XG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIGxlbmZpeCA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyBJbnQzMkFycmF5KDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgbGV0IHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZnRyZWVzKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mdHJlZXMoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59O1xuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5jb25zdCB1cGRhdGV3aW5kb3cgPSAoc3RybSwgc3JjLCBlbmQsIGNvcHkpID0+IHtcblxuICBsZXQgZGlzdDtcbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gc3RhdGUud3NpemUsIGVuZCksIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQgLSBjb3B5ICsgZGlzdCksIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGUkMiA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LJDE7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICEhISBwYWtvIHBhdGNoLiBGb3JjZSB1c2UgYG9wdGlvbnMud2luZG93Qml0c2AgaWYgcGFzc2VkLlxuICAgICAgICAvLyBSZXF1aXJlZCB0byBhbHdheXMgdXNlIG1heCB3aW5kb3cgc2l6ZSBieSBkZWZhdWx0LlxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICAgICAgLy9zdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG5cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYS5zZXQoXG4gICAgICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICAgIG5leHQgKyBjb3B5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUJDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQkMTtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQxKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCQxKSAmJiByZXQgPT09IFpfT0skMSkge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICBsZXQgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUdldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSyQxO1xufTtcblxuXG5jb25zdCBpbmZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG4gIGNvbnN0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBsZXQgc3RhdGU7XG4gIGxldCBkaWN0aWQ7XG4gIGxldCByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyXzEoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUiQxO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbnZhciBpbmZsYXRlUmVzZXRfMSA9IGluZmxhdGVSZXNldDtcbnZhciBpbmZsYXRlUmVzZXQyXzEgPSBpbmZsYXRlUmVzZXQyO1xudmFyIGluZmxhdGVSZXNldEtlZXBfMSA9IGluZmxhdGVSZXNldEtlZXA7XG52YXIgaW5mbGF0ZUluaXRfMSA9IGluZmxhdGVJbml0O1xudmFyIGluZmxhdGVJbml0Ml8xID0gaW5mbGF0ZUluaXQyO1xudmFyIGluZmxhdGVfMiQxID0gaW5mbGF0ZSQyO1xudmFyIGluZmxhdGVFbmRfMSA9IGluZmxhdGVFbmQ7XG52YXIgaW5mbGF0ZUdldEhlYWRlcl8xID0gaW5mbGF0ZUdldEhlYWRlcjtcbnZhciBpbmZsYXRlU2V0RGljdGlvbmFyeV8xID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuXG52YXIgaW5mbGF0ZV8xJDIgPSB7XG5cdGluZmxhdGVSZXNldDogaW5mbGF0ZVJlc2V0XzEsXG5cdGluZmxhdGVSZXNldDI6IGluZmxhdGVSZXNldDJfMSxcblx0aW5mbGF0ZVJlc2V0S2VlcDogaW5mbGF0ZVJlc2V0S2VlcF8xLFxuXHRpbmZsYXRlSW5pdDogaW5mbGF0ZUluaXRfMSxcblx0aW5mbGF0ZUluaXQyOiBpbmZsYXRlSW5pdDJfMSxcblx0aW5mbGF0ZTogaW5mbGF0ZV8yJDEsXG5cdGluZmxhdGVFbmQ6IGluZmxhdGVFbmRfMSxcblx0aW5mbGF0ZUdldEhlYWRlcjogaW5mbGF0ZUdldEhlYWRlcl8xLFxuXHRpbmZsYXRlU2V0RGljdGlvbmFyeTogaW5mbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0aW5mbGF0ZUluZm86IGluZmxhdGVJbmZvXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG52YXIgZ3poZWFkZXIgPSBHWmhlYWRlcjtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNILCBaX0ZJTklTSCxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX05FRURfRElDVCwgWl9TVFJFQU1fRVJST1IsIFpfREFUQV9FUlJPUiwgWl9NRU1fRVJST1Jcbn0gPSBjb25zdGFudHMkMjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlJDEob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBjb21tb24uYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDEwMjQgKiA2NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgY29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyAgPSBpbmZsYXRlXzEkMi5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IGd6aGVhZGVyKCk7XG5cbiAgaW5mbGF0ZV8xJDIuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGFcbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRVxuICogICBmbHVzaCBtb2Rlcy4gU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsXG4gKiAgIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIElmIGVuZCBvZiBzdHJlYW0gZGV0ZWN0ZWQsXG4gKiBbW0luZmxhdGUjb25FbmRdXSB3aWxsIGJlIGNhbGxlZC5cbiAqXG4gKiBgZmx1c2hfbW9kZWAgaXMgbm90IG5lZWRlZCBmb3Igbm9ybWFsIG9wZXJhdGlvbiwgYmVjYXVzZSBlbmQgb2Ygc3RyZWFtXG4gKiBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5LiBZb3UgbWF5IHRyeSB0byB1c2UgaXQgZm9yIGFkdmFuY2VkIHRoaW5ncywgYnV0XG4gKiB0aGlzIGZ1bmN0aW9uYWxpdHkgd2FzIG5vdCB0ZXN0ZWQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmbHVzaF9tb2RlKSB7XG4gIGNvbnN0IHN0cm0gPSB0aGlzLnN0cm07XG4gIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIGNvbnN0IGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGUsIGxhc3RfYXZhaWxfb3V0O1xuXG4gIGlmICh0aGlzLmVuZGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICBpZiAoc3RhdHVzID09PSBaX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBjb2RlIHdpdGggbW9yZSB2ZXJib3NlXG4gICAgICAgIHN0YXR1cyA9IFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgc255YyBtYXJrZXJzIGlmIG1vcmUgZGF0YSBmb2xsb3dzIGFuZCBub3QgcmF3IG1vZGVcbiAgICB3aGlsZSAoc3RybS5hdmFpbF9pbiA+IDAgJiZcbiAgICAgICAgICAgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQgJiZcbiAgICAgICAgICAgc3RybS5zdGF0ZS53cmFwID4gMCAmJlxuICAgICAgICAgICBkYXRhW3N0cm0ubmV4dF9pbl0gIT09IDApXG4gICAge1xuICAgICAgaW5mbGF0ZV8xJDIuaW5mbGF0ZVJlc2V0KHN0cm0pO1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgWl9TVFJFQU1fRVJST1I6XG4gICAgICBjYXNlIFpfREFUQV9FUlJPUjpcbiAgICAgIGNhc2UgWl9ORUVEX0RJQ1Q6XG4gICAgICBjYXNlIFpfTUVNX0VSUk9SOlxuICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgcmVhbCBgYXZhaWxfb3V0YCB2YWx1ZSwgYmVjYXVzZSB3ZSBtYXkgcGF0Y2ggb3V0IGJ1ZmZlciBjb250ZW50XG4gICAgLy8gdG8gYWxpZ24gdXRmOCBzdHJpbmdzIGJvdW5kYXJpZXMuXG4gICAgbGFzdF9hdmFpbF9vdXQgPSBzdHJtLmF2YWlsX291dDtcblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbGV0IG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgbGV0IHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICBsZXQgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWwgJiByZWFsaWduIGNvdW50ZXJzXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSBzdHJtLm91dHB1dC5zZXQoc3RybS5vdXRwdXQuc3ViYXJyYXkobmV4dF9vdXRfdXRmOCwgbmV4dF9vdXRfdXRmOCArIHRhaWwpLCAwKTtcblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQubGVuZ3RoID09PSBzdHJtLm5leHRfb3V0ID8gc3RybS5vdXRwdXQgOiBzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNdXN0IHJlcGVhdCBpdGVyYXRpb24gaWYgb3V0IGJ1ZmZlciBpcyBmdWxsXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9PSyAmJiBsYXN0X2F2YWlsX291dCA9PT0gMCkgY29udGludWU7XG5cbiAgICAvLyBGaW5hbGl6ZSBpZiBlbmQgb2Ygc3RyZWFtIHJlYWNoZWQuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEkMi5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBlYWNoIGNodW5rIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZSQxLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZSQxLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XG4gKiBjb25zdCBpbnB1dCA9IHBha28uZGVmbGF0ZShuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKSk7XG4gKiBsZXQgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpIHtcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGluZmxhdG9yID0gbmV3IEluZmxhdGUkMShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0KTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbWVzc2FnZXNbaW5mbGF0b3IuZXJyXTtcblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3JDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbnZhciBJbmZsYXRlXzEkMSA9IEluZmxhdGUkMTtcbnZhciBpbmZsYXRlXzIgPSBpbmZsYXRlJDE7XG52YXIgaW5mbGF0ZVJhd18xJDEgPSBpbmZsYXRlUmF3JDE7XG52YXIgdW5nemlwJDEgPSBpbmZsYXRlJDE7XG52YXIgY29uc3RhbnRzID0gY29uc3RhbnRzJDI7XG5cbnZhciBpbmZsYXRlXzEkMSA9IHtcblx0SW5mbGF0ZTogSW5mbGF0ZV8xJDEsXG5cdGluZmxhdGU6IGluZmxhdGVfMixcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xJDEsXG5cdHVuZ3ppcDogdW5nemlwJDEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzXG59O1xuXG5jb25zdCB7IERlZmxhdGUsIGRlZmxhdGUsIGRlZmxhdGVSYXcsIGd6aXAgfSA9IGRlZmxhdGVfMSQxO1xuXG5jb25zdCB7IEluZmxhdGUsIGluZmxhdGUsIGluZmxhdGVSYXcsIHVuZ3ppcCB9ID0gaW5mbGF0ZV8xJDE7XG5cblxuXG52YXIgRGVmbGF0ZV8xID0gRGVmbGF0ZTtcbnZhciBkZWZsYXRlXzEgPSBkZWZsYXRlO1xudmFyIGRlZmxhdGVSYXdfMSA9IGRlZmxhdGVSYXc7XG52YXIgZ3ppcF8xID0gZ3ppcDtcbnZhciBJbmZsYXRlXzEgPSBJbmZsYXRlO1xudmFyIGluZmxhdGVfMSA9IGluZmxhdGU7XG52YXIgaW5mbGF0ZVJhd18xID0gaW5mbGF0ZVJhdztcbnZhciB1bmd6aXBfMSA9IHVuZ3ppcDtcbnZhciBjb25zdGFudHNfMSA9IGNvbnN0YW50cyQyO1xuXG52YXIgcGFrbyA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzEsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSxcblx0Z3ppcDogZ3ppcF8xLFxuXHRJbmZsYXRlOiBJbmZsYXRlXzEsXG5cdGluZmxhdGU6IGluZmxhdGVfMSxcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xLFxuXHR1bmd6aXA6IHVuZ3ppcF8xLFxuXHRjb25zdGFudHM6IGNvbnN0YW50c18xXG59O1xuXG5leHBvcnQgeyBEZWZsYXRlXzEgYXMgRGVmbGF0ZSwgSW5mbGF0ZV8xIGFzIEluZmxhdGUsIGNvbnN0YW50c18xIGFzIGNvbnN0YW50cywgcGFrbyBhcyBkZWZhdWx0LCBkZWZsYXRlXzEgYXMgZGVmbGF0ZSwgZGVmbGF0ZVJhd18xIGFzIGRlZmxhdGVSYXcsIGd6aXBfMSBhcyBnemlwLCBpbmZsYXRlXzEgYXMgaW5mbGF0ZSwgaW5mbGF0ZVJhd18xIGFzIGluZmxhdGVSYXcsIHVuZ3ppcF8xIGFzIHVuZ3ppcCB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IExHcmFwaCwgTEdyYXBoQ2FudmFzLCBMaXRlR3JhcGggfSBmcm9tICdsaXRlZ3JhcGguanMnO1xuaW1wb3J0IHsgRGVuc2l0eUZ1bmN0aW9uT3V0cHV0IH0gZnJvbSAnLi9ub2Rlcy9kZW5zaXR5X2Z1bmN0aW9uX291dHB1dCc7XG5pbXBvcnQgeyByZWdpc3Rlck5vZGVzIH0gZnJvbSAnLi9ub2Rlcy9yZWdpc3Rlcic7XG5pbXBvcnQgeyBHcmFwaE1hbmFnZXIgfSBmcm9tICcuL1VJL0dyYXBoTWFuYWdlcic7XG5pbXBvcnQgeyBNZW51TWFuYWdlciB9IGZyb20gJy4vVUkvTWVudU1hbmFnZXInO1xuXG5vbmxvYWQgPSAoKSA9PiB7XG4gICAgTWVudU1hbmFnZXIuYWRkSGFuZGxlcnMoKVxuICAgIEdyYXBoTWFuYWdlci5pbml0KClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==